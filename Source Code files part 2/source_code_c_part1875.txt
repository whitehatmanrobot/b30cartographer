FT);
    DebugAssertion(!(flags & RIP_USERTAGBITS));

    return PrintAndPrompt(
            TEST_RIPF(aLevel[iLevel].dwPrint),
            TEST_RIPF(aLevel[iLevel].dwPrompt),
            idErr,
            flags,
            aLevel[iLevel].szLevel,
            pszFile,
            iLine,
            pszErr,
            pexi);
}

#else

ULONG _cdecl VRipOutput(
    ULONG       idErr,
    ULONG       flags,
    LPSTR       pszFile,
    int         iLine,
    LPSTR       pszFmt,
    ...)
{
    return 0;

    idErr;
    flags;
    pszFile;
    iLine;
    pszFmt;
}

#endif // if DBG

#if DEBUGTAGS

BOOL _cdecl VTagOutput(
    DWORD   flags,
    LPSTR   pszFile,
    int     iLine,
    LPSTR   pszFmt,
    ...)
{
    char    szT[512];
    va_list arglist;
    int     tag;
    DWORD   dwDBGTAGFlags;

    tag = (flags & RIP_USERTAGBITS);
    DebugAssertion(tag < DBGTAG_Max);
    DebugAssertion(!(flags & RIP_LEVELBITS));

    dwDBGTAGFlags = GetDbgTagFlags(tag) & DBGTAG_VALIDUSERFLAGS;

    if (dwDBGTAGFlags < DBGTAG_PRINT) {
        return FALSE;
    }

    va_start(arglist, pszFmt);
    _vsnprintf(szT, ARRAY_SIZE(szT) - 1, pszFmt, arglist);
    szT[ARRAY_SIZE(szT) - 1] = 0;              /* ensure null termination */
    va_end(arglist);
    return PrintAndPrompt(
            dwDBGTAGFlags >= DBGTAG_PRINT,
            dwDBGTAGFlags >= DBGTAG_PROMPT,
            0,
            flags,
            gadbgtag[tag].achName,
            pszFile,
            iLine,
            szT,
            NULL);
}

#else

BOOL _cdecl VTagOutput(
    DWORD   flags,
    LPSTR   pszFile,
    int     iLine,
    LPSTR   pszFmt,
    ...)
{
    UNREFERENCED_PARAMETER(flags);
    UNREFERENCED_PARAMETER(pszFile);
    UNREFERENCED_PARAMETER(iLine);
    UNREFERENCED_PARAMETER(pszFmt);

    return FALSE;
}

#endif  // if DEBUGTAGS

VOID UserSetLastError(
    DWORD dwErrCode
    )
{
    PTEB pteb;

#if DBG
    /*
     * Check if NT Error is directly passed to UserSetLastError.
     * Raid #320555 note: some Win32 error could be
     * 0x4000XXXX, 0x8000XXXX or 0xC000XXXX etc.,
     * but they are still valid. E.g) STATUS_SEGMENT_NOTIFICATION,
     * STATUS_GUARD_PAGE_VIOLATION, etc.
     * The mapper returns the equivalent W32 error value as NT error.
     * So we assert only if mapper routine returns the different w32 error code.
     */
    if ((dwErrCode & 0xffff0000) != 0 && RtlNtStatusToDosError(dwErrCode) != dwErrCode) {
        RIPMSG1(RIP_ERROR, "UserSetLastError: Error code passed (%08x) is not a valid Win32 error.",
                dwErrCode);
    }
#endif

    pteb = NtCurrentTeb();
    if (pteb) {
        try {
            pteb->LastErrorValue = (LONG)dwErrCode;
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
              /*
               * Nothing we can do here, as we are in UserSetLastError already...
               */
        }
    }
}

VOID SetLastNtError(
    NTSTATUS Status)
{
    UserSetLastError(RtlNtStatusToDosError(Status));
}

#if DBG
void
ValidateZero(void)
{
    static ALWAYSZERO z;
    UserAssert(RtlCompareMemory(&z, (void *) &gZero, sizeof(z)) == sizeof(z));
}
#endif // DBG


/***************************************************************************\
* W32ExceptionHandler
*
* To be called from except blocks.
*
* History:
* 07-17-98 GerardoB      Created.
\***************************************************************************/
ULONG _W32ExceptionHandler(NTSTATUS ExceptionCode)
{
    SetLastNtError(ExceptionCode);
    return EXCEPTION_EXECUTE_HANDLER;
}

#if DBG
ULONG DBGW32ExceptionHandler(PEXCEPTION_POINTERS pexi, BOOL fSetLastError, ULONG ulflags)
{
    RIPMSG5(ulflags,
            "Exception %#x at address %#p. flags:%#x. .exr %#p .cxr %#p",
            pexi->ExceptionRecord->ExceptionCode,
            CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord),
            pexi->ExceptionRecord->ExceptionFlags,
            pexi->ExceptionRecord,
            pexi->ContextRecord);

    if (fSetLastError) {
        SetLastNtError(pexi->ExceptionRecord->ExceptionCode);
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif

#if defined(PRERELEASE) || defined(USER_INSTRUMENTATION)

/*
 * UserBreakIfDebugged(): software break point that *may* also be available in FRE.
 * Fre: breaks in only if there's a debugger attached.
 * Chk: always breaks in.
 */
#if DBG
    #define UserBreakIfDebugged DbgBreakPoint
#else
    #ifdef _USERK_
        #define IS_DEBUGGER_ATTACHED    KD_DEBUGGER_ENABLED
    #else
        #define IS_DEBUGGER_ATTACHED    IsDebuggerPresent()
    #endif // _USERK_
    VOID __inline UserBreakIfDebugged(VOID)
    {
        if (IS_DEBUGGER_ATTACHED) {
            DbgBreakPoint();
        }
    }
#endif // DBG


/*
 * Called by FRE_RIPMSGx.  This is a partial implementation
 * of RIPMSGx.  In the future (Blackcomb?), we'll revisit
 * this to have the fullest support of RIP.
 */
void FreDbgPrint(ULONG flags, LPSTR pszFile, int iLine, LPSTR pszFmt, ...)
{
    static BOOL fSuppressFileLine;
    va_list arglist;

    if (!fSuppressFileLine) {
        DbgPrintEx(-1, 0, "File: %s, Line: %d\n -- ", pszFile, iLine);
    } else {
        fSuppressFileLine = FALSE;
    }

    va_start(arglist, pszFmt);
    vDbgPrintEx(-1, 0, pszFmt, arglist);
    if ((flags & RIP_NONEWLINE) != 0) {
        fSuppressFileLine = TRUE;
    } else {
        DbgPrintEx(-1, 0, "\n");
    }

    if ((flags & RIP_ERROR) != 0) {
        UserBreakIfDebugged();
    }
}

#endif  // PRERELEASE || USER_INSTRUMENTATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\syminfo\makefile.inc ===
$(O)\win32k.cpp : syminfo.cpp
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\syminfo\syminfo.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    syminfo.c

--*/

extern "C"
{
    #define __CPLUSPLUS

    // From ntgdi\gre
    #include "engine.h"
};


// From ntgdi\gre
#include "verifier.hxx"





GDIHandleBitFields  GDIHandleBitFieldsRef;
GDIObjType          GDIObjTypeRef;
GDILoObjType        GDILoObjTypeRef;

//
// Types defined in ntuser\kernel\userk.h, #include of that file causes 
// lot of missing definitions
//
#define RECORD_STACK_TRACE_SIZE 6

typedef struct tagWin32AllocStats {
    SIZE_T dwMaxMem;             // max pool memory allocated
    SIZE_T dwCrtMem;             // current pool memory used
    DWORD  dwMaxAlloc;           // max number of pool allocations made
    DWORD  dwCrtAlloc;           // current pool allocations

    PWin32PoolHead pHead;        // pointer to the link list with the allocations

} Win32AllocStats, *PWin32AllocStats;

typedef struct tagPOOLRECORD {
    PVOID   ExtraData;           // the tag
    SIZE_T  size;
    PVOID   trace[RECORD_STACK_TRACE_SIZE];
} POOLRECORD, *PPOOLRECORD;

//
// Reference each type we need
// 

ENTRY                               Entry;

POOLRECORD                          PoolRecord;
VSTATE                              VerifierState;
VERIFIERTRACKHDR                    VerifierTrackHdr;

Win32AllocStats                     Win32AllocStatsRef;
Win32PoolHead                       Win32PoolHeadRef;

// Make it build

int __cdecl main() { 
    return 0; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\kmsplapi.h ===
typedef BOOL   (FAR WINAPI * FPOPENPRINTERW)(LPWSTR,LPHANDLE,LPPRINTER_DEFAULTS);
typedef BOOL   (FAR WINAPI * FPGETPRINTERW)(HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPGETPRINTERDRIVERW)(HANDLE,LPWSTR,DWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPGETPRINTERDATAW)(HANDLE,LPWSTR,LPDWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPSETPRINTERDATAW)(HANDLE,LPWSTR,DWORD,LPBYTE,DWORD);
typedef BOOL   (FAR WINAPI * FPGETFORMW)(HANDLE,LPWSTR,DWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPENUMFORMSW)(HANDLE,DWORD,LPBYTE,DWORD,LPDWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPCLOSEPRINTER)(HANDLE);
typedef DWORD  (FAR WINAPI * FPSTARTDOCPRINTERW)(HANDLE,DWORD,LPBYTE);
typedef DWORD  (FAR WINAPI * FPENDDOCPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPSTARTPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPENDPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPWRITEPRINTER)(HANDLE,LPVOID,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPABORTPRINTER)(HANDLE);

FPOPENPRINTERW		fpOpenPrinterW;
FPGETPRINTERW		fpGetPrinterW;
FPGETPRINTERDRIVERW	fpGetPrinterDriverW;
FPGETPRINTERDATAW	fpGetPrinterDataW;
FPSETPRINTERDATAW	fpSetPrinterDataW;
FPGETFORMW			fpGetFormW;
FPENUMFORMSW		fpEnumFormsW;
FPCLOSEPRINTER		fpClosePrinter;
FPSTARTDOCPRINTERW	fpStartDocPrinterW;
FPSTARTPAGEPRINTER	fpStartPagePrinter;
FPWRITEPRINTER		fpWritePrinter;
FPABORTPRINTER		fpAbortPrinter;
FPENDPAGEPRINTER	fpEndPagePrinter;
FPENDDOCPRINTER		fpEndDocPrinter;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\musspl.h ===
/*************************************************************************
*
* musspl.h
*
*       (previously called ctxspl.h)
*
* Per CSRSS spooler header.
*
* This header is designed to support enough of an environment to move
* windows\spooler\spoolss\server\splkernl.c (SPOOLSS)
* to ntos\w32\ntuser\server\citrix (CSRSS)
*
* copyright notice: Copyright 1997, Microsoft
*
* Author:
*************************************************************************/

#if DBG

#define DBG_NONE      0x0000
#define DBG_INFO      0x0001
#define DBG_WARN      0x0002
#define DBG_WARNING   0x0002
#define DBG_ERROR     0x0004
#define DBG_TRACE     0x0008
#define DBG_SECURITY  0x0010
#define DBG_TIME      0x0020
#define DBG_PORT      0x0040
#define DBG_NOTIFY    0x0080
#define DBG_PAUSE     0x0100
#define DBG_ASSERT    0x0200
#define DBG_THREADM   0x0400
#define DBG_MIN       0x0800

#define DBGMSG( Level, Message ) DbgPrint Message

#define SPLASSERT(exp) \
    if (!(exp)) { \
        DBGMSG( DBG_ASSERT, ( "Failed: %s\nLine %d, %s\n", \
                              #exp,        \
                              __LINE__,    \
                              __FILE__ )); \
    }

#else

#define DBGMSG( Level, Message )
#define SPLASSERT(exp)

#endif

#include "client.h"
#include "kmspool.h"
#include "yspool.h"

LPVOID
AllocSplMem(
    DWORD cb
    );

BOOL
FreeSplMem(
    LPVOID pMem
    );

LPVOID
ReallocSplMem(
    LPVOID lpOldMem,
    DWORD cbOld,
    DWORD cbNew
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\musspl.c ===
/*************************************************************************
*
* musspl.c
*
*       (previously called ctxspl.c)
*
* copyright notice: Copyright 1997, Microsoft
*
* Author:
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Global data
 */
CRITICAL_SECTION ThreadCriticalSection;

/*
 * External references
 */
extern DWORD GetSpoolMessages();


/*****************************************************************************
 *
 *  MultiUserSpoolerInit
 *
 *   Init the spooler data upcall thread for WIN32K.SYS
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
MultiUserSpoolerInit()
{
    DWORD               Win32status;
    NTSTATUS            Status;

    //
    // Init the critical section
    //

    //We should rather do a RtlInitializeCriticalSection in order to get a return code
    InitializeCriticalSection(&ThreadCriticalSection);

    //
    // Create Kernel Spooler Message Thread
    //

    Win32status = GetSpoolMessages();
    if (Win32status != ERROR_SUCCESS) {
#if DBG
        DbgPrint("Kernel Spooler Messaging Initialization Failed %d\n", Win32status);
#endif
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
#if DBG
        DbgPrint("Kernel Spooler Messaging Initialization succeeded\n");
#endif
        Status = STATUS_SUCCESS;
    }

    return Status;
}


/*****************************************************************************
 *
 *  AllocSplMem
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

LPVOID
AllocSplMem(
    DWORD cb)
{
    LPDWORD pMem;

    pMem=(LPDWORD)LocalAlloc(LPTR, cb);

    if (!pMem)
    {
        return NULL;
    }
    return (LPVOID)pMem;
}

/*****************************************************************************
 *
 *  FreeSplMem
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
FreeSplMem(
    LPVOID pMem)
{
    return LocalFree((HLOCAL)pMem) == NULL;
}

/*****************************************************************************
 *
 *  ReallocSplMem
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

LPVOID
ReallocSplMem(
    LPVOID lpOldMem,
    DWORD cbOld,
    DWORD cbNew)
{
    if (lpOldMem)
        return LocalReAlloc(lpOldMem, cbNew, LMEM_MOVEABLE);
    else
        return AllocSplMem(cbNew);
    UNREFERENCED_PARAMETER(cbOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#include <stddef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\splkernl.c ===
/*************************************************************************
*
* splkernl.c
*
* This is a modified Microsoft NT 4.0 file from
* \nt\private\windows\spooler\spoolss\server\splkernl.c
*
* This provides for reading spooler requests from printer device drivers
* running in kernel mode under WIN32K.SYS.
*
* WinFrame isolates each WIN32K.SYS and printer device driver into its
* own independent WINSTATION SPACE. Because of this, the threads that
* run inside of the spool subsystem can only read the requests from
* printer drivers running on the console.
*
* This module has been moved to CSRSS to read the requests out for this
* WINSTATION, and then convert them to RPC calls onto the spooler.
*
* NOTE: The kernel mode spooler requests take a different path than
* pure RPC requests. The console will continue to run this way. On
* WINSTATIONS, all print spooler interaction will be through RPC
* like NT 3.51.
*
* Also there is a new printer UI type that processing when a page
* or job is printed. These are OEM supplied for things like FAX
* servers. If they attempt to do any Windows dialogs or pop-ups
* they will only show up on the console. By having them be inside
* of the WINSTATIONS CSRSS they will pop up on the proper WINSTATION.
*
* copyright notice: Copyright 1997, Microsoft
*
* Author:
*
*************************************************************************/

/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:

    splkernl.c

Abstract:

    This module contains the Spooler's Kernel mode message router and unmarshalling functions,
    which then call kmxxx().

Author:

    Steve Wilson (NT) (swilson) 1-Jun-1995

[Notes:]

    optional-notes

Revision History:
        Nicolas Biju-Duval Dec-97       :       adaptation for Hydra


--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>
#include <ntgdispl.h>
#include "winspl.h"
#include "wingdip.h"
#include "musspl.h"
#include "kmsplapi.h"
#include "winuserk.h"

extern CRITICAL_SECTION ThreadCriticalSection;

#define IN_BUF_SIZE     4500    // must be at least 4096
#define OUT_BUF_SIZE    1024

#define DECREMENT       0
#define INCREMENT       1

#define MAX_GRE_STRUCT_SIZE 100     // At least the size of the largest GRExxx struct in ntgdispl.h

BOOL    LoadWinspoolDrv();

DWORD cGetSpoolMessage(PSPOOLESC psesc, DWORD cjMsg, PDWORD pulOut, DWORD cjOut);
BOOL SpoolerGetSpoolMessage();

BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE*, DWORD*);
BOOL DoGetPrinter(PSPOOLESC psesc, GREGETPRINTER *pGetPrinterReturn, DWORD *pcjOut);
BOOL DoGetPrinterDriver( PSPOOLESC, GREGETPRINTERDRIVER*, DWORD* );
BOOL DoStartDocPrinter( PSPOOLESC psesc );
BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten );
BOOL DoGetForm(PSPOOLESC psesc, GREGETFORM *pGetFormReturn, DWORD *pcjOut);
BOOL DoEnumForms(PSPOOLESC psesc, GREENUMFORMS *pEnumFormsReturn, DWORD *pcjOut);
BOOL DoGetPrinterData(PSPOOLESC psesc, GREGETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoSetPrinterData(PSPOOLESC psesc, GRESETPRINTERDATA *pXReturn, DWORD *pcjOut);
BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD  *pcjWritten );

DWORD GetSpoolMessages();
DWORD AddThread();

LONG nIdleThreads = 0;          // Number of idle threads
LONG nThreads = 0;
SYSTEMTIME LastMessageTime;     // Time at which last message was received

//*************************************************************
//
// LoadWinspoolDrv
//
//  This function is called at initialization, just to make sure
//  that there is enough memory available. This is a little weird:
//  we just want to load winspool.drv, but the obtained pointers
//  will never be used. By doing that we are protected against
//  the risk of not being able to load winspool.drv later.
//
//*************************************************************

BOOL    LoadWinspoolDrv()
{
        BOOL    bRet = FALSE;
        HANDLE hWinspoolDll = NULL;
        hWinspoolDll = LoadLibraryW(L"winspool.drv");

        if (hWinspoolDll != NULL)       //      winspool.drv OK, now get the addresses
        {
                fpOpenPrinterW =                (FPOPENPRINTERW)        GetProcAddress( hWinspoolDll, "OpenPrinterW");
                fpGetPrinterW =                 (FPGETPRINTERW)         GetProcAddress( hWinspoolDll, "GetPrinterW");
                fpGetPrinterDriverW =   (FPGETPRINTERDRIVERW)GetProcAddress( hWinspoolDll, "GetPrinterDriverW");
                fpGetPrinterDataW =             (FPGETPRINTERDATAW)     GetProcAddress( hWinspoolDll, "GetPrinterDataW");
                fpSetPrinterDataW =             (FPSETPRINTERDATAW)     GetProcAddress( hWinspoolDll, "SetPrinterDataW");
                fpGetFormW =                    (FPGETFORMW)            GetProcAddress( hWinspoolDll, "GetFormW");
                fpEnumFormsW =                  (FPENUMFORMSW)          GetProcAddress( hWinspoolDll, "EnumFormsW");
                fpClosePrinter =                (FPCLOSEPRINTER)        GetProcAddress( hWinspoolDll, "ClosePrinter");
                fpStartDocPrinterW =    (FPSTARTDOCPRINTERW)GetProcAddress( hWinspoolDll, "StartDocPrinterW");
                fpStartPagePrinter =    (FPSTARTPAGEPRINTER)GetProcAddress( hWinspoolDll, "StartPagePrinter");
                fpWritePrinter =                (FPWRITEPRINTER)        GetProcAddress( hWinspoolDll, "WritePrinter");
                fpAbortPrinter =                (FPABORTPRINTER)        GetProcAddress( hWinspoolDll, "AbortPrinter");
                fpEndPagePrinter =              (FPENDPAGEPRINTER)      GetProcAddress( hWinspoolDll, "EndPagePrinter");
                fpEndDocPrinter =               (FPENDDOCPRINTER)       GetProcAddress( hWinspoolDll, "EndDocPrinter");

                if ((fpOpenPrinterW != NULL)            &&
                        (fpGetPrinterW != NULL)                 &&
                        (fpGetPrinterDriverW != NULL)   &&
                        (fpGetPrinterDataW != NULL)             &&
                        (fpSetPrinterDataW != NULL)             &&
                        (fpGetFormW != NULL)                    &&
                        (fpEnumFormsW != NULL)                  &&
                        (fpClosePrinter != NULL)                &&
                        (fpStartDocPrinterW != NULL)    &&
                        (fpStartPagePrinter != NULL)    &&
                        (fpWritePrinter != NULL)                &&
                        (fpAbortPrinter != NULL)                &&
                        (fpEndPagePrinter != NULL)              &&
                        (fpEndDocPrinter != NULL)               )
                {
                        bRet = TRUE;            // everything is OK. We are ready to call winspool.drv
                }
                else
                {
                        bRet = FALSE;
                        FreeLibrary(hWinspoolDll);
                }
        }

        return bRet;
}

//
// GetSpoolMessages - Manages creation & deletion of spooler message threads
//
DWORD GetSpoolMessages()
{
    if (!GdiInitSpool()) {
        DBGMSG(DBG_TRACE, ("Error calling GdiInitSpool()\n"));
        return GetLastError();
    }

        if (!LoadWinspoolDrv())
        {
        DBGMSG(DBG_TRACE, ("Unable to load Winspool.drv\n"));
        return GetLastError();
        }

    return AddThread();
}

DWORD AddThread()
{
    HANDLE  hThread;
    DWORD   MessageThreadId;
    DWORD   dwError;

    try {
        if(hThread = CreateThread(  NULL,
                                    64*1024,
                                    (LPTHREAD_START_ROUTINE) SpoolerGetSpoolMessage,
                                    0,
                                    0,
                                    &MessageThreadId)) {
            CloseHandle(hThread);
            dwError = ERROR_SUCCESS;
        } else {
            dwError = GetLastError();
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = TranslateExceptionCode(GetExceptionCode());
    }

    return dwError;
}


BOOL SpoolerGetSpoolMessage()
{
    DWORD           dwResult;
    PSPOOLESC       pInput;                     // Input buffer that receives messages from Kernel
    BYTE            *pOutput;                   // Output buffer that receives data from KMxxx() spooler calls
    BYTE            *pMem;
    DWORD           cbOut        = 0;           // Size of pOutput
    DWORD           cbIn         = IN_BUF_SIZE; // Size of pInput buffer in bytes
    DWORD           cbOutSize;
    USERTHREAD_USEDESKTOPINFO  utudi = { 0 };
    BOOL            bHaveDesktop = FALSE;

    (VOID) CsrConnectToUser();

    if(!(pInput = (PSPOOLESC) AllocSplMem(cbIn))) {
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    if(!(pOutput = AllocSplMem(OUT_BUF_SIZE))) {
        FreeSplMem(pInput);
        DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
        return FALSE;
    }

    cbOutSize = OUT_BUF_SIZE;

    EnterCriticalSection(&ThreadCriticalSection);

    ++nThreads;

    LeaveCriticalSection(&ThreadCriticalSection);

    while(1) {

        EnterCriticalSection(&ThreadCriticalSection);
        ++nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);

        dwResult = GdiGetSpoolMessage(pInput,cbIn,(PDWORD)pOutput,cbOut);

        EnterCriticalSection(&ThreadCriticalSection);
        --nIdleThreads;
        LeaveCriticalSection(&ThreadCriticalSection);

        if(dwResult) {
            if( (pInput->iMsg != GDISPOOL_TERMINATETHREAD) &&
                (pInput->iMsg != GDISPOOL_INPUT2SMALL)) {

                EnterCriticalSection(&ThreadCriticalSection);

                if(nIdleThreads == 0) {
                    AddThread();
                    DBGMSG(DBG_TRACE, ("Thread Added: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));
                }

                LeaveCriticalSection(&ThreadCriticalSection);
            }

            // check if the out buffer needs to be grown or shrunk.

            if ((pInput->cjOut + MAX_GRE_STRUCT_SIZE) > cbOutSize) {

                FreeSplMem(pOutput);

                pOutput = AllocSplMem(cbOutSize = pInput->cjOut + MAX_GRE_STRUCT_SIZE);

                if (!pOutput) {

                    DBGMSG(DBG_WARNING, ("Error allocating pInput in SpoolerGetSpoolMessage\n"));
                    pInput->ulRet = 0;
                    cbOut = 0;
                    cbOutSize = 0;
                    continue;
                }
            }
            else if ((pInput->cjOut < OUT_BUF_SIZE) &&
                     (cbOutSize > OUT_BUF_SIZE)) {

                // we want to shrink the buffer

                PBYTE pbTmp = AllocSplMem(OUT_BUF_SIZE);

                if (pbTmp) {

                    FreeSplMem(pOutput);

                    pOutput = pbTmp;
                    cbOutSize = OUT_BUF_SIZE;
                }
            }


            if (pInput->iMsg & GDISPOOL_API) {

                SPLASSERT(pInput->hSpool || pInput->iMsg == GDISPOOL_OPENPRINTER);

                if (pInput->iMsg != GDISPOOL_OPENPRINTER || pInput->hSpool) {
                    if (InterlockedIncrement(&((PSPOOL)pInput->hSpool)->cThreads) > 0) {

                        // We are already processing a message & have now gotten a ClosePrinter
                        // We should not get here on any other API
                        SPLASSERT(pInput->iMsg == GDISPOOL_CLOSEPRINTER);

                        pInput->ulRet = TRUE;       // Let Client terminate
                        continue;
                    }
                }
            }

            //
            // This is a Csrss thread with no desktop. It needs to grab a temporary one
            // before calling into win32k so set a desktop in case there is a user mode
            // print driver that wants to write to a desktop (ie dialog box messages).
            //
            utudi.hThread = NULL;
            utudi.drdRestore.pdeskRestore = NULL;

            bHaveDesktop = ((NtUserSetInformationThread(
                                NtCurrentThread(),
                                UserThreadUseActiveDesktop,
                                &utudi, 
                                sizeof(utudi)) == STATUS_SUCCESS) ? TRUE : FALSE );

            switch (pInput->iMsg) {
                case GDISPOOL_INPUT2SMALL:
                    DBGMSG(DBG_TRACE,(" - buffer not big enough\n"));

                    pMem = ReallocSplMem(pInput, cbIn, pInput->cjOut);

                    if (!pMem) {

                        DBGMSG(DBG_WARNING, ("Error reallocating pInput in SpoolerGetSpoolMessage\n"));
                        pInput->ulRet = 0;
                    }
                    else {
                        pInput = (PSPOOLESC) pMem;
                        cbIn   = pInput->cjOut;
                        pInput->ulRet = 1;
                    }

                    break;

                case GDISPOOL_TERMINATETHREAD:
                    EnterCriticalSection(&ThreadCriticalSection);

                    // There is 1 way to get here: from a 10 minute Kernel Event timeout

                    if(nIdleThreads > 1) {
                        --nThreads;
                        if (nThreads == 0) {
                            DBGMSG(DBG_WARNING, ("SpoolerGetSpoolMessage nThreads is now ZERO\n"));
                        }

                        DBGMSG(DBG_TRACE, ("Thread Deleted: nIdle = %d  nThreads = %d\n", nIdleThreads, nThreads));

                        LeaveCriticalSection(&ThreadCriticalSection);

                        FreeSplMem(pInput);
                        FreeSplMem(pOutput);

                        return TRUE;
                    }

                    LeaveCriticalSection(&ThreadCriticalSection);
                    break;
#ifdef _IA64_
                case GDISPOOL_WRITE:
                case GDISPOOL_OPENPRINTER:
                case GDISPOOL_STARTDOCPRINTER:
                case GDISPOOL_STARTPAGEPRINTER:
                case GDISPOOL_ENDPAGEPRINTER:
                case GDISPOOL_ENDDOCPRINTER:
                case GDISPOOL_ENUMFORMS:
                case GDISPOOL_GETPRINTER:
                case GDISPOOL_GETFORM:
                case GDISPOOL_GETPRINTERDRIVER:
                case GDISPOOL_GETPRINTERDATA:
                case GDISPOOL_SETPRINTERDATA:
                case GDISPOOL_ABORTPRINTER:
                case GDISPOOL_CLOSEPRINTER:
                case GDISPOOL_GETPATHNAME:

                    //
                    // We should normally never get here. We do not support KMPD on IA64.
                    // However, GDI may try to take the route of KM messaging, if OpenPrinter
                    // for a queue using a UMPD fails. This can happen under stress conditons.
                    // For this reason we handle the KM request on IA64.
                    //
                    pInput->ulRet = FALSE;
                    SetLastError(ERROR_NOT_SUPPORTED);
                    break;
#else            
                case GDISPOOL_WRITE:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_WRITE\n"));
                    pInput->ulRet = DoWritePrinter( pInput, (DWORD*) pOutput );
                    cbOut = sizeof(DWORD);
                    break;

                case GDISPOOL_OPENPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_OPENPRINTER\n"));
                    DoOpenPrinter(pInput,(HANDLE*)pOutput,&cbOut);
                    break;

                case GDISPOOL_STARTDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTDOCPRINTER\n"));
                    DoStartDocPrinter(pInput);
                    break;

                case GDISPOOL_STARTPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_STARTPAGEPRINTER\n"));
                    pInput->ulRet = KMStartPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDPAGEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDPAGEPRINTER\n"));
                    pInput->ulRet = KMEndPagePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENDDOCPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENDDOCPRINTER\n"));
                    pInput->ulRet = KMEndDocPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_ENUMFORMS:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ENUMFORMS\n"));
                    DoEnumForms(pInput, (GREENUMFORMS *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTER\n"));
                    DoGetPrinter(pInput, (GREGETPRINTER *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETFORM:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETFORM\n"));
                    DoGetForm(pInput, (GREGETFORM *) pOutput, &cbOut);
                    break;

                case GDISPOOL_GETPRINTERDRIVER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDRIVER\n"));
                    DoGetPrinterDriver(pInput,(GREGETPRINTERDRIVER*)pOutput,&cbOut);
                    break;

                case GDISPOOL_GETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPRINTERDATA\n"));
                    DoGetPrinterData(pInput,(GREGETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_SETPRINTERDATA:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_SETPRINTERDATA\n"));
                    DoSetPrinterData(pInput,(GRESETPRINTERDATA *) pOutput,&cbOut);
                    break;

                case GDISPOOL_ABORTPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_ABORTPRINTER\n"));
                    pInput->ulRet = KMAbortPrinter( pInput->hSpool );
                    break;

                case GDISPOOL_CLOSEPRINTER:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
                    break;

                case GDISPOOL_GETPATHNAME:
                    DBGMSG(DBG_TRACE,(" - GDISPOOL_GETPATHNAME\n"));
                    pInput->ulRet = DoGetPathName((WCHAR*)pInput->ajData,
                                                  (WCHAR*)pOutput,
                                                  &cbOut);
                    break;
#endif
                default:
                    DBGMSG(DBG_ERROR,(" - invalid message\n"));
                    break;
            }

            //
            // Release the temporary desktop
            //
            if (bHaveDesktop) {

                (VOID)NtUserSetInformationThread(NtCurrentThread(),
                                                    UserThreadUseDesktop,
                                                    &utudi,
                                                    sizeof(utudi));
            }                                                   

            if ((pInput->iMsg & GDISPOOL_API) &&
                 pInput->iMsg != GDISPOOL_CLOSEPRINTER &&
                 pInput->iMsg != GDISPOOL_OPENPRINTER &&
                 pInput->hSpool) {

                if (InterlockedDecrement(&((PSPOOL)pInput->hSpool)->cThreads) == 0) {

                    DBGMSG(DBG_TRACE,(" - GDISPOOL_CLOSEPRINTER\n"));
#ifdef _IA64_
                    pInput->ulRet = FALSE;
                    SetLastError(ERROR_NOT_SUPPORTED);
#else
                    pInput->ulRet = KMClosePrinter( pInput->hSpool );
#endif
                }
            }
        }
                
    }
}



/******************************Public*Routine******************************\
*
*
* History:
*  11-Apr-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/


BOOL DoOpenPrinter(PSPOOLESC psesc, HANDLE* phPrinter, DWORD* pcjOut)
{
    LPWSTR pPrinterName = NULL;
    PRINTER_DEFAULTSW pDefault;
    GREOPENPRINTER *pOpenPrinter = (GREOPENPRINTER *)psesc->ajData;
    PLONG plData;

    plData      = pOpenPrinter->alData;
    pDefault    = pOpenPrinter->pd;

    // see if there is a printer name?

    if (pOpenPrinter->cjName)
    {
        pPrinterName = (PWCHAR)plData;
        plData += pOpenPrinter->cjName/4;
    }

    // now setup the printer defaults

    if (pOpenPrinter->cjDatatype)
    {
        pDefault.pDatatype = (PWCHAR)plData;
        plData += pOpenPrinter->cjDatatype/4;
    }

    if (pOpenPrinter->cjDevMode)
    {
        pDefault.pDevMode = (PDEVMODEW)plData;
    }

    DBGMSG(DBG_TRACE,
                ("OpenPrinter(%ls,%ls,%lx,%d)\n",
                pPrinterName,
                pDefault.pDatatype,
                pDefault.pDevMode,
                pDefault.DesiredAccess) );

    psesc->ulRet = KMOpenPrinterW(pPrinterName,phPrinter,&pDefault);

    DBGMSG( DBG_TRACE,("OpenPrinter returned = %lx\n",psesc->ulRet));

    *pcjOut = sizeof(DWORD);

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}




/****************************************************************************
*  DoStartDocPrinter()
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL DoStartDocPrinter( PSPOOLESC psesc )
{
    DOC_INFO_1W di;
    GRESTARTDOCPRINTER *pStartDocPrinter = (GRESTARTDOCPRINTER *)psesc->ajData;
    PLONG plData;

    plData = pStartDocPrinter->alData;

    // see if there is a printer name?

    if (pStartDocPrinter->cjDocName)
    {
        di.pDocName = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDocName/4;
    }
    else
    {
        di.pDocName = NULL;
    }

    if (pStartDocPrinter->cjOutputFile)
    {
        di.pOutputFile = (PWCHAR)plData;
        plData += pStartDocPrinter->cjOutputFile/4;
    }
    else
    {
        di.pOutputFile = NULL;
    }

    if (pStartDocPrinter->cjDatatype)
    {
        di.pDatatype = (PWCHAR)plData;
        plData += pStartDocPrinter->cjDatatype/4;
    }
    else
    {
        di.pDatatype = NULL;
    }

    psesc->ulRet = KMStartDocPrinterW(psesc->hSpool, 1, (LPBYTE) &di);

    if(psesc->ulRet)
        return TRUE;
    else
        return FALSE;
}


/*************************************************************************************
    DoEnumForms()

    History:
    25/7/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoEnumForms(
    PSPOOLESC psesc,
    GREENUMFORMS *pEnumFormsReturn,
    DWORD *pcjOut
)
{
    GREENUMFORMS *pEnumForms = (GREENUMFORMS *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMEnumFormsW (   psesc->hSpool,
                                    pEnumForms->dwLevel,
                                    (BYTE *) pEnumFormsReturn->alData,
                                    pEnumForms->cjData,
                                    &dwNeeded,
                                    &pEnumFormsReturn->nForms
                                );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pEnumFormsReturn->cjData = pEnumForms->cjData;
        *pcjOut = pEnumForms->cjData + sizeof(GREENUMFORMS);
    }
    else {
        pEnumFormsReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREENUMFORMS);
    }

    return psesc->ulRet;
}


/*************************************************************************************
    DoGetPrinter()

    History:
    9/30/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoGetPrinter(
    PSPOOLESC psesc,
    GREGETPRINTER *pGetPrinterReturn,
    DWORD *pcjOut
)
{
    GREGETPRINTER *pGetPrinter = (GREGETPRINTER *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterW (  psesc->hSpool,
                                    pGetPrinter->dwLevel,
                                    (BYTE *) pGetPrinterReturn->alData,
                                    pGetPrinter->cjData,
                                    &dwNeeded
                                  );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetPrinterReturn->cjData = pGetPrinter->cjData;
        *pcjOut = pGetPrinter->cjData + sizeof(GREGETPRINTER);
    }
    else {
        pGetPrinterReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETPRINTER);
    }

    return psesc->ulRet;
}


/*************************************************************************************
    DoGetForm()

    History:
    25/7/95 by Steve Wilson [swilson]

**************************************************************************************/

BOOL DoGetForm(
    PSPOOLESC psesc,
    GREGETFORM *pGetFormReturn,
    DWORD *pcjOut
)
{
    GREGETFORM *pGetForm = (GREGETFORM *) psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetFormW (   psesc->hSpool,
                                  pGetForm->cjFormName ? (PWCHAR) pGetForm->alData : NULL,
                                  pGetForm->dwLevel,
                                  (BYTE *) pGetFormReturn->alData,
                                  pGetForm->cjData,
                                  &dwNeeded
                              );

    if (psesc->ulRet) {

        // Set return data size to incoming buffer size since strings are packed at end of in buffer
        pGetFormReturn->cjData = pGetForm->cjData;
        *pcjOut = pGetForm->cjData + sizeof(GREGETFORM);
    }
    else {
        pGetFormReturn->cjData = dwNeeded; // This makes client alloc more than needed
        *pcjOut = sizeof(GREGETFORM);
    }

    return psesc->ulRet;
}




/***************************************************************************************
*  DoGetPrinterDriver()

*  History:
*   4/17/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
**************************************************************************************/


BOOL DoGetPrinterDriver(
    PSPOOLESC psesc,
    GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDRIVER *pGetPrinterDriver = (GREGETPRINTERDRIVER *)psesc->ajData;
    DWORD dwNeeded = 0;

    psesc->ulRet = KMGetPrinterDriverW(psesc->hSpool,
                                      pGetPrinterDriver->cjEnv ? (PWCHAR)pGetPrinterDriver->alData : NULL,
                                      pGetPrinterDriver->dwLevel,
                                      (BYTE*)pGetPrinterDriverReturn->alData,
                                      pGetPrinterDriver->cjData,
                                      &dwNeeded );

    if (psesc->ulRet)
    {
        pGetPrinterDriverReturn->cjData = pGetPrinterDriver->cjData;  // fix for ValidateStrings in spool.cxx
        *pcjOut = pGetPrinterDriver->cjData + sizeof(GREGETPRINTERDRIVER);
    }
    else
    {
        // we failed so just return the size

        pGetPrinterDriverReturn->cjData = dwNeeded;
        *pcjOut = sizeof(GREGETPRINTERDRIVER);
    }


    if(psesc->ulRet)
        return TRUE;

    return FALSE;
}


/***************************************************************************************
*  DoGetPrinterData()

*  History:
*   Jul-25-95 by Steve Wilson [swilson]
*  Wrote it.
**************************************************************************************/


BOOL DoGetPrinterData(
    PSPOOLESC psesc,
    GREGETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GREGETPRINTERDATA *pX = (GREGETPRINTERDATA *) psesc->ajData;

    DWORD dwNeeded = 0;        // return values
    DWORD dwType;


    psesc->ulRet = KMGetPrinterDataW( psesc->hSpool,
                                      pX->cjValueName ? (PWCHAR) pX->alData : NULL,
                                      &dwType,
                                      (BYTE *) pXReturn->alData,
                                      pX->cjData,
                                      &dwNeeded );

    pXReturn->dwNeeded = dwNeeded;
    pXReturn->cjData = pX->cjData;
    *pcjOut = pX->cjData + sizeof *pX;
    pXReturn->dwType = dwType;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
}



/***************************************************************************************
*  DoSetPrinterData()

*  History:
*   Jul-25-95 by Steve Wilson [swilson]
*  Wrote it.
**************************************************************************************/


BOOL DoSetPrinterData(
    PSPOOLESC psesc,
    GRESETPRINTERDATA *pXReturn,
    DWORD *pcjOut
    )
{
    GRESETPRINTERDATA *pX = (GRESETPRINTERDATA *) psesc->ajData;


    psesc->ulRet = KMSetPrinterDataW( psesc->hSpool,
                                      pX->cjType ? (PWCHAR) pX->alData : NULL,
                                      pX->dwType,
                                      pX->cjPrinterData ? (BYTE *) pX->alData + pX->cjType : NULL,
                                      pX->cjPrinterData );

    *pcjOut = sizeof *pX;

    SetLastError(psesc->ulRet);

    return psesc->ulRet = !psesc->ulRet;
    UNREFERENCED_PARAMETER(pXReturn);
}





/****************************************************************************
*  DoWritePrinter()

*  History:
*   5/1/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL DoWritePrinter(PSPOOLESC psesc, DWORD *pWritten )
{
    GREWRITEPRINTER *pWritePrinter;

    pWritePrinter = (GREWRITEPRINTER*) psesc->ajData;

    if( KMWritePrinter( psesc->hSpool,
                      (PVOID) pWritePrinter->alData,
                      pWritePrinter->cjData,
                      pWritten) )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


BOOL DoGetPathName( WCHAR  *pwcSrc, WCHAR  *pwcDst, DWORD  *pcjWritten )
{
    BOOL    bRet;
    WCHAR   awcFontsDir[MAX_PATH + sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR)];

    wcscpy(awcFontsDir,L"\\DOSDEVICES\\");

    bRet = bMakePathNameW (
            &awcFontsDir[sizeof(L"\\DOSDEVICES\\")/sizeof(WCHAR) - 1],
            pwcSrc,
            NULL,
            NULL
            );


    if (bRet)
    {
        wcscpy(pwcDst,awcFontsDir);
        *pcjWritten = sizeof(WCHAR) * (wcslen(awcFontsDir) + 1);
    }

// Buffer large enough and search successfull?

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\umpdhook.c ===
/*++

Copyright (c) 1999 Microsoft Corporation
All rights reserved

Module Name:

    umpdhook.c

Abstract:

    This module is to redirect SPOOLSS.DLL functions to the WINSPOOL.DRV
    functions for the User Mode Printer Device (UMPD) DLLs.

Author:

    Min-Chih Lu Earl (v-mearl) 8-March-99  (Get ideas and implementation from
                                            \private\tsext\admtools\tsappcmp\register.c
                                            by v-johnjr)

Environment:

    User Mode - Win32 (in WINSRV.DLL running in the CSRSS.EXE process)

Revision History:


--*/
#define _USER_

#include "precomp.h"
#pragma hdrstop

#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>
#if(WINVER >= 0x0500)
    #include <winspl.h>
#else
    #include "..\..\..\..\..\windows\spooler\spoolss\winspl.h"
#endif
#include <data.h>
#include "wingdip.h"
#if(WINVER >= 0x0500)
   #include "musspl.h"
#else
   #include "ctxspl.h"
#endif




//*====================================================================*//
//* Local definitions                                                  *//
//*====================================================================*//
#define SPOOLSS_DLL_W   L"SPOOLSS.DLL"
#define SPOOLSS_DLL_A   "SPOOLSS.DLL"

//*====================================================================*//
//*  Local function prototypes
//*====================================================================*//

BOOL  PlaceHooks(HMODULE hUMPD, HMODULE hSpoolss);
PVOID PlaceHookEntry(HMODULE hSpoolss, PVOID * pProcAddress);

//*====================================================================*//
//* Hook function prototypes                                           *//
//*====================================================================*//
PVOID TSsplHookGetProcAddress(IN HMODULE hModule,IN LPCSTR lpProcName);

//*====================================================================*//
//* Public functions Implementations                                   *//
//*====================================================================*//
BOOL
TSsplHookSplssToWinspool(
    IN HMODULE hUMPD
    )
/*++

Routine Description:

    This routine redirect the statically linked SPOOLSS.DLL address
    to the winspool.drv equivalent functions

Arguments:

    hUMPD - Supplies the user mode printer driver DLL handle which uses
            the SPOOLSS.DLL

Return Value:

    TRUE - Success
    FAIL - Error. Use GetLastError() to get the error status

--*/
{
    BOOL    bStatus = TRUE;
    HMODULE hSpoolss;

    /*
     * Load SPOOLSS.DLL
     */

    hSpoolss = LoadLibrary(SPOOLSS_DLL_W);
    if (!hSpoolss) {
        DBGMSG(DBG_WARNING,("TSsplHookSplssToWinspool - Cannot load SPOOLSS.DLL\n"));
        return FALSE;
    }

    /*
     * Redirect the spoolss.dll call to the winspool.drv call in the
     * UMPD.DLL
     */

    bStatus = PlaceHooks(hUMPD, hSpoolss);

    FreeLibrary(hSpoolss);
    DBGMSG(DBG_TRACE,("TSsplHookSplssToWinspool - Redirect UMPD.DLL Spoolss.dll to Winspool.dll\n"));

    return bStatus;

}

//*====================================================================*//
//* Hook functions Implementations                                     *//
//*     These function hooks to the UMPD.DLL                           *//
//*====================================================================*//

PVOID
TSsplHookGetProcAddress(
    IN HMODULE hModule,
    IN LPCSTR lpProcName
    )
/*++

Routine Description:
    Redirect Spoolss.dll function in hUMPD to winspool.drv for dynamic load

--*/

{
    PVOID p;
    DWORD dllNameCount;
    WCHAR dllName[MAX_PATH];

    p = GetProcAddress(hModule, lpProcName);

    if (p &&
        (dllNameCount = GetModuleFileName(hModule, dllName, sizeof(dllName)/sizeof(WCHAR))) &&
        (wcsstr(_wcsupr(dllName), SPOOLSS_DLL_W) )
       ) {
        /*
         *This is SPOOLSS.DLL GetProcAddres. We need to redirect the p
         */

        DBGMSG(DBG_TRACE,("TSsplHookGetProcAddress - Redirect UMPD.DLL GetProcAddress %s\n",lpProcName));
        p = PlaceHookEntry(hModule, &p);
    }
    return p;
}
//*==========================================================================*//
//* Local functions                                                          *//
//*==========================================================================*//
BOOL
PlaceHooks(
           HMODULE hUMPD,
           HMODULE hSpoolss
           )

/*++

Routine Description:
    Redirect Spoolss.dll function in hUMPD to winspool.drv.

--*/
{
    NTSTATUS st;
    PVOID IATBase;
    SIZE_T BigIATSize;
    ULONG  LittleIATSize = 0;
    PVOID *ProcAddresses;
    ULONG NumberOfProcAddresses;
    ULONG OldProtect;

    IATBase = RtlImageDirectoryEntryToData( hUMPD,
                                            TRUE,
                                            IMAGE_DIRECTORY_ENTRY_IAT,
                                            &LittleIATSize
                                          );
    BigIATSize = LittleIATSize;
    if (IATBase != NULL) {
        st = NtProtectVirtualMemory( NtCurrentProcess(),
                                     &IATBase,
                                     &BigIATSize,
                                     PAGE_READWRITE,
                                     &OldProtect
                                   );
        if (!NT_SUCCESS(st)) {
            return FALSE;
        } else {
            ProcAddresses = (PVOID *)IATBase;
            NumberOfProcAddresses = (ULONG)(BigIATSize / sizeof(PVOID));
            while (NumberOfProcAddresses--) {
                /*
                 * Redirect the LoadLibrary and GetProcAddress function. We will
                 * have a chance to replace the address when the UMPD is a
                 * dynamically load
                 * DLL
                 */

                if (*ProcAddresses == GetProcAddress) {
                    *ProcAddresses = TSsplHookGetProcAddress;
                } else {
                    /* Replace the (static linked) spoolss.dll entry */
                    *ProcAddresses = PlaceHookEntry(hSpoolss, ProcAddresses);
                }

                ProcAddresses += 1;
            }

            NtProtectVirtualMemory( NtCurrentProcess(),
                                    &IATBase,
                                    &BigIATSize,
                                    OldProtect,
                                    &OldProtect
                                  );
        }
    }

    return TRUE;

}


PVOID
PlaceHookEntry(HMODULE              hSpoolss,
               PVOID *              pProcAddress
               )
/*--

Routine Description:

    This routine redirect the pProcAddress SPOOLSS.DLL function to the
    corresponding winspool.drv function.

Arguments:


Return Value:

    The corresponding winspool.drv function if found. Else, the original
    function
--*/
{

    /*
     * Print jobs functions
     */

    if ((GetProcAddress(hSpoolss,"SetJobW")) == *pProcAddress) {
        return (&SetJobW);
    }
    if ((GetProcAddress(hSpoolss,"GetJobW")) == *pProcAddress) {
        return(&GetJobW);
    }
    if ((GetProcAddress(hSpoolss,"WritePrinter")) == *pProcAddress) {
        return(&WritePrinter);
    }
    if ((GetProcAddress(hSpoolss,"EnumJobsW")) == *pProcAddress) {
        return(&EnumJobsW);
    }
    if ((GetProcAddress(hSpoolss,"AddJobW")) == *pProcAddress) {
        return(&AddJobW);
    }
    if ((GetProcAddress(hSpoolss,"ScheduleJob")) == *pProcAddress) {
        return(&ScheduleJob);
    }

    /*
     * Manage Printers
     */

    if ((GetProcAddress(hSpoolss,"EnumPrintersW")) == *pProcAddress) {
        return(&EnumPrintersW);
    }
    if (((BOOL (*)())GetProcAddress(hSpoolss,"AddPrinterW")) == *pProcAddress) {
        return(&AddPrinterW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePrinter")) == *pProcAddress) {
        return(&DeletePrinter);
    }
    if ((GetProcAddress(hSpoolss,"SetPrinterW")) == *pProcAddress) {
        return(&SetPrinterW);
    }
    if ((GetProcAddress(hSpoolss,"GetPrinterW")) == *pProcAddress) {
        return(&GetPrinterW);
    }

    /*
     * Printer Data functions
     */

    if ((GetProcAddress(hSpoolss,"GetPrinterDataW")) == *pProcAddress) {
        return(&GetPrinterDataW);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"GetPrinterDataExW")) == *pProcAddress) {
        return(&GetPrinterDataExW);
    }
#endif
    if ((GetProcAddress(hSpoolss,"EnumPrinterDataW")) == *pProcAddress) {
        return(&EnumPrinterDataW);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"EnumPrinterDataExW")) == *pProcAddress) {
        return(&EnumPrinterDataExW);
    }
    if ((GetProcAddress(hSpoolss,"EnumPrinterKeyW")) == *pProcAddress) {
        return(&EnumPrinterKeyW);
    }
#endif
    if ((GetProcAddress(hSpoolss,"DeletePrinterDataW")) == *pProcAddress) {
        return(&DeletePrinterDataW);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"DeletePrinterDataExW")) == *pProcAddress) {
        return(&DeletePrinterDataExW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePrinterKeyW")) == *pProcAddress) {
        return(&DeletePrinterKeyW);
    }
#endif

    if ((GetProcAddress(hSpoolss,"SetPrinterDataW")) == *pProcAddress) {
        return(&SetPrinterDataW);
    }

#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"SetPrinterDataExW")) == *pProcAddress) {
        return(&SetPrinterDataExW);
    }
#endif

    /*
     * PrinterConnection functions
     */

    if ((GetProcAddress(hSpoolss,"AddPrinterConnectionW")) == *pProcAddress) {
        return(&AddPrinterConnectionW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePrinterConnectionW")) == *pProcAddress) {
        return(&DeletePrinterConnectionW);
    }

    /*
     * Driver functions
     */

    if ((GetProcAddress(hSpoolss,"GetPrinterDriverDirectoryW")) == *pProcAddress) {
        return(&GetPrinterDriverDirectoryW);
    }
    if ((GetProcAddress(hSpoolss,"GetPrinterDriverW")) == *pProcAddress) {
        return(&GetPrinterDriverW);
    }
    if ((GetProcAddress(hSpoolss,"AddPrinterDriverW")) == *pProcAddress) {
        return(&AddPrinterDriverW);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"AddPrinterDriverExW")) == *pProcAddress) {
        return(&AddPrinterDriverExW);
    }
#endif
    if ((GetProcAddress(hSpoolss,"EnumPrinterDriversW")) == *pProcAddress) {
        return(&EnumPrinterDriversW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePrinterDriverW")) == *pProcAddress) {
        return(&DeletePrinterDriverW);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"DeletePrinterDriverExW")) == *pProcAddress) {
        return(&DeletePrinterDriverExW);
    }
#endif
    /*
     * Print Processors
     */

    if ((GetProcAddress(hSpoolss,"AddPrintProcessorW")) == *pProcAddress) {
        return(&AddPrintProcessorW);
    }
    if ((GetProcAddress(hSpoolss,"EnumPrintProcessorsW")) == *pProcAddress) {
        return(&EnumPrintProcessorsW);
    }
    if ((GetProcAddress(hSpoolss,"GetPrintProcessorDirectoryW")) == *pProcAddress) {
        return(&GetPrintProcessorDirectoryW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePrintProcessorW")) == *pProcAddress) {
        return(&DeletePrintProcessorW);
    }
    if ((GetProcAddress(hSpoolss,"EnumPrintProcessorDatatypesW")) == *pProcAddress) {
        return(&EnumPrintProcessorDatatypesW);
    }
    if ((GetProcAddress(hSpoolss,"OpenPrinterW")) == *pProcAddress) {
        return(&OpenPrinterW);
    }
    if ((GetProcAddress(hSpoolss,"ResetPrinterW")) == *pProcAddress) {
        return(&ResetPrinterW);
    }
    if ((GetProcAddress(hSpoolss,"ClosePrinter")) == *pProcAddress) {
        return(&ClosePrinter);
    }
    if ((GetProcAddress(hSpoolss,"AddPrintProcessorW")) == *pProcAddress) {
        return(&AddPrintProcessorW);
    }

    /*
     * Doc Printer
     */

    if ((GetProcAddress(hSpoolss,"StartDocPrinterW")) == *pProcAddress) {
        return(&StartDocPrinterW);
    }
    if ((GetProcAddress(hSpoolss,"StartPagePrinter")) == *pProcAddress) {
        return(&StartPagePrinter);
    }
    if ((GetProcAddress(hSpoolss,"EndPagePrinter")) == *pProcAddress) {
        return(&EndPagePrinter);
    }
    if ((GetProcAddress(hSpoolss,"WritePrinter")) == *pProcAddress) {
        return(&WritePrinter);
    }
#if(WINVER >= 0x0500)
    if ((GetProcAddress(hSpoolss,"FlushPrinter")) == *pProcAddress) {
        return(&FlushPrinter);
    }
#endif
    if ((GetProcAddress(hSpoolss,"AbortPrinter")) == *pProcAddress) {
        return(&AbortPrinter);
    }
    if ((GetProcAddress(hSpoolss,"ReadPrinter")) == *pProcAddress) {
        return(&ReadPrinter);
    }
    if ((GetProcAddress(hSpoolss,"EndDocPrinter")) == *pProcAddress) {
        return(&EndDocPrinter);
    }

    /*
     * Change functions
     */

    if ((GetProcAddress(hSpoolss,"WaitForPrinterChange")) == *pProcAddress) {
        return(&WaitForPrinterChange);
    }

    if ((GetProcAddress(hSpoolss,"FindClosePrinterChangeNotification")) == *pProcAddress) {
        return(&FindClosePrinterChangeNotification);
    }

    /*
     * Forms and port
     */

    if ((GetProcAddress(hSpoolss,"AddFormW")) == *pProcAddress) {
        return(&AddFormW);
    }

    if ((GetProcAddress(hSpoolss,"DeleteFormW")) == *pProcAddress) {
        return(&DeleteFormW);
    }
    if ((GetProcAddress(hSpoolss,"GetFormW")) == *pProcAddress) {
        return(&GetFormW);
    }
    if ((GetProcAddress(hSpoolss,"SetFormW")) == *pProcAddress) {
        return(&SetFormW);
    }
    if ((GetProcAddress(hSpoolss,"EnumFormsW")) == *pProcAddress) {
        return(&EnumFormsW);
    }
    if ((GetProcAddress(hSpoolss,"EnumPortsW")) == *pProcAddress) {
        return(&EnumPortsW);
    }
    if ((GetProcAddress(hSpoolss,"EnumMonitorsW")) == *pProcAddress) {
        return(&EnumMonitorsW);
    }
    if ((GetProcAddress(hSpoolss,"AddPortW")) == *pProcAddress) {
        return(&AddPortW);
    }
    if ((GetProcAddress(hSpoolss,"ConfigurePortW")) == *pProcAddress) {
        return(&ConfigurePortW);
    }
    if ((GetProcAddress(hSpoolss,"DeletePortW")) == *pProcAddress) {
        return(&DeletePortW);
    }
    if ((GetProcAddress(hSpoolss,"SetPortW")) == *pProcAddress) {
        return(&SetPortW);
    }
    if ((GetProcAddress(hSpoolss,"AddMonitorW")) == *pProcAddress) {
        return(&AddMonitorW);
    }
    if ((GetProcAddress(hSpoolss,"DeleteMonitorW")) == *pProcAddress) {
        return(&DeleteMonitorW);
    }
    if ((GetProcAddress(hSpoolss,"AddPrintProvidorW")) == *pProcAddress) {
        return(&AddPrintProvidorW);
    }
    return *pProcAddress;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\umode\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\umode\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\kmspool.c ===
/*************************************************************************
*
* kmspool.c
*
* This is a modified Microsoft NT 4.0 file duplicated from
* \nt\private\windows\spooler\spoolss\server\kmspool.c
*
* The portion that deals with loading and calling the user space
* printer driver DLL is untouched to make merges easier.
*
* copyright notice: Copyright 1997, Microsoft
*
* Author:
*
*
*************************************************************************/

/*++

Copyright (c) 1990-1996 Microsoft Corporation
All rights reserved

Module Name:

    kmspool.c

Abstract:

    Spooler API entry points for Kernel Clients.

Author:
    Steve Wilson (NT) (swilson) 1-Jun-95  (Ported from client\winspool.c)

Environment:

    User Mode -Win32

Revision History:
    Matthew Felton (mattfe) May-96  Driver Hooks
        Nicolas Biju-Duval      Dec-97  adaptation for Hydra

--*/
#define _USER_

#include "precomp.h"
#pragma hdrstop

#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>
//#include <ntgdispl.h>

#include <winspl.h>
#include <data.h>
#include "wingdip.h"
#include "musspl.h"


extern CRITICAL_SECTION ThreadCriticalSection;
extern LPWSTR InterfaceAddress;

//
// Globals
//

#define ENTER_WAIT_LIST() EnterCriticalSection(&ThreadCriticalSection)
#define EXIT_WAIT_LIST()  LeaveCriticalSection(&ThreadCriticalSection)


#if defined(_AMD64_)
LPWSTR szEnvironment = L"Windows NT Amd64";
#elif defined(_IA64_)
LPWSTR szEnvironment = L"Windows NT Ia64";
#else
LPWSTR szEnvironment = L"Windows NT x86";
#endif

//
//  Printer Attributes
//

#define     SPLPRINTER_USER_MODE_PRINTER_DRIVER       TEXT("SPLUserModePrinterDriver")


BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
);

BOOL
DriverEndPageHook(
    PSPOOL  pSpool
);


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
);

BOOL
DriverWritePrinterHook(
    PSPOOL pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

VOID
DriverEndDocHook(
    PSPOOL pSpool
);

DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
);

VOID
DriverClosePrinterHook(
    PSPOOL pSpool
);

VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
);

BOOL
TSsplHookSplssToWinspool(
    IN HMODULE hUMPD
    ) ;


// Simple for Now !!!

DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
)
{
    switch (ExceptionCode) {

    case EXCEPTION_ACCESS_VIOLATION:
    case EXCEPTION_DATATYPE_MISALIGNMENT:
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
    case EXCEPTION_FLT_DENORMAL_OPERAND:
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
    case EXCEPTION_FLT_INEXACT_RESULT:
    case EXCEPTION_FLT_INVALID_OPERATION:
    case EXCEPTION_FLT_OVERFLOW:
    case EXCEPTION_FLT_STACK_CHECK:
    case EXCEPTION_FLT_UNDERFLOW:
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
    case EXCEPTION_INT_OVERFLOW:
    case EXCEPTION_PRIV_INSTRUCTION:
    case ERROR_NOACCESS:
    case RPC_S_INVALID_BOUND:

        return ERROR_INVALID_PARAMETER;
        break;
    default:
        return ExceptionCode;
    }
}


BOOL
KMOpenPrinterW(
   LPWSTR   pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTS pDefault
)
{
    BOOL  ReturnValue;
    HANDLE  hPrinter;
    PSPOOL  pSpool;
    DWORD   dwSize = 0;
    DEVMODE_CONTAINER    DevModeContainer;

    if (pDefault && pDefault->pDevMode)
    {

        dwSize = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;
        if (dwSize) {
            DevModeContainer.cbBuf = pDefault->pDevMode->dmSize +
                                 pDefault->pDevMode->dmDriverExtra;
            DevModeContainer.pDevMode = (LPBYTE)pDefault->pDevMode;
        } else {
            DevModeContainer.cbBuf = 0;
            DevModeContainer.pDevMode = NULL;
        }
    }
    else
    {
        DevModeContainer.cbBuf = 0;
        DevModeContainer.pDevMode = NULL;
    }

    try {

        if (ReturnValue = YOpenPrinter(pPrinterName, &hPrinter,
                                         pDefault ? pDefault->pDatatype : NULL,
                                         &DevModeContainer,
                                         pDefault ? pDefault->DesiredAccess : 0,
                                         0 )) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    if (ReturnValue) {

        pSpool = AllocSplMem(sizeof(SPOOL));

        if (pSpool) {

            memset(pSpool, 0, sizeof(SPOOL));
            pSpool->signature = SP_SIGNATURE;
            pSpool->hPrinter = hPrinter;
            pSpool->cThreads = -1;

            //
            // This is to fix passing a bad pHandle to OpenPrinter!!
            //
            try {
                *phPrinter = pSpool;
            } except(1) {
                YClosePrinter(&hPrinter, 0);
                                FreeSplMem(pSpool);
                SetLastError(TranslateExceptionCode(GetExceptionCode()));
                return FALSE;
            }

        } else {

            YClosePrinter(&hPrinter, 0);
            ReturnValue = FALSE;
        }
    }

    return ReturnValue;
}


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL      ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }
    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YGetForm(pSpool->hPrinter, pFormName, Level, pForm,
                                     cbBuf, pcbNeeded, 0)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    BOOL    ReturnValue;
    DWORD   cbStruct;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pForm)
            memset(pForm, 0, cbBuf);

        if (ReturnValue = YEnumForms(pSpool->hPrinter, Level, pForm, cbBuf,
                                     pcbNeeded, pcReturned, 0)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    switch (Level) {

    case 1:
        pOffsets = PrinterInfo1Offsets;
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        break;

    case 3:
        pOffsets = PrinterInfo3Offsets;
        break;

    case 4:
        pOffsets = PrinterInfo4Offsets;
        break;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (pPrinter)
        memset(pPrinter, 0, cbBuf);

    try {

        if (ReturnValue = YGetPrinter(pSpool->hPrinter, Level, pPrinter, cbBuf, pcbNeeded, 0)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}




BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    if (Level < 1 || Level > 3) {
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    try {

        if (pDriverInfo)
            memset(pDriverInfo, 0, cbBuf);

        if (!pEnvironment || !*pEnvironment)
            pEnvironment = szEnvironment;

        if (ReturnValue = YGetPrinterDriver(pSpool->hPrinter, pEnvironment,
                                          Level, pDriverInfo, cbBuf,
                                          pcbNeeded,
                                          0 )) {
            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else {

            ReturnValue = TRUE;

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // The user should be able to pass in NULL for buffer, and
    // 0 for size.  However, the RPC interface specifies a ref pointer,
    // so we must pass in a valid pointer.  Pass in a pointer to
    // ReturnValue (this is just a dummy pointer).
    //
    if( !pData && !nSize ){

        pData = (PBYTE)&ReturnValue;
    }

    try {

        ReturnValue =  YGetPrinterData(pSpool->hPrinter, pValueName, pType,
                                         pData, nSize, pcbNeeded, 0);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
)
{
    DWORD   ReturnValue = 0;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return ERROR_INVALID_HANDLE;
    }

    try {

        ReturnValue = YSetPrinterData(pSpool->hPrinter, pValueName, Type,
                                        pData, cbData, 0);

    } except(1) {

        ReturnValue = TranslateExceptionCode(GetExceptionCode());

    }

    return ReturnValue;
}



DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
)
{
    BOOL ReturnValue;
    DWORD JobId;
    GENERIC_CONTAINER DocInfoContainer;
    PSPOOL  pSpool = (PSPOOL)hPrinter;


    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        DBGMSG(DBG_TRACE,("Entered KMStartDocPrinterW side  hPrinter = %x\n", hPrinter));

        if (Level != 1) {
            SetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
        }

        DocInfoContainer.Level = Level;
        DocInfoContainer.pData = pDocInfo;

        try {

            if (ReturnValue = YStartDocPrinter(pSpool->hPrinter,
                                       (LPDOC_INFO_CONTAINER)&DocInfoContainer,
                                       &JobId, 0)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;
            } else

                ReturnValue = JobId;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;
        }


        if (ReturnValue) {

            ReturnValue = DriverStartDocHook( pSpool, JobId );

            if ( ReturnValue )
                pSpool->Status |= SPOOL_STATUS_STARTDOC;

        }

        return ReturnValue;

    } except (1) {
        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        return(FALSE);
    }
}

BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    try {

        if (!ValidatePrinterHandle(hPrinter)) {
            return(FALSE);
        }

        pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

        DriverEndDocHook( pSpool );

        try {

            if (ReturnValue = YEndDocPrinter(pSpool->hPrinter, 0)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;

        }

        DBGMSG(DBG_TRACE, ("Exit EndDocPrinter - client side hPrinter %x\n", hPrinter));

        return ReturnValue;
   } except (1) {
       SetLastError(ERROR_INVALID_HANDLE);
       return(FALSE);
   }
}




BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    BOOL ReturnValue = TRUE;
    PSPOOL  pSpool   = (PSPOOL)hPrinter;

    DBGMSG(DBG_TRACE, ("WritePrinter - hPrinter %x pBuf %x cbBuf %d pcWritten %x\n",
                        hPrinter, pBuf, cbBuf, pcWritten));

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    *pcWritten = 0;

    if ( !(pSpool->Status & SPOOL_STATUS_STARTDOC) ) {

        SetLastError(ERROR_SPL_NO_STARTDOC);
        return FALSE;
    }


    //
    //  Call Printer Drivers User Mode WritePrinter Hook
    //


    if ( pSpool->hDriver ) {

        return DriverWritePrinterHook( pSpool, pBuf, cbBuf, pcWritten );
    }



    try {

        if (ReturnValue = YWritePrinter(pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, pcWritten, 0)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;
            DBGMSG(DBG_WARNING, ("KMWritePrinter - YWritePrinter Failed Error %d\n",GetLastError() ));

        } else {
            ReturnValue = TRUE;
            DBGMSG(DBG_TRACE, ("KMWritePrinter - YWritePrinter Success hPrinter %x pBuffer %x cbBuffer %x cbWritten %x\n",
                                pSpool->hPrinter, (LPBYTE) pBuf, cbBuf, *pcWritten));

        }

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_WARNING, ("YWritePrinter Exception Error %d\n",GetLastError()));

    }

    // Return the number of bytes written.

    DBGMSG(DBG_TRACE, ("KMWritePrinter cbWritten %d ReturnValue %d\n",*pcWritten, ReturnValue));

    return ReturnValue;
}


BOOL
KMStartPagePrinter(
    HANDLE hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    ReturnValue = DriverStartPageHook( pSpool );

    if ( ReturnValue ) {

        try {

            if (ReturnValue = YStartPagePrinter(pSpool->hPrinter, 0)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;

        }
    }

    return ReturnValue;
}

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
)
{
    BOOL ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    ReturnValue = DriverEndPageHook( pSpool );

    if ( ReturnValue ) {

        try {

            if (ReturnValue = YEndPagePrinter(pSpool->hPrinter, 0)) {

                SetLastError(ReturnValue);
                ReturnValue = FALSE;

            } else

                ReturnValue = TRUE;

        } except(1) {

            SetLastError(TranslateExceptionCode(GetExceptionCode()));
            ReturnValue = FALSE;

        }
    }

    return ReturnValue;
}


BOOL
KMAbortPrinter(
    HANDLE  hPrinter
)
{
    BOOL  ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    DWORD   dwNumWritten = 0;
    DWORD   dwPointer = 0;

    if (!ValidatePrinterHandle(hPrinter)){
        return(FALSE);
    }

    pSpool->Status &= ~SPOOL_STATUS_STARTDOC;

    DriverAbortPrinterHook( pSpool );

    try {

        if (ReturnValue = YAbortPrinter(pSpool->hPrinter, 0)) {

            SetLastError(ReturnValue);
            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}


BOOL
KMClosePrinter(
    HANDLE  hPrinter)
{
    BOOL    ReturnValue;
    PSPOOL  pSpool = (PSPOOL)hPrinter;
    HANDLE  hPrinterKM;

    if (!ValidatePrinterHandle(hPrinter)) {
        return(FALSE);
    }

    DriverClosePrinterHook( pSpool );

    ENTER_WAIT_LIST();

    hPrinterKM = pSpool->hPrinter;

    FreeSplMem(pSpool);

    EXIT_WAIT_LIST();


    try {

        if (ReturnValue = YClosePrinter(&hPrinterKM, 0)) {

            SetLastError(ReturnValue);

            ReturnValue = FALSE;

        } else

            ReturnValue = TRUE;

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;

    }

    return ReturnValue;
}



BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    )
{
    PSPOOL pSpool = hPrinter;
    BOOL bReturnValue = FALSE;

    try {
        if ( pSpool && (pSpool->signature == SP_SIGNATURE)) {
            bReturnValue = TRUE;
        }
    } except (1) {
    }

    if ( !bReturnValue ) {
        SetLastError( ERROR_INVALID_HANDLE );
    }

    return bReturnValue;
}




BOOL
DriverWritePrinterHook(
    PSPOOL  pSpool,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{

    BOOL    ReturnValue;

    //  Some Printer Drivers want to push functionality out of kernel mode
    //  to achieve that we allow them to hook the calls to writeprinter from
    //  their Kernel Mode DLL to their User Mode Dll


    SPLASSERT( pSpool->hModule &&
               pSpool->pfnWrite &&
               pSpool->hDriver &&
               pSpool->hPrinter );


    try {

       ReturnValue = (BOOL) (*pSpool->pfnWrite)( pSpool->hDriver,
                                                 pBuf,
                                                 cbBuf,
                                                 pcWritten );

    } except(1) {

        SetLastError(TranslateExceptionCode(GetExceptionCode()));
        ReturnValue = FALSE;
        DBGMSG(DBG_ERROR, ("DrvWritePrinter Exception Error %d pSpool %x\n",GetLastError(), pSpool));
    }

    if ( !ReturnValue ) {
        SPLASSERT( GetLastError() );
    }

    return ReturnValue;
}


HANDLE
LoadPrinterDriver(
    PSPOOL  pSpool,
    PWCHAR  pUserModeDriverName
)
{
    PDRIVER_INFO_2  pDriverInfo;
    DWORD   cbNeeded;
    HANDLE  hModule= NULL;
    PWCHAR  pFileName;

    if (!GetPrinterDriver(pSpool->hPrinter, NULL, 2, NULL, 0, &cbNeeded)) {

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            // Allow for the size of the string passed in.

            cbNeeded += ( wcslen( pUserModeDriverName ) + 1 )* sizeof(WCHAR);

            if (pDriverInfo = (PDRIVER_INFO_2)AllocSplMem( cbNeeded )) {

                if (GetPrinterDriver(pSpool->hPrinter, NULL, 2, (LPBYTE)pDriverInfo,
                                     cbNeeded, &cbNeeded)) {

                    //
                    //  Driver Info 2 doesn't have the fully Qualified Path
                    //  to the UserModePrinterDriver.
                    //  So form it by taking replacine the UI DLL name with the
                    //  UseModePrinterDriverName

                    pFileName = wcsrchr( pDriverInfo->pConfigFile, L'\\');
                    pFileName++;

                    wcscpy( pFileName, pUserModeDriverName );

                    pFileName = pDriverInfo->pConfigFile;

                    DBGMSG( DBG_WARNING, ("UserModeDriverPath %ws\n", pFileName ));

                    hModule = LoadLibrary( pFileName );

                    if ( !hModule ) {
                        DBGMSG( DBG_WARNING, ("Failed to load %ws error %d\n", pFileName, GetLastError() ));
                    }

                }
                FreeSplMem(pDriverInfo);
            }
        }
    }


    if (hModule) {
        /*
	 * Need to redirect SPOOLSS.DLL function to WINSPOOL.DRV
	 */
        if (!TSsplHookSplssToWinspool(hModule)) {
	    DBGMSG(DBG_WARNING,("LoadPrinterDriver: TSsplHookSplssToWinspool returns Error=%ld. Cannot redirect!!!", GetLastError()));
        }
    }

    return hModule;
}



VOID
UnloadPrinterDriver(
    PSPOOL pSpool
)
{
    if ( pSpool->hModule ) {

        SPLASSERT( pSpool->hDriver == NULL );

        FreeLibrary( pSpool->hModule );
        pSpool->hModule = NULL;

        pSpool->pfnWrite = NULL;
        pSpool->pfnStartDoc = NULL;
        pSpool->pfnEndDoc = NULL;
        pSpool->pfnClose = NULL;
        pSpool->pfnStartPage = NULL;
        pSpool->pfnEndPage = NULL;
    }
}



DWORD
DriverStartDocHook(
    PSPOOL  pSpool,
    DWORD   JobId
)
{
    DWORD   dwReturn;
    WCHAR   UserModeDriverName[MAX_PATH];
    DWORD   dwNeeded;
    INT     cDriverName;
    BOOL    ReturnValue = FALSE;
    DWORD   Type;


    //
    //  Determine if there is a UserMode Printer Driver
    //

    dwReturn = GetPrinterDataW( pSpool->hPrinter,
                                SPLPRINTER_USER_MODE_PRINTER_DRIVER,
                                &Type,
                                (LPBYTE)&UserModeDriverName,
                                MAX_PATH,
                                &dwNeeded );

    if ( dwReturn != ERROR_SUCCESS ) {

        SPLASSERT( dwReturn != ERROR_INSUFFICIENT_BUFFER );
        ReturnValue = TRUE;
        goto Complete;
    }

    if ( Type != REG_SZ ) {
        SPLASSERT( Type == REG_SZ );
        goto Complete;
    }

    //  No String treat as success

    cDriverName = wcslen( UserModeDriverName );
    if ( !cDriverName ) {
        ReturnValue = TRUE;
        goto Complete;
    }


    //
    //  Load the UM Driver DLL
    //

    if ( pSpool->hModule == NULL ) {

        pSpool->hModule = LoadPrinterDriver( pSpool, UserModeDriverName );

        if ( pSpool->hModule == NULL ) goto Complete;
    }


    //
    //  Get Function Pointers
    //


    //  Required
    //
    pSpool->pfnWrite = (DWORD (*)()) GetProcAddress( pSpool->hModule, "DrvSplWritePrinter" );
    pSpool->pfnStartDoc = (HANDLE (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartDoc" );
    pSpool->pfnClose = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplClose" );
    pSpool->pfnEndDoc = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndDoc" );

    //  Optional
    //
    pSpool->pfnEndPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplEndPage" );
    pSpool->pfnStartPage = (BOOL (*)()) GetProcAddress( pSpool->hModule, "DrvSplStartPage" );
    pSpool->pfnAbort = (VOID (*)()) GetProcAddress( pSpool->hModule, "DrvSplAbort" );

    if (!( pSpool->pfnWrite)    ||
        !( pSpool->pfnStartDoc) ||
        !( pSpool->pfnClose)    ||
        !( pSpool->pfnEndDoc)) {

        goto Complete;
    }


    //
    //  Ask the Driver for a Handle for this print job
    //

    SPLASSERT( pSpool->hDriver == NULL );
    SPLASSERT( pSpool->hPrinter );
    SPLASSERT( JobId );

    pSpool->hDriver = (HANDLE)(*pSpool->pfnStartDoc)( pSpool->hPrinter, JobId );

    if ( pSpool->hDriver != NULL ) {
        ReturnValue = TRUE;
    }


Complete:

    if (!ReturnValue) {

        UnloadPrinterDriver( pSpool );

        // Cancel the outstanding job
        //
        // In the direct case
        //    AbortPrinter doesn't work
        //    SetJob _CANCEL doesn't work
        //    EndDocPrinter does work

        EndDocPrinter( pSpool->hPrinter );
        JobId = 0;
    }

    pSpool->JobId = JobId;

    return  JobId;
}


VOID
DriverEndDocHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        (*pSpool->pfnEndDoc)( pSpool->hDriver );
        (*pSpool->pfnClose)(pSpool->hDriver );
        pSpool->hDriver = NULL;
    }
}


BOOL
DriverStartPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnStartPage ){

        return (*pSpool->pfnStartPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


BOOL
DriverEndPageHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnEndPage ){

        return (*pSpool->pfnEndPage)( pSpool->hDriver );

    } else {

        return  TRUE;
    }
}


VOID
DriverAbortPrinterHook(
    PSPOOL  pSpool
)
{
    if ( pSpool->hDriver && pSpool->pfnAbort ){
        (*pSpool->pfnAbort)( pSpool->hDriver );
    }
}



VOID
DriverClosePrinterHook(
    PSPOOL pSpool
)
{
    if ( pSpool->hDriver ) {

        SPLASSERT( pSpool->pfnClose );

        (*pSpool->pfnClose)(pSpool->hDriver);
        pSpool->hDriver = NULL;
    }

    UnloadPrinterDriver( pSpool );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\umode\sources.inc ===
!include $(WINCORE_PATH)\core.inc

MAJORCOMP=ntos
MINORCOMP=w32

TARGETNAME=w32umode
TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBDIR)}

TARGETTYPE=LIBRARY

SYNCHRONIZE_BLOCK=1

SOURCES=

NTTARGETFILE0=$(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\services.tab \
              $(O)\usrstubs.$(ASM_SUFFIX)

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\yspool.h ===
void
MarshallDownStructure(
    LPBYTE lpStructure,
    LPDWORD lpOffsets
    );

DWORD
YOpenPrinter(
    LPWSTR pPrinterName,
    HANDLE *phPrinter,
    LPWSTR pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD AccessRequired,
    BOOL Rpc
    );

DWORD
YGetPrinter(
    HANDLE hPrinter,
    DWORD Level,
    LPBYTE pPrinter,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    BOOL Rpc
    );

DWORD
YGetPrinterDriver(
    HANDLE hPrinter,
    LPWSTR pEnvironment,
    DWORD Level,
    LPBYTE pDriverInfo,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    BOOL Rpc
    );

DWORD
YStartDocPrinter(
    HANDLE hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId,
    BOOL Rpc
    );

DWORD
YStartPagePrinter(
    HANDLE hPrinter,
    BOOL Rpc
    );

DWORD
YWritePrinter(
    HANDLE hPrinter,
    LPBYTE pBuf,
    DWORD cbBuf,
    LPDWORD pcWritten,
    BOOL Rpc
    );

DWORD
YEndPagePrinter(
    HANDLE hPrinter,
    BOOL Rpc
    );

DWORD
YAbortPrinter(
    HANDLE hPrinter,
    BOOL Rpc
    );

DWORD
YEndDocPrinter(
    HANDLE hPrinter,
    BOOL Rpc
    );

DWORD
YGetPrinterData(
    HANDLE hPrinter,
    LPTSTR pValueName,
    LPDWORD pType,
    LPBYTE pData,
    DWORD nSize,
    LPDWORD pcbNeeded,
    BOOL Rpc
    );

DWORD
YSetPrinterData(HANDLE hPrinter , LPTSTR pValueName , DWORD Type , LPBYTE pData , DWORD cbData , BOOL Rpc);

DWORD
YClosePrinter(LPHANDLE phPrinter , BOOL Rpc);

DWORD
YGetForm(PRINTER_HANDLE hPrinter , LPWSTR pFormName , DWORD Level , LPBYTE pForm , DWORD cbBuf , LPDWORD pcbNeeded , BOOL Rpc);

DWORD
YEnumForms(PRINTER_HANDLE hPrinter , DWORD Level , LPBYTE pForm , DWORD cbBuf , LPDWORD pcbNeeded , LPDWORD pcReturned , BOOL Rpc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\umode\makefile.inc ===
$(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\services.tab: $(WKMODE_PATH)\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(O)\usrstubs.obj: $(O)\usrstubs.$(ASM_SUFFIX)

$(O)\usrstubs.$(ASM_SUFFIX): $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\services.tab $(WKMODE_PATH)\$(TARGET_DIRECTORY)\table.stb $(WKMODE_PATH)\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(O) $(TARGET_BRACES) -C -R -s $(WKMODE_PATH)\$(TARGET_DIRECTORY) $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\termspl\yspool.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    yspool.c

        This file was duplicated from private\windows\spooler\spoolss\server\yspool.c
        Only useful functions have been kept (only those that go through the GDI message queue)

Abstract:

    This module provides all the public exported APIs relating to Printer
    and Job management for the Print Providor Routing layer

Author:

    Dave Snipp (DaveSn) 15-Mar-1991

[Notes:]

    optional-notes

Revision History:

    swilson    1-Jun-95     Converted winspool.c to yspool: the merging point of KM & RPC paths
        Nicolas Biju-Duval      Dec-97  Adaptation for Hydra :
                                                                        - call to winspool.drv functions
                                                                        - removed all useless stuff (since we only deal with KM requests)

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddrdr.h>
#include <stdio.h>
#include <windows.h>
#include <winspool.h>

#include <winspl.h>

#define MIN_DEVMODE_SIZEW 72
#define MIN_DEVMODE_SIZEA 40

//
// We must define these to get the data arrays in data.h to
// load. This avoids a multiple definition problem.
//
#define PRINTER_OFFSETS 1
#define JOB_OFFSETS     1
#define DRIVER_OFFSETS  1
#define FORM_OFFSETS    1
#define ADDJOB_OFFSETS  1
#define FORM_OFFSETS    1
#define PORT_OFFSETS    1
#define PRINTPROCESSOR_OFFSETS 1
#define MONITOR_OFFSETS 1
#define DATATYPE_OFFSETS 1

#include <data.h>

//
// Remove their macros...
//
#undef DBG_TIME
#undef DBGMSG
#undef SPLASSERT
#undef AllocSplMem
#undef FreeSplMem

#include "wingdip.h"
#include "musspl.h"

DWORD   ServerHandleCount = 0;

BOOL
InvalidDevModeContainer(
    LPDEVMODE_CONTAINER pDevModeContainer
    )
{
    PDEVMODE    pDevMode = (PDEVMODE) pDevModeContainer->pDevMode;
    DWORD       dwSize = pDevMode ? pDevMode->dmSize + pDevMode->dmDriverExtra : 0;

    return dwSize != (DWORD)pDevModeContainer->cbBuf ||
           ( dwSize && dwSize < MIN_DEVMODE_SIZEW );
}


void
MarshallDownStructure(
   LPBYTE   lpStructure,
   LPDWORD  lpOffsets
)
{
    register DWORD       i=0;

    if (!lpStructure)
        return;

    while (lpOffsets[i] != -1) {

        if ((*(LPBYTE*)(lpStructure+lpOffsets[i]))) {
            (*(LPBYTE*)(lpStructure+lpOffsets[i]))-=(UINT_PTR)lpStructure;
        }

        i++;
    }
}


DWORD
YOpenPrinter(
    LPWSTR              pPrinterName,
    HANDLE             *phPrinter,
    LPWSTR              pDatatype,
    LPDEVMODE_CONTAINER pDevModeContainer,
    DWORD               AccessRequired,
    BOOL                bRpc
)
{
    PRINTER_DEFAULTS  Defaults;
    BOOL              bRet;

    if ( InvalidDevModeContainer(pDevModeContainer) ) {
        return ERROR_INVALID_PARAMETER;
    }

    Defaults.pDatatype = pDatatype;

    Defaults.pDevMode = (LPDEVMODE)pDevModeContainer->pDevMode;

    Defaults.DesiredAccess = AccessRequired;

    bRet = OpenPrinter(pPrinterName, phPrinter, &Defaults);

    if (bRet) {
        InterlockedIncrement ( &ServerHandleCount );
        return ERROR_SUCCESS;
    } else {
        *phPrinter = NULL;
        return GetLastError();
    }
        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YGetPrinter(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    BOOL    bRpc
)
{
    BOOL  ReturnValue;
    DWORD   *pOffsets;

    *pcbNeeded = 0;
    switch (Level) {

    case STRESSINFOLEVEL:
        pOffsets = PrinterInfoStressOffsets;
        break;

    case 1:
        pOffsets = PrinterInfo1Offsets;
        break;

    case 2:
        pOffsets = PrinterInfo2Offsets;
        break;

    case 3:
        pOffsets = PrinterInfo3Offsets;
        break;

    case 4:
        pOffsets = PrinterInfo4Offsets;
        break;

    case 5:
        pOffsets = PrinterInfo5Offsets;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // HACK for 3.51: Catch bad parameters passed across the wire.
    // If the buffer passed is > 1 MEG, fail the call.
    //
    if( cbBuf > 0x100000 ){

        DBGMSG( DBG_ERROR,
                ( "** GetPrinter: cbBuf is 0x%x !! Contact VibhasC and AlbertT **\n", cbBuf ));

        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    ReturnValue = GetPrinter(hPrinter, Level, pPrinter, cbBuf, pcbNeeded);

    if (ReturnValue) {

         MarshallDownStructure(pPrinter, pOffsets);

         return ERROR_SUCCESS;

    } else

         return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}


DWORD
YStartDocPrinter(
    HANDLE  hPrinter,
    LPDOC_INFO_CONTAINER pDocInfoContainer,
    LPDWORD pJobId,
    BOOL    bRpc
)
{
    LPWSTR pChar;

    if( pDocInfoContainer->Level != 1 ){
        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    try {
        if( pDocInfoContainer->DocInfo.pDocInfo1->pDocName ){

            for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDocName;
                 *pChar;
                 ++pChar )
                ;
        }

        if( pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile ){

            for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pOutputFile;
                 *pChar;
                 ++pChar )
                ;
        }

        if( pDocInfoContainer->DocInfo.pDocInfo1->pDatatype ){

            for( pChar = pDocInfoContainer->DocInfo.pDocInfo1->pDatatype;
                 *pChar;
                 ++pChar )
                ;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ){

        RaiseException( ERROR_INVALID_USER_BUFFER,
                        EXCEPTION_NONCONTINUABLE,
                        0,
                        NULL );
    }

    *pJobId = StartDocPrinter(hPrinter, pDocInfoContainer->Level,
                              (LPBYTE)pDocInfoContainer->DocInfo.pDocInfo1);

    if (*pJobId)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YStartPagePrinter(
   HANDLE hPrinter,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = StartPagePrinter(hPrinter);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YWritePrinter(
    HANDLE  hPrinter,
    LPBYTE  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = WritePrinter(hPrinter, pBuf, cbBuf, pcWritten);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YEndPagePrinter(
    HANDLE  hPrinter,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = EndPagePrinter(hPrinter);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YAbortPrinter(
    HANDLE  hPrinter,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = AbortPrinter(hPrinter);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YEndDocPrinter(
    HANDLE  hPrinter,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = EndDocPrinter(hPrinter);

    if (bRet)
        return ERROR_SUCCESS;
    else
        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}


DWORD
YGetPrinterData(
   HANDLE   hPrinter,
   LPTSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded,
    BOOL    bRpc
)
{
    DWORD dwRet;

    dwRet = GetPrinterData(hPrinter, pValueName, pType,
                           pData, nSize, pcbNeeded);

    return dwRet;

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YSetPrinterData(
    HANDLE  hPrinter,
    LPTSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData,
    BOOL    bRpc
)
{
    DWORD dwRet;

    dwRet = SetPrinterData(hPrinter, pValueName, Type, pData, cbData);

    return dwRet;

        UNREFERENCED_PARAMETER(bRpc);
}

DWORD
YClosePrinter(
   LPHANDLE phPrinter,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = ClosePrinter(*phPrinter);

    *phPrinter = NULL;  // NULL out handle so bRpc knows to close it down.

    if (bRet) {

        InterlockedDecrement( &ServerHandleCount );
        return ERROR_SUCCESS;

    } else

        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}


DWORD
YGetForm(
    PRINTER_HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD Level,
    LPBYTE pForm,
    DWORD cbBuf,
    LPDWORD pcbNeeded,
    BOOL    bRpc
)
{
    BOOL bRet;

    bRet = GetForm(hPrinter, pFormName, Level, pForm, cbBuf, pcbNeeded);

    if (bRet) {

        MarshallDownStructure(pForm, FormInfo1Offsets);

        return ERROR_SUCCESS;

    } else

        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}


DWORD
YEnumForms(
   PRINTER_HANDLE hPrinter,
   DWORD    Level,
   LPBYTE   pForm,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded,
   LPDWORD  pcReturned,
    BOOL    bRpc
)
{
    BOOL  bRet;
    DWORD cReturned, cbStruct;
    DWORD *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = FormInfo1Offsets;
        cbStruct = sizeof(FORM_INFO_1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    bRet = EnumForms(hPrinter, Level, pForm, cbBuf, pcbNeeded, pcReturned);

    if (bRet) {

        cReturned=*pcReturned;

        while (cReturned--) {

            MarshallDownStructure(pForm, pOffsets);

            pForm+=cbStruct;
        }

        return ERROR_SUCCESS;

    } else

        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}




DWORD
YGetPrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    BOOL    bRpc
)
{
    DWORD *pOffsets;
    BOOL   bRet;

    switch (Level) {

    case 1:
        pOffsets = DriverInfo1Offsets;
        break;

    case 2:
        pOffsets = DriverInfo2Offsets;
        break;

    case 3:
        pOffsets = DriverInfo3Offsets;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // Hack-Hack-Hack  to determine if we want the most recent driver
    //

    bRet = GetPrinterDriverW(hPrinter, pEnvironment, Level, pDriverInfo,
                                cbBuf, pcbNeeded);

    if (bRet) {

        MarshallDownStructure(pDriverInfo, pOffsets);

        return ERROR_SUCCESS;

    } else

        return GetLastError();

        UNREFERENCED_PARAMETER(bRpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\heap.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This module contains private heap functions used by USER, WIN32K and WINSRV

Author:

    Corneliu Lupu (clupu) 16-Nov-1998

Revision History:

--*/

#ifndef _WIN32_HEAP_H_
#define _WIN32_HEAP_H_

#include "nturtl.h"

// Max number of heaps per process
#define MAX_HEAPS               64

// WIN32HEAP flags
#define WIN32_HEAP_INUSE        0x00000001
#define WIN32_HEAP_USE_GUARDS   0x00000002
#define WIN32_HEAP_FAIL_ALLOC   0x00000004
#define WIN32_HEAP_USE_HM_TAGS  0x00000008

// max size of the head and tail strings
#define HEAP_CHECK_SIZE         8

#define HEAP_ALLOC_TRACE_SIZE   6
#define HEAP_ALLOC_MARK         0xDADADADA

#if i386 && !FPO
#define HEAP_ALLOC_TRACE
#endif

typedef struct tagWIN32HEAP* PWIN32HEAP;

typedef struct tagDbgHeapHead  {
    ULONG       mark;
    ULONG       tag;
    PWIN32HEAP  pheap;
    SIZE_T      size;               // the size of the allocation (doesn't include
                                    // neither this structure nor the head and
                                    // tail strings)

    struct tagDbgHeapHead * pPrev;  // pointer to the previous allocation in the heap
    struct tagDbgHeapHead * pNext;  // pointer to the next allocation in the heap

#ifdef HEAP_ALLOC_TRACE
    PVOID       trace[HEAP_ALLOC_TRACE_SIZE];
#endif // HEAP_ALLOC_TRACE

} DbgHeapHead , *PDbgHeapHead ;

typedef struct tagWIN32HEAP {

    PVOID                   heap;
    DWORD                   dwFlags;
    char                    szHead[HEAP_CHECK_SIZE];
    char                    szTail[HEAP_CHECK_SIZE];
    SIZE_T                  heapReserveSize;
    SIZE_T                  crtMemory;
    SIZE_T                  crtAllocations;
    SIZE_T                  maxMemory;
    SIZE_T                  maxAllocations;
#ifdef _USERK_
    FAST_MUTEX*             pFastMutex;
#else
    RTL_CRITICAL_SECTION    critSec;
#endif
    PDbgHeapHead            pFirstAlloc;

} WIN32HEAP, *PWIN32HEAP;

#define RECORD_HEAP_STACK_TRACE_SIZE    6

typedef struct tagHEAPRECORD {
    PVOID      p;
    PWIN32HEAP pheap;
    SIZE_T     size;
    PVOID      trace[RECORD_HEAP_STACK_TRACE_SIZE];
} HEAPRECORD, *PHEAPRECORD;

/*
 * Heap Functions
 */

#if DBG

    PVOID Win32HeapGetHandle(
        PWIN32HEAP pheap);

    ULONG Win32HeapCreateTag(
        PWIN32HEAP pheap,
        ULONG      Flags,
        PWSTR      TagPrefix,
        PWSTR      TagNames);

    PWIN32HEAP Win32HeapCreate(
        char*                pszHead,
        char*                pszTail,
        ULONG                Flags,
        PVOID                HeapBase,
        SIZE_T               ReserveSize,
        SIZE_T               CommitSize,
        PVOID                Lock,
        PRTL_HEAP_PARAMETERS Parameters);

    BOOL Win32HeapDestroy(
        PWIN32HEAP  pheap);

    PVOID Win32HeapAlloc(
        PWIN32HEAP pheap,
        SIZE_T     uSize,
        ULONG      tag,
        ULONG      Flags);

    BOOL Win32HeapFree(
        PWIN32HEAP pheap,
        PVOID      p);

    BOOL Win32HeapCheckAlloc(
        PWIN32HEAP    pheap,
        PVOID         p);

    VOID Win32HeapDump(
        PWIN32HEAP pheap);

    VOID Win32HeapFailAllocations(
        BOOL       bFail);

    SIZE_T Win32HeapSize(
        PWIN32HEAP pheap,
        PVOID      p);

    PVOID Win32HeapReAlloc(
        PWIN32HEAP pheap,
        PVOID      p,
        SIZE_T     uSize,
        ULONG      Flags);

    BOOL Win32HeapValidate(
        PWIN32HEAP pheap);

    BOOL InitWin32HeapStubs(
        VOID);

    VOID CleanupWin32HeapStubs(
        VOID);

#else // !DBG

    #define Win32HeapGetHandle(pheap)   ((PVOID)(pheap))

    ULONG __inline Win32HeapCreateTag(
        PWIN32HEAP pheap,
        ULONG      Flags,
        PWSTR      TagPrefix,
        PWSTR      TagNames)
    {
#ifndef _USERK_
        return RtlCreateTagHeap((PVOID)pheap, Flags, TagPrefix, TagNames);
#else
        return 0;
#endif
    }

    PWIN32HEAP __inline Win32HeapCreate(
        char*                pszHead,
        char*                pszTail,
        ULONG                Flags,
        PVOID                HeapBase,
        SIZE_T               ReserveSize,
        SIZE_T               CommitSize,
        PVOID                Lock,
        PRTL_HEAP_PARAMETERS Parameters)
    {
        return RtlCreateHeap(Flags,
                             HeapBase,
                             ReserveSize,
                             CommitSize,
                             Lock,
                             Parameters);

        UNREFERENCED_PARAMETER(pszHead);
        UNREFERENCED_PARAMETER(pszTail);
    }

    BOOL __inline Win32HeapDestroy(PWIN32HEAP pheap)
    {
        RtlDestroyHeap((PVOID)pheap);
        return TRUE;
    }

    PVOID __inline Win32HeapAlloc(PWIN32HEAP pheap, SIZE_T uSize, ULONG tag, ULONG Flags)
    {
        return RtlAllocateHeap((PVOID)pheap, Flags, uSize);

        UNREFERENCED_PARAMETER(tag);
    }

    BOOL __inline Win32HeapFree(PWIN32HEAP pheap, PVOID p)
    {
        return RtlFreeHeap((PVOID)pheap, 0, p);
    }

    #define Win32HeapCheckAlloc(pheap, p)

    #define Win32HeapDump(pheap)

    #define Win32HeapFailAllocations(pheap, bFail)

    SIZE_T __inline Win32HeapSize(PWIN32HEAP pheap, PVOID p)
    {
        return RtlSizeHeap((PVOID)pheap, 0, p);
    }

    PVOID __inline Win32HeapReAlloc(
        PWIN32HEAP pheap,
        PVOID      p,
        SIZE_T     uSize,
        ULONG      Flags)
    {
        return RtlReAllocateHeap((PVOID)pheap, Flags, p, uSize);
    }

    BOOL __inline Win32HeapValidate(PWIN32HEAP pheap)
    {
#ifndef _USERK_
        return RtlValidateHeap((PVOID)pheap, 0, NULL);
#else
        return TRUE;
#endif // _USERK_
    }

    #define InitWin32HeapStubs()    TRUE
    #define CleanupWin32HeapStubs()

#endif // DBG

#endif // _WIN32_HEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\asdf.h ===
/****************************** Module Header ******************************\
* Copyright (c) 1991-1998 Microsoft Corporation
*
* Module Name: ASDF.H
*
* This header contains all structures and constants needed for manipulating
* ASDF format data files.
*
* History:
* 10-02-91 DarrinM      Created.
* 08-17-92 DarrinM      Recreated in a RIFF compatible fashion.
\***************************************************************************/

#include <mmsystem.h>

// RIFF chunk header.

typedef struct _RTAG {
    FOURCC ckID;
    DWORD ckSize;
} RTAG, *PRTAG;


// Valid TAG types.

// 'ANI ' - simple ANImation file

#define FOURCC_ACON  mmioFOURCC('A', 'C', 'O', 'N')


// 'anih' - ANImation Header
// Contains an ANIHEADER structure.

#define FOURCC_anih mmioFOURCC('a', 'n', 'i', 'h')


// 'rate' - RATE table (array of jiffies)
// Contains an array of JIFs.  Each JIF specifies how long the corresponding
// animation frame is to be displayed before advancing to the next frame.
// If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
// otherwise the count == anih.cFrames.

#define FOURCC_rate mmioFOURCC('r', 'a', 't', 'e')


// 'seq ' - SEQuence table (array of frame index values)
// Countains an array of DWORD frame indices.  anih.cSteps specifies how
// many.

#define FOURCC_seq  mmioFOURCC('s', 'e', 'q', ' ')


// 'fram' - list type for the icon list that follows

#define FOURCC_fram mmioFOURCC('f', 'r', 'a', 'm')

// 'icon' - Windows ICON format image (replaces MPTR)

#define FOURCC_icon mmioFOURCC('i', 'c', 'o', 'n')


// Standard tags (but for some reason not defined in MMSYSTEM.H)

#define FOURCC_INFO mmioFOURCC('I', 'N', 'F', 'O')      // INFO list
#define FOURCC_IART mmioFOURCC('I', 'A', 'R', 'T')      // Artist
#define FOURCC_INAM mmioFOURCC('I', 'N', 'A', 'M')      // Name/Title

#if 0 //in winuser.w
typedef DWORD JIF;  // in winuser.w

typedef struct _ANIHEADER {     // anih
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

// If the AF_ICON flag is specified the fields cx, cy, cBitCount, and
// cPlanes are all unused.  Each frame will be of type ICON and will
// contain its own dimensional information.

#define AF_ICON     0x0001L     // Windows format icon/cursor animation

#define AF_SEQUENCE 0x0002L     // Animation is sequenced
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\immuser.h ===
/****************************** Module Header ******************************\
* Module Name: immuser.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains the internal IMM structure definitions for
* the user mode USER32/IMM32.
*
* History:
* 25-Mar-1996 TakaoK        Split from immstruc.h
\***************************************************************************/
#ifndef _IMMUSER_
#define _IMMUSER_

#include <imm.h>
#include <immp.h>
#include <ime.h>
#include <imep.h>

/*
 * Client side input context structure.
 */
typedef struct tagCLIENTIMC {
    HANDLE hInputContext;
    LONG   cLockObj;
    DWORD  dwFlags;
    DWORD  dwImeCompatFlags;    // win95 compatible application compat flags
    RTL_CRITICAL_SECTION cs;
    DWORD  dwCodePage;
    HKL    SelectedHKL;
#ifdef CUAS_ENABLE
    BOOL   fCtfImeContext;
#endif
} CLIENTIMC, *PCLIENTIMC;

#define InitImcCrit(pClientImc)     RtlInitializeCriticalSection(&pClientImc->cs)
#define DeleteImcCrit(pClientImc)   RtlDeleteCriticalSection(&pClientImc->cs)
#define EnterImcCrit(pClientImc)    RtlEnterCriticalSection(&pClientImc->cs)
#define LeaveImcCrit(pClientImc)    RtlLeaveCriticalSection(&pClientImc->cs)

/*
 * IME Dispatch Processing Interface
 */
typedef BOOL    (CALLBACK* PFNINQUIREA)(LPIMEINFO, LPSTR,  DWORD);
typedef BOOL    (CALLBACK* PFNINQUIREW)(LPIMEINFO, LPWSTR, DWORD);
typedef DWORD   (CALLBACK* PFNCONVLISTA)(HIMC, LPCSTR,  LPCANDIDATELIST, DWORD, UINT);
typedef DWORD   (CALLBACK* PFNCONVLISTW)(HIMC, LPCWSTR, LPCANDIDATELIST, DWORD, UINT);
typedef BOOL    (CALLBACK* PFNREGWORDA)(LPCSTR,  DWORD, LPCSTR);
typedef BOOL    (CALLBACK* PFNREGWORDW)(LPCWSTR, DWORD, LPCWSTR);
typedef BOOL    (CALLBACK* PFNUNREGWORDA)(LPCSTR,  DWORD, LPCSTR);
typedef BOOL    (CALLBACK* PFNUNREGWORDW)(LPCWSTR, DWORD, LPCWSTR);
typedef UINT    (CALLBACK* PFNGETREGWORDSTYA)(UINT, LPSTYLEBUFA);
typedef UINT    (CALLBACK* PFNGETREGWORDSTYW)(UINT, LPSTYLEBUFW);
typedef UINT    (CALLBACK* PFNENUMREGWORDA)(REGISTERWORDENUMPROCA, LPCSTR,  DWORD, LPCSTR,  LPVOID);
typedef UINT    (CALLBACK* PFNENUMREGWORDW)(REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, LPVOID);
typedef BOOL    (CALLBACK* PFNCONFIGURE)(HKL, HWND, DWORD, LPVOID);
typedef BOOL    (CALLBACK* PFNDESTROY)(UINT);
typedef LRESULT (CALLBACK* PFNESCAPE)(HIMC, UINT, LPVOID);
typedef BOOL    (CALLBACK* PFNPROCESSKEY)(HIMC, UINT, LPARAM, CONST LPBYTE);
typedef BOOL    (CALLBACK* PFNSELECT)(HIMC, BOOL);
typedef BOOL    (CALLBACK* PFNSETACTIVEC)(HIMC, BOOL);
typedef UINT    (CALLBACK* PFNTOASCEX)(UINT, UINT, CONST LPBYTE, PTRANSMSGLIST, UINT, HIMC);
typedef BOOL    (CALLBACK* PFNNOTIFY)(HIMC, DWORD, DWORD, DWORD);
typedef BOOL    (CALLBACK* PFNSETCOMPSTR)(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
typedef DWORD   (CALLBACK* PFNGETIMEMENUITEMS)(HIMC, DWORD, DWORD, LPVOID, LPVOID, DWORD);

#ifdef CUAS_ENABLE
/*
 * IME Dispatch Processing Interface for Cicero Unaware Apps Support.
 */
typedef BOOL    (CALLBACK* PFNINQUIREEXW)(LPIMEINFO, LPWSTR, DWORD, HKL);
typedef HRESULT (CALLBACK* PFNSELECTEX)(HIMC, BOOL, HKL);
typedef LRESULT (CALLBACK* PFNESCAPEEX)(HIMC, UINT, LPVOID, HKL);
typedef HRESULT (CALLBACK* PFNGETGUIDATOM)(HIMC, BYTE, DWORD*);
typedef BOOL    (CALLBACK* PFNISGUIDMAPENABLE)(HIMC);
#endif // CUAS_ENABLE

#define IMEDPI_UNLOADED      1
#define IMEDPI_UNLOCKUNLOAD  2

typedef struct tagIMEDPI {
    struct tagIMEDPI   *pNext;
    HANDLE              hInst;
    HKL                 hKL;
    IMEINFO             ImeInfo;
    DWORD               dwCodePage;
    WCHAR               wszUIClass[IM_UI_CLASS_SIZE];
    DWORD               cLock;
    DWORD               dwFlag;

    struct _tagImeFunctions {
        union {PFNINQUIREA       a; PFNINQUIREW       w; PVOID t;} ImeInquire;
        union {PFNCONVLISTA      a; PFNCONVLISTW      w; PVOID t;} ImeConversionList;
        union {PFNREGWORDA       a; PFNREGWORDW       w; PVOID t;} ImeRegisterWord;
        union {PFNUNREGWORDA     a; PFNUNREGWORDW     w; PVOID t;} ImeUnregisterWord;
        union {PFNGETREGWORDSTYA a; PFNGETREGWORDSTYW w; PVOID t;} ImeGetRegisterWordStyle;
        union {PFNENUMREGWORDA   a; PFNENUMREGWORDW   w; PVOID t;} ImeEnumRegisterWord;
        PFNCONFIGURE                                               ImeConfigure;
        PFNDESTROY                                                 ImeDestroy;
        PFNESCAPE                                                  ImeEscape;
        PFNPROCESSKEY                                              ImeProcessKey;
        PFNSELECT                                                  ImeSelect;
        PFNSETACTIVEC                                              ImeSetActiveContext;
        PFNTOASCEX                                                 ImeToAsciiEx;
        PFNNOTIFY                                                  NotifyIME;
        PFNSETCOMPSTR                                              ImeSetCompositionString;
        PFNGETIMEMENUITEMS                                         ImeGetImeMenuItems;

#ifdef CUAS_ENABLE
        PFNINQUIREEXW                                              CtfImeInquireExW; // Unicode only
        PFNSELECTEX                                                CtfImeSelectEx;
        PFNESCAPEEX                                                CtfImeEscapeEx;
        PFNGETGUIDATOM                                             CtfImeGetGuidAtom;
        PFNISGUIDMAPENABLE                                         CtfImeIsGuidMapEnable;
#endif // CUAS_ENABLE

    } pfn;

} IMEDPI, *PIMEDPI;

/*
 * IME Mode Saver
 */

typedef struct tagIMEPRIVATESAVER {
    struct tagIMEPRIVATESAVER* next;
    HKL hkl;
    DWORD fdwSentence;
} IMEPRIVATEMODESAVER, *PIMEPRIVATEMODESAVER;

typedef struct tagIMEMODESAVER {
    struct tagIMEMODESAVER* next;
    USHORT langId;                  // Primary LangId
    BOOLEAN fOpen;
    DWORD fdwConversion;
    DWORD fdwSentence;
    DWORD fdwInit;
    PIMEPRIVATEMODESAVER pImePrivateModeSaver;
} IMEMODESAVER, *PIMEMODESAVER;


/*
 * Private client side routines in IMM32.DLL.
 */
BOOL ImmSetActiveContext(
    HWND hWnd,
    HIMC hImc,
    BOOL fActivate);

BOOL WINAPI ImmLoadIME(
    HKL hKL);

BOOL WINAPI ImmUnloadIME(
    HKL hKL);

BOOL WINAPI ImmFreeLayout(
    DWORD dwFlag);

BOOL WINAPI ImmActivateLayout(
    HKL    hSelKL);

BOOL WINAPI ImmLoadLayout(
    HKL        hKL,
    PIMEINFOEX piiex);

BOOL WINAPI ImmDisableIme(
    DWORD dwThreadId);

PCLIENTIMC WINAPI ImmLockClientImc(
    HIMC hImc);

VOID WINAPI ImmUnlockClientImc(
    PCLIENTIMC pClientImc);

PIMEDPI WINAPI ImmLockImeDpi(
    HKL hKL);

VOID WINAPI ImmUnlockImeDpi(
    PIMEDPI pImeDpi);

BOOL WINAPI ImmGetImeInfoEx(
    PIMEINFOEX piiex,
    IMEINFOEXCLASS SearchType,
    PVOID pvSearchKey);

DWORD WINAPI ImmProcessKey(
    HWND hWnd,
    HKL  hkl,
    UINT uVKey,
    LPARAM lParam,
    DWORD dwHotKeyID);

BOOL ImmTranslateMessage(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam);

VOID ImmInitializeHotKeys( BOOL bUserLoggedOn );

#ifdef CUAS_ENABLE

HRESULT CtfImmTIMActivate(HKL hKL);

HRESULT CtfImmCoInitialize();

void CtfImmCoUninitialize();

#endif // CUAS_ENABLE

#endif // _IMMUSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\umode\wow6432\makefile.inc ===
GUISVC_TAB=$(O)\guisvc32.tab

clean:
    -del $(GUISVC_TAB)

$(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\services.tab: $(WKMODE_PATH)\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

$(GUISVC_TAB): $(WKMODE_PATH)\services.tab
    $(C_PREPROCESSOR) $** > $@
    binplace $@

$(O)\usrstubs.obj: $(O)\usrstubs.$(ASM_SUFFIX)

$(O)\usrstubs.$(ASM_SUFFIX): $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)\services.tab $(WKMODE_PATH)\$(ALT_PROJECT)\$(TARGET_DIRECTORY)\table.stb $(WKMODE_PATH)\$(ALT_PROJECT)\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) $(TARGET_BRACES) -C -R -s $(WKMODE_PATH)\$(ALT_PROJECT)\$(TARGET_DIRECTORY) $(WUMODE_PATH)\$(ALT_PROJECT)\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

TARGETSRCS=w32inc\ptag.h \
           w32inc\dbgtag.h

NTUSR_KRNL=..\ntuser\kernel

$(O)\ptag.h: $(NTUSR_KRNL)\ptag.tpl $(NTUSR_KRNL)\ptag.lst $(NTUSR_KRNL)\ptag.bat
    listmung $(NTUSR_KRNL)\ptag.lst $(NTUSR_KRNL)\ptag.tpl > $(O)\ptag.tmp
    $(NTUSR_KRNL)\ptag.bat $(O)\ptag.tmp $(O)\ptag.h
    @del $(O)\ptag.tmp

$(O)\dbgtag.h: dbgtag.lst dbgtag.tpl dbgtag.bat
    listmung dbgtag.lst dbgtag.tpl > $(O)\dbgtag.tmp
    dbgtag.bat $(O)\dbgtag.tmp $(O)\dbgtag.h
    @del $(O)\dbgtag.tmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\gre.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    gre.h

Abstract:

    This module contains private GDI functions used by USER
    All of these function are named GRExxx.

Author:

    Andre Vachon (andreva) 19-Apr-1995

Revision History:

--*/

#include "w32wow64.h"


DECLARE_HANDLE(HOBJ);
DECLARE_KHANDLE(HOBJ);
DECLARE_HANDLE(HLFONT);



#define GGB_ENABLE_WINMGR       0x00000001
#define GGB_DISABLE_WINMGR      0x00000002

#define ULW_NOREPAINT           0x80000000
#define ULW_DEFAULT_ATTRIBUTES  0x40000000
#define ULW_NEW_ATTRIBUTES      0x20000000

//
// Various owner ship functions
//

// GDI object ownership flags
// Note that normal process IDs (executive handles) use the upper 30 bits
// of the handle.  We set the second bit to 1 in the PIDs below so that
// they will not conflict with normal PIDs.  The lowest bit is reserved for
// the OBJECTOWNER lock.

#define OBJECT_OWNER_ERROR   ( 0x80000022)
#define OBJECT_OWNER_PUBLIC  ( 0x00000000)
#define OBJECT_OWNER_CURRENT ( 0x80000002)
#define OBJECT_OWNER_NONE    ( 0x80000012)

//
// WINBUG #83303 2-8-2000 bhouse Investigate old comment
// Old Comment:
//    -  make these functions call direct to NtGdi
//

#define GrePatBlt NtGdiPatBlt
BOOL  APIENTRY GrePatBlt(HDC,int,int,int,int,DWORD);

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifndef _WINDOWBLT_NOTIFICATION_
#define _WINDOWBLT_NOTIFICATION_
#endif
#ifdef _WINDOWBLT_NOTIFICATION_
    // Flags passed to NtGdiBitBlt:
    #define GBB_WINDOWBLT   0x00000001

    #define GreBitBlt(a,b,c,d,e,f,g,h,i,j) NtGdiBitBlt((a),(b),(c),(d),(e),(f),(g),(h),(i),(j),0)
    BOOL  APIENTRY NtGdiBitBlt(HDC,int,int,int,int,HDC,int,int,DWORD,DWORD,FLONG);
#else
    #define GreBitBlt NtGdiBitBlt
    BOOL  APIENTRY GreBitBlt(HDC,int,int,int,int,HDC,int,int,DWORD,DWORD);
#endif

typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;

BOOL
GrePolyPatBlt(
    HDC  hdc,
    DWORD rop,
    PPOLYPATBLT pPoly,
    DWORD Count,
    DWORD Mode);

//
// Owner APIs
//

BOOL
GreSetBrushOwner(
    HBRUSH hbr,
    W32PID lPid
    );

#define GreSetBrushOwnerPublic(x) GreSetBrushOwner((x), OBJECT_OWNER_PUBLIC)

BOOL
GreSetDCOwner(
    HDC  hdc,
    W32PID lPid
    );

BOOL
GreSetBitmapOwner(
    HBITMAP hbm,
    W32PID lPid
    );

HBITMAP
GreMakeBitmapStock(
    HBITMAP hbm);

HBITMAP
GreMakeBitmapNonStock(
    HBITMAP hbm);

HBRUSH
GreMakeBrushStock(
    HBRUSH hbr);

HBRUSH
GreMakeBrushNonStock(
    HBRUSH hbr);

W32PID
GreGetObjectOwner(
    HOBJ hobj,
    DWORD objt
    );

BOOL
GreSetLFONTOwner(
    HLFONT hlfnt,
    W32PID lPid
    );

BOOL
GreSetRegionOwner(
    HRGN hrgn,
    W32PID lPid
    );

int
GreSetMetaRgn(
    HDC
    );

HRGN APIENTRY NtGdiCreateRoundRectRgn(int, int, int, int, int, int);
BOOL APIENTRY NtGdiFrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL APIENTRY NtGdiRoundRect(HDC, int, int, int, int, int, int);
BOOL
GreSetPaletteOwner(
    HPALETTE hpal,
    W32PID lPid
    );

BOOL
GreWindowInsteadOfClient(
    PVOID pwo
    );

//
// Mark Global APIS
//
VOID
GreSetBrushGlobal(HBRUSH hbr);

//
// Mark Delete\Undelete APIS
//

VOID
GreMarkDeletableBrush(
    HBRUSH hbr
    );

VOID
GreMarkUndeletableBrush(
    HBRUSH hbr
    );

VOID
GreMarkUndeletableDC(
    HDC hdc
    );

VOID
GreMarkDeletableDC(
    HDC hdc
    );

VOID
GreMarkUndeletableFont(
    HFONT hfnt
    );

VOID
GreMarkDeletableFont(
    HFONT hfnt
    );

BOOL
GreMarkUndeletableBitmap(
    HBITMAP hbm
    );

BOOL
GreMarkDeletableBitmap(
    HBITMAP hbm
    );

ULONG
GreGetFontEnumeration(
    );

ULONG
GreGetFontContrast(
    );

VOID
GreLockDisplay(
    HDEV hdev
    );

VOID
GreUnlockDisplay(
    HDEV hdev
    );

#if DBG
BOOL
GreIsDisplayLocked(
    HDEV hdev
    );

VOID
GreValidateVisrgn(
    HDC hdc,
    BOOL bValidateVisrgn
    );
#endif


BOOL  APIENTRY bSetDevDragRect(HDEV, RECTL*, RECTL *);
BOOL  APIENTRY bSetDevDragWidth(HDEV, ULONG);
BOOL  APIENTRY bMoveDevDragRect(HDEV, RECTL*);

ULONG_PTR APIENTRY GreSaveScreenBits(HDEV hdev, ULONG iMode, ULONG_PTR iIdent, RECTL *prcl);
typedef struct _CURSINFO *PCURSINFO;
VOID  APIENTRY GreSetPointer(HDEV hdev,PCURSINFO pci,ULONG fl, ULONG ulTrailLength, ULONG ulFreq);

VOID  APIENTRY GreMovePointer(HDEV hdev,int x,int y, ULONG ulFlags);

//
// Vis region calls
//

typedef enum _VIS_REGION_SELECT {
    SVR_DELETEOLD = 1,
    SVR_COPYNEW,
    SVR_ORIGIN,
    SVR_SWAP,
} VIS_REGION_SELECT;

BOOL
GreSelectVisRgn(
    HDC               hdc,
    HRGN              hrgn,
    VIS_REGION_SELECT fl
    );

BOOL
GreGetDCOrgEx(
    HDC hdc,
    PPOINT ppt,
    PRECT prc
    );

BOOL
GreGetDCOrg(
    HDC hdc,
    LPPOINT pptl
    );

BOOL
GreSetDCOrg(
    HDC hdc,
    LONG x,
    LONG y,
    PRECTL prcl
    );

//
// DC creation
//

HDC
GreCreateDisplayDC(
    HDEV hdev,
    ULONG iType,
    BOOL bAltType
    );

BOOL
GreDeleteDC(
    HDC hdc
    );

BOOL
GreCleanDC(
    HDC hdc
    );


HBRUSH
GreGetFillBrush(
    HDC hdc
    );

int
GreSetMetaRgn(
    HDC hdc
    );

int
GreGetDIBitsInternal(
    HDC hdc,
    HBITMAP hBitmap,
    UINT iStartScan,
    UINT cNumScan,
    LPBYTE pjBits,
    LPBITMAPINFO pBitsInfo,
    UINT iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo
    );

HBITMAP APIENTRY
GreCreateDIBitmapReal(
    HDC hdc,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    HANDLE hSection,
    DWORD dwOffset,
    HANDLE hSecure,
    FLONG fl,
    ULONG_PTR dwClientColorSpace,  //dwClientColorSpace used to pass pointer
    PVOID *ppvBits);

HBRUSH
GreCreateSolidBrush(
    COLORREF
    );

ULONG
GreRealizeDefaultPalette(
    HDC,
    BOOL
    );

BOOL
IsDCCurrentPalette(
    HDC
    );

HPALETTE
GreSelectPalette(
    HDC hdc,
    HPALETTE hpalNew,
    BOOL bForceBackground
    );

DWORD
GreRealizePalette(
    HDC
    );

BOOL
GreDeleteServerMetaFile(
    HANDLE hmo
    );

//
// Fonts
//

ULONG
GreSetFontEnumeration(
    ULONG ulType
    );

ULONG
GreSetFontContrast(
    ULONG ulContrast
    );

VOID
GreSetLCDOrientation(
    DWORD dwOrientation
    );

int
GreGetTextCharacterExtra(
    HDC
    );

int
GreSetTextCharacterExtra(
    HDC,
    int
    );

int
GreGetTextCharsetInfo(
    HDC,
    LPFONTSIGNATURE,
    DWORD);

VOID
GreGetCannonicalName(
    WCHAR*,
    WCHAR*,
    ULONG*,
    DESIGNVECTOR*);

//
// For fullscreen support
//

NTSTATUS
GreDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    );

//
// Pixel format support
//

int
NtGdiDescribePixelFormat(
    HDC hdc,
    int ipfd,
    UINT cjpfd,
    PPIXELFORMATDESCRIPTOR ppfd
    );

BOOL
GreSetMagicColors(
    HDC,
    PALETTEENTRY,
    ULONG
    );

COLORREF
APIENTRY
GreGetNearestColor(
    HDC,
    COLORREF);

BOOL
GreUpdateSharedDevCaps(
    HDEV hdev
    );

INT
GreNamedEscape(
    LPWSTR,
    int,
    int,
    LPSTR,
    int,
    LPSTR
    );

typedef struct
{
    UINT uiWidth;
    UINT uiHeight;
    BYTE ajBits[1];
} STRINGBITMAP, *LPSTRINGBITMAP;

UINT
GreGetStringBitmapW(
    HDC hdc,
    LPWSTR pwsz,
    UINT cwc,
    LPSTRINGBITMAP lpSB,
    UINT cj
    );

UINT
GetStringBitmapW(
    HDC hdc,
    LPWSTR pwsz,
    ULONG cwc,
    UINT cj,
    LPSTRINGBITMAP lpSB
    );

UINT
GetStringBitmapA(
    HDC hdc,
    LPCSTR psz,
    ULONG cbStr,
    UINT cj,
    LPSTRINGBITMAP lpSB
    );

INT
GetSystemEUDCRange (
    BYTE *pbEUDCLeadByteTable ,
    INT   cjSize
    );

//
// Hydra support
//

BOOL
GreMultiUserInitSession(
    HANDLE hRemoteConnectionChannel,
    PBYTE pPerformanceStatistics,
    PFILE_OBJECT pVideoFile,
    PFILE_OBJECT pRemoteConnectionFileObject,
    ULONG DisplayDriverNameLength,
    PWCHAR DisplayDriverName
    );

BOOL
GreConsoleShadowStart(
    HANDLE hRemoteConnectionChannel,
    PBYTE pPerformanceStatistics,
    PFILE_OBJECT pVideoFile,
    PFILE_OBJECT pRemoteConnectionFileObject 
    );


BOOL
GreConsoleShadowStop(
    VOID
    );

BOOL
MultiUserNtGreCleanup();

BOOL
bDrvReconnect(
    HDEV hdev,
    HANDLE RemoteConnectionChannel,
    PFILE_OBJECT pRemoteConnectionFileObject,
    BOOL bSetPalette
    );

BOOL
bDrvDisconnect(
    HDEV hdev,
    HANDLE RemoteConnectionChannel,
    PFILE_OBJECT pRemoteConnectionFileObject
    );

BOOL
bDrvShadowConnect(
    HDEV hdev,
    PVOID pRemoteConnectionData,
    ULONG RemoteConnectionDataLength
    );

BOOL
bDrvShadowDisconnect(
    HDEV hdev,
    PVOID pRemoteConnectionData,
    ULONG RemoteConnectionDataLength
    );

VOID
vDrvInvalidateRect(
    HDEV hdev,
    PRECT prcl
    );

BOOL
bDrvDisplayIOCtl(
    HDEV hdev,
    PVOID pbuffer,
    ULONG cbbuffer
    );

BOOL
HDXDrvEscape(
    HDEV hdev,
    ULONG iEsc,
    PVOID pInbuffer,
    ULONG cbInbuffer
    );

//
// DirectDraw support
//

VOID
GreSuspendDirectDraw(
    HDEV    hdev,
    BOOL    bChildren
    );

VOID
GreResumeDirectDraw(
    HDEV    hdev,
    BOOL    bChildren
    );

BOOL
GreGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    );

//
// Driver support
//

// MDEV.ulFlags

#define MDEV_MISMATCH_COLORDEPTH  0x01

typedef struct _MDEV {
    HDEV  hdevParent;
    HDEV  Reserved;
    ULONG ulFlags;
    ULONG chdev;
    PVOID pDesktopId;
    struct {
        HDEV  hdev;
        HDEV  Reserved;
        RECT  rect;
    } Dev[1];
} MDEV, *PMDEV;

BOOL
DrvDisableMDEV(
    PMDEV pmdev,
    BOOL bHardware
    );

BOOL
DrvEnableMDEV(
    PMDEV pmdev,
    BOOL bHardware
    );

NTSTATUS
DrvGetMonitorPowerState(
    PMDEV              pmdev,
    DEVICE_POWER_STATE PowerState
    );

NTSTATUS
DrvSetMonitorPowerState(
    PMDEV              pmdev,
    DEVICE_POWER_STATE PowerState
    );

BOOL
DrvQueryMDEVPowerState(
    PMDEV mdev
    );

VOID
DrvSetMDEVPowerState(
    PMDEV mdev,
    BOOL  On
    );

BOOL
DrvDisplaySwitchHandler(
    PVOID PhysDisp,
    PUNICODE_STRING pstrDeviceName,
    LPDEVMODEW pNewMode,
    PULONG     pPrune
    );

PVOID
DrvWakeupHandler(
    HANDLE *ppdo
    );

BOOL
DrvUpdateGraphicsDeviceList(
    BOOL bDefaultDisplayDisabled,
    BOOL bReenumerationNeeded,
    BOOL bLocal
    );

BOOL
DrvGetHdevName(
    HDEV   hdev,
    PWCHAR DeviceName
    );

NTSTATUS
DrvEnumDisplayDevices(
    PUNICODE_STRING   pstrDeviceName,
    HDEV              hdevPrimary,
    DWORD             iDevNum,
    LPDISPLAY_DEVICEW lpDisplayDevice,
    DWORD             dwFlags,
    MODE              ExecutionMode
    );

NTSTATUS
DrvEnumDisplaySettings(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    DWORD           iModeNum,
    LPDEVMODEW      lpDevMode,
    DWORD           dwFlags
    );

#define GRE_DISP_CHANGE_SUCCESSFUL       0
#define GRE_DISP_CHANGE_RESTART          1
#define GRE_DISP_CHANGE_NO_CHANGE        2
#define GRE_DISP_CHANGE_FAILED          -1
#define GRE_DISP_CHANGE_BADMODE         -2
#define GRE_DISP_CHANGE_NOTUPDATED      -3
#define GRE_DISP_CHANGE_BADFLAGS        -4
#define GRE_DISP_CHANGE_BADPARAM        -5
#define GRE_DISP_CHANGE_BADDUALVIEW     -6

#define GRE_PRUNE       TRUE
#define GRE_RAWMODE     FALSE
#define GRE_DEFAULT     0xFFFFFFFF

LONG
DrvChangeDisplaySettings(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    LPDEVMODEW      lpDevMode,
    PVOID           pDesktopId,
    MODE            PreviousMode,
    BOOL            bUpdateRegistry,
    BOOL            bSetMode,
    PMDEV           pOrgMdev,
    PMDEV           *pNewMdev,
    DWORD           PruneFlag,
    BOOL            bTryClosest
    );

#define GRE_DISP_CREATE_NODISABLE     0x00000001
#define GRE_DISP_NOT_APARTOF_DESKTOP  0x00000002

PMDEV
DrvCreateMDEV(
    PUNICODE_STRING pstrDevice,
    LPDEVMODEW      lpdevmodeInformation,
    PVOID           pGroupId,
    ULONG           ulFlags,
    PMDEV           pMdevOrg,
    MODE            PreviousMode,
    DWORD           PruneFlag,
    BOOL            bClosest
    );

VOID
DrvDestroyMDEV(
    PMDEV pmdev
    );

VOID
DrvSetBaseVideo(
    BOOL bSet
    );

NTSTATUS
DrvInitConsole(
    BOOL bEnumerationNeeded
    );

LONG
DrvSetVideoParameters(
    PUNICODE_STRING pstrDeviceName,
    HDEV            hdevPrimary,
    MODE            PreviousMode,
    PVOID           VideoParameters
    );

VOID
GreStartTimers(
    VOID
    );

#define GCR_WNDOBJEXISTS        0x00000001
#define GCR_DELAYFINALUPDATE    0x00000002

#define GreAlphaBlend NtGdiAlphaBlend
BOOL APIENTRY NtGdiAlphaBlend(HDC,LONG,LONG,LONG,LONG,HDC,LONG,LONG,LONG,LONG,BLENDFUNCTION,HANDLE);

VOID APIENTRY GreClientRgnUpdated(FLONG);
VOID APIENTRY GreClientRgnDone(FLONG);
VOID APIENTRY GreFlush(VOID);

BOOL     APIENTRY GreDPtoLP(HDC, LPPOINT, int);
BOOL     APIENTRY GreLPtoDP(HDC, LPPOINT, int);
BOOL     APIENTRY GreGradientFill(HDC,PTRIVERTEX,ULONG,PVOID,ULONG,ULONG);
COLORREF APIENTRY GreSetBkColor(HDC, COLORREF);
int      APIENTRY GreSetBkMode(HDC, int);
HFONT    APIENTRY GreSelectFont(HDC hdc, HFONT hlfntNew);
int      APIENTRY GreCombineRgn(HRGN, HRGN, HRGN, int);
COLORREF APIENTRY GreSetTextColor(HDC, COLORREF);
HBITMAP  APIENTRY GreSelectBitmap(HDC,HBITMAP);
int      APIENTRY GreOffsetRgn(HRGN, int, int);
BOOL     APIENTRY GreGetTextExtentW(HDC,LPWSTR,int,LPSIZE,UINT);
BOOL     APIENTRY GreExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);
HBRUSH   APIENTRY GreSelectBrush(HDC,HBRUSH);
BOOL     APIENTRY GreRestoreDC(HDC, int);
int      APIENTRY GreSaveDC(HDC);
int      APIENTRY GreExtGetObjectW(HANDLE, int, LPVOID);
BOOL     APIENTRY GreDeleteObject(HANDLE);
HBITMAP  APIENTRY GreCreateBitmap(int, int, UINT, UINT, LPBYTE);
HBITMAP  APIENTRY GreCreateCompatibleBitmap(HDC, int, int);
HDC      APIENTRY GreCreateCompatibleDC(HDC);
int      APIENTRY GreGetDeviceCaps(HDC, int);
UINT     APIENTRY GreGetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY);
UINT     APIENTRY GreGetSystemPaletteUse(HDC);
HPALETTE APIENTRY GreCreatePalette(LPLOGPALETTE);
HPALETTE APIENTRY GreCreateHalftonePalette(HDC hdc);
BOOL     APIENTRY GreGetBounds(HDC hdc, LPRECT lprcBounds, DWORD fl);
int      APIENTRY GreSetDIBits(HDC, HBITMAP, UINT, UINT, LPBYTE, LPBITMAPINFO, UINT);
ULONG    APIENTRY GreGetBitmapSize(CONST BITMAPINFO *pbmi, ULONG iUsage);
ULONG    APIENTRY GreGetBitmapBitsSize(CONST BITMAPINFO *pbmi);
VOID     APIENTRY GreDeleteWnd(PVOID pwo);
HBRUSH   APIENTRY GreCreatePatternBrush(HBITMAP);
BOOL     APIENTRY GreGetWindowOrg(HDC, LPPOINT);
BOOL     APIENTRY GreSetWindowOrg(HDC hdc, int x, int y, LPPOINT pPoint);
DWORD    APIENTRY GreSetLayout(HDC hdc, LONG wox, DWORD dwLayout);
DWORD    APIENTRY GreGetLayout(HDC hdc);
BOOL     APIENTRY GreMirrorWindowOrg(HDC hdc);
LONG     APIENTRY GreGetDeviceWidth(HDC hdc);
DWORD    APIENTRY GreGetRegionData(HRGN, DWORD, LPRGNDATA);
HRGN     APIENTRY GreExtCreateRegion(XFORML *, DWORD, LPRGNDATA);
BOOL     APIENTRY GrePtInRegion(HRGN, int, int);
BOOL     APIENTRY GreRectInRegion(HRGN, LPRECT);
int      APIENTRY GreGetClipBox(HDC, LPRECT, BOOL);
int      APIENTRY GreGetRgnBox(HRGN, LPRECT);
BOOL     APIENTRY GreGetTextMetricsW(HDC, TMW_INTERNAL *);
int      APIENTRY GreGetRandomRgn(HDC, HRGN, int);
BOOL     APIENTRY GreStretchBlt(HDC,int,int,int,int,HDC,int,int,int,int,DWORD,DWORD);
int      APIENTRY GreExtSelectClipRgn(HDC, HRGN, int);
int      APIENTRY GreSetStretchBltMode(HDC, int);
BOOL     APIENTRY GreSetViewportOrg(HDC, int, int, LPPOINT);
BOOL     APIENTRY GreGetViewportOrg(HDC, LPPOINT);
BOOL     APIENTRY GreGetBrushOrg(HDC, LPPOINT);
int      APIENTRY GreCopyVisRgn(HDC, HRGN);
int      APIENTRY GreSubtractRgnRectList(HRGN, LPRECT, LPRECT, int);
HRGN     APIENTRY GreCreateRectRgnIndirect(LPRECT);
BOOL     APIENTRY GreSetBrushOrg(HDC, int, int, LPPOINT);
VOID     APIENTRY GreSetClientRgn(PVOID, HRGN, LPRECT);
BOOL     APIENTRY GreIntersectVisRect(HDC,int,int,int,int);
int      APIENTRY GreIntersectClipRect(HDC, int, int, int, int);
HFONT    APIENTRY GreGetHFONT(HDC);
HANDLE   APIENTRY GreGetStockObject(int);
COLORREF APIENTRY GreGetBkColor(HDC);
COLORREF APIENTRY GreGetTextColor(HDC);
BOOL     APIENTRY GreSetRectRgn(HRGN, int, int, int, int);
BOOL     APIENTRY GreSetSolidBrush(HBRUSH hbr, COLORREF clr);
HFONT    APIENTRY GreCreateFontIndirectW(LPLOGFONTW);
BOOL     APIENTRY GreValidateServerHandle(HANDLE hobj, ULONG ulType);
COLORREF APIENTRY GreGetBrushColor(HBRUSH);
BOOL     APIENTRY GreGetColorAdjustment(HDC, PCOLORADJUSTMENT);
UINT     APIENTRY GreGetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *pRGB);
int      APIENTRY GreExcludeClipRect(HDC, int, int, int, int);
BOOL     APIENTRY GreRemoveAllButPermanentFonts();
BOOL     APIENTRY GreSetColorAdjustment(HDC, PCOLORADJUSTMENT);
VOID     APIENTRY GreMarkDCUnreadable(HDC);
BOOL     APIENTRY GreGetViewportExt(HDC, LPSIZE);
BOOL     APIENTRY GreGetWindowExt(HDC, LPSIZE);
DWORD    APIENTRY GreGetCharSet(HDC hdc);
int      APIENTRY GreGetMapMode(HDC);
HRGN     APIENTRY GreCreateRectRgn(int, int, int, int);
BOOL     APIENTRY GrePtInSprite(HDEV, HWND, int, int);
VOID     APIENTRY GreUpdateSpriteVisRgn(HDEV);
VOID     APIENTRY GreZorderSprite(HDEV, HWND, HWND);
HANDLE   APIENTRY GreCreateSprite(HDEV, HWND, RECT*);
BOOL     APIENTRY GreDeleteSprite(HDEV, HWND, HANDLE);
BOOL     APIENTRY GreGetSpriteAttributes(HDEV, HWND, HANDLE, COLORREF*, BLENDFUNCTION*, DWORD*);
BOOL     APIENTRY GreUpdateSprite(HDEV, HWND, HANDLE, HDC, POINT*, SIZE*, HDC, POINT*, COLORREF, BLENDFUNCTION*, DWORD, RECT*);
BOOL     APIENTRY GreIsPaletteDisplay(HDEV);
VOID     APIENTRY GreFreePool(PVOID);
VOID     GreIncQuotaCount(PW32PROCESS);
VOID     GreDecQuotaCount(PW32PROCESS);
DWORD    APIENTRY GreGetBoundsRect(HDC, LPRECT, DWORD);
DWORD    APIENTRY GreSetBoundsRect(HDC, LPRECT, DWORD);
BOOL     APIENTRY GreSelectRedirectionBitmap(HDC hdc, HBITMAP hbitmap);
int      APIENTRY GreSetGraphicsMode(HDC hdc, int iMode);
BOOL     APIENTRY GreEnableDirectDrawRedirection(HDEV, BOOL);

#define GreFillRgn NtGdiFillRgn
BOOL NtGdiFillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);

#ifdef MOUSE_IP
W32KAPI HRGN APIENTRY NtGdiCreateEllipticRgn(IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL APIENTRY NtGdiFillRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush);
HPEN APIENTRY GreCreatePen(int, int, COLORREF,HBRUSH);
HPEN APIENTRY GreSelectPen(HDC,HPEN);
W32KAPI BOOL APIENTRY NtGdiEllipse(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
#endif

HANDLE NtGdiGetDCObject (HDC hdc, int itype);

//
// Private draw stream driver related declarations and defines.
// Note, no driver currently supports draw stream and is only used
// as an internal mechanism to support the private DS_NINEGRID
// command used to render nine grids.
//

typedef struct _DSSTATE
{
    ULONG            ulSize;
    COLORREF         crColorKey;
    BLENDFUNCTION    blendFunction;
    POINTL           ptlSrcOrigin;
} DSSTATE;   

BOOL APIENTRY EngDrawStream(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDstClip,
    PPOINTL     pptlDstOffset,
    ULONG       ulIn,
    PVOID       pvIn,
    DSSTATE    *pdss
);

BOOL APIENTRY DrvDrawStream(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDstClip,
    PPOINTL     pptlDstOffset,
    ULONG       ulIn,
    PVOID       pvIn,
    DSSTATE    *pdss
);

typedef BOOL   (APIENTRY *PFN_DrvDrawStream)(SURFOBJ *,SURFOBJ *,CLIPOBJ *, XLATEOBJ *,PRECTL,PPOINTL,ULONG,PVOID,DSSTATE*);

//
// Private draw nine grid driver related declarations and defines.
//

// The flags specified in flFlags correspond to the DSDNG_xxx flags
// found as part of the draw stream command interface.

typedef struct NINEGRID
{
    ULONG            flFlags;
    LONG             ulLeftWidth;
    LONG             ulRightWidth;
    LONG             ulTopHeight;
    LONG             ulBottomHeight;
    COLORREF         crTransparent;
} NINEGRID, *PNINEGRID;
 
#define INDEX_DrvDrawStream     INDEX_DrvReserved9

// By specifying GCAPS2_REMOTEDRIVER, the remote driver indicates that it
// supports DrvNineGrid and as such will be called to render nine grids.
// The remote driver can safely punt the call to EngNineGrid.

#define GCAPS2_REMOTEDRIVER     GCAPS2_RESERVED1

// Drivers which support DrvNineGrid will need to specify the following
// driver entry index.

#define INDEX_DrvNineGrid       INDEX_DrvReserved10  // remote drivers only

BOOL APIENTRY DrvNineGrid(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PNINEGRID   png,
    BLENDOBJ*   pBlendObj,
    PVOID       pvReserved
);

BOOL APIENTRY EngNineGrid(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    PRECTL      prclDst,
    PRECTL      prclSrc,
    PNINEGRID   png,
    BLENDOBJ*   pBlendObj,
    PVOID       pvReserved
);

typedef BOOL   (APIENTRY *PFN_DrvNineGrid)(SURFOBJ *,SURFOBJ *,CLIPOBJ *, XLATEOBJ *,PRECTL,PRECTL,PNINEGRID,BLENDOBJ*,PVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\immstruc.h ===
/****************************** Module Header ******************************\
* Module Name: immstruc.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains the internal IMM structure definitions
*
* used by both Client and Kernel
*
* History:
* 28-Dec-1995 WKwok        Created.
\***************************************************************************/

#ifndef _IMMSTRUC_
#define _IMMSTRUC_

#include <imm.h>
#include <immp.h>
#include <ime.h>
#include <imep.h>
//#include "winnls32.h"
//#include "winnls3p.h"


#define NULL_HIMC        (HIMC)  0
#define INVALID_HIMC     (HIMC) -1
#define NULL_HIMCC       (HIMCC) 0
#define INVALID_HIMCC    (HIMCC)-1

/*
 * dwFlags for tagIMC.
 */
#define IMCF_UNICODE            0x0001
#define IMCF_ACTIVE             0x0002
#define IMCF_CHGMSG             0x0004
#define IMCF_SAVECTRL           0x0008
#define IMCF_PROCESSEVENT       0x0010
#define IMCF_FIRSTSELECT        0x0020
#define IMCF_INDESTROY          0x0040
#define IMCF_WINNLSDISABLE      0x0080
#define IMCF_DEFAULTIMC         0x0100

/*
 * dwFlag for ImmGetSaveContext().
 */
#define IGSC_DEFIMCFALLBACK     0x0001
#define IGSC_WINNLSCHECK        0x0002

/*
 * dwFlag for ImmFreeLayout().
 */
#define IFL_DEACTIVATEIME       0x0001
#define IFL_UNLOADIME           0x0002

#define IS_IME_KBDLAYOUT(hkl) ((HIWORD((ULONG_PTR)(hkl)) & 0xf000) == 0xe000)

/*
 * Load flag for loading IME.DLL
 */
#define IMEF_NONLOAD            0x0000
#define IMEF_LOADERROR          0x0001
#define IMEF_LOADED             0x0002

#define IM_DESC_SIZE            50
#define IM_FILE_SIZE            80
#define IM_OPTIONS_SIZE         30
#define IM_UI_CLASS_SIZE        16
#define IM_USRFONT_SIZE         80


/*
 * hotkey related defines that are common both client and kernel side
 */
#define MOD_MODIFY_KEYS         (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN)
#define MOD_BOTH_SIDES          (MOD_LEFT|MOD_RIGHT)
#define ISHK_REMOVE             1
#define ISHK_ADD                2
#define ISHK_INITIALIZE         3

typedef struct _tagIMEHOTKEY {
    DWORD       dwHotKeyID;             // hot key ID
    UINT        uVKey;                  // hot key vkey
    UINT        uModifiers;             // combination keys with the vkey
    HKL         hKL;                    // target keyboard layout (IME)
} IMEHOTKEY;
typedef IMEHOTKEY      *PIMEHOTKEY;
typedef IMEHOTKEY      CONST *PCIMEHOTKEY;


typedef struct _tagIMEHOTKEYOBJ {
    struct _tagIMEHOTKEYOBJ *pNext;
    IMEHOTKEY        hk;
} IMEHOTKEYOBJ, *PIMEHOTKEYOBJ;


/*
 * Extended IME information.
 */
typedef struct tagIMEINFOEX {
    HKL                 hkl;
    IMEINFO             ImeInfo;
    WCHAR               wszUIClass[IM_UI_CLASS_SIZE];
    DWORD               fdwInitConvMode;    // Check this later
    BOOL                fInitOpen;          // Check this later
    BOOL                fLoadFlag;
    DWORD               dwProdVersion;
    DWORD               dwImeWinVersion;
    WCHAR               wszImeDescription[IM_DESC_SIZE];
    WCHAR               wszImeFile[IM_FILE_SIZE];
} IMEINFOEX, *PIMEINFOEX;

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

/*
 * IMM related kernel calls
 */
W32KAPI
HIMC
NtUserCreateInputContext(
    IN ULONG_PTR dwClientImcData);

W32KAPI
BOOL
NtUserDestroyInputContext(
    IN HIMC hImc);

typedef enum _AIC_STATUS {
    AIC_SUCCESS,
    AIC_FOCUSCONTEXTCHANGED,
    AIC_ERROR,
} AIC_STATUS;

W32KAPI
AIC_STATUS
NtUserAssociateInputContext(
    IN HWND hwnd,
    IN HIMC hImc,
    IN DWORD dwFlag);

typedef enum _UPDATEINPUTCONTEXTCLASS {
    UpdateClientInputContext,
    UpdateInUseImeWindow,
} UPDATEINPUTCONTEXTCLASS;

W32KAPI
BOOL
NtUserUpdateInputContext(
    IN HIMC hImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue);

typedef enum _INPUTCONTEXTINFOCLASS {
    InputContextProcess,
    InputContextThread,
    InputContextDefaultImeWindow,
    InputContextDefaultInputContext,
} INPUTCONTEXTINFOCLASS;

W32KAPI
ULONG_PTR
NtUserQueryInputContext(
    IN HIMC hImc,
    IN INPUTCONTEXTINFOCLASS InputContextInfo);

W32KAPI
NTSTATUS
NtUserBuildHimcList(
    IN DWORD  idThread,
    IN UINT   cHimcMax,
    OUT HIMC  *phimcFirst,
    OUT PUINT  pcHimcNeeded);

typedef enum _IMEINFOEXCLASS {
    ImeInfoExKeyboardLayout,
#if defined(CUAS_ENABLE)
    ImeInfoExKeyboardLayoutWithCUAS,
#endif
    ImeInfoExImeWindow,
    ImeInfoExImeFileName,
} IMEINFOEXCLASS;

W32KAPI
BOOL
NtUserGetImeInfoEx(
    IN OUT PIMEINFOEX piiex,
    IN IMEINFOEXCLASS SearchType);

W32KAPI
BOOL
NtUserSetImeInfoEx(
    IN PIMEINFOEX piiex);

W32KAPI
BOOL
NtUserGetImeHotKey(
    IN DWORD dwID,
    OUT PUINT puModifiers,
    OUT PUINT puVKey,
    OUT HKL  *phkl);

W32KAPI
BOOL
NtUserSetImeHotKey(
    IN DWORD dwID,
    IN UINT  uModifiers,
    IN UINT  uVKey,
    IN HKL   hkl,
    IN DWORD dwAction);

W32KAPI
DWORD
NtUserCheckImeHotKey(
    IN UINT uVKey,
    IN LPARAM lParam);

W32KAPI
BOOL
NtUserSetAppImeLevel(
    IN HWND hWnd,
    IN DWORD dwLevel);

W32KAPI
DWORD
NtUserGetAppImeLevel(
    IN HWND hWnd );


W32KAPI
BOOL
NtUserSetImeOwnerWindow(
    IN HWND hwndIme,
    IN HWND hwndFocus);

W32KAPI
VOID
NtUserSetThreadLayoutHandles(
    IN HKL hklNew,
    IN HKL hklOld);

W32KAPI
VOID
NtUserNotifyIMEStatus(
    IN HWND hwnd,
    IN DWORD dwOpenStatus,
    IN DWORD dwConversion);

W32KAPI
BOOL
NtUserDisableThreadIme(
    IN DWORD dwThreadId);

#endif // _IMMSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\usergdi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    usergdi.h

Abstract:

    This module contains private USER functions used by GDI.
    All of these function are named Userxxx.

Author:

    Chris Williams (chriswil) 25-May-1995

Revision History:

--*/


extern PDRIVER_OBJECT gpWin32kDriverObject;


VOID
VideoPortCallout(
    IN PVOID Params
    );

BOOL FASTCALL
UserScreenAccessCheck(
    VOID
    );

HDC
UserGetDesktopDC(
    ULONG type,
    BOOL bAltType,
    BOOL bValidate
    );

BOOL
UserReleaseDC(
    HDC hdc
    );

HDEV
UserGetHDEV(
    VOID
    );

VOID
UserAssociateHwnd(
    HWND hwnd,
    PVOID pwo
    );

HRGN
UserGetClientRgn(
    HWND hwnd,
    LPRECT lprc,
    BOOL bWindowInsteadOfClient
    );

BOOL
UserGetHwnd(
    HDC hdc,
    HWND *phwnd,
    PVOID *ppwo,
    BOOL bCheckStyle
    );

VOID
UserEnterUserCritSec(
    VOID
    );

VOID
UserLeaveUserCritSec(
    VOID
    );

BOOL
UserGetCurrentDesktopId(
    DWORD* pdwDesktopId
);

VOID
UserRedrawDesktop(
    VOID
    );

UINT_PTR
UserSetTimer(
    UINT dwElapse,
    PVOID pTimerFunc
    );

BOOL
UserVisrgnFromHwnd(
    HRGN *phrgn,
    HWND hwnd
    );

VOID
UserKillTimer(
    UINT_PTR nID
    );

#if DBG
VOID
UserAssertUserCritSecIn(
    VOID
    );

VOID
UserAssertUserCritSecOut(
    VOID
    );
#endif

VOID
UserGetDisconnectDeviceResolutionHint(
    PDEVMODEW
    );

NTSTATUS
UserSessionSwitchEnterCrit(
    VOID
    );

VOID
UserSessionSwitchLeaveCrit(
    VOID
    );

BOOL
UserIsUserCritSecIn(
    VOID
    );

DWORD
GetAppCompatFlags2(
    WORD wVersion
    );

BOOL
UserGetRedirectedWindowOrigin(
    HDC hdc,
    LPPOINT ppt
    );

HBITMAP
UserGetRedirectionBitmap(
    HWND hwnd
    );

//
// User-mode printer driver kernel-to-client callback mechanism.
//

DWORD
ClientPrinterThunk(
    PVOID pvIn,
    ULONG cjIn,
    PVOID pvOut,
    ULONG cjOut
    );

//
// Gdi fonts stuff
//

VOID
GdiMultiUserFontCleanup();


#define BEGIN_REENTERCRIT()                                             \
{                                                                       \
    BOOL fAlreadyHadCrit;                                               \
                                                                        \
    /*                                                                  \
     * If we're not in the user crit then acquire it.                   \
     */                                                                 \
    fAlreadyHadCrit = ExIsResourceAcquiredExclusiveLite(gpresUser);     \
    if (fAlreadyHadCrit == FALSE) {                                     \
        EnterCrit();                                                    \
    }

#define END_REENTERCRIT()               \
    if (fAlreadyHadCrit == FALSE) {     \
       LeaveCrit();                     \
    }                                   \
}


/*
 * Pool memory allocation functions used in win32k
 */

/*
 * From ntos\inc\pool.h
 */
#define SESSION_POOL_MASK 32

#if DBG
#define TRACE_MAP_VIEWS
#define MAP_VIEW_STACK_TRACE
#else
#if defined(PRERELEASE) || defined(USER_INSTRUMENTATION)
#define TRACE_MAP_VIEWS
#define MAP_VIEW_STACK_TRACE
#endif
#endif

#define TAG_SECTION_SHARED          101
#define TAG_SECTION_DESKTOP         102
#define TAG_SECTION_GDI             103
#define TAG_SECTION_FONT            104
#define TAG_SECTION_REMOTEFONT      105
#define TAG_SECTION_CREATESECTION   106
#define TAG_SECTION_DIB             107
#define TAG_SECTION_HMGR            108

struct tagWin32MapView;

#define MAP_VIEW_STACK_TRACE_SIZE 6

typedef struct tagWin32Section {
    struct tagWin32Section*  pNext;
    struct tagWin32Section*  pPrev;
    struct tagWin32MapView*  pFirstView;
    PVOID                    SectionObject;
    LARGE_INTEGER            SectionSize;
    DWORD                    SectionTag;
#ifdef MAP_VIEW_STACK_TRACE
    PVOID                    trace[MAP_VIEW_STACK_TRACE_SIZE];
#endif // MAP_VIEW_STACK_TRACE
} Win32Section, *PWin32Section;

typedef struct tagWin32MapView {
    struct tagWin32MapView*  pNext;
    struct tagWin32MapView*  pPrev;
    PWin32Section            pSection;
    PVOID                    pViewBase;
    SIZE_T                   ViewSize;
#ifdef MAP_VIEW_STACK_TRACE
    PVOID                    trace[MAP_VIEW_STACK_TRACE_SIZE];
#endif // MAP_VIEW_STACK_TRACE
} Win32MapView, *PWin32MapView;
    
#ifndef TRACE_MAP_VIEWS
    
    NTSTATUS __inline Win32CreateSection(
                PVOID *SectionObject,
                ACCESS_MASK DesiredAccess,
                POBJECT_ATTRIBUTES ObjectAttributes,
                PLARGE_INTEGER InputMaximumSize,
                ULONG SectionPageProtection,
                ULONG AllocationAttributes,
                HANDLE FileHandle,
                PFILE_OBJECT FileObject,
                DWORD SectionTag)
    {
        return MmCreateSection(
                    SectionObject,
                    DesiredAccess,
                    ObjectAttributes,
                    InputMaximumSize,
                    SectionPageProtection,
                    AllocationAttributes,
                    FileHandle,
                    FileObject);
    }

    NTSTATUS __inline Win32MapViewInSessionSpace(
                PVOID Section,
                PVOID *MappedBase,
                PSIZE_T ViewSize)
    {
        return MmMapViewInSessionSpace(Section, MappedBase, ViewSize);
    }

    NTSTATUS __inline Win32UnmapViewInSessionSpace(
                PVOID MappedBase)
    {
        return MmUnmapViewInSessionSpace(MappedBase);
    }

    VOID __inline Win32DestroySection(PVOID Section)
    {
        ObDereferenceObject(Section);
    }
#else
    
    NTSTATUS _Win32CreateSection(
                PVOID*              pSectionObject,
                ACCESS_MASK         DesiredAccess,
                POBJECT_ATTRIBUTES  ObjectAttributes,
                PLARGE_INTEGER      pInputMaximumSize,
                ULONG               SectionPageProtection,
                ULONG               AllocationAttributes,
                HANDLE              FileHandle,
                PFILE_OBJECT        FileObject,
                DWORD               SectionTag);
    
    NTSTATUS _Win32MapViewInSessionSpace(
                PVOID   Section,
                PVOID*  pMappedBase,
                PSIZE_T pViewSize);
    
    NTSTATUS _Win32UnmapViewInSessionSpace(
                PVOID   MappedBase);
    
    VOID _Win32DestroySection(
                PVOID Section);

    #define Win32CreateSection              _Win32CreateSection
    #define Win32MapViewInSessionSpace      _Win32MapViewInSessionSpace
    #define Win32UnmapViewInSessionSpace    _Win32UnmapViewInSessionSpace
    #define Win32DestroySection             _Win32DestroySection
#endif // TRACE_MAP_VIEWS

#if DBG
    #define POOL_INSTR
    #define POOL_INSTR_API
#else
    #define POOL_INSTR
#endif // DBG

/*++

    How the registry controls pool instrumentation in win32k.sys:
    --------------------------------------------------------------
    
    If pool instrumentation is turned on (this can be done for free builds as
    well as checked) then there are several levels of tracing controlled from
    the registry under the following key:
    
    HKLM\System\CurrentControlSet\Control\Session Manager\SubSystems\Pool
    
    if this key doesn't exist default settings are used for each of the following key.
    
    1.  HeavyRemoteSession     REG_DWORD
    
    default: 1
    if this is non zero or the key doesn't exist then pool tracing is on
    for remote sessions of win32k.sys.
    
    2.  HeavyConsoleSession    REG_DWORD
    
    default: 0
    if this is non zero then pool tracing is on for console sessions
    of win32k.sys. it the key doesn't exist then pool tracing is off for
    the main session.
    
    3.  StackTraces            REG_DWORD
    
    default:
    - 1 for remote sessions
    - 0 for the main session
    
    if non zero then a stack trace record will be saved for every
    pool allocation made.
    
    4.  KeepFailRecords        REG_DWORD
    
    default: 32
    if non zero then win32k.sys will keep a list of the last x allocations
    that failed (tag + stack trace). Use !dpa -f to dump the stack traces of
    the failed allocations
    
    4.  UseTailString          REG_DWORD
    
    default: 0
    if non zero for every pool allocation there will be a string attached
    to the end of the allocation to catch some specific type of memory corruption.
    
    5.  KeepFreeRecords      REG_DWORD
    
    default: 0
    not implemented yet. the number will specify how many free pointers will
    be kept in a list so we can differentiate when we call ExFreePool between
    a totally bogus value and a pointer that was already freed.
    
    6.  AllocationIndex         REG_DWORD
    7.  AllocationsToFail       REG_DWORD
    
    If AllocationIndex is non zero then win32k counts the pool allocations
    made and will start failing from allocation AllocationIndex a number
    of AllocationsToFail allocations. This is useful during boot time when
    a user mode test cannot call Win32PoolAllocationStats to fail pool allocations.
    
    8. BreakForPoolLeaks        REG_DWORD
    
    default: 0
    
    Breaks in the debugger (if started with /debug in boot.ini) if pool leaks
    are detected in win32k.sys for remote sessions.

--*/


#ifdef POOL_INSTR
    PVOID HeavyAllocPool(SIZE_T uBytes, ULONG iTag, DWORD dwFlags);
    VOID  HeavyFreePool(PVOID p);

    #define Win32AllocPool(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, 0)

    #define Win32AllocPoolZInit(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_ZEROINIT)

    #define Win32AllocPoolWithQuota(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_USEQUOTA)

    #define Win32AllocPoolWithQuotaZInit(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_USEQUOTA | DAP_ZEROINIT)

    #define Win32AllocPoolNonPaged(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_NONPAGEDPOOL);

    #define Win32AllocPoolWithQuotaNonPaged(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_USEQUOTA | DAP_NONPAGEDPOOL);

    #define Win32AllocPoolNonPagedNS(uBytes, iTag) \
        HeavyAllocPool(uBytes, iTag, DAP_NONPAGEDPOOL | DAP_NONSESSION);

    #define Win32FreePool    HeavyFreePool

#else
    PVOID __inline Win32AllocPool(SIZE_T uBytes, ULONG  uTag)
    {
        return ExAllocatePoolWithTag(
                (POOL_TYPE)(SESSION_POOL_MASK | PagedPool),
                uBytes, uTag);
    }
    PVOID __inline Win32AllocPoolWithQuota(SIZE_T uBytes, ULONG uTag)
    {
        return ExAllocatePoolWithQuotaTag(
                (POOL_TYPE)(SESSION_POOL_MASK | PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE),
                uBytes, uTag);
    }
    PVOID __inline Win32AllocPoolNonPaged(SIZE_T uBytes, ULONG uTag)
    {
        return ExAllocatePoolWithTag(
                        (POOL_TYPE)(SESSION_POOL_MASK | NonPagedPool),
                        uBytes, uTag);
    }
    PVOID __inline Win32AllocPoolNonPagedNS(SIZE_T uBytes, ULONG uTag)
    {
        return ExAllocatePoolWithTag(
                        (POOL_TYPE)NonPagedPool,
                        uBytes, uTag);
    }
    PVOID __inline Win32AllocPoolWithQuotaNonPaged(SIZE_T uBytes, ULONG uTag)
    {
        return ExAllocatePoolWithQuotaTag(
                        (POOL_TYPE)(SESSION_POOL_MASK | NonPagedPool), uBytes, uTag);
    }
    
    PVOID Win32AllocPoolWithTagZInit(SIZE_T uBytes, ULONG uTag);
    PVOID Win32AllocPoolWithQuotaTagZInit(SIZE_T uBytes, ULONG uTag);
    
    PVOID __inline Win32AllocPoolZInit(SIZE_T uBytes, ULONG uTag)
    {
        return Win32AllocPoolWithTagZInit(uBytes, uTag);
    }
    PVOID __inline Win32AllocPoolWithQuotaZInit(SIZE_T uBytes, ULONG uTag)
    {
        return Win32AllocPoolWithQuotaTagZInit(uBytes, uTag);
    }
    
    #define Win32FreePool    ExFreePool

#endif // POOL_INSTR

/*
 * All the User* allocation functions are defined to be Win32*
 */

#define UserAllocPool                       Win32AllocPool
#define UserAllocPoolZInit                  Win32AllocPoolZInit
#define UserAllocPoolWithQuota              Win32AllocPoolWithQuota
#define UserAllocPoolWithQuotaZInit         Win32AllocPoolWithQuotaZInit
#define UserAllocPoolNonPaged               Win32AllocPoolNonPaged
#define UserAllocPoolNonPagedNS             Win32AllocPoolNonPagedNS
#define UserAllocPoolWithQuotaNonPaged      Win32AllocPoolWithQuotaNonPaged
#define UserFreePool                        Win32FreePool


PVOID UserReAllocPoolWithTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG uTag);

PVOID UserReAllocPoolWithQuotaTag(
    PVOID pSrc,
    SIZE_T uBytesSrc,
    SIZE_T uBytes,
    ULONG uTag);

PVOID __inline UserReAllocPool(PVOID p, SIZE_T uBytesSrc, SIZE_T uBytes, ULONG uTag)
{
    return UserReAllocPoolWithTag(p, uBytesSrc, uBytes, uTag);
}

PVOID __inline UserReAllocPoolWithQuota(PVOID p, SIZE_T uBytesSrc, SIZE_T uBytes, ULONG uTag)
{
    return UserReAllocPoolWithQuotaTag(p, uBytesSrc, uBytes, uTag);
}

/*
 * Since the ReAllocPoolZInit functions are not yet used, they are
 * made inline to save code space. Consider making them non-inline
 * if they get a few uses.
 */
PVOID __inline UserReAllocPoolZInit(PVOID p, SIZE_T uBytesSrc, SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;
    pv = UserReAllocPoolWithTag(p, uBytesSrc, uBytes, uTag);
    if (pv && uBytes > uBytesSrc) {
        RtlZeroMemory((BYTE *)pv + uBytesSrc, uBytes - uBytesSrc);
    }

    return pv;
}

PVOID __inline UserReAllocPoolWithQuotaZInit(PVOID p, SIZE_T uBytesSrc, SIZE_T uBytes, ULONG uTag)
{
    PVOID   pv;
    pv = UserReAllocPoolWithQuotaTag(p, uBytesSrc, uBytes, uTag);
    if (pv && uBytes > uBytesSrc) {
        RtlZeroMemory((BYTE *)pv + uBytesSrc, uBytes - uBytesSrc);
    }

    return pv;
}

#define DAP_USEQUOTA        0x01
#define DAP_ZEROINIT        0x02
#define DAP_NONPAGEDPOOL    0x04
#define DAP_NONSESSION      0x08

//!!!dbug -- there has to be a better one somewhere...
/*
 * Memory manager (ExAllocate..., etc.) pool header size.
 */
#define MM_POOL_HEADER_SIZE     8

#define POOL_ALLOC_TRACE_SIZE   8

typedef struct tagWin32PoolHead {
    SIZE_T size;                    // the size of the allocation (doesn't include
                                    // this structure
    struct tagWin32PoolHead* pPrev; // pointer to the previous allocation of this tag
    struct tagWin32PoolHead* pNext; // pointer to the next allocation of this tag
    PVOID* pTrace;                  // pointer to the stack trace

} Win32PoolHead, *PWin32PoolHead;

#ifdef POOL_INSTR
    #define POOL_HEADER_SIZE   (sizeof(Win32PoolHead) + MM_POOL_HEADER_SIZE)
#else
    #define POOL_HEADER_SIZE    MM_POOL_HEADER_SIZE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\w32err.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    w32err.h

Abstract:

    private header file for Win32 kernel mode driver to do error logging


--*/

#ifndef _W32ERR_
#define _W32ERR_

/*
 * Compile tags under a separate #define from DEBUG. That way,
 * we can pull tags from the checked build before release.
 *
 * NOTE: When removing DEBUGTAGS via this #define, be sure
 * to remove the DEBUGTAGS define in ntuser\kdexts\{kd|ntsd}\makefile.inc
 */
#undef DEBUGTAGS
#if DBG
#define DEBUGTAGS 1
#endif


DWORD GetRipComponent(VOID);
DWORD GetDbgTagFlags(int tag);
DWORD GetRipPID(VOID);
DWORD GetRipFlags(VOID);
VOID SetRipFlags(DWORD dwRipFlags, DWORD dwRipPID);
VOID SetDbgTag(int tag, DWORD dwBitFlags);

VOID UserSetLastError(DWORD dwErrCode);
VOID SetLastNtError(NTSTATUS Status);

#if DBG

/*
 * Note: the only way to have multiple statements in a macro treated
 * as a single statement and not cause side effects is to put it
 * in a do-while loop.
 */
#define UserAssert(exp)                                                                       \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG0(RIP_ERROR, "Assertion failed: " #exp);                                    \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg0(exp, msg)                                                              \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG0(RIP_ERROR, "Assertion failed: " msg);                                     \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg1(exp, msg, p1)                                                          \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG1(RIP_ERROR, "Assertion failed: " msg, p1);                                 \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg2(exp, msg, p1, p2)                                                      \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG2(RIP_ERROR, "Assertion failed: " msg, p1, p2);                             \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg3(exp, msg, p1, p2, p3)                                                  \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG3(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3);                         \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg4(exp, msg, p1, p2, p3, p4)                                              \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG4(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3, p4);                     \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg5(exp, msg, p1, p2, p3, p4, p5)                                          \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG5(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3, p4, p5);                 \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg6(exp, msg, p1, p2, p3, p4, p5, p6)                                      \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG6(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3, p4, p5, p6);             \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg7(exp, msg, p1, p2, p3, p4, p5, p6, p7)                                  \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG7(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3, p4, p5, p6, p7);         \
        }                                                                                     \
    } while (FALSE)

#define UserAssertMsg8(exp, msg, p1, p2, p3, p4, p5, p6, p7, p8)                              \
    do {                                                                                      \
        if (!(exp)) {                                                                         \
            RIPMSG8(RIP_ERROR, "Assertion failed: " msg, p1, p2, p3, p4, p5, p6, p7, p8);     \
        }                                                                                     \
    } while (FALSE)

#define UserVerify(exp)                                                 UserAssert(exp)
#define UserVerifyMsg0(exp, msg)                                        UserAssertMsg0(exp, msg)
#define UserVerifyMsg1(exp, msg, p1)                                    UserAssertMsg1(exp, msg, p1)
#define UserVerifyMsg2(exp, msg, p1, p2)                                UserAssertMsg2(exp, msg, p1, p2)
#define UserVerifyMsg3(exp, msg, p1, p2, p3)                            UserAssertMsg3(exp, msg, p1, p2, p3)
#define UserVerifyMsg4(exp, msg, p1, p2, p3, p4)                        UserAssertMsg4(exp, msg, p1, p2, p3, p4)
#define UserVerifyMsg5(exp, msg, p1, p2, p3, p4, p5)                    UserAssertMsg5(exp, msg, p1, p2, p3, p4, p5)
#define UserVerifyMsg6(exp, msg, p1, p2, p3, p4, p5, p6)                UserAssertMsg6(exp, msg, p1, p2, p3, p4, p5, p6)
#define UserVerifyMsg7(exp, msg, p1, p2, p3, p4, p5, p6, p7)            UserAssertMsg7(exp, msg, p1, p2, p3, p4, p5, p6, p7)
#define UserVerifyMsg8(exp, msg, p1, p2, p3, p4, p5, p6, p7, p8)        UserAssertMsg8(exp, msg, p1, p2, p3, p4, p5, p6, p7, p8)

/*
 * Invalid Parameter warning message and last error setting
 */
#define VALIDATIONFNNAME(sz) static char szFnName [] = #sz;

#define VALIDATIONFAIL(p) \
    RIPMSG2(RIP_WARNING, "%s: Invalid " #p ": %#lx", szFnName, ##p); \
    goto InvalidParameter;

#define VALIDATIONOBSOLETE(o, u) \
    RIPMSG1(RIP_WARNING, "%s: " #o " obsolete; use " #u, szFnName)

#else /* of #ifdef DEBUG */


#define UserAssert(exp)
#define UserAssertMsg0(exp, msg)
#define UserAssertMsg1(exp, msg, p1)
#define UserAssertMsg2(exp, msg, p1, p2)
#define UserAssertMsg3(exp, msg, p1, p2, p3)
#define UserAssertMsg4(exp, msg, p1, p2, p3, p4)
#define UserAssertMsg5(exp, msg, p1, p2, p3, p4, p5)
#define UserAssertMsg6(exp, msg, p1, p2, p3, p4, p5, p6)
#define UserAssertMsg7(exp, msg, p1, p2, p3, p4, p5, p6, p7)
#define UserAssertMsg8(exp, msg, p1, p2, p3, p4, p5, p6, p7, p8)

#define UserVerify(exp)                                                 exp
#define UserVerifyMsg0(exp, msg)                                        exp
#define UserVerifyMsg1(exp, msg, p1)                                    exp
#define UserVerifyMsg2(exp, msg, p1, p2)                                exp
#define UserVerifyMsg3(exp, msg, p1, p2, p3)                            exp
#define UserVerifyMsg4(exp, msg, p1, p2, p3, p4)                        exp
#define UserVerifyMsg5(exp, msg, p1, p2, p3, p4, p5)                    exp
#define UserVerifyMsg6(exp, msg, p1, p2, p3, p4, p5, p6)                exp
#define UserVerifyMsg7(exp, msg, p1, p2, p3, p4, p5, p6, p7)            exp
#define UserVerifyMsg8(exp, msg, p1, p2, p3, p4, p5, p6, p7, p8)        exp

#define VALIDATIONFNNAME(sz)
#define VALIDATIONFAIL(p) goto InvalidParameter;
#define VALIDATIONOBSOLETE(o, u)

#endif /* #else of #ifdef DEBUG */

#define VALIDATIONERROR(ret) \
InvalidParameter: \
    UserSetLastError(ERROR_INVALID_PARAMETER); \
    return ret;

/***************************************************************************\
* Tags
*
* Use tags to control "internal" debugging: output we don't want
* external users of a checked build to see and debug code we don't want
* external users to have to run.
*
* You control tag output in the debugger by using the "tag"
* extension in userkdx.dll or userexts.dll, or type 't' at a debug prompt.
*
* You can create your own tag by adding it to ntuser\inc\dbgtag.lst.
* If you need debug output while developing but don't want to check in the
* code using tags, use DBGTAG_Other as a generic tag, and remove the tag code
* when done.
*
* IsDbgTagEnabled() checks if a tag is enabled. Use this to control optional
* debugging features, for example in handtabl.c:
*
* #if DEBUGTAGS
*     \*
*      * Record where the object was marked for destruction.
*      *\
*     if (IsDbgTagEnabled(tagTrackLocks)) {
*         if (!(phe->bFlags & HANDLEF_DESTROY)) {
*             PVOID pfn1, pfn2;
*
*             RtlGetCallersAddress(&pfn1, &pfn2);
*             HMRecordLock(pfn1, pobj, ((PHEAD)pobj)->cLockObj, 0);
*         }
*     }
* #endif
*
* TAGMSG prints a message when a tag has printing or prompting
* enabled. Example in input.c:
*
*     TAGMSG5(tagSysPeek,
*             "%d pti %lx sets ptiSL %lx to pq %lx ; old ptiSL %lx\n",
*             where, ptiCurrent, ptiSysLock, pq, pq->ptiSysLock);
*
*
* Use DbgTagBreak() to break when a tag is enabled (and not just
* when prompting for that tag is enabled).
*
* Use GetDbgTag() and SetDbgTag to temporarily change the state of
* a tag. You should rarely if ever do this.
*
\***************************************************************************/

#if DEBUGTAGS
BOOL _cdecl VTagOutput(DWORD flags, LPSTR pszFile, int iLine, LPSTR pszFmt, ...);

BOOL IsDbgTagEnabled(int tag);
void DbgTagBreak(int tag);
DWORD GetDbgTag(int tag);

void InitDbgTags(void);

/*
 * Use TAGMSG to print a tagged message.
 */
#define TAGMSG0(flags, szFmt)                                                                CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt)))
#define TAGMSG1(flags, szFmt, p1)                                                            CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1)))
#define TAGMSG2(flags, szFmt, p1, p2)                                                        CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2)))
#define TAGMSG3(flags, szFmt, p1, p2, p3)                                                    CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3)))
#define TAGMSG4(flags, szFmt, p1, p2, p3, p4)                                                CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4)))
#define TAGMSG5(flags, szFmt, p1, p2, p3, p4, p5)                                            CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5)))
#define TAGMSG6(flags, szFmt, p1, p2, p3, p4, p5, p6)                                        CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6)))
#define TAGMSG7(flags, szFmt, p1, p2, p3, p4, p5, p6, p7)                                    CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7)))
#define TAGMSG8(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)                                CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)))
#define TAGMSG9(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9)                            CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9)))
#define TAGMSG10(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)                      CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)))
#define TAGMSG11(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)                 CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)))
#define TAGMSG12(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)            CALLRIP((VTagOutput((flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)))

#else

#define IsDbgTagEnabled(tag)
#define DbgTagBreak(tag)

#define InitDbgTags()
#define GetDbgTag(tag)

#define TAGMSG0(flags, szFmt)
#define TAGMSG1(flags, szFmt, p1)
#define TAGMSG2(flags, szFmt, p1, p2)
#define TAGMSG3(flags, szFmt, p1, p2, p3)
#define TAGMSG4(flags, szFmt, p1, p2, p3, p4)
#define TAGMSG5(flags, szFmt, p1, p2, p3, p4, p5)
#define TAGMSG6(flags, szFmt, p1, p2, p3, p4, p5, p6)
#define TAGMSG7(flags, szFmt, p1, p2, p3, p4, p5, p6, p7)
#define TAGMSG8(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)
#define TAGMSG9(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9)
#define TAGMSG10(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)
#define TAGMSG11(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)
#define TAGMSG12(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)

#endif // if DEBUGTAGS

#define DUMMYCALLINGTYPE 
#if DBG 


#define FUNCLOG1(LogClass, retType, CallType, fnName, p1Type, p1) \
retType CallType fnName(p1Type p1); \
retType CallType fnName##_wrapper(p1Type p1) \
{ \
    retType ret; \
    TAGMSG1(DBGTAG_LOG, #fnName"("#p1" 0x%p)", p1); \
    ret = fnName(p1); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 


#define FUNCLOG2(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2) \
retType CallType fnName(p1Type p1, p2Type p2); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2) \
{ \
    retType ret; \
    TAGMSG2(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p)", p1, p2); \
    ret = fnName(p1, p2); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 


#define FUNCLOG3(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3) \
{ \
    retType ret; \
    TAGMSG3(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p)", p1, p2, p3); \
    ret = fnName(p1, p2, p3); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 


#define FUNCLOG4(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4) \
{ \
    retType ret; \
    TAGMSG4(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p)", p1, p2, p3, p4); \
    ret = fnName(p1, p2, p3, p4); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG5(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5) \
{ \
    retType ret; \
    TAGMSG5(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p)", p1, p2, p3, p4, p5); \
    ret = fnName(p1, p2, p3, p4, p5); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG6(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6) \
{ \
    retType ret; \
    TAGMSG6(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p)", p1, p2, p3, p4, p5, p6); \
    ret = fnName(p1, p2, p3, p4, p5, p6); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG7(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7) \
{ \
    retType ret; \
    TAGMSG7(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p)", p1, p2, p3, p4, p5, p6, p7); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG8(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8) \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8) \
{ \
    retType ret; \
    TAGMSG8(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7, p8); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG9(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9) \
{ \
    retType ret; \
    TAGMSG9(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG10(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10) \
{ \
    retType ret; \
    TAGMSG10(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG11(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11) \
{ \
    retType ret; \
    TAGMSG11(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p,"#p11" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOG12(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11, p12Type, p12) \
retType CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11, p12Type p12); \
retType CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11, p12Type p12) \
{ \
    retType ret; \
    TAGMSG12(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p,"#p11" 0x%p,"#p12" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
    ret = fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
    TAGMSG1(DBGTAG_LOG, "Return of "#fnName" is 0x%p", ret); \
    return ret; \
} 

#define FUNCLOGVOID1(LogClass, CallType, fnName, p1Type, p1) \
void CallType fnName(p1Type p1); \
void CallType fnName##_wrapper(p1Type p1) \
{ \
    TAGMSG1(DBGTAG_LOG, #fnName"("#p1" 0x%p)", p1); \
    fnName(p1); \
    return; \
} 


#define FUNCLOGVOID2(LogClass, CallType, fnName, p1Type, p1, p2Type, p2) \
void CallType fnName(p1Type p1, p2Type p2); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2) \
{ \
    TAGMSG2(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p)", p1, p2); \
    fnName(p1, p2); \
    return; \
} 


#define FUNCLOGVOID3(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3) \
{ \
    TAGMSG3(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p)", p1, p2, p3); \
    fnName(p1, p2, p3); \
    return; \
} 


#define FUNCLOGVOID4(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4) \
{ \
    TAGMSG4(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p)", p1, p2, p3, p4); \
    fnName(p1, p2, p3, p4); \
    return; \
} 

#define FUNCLOGVOID5(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5) \
{ \
    TAGMSG5(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p)", p1, p2, p3, p4, p5); \
    fnName(p1, p2, p3, p4, p5); \
    return; \
} 

#define FUNCLOGVOID6(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6) \
{ \
    TAGMSG6(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p)", p1, p2, p3, p4, p5, p6); \
    fnName(p1, p2, p3, p4, p5, p6); \
    return; \
} 

#define FUNCLOGVOID7(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7) \
{ \
    TAGMSG7(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p)", p1, p2, p3, p4, p5, p6, p7); \
    fnName(p1, p2, p3, p4, p5, p6, p7); \
    return; \
} 

#define FUNCLOGVOID8(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8) \
{ \
    TAGMSG4(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8); \
    fnName(p1, p2, p3, p4, p5, p6, p7, p8); \
    return; \
} 

#define FUNCLOGVOID9(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9) \
{ \
    TAGMSG9(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9); \
    fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9); \
    return; \
} 

#define FUNCLOGVOID10(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10) \
{ \
    TAGMSG10(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
    fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); \
    return; \
} 

#define FUNCLOGVOID11(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11) \
{ \
    TAGMSG11(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p,"#p11" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
    fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); \
    return; \
} 

#define FUNCLOGVOID12(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11, p12Type, p12) \
void CallType fnName(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11, p12Type p12); \
void CallType fnName##_wrapper(p1Type p1, p2Type p2, p3Type p3, p4Type p4, p5Type p5, p6Type p6, p7Type p7, p8Type p8, p9Type p9, p10Type p10, p11Type p11, p12Type p12) \
{ \
    TAGMSG12(DBGTAG_LOG, #fnName"("#p1" 0x%p,"#p2" 0x%p,"#p3" 0x%p,"#p4" 0x%p,"#p5" 0x%p,"#p6" 0x%p,"#p7" 0x%p,"#p8" 0x%p,"#p9" 0x%p,"#p10" 0x%p,"#p11" 0x%p,"#p12" 0x%p)", p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
    fnName(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); \
    return; \
} 

#else

#define FUNCLOG1(LogClass, retType, CallType, fnName, p1Type, p1)
#define FUNCLOG2(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2)
#define FUNCLOG3(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3)
#define FUNCLOG4(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4) 
#define FUNCLOG5(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5) 
#define FUNCLOG6(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6) 
#define FUNCLOG7(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7) 
#define FUNCLOG8(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8) 
#define FUNCLOG9(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9) 
#define FUNCLOG10(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10) 
#define FUNCLOG11(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11) 
#define FUNCLOG12(LogClass, retType, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11, p12Type, p12) 
#define FUNCLOGVOID1(LogClass,  CallType, fnName, p1Type, p1) 
#define FUNCLOGVOID2(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2) 
#define FUNCLOGVOID3(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3) 
#define FUNCLOGVOID4(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4) 
#define FUNCLOGVOID5(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5) 
#define FUNCLOGVOID6(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6) 
#define FUNCLOGVOID7(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7) 
#define FUNCLOGVOID8(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8) 
#define FUNCLOGVOID9(LogClass,  CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9) 
#define FUNCLOGVOID10(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10) 
#define FUNCLOGVOID11(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11) 
#define FUNCLOGVOID12(LogClass, CallType, fnName, p1Type, p1, p2Type, p2, p3Type, p3, p4Type, p4, p5Type, p5, p6Type, p6, p7Type, p7, p8Type, p8, p9Type, p9, p10Type, p10, p11Type, p11, p12Type, p12) 
#endif


/*
 * Tag implementation declarations
 */

#if DEBUGTAGS

#define DECLARE_DBGTAG(tagName, tagDescription, tagFlags, tagIndex)

#include "dbgtag.h"

/*
 * Define debug type information.
 */
#define DBGTAG_NAMELENGTH          19
#define DBGTAG_DESCRIPTIONLENGTH   41

typedef struct tagDBGTAG
{
    DWORD   dwDBGTAGFlags;
    char    achName[DBGTAG_NAMELENGTH + 1];
    char    achDescription[DBGTAG_DESCRIPTIONLENGTH + 1];
} DBGTAG;

#define DBGTAG_DISABLED         0x00000000
#define DBGTAG_ENABLED          0x00000001
#define DBGTAG_PRINT            0x00000002
#define DBGTAG_PROMPT           0x00000003
#define DBGTAG_VALIDUSERFLAGS   0x00000003
#define DBGTAG_REQUIRESREBOOT   0x10000000

__inline void
DbgTagBreak(int tag)
{
    if (IsDbgTagEnabled(tag)) {
        DbgBreakPoint();
    }
}

#endif // if DEBUGTAGS

/*
 * W32 wide RIP and error setting flags
 */

#define RIP_COMPONENT               GetRipComponent()

#define RIP_USERTAGBITS             0x0000ffff

/* shift amount to make RIP_LEVELBITS a 0-based index */
#define RIP_LEVELBITSSHIFT          0x1c
#define RIP_LEVELBITS               0x30000000
#define RIP_ERROR                   0x10000000
#define RIP_WARNING                 0x20000000
#define RIP_VERBOSE                 0x30000000

#define RIP_NONAME                  0x01000000
#define RIP_NONEWLINE               0x02000000
#define RIP_THERESMORE              0x04000000

/* shift amount to make RIP_COMPBITS a 0-based index */
#define RIP_COMPBITSSHIFT           0x10
#define RIP_COMPBITS                0x000f0000
#define RIP_USER                    0x00010000
#define RIP_USERSRV                 0x00020000
#define RIP_USERRTL                 0x00030000
#define RIP_GDI                     0x00040000
#define RIP_GDIKRNL                 0x00050000
#define RIP_GDIRTL                  0x00060000
#define RIP_BASE                    0x00070000
#define RIP_BASESRV                 0x00080000
#define RIP_BASERTL                 0x00090000
#define RIP_DISPLAYDRV              0x000a0000
#define RIP_CONSRV                  0x000b0000
#define RIP_USERKRNL                0x000c0000
#define RIP_IMM                     0x000d0000


#if DBG

ULONG        RipOutput(ULONG idErr, ULONG flags, LPSTR pszFile, int iLine, LPSTR pszErr, PEXCEPTION_POINTERS pexi);
ULONG _cdecl VRipOutput(ULONG idErr, ULONG flags, LPSTR pszFile, int iLine, LPSTR pszFmt, ...);

/*
 * CALLRIP calls a function and breaks if it returns true in a
 * single logical statement.
 */
#define CALLRIP(x)              \
    do {                        \
        if x {                  \
            DbgBreakPoint();    \
        }                       \
    } while (FALSE)             \

/***************************************************************************\
* Macros to set the last error and print a message to the debugger.
* Use one of the following flags:
*
* RIP_ERROR: A serious error in NTUSER. Will be printed and will cause a
* debug break by default. NTUSER should fix any occurance of a RIP_ERROR.
* Assertions use the RIP_ERROR flag.
*
* RIP_WARNING: A less serious error caused by an application. Will be printed
* but will not cause a debug break by default. Applications should fix
* any occurance of a RIP_WARNING.
*
* RIP_VERBOSE: An error caused by an application or intermediate USER code,
* or useful information for an application. Will not be printed and will
* not cause a debug break by default. Applications may want to fix
* occurances of RIP_VERBOSE messages to optimize their program.
*
*
* Use the following flags to control printing:
*
* RIP_NONAME: Doesn't print the prefix to the message. Useful for
* multiple RIPs.
*
* RIP_NONEWLINE: Doesn't print a newline after the message. Useful for
* multiple rips on a single line.
*
* RIP_THERESMORE: Indicates that this RIP will be followed by others in
* the same group. Prevents file/line and prompting until the last RIP
* in the group.
*
* You control RIP output in the debugger by using the "df"
* extension in userkdx.dll or userexts.dll, or type 'f' at a debug prompt.
*
* You can also control the default state of RIP output by setting the
* following registry values to 0 or 1 under the key
* HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\Current Version\Windows
*
* fPromptOnError, fPromptOnWarning, fPromptOnVerbose
* fPrintError, fPrintWarning, fPrintVerbose
* fPrintFileLine
*
\***************************************************************************/

/*
 * Use RIPERR to set a Win32 error code as the last error and print a message.
 */

#define RIPERR0(idErr, flags, szFmt)                                    CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt)))
#define RIPERR1(idErr, flags, szFmt, p1)                                CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1)))
#define RIPERR2(idErr, flags, szFmt, p1, p2)                            CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2)))
#define RIPERR3(idErr, flags, szFmt, p1, p2, p3)                        CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3)))
#define RIPERR4(idErr, flags, szFmt, p1, p2, p3, p4)                    CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4)))
#define RIPERR5(idErr, flags, szFmt, p1, p2, p3, p4, p5)                CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5)))
#define RIPERR6(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6)            CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6)))
#define RIPERR7(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6, p7)        CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7)))
#define RIPERR8(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)    CALLRIP((VRipOutput(idErr, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)))

/*
 * Use RIPNTERR to set an NTSTATUS as the last error and print a message.
 */
#define RIPNTERR0(status, flags, szFmt)                                 CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt)))
#define RIPNTERR1(status, flags, szFmt, p1)                             CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1)))
#define RIPNTERR2(status, flags, szFmt, p1, p2)                         CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2)))
#define RIPNTERR3(status, flags, szFmt, p1, p2, p3)                     CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3)))
#define RIPNTERR4(status, flags, szFmt, p1, p2, p3, p4)                 CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4)))
#define RIPNTERR5(status, flags, szFmt, p1, p2, p3, p4, p5)             CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5)))
#define RIPNTERR6(status, flags, szFmt, p1, p2, p3, p4, p5, p6)         CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6)))
#define RIPNTERR7(status, flags, szFmt, p1, p2, p3, p4, p5, p6, p7)     CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7)))
#define RIPNTERR8(status, flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8) CALLRIP((VRipOutput(RtlNtStatusToDosError(status), (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)))

/*
 * Use RIPMSG to print a message without setting the last error.
 */
#define RIPMSG0(flags, szFmt)                                           CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt)))
#define RIPMSG1(flags, szFmt, p1)                                       CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1)))
#define RIPMSG2(flags, szFmt, p1, p2)                                   CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2)))
#define RIPMSG3(flags, szFmt, p1, p2, p3)                               CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3)))
#define RIPMSG4(flags, szFmt, p1, p2, p3, p4)                           CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4)))
#define RIPMSG5(flags, szFmt, p1, p2, p3, p4, p5)                       CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5)))
#define RIPMSG6(flags, szFmt, p1, p2, p3, p4, p5, p6)                   CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6)))
#define RIPMSG7(flags, szFmt, p1, p2, p3, p4, p5, p6, p7)               CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7)))
#define RIPMSG8(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)           CALLRIP((VRipOutput(0, (flags) | RIP_COMPONENT, __FILE__, __LINE__, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)))


/*
 * Use W32ExceptionHandler in try-except blocks
 */
ULONG DBGW32ExceptionHandler(PEXCEPTION_POINTERS pexi, BOOL fSetLastError, ULONG ulflags);
#define W32ExceptionHandler(fSetLastError, ulflags) \
        DBGW32ExceptionHandler(GetExceptionInformation(), (fSetLastError), (ulflags))

#else /* of #ifdef DEBUG */

#define RIPERR0(idErr, flags, szFmt)                                    UserSetLastError(idErr)
#define RIPERR1(idErr, flags, szFmt, p1)                                UserSetLastError(idErr)
#define RIPERR2(idErr, flags, szFmt, p1, p2)                            UserSetLastError(idErr)
#define RIPERR3(idErr, flags, szFmt, p1, p2, p3)                        UserSetLastError(idErr)
#define RIPERR4(idErr, flags, szFmt, p1, p2, p3, p4)                    UserSetLastError(idErr)
#define RIPERR5(idErr, flags, szFmt, p1, p2, p3, p4, p5)                UserSetLastError(idErr)
#define RIPERR6(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6)            UserSetLastError(idErr)
#define RIPERR7(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6, p7)        UserSetLastError(idErr)
#define RIPERR8(idErr, flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)    UserSetLastError(idErr)

#define RIPNTERR0(status, flags, szFmt)                                 SetLastNtError(status)
#define RIPNTERR1(status, flags, szFmt, p1)                             SetLastNtError(status)
#define RIPNTERR2(status, flags, szFmt, p1, p2)                         SetLastNtError(status)
#define RIPNTERR3(status, flags, szFmt, p1, p2, p3)                     SetLastNtError(status)
#define RIPNTERR4(status, flags, szFmt, p1, p2, p3, p4)                 SetLastNtError(status)
#define RIPNTERR5(status, flags, szFmt, p1, p2, p3, p4, p5)             SetLastNtError(status)
#define RIPNTERR6(status, flags, szFmt, p1, p2, p3, p4, p5, p6)         SetLastNtError(status)
#define RIPNTERR7(status, flags, szFmt, p1, p2, p3, p4, p5, p6, p7)     SetLastNtError(status)
#define RIPNTERR8(status, flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8) SetLastNtError(status)

#define RIPMSG0(flags, szFmt)
#define RIPMSG1(flags, szFmt, p1)
#define RIPMSG2(flags, szFmt, p1, p2)
#define RIPMSG3(flags, szFmt, p1, p2, p3)
#define RIPMSG4(flags, szFmt, p1, p2, p3, p4)
#define RIPMSG5(flags, szFmt, p1, p2, p3, p4, p5)
#define RIPMSG6(flags, szFmt, p1, p2, p3, p4, p5, p6)
#define RIPMSG7(flags, szFmt, p1, p2, p3, p4, p5, p6, p7)
#define RIPMSG8(flags, szFmt, p1, p2, p3, p4, p5, p6, p7, p8)

ULONG _W32ExceptionHandler(NTSTATUS ExceptionCode);
#define W32ExceptionHandler(fSetLastError, ulflags)  \
        ((fSetLastError) ? _W32ExceptionHandler(GetExceptionCode()) : EXCEPTION_EXECUTE_HANDLER)

#endif /* #else of #ifdef DEBUG */

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))


/*
 * Macros for manipulating flag fields. All work for multiple flags.
 */
#define TEST_FLAG(field, flag)                  ((field) & (flag))
#define TEST_BOOL_FLAG(field, flag)             (((field) & (flag)) != 0)
#define SET_FLAG(field, flag)                   ((field) |= (flag))
#define CLEAR_FLAG(field, flag)                 ((field) &= ~(flag))
#define TOGGLE_FLAG(field, flag)                ((field ^= (flag))

/*
 * COPY_FLAG copies the value of flags from a source field
 * into a destination field.
 *
 * In the macro:
 * + "&flag" limits the outer xor operation to just the flag we're interested in.
 * + These are the results of the two xor operations:
 *
 * fieldDst    fieldSrc    inner xor   outer xor
 * 0           0           0           0
 * 0           1           1           1
 * 1           0           1           0
 * 1           1           0           1
 */
#define COPY_FLAG(fieldDst, fieldSrc, flag)     ((fieldDst) ^= ((fieldDst) ^ (fieldSrc)) & (flag))

/*
 * Define SET_OR_CLEAR_FLAG to do the following logically:
 *
 *  #define SET_OR_CLEAR_FLAG(field, flag, fset) ((fset) ? SET_FLAG(field, flag) : CLEAR_FLAG(field, flag))
 *
 * but with 5 fewer bytes.
 *
 * In the macro,
 * + "-!!(fset)" sets all bits in the source field to 1 if setting,
 *    0 if clearing.
 */
#define SET_OR_CLEAR_FLAG(field, flag, fset)    COPY_FLAG((field), -!!(fset), (flag))

// RIP flags and macros

#define RIPF_PROMPTONERROR              0x0001
#define RIPF_PROMPTONWARNING            0x0002
#define RIPF_PROMPTONVERBOSE            0x0004
#define RIPF_PRINTONERROR               0x0010
#define RIPF_PRINTONWARNING             0x0020
#define RIPF_PRINTONVERBOSE             0x0040
#define RIPF_PRINTFILELINE              0x0100
#define RIPF_HIDEPID                    0x0200

#define RIPF_DEFAULT                    ((WORD)(RIPF_PROMPTONERROR   |  \
                                                RIPF_PRINTONERROR    |  \
                                                RIPF_PRINTONWARNING))

#define RIPF_PROMPT_MASK                0x0007
#define RIPF_PROMPT_SHIFT               0x00
#define RIPF_PRINT_MASK                 0x0070
#define RIPF_PRINT_SHIFT                0x04
#define RIPF_VALIDUSERFLAGS             0x0377

#define TEST_RIPF(f)    TEST_FLAG(GetRipFlags(), f)

/*
 * Provides zero'd memory so you don't have to create zero'd memory on the
 * stack. The zero'd memory should never be modified. Use the ZERO and PZERO
 * macros to access the memory to ensure it is zero before it is used.
 *
 * Feel free to add more fields to the union as you need them.
 */
typedef union tagALWAYSZERO
{
    BYTE    b;
    WORD    w;
    DWORD   dw;
    int     i;
    POINT   pt;
    POINTL  ptl;
    RECT    rc;
    RECTL   rcl;
    LARGE_INTEGER li;
} ALWAYSZERO;

#if DBG
extern void ValidateZero(void);
#define ZERO(t)     (ValidateZero(), (*(t *)(void *)&gZero))
#define PZERO(t)    (ValidateZero(), ((t *)(void *)&gZero))
#else
#define ZERO(t)     ((*(t *)&gZero))
#define PZERO(t)    ((t *)&gZero)
#endif

/*
 * Special DbgPrint that is also available for Fre build.
 */
#if DBG

void FreDbgPrint(ULONG flags, LPSTR pszFile, int iLine, LPSTR pszFmt, ...);

  #define FRE_RIPMSG0 RIPMSG0
  #define FRE_RIPMSG1 RIPMSG1
  #define FRE_RIPMSG2 RIPMSG2
  #define FRE_RIPMSG3 RIPMSG3
  #define FRE_RIPMSG4 RIPMSG4
  #define FRE_RIPMSG5 RIPMSG5

#else   // DBG

  #if defined(PRERELEASE) || defined(USER_INSTRUMENTATION)

    void FreDbgPrint(ULONG flags, LPSTR pszFile, int iLine, LPSTR pszFmt, ...);

    #define FRE_RIPMSG0(flags, s)                   FreDbgPrint(flags, __FILE__, __LINE__, s)
    #define FRE_RIPMSG1(flags, s, a)                FreDbgPrint(flags, __FILE__, __LINE__, s, a)
    #define FRE_RIPMSG2(flags, s, a, b)             FreDbgPrint(flags, __FILE__, __LINE__, s, a, b)
    #define FRE_RIPMSG3(flags, s, a, b, c)          FreDbgPrint(flags, __FILE__, __LINE__, s, a, b, c)
    #define FRE_RIPMSG4(flags, s, a, b, c, d)       FreDbgPrint(flags, __FILE__, __LINE__, s, a, b, c, d)
    #define FRE_RIPMSG5(flags, s, a, b, c, d, e)    FreDbgPrint(flags, __FILE__, __LINE__, s, a, b, c, d, e)

  #else

    #define FRE_RIPMSG0(flags, x)
    #define FRE_RIPMSG1(flags, x, a)
    #define FRE_RIPMSG2(flags, x, a, b)
    #define FRE_RIPMSG3(flags, x, a, b, c)
    #define FRE_RIPMSG4(flags, x, a, b, c, d)
    #define FRE_RIPMSG5(flags, x, a, b, c, d, e)

  #endif  // PRERELEASE  || USER_INSTRUMENTATION

#endif  // DBG

#endif // _W32ERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\newres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#pragma pack(2)

typedef struct tagBITMAPHEADER
  {
    DWORD   Size;
    WORD    Width;
    WORD    Height;
    WORD    Planes;
    WORD    BitCount;
  } BITMAPHEADER;

// WHY WASN'T THIS DEFINED TO BE SAME AS RESOURCE FORMAT?
// Image File header
typedef struct tagIMAGEFILEHEADER
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} IMAGEFILEHEADER;

// File header
#define FT_ICON     1
#define FT_CURSOR   2

typedef struct tagICONFILEHEADER
{
        WORD iReserved;
        WORD iResourceType;
        WORD cresIcons;
        IMAGEFILEHEADER imh[1];
} ICONFILEHEADER;

typedef struct tagNEWHEADER {
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *LPNEWHEADER;

typedef struct tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
} ICONDIR;

// Format of resource directory (array of resources)

typedef struct tagRESDIR
{
        ICONDIR Icon;
        WORD    Planes;
        WORD    BitCount;
        DWORD   BytesInRes;
        WORD    idIcon;
} RESDIR, *LPRESDIR;

typedef struct tagRESDIRDISK
{
        struct  tagICONDIR  Icon;

        WORD   Reserved[2];
        DWORD  BytesInRes;
        DWORD  Offset;
} RESDIRDISK, *LPRESDIRDISK;

#pragma pack()
#endif // !RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\w32w64a.h ===
/****************************** Module Header ******************************\
* Module Name: w32w64a.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32W64A_
#define _W32W64A_

#include <w32w64.h>

#if !defined(_MAC) || !defined(GDI_INTERNAL)
DECLARE_KHANDLE(HBRUSH);
#endif

DECLARE_KHANDLE(HBITMAP);

#endif // _W32W64A_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\w32gdip.h ===
/****************************** Module Header ******************************\
* Module Name: w32gdip.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32GDIP_
#define _W32GDIP_

#include <wingdip.h>
#include "w32w64a.h"

// internal GDI/USER cursor structures and defines

#define CURSORF_FROMRESOURCE    0x0001 // it was loaded from a resource
#define CURSORF_GLOBAL          0x0002 // it never dies
#define CURSORF_LRSHARED        0x0004 // its cached
#define CURSORF_ACON            0x0008 // its animated
#define CURSORF_WOWCLEANUP      0x0010 // marked for cleanup at wow task exit time
#define CURSORF_ACONFRAME       0x0040 // its a frame of an acon
#define CURSORF_SECRET          0x0080 // created internally - not exposed to apps
#define CURSORF_LINKED          0x0100 // linked into a cache
#define CURSORF_SYSTEM          0x0200 // it's a system cursor
#define CURSORF_SHADOW          0x0400 // GDI created the shadow effect

/*
 * The CURSINFO structure defines cursor elements that both GRE and USER care
 * about. This information is persistent for a particular object. Thus, when
 * GRE needs to add a new object where it wants to cache some information
 * about a cursor, such as the combined bitmap image, it can be added here.
 * USER will copy the data about cursors starting from xHotspot, the flags
 * are normally not stored and are reinitialized. Thus, new elements like the
 * common bitmap image should be added after xHotspot, preferably last.
 *
 * BE VERY CAREFUL about changing CI_FIRST and CI_COPYSTART members, they
 * serve for casting purpose in the USER code. Don't make changes to
 * these structure members without understanding all implications first.
 */
#define CI_FIRST CURSORF_flags
#define CI_COPYSTART xHotspot

typedef struct _CURSINFO /* ci */
{
    DWORD CURSORF_flags;  // CURSORF_flags must be the first member of this
                          // struct, see CI_FIRST, tagCURSOR, and tagACON.
    SHORT   xHotspot;     // see comment above on CI_COPYSTART
    SHORT   yHotspot;
    KHBITMAP hbmMask;      // AND/XOR bits
    KHBITMAP hbmColor;
    KHBITMAP hbmAlpha;     // GDI alpha bitmap cache
    RECT    rcBounds;     // GDI created tight bounds of the visible shape
    KHBITMAP hbmUserAlpha; // USER alpha bitmap cache
} CURSINFO, *PCURSINFO;

//
// PolyPatBlt
//

typedef struct _POLYPATBLT
{
    int     x;
    int     y;
    int     cx;
    int     cy;
    union {
        KHBRUSH  hbr;
        COLORREF clr;
    } BrClr;
} POLYPATBLT,*PPOLYPATBLT;

#define PPB_BRUSH         0
#define PPB_COLORREF      1

WINGDIAPI
BOOL
WINAPI
PolyPatBlt(
    HDC,
    DWORD,
    PPOLYPATBLT,
    DWORD,
    DWORD
    );

#endif // _W32GDIP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\w32p.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    w32p.h

Abstract:

    private header file for Win32 kernel mode driver

Author:

    Mark Lucovsky (markl) 31-Oct-1994

Revision History:

--*/

#ifndef _W32P_
#define _W32P_

#include "w32w64.h"

//
// Service Table description (from table.stb)
//

extern ULONG_PTR W32pServiceTable[];
extern ULONG W32pServiceLimit;
extern UCHAR W32pArgumentTable[];

//
// shared handle table
//

extern PVOID *gpHmgrSharedHandleTable;
extern PVOID  gpHmgrSharedHandleSection;

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

#define W32_SERVICE_NUMBER WIN32K_SERVICE_INDEX

W32KAPI
VOID NtGdiFlushUserBatch(void);

#if defined(_X86_)
//
// Keep our own copy of this to avoid double indirections on probing
//

extern ULONG Win32UserProbeAddress;
#undef  MM_USER_PROBE_ADDRESS
#define MM_USER_PROBE_ADDRESS Win32UserProbeAddress
#endif

typedef struct _W32THREAD * KPTR_MODIFIER PW32THREAD;

//
// The following is a "thread lock structure". This structure lives on
// the stack and is linked into a LIFO list that is rooted in the thread
// information structure.
//
// In DBG, a shadow of it is copied in gThreadLocksArray where it will persist
// The stack TL will have the ptl point to the global element while the
// global will have ptl point to the stack TL.
// A freed global TL will have TL_FREED_PATTERN in the HIWORD of uTLCount
//
typedef struct _TL {
    struct _TL    *next;
    PVOID          pobj;
    PFREE_FUNCTION pfnFree;
#if DBG
    ULONG          uTLCount;
    PW32THREAD     pW32Thread;
    PVOID          pfnCaller;
    struct _TL    *ptl;
#endif
} TL, * KPTR_MODIFIER PTL;

#define TL_FREED_PATTERN 0x4f000000
#if DBG
//
// global array of TL structures
//
extern PTL gFreeTLList;
extern void CreateShadowTL(PTL ptl);
#endif

//
// This is the header shared info for W32 threads.  It is followed by the
// NtUser per thread information.
//

typedef struct _W32THREAD {
    PETHREAD        pEThread;
    ULONG           RefCount;
    PTL             ptlW32;
    KERNEL_PVOID    pgdiDcattr;
    KERNEL_PVOID    pgdiBrushAttr;
    KERNEL_PVOID    pUMPDObjs;
    KERNEL_PVOID    pUMPDHeap;
    ULONG           dwEngAcquireCount;
    KERNEL_PVOID    pSemTable;
    KERNEL_PVOID    pUMPDObj;
#if defined(_WIN64)
    KERNEL_PVOID    pProxyPort;
    KERNEL_PVOID    pClientID;
#endif
} W32THREAD, * KPTR_MODIFIER PW32THREAD;

#define W32PF_CONSOLEAPPLICATION          0x00000001
#define W32PF_FORCEOFFFEEDBACK            0x00000002
#define W32PF_STARTGLASS                  0x00000004
#define W32PF_WOW                         0x00000008
#define W32PF_READSCREENACCESSGRANTED     0x00000010
#define W32PF_INITIALIZED                 0x00000020
#define W32PF_APPSTARTING                 0x00000040
#define W32PF_WOW64                       0x00000080 /* Process emulated 32bit */
#define W32PF_ALLOWFOREGROUNDACTIVATE     0x00000100
#define W32PF_OWNDCCLEANUP                0x00000200
#define W32PF_SHOWSTARTGLASSCALLED        0x00000400
#define W32PF_FORCEBACKGROUNDPRIORITY     0x00000800
#define W32PF_TERMINATED                  0x00001000
#define W32PF_CLASSESREGISTERED           0x00002000
#define W32PF_THREADCONNECTED             0x00004000
#define W32PF_PROCESSCONNECTED            0x00008000
#define W32PF_WAKEWOWEXEC                 0x00010000
#define W32PF_WAITFORINPUTIDLE            0x00020000
#define W32PF_IOWINSTA                    0x00040000
#define W32PF_ALLOWSETFOREGROUND          0x00080000
#define W32PF_OLELOADED                   0x00100000
#define W32PF_SCREENSAVER                 0x00200000
#define W32PF_IDLESCREENSAVER             0x00400000
#define W32PF_DISABLEIME                  0x00800000
#define W32PF_SETUPAPP                    0x01000000
#define W32PF_RESTRICTED                  0x02000000
#define W32PF_CONSOLEHASFOCUS             0x04000000

//
// Process must be first element of structure to correctly handle
// initialization.  See PsConvertToGuiThread in ntos\ps\psquery.c.
//

typedef ULONG W32PID;

typedef struct _W32PROCESS * KPTR_MODIFIER PW32PROCESS;

typedef struct _W32PROCESS {
    PEPROCESS       Process;
    ULONG           RefCount;
    ULONG           W32PF_Flags;    // must hold USER lock while changing this
    PKEVENT         InputIdleEvent;
    ULONG           StartCursorHideTime;
    PW32PROCESS     NextStart;
    KERNEL_PVOID    pDCAttrList;
    KERNEL_PVOID    pBrushAttrList;
    W32PID          W32Pid;
    LONG            GDIHandleCount;
    LONG            UserHandleCount;
} W32PROCESS;


#define W32GetCurrentProcess() ((PW32PROCESS)PsGetCurrentProcessWin32Process())
#define W32GetCurrentThread()  ((PW32THREAD)PsGetCurrentThreadWin32Thread())


#define PID_BITS 0xfffffffc  // The actual bits used by the PID

#define W32GetCurrentPID() (W32PID)(HandleToUlong(PsGetCurrentProcessId()) & PID_BITS)
#define W32GetCurrentTID() (W32PID)HandleToUlong(PsGetCurrentThreadId())

NTSTATUS
UserPowerStateCallout(
    IN PKWIN32_POWERSTATE_PARAMETERS Parms);

NTSTATUS
UserPowerEventCallout(
    IN PKWIN32_POWEREVENT_PARAMETERS Parms);

PVOID
UserGlobalAtomTableCallout(
    VOID);

NTSTATUS
xxxUserProcessCallout(
    IN PW32PROCESS Process,
    IN BOOLEAN Initialize);

NTSTATUS
UserThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType);

VOID
UserDeleteW32Process(
    IN PW32PROCESS pW32Process);

VOID
UserDeleteW32Thread(
    IN PW32THREAD pW32Thread);

NTSTATUS
GdiProcessCallout(
    IN PW32PROCESS Process,
    IN BOOLEAN Initialize);

VOID
GdiThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType);

BOOLEAN
InitializeGre(
    VOID);


NTSTATUS
W32pProcessCallout(
    IN PEPROCESS Process,
    IN BOOLEAN Initialize);


NTSTATUS
W32pThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType);


//
// Generic thread locking functions
//

#if DBG
ULONG ValidateThreadLocks(
    PTL NewLock,
    PTL OldLock,
    ULONG_PTR dwLimit,
    BOOLEAN fHM);
#else
#define ValidateThreadLocks(NewLock, OldLock, dwLimit, fHM)
#endif

//
// DO_INLINE controls whether we want to try inlining the thread locking
// functions. We always want to try inlining on free builds. On debug builds,
// we don't want to inline and we don't want to include multiple copies of
// this code, so we define DO_INCLUDE as empty in w32init.c.
//

#if !DBG
#undef DO_INLINE
#define DO_INLINE __inline
#endif

#ifdef DO_INLINE

DO_INLINE VOID
PushW32ThreadLock(
    IN PVOID pobj,
    IN PTL ptl,
    IN PFREE_FUNCTION pfnFree
    )
{
#if DBG
    PVOID pfnT;
#endif
    PW32THREAD pW32Thread = W32GetCurrentThread();

    ptl->next = (struct _TL *)(LONG_PTR)((W32THREAD *)(LONG_PTR)pW32Thread)->ptlW32;
    pW32Thread->ptlW32 = ptl;
    ptl->pobj = pobj;
    ptl->pfnFree = pfnFree;
#if DBG
    ptl->pW32Thread = pW32Thread;
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    CreateShadowTL(ptl);
    ValidateThreadLocks(ptl, ptl->next, (ULONG_PTR)&pW32Thread, FALSE);
#endif
}

DO_INLINE VOID
ExchangeW32ThreadLock(
    IN PVOID pobj,
    IN PTL ptl
    )
{
#if DBG
    PVOID pfnT;
    PW32THREAD pW32Thread = W32GetCurrentThread();
#endif
    PVOID pobjOld;

    pobjOld = ptl->pobj;
    ptl->pobj = pobj;
    if (pobjOld) {
        ptl->pfnFree(pobjOld);
    }
#if DBG
    ASSERT(ptl->pW32Thread == pW32Thread);
    RtlGetCallersAddress(&ptl->pfnCaller, &pfnT);
    ValidateThreadLocks(ptl, ptl->next, (ULONG_PTR)&pW32Thread, FALSE);
    /*
     * Maintain gFreeTLList
     */
    ptl->ptl->pobj = pobj;
    ptl->ptl->pfnCaller = ptl->pfnCaller;
#endif
}

DO_INLINE VOID
PopW32ThreadLock(
    IN PTL ptl
    )
{
    PW32THREAD pW32Thread = W32GetCurrentThread();

#if DBG
    ASSERT(ptl);
    ASSERT(ptl == pW32Thread->ptlW32);
    ValidateThreadLocks(NULL, ptl, (ULONG_PTR)&pW32Thread, FALSE);
#endif
    pW32Thread->ptlW32 = ptl->next;
#if DBG
    ptl->ptl->next = gFreeTLList;
    ptl->ptl->uTLCount += TL_FREED_PATTERN;
    gFreeTLList = ptl->ptl;
#endif
}

DO_INLINE VOID
PopAndFreeW32ThreadLock(
    IN PTL ptl
    )
{
    PW32THREAD pW32Thread = W32GetCurrentThread();

#if DBG
    ASSERT(ptl);
    ASSERT(ptl == pW32Thread->ptlW32);
    ValidateThreadLocks(NULL, ptl, (ULONG_PTR)&pW32Thread, FALSE);
#endif
    pW32Thread->ptlW32 = ptl->next;
    if (ptl->pobj) {
        ptl->pfnFree(ptl->pobj);
    }
#if DBG
    ptl->ptl->next = gFreeTLList;
    ptl->ptl->uTLCount += TL_FREED_PATTERN;
    gFreeTLList = ptl->ptl;
#endif
}

DO_INLINE VOID
PopAndFreeAlwaysW32ThreadLock(
    IN PTL ptl
    )
{
    PW32THREAD pW32Thread = W32GetCurrentThread();

#if DBG
    ASSERT(ptl);
    ASSERT(ptl == pW32Thread->ptlW32);
    ValidateThreadLocks(NULL, ptl, (ULONG_PTR)&pW32Thread, FALSE);
    ASSERT(ptl->pobj);
#endif
    pW32Thread->ptlW32 = ptl->next;
    ptl->pfnFree(ptl->pobj);

#if DBG
    ptl->ptl->next = gFreeTLList;
    ptl->ptl->uTLCount += TL_FREED_PATTERN;
    gFreeTLList = ptl->ptl;
#endif
}

#else

VOID PushW32ThreadLock(IN PVOID pobj, IN PTL ptl, IN PFREE_FUNCTION pfnFree);
VOID ExchangeW32ThreadLock(IN PVOID pobj, IN PTL ptl);
VOID PopW32ThreadLock(IN PTL ptl);
VOID PopAndFreeW32ThreadLock(IN PTL ptl);
VOID PopAndFreeAlwaysW32ThreadLock(IN PTL ptl);

#endif

VOID
CleanupW32ThreadLocks(
    IN PW32THREAD pW32Thread
    );

//
// Process and thread manipulation functions
//

VOID
DereferenceW32Thread(
    IN PW32THREAD pW32Thread);

NTSTATUS
AllocateW32Process(
    IN OUT PEPROCESS pEProcess);

NTSTATUS
AllocateW32Thread(
    IN OUT PETHREAD pEThread);

__inline VOID
FreeW32Thread(
    IN OUT PETHREAD pEThread)
{
    ASSERT(pEThread == PsGetCurrentThread());
    ASSERT(PsGetThreadWin32Thread(pEThread) != NULL);

    DereferenceW32Thread((PW32THREAD)PsGetThreadWin32Thread(pEThread));
}

VOID
LockW32Process(
    IN PW32PROCESS pW32Process,
    IN PTL ptl);

#define UnlockW32Process(ptl) \
        PopAndFreeW32ThreadLock(ptl)

VOID
LockW32Thread(
    IN PW32THREAD pW32Thread,
    IN PTL ptl);

VOID
LockExchangeW32Thread(
    IN PW32THREAD pW32Thread,
    IN PTL ptl);

#define UnlockW32Thread(ptl) \
        PopAndFreeW32ThreadLock(ptl)

//
// Base address where win32k.sys is loaded.
//
extern PVOID gpvWin32kImageBase;
#endif // _W32P_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow6432\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\w32wow64.h ===
/****************************** Module Header ******************************\
* Module Name: w32wow64.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32WOW64_
#define _W32WOW64_

#include "w32w64a.h"

/*
 * Pointers in shared memory need to be 64-bit for user32 on 64-bit kernel
 */
#ifdef BUILD_WOW6432

#define BUILD_WOW64

#include <wow64t.h>

#ifndef BUILD_WOW6432_WRN
// disable ptr truncation warnings on the 32/64 build
// by default
#pragma warning (disable:4244)
// disable warnings for ((KERNEL_PVOID)p) == NULL
#pragma warning (disable:4047)
#endif

    /*
     * From windows\inc\windef.w
     */
    typedef KERNEL_UINT_PTR         KERNEL_WPARAM;
    typedef KERNEL_LONG_PTR         KERNEL_LPARAM;
    typedef KERNEL_LONG_PTR         KERNEL_LRESULT;

    #define KERNEL_WPARAM_TO_WPARAM(w)       ((WPARAM)(w))
    #define KERNEL_LPARAM_TO_LPARAM(l)       ((LPARAM)(l))
    #define KERNEL_LRESULT_TO_LRESULT(r)     ((LRESULT)(r))
    #define KERNEL_INT_PTR_TO_INT_PTR(i)     ((INT)(i))
    #define KERNEL_ULONG_PTR_TO_ULONG_PTR(u) ((ULONG)(u))
    #define KPBYTE_TO_PBYTE(p)               ((PBYTE)(KERNEL_ULONG_PTR)(p))
    #define KPRECT_TO_PRECT(p)               ((PRECT)(KERNEL_ULONG_PTR)(p))
    #define KPSBDATA_TO_PSBDATA(p)           ((PSBDATA)(KERNEL_ULONG_PTR)(p))
    #define KPVOID_TO_PVOID(p)               ((PVOID)(KERNEL_ULONG_PTR)(p))
    #define KPWSTR_TO_PWSTR(p)               ((PWSTR)(KERNEL_ULONG_PTR)(p))
    #define KHANDLE_TO_HANDLE(h)             ((HANDLE)(KERNEL_ULONG_PTR)(h))
    #define KHBITMAP_TO_HBITMAP(h)           ((HBITMAP)(KERNEL_ULONG_PTR)(h))
    #define KHBRUSH_TO_HBRUSH(h)             ((HBRUSH)(KERNEL_ULONG_PTR)(h))
    #define KHFONT_TO_HFONT(h)               ((HFONT)(KERNEL_ULONG_PTR)(h))
    #define KHICON_TO_HICON(h)               ((HICON)(KERNEL_ULONG_PTR)(h))
    #define KHIMC_TO_HIMC(h)                 ((HIMC)(KERNEL_ULONG_PTR)(h))
    #define KHKL_TO_HKL(h)                   ((HKL)(KERNEL_ULONG_PTR)(h))
    #define KHRGN_TO_HRGN(h)                 ((HRGN)(KERNEL_ULONG_PTR)(h))
    #define KHWND_TO_HWND(h)                 ((HWND)(KERNEL_ULONG_PTR)(h))
    typedef KERNEL_PVOID KPROC;

    typedef PEB64 PEBSHARED, *PPEBSHARED;
    typedef TEB64 TEBSHARED, *PTEBSHARED;

    #define NtCurrentTeb64()   ((PTEB64)((PTEB32)NtCurrentTeb())->GdiBatchCount)
    #define NtCurrentPeb64()   ((PPEB64)NtCurrentTeb64()->ProcessEnvironmentBlock)

    #define NtCurrentPebShared() NtCurrentPeb64()
    #define NtCurrentTebShared() NtCurrentTeb64()

#if defined(_AMD64_) || defined(_X86_) || defined(_IA64_)
    // use IA64 PAGE_SIZE
    #define KERNEL_PAGE_SIZE (0x2000)
#else
    #error Unknown platform for KERNEL_PAGE_SIZE
#endif

#else  // BUILD_WOW6432
    typedef WPARAM                  KERNEL_WPARAM;
    typedef LPARAM                  KERNEL_LPARAM;
    typedef LRESULT                 KERNEL_LRESULT;

    #define KERNEL_WPARAM_TO_WPARAM(w)       (w)
    #define KERNEL_LPARAM_TO_LPARAM(l)       (l)
    #define KERNEL_LRESULT_TO_LRESULT(r)     (r)
    #define KERNEL_INT_PTR_TO_INT_PTR(i)     (i)
    #define KERNEL_ULONG_PTR_TO_ULONG_PTR(u) (u)
    #define KPBYTE_TO_PBYTE(p)               (p)
    #define KPRECT_TO_PRECT(p)               (p)
    #define KPSBDATA_TO_PSBDATA(p)           (p)
    #define KPVOID_TO_PVOID(p)               (p)
    #define KPWSTR_TO_PWSTR(p)               (p)
    #define KHANDLE_TO_HANDLE(h)             (h)
    #define KHBITMAP_TO_HBITMAP(h)           (h)
    #define KHBRUSH_TO_HBRUSH(h)             (h)
    #define KHFONT_TO_HFONT(h)               (h)
    #define KHICON_TO_HICON(h)               (h)
    #define KHIMC_TO_HIMC(h)                 (h)
    #define KHKL_TO_HKL(h)                   (h)
    #define KHRGN_TO_HRGN(h)                 (h)
    #define KHWND_TO_HWND(h)                 (h)
    typedef PROC KPROC;

    typedef PEB PEBSHARED, *PPEBSHARED;
    typedef TEB TEBSHARED, *PTEBSHARED;

    #define NtCurrentPebShared() NtCurrentPeb()
    #define NtCurrentTebShared() NtCurrentTeb()

    #define KERNEL_PAGE_SIZE PAGE_SIZE

#endif // BUILD_WOW64

DECLARE_KHANDLE(HCOLORSPACE);
DECLARE_KHANDLE(HDC);
DECLARE_KHANDLE(HFONT);
DECLARE_KHANDLE(HICON);
typedef KHICON KHCURSOR;    // HICON & HCURSOR are polymorphic
DECLARE_KHANDLE(HKL);
DECLARE_KHANDLE(HRGN);
DECLARE_KHANDLE(HWND);

typedef BYTE *              KPTR_MODIFIER   KPBYTE;
typedef WORD *              KPTR_MODIFIER   KPWORD;
typedef INT *               KPTR_MODIFIER   KPINT;
typedef DWORD *             KPTR_MODIFIER   KPDWORD;
typedef ULONG_PTR *         KPTR_MODIFIER   KPULONG_PTR;
typedef KERNEL_ULONG_PTR *  KPTR_MODIFIER   KPKERNEL_ULONG_PTR;
typedef WCHAR *             KPTR_MODIFIER   KLPWSTR;
typedef WCHAR *             KPTR_MODIFIER   KPWSTR;
typedef CHAR *              KPTR_MODIFIER   KLPSTR;
typedef CHAR *              KPTR_MODIFIER   KPSTR;

#ifdef BUILD_WOW6432

    /*
     * Message structure
     *
     * This is copied right out of windows\inc\winuser.w
     */
    typedef struct tagKERNEL_MSG {
        KHWND           hwnd;
        UINT            message;
        KERNEL_WPARAM   wParam;
        KERNEL_LPARAM   lParam;
        DWORD           time;
        POINT           pt;
    } KERNEL_MSG, *PKERNEL_MSG;

    __inline VOID
    COPY_KERNELMSG_TO_MSG(PMSG pmsg, PKERNEL_MSG pkmsg)
    {
        pmsg->hwnd      = KHWND_TO_HWND(pkmsg->hwnd);
        pmsg->message   = pkmsg->message;
        pmsg->wParam    = KERNEL_WPARAM_TO_WPARAM(pkmsg->wParam);
        pmsg->lParam    = KERNEL_LPARAM_TO_LPARAM(pkmsg->lParam);
        pmsg->time      = pkmsg->time;
        pmsg->pt        = pkmsg->pt;
    }

    __inline VOID
    COPY_MSG_TO_KERNELMSG(PKERNEL_MSG pkmsg, PMSG pmsg)
    {
        pkmsg->hwnd     = pmsg->hwnd;
        pkmsg->message  = pmsg->message;
        pkmsg->wParam   = pmsg->wParam;
        pkmsg->lParam   = pmsg->lParam;
        pkmsg->time     = pmsg->time;
        pkmsg->pt       = pmsg->pt;
    }

#else // BUILD_WOW6432

    #define KERNEL_MSG              MSG
    #define PKERNEL_MSG             PMSG

    #define COPY_KERNELMSG_TO_MSG(pmsg, pkmsg) RtlCopyMemory(pmsg, pkmsg, sizeof(MSG))
    #define COPY_MSG_TO_KERNELMSG(pkmsg, pmsg) RtlCopyMemory(pkmsg, pmsg, sizeof(MSG))

#endif

#endif // _W32WOW64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\winsrv\makefile.inc ===
winsrv.rc: ..\vgasys.fnt \ 
        $(PROJECT_ROOT)\core\ntcon\server\res.rc \
        $(PROJECT_ROOT)\core\ntuser\server\res.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow6432\makefile.inc ===
$(O)\services.tab: ..\services.tab
    $(C_PREPROCESSOR)  $** > $@

$(O)\usrstubs.obj: $(O)\usrstubs.$(ASM_SUFFIX)

$(O)\usrstubs.$(ASM_SUFFIX): $(O)\services.tab $(TARGET_DIRECTORY)\table.stb $(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) $(TARGET_BRACES) -s $(TARGET_DIRECTORY) $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\winsrv\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-23-1996 WKwok Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\w32inc\winuserk.h ===
/****************************************************************************
*                                                                           *
* winuserk.h -- New private kernel-mode APIs                                *
*                                                                           *
* Copyright (c) 1985 - 1999, Microsoft Corporation                          *
*                                                                           *
****************************************************************************/


#ifndef _WINUSERK_
#define _WINUSERK_

#include "w32w64.h"

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_USER32_)
#define WINUSERAPI DECLSPEC_IMPORT
#else
#define WINUSERAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef struct tagDESKTOP * KPTR_MODIFIER PDESKTOP;

typedef enum _CONSOLECONTROL {
    ConsoleDesktopConsoleThread,     // 0
    ConsoleClassAtom,                // 1
    ConsolePermanentFont,            // 2
    ConsoleSetVDMCursorBounds,       // 3
    ConsoleNotifyConsoleApplication, // 4
    ConsolePublicPalette,            // 5
    ConsoleWindowStationProcess,     // 6
    ConsoleRegisterConsoleIME,       // 7
    ConsoleFullscreenSwitch,         // 8
    ConsoleSetCaretInfo              // 9
} CONSOLECONTROL;


/*
 * Hard error functions
 */
#define HEF_NORMAL       0        /* normal FIFO error processing */
#define HEF_SWITCH       1        /* desktop switch occured */
#define HEF_RESTART      2        /* hard error was reordered, restart processing */

typedef struct _CONSOLEDESKTOPCONSOLETHREAD {
    HDESK hdesk;
    DWORD dwThreadId;
} CONSOLEDESKTOPCONSOLETHREAD, *PCONSOLEDESKTOPCONSOLETHREAD;

typedef struct _CONSOLEWINDOWSTATIONPROCESS {
    DWORD dwProcessId;
    HWINSTA hwinsta;
} CONSOLEWINDOWSTATIONPROCESS, *PCONSOLEWINDOWSTATIONPROCESS;

#if defined(FE_IME)
enum {REGCONIME_QUERY, REGCONIME_REGISTER, REGCONIME_UNREGISTER, REGCONIME_TERMINATE};

typedef struct _CONSOLE_REGISTER_CONSOLEIME {
    IN HDESK hdesk;
    IN DWORD dwThreadId;
    IN DWORD dwAction;   // is REGCONIME_QUERY/REGISTER/UNREGISTER/TERMINATE
    OUT DWORD dwConsoleInputThreadId;
} CONSOLE_REGISTER_CONSOLEIME, *PCONSOLE_REGISTER_CONSOLEIME;
#endif

typedef struct _CONSOLE_FULLSCREEN_SWITCH {
    IN BOOL      bFullscreenSwitch;
    IN HWND      hwnd;
    IN PDEVMODEW pNewMode;
} CONSOLE_FULLSCREEN_SWITCH, *PCONSOLE_FULLSCREEN_SWITCH;

/*
 * Bug 273518 - joejo
 *
 * Adding optimization to bug fix
 */
#define CPI_NEWPROCESSWINDOW    0x0001

typedef struct _CONSOLE_PROCESS_INFO {
    IN DWORD    dwProcessID;
    IN DWORD    dwFlags;
} CONSOLE_PROCESS_INFO, *PCONSOLE_PROCESS_INFO;

typedef struct _CONSOLE_CARET_INFO {
    IN HWND hwnd;
    IN RECT rc;
} CONSOLE_CARET_INFO, *PCONSOLE_CARET_INFO;

NTSTATUS
NtUserConsoleControl(
    IN CONSOLECONTROL Command,
    IN OUT PVOID ConsoleInformation,
    IN ULONG ConsoleInformationLength
    );

HDESK
NtUserResolveDesktop(
    IN HANDLE hProcess,
    IN PUNICODE_STRING pstrDesktop,
    IN BOOL fInherit,
    OUT HWINSTA *phwinsta
    );

WINUSERAPI
BOOL
NtUserNotifyProcessCreate(
    IN DWORD dwProcessId,
    IN DWORD dwParentThreadId,
    IN ULONG_PTR dwData,
    IN DWORD dwFlags
    );

typedef enum _HARDERRORCONTROL {
    HardErrorSetup,
    HardErrorCleanup,
    HardErrorAttach,
    HardErrorAttachUser,
    HardErrorDetach,
    HardErrorAttachNoQueue,
    HardErrorDetachNoQueue,
    HardErrorQuery,
    HardErrorInDefDesktop,
} HARDERRORCONTROL;


/*
 * This structure is used to pass a handle and a pointer back
 * for later restoration when setting a CSRSS thread to a desktop.
 */

typedef struct tagDESKRESTOREDATA {
    PDESKTOP pdeskRestore;
    HDESK    hdeskNew;              /*
                                     * This handle is opened to guarantee
                                     * that the desktop stays around and
                                     * active while the CSRSS thread is
                                     * using it.
                                     */
} DESKRESTOREDATA, *PDESKRESTOREDATA;

UINT
NtUserHardErrorControl(
    IN HARDERRORCONTROL dwCmd,
    IN HANDLE handle OPTIONAL,
    OUT PDESKRESTOREDATA pdrdRestore OPTIONAL
    );

#define HEC_SUCCESS         0
#define HEC_ERROR           1
#define HEC_WRONGDESKTOP    2
#define HEC_DESKTOPSWITCH   3


typedef enum _USERTHREADINFOCLASS {
    UserThreadShutdownInformation,
    UserThreadFlags,
    UserThreadTaskName,
    UserThreadWOWInformation,
    UserThreadHungStatus,
    UserThreadInitiateShutdown,
    UserThreadEndShutdown,
    UserThreadUseDesktop,
    UserThreadPolled,           // obsolete
    UserThreadKeyboardState,    // obsolete
    UserThreadCsrApiPort,
    UserThreadResyncKeyState,   // obsolete
    UserThreadUseActiveDesktop
} USERTHREADINFOCLASS;

typedef enum _USERPROCESSINFOCLASS {
    UserProcessFlags
} USERPROCESSINFOCLASS;

#define USER_THREAD_GUI     1

typedef struct _USERTHREAD_SHUTDOWN_INFORMATION {
    HWND hwndDesktop;
    NTSTATUS StatusShutdown;
    DWORD dwFlags;
    DESKRESTOREDATA drdRestore;  /* Must be the last field or will be zero'ed */
} USERTHREAD_SHUTDOWN_INFORMATION, *PUSERTHREAD_SHUTDOWN_INFORMATION;

typedef struct _USERTHREAD_FLAGS {
    DWORD dwFlags;
    DWORD dwMask;
} USERTHREAD_FLAGS, *PUSERTHREAD_FLAGS;

typedef struct _USERTHREAD_USEDESKTOPINFO {
    HANDLE hThread;
    DESKRESTOREDATA drdRestore;
} USERTHREAD_USEDESKTOPINFO, *PUSERTHREAD_USEDESKTOPINFO;


typedef USERTHREAD_FLAGS USERPROCESS_FLAGS;
typedef USERTHREAD_FLAGS *PUSERPROCESS_FLAGS;

typedef struct _USERTHREAD_WOW_INFORMATION {
    PVOID lpfnWowExitTask;
    DWORD hTaskWow;
} USERTHREAD_WOW_INFORMATION, *PUSERTHREAD_WOW_INFORMATION;

WINUSERAPI
NTSTATUS
NtUserQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSTATUS
NtUserSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
    );

NTSTATUS
NtUserSetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );

WINUSERAPI
NTSTATUS
NtUserSoundSentry(
    VOID
    );


WINUSERAPI
NTSTATUS
NtUserTestForInteractiveUser(
    IN PLUID pluidCaller
    );

WINUSERAPI
NTSTATUS
NtUserInitialize(
    IN DWORD dwVersion,
    IN HANDLE hPowerRequestEvent,
    IN HANDLE hMediaChangeEvent);

WINUSERAPI
NTSTATUS
NtUserProcessConnect(
    IN HANDLE hProcess,
    IN OUT PVOID pConnectInfo,
    IN ULONG cbConnectInfo
    );

HPALETTE
NtUserSelectPalette(
    IN HDC hdc,
    IN HPALETTE hpalette,
    IN BOOL fForceBackground
    );

typedef enum _WINDOWINFOCLASS {
    WindowProcess,
    WindowThread,
    WindowActiveWindow,
    WindowFocusWindow,
    WindowIsHung,
    WindowClientBase,
    WindowIsForegroundThread,
    WindowDefaultImeWindow,
    WindowDefaultInputContext,
    WindowActiveDefaultImeWindow,
} WINDOWINFOCLASS;

HANDLE
NtUserQueryWindow(
    IN HWND hwnd,
    IN WINDOWINFOCLASS WindowInformation
    );

typedef enum _USERTHREADSTATECLASS {
    UserThreadStateFocusWindow,
    UserThreadStateActiveWindow,
    UserThreadStateCaptureWindow,
    UserThreadStateDefaultImeWindow,
    UserThreadStateDefaultInputContext,
    UserThreadStateInputState,
    UserThreadStateCursor,
    UserThreadStateChangeBits,
    UserThreadStatePeekMessage,
    UserThreadStateExtraInfo,
    UserThreadStateInSendMessage,
    UserThreadStateMessageTime,
    UserThreadStateIsForeground,
// #if defined(FE_IME)
    UserThreadStateImeCompatFlags,
    UserThreadStatePreviousKeyboardLayout,
    UserThreadStateIsWinlogonThread,
    UserThreadStateNeedsSecurity,
// #endif
    UserThreadStateIsConImeThread,
    UserThreadConnect,
} USERTHREADSTATECLASS;

ULONG_PTR
NtUserGetThreadState(
    IN USERTHREADSTATECLASS ThreadState);

NTSTATUS
NtUserEnumDisplaySettings(
    IN PUNICODE_STRING pstrDeviceName,
    IN DWORD           iModeNum,
    OUT LPDEVMODEW     lpDevMode,
    IN DWORD           dwFlags);

#if defined(FE_IME)
BOOL
NtUserGetObjectInformation(
    IN HANDLE hObject,
    IN int nIndex,
    OUT PVOID pvInfo,
    IN DWORD nLength,
    IN LPDWORD pnLengthNeeded);
#endif // FE_IME


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_WINUSERK_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow6432\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=w32
W32_SB=1

TARGETNAME=w32wow
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
PASS1_PUBLISH={$(O)\w32wow.lib=$(WINDOWS_LIB_PATH)\w32wow.lib}

INCLUDES=..\..\..\inc

SOURCES=

NTTARGETFILE0=$(O)\usrstubs.$(ASM_SUFFIX)

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    Common macros shared between cgen, whcon, and whwin32.


!ENDIF

!include $(WINCORE_PATH)\core.inc
SOURCE_USED=..\sources.inc $(WINCORE_PATH)\core.inc

W32_SB=1

MAJORCOMP=windows

INCLUDES=$(INCLUDES);$(MULTIMEDIA_INC_PATH);$(WINCORE_PATH)\w32inc;$(SDKTOOLS_INC_PATH);
INCLUDES=$(INCLUDES);$(WINCORE_PATH)\ntcon\inc;$(WINCORE_PATH)\ntcon\client
INCLUDES=$(INCLUDES);$(WINCORE_PATH)\ntgdi\inc;$(WINCORE_PATH)\ntuser\inc;$(BASE_INC_PATH)
INCLUDES=$(INCLUDES);$(DDK_INC_PATH)
INCLUDES=$(INCLUDES);$(WINCORE_PATH)\w32inc\$(O)

USE_NTDLL=1

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -D_USER32_ -DUNICODE

UMTYPE=windows

NTTARGETFILE0=thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\winsrv\sources.inc ===
MAJORCOMP=windows

MINORCOMP=winsrv
TARGETNAME=winsrv

TARGETPATH=$(_OBJ_DIR)\$(ALT_PROJECT_TARGET)

TARGETTYPE=DYNLINK

LINKER_FLAGS = $(LINKER_FLAGS) /WX

LINKLIBS=                                                                \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\w32umode.lib      \
           $(NTUSER_PATH)\server\$(ALT_PROJECT)\$(O)\usersrvl.lib        \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib       \
           $(NTCON_PATH)\server\$(ALT_PROJECT)\$(O)\consrvl.lib   \
           $(WINCORE_PATH)\rtl\client\$(O)\w32crtl.lib

TARGETLIBS=                                 \
           $(SDK_LIB_PATH)\basesrv.lib      \
           $(WINDOWS_LIB_PATH)\gdi32p.lib   \
           $(SDK_LIB_PATH)\kernel32.lib     \
           $(BASE_LIB_PATH)\csrsrv.lib

TARGETLIBS=                                 \
           $(TARGETLIBS)                    \
           $(SDK_LIB_PATH)\winspool.lib

INCLUDES=                                           \
         $(WINCORE_PATH)\w32inc;                    \
         $(WINCORE_PATH)\w32inc\$(O);               \
         $(NTUSER_PATH)\inc;                        \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);    \
         $(NTUSER_PATH)\server\$(ALT_PROJECT)\$(O); \
         $(NTUSER_PATH)\server;                     \
         $(NTCON_PATH)\server;                      \
         $(SHELL_INC_PATH)

USE_NTDLL=1

SOURCES=..\winsrv.rc

DLLDEF=$(O)\winsrv.def
DLLORDER=..\$(TARGETNAME).prf

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\cgen\cgenhdr.h ===
// Copyright (c) 1998-1999 Microsoft Corporation

#ifdef SORTPP_PASS
#define BUILD_WOW6432 1
#endif

#if !defined(LANGPACK)
#define LANGPACK
#endif

// Avoid picking up the wrong prototypes for these functions from user.h.
#define fnHkOPTINLPEVENTMSG fnHkOPTINLPEVENTMSGFake
#define fnHkINLPRECT fnHkINLPRECTFake
#define fnHkINLPMSG fnHkINLPMSGFake
#define fnHkINLPMSLLHOOKSTRUCT fnHkINLPMSLLHOOKSTRUCTFake
#define fnHkINLPKBDLLHOOKSTRUCT fnHkINLPKBDLLHOOKSTRUCTFake
#define fnHkINLPMOUSEHOOKSTRUCTEX fnHkINLPMOUSEHOOKSTRUCTEXFake
#define fnHkINLPDEBUGHOOKSTRUCT fnHkINLPDEBUGHOOKSTRUCTFake
#define fnHkINLPCBTACTIVATESTRUCT fnHkINLPCBTACTIVATESTRUCTFake
#define fnHkINDWORD fnHkINDWORDFake

#include <stddef.h>
#include <nt.h>                                            
#include <ntrtl.h>                                         
#include <nturtl.h>                                        
#include <windef.h>
#include <winbase.h>
#include <wincon.h>
#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winuser.h>
#include <winnls.h>
#include <wincon.h>
#include <condll.h>
#include <w32gdip.h>
#include <ddrawp.h>
#include <ddrawi.h>
// ddrawp.h leaves INTERFACE defined to IDirectDrawGammaControl, but
// ntos\inc\io.h tries to define a new datatype called INTERFACE and ends
// up defining it has IDirectDrawGammaControl, which errors out.
#if defined(INTERFACE)
#undef INTERFACE
#endif
#include <winddi.h>
#include <ntgdistr.h>
#include <w32err.h>
#include <ddeml.h>
#include <ddemlp.h>
#include <winuserp.h>
#include <dde.h>
#include <ddetrack.h>
#include <kbd.h>
#include <wowuserp.h>
#include <vkoem.h>
#include <dbt.h>

#ifdef SORTPP_PASS
//Restore IN, OUT
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#define IN __in
#define OUT __out
#endif

#include <immstruc.h>
#include <immuser.h>
#include <user.h>

// on free builds, user.h defines DbgPrint to garbage to ensure nobody calls it.  Undo that now.
#if defined(DbgPrint)
#undef DbgPrint
#endif

// user.h makes unreferenced formal parameters into errors.
// ntos\inc\ke.h and others in the kernel don't expect this, so put
// things back now.
#pragma warning(default:4100)
#include <winspool.h>
#include <ntgdispl.h>
#include <ntgdi.h>
#include <ntuser.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

#include <ntwow64c.h>

#undef fnHkOPTINLPEVENTMSG
#undef fnHkINLPRECT
#undef fnHkINLPMSG
#undef fnHkINLPMSLLHOOKSTRUCT
#undef fnHkINLPKBDLLHOOKSTRUCT
#undef fnHkINLPMOUSEHOOKSTRUCTEX
#undef fnHkINLPDEBUGHOOKSTRUCT
#undef fnHkINLPCBTACTIVATESTRUCT
#undef fnHkINDWORD

VOID Wow64Teb32(TEB * Teb);

VOID
NtGdiFlushUserBatch(
    VOID
    );

int
NtUserGetMouseMovePoints(
    IN UINT             cbSize,
    IN LPMOUSEMOVEPOINT lppt,
    IN LPMOUSEMOVEPOINT lpptBuf,
    IN int              nBufPoints,
    IN DWORD            resolution
);

#define CLIENTSIDE 1

#ifdef SORTPP_PASS

#define RECVSIDE 1

//
// For each RECVCALL macro in ntcb.h, make a function prototype with
// a reasonable name and the right datatype for the parameter.  Then
// use __inline to force sortpp to ignore the body of the function as
// we don't want them.
//
#define RECVCALL(lower, upper)      \
    DWORD lower(IN upper *pmsg);    \
    __inline __ ## lower(upper *pmsg)

#define BEGINRECV(err, p, cb)       \
    CALLBACKSTATUS CallbackStatus;

#define FIXUPPOINTERS()             \
    ;

#define ENDRECV()                   \
    return 0;

#define MSGERROR()                  \
    ;

#define MSGERRORCODE(code)          \
    ;

#define MSGNTERRORCODE(code)        \
    ;

#define CALLDATA(x) (pmsg->x)
#define PCALLDATA(x) (&(pmsg->x))
#define PCALLDATAOPT(x) (pmsg->p ## x ? (PVOID)&(pmsg->x) : NULL)
#define FIRSTFIXUP(x) (pmsg->x)
#define FIXUPOPT(x) (pmsg->x)
#define FIRSTFIXUPOPT(x) FIXUPOPT(x)
#define FIXUP(x) (pmsg->x)
#define FIXUPID(x) (pmsg->x)
#define FIXUPIDOPT(x) (pmsg->x)
#define FIXUPSTRING(x) (pmsg->x.Buffer)
#define FIXUPSTRINGID(x) (pmsg->x.Buffer)
#define FIXUPSTRINGIDOPT(x) (pmsg->x.Buffer)

//
// Work around a '?' character some API bodies.  Sortpp can't handle
// them.  We don't care about these functions so declaring them inline
// inline is OK, and sortpp silently consumes inline functions.
//
#define CallHookWithSEH x; __inline CallHookWithSEHHack
#define GdiAddFontResourceW(x, y, z) 0

//
// Wherever there's a rule, there's an exception.  These don't
// use the RECVCALL macros:
//
DWORD ClientFontSweep(PVOID p);
#define  __ClientFontSweep x; __inline __ClientFontSweepHack
DWORD ClientLoadLocalT1Fonts(PVOID p);
#define  __ClientLoadLocalT1Fonts x; __inline __ClientLoadLocalT1FontsHack
#define __ClientPrinterThunk x; __inline __ClientPrinterThunkHack
DWORD ClientNoMemoryPopup(PVOID p);
#define __ClientNoMemoryPopup x; __inline __ClientNoMemoryPopupHack
DWORD ClientThreadSetup(PVOID p);
#define __ClientThreadSetup x; __inline __ClientThreadSetupHack
DWORD ClientDeliverUserApc(PVOID p);
#define __ClientDeliverUserApc x; __inline __ClientDeliverUserApcHack
DWORD ClientLoadRemoteT1Fonts(PVOID p);
#define __ClientLoadRemoteT1Fonts x; __inline __ClientLoadRemoteT1Fonts


#endif  //SORTPP_PASS

// prevent multiple definitions of this function
#define GetDebugHookLParamSize __x; __inline __GetDebugHookLParamSize

#include <ntcb.h>

#ifdef SORTPP_PASS

#undef __ClientPrinterThunk
DWORD ClientPrinterThunk(IN OUT CLIENTPRINTERTHUNKMSG *pMsg);

DWORD ClientLoadOLE(PVOID p);
DWORD ClientRegisterDragDrop(IN HWND *phwnd);
DWORD ClientRevokeDragDrop(IN HWND *phwnd);

// This is the same as fnGETTEXTLENGTHS... both entries in the dispatch
// table point to the same function in user32.
DWORD fnGETDBCSTEXTLENGTHS(IN OUT FNGETTEXTLENGTHSMSG *pmsg);

// Include the fake protypes for the message thunks.
#include "..\whwin32\msgpro.h"

#endif  //SORTPP_PASS

#include <csrhlpr.h>

// on free builds, user.h defines DbgPrint to garbage to ensure nobody calls it.  Undo that now.
#if defined(DbgPrint)
#undef DbgPrint
#endif

// hack for a user API that doesn't have a prototype
UINT NtUserBlockInput(IN BOOL fBlockIt);

// crank down some warnings that don't apply to wow64 thunks
#pragma warning(4:4312)   // conversion to type of greater size
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\cgen\winbld.c ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file is used to verify that winincs.c can be successfully compiled
// by the x86 C compiler.  Do do that, we must undefine __in and __out
#define __in
#define __out
#pragma warning(disable:4049)
#include "winincs.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\cgen\winincs.cpp ===
#include "cgenhdr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\vermsg\vermsg.c ===
/*++
                                                                                
Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    vermsg.c

Abstract:
    
    This program validates the message thunk table.
    
Author:

    19-Oct-1998 mzoran

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define MAX_LINE_LENGTH 2048
char LineBuffer[MAX_LINE_LENGTH];

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8604: 'VERMSG' ";

void
__cdecl ErrMsg(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    fputs(ErrMsgPrefix, stderr);
    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);
}

void
__cdecl ExitErrMsg(
    BOOL bSysError,
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    bSysErr -- TRUE if the value of errno should be printed with the error
    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr, open files closed and
    deleted, process terminated.

--*/
{
    va_list pArg;
    if (bSysError) {
        fprintf(stderr, "%s System ERROR %s", ErrMsgPrefix, strerror(errno));
    } else {
        fprintf(stderr, "%s ERROR ", ErrMsgPrefix);
    }

    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);

    //
    // Flush stdout and stderr buffers, so that the last few printfs
    // get sent back to BUILD before ExitProcess() destroys them.
    //
    fflush(stdout);
    fflush(stderr);

    ExitProcess(1);
}

char *MyFgets(char *string, int n, FILE *stream)
{
    char *ret;

    ret = fgets(string, n, stream);
    if (ret) {
        char *p;

        // Trim trailing carriage-return and linefeed
        p = strchr(string, '\r');
        if (p) {
            *p = '\0';
        }
        p = strchr(string, '\n');
        if (p) {
            *p = '\0';
        }

        // Trim trailing spaces
        if (strlen(string)) {
            p = string + strlen(string) - 1;
            while (p != string && isspace(*p)) {
                *p = '\0';
                p--;
            }
        }
    }
    return ret;
}


int __cdecl main(int argc, char*argv[])
{
    FILE *fp;
    char *p;
    char *StopString;
    long LineNumber;
    long ExpectedMessageNumber;
    long ActualMessageNumber;

    fp = fopen("messages.h", "r");
    if (!fp) {
        ExitErrMsg(TRUE, "Could not open messages.h for read");
    }

    printf("Validating message table...\n");

    // Scan down until the MSG_TABLE_BEGIN has been found
    LineNumber = 0;
    do {
        LineNumber++;
        p = MyFgets(LineBuffer, MAX_LINE_LENGTH, fp);
        if (!p) {
            // EOF or error
            ExitErrMsg(FALSE, "EOF reached in messages.h without finding 'MSG_TABLE_BEGIN'\n");
        }
    } while (strcmp(p, "MSG_TABLE_BEGIN"));

    // Validate the messages are in order
    ExpectedMessageNumber = 0;
    for (;;) {
        LineNumber++;
        p = MyFgets(LineBuffer, MAX_LINE_LENGTH, fp);
        if (!p) {
            // EOF or error
            ExitErrMsg(FALSE, "EOF reached in messages.h without finding 'MSG_TABLE_END'\n");
        }

        // Skip leading blanks
        p = LineBuffer;
        while (isspace(*p)) {
            p++;
        }

        if (strcmp(p, "MSG_TABLE_END") == 0) {
            // hit end of the table.
            break;
        } else if (strncmp(p, "MSG_ENTRY", 9)) {
            // Possibly blank line or multi-line MSG_ENTRY_ macro
            continue;
        }

        // Find the opening paren
        p = strchr(p, '(');
        if (!p) {
            ExitErrMsg(FALSE, "messages.h line %d - end of line reached without finding '('\n", LineNumber);
        }
        p++;    // skip the '(';

        // Convert the message number to a long, using the C rules to determine base
        ActualMessageNumber = strtol(p, &StopString, 0);

        if (ExpectedMessageNumber != ActualMessageNumber) {
            ExitErrMsg(FALSE, "messages.h line %d - Actual message 0x%x does not match expected 0x%x\n",
                        LineNumber, ActualMessageNumber, ExpectedMessageNumber);
        }
        ExpectedMessageNumber++;
    }

    if (ExpectedMessageNumber != WM_USER) {
        ExitErrMsg(FALSE, "messages.h line %d - hit MSG_TABLE_END but got 0x%x messages instead of expected 0x%x\n",
                    LineNumber, ExpectedMessageNumber, WM_USER);
    }

    printf("Message table validated OK.\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\cgen\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

WHWIN32TABSRC=..\..\kmode\services.tab
WHWIN32TAB=..\whwin32\$(O)\services.tab
WIN32TAB=..\whwin32\$(O)\guisvc.tab

#
# bash the 64-bit-targetted C compiler so it preprocesses using the
# 32-bit defines as we want 32-bit type information
#
!if $(IA64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_IA64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_IA64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DIA64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_IA64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_IA64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DIA64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!elseif $(AMD64)
WOW64_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:_WIN64=_WIN32) -DSORTPP_PASS -DGUID_DEFINED
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_M_AMD64=_M_X86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:_AMD64_=_X86_)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS:DAMD64=DX86)
WOW64_COMPILER_FLAGS=$(WOW64_COMPILER_FLAGS) /U_WIN64 /Di386=1 /DBUILD_WOW6432
WOW6432_PREPROCESSOR_FLAGS=$(C_PREPROCESSOR_FLAGS:_WIN64=_WIN32)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_M_AMD64=_M_X86)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:_AMD64_=_X86_)
WOW6432_PREPROCESSOR_FLAGS=$(WOW6432_PREPROCESSOR_FLAGS:DAMD64=DX86)
WOW6432_PREPROCESSOR_FLAGS=/U_WIN64 /Di386=1 /DBUILD_WOW6432 $(WOW6432_PREPROCESSOR_FLAGS)
!else
!error no target architecture.
!endif


!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
SORTPP_FLAGS=$(SORTPP_FLAGS) -l
!else
SORTPP_FLAGS=$(SORTPP_FLAGS)
!endif

PPMFILE=$(O)\winincs.ppm
NT32HDR=$(O)\nt32.h

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) $(WOW64_COMPILER_FLAGS) -noHRESULT -DIN=__in -DOUT=__out

$(WHWIN32TAB): $(WHWIN32TABSRC)
    @echo Creating $(WHWIN32TAB) from $(WHWIN32TABSRC)
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $** > $@

$(WIN32TAB): $(WHWIN32TABSRC)
    $(C_PREPROCESSOR_NAME) $(WOW6432_PREPROCESSOR_FLAGS) $** > $@

$(O)\winincs.pp: winincs.cpp cgenhdr.h
    $(CXX_COMPILER_NAME) /C @<<$(O)\cl.rsp /E /FC winincs.cpp >$(O)\winincs2.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP
    idlclean.exe $(O)\winincs2.pp $(O)\winincs2.cpp
    $(CXX_COMPILER_NAME) @<<cl.rsp /E /FC $(O)\winincs2.cpp >$(O)\winincs.pp
$(WOW64_COMPILER_FLAGS: =
)
<<NOKEEP

$(PPMFILE): $(O)\winincs.pp
   sortpp.exe $(SORTPP_FLAGS) -m$(PPMFILE) $(O)\winincs.pp

$(NT32HDR): $(PPMFILE)
   gennt32t.exe $(PPMFILE) >$(NT32HDR)

thunks: $(WHWIN32TAB) $(NT32HDR) $(PPMFILE) $(WIN32TAB)

cleanfiles:
    -del $(O)\winincs.pp
    -del $(O)\winincs2.pp
    -del $(WHWIN32TAB)
    -del $(WIN32TAB)
    -del $(PPMFILE)
    -del $(NT32HDR)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\msgpro.h ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msgpro.h

Abstract:
    
    Defines the macros to allow sortpp to add "fake" prototypes for the message thunk functions and
    then includes messages.h to build the prototypes.
    
Author:

    6-Oct-1998 mzoran

Revision History:

--*/
                                                      
#define MSG_ENTRY_NOPARAM(entrynumber, ident)             
#define MSG_ENTRY_WPARAM(entrynumber, ident, wparam)      LONG_PTR Wow64MsgFnc##ident(wparam, IN LPARAM lParam);
#define MSG_ENTRY_LPARAM(entrynumber, ident, lparam)      LONG_PTR Wow64MsgFnc##ident(IN WPARAM wParam, lparam);
#define MSG_ENTRY_STD(entrynumber, ident, wparam, lparam) LONG_PTR Wow64MsgFnc##ident(wparam, lparam);
#define MSG_ENTRY_UNREFERENCED(entrynumber, ident)
#define MSG_ENTRY_KERNELONLY(entrynumber, ident)
#define MSG_ENTRY_EMPTY(entrynumber)                   
#define MSG_ENTRY_RESERVED(entrynumber)                
#define MSG_ENTRY_TODO(entrynumber)

#define MSG_TABLE_BEGIN
#define MSG_TABLE_END

#include "messages.h"

#undef MSG_ENTRY_NOPARAM
#undef MSG_ENTRY_WPARAM
#undef MSG_ENTRY_LPARAM
#undef MSG_ENTRY_STD
#undef MSG_ENTRY_UNREFERENCED
#undef MSG_ENTRY_KERNELONLY
#undef MSG_ENTRY_EMPTY
#undef MSG_ENTRY_RESERVED
#undef MSG_ENTRY_TODO

#undef MSG_TABLE_BEGIN
#undef MSG_TABLE_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whcon\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64lg2\$(O)

WHCONTABSRC=..\..\wow6432\services.tab
WHCONTAB=$(O)\services.tab
WHCONC=$(O)\whcon.c
WHCONLOGC=$(WHLOGGENDIR)\whcon.c
WHCONERRC=$(O)\whconerr.c

$(WHCONTAB): $(WHCONTABSRC)
    @echo Creating $(WHCONTAB) from $(WHCONTABSRC)
    $(C_PREPROCESSOR) $(WHCONTABSRC) > $(WHCONTAB)

$(WHCONC): $(PPMFILE) \
           $(BASE_INC_PATH)\apithunk.tpl \
           $(BASE_INC_PATH)\genmacro.tpl \
           $(BASE_INC_PATH)\gentypes.tpl \
           whcon.tpl \
           $(WHCONTAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\gentypes.tpl \
                -twhcon.tpl \
                -c$(WHCONC):whcon \
                -s$(WHCONTAB)

$(WHCONLOGC): $(PPMFILE) \
              $(BASE_INC_PATH)\apithunk.tpl \
              $(BASE_INC_PATH)\genmacro.tpl \
              $(BASE_INC_PATH)\thunklog.tpl \
              $(WHCONTAB)
    -mkdir $(WHLOGGENDIR)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\thunklog.tpl \
                -c$(WHCONLOGC):whconlog \
                -s$(WHCONTAB)

$(WHCONERRC): $(PPMFILE) whconerr.tpl $(WHCONTAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -twhconerr.tpl \
                -c$(WHCONERRC):whcon \
                -s$(WHCONTAB)

thunks: $(WHCONC) $(WHCONERRC) $(WHCONLOGC)

cleanfiles:
    -del $(WHCONTAB)
    -del $(WHCONC)
    -del $(WHCONLOGC)
    -del $(WHCONERRC)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64lg2\$(O)

WHWIN32TAB=$(O)\services.tab
WHWIN32C=$(O)\whwin32.c
WHWIN32LOGC=$(WHLOGGENDIR)\whwin32.c

# defines error return values for win32 functions
WHWIN32ERRC=$(O)\whwin32er.c

# this defines the 64-to-32 callbacks from win32k into user32
NTCBC=$(O)\ntcbc.c

# defines outbound message thunk functions.
MSGXPT=$(O)\msgthnk.xpt
MSGTHNKC=$(O)\msgthnk.c

CXX_COMPILER_NAME=$(CXX_COMPILER_NAME) -noHRESULT -DIN=__in -DOUT=__out
WOW64_CPP_FLAGS=$(WOW64_CPP_FLAGS) -DSORTPP_PASS -DGUID_DEFINED

$(WHWIN32C): $(PPMFILE) \
	     $(BASE_INC_PATH)\apithunk.tpl \
	     $(BASE_INC_PATH)\genmacro.tpl \
	     $(BASE_INC_PATH)\gentypes.tpl \
	     whwin32.tpl \
	     $(WHWIN32TAB)
  genthnk.exe $(GENTHNK_FLAGS) \
       -m$(PPMFILE) \
       -t$(BASE_INC_PATH)\apithunk.tpl \
       -t$(BASE_INC_PATH)\genmacro.tpl \
       -t$(BASE_INC_PATH)\gentypes.tpl \
       -twhwin32.tpl \
       -c$(WHWIN32C):whwin32 -s$(WHWIN32TAB):Nt

$(WHWIN32LOGC): $(PPMFILE) \
		$(BASE_INC_PATH)\apithunk.tpl \
		$(BASE_INC_PATH)\genmacro.tpl \
		$(BASE_INC_PATH)\thunklog.tpl \
		$(WHWIN32TAB)
  -mkdir $(WHLOGGENDIR)
  genthnk.exe $(GENTHNK_FLAGS) \
       -m$(PPMFILE) \
       -t$(BASE_INC_PATH)\apithunk.tpl \
       -t$(BASE_INC_PATH)\genmacro.tpl \
       -t$(BASE_INC_PATH)\thunklog.tpl \
       -c$(WHWIN32LOGC):whwin32log -s$(WHWIN32TAB):Nt

$(NTCBC): $(PPMFILE) ntcbc.tpl $(NTCBTAB) cbtypes.tpl
    genthnk.exe $(GENTHNK_FLAGS) -m$(PPMFILE) -tntcbc.tpl -tcbtypes.tpl -c$(NTCBC):ntcbc -e..\..\ntuser\inc\daytona\$(O)\cb.lst

$(WHWIN32ERRC): $(PPMFILE) whwin32er.tpl $(WHWIN32TAB)
    genthnk.exe $(GENTHNK_FLAGS) -m$(PPMFILE) -twhwin32er.tpl -c$(WHWIN32ERRC):whwin32 -s$(WHWIN32TAB):Nt

$(MSGXPT): msgxpt.h messages.h
    $(CXX_COMPILER_NAME) msgxpt.h /EP > $(MSGXPT)

$(MSGTHNKC): $(PPMFILE) $(BASE_INC_PATH)\genmacro.tpl $(BASE_INC_PATH)\gentypes.tpl msgthnk.tpl $(MSGXPT)
    genthnk.exe $(GENTHNK_FLAGS) \
	-m$(PPMFILE) \
	-t$(BASE_INC_PATH)\genmacro.tpl \
	-t$(BASE_INC_PATH)\gentypes.tpl \
	-tmsgthnk.tpl \
	-c$(MSGTHNKC):msgthnk -e$(MSGXPT)

$(O)\callcf.c:  callcf.tpl $(O)\scf.lst
    listmung $(O)\scf.lst callcf.tpl >$(O)\callcf.c

$(O)\cscall.h:  cscall.tpl $(O)\scf.lst
    listmung $(O)\scf.lst cscall.tpl >$(O)\cscall.h

$(O)\scf.lst: ..\..\ntuser\inc\scf.lst
    @echo Creating $@ from $**
    $(C_PREPROCESSOR)  $** > $@

thunks: $(WHWIN32C) \
        $(NTCBC) \
        $(WHWIN32ERRC) \
        $(MSGTHNKC) \
        $(WHWIN32LOGC) \
        $(O)\callcf.c \
        $(O)\cscall.h
    vermsg.exe

cleanfiles:
    -del $(WHWIN32C)
    -del $(WHWIN32LOGC)
    -del $(NTCBC)
    -del $(WHWIN32ERRC)
    -del $(MSGXPT)
    -del $(MSGTHNKC)
    -del $(O)\callcf.c
    -del $(O)\cscall.h
    -del $(O)\scf.lst

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\wow64dx.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wow64dx.c

Abstract:

    Helper thunk routines to support DirectX

Author:

    03-Mar-2000   SamerA

Revision History:

--*/

//
// Define DirectX GUIDs
//

#define INITGUID
#include <nt.h>

#define GUID_DEFS_ONLY
#include <ddrawint.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\msgxpt.h ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msgxpt.h

Abstract:
    
    Defines the macros necessary to obtain an export list for the messages thunk functions
    and builds the list by including messages.h.
    
Author:

    6-Oct-1998 mzoran

Revision History:

--*/

#define MSGFN(id)                                      Wow64MsgFnc##id
#define MSG_THUNK_DECLARE(id, wprm, lprm)
#define MSG_ENTRY_NOPARAM(entrynumber, id)             
#define MSG_ENTRY_WPARAM(entrynumber, id, wparam)      MSGFN(id)
#define MSG_ENTRY_LPARAM(entrynumber, id, lparam)      MSGFN(id)
#define MSG_ENTRY_STD(entrynumber, id, wparam, lparam) MSGFN(id)
#define MSG_ENTRY_UNREFERENCED(entrynumber, id)
#define MSG_ENTRY_KERNELONLY(entrynumber, id)
#define MSG_ENTRY_EMPTY(entrynumber)                   
#define MSG_ENTRY_RESERVED(entrynumber)                
#define MSG_ENTRY_TODO(entrynumber)

#define MSG_TABLE_BEGIN
#define MSG_TABLE_END

#include "messages.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\whwin32p.h ===
/*++                 

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:
  
   whwin32p.h
 
Abstract:
   
   Private header for whwin32.
 
Author:

Revision History:

--*/

#define _WOW64DLLAPI_                                      
#include "nt32.h"                                          
#include "cgenhdr.h"                                                                                            
#include <stdio.h>                                         
#include <stdlib.h>                                        
#include <windef.h>                                        
#include "wow64thk.h"
#include "cscall.h"

// Make the compiler more strict.
#pragma warning(1:4033)   // function must return a value
#pragma warning(1:4035)   // no return value
#pragma warning(1:4702)   // Unreachable code
#pragma warning(1:4705)   // Statement has no effect

                                        
typedef struct _NTUSERMESSAGECALL_PARMS {
   HWND hwnd;
   UINT msg;
   // WPARAM wParam;
   // LPARAM lParam;
   ULONG_PTR xParam;
   DWORD xpfnProc;
   BOOL bAnsi;
} NTUSERMESSAGECALL_PARMS, *PNTUSERMESSAGECALL_PARMS;

#define ALIGN4(X) (((X) + 3) & ~3)

// Redefine WOW64_ISPTR to be the USER32 IS_PTR
#undef WOW64_ISPTR 
#define WOW64_ISPTR IS_PTR

typedef LONG_PTR (*PMSG_THUNKCB_FUNC)(WPARAM wParam, LPARAM lParam, PVOID pContext);
typedef LONG_PTR (*PMSG_THUNK_FUNC)(PMSG_THUNKCB_FUNC wrapfunc, WPARAM wParam, LPARAM lParam, PVOID pContext);

LONG_PTR Wow64DoMessageThunk(PMSG_THUNKCB_FUNC func, UINT msg, WPARAM wParam, LPARAM lParam, PVOID pContext);

// WM_SYSTIMER messages have a kernel mode proc address
// stuffed in the lParam. Forunately the address will
// allways be in win32k.sys so the hi bits will be the same
// for all kprocs. On the first WM_SYSTIMER message
// we save the hi bits here, and restore them when we go
// back to the kernel.
extern DWORD gdwWM_SYSTIMERProcHiBits;

#if defined(DBG)
extern CHAR* apszSimpleCallNames[];
#endif
extern CONST ULONG ulMaxSimpleCall;

#if defined(WOW64DOPROFILE)
extern WOW64SERVICE_PROFILE_TABLE_ELEMENT SimpleCallProfileElements[];

extern WOW64SERVICE_PROFILE_TABLE NtUserCallNoParamProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallOneParamProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallHwndProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallHwndOptProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallHwndParamProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallHwndLockProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallHwndParamLockProfileTable;
extern WOW64SERVICE_PROFILE_TABLE NtUserCallTwoParamProfileTable;
#endif

PMSG Wow64ShallowThunkMSG32TO64(PMSG pMsg64, NT32MSG *pMsg32);
NT32MSG *Wow64ShallowThunkMSG64TO32(NT32MSG *pMsg32, PMSG pMsg64);
PEVENTMSG Wow64ShallowThunkEVENTMSG32TO64(PEVENTMSG pMsg64, NT32EVENTMSG *pMsg32);
NT32EVENTMSG *Wow64ShallowThunkEVENTMSG64TO32(NT32EVENTMSG *pMsg32, PEVENTMSG pMsg64);
LPHELPINFO Wow64ShallowAllocThunkHELPINFO32TO64(NT32HELPINFO *pHelp32);
NT32HELPINFO *Wow64ShallowAllocThunkHELPINFO64TO32(LPHELPINFO pHelp64);
LPHLP Wow64ShallowAllocThunkHLP32TO64(NT32HLP *pHlp32);
NT32HLP *Wow64ShallowAllocThunkHLP64TO32(LPHLP pHlp64);
PWND Wow64ValidateHwnd(HWND h);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\wow64win\whwin32\messages.h ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

   messages.h
   
Abstract:
   
   This tables defines the system messages and the parameters that they contain.
    
Author:

   6-Oct-98 mzoran
   
Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Macros used to define the message table:
//
//  MSG_ENTRY_NOPARAM(messagenumber, id for message) - Message has no parameters.
//  MSG_ENTRY_LPARAM(messagenumber, id for message, LPARAM type) - Message has an LPARAM only. 
//  MSG_ENTRY_WPARAM(messagenumber, id for message, WPARAM type) - Message has an WPARAM only.
//  MSG_ENTRY_STD(messagenumber, id for message, WPARAM type, LPARAM type) - Message has both params.
//  MSG_ENTRY_UNREFERENCED(messagenumber, id for message) - Message is defined but no uses found.
//  MSG_ENTRY_KERNELONLY(messagenumber, id for messagage) - Message is sent only from the kernel.
//  MSG_ENTRY_EMPTY(messagenumber) - Message is unused and unreserved.
//  MSG_ENTRY_RESERVED(messagenumber) - Message is reserved.
//  MSG_ENTRY_TODO(messagenumber) - Message is under investigation.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

#if !defined(MSG_TABLE_BEGIN) || !defined(MSG_ENTRY_NOPARAM) || !defined(MSG_ENTRY_LPARAM) ||      \
    !defined(MSG_ENTRY_WPARAM) || !defined(MSG_ENTRY_STD) || !defined(MSG_ENTRY_UNREFERENCED) ||   \
    !defined(MSG_ENTRY_KERNELONLY) || !defined(MSG_ENTRY_EMPTY) || !defined(MSG_ENTRY_RESERVED) || \
    !defined(MSG_ENTRY_TODO) || !defined(MSG_TABLE_END)
#error The required macros for this table are not defined.
#endif

MSG_TABLE_BEGIN                                                

    MSG_ENTRY_NOPARAM(0x0000, WM_NULL)                                  
    MSG_ENTRY_LPARAM(0x0001, WM_CREATE, IN LPCREATESTRUCT lpcs)      
    MSG_ENTRY_NOPARAM(0x0002, WM_DESTROY)                              
    MSG_ENTRY_LPARAM(0x0003, WM_MOVE, IN DWORD composite)             // (0, DWORD(WORD x, WORD y)) 3
    MSG_ENTRY_UNREFERENCED(0x0004, WM_SIZEWAIT)                       //
    MSG_ENTRY_STD(0x0005, WM_SIZE, IN UINT fwSizeType, IN DWORD cmpost)// (UINT, DWORD(WORD x, WORD y))WM_SIZE                  0x0005
    MSG_ENTRY_STD(0x0006, WM_ACTIVATE, IN DWORD compostite, IN HWND hwnd) // (DWORD(state, fMinimized), HWND) WM_ACTIVATE              0x0006
    MSG_ENTRY_STD(0x0007, WM_SETFOCUS, IN BOOL fShow, IN INT fnStatus) 
    MSG_ENTRY_STD(0x0008, WM_KILLFOCUS, IN BOOL fShow, IN INT fnStatus) 
    MSG_ENTRY_STD(0x0009, 0x0009, IN BOOL fShow, IN INT fnStatus) // WM_SETVISIBLE
    MSG_ENTRY_WPARAM(0x000A, WM_ENABLE, IN BOOL fEnabled)            
    MSG_ENTRY_WPARAM(0x000B, WM_SETREDRAW, IN BOOL fRedraw)          
    MSG_ENTRY_LPARAM(0x000C, WM_SETTEXT, IN LPCSTR lpsz)             
    MSG_ENTRY_STD(0x000D, WM_GETTEXT, IN DWORD cchTextMax, OUT LPCSTR lpszText) // (DWORD(maxchars), LPCTXT)WM_GETTEXT               0x000D
    MSG_ENTRY_NOPARAM(0x000E, WM_GETTEXTLENGTH)                        
    MSG_ENTRY_NOPARAM(0x000F, WM_PAINT)                                

    MSG_ENTRY_NOPARAM(0x0010, WM_CLOSE)                   
    MSG_ENTRY_NOPARAM(0x0011, WM_QUERYENDSESSION)         
    MSG_ENTRY_WPARAM(0x0012, WM_QUIT, IN INT nExitCode) 
    MSG_ENTRY_NOPARAM(0x0013, WM_QUERYOPEN)               
    MSG_ENTRY_WPARAM(0x0014, WM_ERASEBKGND, IN HDC hdc) 
    MSG_ENTRY_NOPARAM(0x0015, WM_SYSCOLORCHANGE)          
    MSG_ENTRY_STD(0x0016, WM_ENDSESSION, IN BOOL fEndSession, IN UINT fLogOff) 
    MSG_ENTRY_WPARAM(0x0017, WM_SYSTEMERROR, IN INT ErrorCode)      
    MSG_ENTRY_STD(0x0018, WM_SHOWWINDOW, IN BOOL fShow, IN INT fnStatus)             
    MSG_ENTRY_RESERVED(0x0019)                            
    MSG_ENTRY_WPARAM(0x001A, WM_WININICHANGE, IN LPCSTR lpszSectionName) 
    MSG_ENTRY_LPARAM(0x001B, WM_DEVMODECHANGE, IN LPCSTR lpszDev) 
    MSG_ENTRY_STD(0x001C, WM_ACTIVATEAPP, IN BOOL fActive, IN DWORD dwThreadId) 
    MSG_ENTRY_NOPARAM(0x001D, WM_FONTCHANGE)              
    MSG_ENTRY_NOPARAM(0x001E, WM_TIMECHANGE)              
    MSG_ENTRY_NOPARAM(0x001F, WM_CANCELMODE)              

    MSG_ENTRY_STD(0x0020, WM_SETCURSOR, IN HWND hwnd, IN DWORD composite) // (HWND, DWORD(WORD wMouseMsg, WORD nHittest)) WM_SETCURSOR             0x0020
    MSG_ENTRY_STD(0x0021, WM_MOUSEACTIVATE, IN HWND hwndTopLevel, IN DWORD composite)  // (HWND, DWORD(UINT uMsg, INT nHitTest) WM_MOUSEACTIVATE         0x0021
    MSG_ENTRY_NOPARAM(0x0022, WM_CHILDACTIVATE)          
    MSG_ENTRY_NOPARAM(0x0023, WM_QUEUESYNC)               
    MSG_ENTRY_LPARAM(0x0024, WM_GETMINMAXINFO, IN OUT LPMINMAXINFO lpmmi)  
    MSG_ENTRY_EMPTY(0x0025)                               
    MSG_ENTRY_NOPARAM(0x0026, WM_PAINTICON)               
    MSG_ENTRY_WPARAM(0x0027, WM_ICONERASEBKGND, IN HDC hdc) 
    MSG_ENTRY_STD(0x0028, WM_NEXTDLGCTL, IN HWND wCtlFocus, IN BOOL fHandle) 
    MSG_ENTRY_UNREFERENCED(0x0029, WM_ALTTABACTIVE) 
    MSG_ENTRY_STD(0x002A, WM_SPOOLERSTATUS, IN UINT fwJobStatus, IN DWORD composite) 
    MSG_ENTRY_STD(0x002B, WM_DRAWITEM, IN UINT idCtl, IN LPDRAWITEMSTRUCT lpdis) 
    MSG_ENTRY_STD(0x002C, WM_MEASUREITEM, IN UINT idCtl, IN OUT LPMEASUREITEMSTRUCT lpmis) 
    MSG_ENTRY_STD(0x002D, WM_DELETEITEM, IN UINT idCtl, IN LPDELETEITEMSTRUCT lpdis) 
    MSG_ENTRY_STD(0x002E, WM_VKEYTOITEM, IN UINT composite, IN HWND hwndLB)                // (DWORD(UINT, INT), HWND) WM_VKEYTOITEM            0x002E
    MSG_ENTRY_STD(0x002F, WM_CHARTOITEM, IN UINT composite, IN HWND hwndLB)                // (DWORD(UING, UING), HWND) WM_CHARTOITEM            0x002F

    MSG_ENTRY_STD(0x0030, WM_SETFONT, IN HFONT hFont, IN BOOL fRedraw) 
    MSG_ENTRY_NOPARAM(0x0031, WM_GETFONT)                 
    MSG_ENTRY_WPARAM(0x0032, WM_SETHOTKEY, IN WORD composite)   
    MSG_ENTRY_NOPARAM(0x0033, WM_GETHOTKEY)               
    MSG_ENTRY_STD(0x0034, WM_FILESYSCHANGE, IN UINT wParam, IN OUT LPCSTR lpstr) // Only used by winobj
    MSG_ENTRY_NOPARAM(0x0035, WM_ISACTIVEICON) // Nobody sends it, but it is referenced in dwp. /
    MSG_ENTRY_UNREFERENCED(0x0036, WM_QUERYPARKINCON)
    MSG_ENTRY_NOPARAM(0x0037, WM_QUERYDRAGICON)           
    MSG_ENTRY_STD(0x0038, WM_WINHELP, IN HWND hwnd, IN LPHLP lphlp) 
    MSG_ENTRY_STD(0x0039, WM_COMPAREITEM, IN UINT idCtl, IN LPCOMPAREITEMSTRUCT lpcis) 
    MSG_ENTRY_STD(0x003A, WM_FULLSCREEN, IN DWORD dwValue, IN HWND hwnd)  
    MSG_ENTRY_WPARAM(0x003B, WM_CLIENTSHUTDOWN, IN UINT flags) // This is checked in dwp, but nobody seems to be sending it.                    // WM_CLIENTSHUTDOWN        0x003B
    MSG_ENTRY_LPARAM(0x003C, WM_DDEMLEVENT, IN PEVENT_PACKET pep) 
    MSG_ENTRY_EMPTY(0x003D)                               
    MSG_ENTRY_EMPTY(0x003E)                               
    MSG_ENTRY_WPARAM(0x003F, MM_CALCSCROLL, IN BOOL fIgnoreMin) // ntuser\client\mdiwin.c was the only reference.
                                                                // It sends this message, but dos/wow is the only thing
                                                                // thing that checks it and dos/wow does not think it has any parameters.   

    MSG_ENTRY_UNREFERENCED(0x0040, WM_TESTING)     //nobody checks for this or sends it                       
    MSG_ENTRY_WPARAM(0x0041, WM_COMPACTING, IN UINT ratio)  
    MSG_ENTRY_UNREFERENCED(0x0042, WM_OTHERWINDOWCREATED)   
    MSG_ENTRY_UNREFERENCED(0x0043, WM_OTHERWINDOWDESTROYED) 
    MSG_ENTRY_STD(0x0044, WM_COMMNOTIFY, IN UINT cid, IN LONG flags) 
    MSG_ENTRY_UNREFERENCED(0x0045, WM_MEDIASTATUSCHANGE) // no referenced at all 
    MSG_ENTRY_LPARAM(0x0046, WM_WINDOWPOSCHANGING, IN OUT LPWINDOWPOS lpwinpos) 
    MSG_ENTRY_LPARAM(0x0047, WM_WINDOWPOSCHANGED, IN LPWINDOWPOS lpwinpos)      
    MSG_ENTRY_WPARAM(0x0048, WM_POWER, IN INT fwPowerEvt) 
    MSG_ENTRY_STD(0x0049, WM_COPYGLOBALDATA, IN DWORD dwSize, IN OUT PVOID pData) 
    MSG_ENTRY_STD(0x004A, WM_COPYDATA, IN HWND hwnd, IN PCOPYDATASTRUCT pCopyStruct) 
    MSG_ENTRY_NOPARAM(0x004B, WM_CANCELJOURNAL)                                         
    MSG_ENTRY_KERNELONLY(0x004C, WM_LOGONNOTIFY) // It turns out that this message is only sent from 
                                                 // the kernel to the logon process.   The kernel will prevent
                                                 // users from users from sending this since NtUserMessageCall will
                                                 // prevent it.  But the kernel will let it sneak through in
                                                 // some cases. May need to check on this again.             0x004C
    MSG_ENTRY_NOPARAM(0x004D, WM_KEYF1) // posted in kernel/input.c(checked in dwp.c) 
    MSG_ENTRY_STD(0x004E, WM_NOTIFY, IN UINT code, IN OUT PVOID pvoid) // It turns out that this message contains a
                                                                       // pointer to a NMHDR structure which is pointer dependent.
                                                                       // But the kernel doesn't copy or probe this struct, 
                                                                       // this message will not work cross process correctly.
                                                                       // Since the kernel doesn't handle it correctly,
                                                                       // don't handle it here either.                                                                      
    MSG_ENTRY_WPARAM(0x004F, WM_ACCESS_WINDOW, IN HWND hwnd) //seems to only be checked in dwp 

    MSG_ENTRY_STD(0x0050, WM_INPUTLANGCHANGEREQUEST, IN BOOL fSysCharSet, IN HKL hkl)
    MSG_ENTRY_STD(0x0051, WM_INPUTLANGCHANGE, IN UINT charset, IN HKL hkl) 
    MSG_ENTRY_STD(0x0052, WM_TCARD, IN UINT idAction, IN INT dwActionData) 
    MSG_ENTRY_LPARAM(0x0053, WM_HELP, IN LPHELPINFO lphi)  
    MSG_ENTRY_NOPARAM(0x0054, WM_USERCHANGED)      
    MSG_ENTRY_STD(0x0055, WM_NOTIFYFORMAT, IN HWND hwndFrom, IN LONG Command)         
    MSG_ENTRY_EMPTY(0x0056)
    MSG_ENTRY_EMPTY(0x0057)
    MSG_ENTRY_EMPTY(0x0058)

    MSG_ENTRY_EMPTY(0x0059)                                
    MSG_ENTRY_EMPTY(0x005A)
    MSG_ENTRY_EMPTY(0x005B)
    MSG_ENTRY_EMPTY(0x005C)
    MSG_ENTRY_EMPTY(0x005D)
    MSG_ENTRY_EMPTY(0x005E)
    MSG_ENTRY_EMPTY(0x005F)

    MSG_ENTRY_EMPTY(0x0060)                                
    MSG_ENTRY_EMPTY(0x0061)
    MSG_ENTRY_EMPTY(0x0062)
    MSG_ENTRY_EMPTY(0x0063)
    MSG_ENTRY_EMPTY(0x0064)
    MSG_ENTRY_EMPTY(0x0065)
    MSG_ENTRY_EMPTY(0x0066)
    MSG_ENTRY_EMPTY(0x0067)

    MSG_ENTRY_EMPTY(0x0068)                               
    MSG_ENTRY_EMPTY(0x0069)
    MSG_ENTRY_EMPTY(0x006A)
    MSG_ENTRY_EMPTY(0x006B)
    MSG_ENTRY_EMPTY(0x006C)
    MSG_ENTRY_EMPTY(0x006D)
    MSG_ENTRY_EMPTY(0x006E)
    MSG_ENTRY_EMPTY(0x006F)

    MSG_ENTRY_NOPARAM(0x0070, WM_FINALDESTROY)    
    MSG_ENTRY_EMPTY(0x0071)    
    MSG_ENTRY_UNREFERENCED(0x0072, WM_TASKACTIVATED)  // not referenced at all  
    MSG_ENTRY_UNREFERENCED(0x0073, WM_TASKDEACTIVATED)    
    MSG_ENTRY_UNREFERENCED(0x0074, WM_TASKCREATED)             
    MSG_ENTRY_UNREFERENCED(0x0075, WM_TASKDESTROYED)              
    MSG_ENTRY_UNREFERENCED(0x0076, WM_TASKUICHANGED)    
    MSG_ENTRY_UNREFERENCED(0x0077, WM_TASKVISIBLE)    
    MSG_ENTRY_UNREFERENCED(0x0078, WM_TASKNOTVISIBLE)   
    MSG_ENTRY_UNREFERENCED(0x0079, WM_SETCURSORINFO)    
    MSG_ENTRY_EMPTY(0x007A)    
    MSG_ENTRY_STD(0x007B, WM_CONTEXTMENU, IN HWND hwnd, IN DWORD composite)    
    MSG_ENTRY_STD(0x007C, WM_STYLECHANGING, IN WORD wStyleType, IN OUT LPSTYLESTRUCT lpstyle) 
    MSG_ENTRY_STD(0x007D, WM_STYLECHANGED, IN WORD wStyleType, IN OUT LPSTYLESTRUCT lpstyle)  
    
    MSG_ENTRY_EMPTY(0x007E)                                
    MSG_ENTRY_WPARAM(0x007F, WM_GETICON, IN DWORD fType)   
    MSG_ENTRY_STD(0x0080, WM_SETICON, IN DWORD fType, IN HICON hicon)   
    MSG_ENTRY_LPARAM(0x0081, WM_NCCREATE, IN LPCREATESTRUCT lpstruct)  
    MSG_ENTRY_NOPARAM(0x0082, WM_NCDESTROY)                    
    MSG_ENTRY_STD(0x0083, WM_NCCALCSIZE, IN BOOL fCalcValidRects, IN OUT LPNCCALCSIZE_PARAMS lpncsp)  

    MSG_ENTRY_LPARAM(0x0084, WM_NCHITTEST, IN DWORD composite) // (0, DWORD(WORD, WORD))   
    MSG_ENTRY_WPARAM(0x0085, WM_NCPAINT, IN HRGN hrgn)     
    MSG_ENTRY_WPARAM(0x0086, WM_NCACTIVATE, IN BOOL fActive)  
    MSG_ENTRY_WPARAM(0x0087, WM_GETDLGCODE, IN LPMSG lpMsg) // this message needs some hackery since it contains a message.            

    MSG_ENTRY_STD(0x0088, WM_SYNCPAINT, IN DWORD flags, IN DWORD composite) // (DWORD flags,DWORD(WORD pwndSkip, WORD hrgnClip) See DWP WM_SYNCPAINT             0x0088
    MSG_ENTRY_UNREFERENCED(0x0089, WM_SYNCTASK)           // (not referenced)  

    MSG_ENTRY_EMPTY(0x008A)
    MSG_ENTRY_STD(0x008B, WM_KLUDGEMINRECT, IN HWND hwnd, IN OUT LPRECT lprc)  
    MSG_ENTRY_KERNELONLY(0x008C, WM_LPKDRAWSWITCHWND) // This message is like WM_LOGONNOTIFY.  This message
                                                      // can't be send, sent since the probing code won't 
                                                      // allow it.  It is synconly, so it can't be posted.
                                                      // Even if it could be sent, it is undocumented and nothing
                                                      // appears to reference it.   
    MSG_ENTRY_EMPTY(0x008D)                               
    MSG_ENTRY_EMPTY(0x008E)
    MSG_ENTRY_EMPTY(0x008F)

    MSG_ENTRY_EMPTY(0x0090)                                
    MSG_ENTRY_EMPTY(0x0091)
    MSG_ENTRY_EMPTY(0x0092)
    MSG_ENTRY_EMPTY(0x0093)
    MSG_ENTRY_EMPTY(0x0094)
    MSG_ENTRY_EMPTY(0x0095)
    MSG_ENTRY_EMPTY(0x0096)
    MSG_ENTRY_EMPTY(0x0097)

    MSG_ENTRY_EMPTY(0x0098)                                
    MSG_ENTRY_EMPTY(0x0099)
    MSG_ENTRY_EMPTY(0x009A)
    MSG_ENTRY_EMPTY(0x009B)
    MSG_ENTRY_EMPTY(0x009C)
    MSG_ENTRY_EMPTY(0x009D)
    MSG_ENTRY_EMPTY(0x009E)
    MSG_ENTRY_EMPTY(0x009F)

    MSG_ENTRY_STD(0x00A0, WM_NCMOUSEMOVE, IN UINT codeHitTest, IN DWORD composite) // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A1, WM_NCLBUTTONDOWN, IN UINT codeHitTest, IN DWORD composite)                   // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A2, WM_NCLBUTTONUP, IN UINT codeHitTest, IN DWORD composite)                   // (UINT codeHitTest, DWORD(int x, int y)) 
    MSG_ENTRY_STD(0x00A3, WM_NCLBUTTONDBLCLK, IN UINT codeHitTest, IN DWORD composite)                   // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A4, WM_NCRBUTTONDOWN, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A5, WM_NCRBUTTONUP, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y)) 
    MSG_ENTRY_STD(0x00A6, WM_NCRBUTTONDBLCLK, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A7, WM_NCMBUTTONDOWN, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y))  
    MSG_ENTRY_STD(0x00A8, WM_NCMBUTTONUP, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y)) 
    MSG_ENTRY_STD(0x00A9, WM_NCMBUTTONDBLCLK, IN UINT codeHitTest, IN DWORD composite)  // (UINT codeHitTest, DWORD(int x, int y))  

    MSG_ENTRY_EMPTY(0x00AA)                                
    MSG_ENTRY_EMPTY(0x00AB)
    MSG_ENTRY_EMPTY(0x00AC)
    MSG_ENTRY_EMPTY(0x00AD)
    MSG_ENTRY_EMPTY(0x00AE)
    MSG_ENTRY_EMPTY(0x00AF)

    MSG_ENTRY_STD(0x00B0, EM_GETSEL, OUT PDWORD lpswStart, OUT DWORD lpdwEnd)  
    MSG_ENTRY_STD(0x00B1, EM_SETSEL, IN INT nState, IN INT nEnd)                
    MSG_ENTRY_LPARAM(0x00B2, EM_GETRECT, OUT LPRECT lprc)                      
    MSG_ENTRY_LPARAM(0x00B3, EM_SETRECT, IN OUT LPRECT lprc)                   
    MSG_ENTRY_LPARAM(0x00B4, EM_SETRECTNP, IN OUT LPRECT lprc)                 
    MSG_ENTRY_WPARAM(0x00B5, EM_SCROLL, IN INT nScroll)                        
    MSG_ENTRY_STD(0x00B6, EM_LINESCROLL, IN INT cxScroll, IN INT cyScroll)     
    MSG_ENTRY_EMPTY(0x00B7)                                                    
    MSG_ENTRY_NOPARAM(0x00B8, EM_GETMODIFY)                                    
    MSG_ENTRY_WPARAM(0x00B9, EM_SETMODIFY, IN UINT fModified)                  
    MSG_ENTRY_NOPARAM(0x00BA, EM_GETLINECOUNT)                                
    MSG_ENTRY_WPARAM(0x00BB, EM_LINEINDEX, IN INT line)                     
    MSG_ENTRY_WPARAM(0x00BC, EM_SETHANDLE, IN HLOCAL hloc)                  
    MSG_ENTRY_NOPARAM(0x00BD, EM_GETHANDLE)                                   
    MSG_ENTRY_NOPARAM(0x00BE, EM_GETTHUMB)                                    
    MSG_ENTRY_EMPTY(0x00BF)                                                   

    MSG_ENTRY_EMPTY(0x00C0)                                                   
    MSG_ENTRY_WPARAM(0x00C1, EM_LINELENGTH, IN INT ich)                     
    MSG_ENTRY_STD(0x00C2, EM_REPLACESEL, IN BOOL fCanUndo, IN LPCSTR lpszReplace) 
    MSG_ENTRY_LPARAM(0x00C3, EM_SETFONT, IN HLOCAL hLocal)                      
    MSG_ENTRY_STD(0x00C4, EM_GETLINE, IN UINT line, OUT LPCSTR lpch)           
    MSG_ENTRY_LPARAM(0x00C5, EM_LIMITTEXT, IN UINT cchMax)                   
    MSG_ENTRY_NOPARAM(0x00C6, EM_CANUNDO)                                      
    MSG_ENTRY_NOPARAM(0x00C7, EM_UNDO)                                         
    MSG_ENTRY_WPARAM(0x00C8, EM_FMTLINES, IN BOOL fAddEOL)                    
    MSG_ENTRY_WPARAM(0x00C9, EM_LINEFROMCHAR, IN INT ich)                     
    MSG_ENTRY_UNREFERENCED(0x00CA, EM_SETWORDBREAK)  
    MSG_ENTRY_STD(0x00CB, EM_SETTABSTOPS, IN UINT cTabs, LPDWORD lpdwTabs)  
    MSG_ENTRY_WPARAM(0x00CC, EM_SETPASSWORDCHAR, IN UINT ch)                  
    MSG_ENTRY_NOPARAM(0x00CD, EM_EMPTYUNDOBUFFER)          
    MSG_ENTRY_NOPARAM(0x00CE, EM_GETFIRSTVISIBLELINE)      
    MSG_ENTRY_WPARAM(0x00CF, EM_SETREADONLY, IN BOOL fReadOnly)                 

    MSG_ENTRY_LPARAM(0x00D0, EM_SETWORDBREAKPROC, IN EDITWORDBREAKPROC ewbprc)    
    MSG_ENTRY_NOPARAM(0x00D1, EM_GETWORDBREAKPROC)                               
    MSG_ENTRY_NOPARAM(0x00D2, EM_GETPASSWORDCHAR)                             
    MSG_ENTRY_STD(0x00D3, EM_SETMARGINS, IN UINT fwMargin, IN LONG composite)  // (UINT fwMargin, LONG(WORD wLeft, WORD wRight))  
    MSG_ENTRY_NOPARAM(0x00D4, EM_GETMARGINS)                                    
    MSG_ENTRY_NOPARAM(0x00D5, EM_GETLIMITTEXT)                                  
    MSG_ENTRY_WPARAM(0x00D6, EM_POSFROMCHAR, IN UINT wCharIndex)             
    MSG_ENTRY_LPARAM(0x00D7, EM_CHARFROMPOS, IN LPPOINTS pPoint)              
    MSG_ENTRY_STD(0x00D8, EM_SETIMESTATUS, IN UINT Status, IN LONG data)        

    MSG_ENTRY_WPARAM(0x00D9, EM_GETIMESTATUS, IN UINT Status)                 
    MSG_ENTRY_RESERVED(0x00DA)                            // EM_MSGMAX 
    MSG_ENTRY_EMPTY(0x00DB)                              
    MSG_ENTRY_EMPTY(0x00DC)                 
    MSG_ENTRY_EMPTY(0x00DD)                 
    MSG_ENTRY_EMPTY(0x00DE)                 
    MSG_ENTRY_EMPTY(0x00DF)                 

    MSG_ENTRY_STD(0x00E0, SBM_SETPOS, IN UINT nPos, IN BOOL fRedraw)            
    MSG_ENTRY_NOPARAM(0x00E1, SBM_GETPOS)                 
    MSG_ENTRY_STD(0x00E2, SBM_SETRANGE, IN UINT nMinPos, IN LONG nMaxPos)       
    MSG_ENTRY_STD(0x00E3, SBM_GETRANGE, OUT LPINT lpnMinPos, OUT LPINT lpnMaxPos)  
    MSG_ENTRY_WPARAM(0x00E4, SBM_ENABLE_ARROWS, IN UINT fuArrowFlags)           
    MSG_ENTRY_EMPTY(0x00E5)                 
    MSG_ENTRY_STD(0x00E6, SBM_SETRANGEREDRAW, IN UINT nMinPos, UINT nMaxPos)        
    MSG_ENTRY_EMPTY(0x00E7)                 

    MSG_ENTRY_EMPTY(0x00E8)
    MSG_ENTRY_STD(0x00E9, SBM_SETSCROLLINFO, IN BOOL fRedraw, IN OUT LPSCROLLINFO lpsi)  
    MSG_ENTRY_STD(0x00EA, SBM_GETSCROLLINFO, IN BOOL fRedraw, IN OUT LPSCROLLINFO lpsi)        
    MSG_ENTRY_EMPTY(0x00EB)                 
    MSG_ENTRY_EMPTY(0x00EC)                 
    MSG_ENTRY_EMPTY(0x00ED)                 
    MSG_ENTRY_EMPTY(0x00EE)                 
    MSG_ENTRY_EMPTY(0x00EF)                 

    MSG_ENTRY_NOPARAM(0x00F0, BM_GETCHECK)                      
    MSG_ENTRY_WPARAM(0x00F1, BM_SETCHECK, IN UINT fCheck)    
    MSG_ENTRY_NOPARAM(0x00F2, BM_GETSTATE)                     
    MSG_ENTRY_LPARAM(0x00F3, BM_SETSTATE, IN BOOL fState)     
    MSG_ENTRY_STD(0x00F4, BM_SETSTYLE, IN DWORD dwStyle, IN LONG composite) // (DWORD dwStyle, DWORD(BOOL fRedraw, 0))  
    MSG_ENTRY_NOPARAM(0x00F5, BM_CLICK)                         
    MSG_ENTRY_WPARAM(0x00F6,BM_GETIMAGE, IN UINT fImageType)  
    MSG_ENTRY_STD(0x00F7, BM_SETIMAGE, IN UINT fImageType, IN HANDLE hImage)   

    MSG_ENTRY_EMPTY(0x00F8)                                
    MSG_ENTRY_EMPTY(0x00F9)                 
    MSG_ENTRY_EMPTY(0x00FA)              
    MSG_ENTRY_EMPTY(0x00FB)                 
    MSG_ENTRY_EMPTY(0x00FC)                 
    MSG_ENTRY_EMPTY(0x00FD)                 
    MSG_ENTRY_EMPTY(0x00FE)                 
    MSG_ENTRY_EMPTY(0x00FF)                 

    MSG_ENTRY_STD(0x0100, WM_KEYDOWN, IN UINT nVirtKey, IN UINT KeyData)   
    MSG_ENTRY_STD(0x0101, WM_KEYUP, IN UINT nVirtKey, IN UINT KeyData)     
    MSG_ENTRY_STD(0x0102, WM_CHAR, TCHAR chCharCode, UINT KeyData)         
    MSG_ENTRY_STD(0x0103, WM_DEADCHAR, TCHAR chCharCode, IN UINT KeyData)  
    MSG_ENTRY_STD(0x0104, WM_SYSKEYDOWN, IN UINT nVirtKey, IN UINT KeyData)
    MSG_ENTRY_STD(0x0105, WM_SYSKEYUP, IN UINT nVirtKey, IN UINT KeyData)  
    MSG_ENTRY_STD(0x0106, WM_SYSCHAR, IN TCHAR chCharCode, IN UINT KeyData)  
    MSG_ENTRY_STD(0x0107, WM_SYSDEADCHAR, IN TCHAR chCharCode, UINT KeyData)  
    MSG_ENTRY_UNREFERENCED(0x0108, WM_YOMICHAR)               
    MSG_ENTRY_EMPTY(0x0109)                              
    MSG_ENTRY_UNREFERENCED(0x010A, WM_CONVERTREQUEST) 
    MSG_ENTRY_UNREFERENCED(0x010B, WM_CONVERTRESULT) 
    MSG_ENTRY_EMPTY(0x010C)                                
    MSG_ENTRY_EMPTY(0x010D)                                
    MSG_ENTRY_EMPTY(0x010E)                                
    MSG_ENTRY_STD(0x010F, WM_IME_COMPOSITION, IN DWORD cbDBCS, IN BOOL fFlags)   

    MSG_ENTRY_STD(0x0110, WM_INITDIALOG, IN HWND hwndFocus, IN DWORD lInitParam)  
    MSG_ENTRY_STD(0x0111, WM_COMMAND, IN DWORD composite, IN HWND hwndCtl) // (DWORD(WORD wNotifyCode, WORD wID), HWND hwndCtl)  
    MSG_ENTRY_STD(0x0112, WM_SYSCOMMAND, IN UINT uCmdType, IN DWORD composite) // (UINT uCmdType, DWORD(WORD xPos, WORD yPos))  
    MSG_ENTRY_STD(0x0113, WM_TIMER, IN DWORD wTimerId, IN TIMERPROC tmprc)   
    MSG_ENTRY_STD(0x0114, WM_HSCROLL, IN DWORD composte, IN HWND hwndScrollBar)                   // (DWORD(UINT nScrollCode, short int nPos), HWND hwndScrollBar) WM_HSCROLL               0x0114
    MSG_ENTRY_STD(0x0115, WM_VSCROLL, IN DWORD composte, IN HWND hwndScrollBar)                   // (DWORD(UINT nScrollCode, short int nPos), HWND hwndScrollBar) WM_VSCROLL               0x0115
    MSG_ENTRY_WPARAM(0x0116, WM_INITMENU, IN HMENU hmenuInit)               
    MSG_ENTRY_STD(0x0117, WM_INITMENUPOPUP, IN HMENU hmenuPopup, DWORD composite)                   // (HMENU hmenuPopup, DWORD(BOOL fSystemMenu, UINT uPos)) WM_INITMENUPOPUP         0x0117
    MSG_ENTRY_STD(0x0118, WM_SYSTIMER, IN UINT TimerID, IN TIMERPROC tmprc)  
    MSG_ENTRY_EMPTY(0x0119)                                
    MSG_ENTRY_EMPTY(0x011A)                               
    MSG_ENTRY_EMPTY(0x011B)                                
    MSG_ENTRY_EMPTY(0x011C)                                
    MSG_ENTRY_EMPTY(0x011D)                                
    MSG_ENTRY_EMPTY(0x011E)                                
    MSG_ENTRY_STD(0x011F, WM_MENUSELECT, IN DWORD composite, IN HMENU hMenu)  // (DWORD(UINT fuFlags, UINT uItem), HMENU)  

    MSG_ENTRY_STD(0x0120, WM_MENUCHAR, IN DWORD composite, IN HMENU hMenu)    // (DWORD(UINT fuFlags, TCHAR chUser), HMENU) 
    MSG_ENTRY_STD(0x0121, WM_ENTERIDLE, IN UINT fuSource, IN HWND hwnd)       
    MSG_ENTRY_STD(0x0122, WM_MENURBUTTONUP, IN UINT item, IN HMENU hMenu)    
    MSG_ENTRY_STD(0x0123, WM_MENUDRAG, IN UINT index, IN HMENU hMenu)  
    MSG_ENTRY_LPARAM(0x0124, WM_MENUGETOBJECT, IN OUT PMENUGETOBJECTINFO pmgoinfo)  
    MSG_ENTRY_STD(0x0125, WM_UNINITMENUPOPUP, IN HMENU hMenu, IN LONG composite)  
    MSG_ENTRY_STD(0x0126, WM_MENUCOMMAND, IN UINT cmd, IN HWND hMenu)   
    MSG_ENTRY_STD(0x0127, WM_CHANGEUISTATE, IN UINT composite, BOOL bUnknown)  

    MSG_ENTRY_STD(0x0128, WM_UPDATEUISTATE, IN UINT composite, BOOL bUnknown)                                
    MSG_ENTRY_NOPARAM(0x0129, WM_QUERYUISTATE)                 
    MSG_ENTRY_EMPTY(0x012A)                 
    MSG_ENTRY_EMPTY(0x012B)                 
    MSG_ENTRY_EMPTY(0x012C)                 
    MSG_ENTRY_EMPTY(0x012D)                 
    MSG_ENTRY_EMPTY(0x012E)                 
    MSG_ENTRY_EMPTY(0x012F)                 

    MSG_ENTRY_EMPTY(0x0130)                               
    MSG_ENTRY_STD(0x0131, WM_LBTRACKPOINT, IN UINT iSelFromPt, IN LONG composite)  
    MSG_ENTRY_STD(0x0132, WM_CTLCOLORMSGBOX, IN HDC hdc, IN HWND hwndChild)  
    MSG_ENTRY_STD(0x0133, WM_CTLCOLOREDIT, IN HDC hdcEdit, IN HWND hwndEdit)   
    MSG_ENTRY_STD(0x0134, WM_CTLCOLORLISTBOX, IN HDC hdcLB, IN HWND hwndLB)    
    MSG_ENTRY_STD(0x0135, WM_CTLCOLORBTN, IN HDC hdcButton, HWND hwndButton)   
    MSG_ENTRY_STD(0x0136, WM_CTLCOLORDLG, IN HDC hdcDlg, IN HWND hwndDlg)      
    MSG_ENTRY_STD(0x0137, WM_CTLCOLORSCROLLBAR, IN HDC hdcSB, IN HWND hwndSB)  
    MSG_ENTRY_STD(0x0138, WM_CTLCOLORSTATIC, IN HDC hdcStatic, IN HWND hwndStatis)  
    MSG_ENTRY_EMPTY(0x0139)                                
    MSG_ENTRY_EMPTY(0x013A)                                
    MSG_ENTRY_EMPTY(0x013B)                 
    MSG_ENTRY_EMPTY(0x013C)                 
    MSG_ENTRY_EMPTY(0x013D)                 
    MSG_ENTRY_EMPTY(0x013E)                 
    MSG_ENTRY_EMPTY(0x013F)                 

    MSG_ENTRY_STD(0x0140, CB_GETEDITSEL, OUT LPDWORD lpdwStart, OUT LPDWORD lpdwEnd)             
    MSG_ENTRY_WPARAM(0x0141, CB_LIMITTEXT, IN DWORD cchLimit)                     
    MSG_ENTRY_LPARAM(0x0142, CB_SETEDITSEL, IN DWORD composite)                  // (0, DWORD(WORD ichStart, WORD ichEnd)) 
    MSG_ENTRY_LPARAM(0x0143, CB_ADDSTRING, IN LPCSTR lpsz)                        
    MSG_ENTRY_WPARAM(0x0144, CB_DELETESTRING, IN INT item)                        
    MSG_ENTRY_STD(0x0145, CB_DIR, IN INT uAttrs, IN LPCSTR lpszFileSpec)           
    MSG_ENTRY_NOPARAM(0x0146, CB_GETCOUNT)                                         
    MSG_ENTRY_NOPARAM(0x0147, CB_GETCURSEL)                                        
    MSG_ENTRY_STD(0x0148, CB_GETLBTEXT, IN INT Index, OUT LPCSTR lpszBuffer)       
    MSG_ENTRY_WPARAM(0x0149, CB_GETLBTEXTLEN, IN INT Index)  
    MSG_ENTRY_STD(0x014A, CB_INSERTSTRING, IN INT Index, IN LPCTSTR lpstr)         
    MSG_ENTRY_NOPARAM(0x014B, CB_RESETCONTENT)                    
    MSG_ENTRY_STD(0x014C, CB_FINDSTRING, IN INT indexStart, IN LPCSTR lpszFind)    
    MSG_ENTRY_STD(0x014D, CB_SELECTSTRING, IN INT indexStart, IN LPCSTR lpszSelect)  
    MSG_ENTRY_WPARAM(0x014E, CB_SETCURSEL, IN INT index)                        
    MSG_ENTRY_WPARAM(0x014F, CB_SHOWDROPDOWN, IN BOOL fShow)                    

    MSG_ENTRY_LPARAM(0x0150, CB_GETITEMDATA, IN INT index)                      
    MSG_ENTRY_STD(0x0151, CB_SETITEMDATA, IN INT index, IN DWORD dwData)          
    MSG_ENTRY_LPARAM(0x0152, CB_GETDROPPEDCONTROLRECT, OUT LPRECT lprc)         
    MSG_ENTRY_STD(0x0153, CB_SETITEMHEIGHT, IN INT index, IN INT height)          
    MSG_ENTRY_WPARAM(0x0154, CB_GETITEMHEIGHT, IN INT index)                    
    MSG_ENTRY_WPARAM(0x0155, CB_SETEXTENDEDUI, IN BOOL fExtended)               
    MSG_ENTRY_NOPARAM(0x0156, CB_GETEXTENDEDUI)                     
    MSG_ENTRY_NOPARAM(0x0157, CB_GETDROPPEDSTATE)                   
    MSG_ENTRY_STD(0x0158, CB_FINDSTRINGEXACT, IN INT IndexStart, IN LPCSTR lpszFind)  
    MSG_ENTRY_WPARAM(0x0159, CB_SETLOCALE, IN WORD wLocale)                    
    MSG_ENTRY_NOPARAM(0x015A, CB_GETLOCALE)                    
    MSG_ENTRY_NOPARAM(0x015B, CB_GETTOPINDEX)                    
    MSG_ENTRY_WPARAM(0x015C, CB_SETTOPINDEX, IN INT Index)     
    MSG_ENTRY_NOPARAM(0x015D, CB_GETHORIZONTALEXTENT)
    MSG_ENTRY_LPARAM(0x015E, CB_SETHORIZONTALEXTENT, IN UINT cxExtent)  
    MSG_ENTRY_NOPARAM(0x015F, CB_GETDROPPEDWIDTH)                    

    MSG_ENTRY_WPARAM(0x0160, CB_SETDROPPEDWIDTH, IN UINT wWidth)   
    MSG_ENTRY_STD(0x0161, CB_INITSTORAGE, IN INT Items, IN DWORD cb)  
    MSG_ENTRY_RESERVED(0x0162)                             
    MSG_ENTRY_EMPTY(0x0163)                                
    MSG_ENTRY_EMPTY(0x0164)                 
    MSG_ENTRY_EMPTY(0x0165)                 
    MSG_ENTRY_EMPTY(0x0166)                 
    MSG_ENTRY_EMPTY(0x0167)                 
    MSG_ENTRY_EMPTY(0x0168)                                
    MSG_ENTRY_EMPTY(0x0169)                 
    MSG_ENTRY_EMPTY(0x016A)                 
    MSG_ENTRY_EMPTY(0x016B)                 
    MSG_ENTRY_EMPTY(0x016C)                 
    MSG_ENTRY_EMPTY(0x016D)                 
    MSG_ENTRY_EMPTY(0x016E)                 
    MSG_ENTRY_EMPTY(0x016F)                 

    MSG_ENTRY_WPARAM(0x0170, STM_SETICON, IN HICON hicon)  
    MSG_ENTRY_NOPARAM(0x0171, STM_GETICON)                  
    MSG_ENTRY_STD(0x0172, STM_SETIMAGE, IN UINT fImageType, IN HANDLE hImage)   
    MSG_ENTRY_WPARAM(0x0173, STM_GETIMAGE, IN UINT fImageType)    
    MSG_ENTRY_RESERVED(0x0174)                            // STM_MSGMAX  
    MSG_ENTRY_EMPTY(0x0175)                                
    MSG_ENTRY_EMPTY(0x0176)                 
    MSG_ENTRY_EMPTY(0x0177)                 

    MSG_ENTRY_EMPTY(0x0178)                                
    MSG_ENTRY_EMPTY(0x0179)                 
    MSG_ENTRY_EMPTY(0x017A)                 
    MSG_ENTRY_EMPTY(0x017B)                 
    MSG_ENTRY_EMPTY(0x017C)                 
    MSG_ENTRY_EMPTY(0x017D)                 
    MSG_ENTRY_EMPTY(0x017E)                 
    MSG_ENTRY_EMPTY(0x017F)                 

    MSG_ENTRY_LPARAM(0x0180, LB_ADDSTRING, IN LPCSTR lpsz)    
    MSG_ENTRY_STD(0x0181, LB_INSERTSTRING, IN INT index, IN LPCSTR lpsz)  
    MSG_ENTRY_WPARAM(0x0182, LB_DELETESTRING, IN INT index)   
    MSG_ENTRY_EMPTY(0x0183)                                
    MSG_ENTRY_NOPARAM(0x0184, LB_RESETCONTENT)             
    MSG_ENTRY_STD(0x0185, LB_SETSEL, IN BOOL fSelect, INT index)  
    MSG_ENTRY_WPARAM(0x0186, LB_SETCURSEL, IN INT index)        
    MSG_ENTRY_WPARAM(0x0187, LB_GETSEL, IN INT index)           
    MSG_ENTRY_NOPARAM(0x0188, LB_GETCURSEL)                    
    MSG_ENTRY_STD(0x0189, LB_GETTEXT, IN INT index, OUT LPCSTR lpszBuffer)            
    MSG_ENTRY_WPARAM(0x018A, LB_GETTEXTLEN, IN INT index)       
    MSG_ENTRY_NOPARAM(0x018B, LB_GETCOUNT)                    
    MSG_ENTRY_STD(0x018C, LB_SELECTSTRING, IN INT index, IN LPCTSTR lpszFind)  
    MSG_ENTRY_STD(0x018D, LB_DIR, IN UINT uAtrs, IN LPCSTR lpszFileSpec)  
    MSG_ENTRY_NOPARAM(0x018E, LB_GETTOPINDEX)                     
    MSG_ENTRY_STD(0x018F, LB_FINDSTRING, IN INT IndexStart, LPCTSTR lpszFind)  

    MSG_ENTRY_NOPARAM(0x0190, LB_GETSELCOUNT)                    
    MSG_ENTRY_STD(0x0191, LB_GETSELITEMS, IN INT MaxSel, OUT LPINT lpiItems)
    MSG_ENTRY_STD(0x0192, LB_SETTABSTOPS, IN INT cTabs, IN LPINT lpnTabs)  
    MSG_ENTRY_NOPARAM(0x0193, LB_GETHORIZONTALEXTENT)      
    MSG_ENTRY_WPARAM(0x0194, LB_SETHORIZONTALEXTENT, IN UINT cxExtent)    
    MSG_ENTRY_WPARAM(0x0195, LB_SETCOLUMNWIDTH, IN UINT cxColumn)          
    MSG_ENTRY_LPARAM(0x0196, LB_ADDFILE, IN LPCSTR lpszFileName)           
    MSG_ENTRY_WPARAM(0x0197, LB_SETTOPINDEX, IN INT index)                 
    MSG_ENTRY_STD(0x0198, LB_GETITEMRECT, IN INT index, IN OUT LPRECT lprc)   
    MSG_ENTRY_WPARAM(0x0199, LB_GETITEMDATA, IN INT index)                 
    MSG_ENTRY_STD(0x019A, LB_SETITEMDATA, IN INT idex, IN DWORD dwData)      
    MSG_ENTRY_STD(0x019B, LB_SELITEMRANGE, IN BOOL fSelect, IN DWORD composite)  
    MSG_ENTRY_WPARAM(0x019C, LB_SETANCHORINDEX, IN INT index)                
    MSG_ENTRY_NOPARAM(0x019D, LB_GETANCHORINDEX)           
    MSG_ENTRY_STD(0x019E, LB_SETCARETINDEX, IN INT index, IN DWORD composite)                    
    MSG_ENTRY_NOPARAM(0x019F, LB_GETCARETINDEX)            

    MSG_ENTRY_STD(0x01A0, LB_SETITEMHEIGHT, IN INT index, IN DWORD composite)                    
    MSG_ENTRY_WPARAM(0x01A1, LB_GETITEMHEIGHT, IN INT index)                    
    MSG_ENTRY_STD(0x01A2, LB_FINDSTRINGEXACT, IN INT index, IN LPCSTR lpszFind)   
    MSG_ENTRY_NOPARAM(0x01A3, LBCB_CARETON)  
    MSG_ENTRY_NOPARAM(0x01A4, LBCB_CARETOFF)  
    MSG_ENTRY_WPARAM(0x01A5, LB_SETLOCALE, IN DWORD wLocaleID)  
    MSG_ENTRY_NOPARAM(0x01A6, LB_GETLOCALE)               
    MSG_ENTRY_WPARAM(0x01A7, LB_SETCOUNT, IN INT cItems)                     
    MSG_ENTRY_STD(0x01A8, LB_INITSTORAGE, IN INT cItems, IN DWORD cb)    
    MSG_ENTRY_LPARAM(0x01A9, LB_ITEMFROMPOINT, IN DWORD composite)   // (0, DWORD(UINT x, UINT y))  
    MSG_ENTRY_STD(0x01AA, LB_INSERTSTRINGUPPER, IN INT index, IN LPCSTR lpsz)  
    MSG_ENTRY_STD(0x01AB, LB_INSERTSTRINGLOWER, IN INT index, IN LPCSTR lpsz)  
    MSG_ENTRY_LPARAM(0x01AC, LB_ADDSTRINGUPPER, IN LPCSTR lpsz)  
    MSG_ENTRY_LPARAM(0x01AD, LB_ADDSTRINGLOWER, IN LPCSTR lpsz)  
    MSG_ENTRY_WPARAM(0x01AE, LBCB_STARTTRACK, IN BOOL bUnknown) 
    MSG_ENTRY_WPARAM(0x01AF, LBCB_ENDTRACK, IN BOOL bUnknown) 

    MSG_ENTRY_RESERVED(0x01B0)                            // LB_MSGMAX                0x01B0
    MSG_ENTRY_EMPTY(0x01B1)                               
    MSG_ENTRY_EMPTY(0x01B2)                 
    MSG_ENTRY_EMPTY(0x01B3)                 
    MSG_ENTRY_EMPTY(0x01B4)                 
    MSG_ENTRY_EMPTY(0x01B5)                 
    MSG_ENTRY_EMPTY(0x01B6)                 
    MSG_ENTRY_EMPTY(0x01B7)                 

    MSG_ENTRY_EMPTY(0x01B8)                               
    MSG_ENTRY_EMPTY(0x01B9)                 
    MSG_ENTRY_EMPTY(0x01BA)                 
    MSG_ENTRY_EMPTY(0x01BB)                 
    MSG_ENTRY_EMPTY(0x01BC)                 
    MSG_ENTRY_EMPTY(0x01BD)                 
    MSG_ENTRY_EMPTY(0x01BE)                 
    MSG_ENTRY_EMPTY(0x01BF)                 

    MSG_ENTRY_EMPTY(0x01C0)                                
    MSG_ENTRY_EMPTY(0x01C1)                 
    MSG_ENTRY_EMPTY(0x01C2)                 
    MSG_ENTRY_EMPTY(0x01C3)                 
    MSG_ENTRY_EMPTY(0x01C4)                 
    MSG_ENTRY_EMPTY(0x01C5)                 
    MSG_ENTRY_EMPTY(0x01C6)                 
    MSG_ENTRY_EMPTY(0x01C7)                 

    MSG_ENTRY_EMPTY(0x01C8)                                
    MSG_ENTRY_EMPTY(0x01C9)                 
    MSG_ENTRY_EMPTY(0x01CA)                 
    MSG_ENTRY_EMPTY(0x01CB)                 
    MSG_ENTRY_EMPTY(0x01CC)                 
    MSG_ENTRY_EMPTY(0x01CD)                 
    MSG_ENTRY_EMPTY(0x01CE)                 
    MSG_ENTRY_EMPTY(0x01CF)                 

    MSG_ENTRY_EMPTY(0x01D0)                               
    MSG_ENTRY_EMPTY(0x01D1)                 
    MSG_ENTRY_EMPTY(0x01D2)                 
    MSG_ENTRY_EMPTY(0x01D3)                 
    MSG_ENTRY_EMPTY(0x01D4)                 
    MSG_ENTRY_EMPTY(0x01D5)                 
    MSG_ENTRY_EMPTY(0x01D6)                 
    MSG_ENTRY_EMPTY(0x01D7)                 

    MSG_ENTRY_EMPTY(0x01D8)                                
    MSG_ENTRY_EMPTY(0x01D9)                 
    MSG_ENTRY_EMPTY(0x01DA)                 
    MSG_ENTRY_EMPTY(0x01DB)                 
    MSG_ENTRY_EMPTY(0x01DC)                 
    MSG_ENTRY_EMPTY(0x01DD)                
    MSG_ENTRY_EMPTY(0x01DE)                 
    MSG_ENTRY_EMPTY(0x01DF)                 

    MSG_ENTRY_WPARAM(0x01E0, MN_SETHMENU, IN HMENU hMenu)  
    MSG_ENTRY_NOPARAM(0x01E1, MN_GETHMENU) 
    MSG_ENTRY_WPARAM(0x01E2, MN_SIZEWINDOW, IN UINT flags)             
    MSG_ENTRY_NOPARAM(0x01E3, MN_OPENHIERARCHY) 
    MSG_ENTRY_NOPARAM(0x01E4, MN_CLOSEHIERARCHY) 
    MSG_ENTRY_WPARAM(0x01E5, MN_SELECTITEM, IN INT item) 
    MSG_ENTRY_STD(0x01E6, MN_CANCELMENUS, IN UINT cmd, IN BOOL bBool) 
    MSG_ENTRY_WPARAM(0x01E7, MN_SELECTFIRSTVALIDITEM, IN UINT item) 

    MSG_ENTRY_EMPTY(0x01E8)                                
    MSG_ENTRY_EMPTY(0x01E9)                 
    MSG_ENTRY_NOPARAM(0x01EA, MN_GETPPOPUPMENU)                                
    MSG_ENTRY_STD(0x01EB, MN_FINDMENUWINDOWFROMPOINT, OUT PUINT pItem, IN LONG composite)  
    MSG_ENTRY_NOPARAM(0x01EC, MN_SHOWPOPUPWINDOW)  
    MSG_ENTRY_WPARAM(0x01ED, MN_BUTTONDOWN, IN UINT item)  
    MSG_ENTRY_LPARAM(0x01EE, MN_MOUSEMOVE, IN LONG points) // actualy it is a real POINTS struct.   
    MSG_ENTRY_STD(0x01EF, MN_BUTTONUP, IN UINT item, IN LONG composite)  
    MSG_ENTRY_NOPARAM(0x01F0, MN_SETTIMERTOOPENHIERARCHY) 

    MSG_ENTRY_WPARAM(0x01F1, MN_DBLCLK, IN UINT item)
    MSG_ENTRY_NOPARAM(0x01F2, MN_ACTIVATEPOPUP)
    MSG_ENTRY_NOPARAM(0x01F3, MN_ENDMENU) 
    MSG_ENTRY_STD(0x01F4, MN_DODRAGDROP, IN UINT item, IN HMENU hMenu)  
    MSG_ENTRY_RESERVED(0x01F5)      //MN_LASTPOSSIBLE                       
    MSG_ENTRY_EMPTY(0x01F6)                 
    MSG_ENTRY_EMPTY(0x01F7)                 

    MSG_ENTRY_EMPTY(0x01F8)                                
    MSG_ENTRY_EMPTY(0x01F9)                 
    MSG_ENTRY_EMPTY(0x01FA)                 
    MSG_ENTRY_EMPTY(0x01FB)                 
    MSG_ENTRY_EMPTY(0x01FC)                 
    MSG_ENTRY_EMPTY(0x01FD)                 
    MSG_ENTRY_EMPTY(0x01FE)                 
    MSG_ENTRY_EMPTY(0x01FF)                 

    MSG_ENTRY_STD(0x0200, WM_MOUSEMOVE, IN UINT fwKeys, IN DWORD composite)  // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0201, WM_LBUTTONDOWN, IN UINT fwKeys, IN DWORD composite)  // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0202, WM_LBUTTONUP, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0203, WM_LBUTTONDBLCLK, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0204, WM_RBUTTONDOWN, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0205, WM_RBUTTONUP, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0206, WM_RBUTTONDBLCLK, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0207, WM_MBUTTONDOWN, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0208, WM_MBUTTONUP, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x0209, WM_MBUTTONDBLCLK, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(WORD yPos, WORD xPos))  
    MSG_ENTRY_STD(0x020A, WM_MOUSEWHEEL, IN DWORD wcomposite, IN DWORD lcomposite)                   // (DWORD(zDelta, fwKeys), DWORD(yPos, xPos))  
    MSG_ENTRY_EMPTY(0x020B)                                
    MSG_ENTRY_EMPTY(0x020C)                                
    MSG_ENTRY_EMPTY(0x020D)                                
    MSG_ENTRY_EMPTY(0x020E)                                
    MSG_ENTRY_EMPTY(0x020F)                                

    MSG_ENTRY_STD(0x0210, WM_PARENTNOTIFY, IN UINT composite, IN HWND hwnd) // This is cheating since hwnd can be a composite, but this should work (DWORD(WORD idChild, WORD fwEvent), HWND || DWORD(WORD y, WORD y)) 
    MSG_ENTRY_WPARAM(0x0211, WM_ENTERMENULOOP, IN BOOL fIsTrackPopupMenu)                     
    MSG_ENTRY_WPARAM(0x0212, WM_EXITMENULOOP, IN BOOL fIsTrackPopupMenu)                     
    MSG_ENTRY_STD(0x0213, WM_NEXTMENU, IN UINT nVirtKey, IN OUT PMDINEXTMENU pmdin)            
    MSG_ENTRY_STD(0x0214, WM_SIZING, IN UINT fwSide, IN OUT LPRECT lprc)              
    MSG_ENTRY_LPARAM(0x0215, WM_CAPTURECHANGED, IN HWND lParam)                    
    MSG_ENTRY_STD(0x0216, WM_MOVING, IN UINT fwSide, IN OUT LPRECT lprc)             
    MSG_ENTRY_EMPTY(0x0217)                 

    MSG_ENTRY_STD(0x0218, WM_POWERBROADCAST, IN DWORD wParam, IN DWORD dwData)          
    MSG_ENTRY_STD(0x0219, WM_DEVICECHANGE, IN UINT Event, IN DWORD dwData)         
    MSG_ENTRY_EMPTY(0x021A)                                
    MSG_ENTRY_EMPTY(0x021B)                 
    MSG_ENTRY_EMPTY(0x021C)                 
    MSG_ENTRY_EMPTY(0x021D)                 
    MSG_ENTRY_EMPTY(0x021E)                 
    MSG_ENTRY_EMPTY(0x021F)                 

    MSG_ENTRY_LPARAM(0x0220, WM_MDICREATE, IN LPMDICREATESTRUCT lpmdic)      
    MSG_ENTRY_WPARAM(0x0221, WM_MDIDESTROY, IN HWND hwndChild)                   
    MSG_ENTRY_LPARAM(0x0222, WM_MDIACTIVATE, IN DWORD compostite)        
    MSG_ENTRY_WPARAM(0x0223, WM_MDIRESTORE, IN HWND hwndRes)          
    MSG_ENTRY_STD(0x0224, WM_MDINEXT, IN HWND hwndChild, IN BOOL fNext)  
    MSG_ENTRY_WPARAM(0x0225, WM_MDIMAXIMIZE, IN HWND hwndMax)                   
    MSG_ENTRY_WPARAM(0x0226, WM_MDITILE, IN UINT fuTitle)             
    MSG_ENTRY_WPARAM(0x0227, WM_MDICASCADE, IN UINT fuCascade)        
    MSG_ENTRY_NOPARAM(0x0228, WM_MDIICONARRANGE)                   
    MSG_ENTRY_LPARAM(0x0229, WM_MDIGETACTIVE, IN OUT LPBOOL lpb) 
    MSG_ENTRY_STD(0x022A, WM_DROPOBJECT, IN HWND hwndFrom, IN OUT LPDROPSTRUCT lpds) 
    MSG_ENTRY_STD(0x022B, WM_QUERYDROPOBJECT, IN BOOL fNC, IN OUT LPDROPSTRUCT lpds) 
    MSG_ENTRY_STD(0x022C, WM_BEGINDRAG, IN INT iSelBase, IN HWND hwnd) 
    MSG_ENTRY_STD(0x022D, WM_DRAGLOOP, IN BOOL bUnknown, IN OUT LPDROPSTRUCT lpds) 
    MSG_ENTRY_STD(0x022E, WM_DRAGSELECT, IN BOOL bUnknown, IN OUT LPDROPSTRUCT lpds) 
    MSG_ENTRY_LPARAM(0x022F, WM_DRAGMOVE, IN OUT LPDROPSTRUCT lpds) 

    MSG_ENTRY_STD(0x0230, WM_MDISETMENU, IN HMENU hmenuFrame, IN HMENU hMenuFrame)  
    MSG_ENTRY_NOPARAM(0x0231, WM_ENTERSIZEMOVE)                    
    MSG_ENTRY_NOPARAM(0x0232, WM_EXITSIZEMOVE)                    
    MSG_ENTRY_WPARAM(0x0233, WM_DROPFILES, IN HANDLE hDrop)    
    MSG_ENTRY_NOPARAM(0x0234, WM_MDIREFRESHMENU)                 
    MSG_ENTRY_EMPTY(0x0235)                                
    MSG_ENTRY_EMPTY(0x0236)                 
    MSG_ENTRY_EMPTY(0x0237)                 

    MSG_ENTRY_EMPTY(0x0238)                                
    MSG_ENTRY_EMPTY(0x0239)                 
    MSG_ENTRY_EMPTY(0x023A)                 
    MSG_ENTRY_EMPTY(0x023B)                 
    MSG_ENTRY_EMPTY(0x023C)                 
    MSG_ENTRY_EMPTY(0x023D)                 
    MSG_ENTRY_EMPTY(0x023E)                 
    MSG_ENTRY_EMPTY(0x023F)                 

    MSG_ENTRY_EMPTY(0x0240)                                
    MSG_ENTRY_EMPTY(0x0241)                 
    MSG_ENTRY_EMPTY(0x0242)                 
    MSG_ENTRY_EMPTY(0x0243)                 
    MSG_ENTRY_EMPTY(0x0244)                 
    MSG_ENTRY_EMPTY(0x0245)                 
    MSG_ENTRY_EMPTY(0x0246)                 
    MSG_ENTRY_EMPTY(0x0247)                 

    MSG_ENTRY_EMPTY(0x0248)                                
    MSG_ENTRY_EMPTY(0x0249)                 
    MSG_ENTRY_EMPTY(0x024A)                 
    MSG_ENTRY_EMPTY(0x024B)                 
    MSG_ENTRY_EMPTY(0x024C)                 
    MSG_ENTRY_EMPTY(0x024D)                 
    MSG_ENTRY_EMPTY(0x024E)                 
    MSG_ENTRY_EMPTY(0x024F)                 

    MSG_ENTRY_EMPTY(0x0250)                                
    MSG_ENTRY_EMPTY(0x0251)                 
    MSG_ENTRY_EMPTY(0x0252)                 
    MSG_ENTRY_EMPTY(0x0253)                 
    MSG_ENTRY_EMPTY(0x0254)                 
    MSG_ENTRY_EMPTY(0x0255)                 
    MSG_ENTRY_EMPTY(0x0256)                 
    MSG_ENTRY_EMPTY(0x0257)                 

    MSG_ENTRY_EMPTY(0x0258)                                
    MSG_ENTRY_EMPTY(0x0259)                 
    MSG_ENTRY_EMPTY(0x025A)                 
    MSG_ENTRY_EMPTY(0x025B)                 
    MSG_ENTRY_EMPTY(0x025C)                 
    MSG_ENTRY_EMPTY(0x025D)                 
    MSG_ENTRY_EMPTY(0x025E)                 
    MSG_ENTRY_EMPTY(0x025F)                 

    MSG_ENTRY_EMPTY(0x0260)                                
    MSG_ENTRY_EMPTY(0x0261)                 
    MSG_ENTRY_EMPTY(0x0262)                 
    MSG_ENTRY_EMPTY(0x0263)                 
    MSG_ENTRY_EMPTY(0x0264)                 
    MSG_ENTRY_EMPTY(0x0265)                 
    MSG_ENTRY_EMPTY(0x0266)                 
    MSG_ENTRY_EMPTY(0x0267)                 

    MSG_ENTRY_EMPTY(0x0268)                                
    MSG_ENTRY_EMPTY(0x0269)                 
    MSG_ENTRY_EMPTY(0x026A)                 
    MSG_ENTRY_EMPTY(0x026B)                 
    MSG_ENTRY_EMPTY(0x026C)                 
    MSG_ENTRY_EMPTY(0x026D)                 
    MSG_ENTRY_EMPTY(0x026E)                 
    MSG_ENTRY_EMPTY(0x026F)                 

    MSG_ENTRY_EMPTY(0x0270)                                
    MSG_ENTRY_EMPTY(0x0271)                 
    MSG_ENTRY_EMPTY(0x0272)                 
    MSG_ENTRY_EMPTY(0x0273)                 
    MSG_ENTRY_EMPTY(0x0274)                 
    MSG_ENTRY_EMPTY(0x0275)                 
    MSG_ENTRY_EMPTY(0x0276)                 
    MSG_ENTRY_EMPTY(0x0277)                 

    MSG_ENTRY_EMPTY(0x0278)                                
    MSG_ENTRY_EMPTY(0x0279)                 
    MSG_ENTRY_EMPTY(0x027A)                 
    MSG_ENTRY_EMPTY(0x027B)                 
    MSG_ENTRY_EMPTY(0x027C)                 
    MSG_ENTRY_EMPTY(0x027D)                 
    MSG_ENTRY_EMPTY(0x027E)                 
    MSG_ENTRY_EMPTY(0x027F)                 

    MSG_ENTRY_STD(0x0280, WM_IME_REPORT, IN UINT reportparam, IN HANDLE hUnknown)  
    MSG_ENTRY_STD(0x0281, WM_IME_SETCONTEXT, IN BOOL fSet, IN DWORD iShow)    
    MSG_ENTRY_STD(0x0282, WM_IME_NOTIFY, IN DWORD dwCommand, IN DWORD dwData)  
    MSG_ENTRY_STD(0x0283, WM_IME_CONTROL, IN DWORD dwCommand, IN DWORD dwData)  
    MSG_ENTRY_NOPARAM(0x0284, WM_IME_COMPOSITIONFULL)                    
    MSG_ENTRY_STD(0x0285, WM_IME_SELECT, IN BOOL fSelect, IN HANDLE hkl)  
    MSG_ENTRY_STD(0x0286, WM_IME_CHAR, IN WORD chCharCode, IN DWORD KeyData)  
    MSG_ENTRY_RESERVED(0x0287)                         

    MSG_ENTRY_RESERVED(0x0288)                             
    MSG_ENTRY_RESERVED(0x0289)                         
    MSG_ENTRY_RESERVED(0x028A)                         
    MSG_ENTRY_RESERVED(0x028B)                         
    MSG_ENTRY_RESERVED(0x028C)
    MSG_ENTRY_RESERVED(0x028D)                         
    MSG_ENTRY_RESERVED(0x028E)                         
    MSG_ENTRY_RESERVED(0x028F)                         

    MSG_ENTRY_RESERVED(0x0290)                             
    MSG_ENTRY_RESERVED(0x0291)                         
    MSG_ENTRY_RESERVED(0x0292)                         
    MSG_ENTRY_RESERVED(0x0293)                         
    MSG_ENTRY_RESERVED(0x0294)                         
    MSG_ENTRY_RESERVED(0x0295)                         
    MSG_ENTRY_RESERVED(0x0296)                         
    MSG_ENTRY_RESERVED(0x0297)                         

    MSG_ENTRY_RESERVED(0x0298)                             
    MSG_ENTRY_RESERVED(0x0299)                         
    MSG_ENTRY_RESERVED(0x029A)                         
    MSG_ENTRY_RESERVED(0x029B)                         
    MSG_ENTRY_RESERVED(0x029C)                         
    MSG_ENTRY_RESERVED(0x029D)                         
    MSG_ENTRY_RESERVED(0x029E)                         
    MSG_ENTRY_RESERVED(0x029F)                            // WM_KANJILAST              

    MSG_ENTRY_STD(0x02A0, WM_NCMOUSEHOVER, IN INT nHittest, IN OUT LPPOINTS lppts)                    
    MSG_ENTRY_STD(0x02A1,WM_MOUSEHOVER, IN UINT fwKeys, IN DWORD composite)                   // (UINT fwKeys, DWORD(yPos xPos))  
    MSG_ENTRY_NOPARAM(0x02A2, WM_NCMOUSELEAVE)  
    MSG_ENTRY_NOPARAM(0x02A3, WM_MOUSELEAVE)  

    MSG_ENTRY_EMPTY(0x02A4)                                
    MSG_ENTRY_EMPTY(0x02A5)                 
    MSG_ENTRY_EMPTY(0x02A6)                 
    MSG_ENTRY_EMPTY(0x02A7)                 

    MSG_ENTRY_EMPTY(0x02A8)                                
    MSG_ENTRY_EMPTY(0x02A9)                 
    MSG_ENTRY_EMPTY(0x02AA)                 
    MSG_ENTRY_EMPTY(0x02AB)                 
    MSG_ENTRY_EMPTY(0x02AC)                 
    MSG_ENTRY_EMPTY(0x02AD)                 
    MSG_ENTRY_EMPTY(0x02AE)                 
    MSG_ENTRY_EMPTY(0x02AF)                 

    MSG_ENTRY_EMPTY(0x02B0)                                
    MSG_ENTRY_EMPTY(0x02B1)                 
    MSG_ENTRY_EMPTY(0x02B2)                 
    MSG_ENTRY_EMPTY(0x02B3)                 
    MSG_ENTRY_EMPTY(0x02B4)                 
    MSG_ENTRY_EMPTY(0x02B5)                 
    MSG_ENTRY_EMPTY(0x02B6)                 
    MSG_ENTRY_EMPTY(0x02B7)                 

    MSG_ENTRY_EMPTY(0x02B8)                                
    MSG_ENTRY_EMPTY(0x02B9)                 
    MSG_ENTRY_EMPTY(0x02BA)                 
    MSG_ENTRY_EMPTY(0x02BB)                 
    MSG_ENTRY_EMPTY(0x02BC)                 
    MSG_ENTRY_EMPTY(0x02BD)                 
    MSG_ENTRY_EMPTY(0x02BE)                 
    MSG_ENTRY_EMPTY(0x02BF)                 

    MSG_ENTRY_EMPTY(0x02C0)                                
    MSG_ENTRY_EMPTY(0x02C1)                 
    MSG_ENTRY_EMPTY(0x02C2)                 
    MSG_ENTRY_EMPTY(0x02C3)                 
    MSG_ENTRY_EMPTY(0x02C4)                 
    MSG_ENTRY_EMPTY(0x02C5)                 
    MSG_ENTRY_EMPTY(0x02C6)                 
    MSG_ENTRY_EMPTY(0x02C7)                 

    MSG_ENTRY_EMPTY(0x02C8)                                
    MSG_ENTRY_EMPTY(0x02C9)                 
    MSG_ENTRY_EMPTY(0x02CA)                 
    MSG_ENTRY_EMPTY(0x02CB)                 
    MSG_ENTRY_EMPTY(0x02CC)                
    MSG_ENTRY_EMPTY(0x02CD)                 
    MSG_ENTRY_EMPTY(0x02CE)                 
    MSG_ENTRY_EMPTY(0x02CF)                 

    MSG_ENTRY_EMPTY(0x02D0)                                
    MSG_ENTRY_EMPTY(0x02D1)                 
    MSG_ENTRY_EMPTY(0x02D2)                 
    MSG_ENTRY_EMPTY(0x02D3)                 
    MSG_ENTRY_EMPTY(0x02D4)                 
    MSG_ENTRY_EMPTY(0x02D5)                 
    MSG_ENTRY_EMPTY(0x02D6)                 
    MSG_ENTRY_EMPTY(0x02D7)                 

    MSG_ENTRY_EMPTY(0x02D8)                               
    MSG_ENTRY_EMPTY(0x02D9)                 
    MSG_ENTRY_EMPTY(0x02DA)                 
    MSG_ENTRY_EMPTY(0x02DB)                 
    MSG_ENTRY_EMPTY(0x02DC)                 
    MSG_ENTRY_EMPTY(0x02DD)                 
    MSG_ENTRY_EMPTY(0x02DE)                 
    MSG_ENTRY_EMPTY(0x02DF)                 

    MSG_ENTRY_EMPTY(0x02E0)                                
    MSG_ENTRY_EMPTY(0x02E1)                 
    MSG_ENTRY_EMPTY(0x02E2)                 
    MSG_ENTRY_EMPTY(0x02E3)                 
    MSG_ENTRY_EMPTY(0x02E4)                 
    MSG_ENTRY_EMPTY(0x02E5)                 
    MSG_ENTRY_EMPTY(0x02E6)                 
    MSG_ENTRY_EMPTY(0x02E7)                 

    MSG_ENTRY_EMPTY(0x02E8)                                
    MSG_ENTRY_EMPTY(0x02E9)                 
    MSG_ENTRY_EMPTY(0x02EA)                 
    MSG_ENTRY_EMPTY(0x02EB)                 
    MSG_ENTRY_EMPTY(0x02EC)                 
    MSG_ENTRY_EMPTY(0x02ED)                 
    MSG_ENTRY_EMPTY(0x02EE)                 
    MSG_ENTRY_EMPTY(0x02EF)                 

    MSG_ENTRY_EMPTY(0x02F0)                                
    MSG_ENTRY_EMPTY(0x02F1)                 
    MSG_ENTRY_EMPTY(0x02F2)                 
    MSG_ENTRY_EMPTY(0x02F3)                 
    MSG_ENTRY_EMPTY(0x02F4)                 
    MSG_ENTRY_EMPTY(0x02F5)                 
    MSG_ENTRY_EMPTY(0x02F6)                 
    MSG_ENTRY_EMPTY(0x02F7)                 

    MSG_ENTRY_EMPTY(0x02F8)                                
    MSG_ENTRY_EMPTY(0x02F9)                 
    MSG_ENTRY_EMPTY(0x02FA)                 
    MSG_ENTRY_EMPTY(0x02FB)                 
    MSG_ENTRY_EMPTY(0x02FC)                 
    MSG_ENTRY_EMPTY(0x02FD)                 
    MSG_ENTRY_EMPTY(0x02FE)                 
    MSG_ENTRY_EMPTY(0x02FF)                 

    MSG_ENTRY_NOPARAM(0x0300, WM_CUT)                     
    MSG_ENTRY_NOPARAM(0x0301, WM_COPY)                     
    MSG_ENTRY_NOPARAM(0x0302, WM_PASTE)                    
    MSG_ENTRY_NOPARAM(0x0303, WM_CLEAR)                    
    MSG_ENTRY_NOPARAM(0x0304, WM_UNDO)                     
    MSG_ENTRY_LPARAM(0x0305, WM_RENDERFORMAT, IN UINT uFormat)  
    MSG_ENTRY_NOPARAM(0x0306, WM_RENDERALLFORMATS)         
    MSG_ENTRY_NOPARAM(0x0307, WM_DESTROYCLIPBOARD)         
    MSG_ENTRY_NOPARAM(0x0308, WM_DRAWCLIPBOARD)            
    MSG_ENTRY_STD(0x0309, WM_PAINTCLIPBOARD, IN HWND hwndViewer, IN HGLOBAL hglbPs)           
    MSG_ENTRY_STD(0x030A, WM_VSCROLLCLIPBOARD, IN HWND hwndViewer, IN DWORD composite)       // (HWND hwndViewer, DWORD(nPos, nScrollCode))  
    MSG_ENTRY_STD(0x030B, WM_SIZECLIPBOARD, IN HWND hwndViewer, IN HGLOBAL hglbRc)            
    MSG_ENTRY_STD(0x030C, WM_ASKCBFORMATNAME, IN DWORD cchName, IN LPTSTR lpszFormatName)     
    MSG_ENTRY_STD(0x030D, WM_CHANGECBCHAIN, IN HWND hwndRemove, IN HWND hwndNext)             
    MSG_ENTRY_STD(0x030E, WM_HSCROLLCLIPBOARD, IN HWND hwndViewer, IN DWORD composite)        
    MSG_ENTRY_NOPARAM(0x030F, WM_QUERYNEWPALETTE)          
    MSG_ENTRY_WPARAM(0x0310, WM_PALETTEISCHANGING, HWND hwndRealize)   
    MSG_ENTRY_WPARAM(0x0311, WM_PALETTECHANGED, IN HWND hwndPalChg)    
    MSG_ENTRY_STD(0x0312, WM_HOTKEY, IN INT idHotKey, INT composite)                  

    MSG_ENTRY_EMPTY(0x0313)                               
    MSG_ENTRY_KERNELONLY(0x0314, WM_HOOKMSG)             
    MSG_ENTRY_EMPTY(0x0315)                 
    MSG_ENTRY_EMPTY(0x0316)                 
    MSG_ENTRY_STD(0x0317, WM_PRINT, IN HDC hdc, IN UINT FLAGS) 

    MSG_ENTRY_STD(0x0318, WM_PRINTCLIENT, IN HDC hdc, IN UINT Flags)                    
    MSG_ENTRY_EMPTY(0x0319)                               
    MSG_ENTRY_EMPTY(0x031A)                 
    MSG_ENTRY_EMPTY(0x031B)                 
    MSG_ENTRY_EMPTY(0x031C)                 
    MSG_ENTRY_EMPTY(0x031D)                 
    MSG_ENTRY_EMPTY(0x031E)                 
    MSG_ENTRY_EMPTY(0x031F)                 

    MSG_ENTRY_EMPTY(0x0320)                               
    MSG_ENTRY_EMPTY(0x0321)                 
    MSG_ENTRY_EMPTY(0x0322)                 
    MSG_ENTRY_EMPTY(0x0323)                 
    MSG_ENTRY_EMPTY(0x0324)                 
    MSG_ENTRY_EMPTY(0x0325)                 
    MSG_ENTRY_EMPTY(0x0326)                 
    MSG_ENTRY_EMPTY(0x0327)                 

    MSG_ENTRY_EMPTY(0x0328)                               
    MSG_ENTRY_EMPTY(0x0329)                 
    MSG_ENTRY_EMPTY(0x032A)                 
    MSG_ENTRY_EMPTY(0x032B)                
    MSG_ENTRY_EMPTY(0x032C)                 
    MSG_ENTRY_EMPTY(0x032D)                 
    MSG_ENTRY_EMPTY(0x032E)                 
    MSG_ENTRY_EMPTY(0x032F)                 

    MSG_ENTRY_EMPTY(0x0330)                               
    MSG_ENTRY_EMPTY(0x0331)                 
    MSG_ENTRY_EMPTY(0x0332)
    MSG_ENTRY_EMPTY(0x0333)                 
    MSG_ENTRY_EMPTY(0x0334)                 
    MSG_ENTRY_EMPTY(0x0335)                 
    MSG_ENTRY_EMPTY(0x0336)                 
    MSG_ENTRY_EMPTY(0x0337)                 

    MSG_ENTRY_EMPTY(0x0338)                               
    MSG_ENTRY_EMPTY(0x0339)                 
    MSG_ENTRY_EMPTY(0x033A)                 
    MSG_ENTRY_EMPTY(0x033B)                 
    MSG_ENTRY_EMPTY(0x033C)                 
    MSG_ENTRY_EMPTY(0x033D)                 
    MSG_ENTRY_EMPTY(0x033E)                 
    MSG_ENTRY_EMPTY(0x033F)                 

    MSG_ENTRY_EMPTY(0x0340)                               
    MSG_ENTRY_EMPTY(0x0341)                 
    MSG_ENTRY_EMPTY(0x0342)                 
    MSG_ENTRY_EMPTY(0x0343)                 
    MSG_ENTRY_EMPTY(0x0344)                 
    MSG_ENTRY_EMPTY(0x0345)                 
    MSG_ENTRY_EMPTY(0x0346)                 
    MSG_ENTRY_EMPTY(0x0347)                 

    MSG_ENTRY_EMPTY(0x0348)                               
    MSG_ENTRY_EMPTY(0x0349)                 
    MSG_ENTRY_EMPTY(0x034A)                 
    MSG_ENTRY_EMPTY(0x034B)                 
    MSG_ENTRY_EMPTY(0x034C)                 
    MSG_ENTRY_EMPTY(0x034D)                 
    MSG_ENTRY_EMPTY(0x034E)                 
    MSG_ENTRY_EMPTY(0x034F)                 

    MSG_ENTRY_EMPTY(0x0350)                               
    MSG_ENTRY_EMPTY(0x0351)                 
    MSG_ENTRY_EMPTY(0x0352)                 
    MSG_ENTRY_EMPTY(0x0353)                 
    MSG_ENTRY_EMPTY(0x0354)                 
    MSG_ENTRY_EMPTY(0x0355)                 
    MSG_ENTRY_EMPTY(0x0356)                 
    MSG_ENTRY_EMPTY(0x0357)                 

    MSG_ENTRY_EMPTY(0x0358)                               
    MSG_ENTRY_EMPTY(0x0359)                 
    MSG_ENTRY_EMPTY(0x035A)                 
    MSG_ENTRY_EMPTY(0x035B)                 
    MSG_ENTRY_EMPTY(0x035C)                 
    MSG_ENTRY_EMPTY(0x035D)                 
    MSG_ENTRY_EMPTY(0x035E)                 
    MSG_ENTRY_EMPTY(0x035F)                 

    MSG_ENTRY_EMPTY(0x0360)                               
    MSG_ENTRY_EMPTY(0x0361)                 
    MSG_ENTRY_EMPTY(0x0362)                 
    MSG_ENTRY_EMPTY(0x0363)                 
    MSG_ENTRY_EMPTY(0x0364)                 
    MSG_ENTRY_EMPTY(0x0365)                 
    MSG_ENTRY_EMPTY(0x0366)                 
    MSG_ENTRY_EMPTY(0x0367)                 

    MSG_ENTRY_EMPTY(0x0368)                               
    MSG_ENTRY_EMPTY(0x0369)                 
    MSG_ENTRY_EMPTY(0x036A)                 
    MSG_ENTRY_EMPTY(0x036B)                 
    MSG_ENTRY_EMPTY(0x036C)                 
    MSG_ENTRY_EMPTY(0x036D)                 
    MSG_ENTRY_EMPTY(0x036E)                 
    MSG_ENTRY_EMPTY(0x036F)                 

    MSG_ENTRY_EMPTY(0x0370)                               
    MSG_ENTRY_EMPTY(0x0371)                 
    MSG_ENTRY_EMPTY(0x0372)                 
    MSG_ENTRY_EMPTY(0x0373)                 
    MSG_ENTRY_EMPTY(0x0374)                 
    MSG_ENTRY_EMPTY(0x0375)                 
    MSG_ENTRY_EMPTY(0x0376)                 
    MSG_ENTRY_EMPTY(0x0377)                 

    MSG_ENTRY_EMPTY(0x0378)                               
    MSG_ENTRY_EMPTY(0x0379)                 
    MSG_ENTRY_EMPTY(0x037A)                 
    MSG_ENTRY_EMPTY(0x037B)                 
    MSG_ENTRY_EMPTY(0x037C)                 
    MSG_ENTRY_EMPTY(0x037D)                 
    MSG_ENTRY_EMPTY(0x037E)                 
    MSG_ENTRY_EMPTY(0x037F)                 

    MSG_ENTRY_EMPTY(0x0380)                               
    MSG_ENTRY_EMPTY(0x0381)                 
    MSG_ENTRY_EMPTY(0x0382)                 
    MSG_ENTRY_EMPTY(0x0383)                 
    MSG_ENTRY_EMPTY(0x0384)                 
    MSG_ENTRY_EMPTY(0x0385)                 
    MSG_ENTRY_EMPTY(0x0386)                 
    MSG_ENTRY_EMPTY(0x0387)                 

    MSG_ENTRY_EMPTY(0x0388)                               
    MSG_ENTRY_EMPTY(0x0389)                 
    MSG_ENTRY_EMPTY(0x038A)                 
    MSG_ENTRY_EMPTY(0x038B)                 
    MSG_ENTRY_EMPTY(0x038C)                 
    MSG_ENTRY_EMPTY(0x038D)                 
    MSG_ENTRY_EMPTY(0x038E)                 
    MSG_ENTRY_EMPTY(0x038F)                 

    MSG_ENTRY_EMPTY(0x0390)                               
    MSG_ENTRY_EMPTY(0x0391)                 
    MSG_ENTRY_EMPTY(0x0392)                 
    MSG_ENTRY_EMPTY(0x0393)                 
    MSG_ENTRY_EMPTY(0x0394)                 
    MSG_ENTRY_EMPTY(0x0395)                 
    MSG_ENTRY_EMPTY(0x0396)                 
    MSG_ENTRY_EMPTY(0x0397)                 

    MSG_ENTRY_EMPTY(0x0398)                               
    MSG_ENTRY_EMPTY(0x0399)                 
    MSG_ENTRY_EMPTY(0x039A)                 
    MSG_ENTRY_EMPTY(0x039B)                 
    MSG_ENTRY_EMPTY(0x039C)                 
    MSG_ENTRY_EMPTY(0x039D)                 
    MSG_ENTRY_EMPTY(0x039E)                 
    MSG_ENTRY_EMPTY(0x039F)                 

    MSG_ENTRY_RESERVED(0x03A0)                            // WM_MM_RESERVED_FIRST      
    MSG_ENTRY_RESERVED(0x03A1)                         
    MSG_ENTRY_RESERVED(0x03A2)                         
    MSG_ENTRY_RESERVED(0x03A3)                         
    MSG_ENTRY_RESERVED(0x03A4)                         
    MSG_ENTRY_RESERVED(0x03A5)                         
    MSG_ENTRY_RESERVED(0x03A6)                         
    MSG_ENTRY_RESERVED(0x03A7)                         

    MSG_ENTRY_RESERVED(0x03A8)                            
    MSG_ENTRY_RESERVED(0x03A9)                         
    MSG_ENTRY_RESERVED(0x03AA)                         
    MSG_ENTRY_RESERVED(0x03AB)                         
    MSG_ENTRY_RESERVED(0x03AC)                        
    MSG_ENTRY_RESERVED(0x03AD)                         
    MSG_ENTRY_RESERVED(0x03AE)                         
    MSG_ENTRY_RESERVED(0x03AF)                         

    MSG_ENTRY_RESERVED(0x03B0)                            
    MSG_ENTRY_RESERVED(0x03B1)                         
    MSG_ENTRY_RESERVED(0x03B2)                         
    MSG_ENTRY_RESERVED(0x03B3)                         
    MSG_ENTRY_RESERVED(0x03B4)                         
    MSG_ENTRY_RESERVED(0x03B5)                         
    MSG_ENTRY_RESERVED(0x03B6)                         
    MSG_ENTRY_RESERVED(0x03B7)                        

    MSG_ENTRY_RESERVED(0x03B8)                            
    MSG_ENTRY_RESERVED(0x03B9)                         
    MSG_ENTRY_RESERVED(0x03BA)                         
    MSG_ENTRY_RESERVED(0x03BB)                         
    MSG_ENTRY_RESERVED(0x03BC)                         
    MSG_ENTRY_RESERVED(0x03BD)                         
    MSG_ENTRY_RESERVED(0x03BE)                         
    MSG_ENTRY_RESERVED(0x03BF)                         

    MSG_ENTRY_RESERVED(0x03C0)                            
    MSG_ENTRY_RESERVED(0x03C1)                         
    MSG_ENTRY_RESERVED(0x03C2)                         
    MSG_ENTRY_RESERVED(0x03C3)                         
    MSG_ENTRY_RESERVED(0x03C4)                         
    MSG_ENTRY_RESERVED(0x03C5)                         
    MSG_ENTRY_RESERVED(0x03C6)                         
    MSG_ENTRY_RESERVED(0x03C7)                         

    MSG_ENTRY_RESERVED(0x03C8)                            
    MSG_ENTRY_RESERVED(0x03C9)                         
    MSG_ENTRY_RESERVED(0x03CA)                         
    MSG_ENTRY_RESERVED(0x03CB)                         
    MSG_ENTRY_RESERVED(0x03CC)                         
    MSG_ENTRY_RESERVED(0x03CD)                         
    MSG_ENTRY_RESERVED(0x03CE)                         
    MSG_ENTRY_RESERVED(0x03CF)                         

    MSG_ENTRY_RESERVED(0x03D0)                            
    MSG_ENTRY_RESERVED(0x03D1)                         
    MSG_ENTRY_RESERVED(0x03D2)                         
    MSG_ENTRY_RESERVED(0x03D3)                         
    MSG_ENTRY_RESERVED(0x03D4)                         
    MSG_ENTRY_RESERVED(0x03D5)                         
    MSG_ENTRY_RESERVED(0x03D6)                         
    MSG_ENTRY_RESERVED(0x03D7)                         

    MSG_ENTRY_RESERVED(0x03D8)                            
    MSG_ENTRY_RESERVED(0x03D9)                         
    MSG_ENTRY_RESERVED(0x03DA)                         
    MSG_ENTRY_RESERVED(0x03DB)                         
    MSG_ENTRY_RESERVED(0x03DC)                         
    MSG_ENTRY_RESERVED(0x03DD)                         
    MSG_ENTRY_RESERVED(0x03DE)                         
    MSG_ENTRY_RESERVED(0x03DF)                            // WM_MM_RESERVED_LAST      
                                                  
    MSG_ENTRY_STD(0x03E0, WM_DDE_INITIATE, IN HWND hwnd, IN LONG composite)
    MSG_ENTRY_STD(0x03E1, WM_DDE_TERMINATE, IN HWND hwnd, IN LONG composite)
    MSG_ENTRY_STD(0x03E2, WM_DDE_ADVISE, IN HWND hwnd, IN LONG_PTR hDdepack)
    MSG_ENTRY_STD(0x03E3, WM_DDE_UNADVISE, IN HWND hwnd, IN LONG composite)
    MSG_ENTRY_STD(0x03E4, WM_DDE_ACK, IN HWND hwnd, IN LONG_PTR hDdepack)
    MSG_ENTRY_STD(0x03E5, WM_DDE_DATA, IN HWND hwnd, IN LONG_PTR hDdepack)
    MSG_ENTRY_STD(0x03E6, WM_DDE_REQUEST, IN HWND hwnd, IN LONG composite)
    MSG_ENTRY_STD(0x03E7, WM_DDE_POKE, IN HWND hwnd, IN LONG_PTR hDdepack)
    MSG_ENTRY_STD(0x03E8, WM_DDE_EXECUTE, IN HWND hwnd, IN HGLOBAL hGlobal) 

    MSG_ENTRY_EMPTY(0x03E9)                               
    MSG_ENTRY_EMPTY(0x03EA)                 
    MSG_ENTRY_EMPTY(0x03EB)                 
    MSG_ENTRY_EMPTY(0x03EC)                 
    MSG_ENTRY_EMPTY(0x03ED)                 
    MSG_ENTRY_EMPTY(0x03EE)                 
    MSG_ENTRY_EMPTY(0x03EF)                 

    MSG_ENTRY_RESERVED(0x03F0)                            // WM_CBT_RESERVED_FIRST 
    MSG_ENTRY_RESERVED(0x03F1)                         
    MSG_ENTRY_RESERVED(0x03F2)                         
    MSG_ENTRY_RESERVED(0x03F3)                         
    MSG_ENTRY_RESERVED(0x03F4)                         
    MSG_ENTRY_RESERVED(0x03F5)
    MSG_ENTRY_RESERVED(0x03F6)                         
    MSG_ENTRY_RESERVED(0x03F7)                         

    MSG_ENTRY_RESERVED(0x03F8)                             
    MSG_ENTRY_RESERVED(0x03F9)                         
    MSG_ENTRY_RESERVED(0x03FA)                         
    MSG_ENTRY_RESERVED(0x03FB)                         
    MSG_ENTRY_RESERVED(0x03FC)                         
    MSG_ENTRY_RESERVED(0x03FD)                         
    MSG_ENTRY_RESERVED(0x03FE)                         
    MSG_ENTRY_RESERVED(0x03FF)                            // WM_CBT_RESERVED_LAST  

MSG_TABLE_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\makefile.inc ===
#
# makefile.inc for keyboard layouts
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdfr\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_windows.ini ddk $(PROJECT_ROOT)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\sources.inc ===
#****************************** File Header ******************************\
# File Name: sources.inc for KBDs
#
# Copyright (c) 1985-2000, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

INCLUDES=..\..\inc

C_DEFINES=
UMTYPE=nt
UMTEST=
UMAPPL=
UMBASE=0x1000000
UMLIBS=
TARGETLIBS=
DLLDEF=$(TARGETNAME).def

!if $(IA64)
SECTION_ALIGNMENT=0x4000
NO_READONLY_STRINGS=1
!endif
LINKER_FLAGS = -merge:.edata=.data -merge:.rdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re

TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

SOURCES=$(TARGETNAME).c $(TARGETNAME).rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdgr\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdfr\kbdfr.c ===
/***************************************************************************\
* Module Name: KBDFR.C
*
* keyboard layout for French
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
* KBDTOOL v3.11 - Created  Thu Aug 24 18:10:18 2000
\***************************************************************************/

#include <windows.h>
#include "kbd.h"
#include "kbdFR.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for French
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot

    T38, T39, T3A, T3B, T3C, T3D, T3E,
    T3F, T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* French Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/
static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT    ,   KBDSHIFT     },
    { VK_CONTROL  ,   KBDCTRL      },
    { VK_MENU     ,   KBDALT       },
    { 0           ,   0           }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    6,
    {
    //  Modification# //  Keys Pressed
    //  ============= // =============
        0,            // 
        1,            // Shift 
        2,            // Control 
        4,            // Shift + Control 
        SHFT_INVALID, // Menu 
        SHFT_INVALID, // Shift + Menu 
        3             // Control + Menu 
     }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch5[]  - Virtual Key to WCHAR translation for 5 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Special values for VirtualKey (column 1)
*     0xff          - dead chars for the previous entry
*     0             - terminate the list
*
* Special values for Attributes (column 2)
*     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT
*
* Special values for wch[*] (column 3 & 4)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)
*     WCH_LGTR      - Ligature (generates multiple characters)
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
//                      |         |  Shift  |
//                      |=========|=========|
  {VK_OEM_7     ,0      ,0x00b2   ,WCH_NONE },
  {'1'          ,CAPLOK ,'&'      ,'1'      },
  {'A'          ,CAPLOK ,'a'      ,'A'      },
  {'Z'          ,CAPLOK ,'z'      ,'Z'      },
  {'R'          ,CAPLOK ,'r'      ,'R'      },
  {'T'          ,CAPLOK ,'t'      ,'T'      },
  {'Y'          ,CAPLOK ,'y'      ,'Y'      },
  {'U'          ,CAPLOK ,'u'      ,'U'      },
  {'I'          ,CAPLOK ,'i'      ,'I'      },
  {'O'          ,CAPLOK ,'o'      ,'O'      },
  {'P'          ,CAPLOK ,'p'      ,'P'      },
  {'Q'          ,CAPLOK ,'q'      ,'Q'      },
  {'S'          ,CAPLOK ,'s'      ,'S'      },
  {'D'          ,CAPLOK ,'d'      ,'D'      },
  {'F'          ,CAPLOK ,'f'      ,'F'      },
  {'G'          ,CAPLOK ,'g'      ,'G'      },
  {'H'          ,CAPLOK ,'h'      ,'H'      },
  {'J'          ,CAPLOK ,'j'      ,'J'      },
  {'K'          ,CAPLOK ,'k'      ,'K'      },
  {'L'          ,CAPLOK ,'l'      ,'L'      },
  {'M'          ,CAPLOK ,'m'      ,'M'      },
  {VK_OEM_3     ,CAPLOK ,0x00f9   ,'%'      },
  {'W'          ,CAPLOK ,'w'      ,'W'      },
  {'X'          ,CAPLOK ,'x'      ,'X'      },
  {'C'          ,CAPLOK ,'c'      ,'C'      },
  {'V'          ,CAPLOK ,'v'      ,'V'      },
  {'B'          ,CAPLOK ,'b'      ,'B'      },
  {'N'          ,CAPLOK ,'n'      ,'N'      },
  {VK_OEM_COMMA ,CAPLOK ,','      ,'?'      },
  {VK_OEM_PERIOD,CAPLOK ,';'      ,'.'      },
  {VK_OEM_2     ,CAPLOK ,':'      ,'/'      },
  {VK_OEM_8     ,CAPLOK ,'!'      ,0x00a7   },
  {VK_DECIMAL   ,0      ,'.'      ,'.'      },
  {VK_TAB       ,0      ,'\t'     ,'\t'     },
  {VK_ADD       ,0      ,'+'      ,'+'      },
  {VK_DIVIDE    ,0      ,'/'      ,'/'      },
  {VK_MULTIPLY  ,0      ,'*'      ,'*'      },
  {VK_SUBTRACT  ,0      ,'-'      ,'-'      },
  {0            ,0      ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
//                      |         |  Shift  |  Ctrl   |
//                      |=========|=========|=========|
  {VK_OEM_6     ,CAPLOK ,WCH_DEAD ,WCH_DEAD ,0x001b   },
  {0xff         ,0      ,'^'      ,0x00a8   ,WCH_NONE },
  {VK_OEM_5     ,CAPLOK ,'*'      ,0x00b5   ,0x001c   },
  {VK_OEM_102   ,0      ,'<'      ,'>'      ,0x001c   },
  {VK_BACK      ,0      ,'\b'     ,'\b'     ,0x007f   },
  {VK_ESCAPE    ,0      ,0x001b   ,0x001b   ,0x001b   },
  {VK_RETURN    ,0      ,'\r'     ,'\r'     ,'\n'     },
  {VK_SPACE     ,0      ,' '      ,' '      ,' '      },
  {VK_CANCEL    ,0      ,0x0003   ,0x0003   ,0x0003   },
  {0            ,0      ,0        ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
//                      |         |  Shift  |  Ctrl   |  Ctl+Alt|
//                      |=========|=========|=========|=========|
  {'2'          ,CAPLOK ,0x00e9   ,'2'      ,WCH_NONE ,WCH_DEAD },
  {0xff         ,0      ,WCH_NONE ,WCH_NONE ,WCH_NONE ,'~'      },
  {'3'          ,CAPLOK ,'\"'     ,'3'      ,WCH_NONE ,'#'      },
  {'4'          ,CAPLOK ,'\''     ,'4'      ,WCH_NONE ,'{'      },
  {'7'          ,CAPLOK ,0x00e8   ,'7'      ,WCH_NONE ,WCH_DEAD },
  {0xff         ,0      ,WCH_NONE ,WCH_NONE ,WCH_NONE ,'`'      },
  {'0'          ,CAPLOK ,0x00e0   ,'0'      ,0x0000   ,'@'      },
  {VK_OEM_4     ,CAPLOK ,')'      ,0x00b0   ,WCH_NONE ,']'      },
  {VK_OEM_PLUS  ,CAPLOK ,'='      ,'+'      ,WCH_NONE ,'}'      },
  {'E'          ,CAPLOK ,'e'      ,'E'      ,WCH_NONE ,0x20ac   },
  {VK_OEM_1     ,CAPLOK ,'$'      ,0x00a3   ,0x001d   ,0x00a4   },
  {0            ,0      ,0        ,0        ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS5 aVkToWch5[] = {
//                      |         |  Shift  |  Ctrl   |  Ctl+Alt|S+Ctrl   |
//                      |=========|=========|=========|=========|=========|
  {'5'          ,CAPLOK ,'('      ,'5'      ,WCH_NONE ,'['      ,0x001b   },
  {'6'          ,CAPLOK ,'-'      ,'6'      ,WCH_NONE ,'|'      ,0x001f   },
  {'8'          ,CAPLOK ,'_'      ,'8'      ,WCH_NONE ,'\\'     ,0x001c   },
  {'9'          ,CAPLOK ,0x00e7   ,'9'      ,WCH_NONE ,'^'      ,0x001e   },
  {0            ,0      ,0        ,0        ,0        ,0        ,0        }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch5) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }
};

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch5, 5, sizeof(aVkToWch5[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },
    {                       NULL, 0, 0                    },
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Virtual Scancode to Key Name tables
*
* Table attributes: Ordered Scan (by scancode), null-terminated
*
* Only the names of Extended, NumPad, Dead and Non-Printable keys are here.
* (Keys producing printable characters are named by that character)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"ECHAP",
    0x0e,    L"RET.ARR",
    0x0f,    L"TAB",
    0x1c,    L"ENTREE",
    0x1d,    L"CTRL",
    0x2a,    L"MAJ",
    0x36,    L"MAJ DROITE",
    0x37,    L"* (PAVE NUM.)",
    0x38,    L"ALT",
    0x39,    L"ESPACE",
    0x3a,    L"VERR.MAJ",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"DEFIL",
    0x47,    L"7 (PAVE NUM.)",
    0x48,    L"8 (PAVE NUM.)",
    0x49,    L"9 (PAVE NUM.)",
    0x4a,    L"- (PAVE NUM.)",
    0x4b,    L"4 (PAVE NUM.)",
    0x4c,    L"5 (PAVE NUM.)",
    0x4d,    L"6 (PAVE NUM.)",
    0x4e,    L"+ (PAVE NUM.)",
    0x4f,    L"1 (PAVE NUM.)",
    0x50,    L"2 (PAVE NUM.)",
    0x51,    L"3 (PAVE NUM.)",
    0x52,    L"0 (PAVE NUM.)",
    0x53,    L". (PAVE NUM.)",
    0x57,    L"F11",
    0x58,    L"F12",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"ENTREE (PAVE NUM.)",
    0x1d,    L"CTRL DROITE",
    0x35,    L"/ (PAVE NUM.)",
    0x37,    L"Impr.Ecran",
    0x38,    L"ALT DROITE",
    0x45,    L"Ver.Num",
    0x46,    L"ATTN",
    0x47,    L"ORIGINE",
    0x48,    L"HAUT",
    0x49,    L"PG.PREC",
    0x4b,    L"GAUCHE",
    0x4d,    L"DROITE",
    0x4f,    L"FIN",
    0x50,    L"BAS",
    0x51,    L"PG.SUIV",
    0x52,    L"INS",
    0x53,    L"SUPPR",
    0x54,    L"<00>",
    0x56,    L"AIDE",
    0x5b,    L"WINDOWS GAUCHE",
    0x5c,    L"WINDOWS DROITE",
    0x5d,    L"APPLICATION",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA DEADKEY_LPWSTR aKeyNamesDead[] = {
    L"^"	L"ACCENT CIRCONFLEXE",
    L"\x00a8"	L"TREMA",
    L"~"	L"TILDE",
    L"`"	L"GRAVE",
    NULL
};

static ALLOC_SECTION_LDATA DEADKEY aDeadKey[] = {
    DEADTRANS( L'a'   , L'^'   , 0x00e2 , 0x0000),
    DEADTRANS( L'e'   , L'^'   , 0x00ea , 0x0000),
    DEADTRANS( L'i'   , L'^'   , 0x00ee , 0x0000),
    DEADTRANS( L'o'   , L'^'   , 0x00f4 , 0x0000),
    DEADTRANS( L'u'   , L'^'   , 0x00fb , 0x0000),
    DEADTRANS( L'A'   , L'^'   , 0x00c2 , 0x0000),
    DEADTRANS( L'E'   , L'^'   , 0x00ca , 0x0000),
    DEADTRANS( L'I'   , L'^'   , 0x00ce , 0x0000),
    DEADTRANS( L'O'   , L'^'   , 0x00d4 , 0x0000),
    DEADTRANS( L'U'   , L'^'   , 0x00db , 0x0000),
    DEADTRANS( L' '   , L'^'   , L'^'   , 0x0000),

    DEADTRANS( L'a'   , 0x00a8 , 0x00e4 , 0x0000),
    DEADTRANS( L'e'   , 0x00a8 , 0x00eb , 0x0000),
    DEADTRANS( L'i'   , 0x00a8 , 0x00ef , 0x0000),
    DEADTRANS( L'o'   , 0x00a8 , 0x00f6 , 0x0000),
    DEADTRANS( L'u'   , 0x00a8 , 0x00fc , 0x0000),
    DEADTRANS( L'y'   , 0x00a8 , 0x00ff , 0x0000),
    DEADTRANS( L'A'   , 0x00a8 , 0x00c4 , 0x0000),
    DEADTRANS( L'E'   , 0x00a8 , 0x00cb , 0x0000),
    DEADTRANS( L'I'   , 0x00a8 , 0x00cf , 0x0000),
    DEADTRANS( L'O'   , 0x00a8 , 0x00d6 , 0x0000),
    DEADTRANS( L'U'   , 0x00a8 , 0x00dc , 0x0000),
    DEADTRANS( L' '   , 0x00a8 , 0x00a8 , 0x0000),

    DEADTRANS( L'a'   , L'~'   , 0x00e3 , 0x0000),
    DEADTRANS( L'A'   , L'~'   , 0x00c3 , 0x0000),
    DEADTRANS( L'n'   , L'~'   , 0x00f1 , 0x0000),
    DEADTRANS( L'N'   , L'~'   , 0x00d1 , 0x0000),
    DEADTRANS( L'o'   , L'~'   , 0x00f5 , 0x0000),
    DEADTRANS( L'O'   , L'~'   , 0x00d5 , 0x0000),
    DEADTRANS( L' '   , L'~'   , L'~'   , 0x0000),

    DEADTRANS( L'a'   , L'`'   , 0x00e0 , 0x0000),
    DEADTRANS( L'e'   , L'`'   , 0x00e8 , 0x0000),
    DEADTRANS( L'i'   , L'`'   , 0x00ec , 0x0000),
    DEADTRANS( L'o'   , L'`'   , 0x00f2 , 0x0000),
    DEADTRANS( L'u'   , L'`'   , 0x00f9 , 0x0000),
    DEADTRANS( L'A'   , L'`'   , 0x00c0 , 0x0000),
    DEADTRANS( L'E'   , L'`'   , 0x00c8 , 0x0000),
    DEADTRANS( L'I'   , L'`'   , 0x00cc , 0x0000),
    DEADTRANS( L'O'   , L'`'   , 0x00d2 , 0x0000),
    DEADTRANS( L'U'   , L'`'   , 0x00d9 , 0x0000),
    DEADTRANS( L' '   , L'`'   , L'`'   , 0x0000),

    0, 0
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics
     */
    aDeadKey,

    /*
     * Names of Keys
     */
    aKeyNames,
    aKeyNamesExt,
    aKeyNamesDead,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * Locale-specific special processing
     */
    MAKELONG(KLLF_ALTGR, KBD_VERSION),

    /*
     * Ligatures
     */
    0,
    0,
    NULL
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\101\kbd101.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdfr\kbdfr.h ===
/****************************** Module Header ******************************\
* Module Name: KBDFR.H
*
* keyboard layout header for French
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
*
* created by KBDTOOL v3.11 Thu Aug 24 18:10:18 2000
*
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
* Include the basis of all keyboard table values
*/
#include "kbd.h"
/***************************************************************************\
* The table below defines the virtual keys for various keyboard types where
* the keyboard differ from the US keyboard.
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +----------+----------+----------+----------+----------+----------+
*     | Scan | |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |
*     | code | |   type 1 |   type 2 |   type 3 |   type 4 |   type 5 |   type 6 |
\****+-------+_+----------+----------+----------+----------+----------+----------+*/

#undef  T29
#define T29 _EQ(                                      OEM_7                      )
#undef  T0C
#define T0C _EQ(                                      OEM_4                      )
#undef  T10
#define T10 _EQ(                                        'A'                      )
#undef  T11
#define T11 _EQ(                                        'Z'                      )
#undef  T1A
#define T1A _EQ(                                      OEM_6                      )
#undef  T1B
#define T1B _EQ(                                      OEM_1                      )
#undef  T1E
#define T1E _EQ(                                        'Q'                      )
#undef  T27
#define T27 _EQ(                                        'M'                      )
#undef  T28
#define T28 _EQ(                                      OEM_3                      )
#undef  T2C
#define T2C _EQ(                                        'W'                      )
#undef  T32
#define T32 _EQ(                                  OEM_COMMA                      )
#undef  T33
#define T33 _EQ(                                 OEM_PERIOD                      )
#undef  T34
#define T34 _EQ(                                      OEM_2                      )
#undef  T35
#define T35 _EQ(                                      OEM_8                      )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\106\kbd106.h ===
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 8

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdgr\kbdgr.h ===
/****************************** Module Header ******************************\
* Module Name: KBDGR.H
*
* keyboard layout header for German
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
*
* created by KBDTOOL v3.11 Thu Aug 24 18:10:19 2000
*
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
* Include the basis of all keyboard table values
*/
#include "kbd.h"
/***************************************************************************\
* The table below defines the virtual keys for various keyboard types where
* the keyboard differ from the US keyboard.
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +----------+----------+----------+----------+----------+----------+
*     | Scan | |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |
*     | code | |   type 1 |   type 2 |   type 3 |   type 4 |   type 5 |   type 6 |
\****+-------+_+----------+----------+----------+----------+----------+----------+*/

#undef  T29
#define T29 _EQ(                                      OEM_5                      )
#undef  T0C
#define T0C _EQ(                                      OEM_4                      )
#undef  T0D
#define T0D _EQ(                                      OEM_6                      )
#undef  T15
#define T15 _EQ(                                        'Z'                      )
#undef  T1A
#define T1A _EQ(                                      OEM_1                      )
#undef  T1B
#define T1B _EQ(                                   OEM_PLUS                      )
#undef  T2B
#define T2B _EQ(                                      OEM_2                      )
#undef  T27
#define T27 _EQ(                                      OEM_3                      )
#undef  T2C
#define T2C _EQ(                                        'Y'                      )
#undef  T35
#define T35 _EQ(                                  OEM_MINUS                      )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\japan.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for JPN KBDs
#
# Copyright (c) 1985-2000, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

!include ..\..\fekbds.inc

C_DEFINES=$(C_DEFINES) -DJAPAN

SOURCES_USED=..\japan.inc
INCLUDES=$(INCLUDES);..\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\101\kbd101.c ===
/***************************************************************************\
* Module Name: kbd101.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include "kbdjpn.h"
#include "kbd101.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * '~' key must have KBDSPECIAL bit set. (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * CapsLock key must have KBDSPECIAL bit set. (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'`'       ,'~'       ,WCH_RO  ,WCH_RO  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_VS  ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_SVS ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_PS  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables101 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,


    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    4,      // Generic 101
    MAKEWORD(MICROSOFT_KBD_101_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables101;
}

/***********************************************************************\
* VkToFuncTable_101[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101[] = {
    {
        VK_CAPITAL,                 // Base Vk
        KBDNLS_TYPE_TOGGLE,         // NLSFEProcType
        KBDNLS_INDEX_NORMAL,        // NLSFEProcCurrent
        0x08, /* 00001000 */        // NLSFEProcSwitch
        {                           // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},        // Base
            {KBDNLS_ALPHANUM,0},            // Shift
            {KBDNLS_HIRAGANA,0},            // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_KATAKANA,0},            // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        },
        {                           // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},        // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        }
    },
    {
        VK_OEM_3,            // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0,                   // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables101 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    2,                      // Number of VK_F entry
    VkToFuncTable_101,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables101;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\fekbds.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for FE KBDs
#
# Copyright (c) 1985-2000, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/


TARGETNAME=$(MINORCOMP)
NOLINK=
MAJORCOMP=user

SOURCES_USED=..\..\fekbds.inc

!include ..\..\..\sources.inc


# Override some of the values set by sources.inc
SOURCES=$(MINORCOMP).c $(MINORCOMP).rc

C_DEFINES=$(C_DEFINES) -DFE_SB -DFE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\kbdus\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\all_kbds\kbdgr\kbdgr.c ===
/***************************************************************************\
* Module Name: KBDGR.C
*
* keyboard layout for German
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
* KBDTOOL v3.11 - Created  Thu Aug 24 18:10:19 2000
\***************************************************************************/

#include <windows.h>
#include "kbd.h"
#include "kbdGR.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for German
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot

    T38, T39, T3A, T3B, T3C, T3D, T3E,
    T3F, T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* German Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/
static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT    ,   KBDSHIFT     },
    { VK_CONTROL  ,   KBDCTRL      },
    { VK_MENU     ,   KBDALT       },
    { 0           ,   0           }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    6,
    {
    //  Modification# //  Keys Pressed
    //  ============= // =============
        0,            // 
        1,            // Shift 
        3,            // Control 
        4,            // Shift + Control 
        SHFT_INVALID, // Menu 
        SHFT_INVALID, // Shift + Menu 
        2             // Control + Menu 
     }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch5[]  - Virtual Key to WCHAR translation for 5 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Special values for VirtualKey (column 1)
*     0xff          - dead chars for the previous entry
*     0             - terminate the list
*
* Special values for Attributes (column 2)
*     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT
*
* Special values for wch[*] (column 3 & 4)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)
*     WCH_LGTR      - Ligature (generates multiple characters)
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
//                      |         |  Shift  |
//                      |=========|=========|
  {VK_OEM_5     ,0      ,WCH_DEAD ,0x00b0   },
  {0xff         ,0      ,'^'      ,WCH_NONE },
  {'1'          ,CAPLOK ,'1'      ,'!'      },
  {'4'          ,CAPLOK ,'4'      ,'$'      },
  {'5'          ,CAPLOK ,'5'      ,'%'      },
  {VK_OEM_6     ,0      ,WCH_DEAD ,WCH_DEAD },
  {0xff         ,0      ,0x00b4   ,'`'      },
  {'W'          ,CAPLOK ,'w'      ,'W'      },
  {'R'          ,CAPLOK ,'r'      ,'R'      },
  {'T'          ,CAPLOK ,'t'      ,'T'      },
  {'Z'          ,CAPLOK ,'z'      ,'Z'      },
  {'U'          ,CAPLOK ,'u'      ,'U'      },
  {'I'          ,CAPLOK ,'i'      ,'I'      },
  {'O'          ,CAPLOK ,'o'      ,'O'      },
  {'P'          ,CAPLOK ,'p'      ,'P'      },
  {'A'          ,CAPLOK ,'a'      ,'A'      },
  {'S'          ,CAPLOK ,'s'      ,'S'      },
  {'D'          ,CAPLOK ,'d'      ,'D'      },
  {'F'          ,CAPLOK ,'f'      ,'F'      },
  {'G'          ,CAPLOK ,'g'      ,'G'      },
  {'H'          ,CAPLOK ,'h'      ,'H'      },
  {'J'          ,CAPLOK ,'j'      ,'J'      },
  {'K'          ,CAPLOK ,'k'      ,'K'      },
  {'L'          ,CAPLOK ,'l'      ,'L'      },
  {VK_OEM_3     ,CAPLOK ,0x00f6   ,0x00d6   },
  {VK_OEM_7     ,CAPLOK ,0x00e4   ,0x00c4   },
  {'Y'          ,CAPLOK ,'y'      ,'Y'      },
  {'X'          ,CAPLOK ,'x'      ,'X'      },
  {'C'          ,CAPLOK ,'c'      ,'C'      },
  {'V'          ,CAPLOK ,'v'      ,'V'      },
  {'B'          ,CAPLOK ,'b'      ,'B'      },
  {'N'          ,CAPLOK ,'n'      ,'N'      },
  {VK_OEM_COMMA ,CAPLOK ,','      ,';'      },
  {VK_OEM_PERIOD,CAPLOK ,'.'      ,':'      },
  {VK_DECIMAL   ,0      ,','      ,','      },
  {VK_TAB       ,0      ,'\t'     ,'\t'     },
  {VK_ADD       ,0      ,'+'      ,'+'      },
  {VK_DIVIDE    ,0      ,'/'      ,'/'      },
  {VK_MULTIPLY  ,0      ,'*'      ,'*'      },
  {VK_SUBTRACT  ,0      ,'-'      ,'-'      },
  {0            ,0      ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
//                      |         |  Shift  |  Ctl+Alt|
//                      |=========|=========|=========|
  {'3'          ,CAPLOK ,'3'      ,0x00a7   ,0x00b3   },
  {'7'          ,CAPLOK ,'7'      ,'/'      ,'{'      },
  {'8'          ,CAPLOK ,'8'      ,'('      ,'['      },
  {'9'          ,CAPLOK ,'9'      ,')'      ,']'      },
  {'0'          ,CAPLOK ,'0'      ,'='      ,'}'      },
  {VK_OEM_4     ,CAPLOK ,0x00df   ,'?'      ,'\\'     },
  {'Q'          ,CAPLOK ,'q'      ,'Q'      ,'@'      },
  {'E'          ,CAPLOK ,'e'      ,'E'      ,0x20ac   },
  {'M'          ,CAPLOK ,'m'      ,'M'      ,0x00b5   },
  {VK_OEM_102   ,0      ,'<'      ,'>'      ,'|'      },
  {0            ,0      ,0        ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
//                      |         |  Shift  |  Ctl+Alt|  Ctrl   |
//                      |=========|=========|=========|=========|
  {VK_OEM_1     ,CAPLOK ,0x00fc   ,0x00dc   ,WCH_NONE ,0x001b   },
  {VK_OEM_PLUS  ,CAPLOK ,'+'      ,'*'      ,'~'      ,0x001d   },
  {VK_OEM_2     ,CAPLOK ,'#'      ,'\''     ,WCH_NONE ,0x001c   },
  {VK_BACK      ,0      ,'\b'     ,'\b'     ,WCH_NONE ,0x007f   },
  {VK_ESCAPE    ,0      ,0x001b   ,0x001b   ,WCH_NONE ,0x001b   },
  {VK_RETURN    ,0      ,'\r'     ,'\r'     ,WCH_NONE ,'\n'     },
  {VK_SPACE     ,0      ,' '      ,' '      ,WCH_NONE ,' '      },
  {VK_CANCEL    ,0      ,0x0003   ,0x0003   ,WCH_NONE ,0x0003   },
  {0            ,0      ,0        ,0        ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS5 aVkToWch5[] = {
//                      |         |  Shift  |  Ctl+Alt|  Ctrl   |S+Ctrl   |
//                      |=========|=========|=========|=========|=========|
  {'2'          ,CAPLOK ,'2'      ,'\"'     ,0x00b2   ,WCH_NONE ,0x0000   },
  {'6'          ,CAPLOK ,'6'      ,'&'      ,WCH_NONE ,WCH_NONE ,0x001e   },
  {VK_OEM_MINUS ,0      ,'-'      ,'_'      ,WCH_NONE ,WCH_NONE ,0x001f   },
  {0            ,0      ,0        ,0        ,0        ,0        ,0        }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch5) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }
};

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch5, 5, sizeof(aVkToWch5[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },
    {                       NULL, 0, 0                    },
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Virtual Scancode to Key Name tables
*
* Table attributes: Ordered Scan (by scancode), null-terminated
*
* Only the names of Extended, NumPad, Dead and Non-Printable keys are here.
* (Keys producing printable characters are named by that character)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"ESC",
    0x0e,    L"R\x00DC" L"CK",
    0x0f,    L"TABULATOR",
    0x1c,    L"EINGABE",
    0x1d,    L"STRG",
    0x2a,    L"UMSCHALT",
    0x36,    L"UMSCHALT RECHTS",
    0x37,    L" (ZEHNERTASTATUR)",
    0x38,    L"ALT",
    0x39,    L"LEER",
    0x3a,    L"FESTSTELL",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"PAUSE",
    0x46,    L"ROLLEN-FESTSTELL",
    0x47,    L"7 (ZEHNERTASTATUR)",
    0x48,    L"8 (ZEHNERTASTATUR)",
    0x49,    L"9 (ZEHNERTASTATUR)",
    0x4a,    L"- (ZEHNERTASTATUR)",
    0x4b,    L"4 (ZEHNERTASTATUR)",
    0x4c,    L"5 (ZEHNERTASTATUR)",
    0x4d,    L"6 (ZEHNERTASTATUR)",
    0x4e,    L"+ (ZEHNERTASTATUR)",
    0x4f,    L"1 (ZEHNERTASTATUR)",
    0x50,    L"2 (ZEHNERTASTATUR)",
    0x51,    L"3 (ZEHNERTASTATUR)",
    0x52,    L"0 (ZEHNERTASTATUR)",
    0x53,    L"KOMMA (ZEHNERTASTATUR)",
    0x57,    L"F11",
    0x58,    L"F12",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"EINGABE (ZEHNERTASTATUR)",
    0x1d,    L"STRG-RECHTS",
    0x35,    L" (ZEHNERTASTATUR)",
    0x37,    L"DRUCK",
    0x38,    L"ALT GR",
    0x45,    L"NUM-FESTSTELL",
    0x46,    L"UNTBR",
    0x47,    L"POS1",
    0x48,    L"NACH-OBEN",
    0x49,    L"BILD-NACH-OBEN",
    0x4b,    L"NACH-LINKS",
    0x4d,    L"NACH-RECHTS",
    0x4f,    L"ENDE",
    0x50,    L"NACH-UNTEN",
    0x51,    L"BILD-NACH-UNTEN",
    0x52,    L"EINFG",
    0x53,    L"ENTF",
    0x54,    L"<00>",
    0x56,    L"HILFE",
    0x5b,    L"LINKE WINDOWS",
    0x5c,    L"RECHTE WINDOWS",
    0x5d,    L"ANWENDUNG",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA DEADKEY_LPWSTR aKeyNamesDead[] = {
    L"\x00b4"	L"AKUT",
    L"`"	L"GRAVIS",
    L"^"	L"ZIRKUMFLEX",
    NULL
};

static ALLOC_SECTION_LDATA DEADKEY aDeadKey[] = {
    DEADTRANS( L'a'   , L'^'   , 0x00e2 , 0x0000),
    DEADTRANS( L'e'   , L'^'   , 0x00ea , 0x0000),
    DEADTRANS( L'i'   , L'^'   , 0x00ee , 0x0000),
    DEADTRANS( L'o'   , L'^'   , 0x00f4 , 0x0000),
    DEADTRANS( L'u'   , L'^'   , 0x00fb , 0x0000),
    DEADTRANS( L'A'   , L'^'   , 0x00c2 , 0x0000),
    DEADTRANS( L'E'   , L'^'   , 0x00ca , 0x0000),
    DEADTRANS( L'I'   , L'^'   , 0x00ce , 0x0000),
    DEADTRANS( L'O'   , L'^'   , 0x00d4 , 0x0000),
    DEADTRANS( L'U'   , L'^'   , 0x00db , 0x0000),
    DEADTRANS( L' '   , L'^'   , L'^'   , 0x0000),

    DEADTRANS( L'a'   , 0x00b4 , 0x00e1 , 0x0000),
    DEADTRANS( L'e'   , 0x00b4 , 0x00e9 , 0x0000),
    DEADTRANS( L'i'   , 0x00b4 , 0x00ed , 0x0000),
    DEADTRANS( L'o'   , 0x00b4 , 0x00f3 , 0x0000),
    DEADTRANS( L'u'   , 0x00b4 , 0x00fa , 0x0000),
    DEADTRANS( L'y'   , 0x00b4 , 0x00fd , 0x0000),
    DEADTRANS( L'A'   , 0x00b4 , 0x00c1 , 0x0000),
    DEADTRANS( L'E'   , 0x00b4 , 0x00c9 , 0x0000),
    DEADTRANS( L'I'   , 0x00b4 , 0x00cd , 0x0000),
    DEADTRANS( L'O'   , 0x00b4 , 0x00d3 , 0x0000),
    DEADTRANS( L'U'   , 0x00b4 , 0x00da , 0x0000),
    DEADTRANS( L'Y'   , 0x00b4 , 0x00dd , 0x0000),
    DEADTRANS( L' '   , 0x00b4 , 0x00b4 , 0x0000),

    DEADTRANS( L'a'   , L'`'   , 0x00e0 , 0x0000),
    DEADTRANS( L'e'   , L'`'   , 0x00e8 , 0x0000),
    DEADTRANS( L'i'   , L'`'   , 0x00ec , 0x0000),
    DEADTRANS( L'o'   , L'`'   , 0x00f2 , 0x0000),
    DEADTRANS( L'u'   , L'`'   , 0x00f9 , 0x0000),
    DEADTRANS( L'A'   , L'`'   , 0x00c0 , 0x0000),
    DEADTRANS( L'E'   , L'`'   , 0x00c8 , 0x0000),
    DEADTRANS( L'I'   , L'`'   , 0x00cc , 0x0000),
    DEADTRANS( L'O'   , L'`'   , 0x00d2 , 0x0000),
    DEADTRANS( L'U'   , L'`'   , 0x00d9 , 0x0000),
    DEADTRANS( L' '   , L'`'   , L'`'   , 0x0000),

    0, 0
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics
     */
    aDeadKey,

    /*
     * Names of Keys
     */
    aKeyNames,
    aKeyNamesExt,
    aKeyNamesDead,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * Locale-specific special processing
     */
    MAKELONG(KLLF_ALTGR, KBD_VERSION),

    /*
     * Ligatures
     */
    0,
    0,
    NULL
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\kbdus\kbdus.h ===
/****************************** Module Header ******************************\
* Module Name: KBDUS.H
*
* keyboard layout header for United States
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
*
* created by KBDTOOL v3.11 Thu Aug 24 18:10:11 2000
*
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
* Include the basis of all keyboard table values
*/
#include "kbd.h"
/***************************************************************************\
* The table below defines the virtual keys for various keyboard types where
* the keyboard differ from the US keyboard.
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +----------+----------+----------+----------+----------+----------+
*     | Scan | |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |
*     | code | |   type 1 |   type 2 |   type 3 |   type 4 |   type 5 |   type 6 |
\****+-------+_+----------+----------+----------+----------+----------+----------+*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\kbdus\kbdus.c ===
/***************************************************************************\
* Module Name: KBDUS.C
*
* keyboard layout for United States
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
* KBDTOOL v3.11 - Created  Thu Aug 24 18:10:11 2000
\***************************************************************************/

#include <windows.h>
#include "kbd.h"
#include "kbdUS.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for United States
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot

    T38, T39, T3A, T3B, T3C, T3D, T3E,
    T3F, T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* United States Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/
static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT    ,   KBDSHIFT     },
    { VK_CONTROL  ,   KBDCTRL      },
    { VK_MENU     ,   KBDALT       },
    { 0           ,   0           }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed
    //  ============= // =============
        0,            // 
        1,            // Shift 
        2,            // Control 
        3             // Shift + Control 
     }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Special values for VirtualKey (column 1)
*     0xff          - dead chars for the previous entry
*     0             - terminate the list
*
* Special values for Attributes (column 2)
*     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT
*
* Special values for wch[*] (column 3 & 4)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)
*     WCH_LGTR      - Ligature (generates multiple characters)
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
//                      |         |  Shift  |
//                      |=========|=========|
  {VK_OEM_3     ,0      ,'`'      ,'~'      },
  {'1'          ,0      ,'1'      ,'!'      },
  {'3'          ,0      ,'3'      ,'#'      },
  {'4'          ,0      ,'4'      ,'$'      },
  {'5'          ,0      ,'5'      ,'%'      },
  {'7'          ,0      ,'7'      ,'&'      },
  {'8'          ,0      ,'8'      ,'*'      },
  {'9'          ,0      ,'9'      ,'('      },
  {'0'          ,0      ,'0'      ,')'      },
  {VK_OEM_PLUS  ,0      ,'='      ,'+'      },
  {'Q'          ,CAPLOK ,'q'      ,'Q'      },
  {'W'          ,CAPLOK ,'w'      ,'W'      },
  {'E'          ,CAPLOK ,'e'      ,'E'      },
  {'R'          ,CAPLOK ,'r'      ,'R'      },
  {'T'          ,CAPLOK ,'t'      ,'T'      },
  {'Y'          ,CAPLOK ,'y'      ,'Y'      },
  {'U'          ,CAPLOK ,'u'      ,'U'      },
  {'I'          ,CAPLOK ,'i'      ,'I'      },
  {'O'          ,CAPLOK ,'o'      ,'O'      },
  {'P'          ,CAPLOK ,'p'      ,'P'      },
  {'A'          ,CAPLOK ,'a'      ,'A'      },
  {'S'          ,CAPLOK ,'s'      ,'S'      },
  {'D'          ,CAPLOK ,'d'      ,'D'      },
  {'F'          ,CAPLOK ,'f'      ,'F'      },
  {'G'          ,CAPLOK ,'g'      ,'G'      },
  {'H'          ,CAPLOK ,'h'      ,'H'      },
  {'J'          ,CAPLOK ,'j'      ,'J'      },
  {'K'          ,CAPLOK ,'k'      ,'K'      },
  {'L'          ,CAPLOK ,'l'      ,'L'      },
  {VK_OEM_1     ,0      ,';'      ,':'      },
  {VK_OEM_7     ,0      ,'\''     ,'\"'     },
  {'Z'          ,CAPLOK ,'z'      ,'Z'      },
  {'X'          ,CAPLOK ,'x'      ,'X'      },
  {'C'          ,CAPLOK ,'c'      ,'C'      },
  {'V'          ,CAPLOK ,'v'      ,'V'      },
  {'B'          ,CAPLOK ,'b'      ,'B'      },
  {'N'          ,CAPLOK ,'n'      ,'N'      },
  {'M'          ,CAPLOK ,'m'      ,'M'      },
  {VK_OEM_COMMA ,0      ,','      ,'<'      },
  {VK_OEM_PERIOD,0      ,'.'      ,'>'      },
  {VK_OEM_2     ,0      ,'/'      ,'?'      },
  {VK_DECIMAL   ,0      ,'.'      ,'.'      },
  {VK_TAB       ,0      ,'\t'     ,'\t'     },
  {VK_ADD       ,0      ,'+'      ,'+'      },
  {VK_DIVIDE    ,0      ,'/'      ,'/'      },
  {VK_MULTIPLY  ,0      ,'*'      ,'*'      },
  {VK_SUBTRACT  ,0      ,'-'      ,'-'      },
  {0            ,0      ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
//                      |         |  Shift  |  Ctrl   |
//                      |=========|=========|=========|
  {VK_OEM_4     ,0      ,'['      ,'{'      ,0x001b   },
  {VK_OEM_6     ,0      ,']'      ,'}'      ,0x001d   },
  {VK_OEM_5     ,0      ,'\\'     ,'|'      ,0x001c   },
  {VK_OEM_102   ,0      ,'\\'     ,'|'      ,0x001c   },
  {VK_BACK      ,0      ,'\b'     ,'\b'     ,0x007f   },
  {VK_ESCAPE    ,0      ,0x001b   ,0x001b   ,0x001b   },
  {VK_RETURN    ,0      ,'\r'     ,'\r'     ,'\n'     },
  {VK_SPACE     ,0      ,' '      ,' '      ,' '      },
  {VK_CANCEL    ,0      ,0x0003   ,0x0003   ,0x0003   },
  {0            ,0      ,0        ,0        ,0        }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
//                      |         |  Shift  |  Ctrl   |S+Ctrl   |
//                      |=========|=========|=========|=========|
  {'2'          ,0      ,'2'      ,'@'      ,WCH_NONE ,0x0000   },
  {'6'          ,0      ,'6'      ,'^'      ,WCH_NONE ,0x001e   },
  {VK_OEM_MINUS ,0      ,'-'      ,'_'      ,WCH_NONE ,0x001f   },
  {0            ,0      ,0        ,0        ,0        ,0        }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch5) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }
};

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },
    {                       NULL, 0, 0                    },
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Virtual Scancode to Key Name tables
*
* Table attributes: Ordered Scan (by scancode), null-terminated
*
* Only the names of Extended, NumPad, Dead and Non-Printable keys are here.
* (Keys producing printable characters are named by that character)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7c,    L"F13",
    0x7d,    L"F14",
    0x7e,    L"F15",
    0x7f,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Ctrl",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x54,    L"<00>",
    0x56,    L"Help",
    0x5b,    L"Left Windows",
    0x5c,    L"Right Windows",
    0x5d,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics
     */
    NULL,

    /*
     * Names of Keys
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * Locale-specific special processing
     */
    MAKELONG(0, KBD_VERSION),

    /*
     * Ligatures
     */
    0,
    0,
    NULL
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\106\kbd106.c ===
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

//@@BEGIN_DDKSPLIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//@@END_DDKSPLIT
#include <windows.h>
#include "kbdjpn.h"
#include "kbd106.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables106 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    7,      // Japanese Keyboard Layout
    MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables106;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables106 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

//@@BEGIN_DDKSPLIT
static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTablesNEC98 = {
    0x0d,                   // OEM ID (0x0d = NEC)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};
//@@END_DDKSPLIT

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
//@@BEGIN_DDKSPLIT
    if (!IsNEC_98) {
//@@END_DDKSPLIT
        return &KbdNlsTables106;
//@@BEGIN_DDKSPLIT
    } else {
        return &KbdNlsTablesNEC98;
    }
//@@END_DDKSPLIT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\ddk\src\input\layout\fe_kbds\jpn\inc\kbdjpn.h ===
/****************************** Module Header ******************************\
* Module Name: kbdjpn.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
/*
 * Katakana Unicode
 */
enum _KATAKANA_UNICODE {
    WCH_IP=0xff61, // Ideographic Period
    WCH_OB,        // Opening Corner Bracket
    WCH_CB,        // Closing Corner Bracket
    WCH_IC,        // Ideographic Comma
    WCH_MD,        // Katakana Middle Dot
    WCH_WO,        // Katakana Letter WO
    WCH_AA,        // Katakana Letter Small A
    WCH_II,        // Katakana Letter Small I
    WCH_UU,        // Katakana Letter Small U
    WCH_EE,        // Katakana Letter Small E
    WCH_OO,        // Katakana Letter Small O
    WCH_YAA,       // Katakana Letter Small YA
    WCH_YUU,       // Katakana Letter Small YU
    WCH_YOO,       // Katakana Letter Small YO
    WCH_TUU,       // Katakana Letter Small TU
    WCH_PS,        // Katakana Prolonged Sound Mark
    WCH_A,         // Katakana Letter A
    WCH_I,         // Katakana Letter I
    WCH_U,         // Katakana Letter U
    WCH_E,         // Katakana Letter E
    WCH_O,         // Katakana Letter O
    WCH_KA,        // Katakana Letter KA
    WCH_KI,        // Katakana Letter KI
    WCH_KU,        // Katakana Letter KU
    WCH_KE,        // Katakana Letter KE
    WCH_KO,        // Katakana Letter KO
    WCH_SA,        // Katakana Letter SA
    WCH_SI,        // Katakana Letter SI
    WCH_SU,        // Katakana Letter SU
    WCH_SE,        // Katakana Letter SE
    WCH_SO,        // Katakana Letter SO
    WCH_TA,        // Katakana Letter TA
    WCH_TI,        // Katakana Letter TI
    WCH_TU,        // Katakana Letter TU
    WCH_TE,        // Katakana Letter TE
    WCH_TO,        // Katakana Letter TO
    WCH_NA,        // Katakana Letter NA
    WCH_NI,        // Kanakana Letter NI
    WCH_NU,        // Katakana Letter NU
    WCH_NE,        // Katakana Letter NE
    WCH_NO,        // Katakana Letter NO
    WCH_HA,        // Katakana Letter HA
    WCH_HI,        // Katakana Letter HI
    WCH_HU,        // Katakana Letter HU
    WCH_HE,        // Katakana Letter HE
    WCH_HO,        // Katakana Letter HO
    WCH_MA,        // Katakana Letter MA
    WCH_MI,        // Katakana Letter MI
    WCH_MU,        // Katakana Letter MU
    WCH_ME,        // Katakana Letter ME
    WCH_MO,        // Katakana Letter MO
    WCH_YA,        // Katakana Letter YA
    WCH_YU,        // Katakana Letter YU
    WCH_YO,        // Katakana Letter YO
    WCH_RA,        // Katakana Letter RA
    WCH_RI,        // Katakana Letter RI
    WCH_RU,        // Katakana Letter RU
    WCH_RE,        // Katakana Letter RE
    WCH_RO,        // Katakana Letter RO
    WCH_WA,        // Katakana Letter WA
    WCH_NN,        // Katakana Letter N
    WCH_VS,        // Katakana Voiced Sound Mark
    WCH_SVS        // Katakana Semi-Voiced Sound Mark
};

/***************************************************************************\
* OEM Key Name -
\***************************************************************************/

                                    // lo  hi  lo  hi
#define SZ_KEY_NAME_HENKAN          "\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_MUHENKAN        "\x21\x71\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_KANJI           "\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_EISU_KANA       "\xf1\x82\x70\x65\x20\000\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HANKAKU_ZENKAKU "\x4a\x53\xd2\x89\x2f\000\x68\x51\xd2\x89\000\000"
#define SZ_KEY_NAME_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HIRAGANA        "\x72\x30\x89\x30\x4c\x30\x6a\x30\000\000"
// FMR Jul.13.1994 KA
// For the GetKeyNameText() API function.
#define SZ_KEY_NAME_BACKSPACE       "\x8C\x5F\x00\x90\000\000"
#define SZ_KEY_NAME_ENTER           "\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_NUMPADENTER     "\x4E\x00\x75\x00\x6d\x00\x20\x00\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_SPACE           "\x7A\x7A\x7D\x76\000\000"
#define SZ_KEY_NAME_INSERT          "\x3F\x63\x65\x51\000\000"
#define SZ_KEY_NAME_DELETE          "\x4A\x52\x64\x96\000\000"
#define SZ_KEY_NAME_KANAKANJI       "\x4b\x30\x6a\x30\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_SHIFTLEFT       "\xB7\x30\xD5\x30\xC8\x30\xE6\x5D\000\000"
#define SZ_KEY_NAME_SHIFTRIGHT      "\xB7\x30\xD5\x30\xC8\x30\xF3\x53\000\000"
#define SZ_KEY_NAME_EIJI            "\xF1\x82\x57\x5B\000\000"
#define SZ_KEY_NAME_JISHO           "\x58\x53\x9E\x8A\x9E\x8F\xF8\x66\000\000"
#define SZ_KEY_NAME_MASSHOU         "\x58\x53\x9E\x8A\xB9\x62\x88\x6D\000\000"
#define SZ_KEY_NAME_TOUROKU         "\x58\x53\x9E\x8A\x7B\x76\x32\x93\000\000"
#define SZ_KEY_NAME_PRIOR           "\x4D\x52\x4C\x88\000\000"
#define SZ_KEY_NAME_NEXT            "\x21\x6B\x4C\x88\000\000"
#define SZ_KEY_NAME_CANCEL          "\xD6\x53\x88\x6D\000\000"
#define SZ_KEY_NAME_EXECUTE         "\x9F\x5B\x4C\x88\000\000"
#define SZ_KEY_NAME_TAB             "\xBF\x30\xD6\x30\000\000"


//----------------------[ NEC Code Original Start ]-----------------
                    // ff76(ka) ff85(na) for Unicode
#define SZ_KEY_NAME_KANA        "\x76\xff\x85\xff"
#define SZ_KEY_NAME_F1          "\x66\x00\x65\xff\x31\x00"
#define SZ_KEY_NAME_F2          "\x66\x00\x65\xff\x32\x00"
#define SZ_KEY_NAME_F3          "\x66\x00\x65\xff\x33\x00"
#define SZ_KEY_NAME_F4          "\x66\x00\x65\xff\x34\x00"
#define SZ_KEY_NAME_F5          "\x66\x00\x65\xff\x35\x00"
#define SZ_KEY_NAME_F6          "\x66\x00\x65\xff\x36\x00"
#define SZ_KEY_NAME_F7          "\x66\x00\x65\xff\x37\x00"
#define SZ_KEY_NAME_F8          "\x66\x00\x65\xff\x38\x00"
#define SZ_KEY_NAME_F9          "\x66\x00\x65\xff\x39\x00"
#define SZ_KEY_NAME_F10         "\x66\x00\x65\xff\x31\x00\x30\x00"
#define SZ_KEY_NAME_F11         "\x66\x00\x65\xff\x31\x00\x31\x00"
#define SZ_KEY_NAME_F12         "\x66\x00\x65\xff\x31\x00\x32\x00"
#define SZ_KEY_NAME_F13         "\x66\x00\x65\xff\x31\x00\x33\x00"
#define SZ_KEY_NAME_F14         "\x66\x00\x65\xff\x31\x00\x34\x00"
#define SZ_KEY_NAME_F15         "\x66\x00\x65\xff\x31\x00\x35\x00"

//----------------------[ NEC Code Original Start ]-----------------
//This is NEC Document Processer define
//
#define SZ_KEY_NAME_DP_ZENKAKU_HANKAKU "\x68\x51\xd2\x89\x2f\000\x4a\x53\xd2\x89\000\000"
#define SZ_KEY_NAME_DP_KANA            "\x4b\x30\x6a\x30\000\000"
#define SZ_KEY_NAME_DP_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_DP_EISU            "\xf1\x82\x70\x65\000\000"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\gdi32.c ===
#include "windowspch.h"
#pragma hdrstop

static
DWORD
WINAPI
GetObjectType(
    IN  HGDIOBJ h
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
BOOL
WINAPI
SetViewportOrgEx(
    IN  HDC     hDC,
    IN  int     x,
    IN  int     y,
    OUT LPPOINT lppt
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
int
WINAPI
GetDeviceCaps(
    IN  HDC hDC,
    IN  int nIndex
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
HGDIOBJ
WINAPI
GetStockObject(
    IN int nObj
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
BOOL
WINAPI
SetViewportExtEx(
    IN HDC      hdc,
    IN int      x,
    IN int      y,
    OUT LPSIZE  lpsize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
BOOL
WINAPI
SetWindowExtEx(
    IN HDC hdc,
    IN int x,
    IN int y,
    OUT LPSIZE lpsize
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
int
WINAPI
SetMapMode(
    IN HDC hdc,
    IN int mode
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}

static
BOOL
WINAPI
DeleteDC(
    IN HDC hdc
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
DeleteObject(
    IN HGDIOBJ hobj
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
BitBlt(
    IN HDC hdc,
    IN int x,
    IN int y,
    IN int cx,
    IN int cy,
    IN HDC hdcSrc,
    IN int xs,
    IN int ys,
    IN DWORD flags
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
HGDIOBJ
WINAPI
SelectObject(
    IN HDC hdc,
    IN HGDIOBJ hobj
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
HBITMAP
WINAPI
CreateCompatibleBitmap(
    IN HDC hdc,
    IN int x,
    IN int y
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
HDC
WINAPI
CreateCompatibleDC(
    IN HDC hdc
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
UINT
WINAPI
RealizePalette(
    IN HDC hdc
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
HPALETTE
WINAPI
SelectPalette(
    IN HDC hdc,
    IN HPALETTE hpal,
    IN BOOL b
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
HPALETTE
WINAPI
CreatePalette(
    IN CONST LOGPALETTE * lplogp
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
UINT
WINAPI
GetSystemPaletteEntries(
    IN HDC hdc,
    IN UINT u1,
    IN UINT u2,
    OUT LPPALETTEENTRY lpentry
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
UINT
WINAPI
SetSystemPaletteUse(
    IN HDC hdc,
    IN UINT u
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return 0;
}


static
HBITMAP
WINAPI
CreateDIBSection(
    IN HDC hdc,
    IN CONST BITMAPINFO * lpbmpinfo,
    IN UINT u,
    OUT VOID ** ppv,
    IN HANDLE h,
    IN DWORD dw
    )
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return NULL;
}




//
// !! WARNING !! The entries below must be in alphabetical order,
//               and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(gdi32)
{
    DLPENTRY(BitBlt)
    DLPENTRY(CreateCompatibleBitmap)
    DLPENTRY(CreateCompatibleDC)
    DLPENTRY(CreateDIBSection)
    DLPENTRY(CreatePalette)
    DLPENTRY(DeleteDC)
    DLPENTRY(DeleteObject)
    DLPENTRY(GetDeviceCaps)
    DLPENTRY(GetObjectType)
    DLPENTRY(GetStockObject)
    DLPENTRY(GetSystemPaletteEntries)
    DLPENTRY(RealizePalette)
    DLPENTRY(SelectObject)
    DLPENTRY(SelectPalette)
    DLPENTRY(SetMapMode)
    DLPENTRY(SetSystemPaletteUse)
    DLPENTRY(SetViewportExtEx)
    DLPENTRY(SetViewportOrgEx)
    DLPENTRY(SetWindowExtEx)
};

DEFINE_PROCNAME_MAP(gdi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\apphelp.c ===
#include "windowspch.h"
#pragma hdrstop

#include <shimdb.h>

static
BOOL
WINAPI
ApphelpCheckExe(
    IN LPCWSTR lpApplicationName,
    IN BOOL    bApphelpIfNecessary,
    IN BOOL    bShimIfNecessary
    )
{
    return TRUE;
}


static
BOOL
WINAPI
ApphelpCheckShellObject(
    IN  REFCLSID    ObjectCLSID,
    IN  BOOL        bShimIfNecessary,
    OUT ULONGLONG*  pullFlags
    )
{
    if (pullFlags) *pullFlags = 0;
    return TRUE;
}

static
BOOL
WINAPI
SdbGetStandardDatabaseGUID(
    IN  DWORD  dwDatabaseType,
    OUT GUID*  pGuidDB
    )
{
    return FALSE;
}

static
HAPPHELPINFOCONTEXT
WINAPI
SdbOpenApphelpInformation(
    IN GUID* pguidDB,
    IN GUID* pguidID
    )
{
    return NULL;
}

static
BOOL
WINAPI
SdbCloseApphelpInformation(
    IN HAPPHELPINFOCONTEXT hctx
    )
{
    return FALSE;
}

static
DWORD
WINAPI
SdbQueryApphelpInformation(
    IN  HAPPHELPINFOCONTEXT hctx,
    IN  APPHELPINFORMATIONCLASS InfoClass,
    OUT LPVOID pBuffer,                     // may be NULL
    IN  DWORD  cbSize                       // may be 0 if pBuffer is NULL
    )
{
    return 0;
}


DWORD
SdbQueryData(
    IN     HSDB    hSDB,              // database handle
    IN     TAGREF  trExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize     // pointer to buffer size
    )
{
    return ERROR_PROC_NOT_FOUND;
}

static
HSDB
SDBAPI
SdbInitDatabase(
    IN DWORD dwFlags,
    IN LPCTSTR pszDatabasePath
    )
{
    return NULL;
}

static
VOID
SDBAPI
SdbReleaseDatabase(
    IN HSDB hSDB
    )
{
    return;
}

static
TAGREF
SDBAPI
SdbGetDatabaseMatch(
    IN HSDB    hSDB,
    IN LPCTSTR szPath,
    IN HANDLE  FileHandle  OPTIONAL,
    IN LPVOID  pImageBase  OPTIONAL,
    IN DWORD   dwImageSize OPTIONAL
    )
{
    return TAGREF_NULL;
}

static
BOOL
SDBAPI
SdbReadEntryInformation(
    IN  HSDB           hSDB,
    IN  TAGREF         trDriver,
    OUT PSDBENTRYINFO  pEntryInfo
    )
{
    return FALSE;
}




//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(apphelp)
{
    DLPENTRY(ApphelpCheckExe)
    DLPENTRY(ApphelpCheckShellObject)
    DLPENTRY(SdbCloseApphelpInformation)
    DLPENTRY(SdbGetDatabaseMatch)
    DLPENTRY(SdbGetStandardDatabaseGUID)
    DLPENTRY(SdbInitDatabase)
    DLPENTRY(SdbOpenApphelpInformation)
    DLPENTRY(SdbQueryApphelpInformation)
    DLPENTRY(SdbQueryData)
    DLPENTRY(SdbReadEntryInformation)
    DLPENTRY(SdbReleaseDatabase)
};

DEFINE_PROCNAME_MAP(apphelp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\duser.cpp ===
#include "windowspch.h"
#pragma hdrstop

#define DUSER_EXPORTS
#define GADGET_ENABLE_TRANSITIONS

#include <duser.h>
#include <duserctrl.h>
#include <duierror.h>

extern "C"
{

static DUSER_API BOOL WINAPI
SetGadgetStyle(HGADGET hgadChange, UINT nNewStyle, UINT nMask)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API HRESULT WINAPI
DUserSendEvent(
    IN  EventMsg * pmsg,            // Message to send
    IN  UINT nFlags)                // Optional flags to modifying sending
{
    return E_FAIL;
}

static DUSER_API HRESULT WINAPI
DUserPostEvent(
    IN  EventMsg * pmsg,            // Message to post
    IN  UINT nFlags)                // Optional flags modifiying posting
{
    return E_FAIL;
}

static DUSER_API BOOL WINAPI
GetGadgetRect(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT RECT * prcPxl,              // Rectangle in specified pixels
    IN  UINT nFlags)                // Rectangle to retrieve
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI  
GetGadgetRgn(
    IN  HGADGET hgad,               // Gadget to get region of
    IN  UINT nRgnType,              // Type of region
    OUT HRGN hrgn,                  // Specified region
    IN  UINT nFlags)                // Modifying flags
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
GetGadgetSize(
    IN  HGADGET hgad,               // Handle of Gadget
    OUT SIZE * psizeLogicalPxl)     // Size in logical pixels
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API DWORD WINAPI
GetGadgetTicket(HGADGET hgad)
{
    SetLastError((DWORD)E_FAIL);
    return 0;
}

static DUSER_API BOOL WINAPI
MapGadgetPoints(HGADGET hgadFrom, HGADGET hgadTo, POINT * rgptClientPxl, int cPts)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
BuildAnimation(UINT nAniID, int nVersion, GANI_DESC * pDesc, REFIID riid, void ** ppvUnk)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
BuildInterpolation(UINT nIPolID, int nVersion, REFIID riid, void ** ppvUnk)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
DeleteHandle(
    IN  HANDLE h)                   // Handle to delete
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
SetGadgetFillI(HGADGET hgadChange, HBRUSH hbrFill, BYTE bAlpha, int w, int h)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
SetGadgetMessageFilter(HGADGET hgadChange, void * pvCookie, UINT nNewFilter, UINT nMask)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API HGADGET WINAPI
CreateGadget(
    IN  HANDLE hParent,             // Handle to parent
    IN  UINT nFlags,                // Creation flags
    IN  GADGETPROC pfnProc,         // Pointer to the Gadget procedure
    IN  void * pvGadgetData)        // User data associated with this Gadget
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API HGADGET WINAPI
FindGadgetFromPoint(
    IN  HGADGET hgadRoot,           // Root Gadget to search from
    IN  POINT ptContainerPxl,       // Point to search from in container pixels
    IN  UINT nFlags,                // Search flags
    OUT POINT * pptClientPxl)       // Optional translated point in client pixels.
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API HGADGET WINAPI
LookupGadgetTicket(
    IN  DWORD dwTicket)             // Ticket
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API BOOL WINAPI
SetGadgetRootInfo(
    IN  HGADGET hgadRoot,           // RootGadget to modify
    IN  const ROOT_INFO * pri)      // Information
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
SetGadgetParent(
    IN  HGADGET hgadMove,           // Gadget to be moved
    IN  HGADGET hgadParent,         // New parent
    IN  HGADGET hgadOther,          // Gadget to moved relative to
    IN  UINT nCmd)                  // Type of move
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
SetGadgetFocus(
    IN  HGADGET hgadFocus)          // Gadget to receive focus.
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API HGADGET WINAPI
GetGadgetFocus()
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API BOOL WINAPI
InvalidateGadget(
    IN  HGADGET hgad)               // Gadget to repaint
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
SetGadgetRect(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  int x,                      // New horizontal position
    IN  int y,                      // New vertical position
    IN  int w,                      // New width
    IN  int h,                      // New height
    IN  UINT nFlags)                // Flags specifying what to change
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API UINT WINAPI
FindStdColor(LPCWSTR pszName)
{
    SetLastError((DWORD)E_FAIL);
    return SC_Black;
}

static DUSER_API HBRUSH WINAPI
GetStdColorBrushI(UINT c)
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API COLORREF WINAPI
GetStdColorI(UINT c)
{
    SetLastError((DWORD)E_FAIL);
    return RGB(0, 0, 0);
}

static DUSER_API HDCONTEXT WINAPI
InitGadgets(
    IN  INITGADGET * pInit)
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API BOOL WINAPI
UtilDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI  
AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI
DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API HACTION WINAPI
CreateAction(const GMA_ACTION * pma)
{
    SetLastError((DWORD)E_FAIL);
    return NULL;
}

static DUSER_API BOOL WINAPI
BuildDropTarget(HGADGET hgadRoot, HWND hwnd)
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static DUSER_API BOOL WINAPI  
SetGadgetBufferInfo(
    IN  HGADGET hgadChange,         // Gadget to change
    IN  const BUFFER_INFO * pbi)    // Buffer information
{
    SetLastError((DWORD)E_FAIL);
    return FALSE;
}

static
DUSER_API
DirectUI::IDebug*
WINAPI
GetDebug()
{
    return NULL;
}

static
DUSER_API 
BOOL 
WINAPI
GetMessageExW(
    IN  LPMSG lpMsg,
    IN  HWND hWnd,
    IN  UINT wMsgFilterMin,
    IN  UINT wMsgFilterMax)
{
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
DUSER_API
void
_cdecl
AutoTrace(const char* pszFormat, ...)
{
    return;
}

static
DUSER_API
BOOL
GetGadgetAnimation(
    HGADGET hgad,
    UINT nAniID,
    REFIID riid,
    void** ppvUnk
    )
{
    return FALSE;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(duser)
{
    DLPENTRY(AttachWndProcW)
    DLPENTRY(AutoTrace)
    DLPENTRY(BuildAnimation)
    DLPENTRY(BuildDropTarget)
    DLPENTRY(BuildInterpolation)
    DLPENTRY(CreateAction)
    DLPENTRY(CreateGadget)
    DLPENTRY(DUserPostEvent)
    DLPENTRY(DUserSendEvent)
    DLPENTRY(DeleteHandle)
    DLPENTRY(DetachWndProc)
    DLPENTRY(FindGadgetFromPoint)
    DLPENTRY(FindStdColor)
    DLPENTRY(ForwardGadgetMessage)
    DLPENTRY(GetDebug)
    DLPENTRY(GetGadgetAnimation)
    DLPENTRY(GetGadgetFocus)
    DLPENTRY(GetGadgetRect)
    DLPENTRY(GetGadgetRgn)
    DLPENTRY(GetGadgetSize)
    DLPENTRY(GetGadgetTicket)
    DLPENTRY(GetMessageExW)
    DLPENTRY(GetStdColorBrushI)
    DLPENTRY(GetStdColorI)
    DLPENTRY(InitGadgets)
    DLPENTRY(InvalidateGadget)
    DLPENTRY(LookupGadgetTicket)
    DLPENTRY(MapGadgetPoints)
    DLPENTRY(SetGadgetBufferInfo)
    DLPENTRY(SetGadgetFillI)
    DLPENTRY(SetGadgetFocus)
    DLPENTRY(SetGadgetMessageFilter)
    DLPENTRY(SetGadgetParent)
    DLPENTRY(SetGadgetRect)
    DLPENTRY(SetGadgetRootInfo)
    DLPENTRY(SetGadgetStyle)
    DLPENTRY(UtilDrawBlendRect)
};

// BUGBUG (reinerf) - we shouldn't need the EXTERN_C below since we are already in 
//                    an extern "C" {} block, but the compiler seems to get my goat,
//                    so I murdered his goat in a bloody melee.
EXTERN_C DEFINE_PROCNAME_MAP(duser)

}; // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\gdiplus.cpp ===
#include "windowspch.h"
#pragma hdrstop

#include <ddraw.h>

#include <GdiplusMem.h>
#include <GdiplusEnums.h>
#include <GdiplusTypes.h>
#include <GdiplusInit.h>
#include <GdiplusPixelFormats.h>
#include <GdiplusColor.h>
#include <GdiplusMetaHeader.h>
#include <GdiplusImaging.h>
#include <GdiplusColorMatrix.h>
#include <GdiplusGpStubs.h>
#include <GdiplusFlat.h>

extern "C"
{

static void* WINGDIPAPI GdipAlloc(IN size_t size)
{
    return NULL;
}

static GpStatus WINGDIPAPI GdipCloneBrush(
    GpBrush *brush,
    GpBrush **cloneBrush)
{
    if (cloneBrush != NULL) {
        *cloneBrush = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateFont(
    GDIPCONST GpFontFamily *fontFamily,
    REAL emSize,
    INT style,
    Unit unit,
    GpFont **font)
{
    if (font != NULL) {
        *font = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateFontFamilyFromName(
    GDIPCONST WCHAR *name,
    GpFontCollection *fontCollection,
    GpFontFamily **FontFamily)
{
    if (FontFamily != NULL) {
        *FontFamily = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateFromHDC(
    HDC hdc,
    GpGraphics **graphics)
{
    if (graphics != NULL) {
        *graphics = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateFromHWND(
    HWND hwnd,
    GpGraphics **graphics)
{
    if (graphics != NULL) {
        *graphics = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateFromHWNDICM(
    HWND hwnd,
    GpGraphics **graphics)
{
    if (graphics != NULL) {
        *graphics = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateMatrix(GpMatrix **matrix)
{
    if (matrix != NULL) {
        *matrix = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateMatrix2(
    REAL m11,
    REAL m12,
    REAL m21,
    REAL m22,
    REAL dx,
    REAL dy,
    GpMatrix **matrix)
{
    if (matrix != NULL) {
        *matrix = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreatePen1(
    ARGB color,
    REAL width,
    GpUnit unit,
    GpPen **pen)
{
    if (pen != NULL) {
        *pen = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateRegion(GpRegion **region)
{
    if (region != NULL) {
        *region = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipCreateSolidFill(
    ARGB color,
    GpSolidFill **brush)
{
    if (brush != NULL) {
        *brush = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteBrush(GpBrush *brush)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteFont(GpFont* font)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteFontFamily(GpFontFamily *FontFamily)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteGraphics(GpGraphics *graphics)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteMatrix(GpMatrix *matrix)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeletePen(GpPen *pen)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDeleteRegion(GpRegion *region)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDrawLine(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDrawRectangle(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipDrawString(
    GpGraphics *graphics,
    GDIPCONST WCHAR *string,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST RectF *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush *brush)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipFillRectangle(
    GpGraphics *graphics,
    GpBrush *brush,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    return NotImplemented;
}

static void WINGDIPAPI GdipFree(IN void* ptr)
{
}

static GpStatus WINGDIPAPI GdipGetClip(
    GpGraphics *graphics,
    GpRegion *region)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetCompositingMode(
    GpGraphics *graphics,
    CompositingMode *compositingMode)
{
    if (compositingMode != NULL) {
        *compositingMode = CompositingModeSourceOver;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetCompositingQuality(
    GpGraphics *graphics,
    CompositingQuality *compositingQuality)
{
    if (compositingQuality != NULL) {
        *compositingQuality = CompositingQualityInvalid;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetDC(GpGraphics* graphics, HDC * hdc)
{
    if (hdc != NULL) {
        *hdc = NULL;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetFontSize(GpFont *font, REAL *size)
{
    if (size != NULL) {
        *size = 0.0;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetGenericFontFamilySansSerif(
    GpFontFamily **nativeFamily)
{
    if (nativeFamily != NULL) {
        *nativeFamily = NULL;
    }
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetInterpolationMode(
    GpGraphics *graphics,
    InterpolationMode *interpolationMode)
{
    if (interpolationMode != NULL) {
        *interpolationMode = InterpolationModeInvalid;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetPixelOffsetMode(
    GpGraphics *graphics,
    PixelOffsetMode *pixelOffsetMode)
{
    if (pixelOffsetMode != NULL) {
        *pixelOffsetMode = PixelOffsetModeInvalid;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetSmoothingMode(
    GpGraphics *graphics,
    SmoothingMode *smoothingMode)
{
    if (smoothingMode != NULL) {
        *smoothingMode = SmoothingModeInvalid;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetTextContrast(
    GpGraphics *graphics,
    UINT * contrast)
{
    if (contrast != NULL) {
        *contrast = 0;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetTextRenderingHint(
    GpGraphics *graphics,
    TextRenderingHint *mode)
{
    if (mode != NULL) {
        *mode = TextRenderingHintSystemDefault;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipGetWorldTransform(
    GpGraphics *graphics,
    GpMatrix *matrix)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipIsClipEmpty(
    GpGraphics *graphics,
    BOOL *result)
{
    if (result != NULL) {
        *result = FALSE;
    }

    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipMeasureString(
    GpGraphics *graphics,
    GDIPCONST WCHAR *string,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST RectF *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF *boundingBox,
    INT *codepointsFitted,
    INT *linesFilled)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipReleaseDC(GpGraphics* graphics, HDC hdc)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipResetWorldTransform(GpGraphics *graphics)
{
    return NotImplemented;
}


static GpStatus WINGDIPAPI GdipRestoreGraphics(
    GpGraphics *graphics,
    GraphicsState state)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSaveGraphics(
    GpGraphics *graphics,
    GraphicsState *state)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetClipRect(
    GpGraphics *graphics,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    CombineMode combineMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetClipRegion(
    GpGraphics *graphics,
    GpRegion *region,
    CombineMode combineMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetCompositingMode(
    GpGraphics *graphics,
    CompositingMode compositingMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetCompositingQuality(
    GpGraphics *graphics,
    CompositingQuality compositingQuality)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetInterpolationMode(
    GpGraphics *graphics,
    InterpolationMode interpolationMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetPixelOffsetMode(
    GpGraphics* graphics,
    PixelOffsetMode pixelOffsetMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetSmoothingMode(
    GpGraphics *graphics,
    SmoothingMode smoothingMode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetTextContrast(
    GpGraphics *graphics,
    UINT contrast)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetTextRenderingHint(
    GpGraphics *graphics,
    TextRenderingHint mode)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipSetWorldTransform(
    GpGraphics *graphics, 
    GpMatrix *matrix)
{
    return NotImplemented;
}

static GpStatus WINGDIPAPI GdipTranslateRegionI(
    GpRegion *region,
    INT dx,
    INT dy)
{
    return NotImplemented;
}

static
VOID WINAPI GdiplusShutdown(ULONG_PTR token)
{
}

static
Status WINAPI GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output)
{
    if (output != NULL) {
        ZeroMemory(output, sizeof(GdiplusStartupOutput));
    }

    return NotImplemented;
}

//
// !! WARNING !! The entries below must be in alphabetical order,
//               and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(gdiplus)
{
    DLPENTRY(GdipAlloc)
    DLPENTRY(GdipCloneBrush)
    DLPENTRY(GdipCreateFont)
    DLPENTRY(GdipCreateFontFamilyFromName)
    DLPENTRY(GdipCreateFromHDC)
    DLPENTRY(GdipCreateFromHWND)
    DLPENTRY(GdipCreateFromHWNDICM)
    DLPENTRY(GdipCreateMatrix)
    DLPENTRY(GdipCreateMatrix2)
    DLPENTRY(GdipCreatePen1)
    DLPENTRY(GdipCreateRegion)
    DLPENTRY(GdipCreateSolidFill)
    DLPENTRY(GdipDeleteBrush)
    DLPENTRY(GdipDeleteFont)
    DLPENTRY(GdipDeleteFontFamily)
    DLPENTRY(GdipDeleteGraphics)
    DLPENTRY(GdipDeleteMatrix)
    DLPENTRY(GdipDeletePen)
    DLPENTRY(GdipDeleteRegion)
    DLPENTRY(GdipDrawLine)
    DLPENTRY(GdipDrawRectangle)
    DLPENTRY(GdipDrawString)
    DLPENTRY(GdipFillRectangle)
    DLPENTRY(GdipFree)
    DLPENTRY(GdipGetClip)
    DLPENTRY(GdipGetCompositingMode)
    DLPENTRY(GdipGetCompositingQuality)
    DLPENTRY(GdipGetDC)
    DLPENTRY(GdipGetFontSize)
    DLPENTRY(GdipGetGenericFontFamilySansSerif)
    DLPENTRY(GdipGetInterpolationMode)
    DLPENTRY(GdipGetPixelOffsetMode)
    DLPENTRY(GdipGetSmoothingMode)
    DLPENTRY(GdipGetTextContrast)
    DLPENTRY(GdipGetTextRenderingHint)
    DLPENTRY(GdipGetWorldTransform)
    DLPENTRY(GdipIsClipEmpty)
    DLPENTRY(GdipMeasureString)
    DLPENTRY(GdipReleaseDC)
    DLPENTRY(GdipResetWorldTransform)
    DLPENTRY(GdipRestoreGraphics)
    DLPENTRY(GdipSaveGraphics)
    DLPENTRY(GdipSetClipRect)
    DLPENTRY(GdipSetClipRegion)
    DLPENTRY(GdipSetCompositingMode)
    DLPENTRY(GdipSetCompositingQuality)
    DLPENTRY(GdipSetInterpolationMode)
    DLPENTRY(GdipSetPixelOffsetMode)
    DLPENTRY(GdipSetSmoothingMode)
    DLPENTRY(GdipSetTextContrast)
    DLPENTRY(GdipSetTextRenderingHint)
    DLPENTRY(GdipSetWorldTransform)
    DLPENTRY(GdipTranslateRegionI)
    DLPENTRY(GdiplusShutdown)
    DLPENTRY(GdiplusStartup)};

// BUGBUG (reinerf) - we shouldn't need the EXTERN_C below since we are already in
//                    an extern "C" {} block, but the compiler seems to get my goat,
//                    so I murdered his goat in a bloody melee.
EXTERN_C DEFINE_PROCNAME_MAP(gdiplus)

}; // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\imm32.c ===
#include "windowspch.h"
#pragma hdrstop

static
LONG
WINAPI
ImmGetCompositionStringW(
    IN HIMC hIMC,
    IN DWORD dwIndex,
    OUT LPVOID lpBuf,
    IN DWORD dwBufLen
    )
{
    return IMM_ERROR_GENERAL;
}

static
HIMC
WINAPI
ImmGetContext(
    IN HWND hWnd
    )
{
    return NULL;
}

static
BOOL
WINAPI
ImmReleaseContext(
    IN HWND hWnd,
    IN HIMC hIMC
    )
{
    return FALSE;
}

static
UINT
WINAPI
ImmGetVirtualKey(
    IN HWND hWnd
    )
{
    return VK_PROCESSKEY;
}

static
HWND
WINAPI
ImmGetDefaultIMEWnd(
    IN HWND hWnd
    )
{
    return NULL;
}

//
// !! WARNING !! The entries below must be in alphabetical order,
//               and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(imm32)
{
    DLPENTRY(ImmGetCompositionStringW)
    DLPENTRY(ImmGetContext)
    DLPENTRY(ImmGetDefaultIMEWnd)
    DLPENTRY(ImmGetVirtualKey)
    DLPENTRY(ImmReleaseContext)
};

DEFINE_PROCNAME_MAP(imm32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\msimg32.c ===
#include "windowspch.h"
#pragma hdrstop

// #define _GDI32_  // must be defined in our precompiled header
#include <wingdi.h>

static
WINGDIAPI
BOOL
WINAPI
TransparentBlt(HDC   hdcDest,
               int   DstX,
               int   DstY,
               int   DstCx,
               int   DstCy,
               HDC   hSrc,
               int   SrcX,
               int   SrcY,
               int   SrcCx,
               int   SrcCy,
               UINT  Color)
{
    return FALSE;
}

static
WINGDIAPI
BOOL
WINAPI
GradientFill(HDC         hdc,
             PTRIVERTEX  pVertex,
             ULONG       nVertex,
             PVOID       pMesh,
             ULONG       nMesh,
             ULONG       ulMode)
{
    return FALSE;
}

static
WINGDIAPI
BOOL 
WINAPI
AlphaBlend(HDC          hdcDest,
          int           DstX,
          int           DstY,
          int           DstCx,
          int           DstCy,
          HDC           hSrc,
          int           SrcX,
          int           SrcY,
          int           SrcCx,
          int           SrcCy,
          BLENDFUNCTION BlendFunction)
{
    return FALSE;
}

 
//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(msimg32)
{
    DLPENTRY(AlphaBlend)
    DLPENTRY(GradientFill)
    DLPENTRY(TransparentBlt)
};

DEFINE_PROCNAME_MAP(msimg32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\oleacc.c ===
#include "windowspch.h"
#pragma hdrstop


#include <oleacc.h>

static
LRESULT
STDAPICALLTYPE
LresultFromObject(
    REFIID riid,
    WPARAM wParam,
    LPUNKNOWN punk
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
HRESULT
STDAPICALLTYPE
AccessibleObjectFromWindow(
    HWND hwnd,
    DWORD dwId,
    REFIID riid,
    void **ppvObject
    )
{
    return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
}

static
UINT
STDAPICALLTYPE
GetRoleTextW(
    DWORD lRole,
    LPWSTR lpszRole,
    UINT cchRoleMax)
{
    return 0;
}

static
HRESULT
STDAPICALLTYPE
CreateStdAccessibleObject(
    HWND hwnd,
    LONG idObject,
    REFIID riid,
    void** ppvObject
    )
{
    *ppvObject = NULL;
    return E_FAIL;
}

 
//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(oleacc)
{
    DLPENTRY(AccessibleObjectFromWindow)
    DLPENTRY(CreateStdAccessibleObject)
    DLPENTRY(GetRoleTextW)
    DLPENTRY(LresultFromObject)
};

DEFINE_PROCNAME_MAP(oleacc)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\windowspch.h ===
#pragma once

#define _GDI32_
#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\dload\user32.c ===
#include "windowspch.h"
#pragma hdrstop

static
BOOL
WINAPI
CharToOemBuffA(
    IN LPCSTR lpszSrc,
    OUT LPSTR lpszDst,
    IN DWORD cchDstLength
    )
{
    return FALSE;
}

static
LRESULT
WINAPI
DispatchMessageA(
    IN CONST MSG *lpMsg
    )
{
    return 0;
}

static
HWINSTA
WINAPI
GetProcessWindowStation(
    VOID
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
HDESK
WINAPI
GetThreadDesktop(
    IN DWORD dwThreadId
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
IsWindow(
    IN HWND hWnd
    )
{
    return FALSE;
}

static
int
WINAPI
LoadStringA(
    IN HINSTANCE hInstance,
    IN UINT uID,
    OUT LPSTR lpBuffer,
    IN int nBufferMax
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}

static
int
WINAPI
LoadStringW(
    IN HINSTANCE hInstance,
    IN UINT uID,
    OUT LPWSTR lpBuffer,
    IN int nBufferMax
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}

static
BOOL
WINAPI
OemToCharBuffA(
    IN LPCSTR lpszSrc,
    OUT LPSTR lpszDst,
    IN DWORD cchDstLength
    )
{
    return FALSE;
}

static
HDESK
WINAPI
OpenDesktopA(
    IN LPCSTR lpszDesktop,
    IN DWORD dwFlags,
    IN BOOL fInherit,
    IN ACCESS_MASK dwDesiredAccess
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CloseDesktop(
    HDESK hDesktop
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
HWINSTA
WINAPI
OpenWindowStationA(
    IN LPCSTR lpszWinSta,
    IN BOOL fInherit,
    IN ACCESS_MASK dwDesiredAccess
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}

static
BOOL
WINAPI
CloseWindowStation(
    HWINSTA hWinSta
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
PeekMessageA(
    OUT LPMSG lpMsg,
    IN HWND hWnd,
    IN UINT wMsgFilterMin,
    IN UINT wMsgFilterMax,
    IN UINT wRemoveMsg
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
PostMessageA(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SetProcessWindowStation(
    IN HWINSTA hWinSta
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SetThreadDesktop(
    IN HDESK hDesktop
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
TranslateMessage(
    IN CONST MSG *lpMsg
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
int
WINAPIV
wsprintfA(
    OUT LPSTR str,
    IN LPCSTR fmt,
    ...
    )
{
    return -1;
}

static
int
WINAPIV
wsprintfW(
    OUT LPWSTR str,
    IN LPCWSTR fmt,
    ...
    )
{
    return -1;
}


//
// Stubs for shims
//
static
LRESULT
WINAPI
DefWindowProcA(
    IN  HWND   hWnd,
    IN  UINT   Msg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}

static
BOOL
WINAPI
IsWindowVisible(
    IN  HWND hWnd
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SetForegroundWindow(
    IN  HWND hWnd
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
EnumDisplaySettingsA(
    IN  LPCSTR     lpszDeviceName,
    IN  DWORD      iModeNum,
    OUT LPDEVMODEA lpDevMode
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
EnumDisplaySettingsW(
    IN  LPCWSTR    lpszDeviceName,
    IN  DWORD      iModeNum,
    OUT LPDEVMODEW lpDevMode
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
LPSTR
WINAPI
CharNextA(
    IN  LPCSTR lpsz
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    /* This function has no documented error mode, so delayloading
       it is just not a good idea..
    */
    return RTL_CONST_CAST(LPSTR)(lpsz);
}

static
BOOL
WINAPI
IsCharAlphaA(
    IN  CHAR ch
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
int
WINAPI
GetWindowTextA(
    IN HWND hWnd,
    OUT LPSTR lpString,
    IN int nMaxCount
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
BOOL
WINAPI
EnumDesktopWindows(
    IN HDESK hDesktop,
    IN WNDENUMPROC lpfn,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
SystemParametersInfoW(
    IN UINT uiAction,
    IN UINT uiParam,
    IN OUT PVOID pvParam,
    IN UINT fWinIni
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
LONG
WINAPI
ChangeDisplaySettingsA(
    IN LPDEVMODEA  lpDevMode,
    IN DWORD       dwFlags
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
VOID
WINAPI
mouse_event(
    IN DWORD dwFlags,
    IN DWORD dx,
    IN DWORD dy,
    IN DWORD dwData,
    IN ULONG_PTR dwExtraInfo
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return;
}


static
HWND
WINAPI
GetForegroundWindow(
    VOID
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
LRESULT
WINAPI
SendMessageW(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
int
WINAPI
GetSystemMetrics(
    IN int nIndex
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
LONG
WINAPI
GetWindowLongA(
    IN HWND hWnd,
    IN int nIndex
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
LONG
WINAPI
GetWindowLongW(
    IN HWND hWnd,
    IN int nIndex
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
int
WINAPI
ReleaseDC(
    IN HWND hWnd,
    IN HDC hDC
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
HDC
WINAPI
GetDC(
    IN HWND hWnd
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
LRESULT
WINAPI
CallNextHookEx(
    IN HHOOK hhk,
    IN int nCode,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
HWND
WINAPI
GetActiveWindow(
    VOID
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}



static
BOOL
WINAPI
DestroyCursor(
    IN HCURSOR hCursor
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
HICON
WINAPI
CopyIcon(
    IN HICON hIcon
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
HCURSOR
WINAPI
LoadCursorW(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpCursorName
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}



static
BOOL
WINAPI
SetSystemCursor(
    IN HCURSOR hcur,
    IN DWORD   id
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
BOOL
WINAPI
EqualRect(
    IN CONST RECT *lprc1,
    IN CONST RECT *lprc2
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
IntersectRect(
    OUT LPRECT lprcDst,
    IN CONST RECT *lprcSrc1,
    IN CONST RECT *lprcSrc2
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
SetRect(
    OUT LPRECT lprc,
    IN int xLeft,
    IN int yTop,
    IN int xRight,
    IN int yBottom
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
LONG
WINAPI
ChangeDisplaySettingsExW(
    IN LPCWSTR    lpszDeviceName,
    IN LPDEVMODEW  lpDevMode,
    IN HWND        hwnd,
    IN DWORD       dwflags,
    IN LPVOID      lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
BOOL
WINAPI
GetClientRect(
    IN HWND hWnd,
    OUT LPRECT lpRect
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
HWND
WINAPI
WindowFromDC(
    IN HDC hDC
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
BOOL
WINAPI
GetClassInfoA(
    IN HINSTANCE hInstance,
    IN LPCSTR lpClassName,
    OUT LPWNDCLASSA lpWndClass
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
BOOL
WINAPI
ShowWindow(
    IN HWND hWnd,
    IN int nCmdShow
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
BOOL
WINAPI
InvalidateRect(
    IN HWND hWnd,
    IN CONST RECT *lpRect,
    IN BOOL bErase
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
int
WINAPI
FillRect(
    IN HDC hDC,
    IN CONST RECT *lprc,
    IN HBRUSH hbr
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
BOOL
WINAPI
GetWindowRect(
    IN HWND hWnd,
    OUT LPRECT lpRect
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
BOOL
WINAPI
EndPaint(
    IN HWND hWnd,
    IN CONST PAINTSTRUCT *lpPaint
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
HDC
WINAPI
BeginPaint(
    IN HWND hWnd,
    OUT LPPAINTSTRUCT lpPaint
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}


static
BOOL
WINAPI
ValidateRect(
    IN HWND hWnd,
    IN CONST RECT *lpRect
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}


static
BOOL
WINAPI
GetUpdateRect(
    IN HWND hWnd,
    OUT LPRECT lpRect,
    IN BOOL bErase
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
LRESULT
WINAPI
CallWindowProcA(
    IN WNDPROC lpPrevWndFunc,
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
LONG
WINAPI
SetWindowLongA(
    IN HWND hWnd,
    IN int nIndex,
    IN LONG dwNewLong
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
HWND
WINAPI
FindWindowA(
    IN LPCSTR lpClassName,
    IN LPCSTR lpWindowName
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}



static
UINT
WINAPI
RegisterWindowMessageW(
    IN LPCWSTR lpString
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
int
WINAPI
ShowCursor(
    IN BOOL bShow
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}



static
BOOL
WINAPI
DestroyWindow(
    IN HWND hWnd
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return FALSE;
}



static
HWND
WINAPI
CreateWindowExA(
    IN DWORD dwExStyle,
    IN LPCSTR lpClassName,
    IN LPCSTR lpWindowName,
    IN DWORD dwStyle,
    IN int X,
    IN int Y,
    IN int nWidth,
    IN int nHeight,
    IN HWND hWndParent,
    IN HMENU hMenu,
    IN HINSTANCE hInstance,
    IN LPVOID lpParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return NULL;
}



static
ATOM
WINAPI
RegisterClassA(
    IN CONST WNDCLASSA *lpWndClass
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}


static
LRESULT
WINAPI
DefWindowProcW(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    SetLastError (ERROR_PROC_NOT_FOUND);
    return 0;
}




//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(user32)
{
    DLPENTRY(BeginPaint)
    DLPENTRY(CallNextHookEx)
    DLPENTRY(CallWindowProcA)
    DLPENTRY(ChangeDisplaySettingsA)
    DLPENTRY(ChangeDisplaySettingsExW)
    DLPENTRY(CharNextA)
    DLPENTRY(CharToOemBuffA)
    DLPENTRY(CloseDesktop)
    DLPENTRY(CloseWindowStation)
    DLPENTRY(CopyIcon)
    DLPENTRY(CreateWindowExA)
    DLPENTRY(DefWindowProcA)
    DLPENTRY(DefWindowProcW)
    DLPENTRY(DestroyCursor)
    DLPENTRY(DestroyWindow)
    DLPENTRY(DispatchMessageA)
    DLPENTRY(EndPaint)
    DLPENTRY(EnumDesktopWindows)
    DLPENTRY(EnumDisplaySettingsA)
    DLPENTRY(EnumDisplaySettingsW)
    DLPENTRY(EqualRect)
    DLPENTRY(FillRect)
    DLPENTRY(FindWindowA)
    DLPENTRY(GetActiveWindow)
    DLPENTRY(GetClassInfoA)
    DLPENTRY(GetClientRect)
    DLPENTRY(GetDC)
    DLPENTRY(GetForegroundWindow)
    DLPENTRY(GetProcessWindowStation)
    DLPENTRY(GetSystemMetrics)
    DLPENTRY(GetThreadDesktop)
    DLPENTRY(GetUpdateRect)
    DLPENTRY(GetWindowLongA)
    DLPENTRY(GetWindowLongW)
    DLPENTRY(GetWindowRect)
    DLPENTRY(GetWindowTextA)
    DLPENTRY(IntersectRect)
    DLPENTRY(InvalidateRect)
    DLPENTRY(IsCharAlphaA)
    DLPENTRY(IsWindow)
    DLPENTRY(IsWindowVisible)
    DLPENTRY(LoadCursorW)
    DLPENTRY(LoadStringA)
    DLPENTRY(LoadStringW)
    DLPENTRY(OemToCharBuffA)
    DLPENTRY(OpenDesktopA)
    DLPENTRY(OpenWindowStationA)
    DLPENTRY(PeekMessageA)
    DLPENTRY(PostMessageA)
    DLPENTRY(RegisterClassA)
    DLPENTRY(RegisterWindowMessageW)
    DLPENTRY(ReleaseDC)
    DLPENTRY(SendMessageW)
    DLPENTRY(SetForegroundWindow)
    DLPENTRY(SetProcessWindowStation)
    DLPENTRY(SetRect)
    DLPENTRY(SetSystemCursor)
    DLPENTRY(SetThreadDesktop)
    DLPENTRY(SetWindowLongA)
    DLPENTRY(ShowCursor)
    DLPENTRY(ShowWindow)
    DLPENTRY(SystemParametersInfoW)
    DLPENTRY(TranslateMessage)
    DLPENTRY(ValidateRect)
    DLPENTRY(WindowFromDC)
    DLPENTRY(mouse_event)
    DLPENTRY(wsprintfA)
    DLPENTRY(wsprintfW)
};

DEFINE_PROCNAME_MAP(user32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\chnuconv.c ===
/**************************************************************************\
* chsuconv.c -- convert to/from unicode using
*                MulitByteToWideChar & WideCharToMulitByte
*
*         Steve Firebaugh
*         Microsoft Developer Support
*         Copyright (C) 1992-1999 Microsoft Inc. 
*
\**************************************************************************/

#include "chnuconv.h"
#include "resource.h"


/**************************************************************************\
*  Global Data Items
\**************************************************************************/

/* Global variables storing the source and destination "type" information.
*
* used to communicate between main wnd proc, and *OptionsProc.
*
* gTypeSource - stores the type interpretation of the source data
*       (and implicitly the destination data.)
*   TYPEUNKNOWN: indeterminant... not set. Can not do conversion.
*   TYPEUNICODE: source unicode & destination giDestinationCodePage.
*   TYPECODEPAGE: source giSourceCodePage & destination unicode.
*
* giSourceCodePage stores valid source code page iff gTypeSource == TRUE
* giDestinationCodePage stores valid destination code page iff gTypeSource == FALSE
*
*/
int gTypeSource;
int gTypeSourceID;
UINT giSourceCodePage;
int gTypeDest;
int gTypeDestID;
UINT giDestinationCodePage;
int giRBInit;
TCHAR szDataOptionsDlg[40];

/* Pointers to the source and destination data, and the
 *  count of bytes in each of the buffers.
 */
PBYTE pSourceData =       NULL;
PBYTE pDestinationData =  NULL;
PBYTE pTempData1 =  NULL;
int   nBytesSource =      NODATA;
int   nBytesDestination = NODATA;
PBYTE pTempData =         NULL;
PBYTE pViewSourceData =   NULL;
int   nBytesTemp        = NODATA;

BOOL  gSourceSwapped=FALSE;
BOOL  gDestSwapped=FALSE;

/* Conversion Options variables. */
DWORD gMBFlags = MB_PRECOMPOSED;
DWORD gWCFlags = 0;
char  glpDefaultChar[4] = "?";  // what is max size of multibyte character?
BOOL  gUsedDefaultChar = FALSE;

DWORD gTCSCMapStatus = DONOTMAP; //simplified and traditional Chinese mapping
DWORD gFWHWMapStatus = DONOTMAP; //full width and half width mapping
/* Handling the Byte Order Mark (BOM).
*
* If the input file begins with a BOM, then we know it is unicode,
*  we skip over the BOM and decrement the size of data by SIZEOFBOM.
*
*
* Before writing data that we know is unicode, write the szBOM string
*  to the file.
*
* Notice that this means that the file sizes we show in the window
*  do NOT include the BOM.
*/

char szBOM[] = "\377\376";  // 0xFF, 0xFE  // leave off TEXT() macro.
char szRBOM[] = "\376\377";  // 0xFF, 0xFE  // leave off TEXT() macro.

UINT  MBFlags = MB_OK | MB_ICONEXCLAMATION;
TCHAR MBTitle[40];
TCHAR MBMessage[EXTENSION_LENGTH];
TCHAR szBlank[] = TEXT("");
TCHAR szNBytes[40];
TCHAR szFilter[MAX_PATH];
TCHAR szHelpPathName[] = TEXT("chnuconv.chm");
DLGTEMPLATE * dlgtSourceTab;
DLGTEMPLATE * dlgtOptionTab;



HGLOBAL hglbMem;
PBYTE  p;
int NumCodePage;
UINT uCodepage[]={  0,//UNICODE
                  936, //GB
                  950,//BIG5
                  20000,//CNS
                  20001,//TCA
                  20002,//ETEN
                  20003,//IBM5
                  20004,//TELE
                  20005//WANG
                 };


//
// Module handle.
//

HANDLE  _hModule;

//
// Application's icon handle.
//

HANDLE  _hIcon;


//
// Main window handle.
//

HANDLE  _hWndMain;
HANDLE  hMainTabControl;
HANDLE  hWndDisplay;
HANDLE  hWndTab[NUMBER_OF_PAGES];

//
// Application's accelerator table handle.
//

HANDLE  _hAccel;

BOOL InitializeApplication( HINSTANCE hInstance, HINSTANCE hPrevInstance);
BOOL MakeTabs( IN HWND hWnd, IN HWND hMainTabControl );
VOID AdjustSelectTab ( IN HWND hWnd, IN HWND hMainTabControl );
LRESULT APIENTRY MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
VOID CreateFilter(PTCHAR);





int APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
/*++

Routine Description:

    Main is the entry point for Code Converter. It initializes the application
    and manages the message pump. When the message pump quits, main performs
    some global cleanup.

Arguments:

    None.

Return Value:

    int - Returns the result of the PostQuitMessgae API or -1 if
          initialization failed.

--*/

{
    MSG    msg;
    BOOL    bHandled=FALSE;

    UNREFERENCED_PARAMETER( lpCmdLine );
    UNREFERENCED_PARAMETER(  nCmdShow );


    if( InitializeApplication(hInstance, hPrevInstance)) {

        while( GetMessage( &msg, NULL, 0, 0 )) {

            bHandled = TranslateAccelerator( _hWndMain, _hAccel, &msg );

            if (bHandled==FALSE)
            {
                bHandled = TranslateAccelerator(hWndDisplay, _hAccel, &msg);
                if (bHandled == FALSE && IsDialogMessage(_hWndMain, &msg)==FALSE)
                {
                    TranslateMessage(&msg);  // Translates virtual key codes

                    DispatchMessage(&msg);   // Dispatches message to window
                }
            }

        }

        return (int)msg.wParam;
    }

    //
    // Initialization failed.
    //
    return -1;
}


BOOL
InitializeApplication(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance
    )

/*++

Routine Description:

    InitializeApplication does just what its name implies. It initializes
    global varaibles, sets up global state (e.g. 3D-Controls), registers window
    classes and creates and shows the application's main window.

Arguments:

    None.

Return Value:

    BOOL    - Returns TRUE if the application succesfully initialized.

--*/

{
    WNDCLASS    Wc;
    TCHAR       szBuffer[MAX_PATH];
    TCHAR       szBuf[400];
    int i;
    //
    // Get the application's module (instance) handle.
    //

    InitCommonControls();

    //_hModule = hInstance;
    _hModule = GetModuleHandle( NULL );
    if( _hModule == NULL ) {
        return FALSE;
    }

    //
    // Load the application's main icon resource.
    //

    _hIcon = LoadIcon( _hModule, MAKEINTRESOURCE( IDI_CHNUCONV ));
    if( _hIcon == NULL ) {
        return FALSE;
    }

    //
    // Load the application's accelerator table.
    //

    _hAccel = LoadAccelerators( _hModule, MAKEINTRESOURCE( IDA_CHNUCONV ));
    if(  _hAccel == NULL ) {
        return FALSE;
    }
    //
    // Register the window class for the application.
    //
    if (!hPrevInstance){
        Wc.style            =   CS_HREDRAW
                              | CS_OWNDC
                              | CS_SAVEBITS
                              | CS_VREDRAW;
        Wc.lpfnWndProc      = MainWndProc;
        Wc.cbClsExtra       = 0;
        Wc.cbWndExtra       = DLGWINDOWEXTRA;
        Wc.hInstance        = _hModule;
        Wc.hIcon            = _hIcon;
        Wc.hCursor          = LoadCursor( NULL, IDC_ARROW );
        Wc.hbrBackground    = ( HBRUSH ) ( COLOR_BTNFACE + 1 );
        Wc.lpszMenuName     = NULL;
        Wc.lpszClassName    = L"Converter";

        if (!RegisterClass( &Wc ))
            return FALSE;
    }

    for(i=0;i<NumCodePage;i++)
       LoadString(_hModule,IDS_STRUNICODE+i,gszCodePage[i], EXTENSION_LENGTH);

    // For different locale we will have different default initial code page
    // and differnt source and dest. dialog box.

    switch(GetACP())
    {
        case 936:
            giRBInit=IDC_RBGB;
            NumCodePage=3;
            break;
        case 950:
            giRBInit=IDC_RBBIG5;
            NumCodePage=9;
            break;
        default:
            giRBInit=IDC_RBBIG5;
            NumCodePage=9;
    }


    dlgtSourceTab=DoLockDlgRes(MAKEINTRESOURCE(IDD_SOURCE_TAB));
    dlgtOptionTab=DoLockDlgRes(MAKEINTRESOURCE(IDD_OPTION_TAB));

    //
    // Create the main window.
    //



     _hWndMain = CreateDialog ( _hModule,
                    MAKEINTRESOURCE( IDD_CHNUCONV ),
                    NULL,
                    (DLGPROC) MainWndProc,
                    );

    if( _hWndMain == NULL ) {
        return FALSE;
    }

    //
    // Set the window title.
    //

    LoadString(_hModule, IDS_APPLICATION_NAME, szBuffer, EXTENSION_LENGTH);
    lstrcpy(MBTitle, szBuffer);
    LoadString(_hModule, IDS_NBYTES,szNBytes, EXTENSION_LENGTH);
    CreateFilter(szFilter);

    SetWindowText(_hWndMain, szBuffer);
    ShowWindow( _hWndMain, SW_SHOW );



    return TRUE;
}

LRESULT
MainWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR       szBuffer[MAX_PATH];

    switch( message ) {
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            RECT rc;

            //
            // Don't waste our time if we're minimized
            //

            if (FALSE == IsIconic(hWnd))
            {
                BeginPaint(hWnd, &ps);
                GetClientRect(hWnd, &rc);

                //
                // Draw an edge just below menu bar
                //

                DrawEdge(ps.hdc, &rc, EDGE_ETCHED, BF_TOP);
                EndPaint(hWnd, &ps);
            }
            return TRUE;
        }

    case WM_CREATE:
        {
            int     ScreenHeight;
            int     ScreenWidth;
            //
            // Display the main window in the center of the screen.
            //

            ScreenWidth  = GetSystemMetrics( SM_CXSCREEN );
            ScreenHeight = GetSystemMetrics( SM_CYSCREEN );

            if(SetWindowPos(
                    hWnd,
                    NULL,
                    ( ScreenWidth  - (( LPCREATESTRUCT ) lParam )->cx )/2,
                    ( ScreenHeight - (( LPCREATESTRUCT ) lParam )->cy )/2,
                    0,
                    0,
                      SWP_NOSIZE
                    | SWP_NOREDRAW
                    | SWP_NOZORDER
                    ))

            return 0;
         }

    case WM_INITDIALOG:
         {
            //
            // Get the handle of the tab control
            //
            hMainTabControl =  GetDlgItem( hWnd, IDC_MAIN_TAB );

            //
            // Fill out tab control with appropriate tabs
            //
            MakeTabs( hWnd, hMainTabControl );


            hWndTab[0] = CreateDialogIndirect(
                    _hModule,
                    dlgtSourceTab,
                    hWnd,
                    SourceTabProc
                    );

            hWndTab[1]= CreateDialogIndirect(
                    _hModule,
                    dlgtSourceTab,
                    hWnd,
                    TargetTabProc
                    );

            hWndTab[2] = CreateDialogIndirect(
                    _hModule,
                    dlgtOptionTab,
                    hWnd,
                    OptionTabProc
                    );

            hWndDisplay=hWndTab[0];
            ShowWindow(hWndDisplay, SW_SHOW);
            return( TRUE );
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam)) {
        /******************************************************************\
        *  WM_COMMAND, IDC_PUSH_CONVERT
        *
        * This is where the conversion actually takes place.
        *  In either case, make the call twice.  Once to determine how
        *  much memory is needed, allocate space, and then make the call again.
        *
        *  If conversion succeeds, it fills pDestinationData.
        \******************************************************************/
        case IDC_PUSH_CONVERT: {
          int      nBytesNeeded, nWCharNeeded, nWCharSource;
          TCHAR    szSourceName[256];
          int      ConfirmMap;
          int i;

          GetSettings();

          SwapSource(FALSE);

          if (nBytesSource == NODATA ) {
                LoadString(_hModule,IDS_NOTEXTCONVERT,MBMessage,EXTENSION_LENGTH);
                MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
                return 0;
          }


          /* Converting UNICODE -> giDestinationCodePage*/
          if (gTypeSource == TYPEUNICODE) {

            nWCharSource = nBytesSource/2;

            /* Allocate the required amount of space, including trailing NULL */
            pTempData1= ManageMemory (MMALLOC, MMDESTINATION,
                    nBytesSource, pTempData1);

            // Map string if we need to do TC-SC conversion.
            if (gTCSCMapStatus != DONOTMAP){
                LCMapString (GetUserDefaultLCID(),gTCSCMapStatus,
                    (LPWSTR)pSourceData,nWCharSource,
                    (LPWSTR)pTempData1,nWCharSource);
            }else{
                // no conversion, just copy things over.
                memcpy(pTempData1,pSourceData,nBytesSource);
            }

            // Map string if we need to do FW-HW conversion.
            if (gFWHWMapStatus != DONOTMAP){
                pTempData= ManageMemory (MMALLOC, MMDESTINATION,
                    nBytesSource, pTempData);

                LCMapString (GetUserDefaultLCID(),gFWHWMapStatus,
                    (LPWSTR)pTempData1,nWCharSource,
                    (LPWSTR)pTempData,nWCharSource);

                memcpy(pTempData1,pTempData,nBytesSource);
            }

            /*TS/SC mapping could happen between Unicode  */
            if (gTypeDest == TYPEUNICODE){
                pDestinationData= ManageMemory (MMALLOC, MMDESTINATION,
                             nBytesSource+2, pDestinationData);
                //put mapped unicode buffer to destination buffer.
                memcpy(pDestinationData,pTempData1,nBytesSource);
                nBytesDestination=nBytesSource;

                /* Unicode Null terminate string. */
                pDestinationData[nBytesDestination] = 0;
                pDestinationData[nBytesDestination+1] = 0;

            }else{
                giDestinationCodePage=uCodepage[gTypeDestID];

                /*Query the number of bytes required to store the Dest string */
                nBytesNeeded = WideCharToMultiByte(giDestinationCodePage,
                             gWCFlags, (LPWSTR)pTempData1, nWCharSource,
                             NULL, 0,
                             glpDefaultChar, &gUsedDefaultChar);
                pDestinationData= ManageMemory (MMALLOC, MMDESTINATION,
                             nBytesNeeded +1, pDestinationData);
                /* Do the conversion */
                nBytesDestination = WideCharToMultiByte(giDestinationCodePage,
                             gWCFlags, (LPWSTR)pTempData1, nWCharSource,
                             (LPSTR)pDestinationData, nBytesNeeded,
                              glpDefaultChar, &gUsedDefaultChar);
                /* Null terminate string. */
                pDestinationData[nBytesDestination] = 0;
            }

          }


          /* converting giSourceCodePage -> UNICODE */
          else if (gTypeSource == TYPECODEPAGE && gTypeDest == TYPEUNICODE) {

            giSourceCodePage=uCodepage[gTypeSourceID];

            /* Query the number of WChar required to store the Dest string */
            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags,
                             pSourceData, nBytesSource, NULL, 0 );

            /* Allocate the required amount of space, including trailing NULL */
            pDestinationData= ManageMemory (MMALLOC, MMDESTINATION, (nWCharNeeded +1)*2, pDestinationData);

            /* Do the conversion */
            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags,
                             pSourceData, nBytesSource,
                             (LPWSTR)pDestinationData, nWCharNeeded);

            /* MultiByteToWideChar returns # WCHAR, so multiply by 2 */
            nBytesDestination = 2*nWCharNeeded ;

            // Decide if we need to do TC-SC conversion.
            if (gTCSCMapStatus != DONOTMAP) {
                pTempData1= ManageMemory (MMALLOC, MMDESTINATION, nBytesDestination, pTempData1);
                LCMapString (GetUserDefaultLCID(),gTCSCMapStatus,
                    (LPWSTR)pDestinationData,nWCharNeeded,
                    (LPWSTR)pTempData1,nWCharNeeded);
                memcpy(pDestinationData,pTempData1,nBytesDestination);
            }

            if (gFWHWMapStatus != DONOTMAP) {
                pTempData1= ManageMemory (MMALLOC, MMDESTINATION, nBytesDestination, pTempData1);
                LCMapString (GetUserDefaultLCID(),gFWHWMapStatus,
                    (LPWSTR)pDestinationData,nWCharNeeded,
                    (LPWSTR)pTempData1,nWCharNeeded);
                memcpy(pDestinationData,pTempData1,nBytesDestination);
            }
            /* Null terminate string. */
            pDestinationData[nBytesDestination]   = 0;  // UNICODE_NULL
            pDestinationData[nBytesDestination+1] = 0;



          /* converting giSourceCodePage -> giDestinationCodePage */
          } else if(gTypeSourceID < NumCodePage && gTypeDestID < NumCodePage){

            giSourceCodePage=uCodepage[gTypeSourceID];
            /* Query the number of WChar required to store the Dest string */
            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags,
                             pSourceData, nBytesSource, NULL, 0 );
            /* Allocate the required amount of space, including trailing NULL */
            pTempData= ManageMemory (MMALLOC, MMDESTINATION, (nWCharNeeded +1)*2, pTempData);
            /* Do the conversion */
            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags,
                             pSourceData, nBytesSource,
                             (LPWSTR)pTempData, nWCharNeeded);
            /* MultiByteToWideChar returns # WCHAR, so multiply by 2 */
            nBytesTemp = 2*nWCharNeeded ;

            // Decide if we need to do TC-SC conversion.
            if (gTCSCMapStatus != DONOTMAP) {
                pTempData1= ManageMemory (MMALLOC, MMDESTINATION, nBytesTemp, pTempData1);
                LCMapString (GetUserDefaultLCID(),gTCSCMapStatus,
                    (LPWSTR)pTempData,nWCharNeeded,
                    (LPWSTR)pTempData1,nWCharNeeded);
                memcpy(pTempData,pTempData1,nBytesTemp);
            }

            if (gFWHWMapStatus != DONOTMAP) {
                pTempData1= ManageMemory (MMALLOC, MMDESTINATION, nBytesTemp, pTempData1);
                LCMapString (GetUserDefaultLCID(),gFWHWMapStatus,
                    (LPWSTR)pTempData,nWCharNeeded,
                    (LPWSTR)pTempData1,nWCharNeeded);
                memcpy(pTempData,pTempData1,nBytesTemp);
            }

            /* Null terminate string. */
            pTempData[nBytesTemp]   = 0;  // UNICODE_NULL
            pTempData[nBytesTemp+1] = 0;

            giDestinationCodePage=uCodepage[gTypeDestID];
            nWCharSource = nBytesTemp/2;


            /* Query the number of bytes required to store the Dest string */
            nBytesNeeded = WideCharToMultiByte(giDestinationCodePage, gWCFlags,
                             (LPWSTR)pTempData, nWCharSource,
                             NULL, 0,
                             glpDefaultChar, &gUsedDefaultChar);

            /* Allocate the required amount of space, including trailing NULL */
            pDestinationData= ManageMemory (MMALLOC, MMDESTINATION, nBytesNeeded +1, pDestinationData);

            /* Do the conversion */
            nBytesDestination = WideCharToMultiByte(giDestinationCodePage, gWCFlags,
                             (LPWSTR)pTempData, nWCharSource,
                             pDestinationData, nBytesNeeded, glpDefaultChar, &gUsedDefaultChar);

            /* Null terminate string. */
            pDestinationData[nBytesDestination] = 0;

          } else {
                LoadString(_hModule,IDS_STYPEUNKNOWN,MBMessage,EXTENSION_LENGTH);
                MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            return 0;
          }


          /* code common to all conversions... */
          LoadString(_hModule, IDS_NOTSAVEYET, szBuffer, 50);


          TabCtrl_SetCurSel(hMainTabControl, 1);
          AdjustSelectTab(hWnd, hMainTabControl);

          SetDlgItemText (hWndTab[1], IDC_NAMETEXT, szBuffer);

          wsprintf (szBuffer, szNBytes, nBytesDestination);
          SetDlgItemText (hWndTab[1], IDC_SIZETEXT, szBuffer);
          EnableControl(hWndTab[1], IDC_OPENORSAVEAS, TRUE);
          EnableControl(hWndTab[1], IDC_VIEW, TRUE);
          EnableControl(hWndTab[1], IDC_PASTEORCOPY, TRUE);
          EnableControl(hWndTab[1], IDC_CLEAR, TRUE);
          EnableControl(hWndTab[1], IDC_SWAPHIGHLOW, TRUE);
          EnableMenuItem (GetMenu (_hWndMain),IDM_FILE_SAVEAS,MF_ENABLED);


                break; // end  case IDC_PUSH_CONVERT
                }
                case IDM_HELP_CONTENT:
                case IDC_PUSH_HELP:
                    {
                        HtmlHelp(hWnd,szHelpPathName, HH_DISPLAY_TOPIC, (DWORD_PTR) NULL );
                        break;
                    }
                case IDM_HELP_ABOUT:
                    {
                        LoadString(_hModule, IDS_APPLICATION_NAME,szBuffer,
                            EXTENSION_LENGTH);
                        ShellAbout (hWnd, szBuffer, TEXT(""), _hIcon );
                        break;
                    }
            break;
                case IDM_FILE_OPEN:
                    {
                        SendMessage(hWndTab[0], WM_COMMAND, IDC_OPENORSAVEAS,0);
                        break;
                    }

                case IDM_FILE_SAVEAS:
                    {
                        SendMessage(hWndTab[1], WM_COMMAND, IDC_OPENORSAVEAS,0);
                        break;
                    }

                case IDM_FILE_EXIT:
                case IDOK:
                    PostMessage(hWnd, WM_CLOSE, 0, 0L);
                    break;
                default:
                    return FALSE;
            }
            break;
        }

    case WM_NOTIFY:
        {
        static
        int         nPreviousTab = 1;

        // switch on notification code

        switch ( ((LPNMHDR)lParam)->code ) {

        case TCN_SELCHANGE:
            {

                AdjustSelectTab(hWnd, hMainTabControl);
                return(TRUE);
            }
        }
        break;
        }
    case WM_CLOSE:
        {
           DestroyWindow( hWnd );
           break;
        }
    case WM_DESTROY:
        {
           // WinHelp( hwnd, szHelpPathName, (UINT) HELP_QUIT, (DWORD) NULL );
            ManageMemory (MMFREE, MMDESTINATION, 0, pTempData1);
            ManageMemory (MMFREE, MMSOURCE,      0, pSourceData);
            ManageMemory (MMFREE, MMDESTINATION, 0, pDestinationData);
            ManageMemory (MMFREE, MMSOURCE,      0, pViewSourceData);
            ManageMemory (MMFREE, MMDESTINATION, 0, pTempData);
            GlobalUnlock(hglbMem);
            GlobalFree(hglbMem);


            //
            // Destroy the application.
            //
            PostQuitMessage(0);
            return 0;
        }
    default:
            break;
    }
    return DefWindowProc( hWnd, message, wParam, lParam );
}


INT_PTR
OptionTabProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {
    case WM_INITDIALOG:
        {

            RECT rcTab;

            //GetTab window size
             // first get the size of the tab control
            if (GetWindowRect( hMainTabControl, &rcTab )){
                // adjust it to compensate for the tabs
                TabCtrl_AdjustRect( hMainTabControl, FALSE , &rcTab);

                // convert the screen coordinates to client coordinates
                MapWindowPoints( HWND_DESKTOP, GetParent(hMainTabControl),
                (LPPOINT)&rcTab, 2);
            }

            SetWindowPos(hWnd, HWND_TOP,
                rcTab.left,
                rcTab.top,
                rcTab.right - rcTab.left,
                rcTab.bottom - rcTab.top,
                SWP_NOACTIVATE  );

            SendDlgItemMessage(hWnd, IDC_NOSCTCMAP, BM_SETCHECK, 1, 0);
            SendDlgItemMessage(hWnd, IDC_NOHWFWMAP, BM_SETCHECK, 1, 0);

            return(FALSE);
        }
    case WM_COMMAND:
        {
        switch (LOWORD(wParam))
        {
            case IDC_RESET  :
            {
                SendDlgItemMessage(hWnd, IDC_NOSCTCMAP, BM_SETCHECK, 1, 0);
                SendDlgItemMessage(hWnd, IDC_SCTCMAP, BM_SETCHECK, 0, 0);
                SendDlgItemMessage(hWnd, IDC_TCSCMAP, BM_SETCHECK, 0, 0);
                SendDlgItemMessage(hWnd, IDC_NOHWFWMAP, BM_SETCHECK, 1, 0);
                SendDlgItemMessage(hWnd, IDC_HWFWMAP, BM_SETCHECK, 0, 0);
                SendDlgItemMessage(hWnd, IDC_FWHWMAP, BM_SETCHECK, 0, 0);
            }
            break;
        }
        }
    default:
        break;
    }
    return DefWindowProc( hWnd, message, wParam, lParam );
}
VOID
GetSettings()
{
    int i;
    gTypeSource = TYPEUNKNOWN;

    //Get source settings.
    for(i=0;i<NumCodePage;i++)
        if (SendDlgItemMessage(hWndTab[0],IDC_RBUNICODE1+i,
                BM_GETCHECK, 0,0))
            {
               gTypeSourceID = IDC_RBUNICODE1+i-CODEPAGEBASE;
               if(i==0)
                    gTypeSource = TYPEUNICODE;
                else
                    gTypeSource = TYPECODEPAGE;
                break;
            }

            //Get target settings.
            for(i=0;i<NumCodePage;i++)
              if (SendDlgItemMessage(hWndTab[1],IDC_RBUNICODE1+i,
                    BM_GETCHECK, 0,0))
                {
                    gTypeDestID = IDC_RBUNICODE1+i-CODEPAGEBASE;
                    if(i==0)
                       gTypeDest = TYPEUNICODE;
                    else
                       gTypeDest = TYPECODEPAGE;
                    break;
                }


            //Get Option settings,
            for (i=0; i<= 2; i++)
                if (SendDlgItemMessage(hWndTab[2],IDC_NOSCTCMAP+i,
                         BM_GETCHECK, 0,0))
                {
                    switch (i) {
                        case 1:
                            gTCSCMapStatus = LCMAP_SIMPLIFIED_CHINESE;
                            break;
                        case 2:
                            gTCSCMapStatus = LCMAP_TRADITIONAL_CHINESE;
                            break;
                        default:
                            gTCSCMapStatus = DONOTMAP;
                            break;
                    }
                    break;
                }
            for (i=0; i<= 2; i++)
                if (SendDlgItemMessage(hWndTab[2],IDC_NOHWFWMAP+i,
                         BM_GETCHECK, 0,0))
                {
                    switch (i) {
                        case 1:
                            gFWHWMapStatus = LCMAP_FULLWIDTH;
                            break;
                        case 2:
                            gFWHWMapStatus = LCMAP_HALFWIDTH;
                            break;
                        default:
                            gFWHWMapStatus = DONOTMAP;
                            break;
                    }
                    break;
                }
            if(gTypeSourceID==gTypeDestID &&
               gTCSCMapStatus==DONOTMAP &&
               gFWHWMapStatus==DONOTMAP)

                if(gTypeSource == TYPEUNICODE){
                    gTypeDest = TYPECODEPAGE;
                    gTypeDestID = giRBInit-CODEPAGEBASE;
                }else{
                    gTypeDest = TYPEUNICODE;
                    gTypeDestID = IDC_RBUNICODE1-CODEPAGEBASE;
                }
        }
VOID
AdjustSelectTab(
    HWND hWnd,
    HWND hMainTabControl
)
{
                TC_ITEM tci;
                int iSel;


                iSel = TabCtrl_GetCurSel( hMainTabControl );

                //
                //get the proper index to the appropriate procs
                //that were set in MakeTabs
                //
                tci.mask = TCIF_PARAM;
                TabCtrl_GetItem(hMainTabControl, iSel, &tci);

                // Create the new child dialog box.
                ShowWindow(hWndDisplay, SW_HIDE);
                ShowWindow(hWndTab[iSel], SW_SHOW);
                if (iSel==1)
                    AdjustTargetTab();
                hWndDisplay=hWndTab[iSel];
}

BOOL
MakeTabs(
    HWND hWnd,
    HWND hMainTabControl
    )
/*++

Routine Description:

    MakeTabs fills out the Main Tab Control with appropriate tabs

Arguments:

    HWND hWnd - handle of main window
    HWND hMainTabControl - handle to the tab control

Return Value:

    BOOL - Returns TRUE if successful.

--*/
{
    TC_ITEM tci;
    TCHAR   pszTabText[30];
    int i;


    tci.mask         = TCIF_TEXT | TCIF_PARAM;
    tci.pszText      = pszTabText;
    tci.cchTextMax   = sizeof( pszTabText );
    for (i = 0; i < NUMBER_OF_PAGES; i++) {

        // Get the Tab title, the current index + the strind ID
        LoadString(_hModule, i + IDS_FIRST_TAB, tci.pszText, EXTENSION_LENGTH);

        // store the index to the procs
        tci.lParam = i;

        // insert the tab
        TabCtrl_InsertItem( hMainTabControl, i + 1, &tci );

    }
    return(TRUE);
}

DLGTEMPLATE * WINAPI
DoLockDlgRes(LPWSTR lpszResName)
/*++

Routine Description:

    DoLockDlgRes - loads and locks a dialog template resource.

Arguments:

    lpszResName - name of the resource

Return Value:

    Returns a pointer to the locked resource.

--*/
{

    HRSRC hrsrc = FindResource(NULL, lpszResName, RT_DIALOG);
    HGLOBAL hglb = LoadResource(_hModule, hrsrc);
    return (DLGTEMPLATE *) LockResource(hglb);

}
/**************************************************************************\
*
*  function:  IsUnicode()
*
* HACK... eventually use a proper function for IsUnicode
*  Use function from unipad?
*
\**************************************************************************/
BOOL IsUnicode (PBYTE pb)
{
  return (IsBOM (pb));
}



/**************************************************************************\
*
*  function:  IsBOM()
*
* true iff pb points to a Byte Order Mark.
*
\**************************************************************************/
BOOL IsBOM (PBYTE pb)
{
  if ((*pb == 0xFF) & (*(pb+1) == 0xFE))  // BOM
    return TRUE;
  else
    return FALSE;
}


/**************************************************************************\
*
*  function:  IsRBOM()
*
* true iff pb points to a reversed Byte Order Mark.
*
\**************************************************************************/
BOOL IsRBOM (PBYTE pb)
{
  if ((*pb == 0xFE) & (*(pb+1) == 0xFF))  // RBOM
    return TRUE;
  else
    return FALSE;
}

VOID CreateFilter(PTCHAR szFilterSpec )
{
    PTCHAR pszFilterSpec;

    TCHAR szAnsiText[EXTENSION_LENGTH], szAllFiles[EXTENSION_LENGTH];
    /* construct default filter string in the required format for
     * the new FileOpen and FileSaveAs dialogs
     * if you add to this, make sure CCHFILTERMAX is large enough.
     */

    LoadString(_hModule, IDS_ANSITEXT, szAnsiText, EXTENSION_LENGTH);
    LoadString(_hModule, IDS_ALLFILES, szAllFiles, EXTENSION_LENGTH);
    // .txt first for compatibility
    pszFilterSpec= szFilterSpec;
    lstrcpy( pszFilterSpec, szAnsiText );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy( pszFilterSpec, TEXT("*.txt"));
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    // and last, all files
    lstrcpy( pszFilterSpec, szAllFiles );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    lstrcpy(pszFilterSpec, TEXT("*.*") );
    pszFilterSpec += lstrlen( pszFilterSpec ) + 1;

    *pszFilterSpec = TEXT('\0');

}

LPVOID ManageMemory (UINT message, UINT sourcedestination, DWORD nBytes, LPVOID p)
{
  switch (message) {
    case MMFREE :
      if (p != NULL) GlobalFree (GlobalHandle (p));
      return NULL;
    break;

    case MMALLOC :
      if (p != NULL) GlobalFree (GlobalHandle (p));
        p = (LPVOID) GlobalAlloc (GPTR, nBytes);
        return p;
    break;

  } /* end switch (message) */
  return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\chnuconv.h ===
/**************************************************************************\
* chtuconv.h -- header file for CHT uconvert program.
*
* Function prototypes, global variables, & preprocessor defines.
*
* Copyright (C) 1992-1999 Microsoft Inc.       
*
\**************************************************************************/

#if ! defined( _CHNUCONV_ )

#define _CHNUCONV_

#include <windows.h>
#include <windowsx.h>
#include <winuserp.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <htmlhelp.h>

/**************************************************************************\
*  Function prototypes, window procedures first.
\**************************************************************************/

INT_PTR SourceTabProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR TargetTabProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR OptionTabProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR ViewSourceProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR ViewTargetProc(HWND, UINT, WPARAM, LPARAM);
DLGTEMPLATE * WINAPI DoLockDlgRes(LPWSTR);
BOOL EnableControl( IN HWND hWnd, IN int ControlId, IN BOOL Enable );
VOID GetSettings(VOID);
VOID AdjustTargetTab(VOID);
BOOL SwapSource(BOOL);
BOOL SwapDest(BOOL);

BOOL IsUnicode (PBYTE );
BOOL IsBOM (PBYTE );
BOOL IsRBOM (PBYTE );

LPVOID ManageMemory (UINT, UINT, DWORD, LPVOID);


/**************************************************************************\
*  Global variables (declared in chtuconv.c).
\**************************************************************************/

/*No convertion between Traditional Chinese and Simplified Chinese characters*/
#define DONOTMAP 0
#define NUMBER_OF_PAGES     3

extern HANDLE  _hWndMain;
extern HANDLE  _hModule;
extern HANDLE  hMainTabControl;
extern HANDLE  hWndDisplay;
extern HANDLE  hWndTab[];

/* Information specifying which is unicode and what the other code page is. */
extern int  gTypeSource;
extern int  gTypeSourceID;
extern UINT giSourceCodePage;
extern int  gTypeDest;
extern int  gTypeDestID;
extern UINT giDestinationCodePage;

/* pointers to global source & destination data, and byte count. */
extern PBYTE pViewSourceData;
extern PBYTE pTempData;
extern PBYTE pTempData1;
extern PBYTE pSourceData;
extern PBYTE pDestinationData;
extern int   nBytesSource;
extern int   nBytesDestination;
extern UINT  uCodepage[];
/* Conversion Options variables. */
extern DWORD gMBFlags;
extern DWORD gWCFlags;
extern char  glpDefaultChar[];
extern BOOL  gUsedDefaultChar;
extern BOOL gSourceSwapped;
extern BOOL gDestSwapped;

extern HGLOBAL  hglbSourceMem;
extern HGLOBAL  hglbDestMem;
extern HGLOBAL hglbMem;
extern PBYTE    p;
extern int NumCodePage;

extern DWORD gTCSCMapStatus;
extern DWORD gFWHWMapStatus;

//used Dynamically initialize default codepage according to ACP -shanxu.
extern int giRBInit;


extern char szBOM[];
extern char szRBOM[];

extern UINT  MBFlags;
extern TCHAR MBTitle[];
extern TCHAR MBMessage[];
extern TCHAR szBlank[];
extern TCHAR szNBytes[];
extern TCHAR szFilter[];

/**************************************************************************\
*  Defined constants.
\**************************************************************************/
#define SIZEOFBOM               2
#define NUM_EXTENSION_STRINGS   50
#define EXTENSION_LENGTH        200

/* Messages that can be send to ManageMemory() as first param */
#define MMALLOC 1
#define MMFREE  2
/* Messages that can be send to ManageMemory() as second param */
#define MMSOURCE       3
#define MMDESTINATION  4

/* Allowed values for the global variable gTypeSource */
#define TYPEUNKNOWN     0
#define TYPEUNICODE     1
#define TYPECODEPAGE    2
#define NODATA          0
#define DLGBORDER    GetSystemMetrics (SM_CXFRAME)*2

/* "user message."  Used by main window.  */
#define  WMU_SETCODEPAGEINFO     WM_USER +100
#define  WMU_ADJUSTFORNEWSOURCE WM_USER +101


/* Define a value for the LOGFONT.lfCharSet
 *  This should be included in wingdi.h, but it
 *  was removed because the font mapper is not
 *  using it anyway in version 1.0.  Currently
 *  scheduled to be included in NT ver 1.1.
 */
#define UNICODE_CHARSET  1

#define MAXNUMOFCODEPAGE 9

TCHAR gszExtensions[NUM_EXTENSION_STRINGS][EXTENSION_LENGTH];
TCHAR gszCodePage[MAXNUMOFCODEPAGE][EXTENSION_LENGTH];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\tgtproc.c ===
/*************************************************
 *  tgtproc.c                                    *
 *                                               *
 *  Copyright (C) 1992-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


#include "chnuconv.h"
#include "resource.h"


INT_PTR
TargetTabProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    TCHAR       szBuffer[MAX_PATH];
    int         i;
    switch( message ) {

    case WM_INITDIALOG:
        {

            RECT rcTab;

            //GetTab window size
             // first get the size of the tab control
            if (GetWindowRect( hMainTabControl, &rcTab )){
                // adjust it to compensate for the tabs
                TabCtrl_AdjustRect( hMainTabControl, FALSE , &rcTab);

                // convert the screen coordinates to client coordinates
                MapWindowPoints( HWND_DESKTOP, GetParent(hMainTabControl),
                (LPPOINT)&rcTab, 2);
            }

            SetWindowPos(hWnd, HWND_TOP,
                rcTab.left,
                rcTab.top,
                rcTab.right - rcTab.left,
                rcTab.bottom - rcTab.top,
                SWP_NOACTIVATE  );

            LoadString(_hModule, IDS_BUT_SAVEAS, szBuffer, EXTENSION_LENGTH);
            SetDlgItemText(hWnd,IDC_OPENORSAVEAS, szBuffer);

            LoadString(_hModule, IDS_BUT_TOCLIPBOARD,szBuffer,EXTENSION_LENGTH);
            SetDlgItemText(hWnd, IDC_PASTEORCOPY, szBuffer);

            for (i=0;i<NumCodePage;i++)
            {
               LoadString(_hModule, IDS_CTLUNICODE+i,szBuffer,EXTENSION_LENGTH);
               ShowWindow(GetDlgItem(hWnd, IDC_RBUNICODE1+i), SW_SHOW);
               SetDlgItemText(hWnd, IDC_RBUNICODE1+i, szBuffer);
            }
            SendMessage(hWnd, WM_COMMAND, IDC_CLEAR, 0);
            return(FALSE);
        }
    case WM_COMMAND:
       {
        switch(wParam){
        /******************************************************************\
        *  WM_COMMAND, IDC_OPENORSAVEAS
        *
        * Put up common dialog, try to open file, and write data to it.
        \******************************************************************/
        case IDC_OPENORSAVEAS:
            {
          HANDLE hFile;
          DWORD nBytesRead;
          TCHAR szFile[MAX_PATH],szFileTitle[MAX_PATH];
          TCHAR szDefExt[4];
          OPENFILENAME OpenFileName;
          /* buffers for the file names. */

          if (nBytesDestination == NODATA ) {
            LoadString(_hModule,IDS_NOTEXTSAVE,MBMessage,EXTENSION_LENGTH);
            MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            return 0;
          }

           //see if user selects swap destination
           SwapDest(FALSE);

          /* Set up the structure for the GetSaveFileName
           *  common dialog.
           */

            lstrcpy(szDefExt, TEXT("txt") );

            wsprintf (szFile, szBlank);
            wsprintf (szFileTitle, szBlank);

            OpenFileName.lStructSize       = sizeof(OPENFILENAME);
            OpenFileName.hwndOwner         = hWnd;
            OpenFileName.hInstance      = (HANDLE) _hModule;
            OpenFileName.lpstrFilter       = szFilter;
            OpenFileName.lpstrCustomFilter = NULL;
            OpenFileName.nMaxCustFilter    = 0L;
            OpenFileName.nFilterIndex      = 1L;
            OpenFileName.lpstrFile         = szFile;
            OpenFileName.nMaxFile          = MAX_PATH;
            OpenFileName.lpstrFileTitle    = szFileTitle;
            OpenFileName.nMaxFileTitle     = MAX_PATH;
            OpenFileName.lpstrInitialDir   = NULL;
            LoadString(_hModule, IDS_SAVEAS, szBuffer, 50);
            OpenFileName.lpstrTitle        = szBuffer;

            OpenFileName.nFileOffset       = 0;
            OpenFileName.nFileExtension    = 0;
            OpenFileName.lpstrDefExt       = szDefExt;

            OpenFileName.lCustData         = 0;
            OpenFileName.lpfnHook          = NULL;
            OpenFileName.lpTemplateName    = NULL;

            OpenFileName.Flags = OFN_HIDEREADONLY;

            if (!GetSaveFileName(&OpenFileName)) return 0;


          /* User has filled in the file information.
           *  Try to open that file for writing.
           */
          hFile = CreateFile(szFile,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

          if (hFile == INVALID_HANDLE_VALUE) {
            LoadString(_hModule,IDS_CREATEERROR,MBMessage,EXTENSION_LENGTH);
            MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            return 0;
          }


          /* if destination is unicode, try to write BOM first.
           *  unless the bytes have been swapped
           *  (criterion: hwndByteOrder contains text)
           *  in which case, write a Reverse Byte Order Mark.
           */
          if (gTypeDest   == TYPEUNICODE)
            if (!SendDlgItemMessage(hWndTab[1],IDC_SWAPHIGHLOW,
                    BM_GETCHECK, 0, 0)){

              if (!WriteFile (hFile, szBOM, SIZEOFBOM, &nBytesRead, NULL)) {
                LoadString(_hModule,IDS_WRITEERROR,MBMessage,EXTENSION_LENGTH);
                MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
                CloseHandle (hFile);
                return 0;
              }
            }
            else
            {
              if (!WriteFile (hFile, szRBOM, SIZEOFBOM, &nBytesRead, NULL)) {
                LoadString(_hModule,IDS_WRITEERROR,MBMessage,EXTENSION_LENGTH);
                MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
                CloseHandle (hFile);
                return 0;
              }
            }


          /* try to write all of it into memory */
          if (!WriteFile (hFile, pDestinationData,nBytesDestination, &nBytesRead, NULL)) {
                LoadString(_hModule,IDS_WRITEERROR,MBMessage,EXTENSION_LENGTH);
                MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            CloseHandle (hFile);
            return 0;
          }

          SetDlgItemText (hWnd,IDC_NAMETEXT,szFile);
          CloseHandle (hFile);
         break;
            }
         case IDC_VIEW:
            {
                 SwapDest(FALSE);
                 if (gTypeDest == TYPEUNICODE)
                    DialogBoxW (_hModule, MAKEINTRESOURCEW(IDD_SHOWTEXT), hWnd,
                                ViewTargetProc);
                  else
                    DialogBoxA (_hModule, MAKEINTRESOURCEA(IDD_SHOWTEXT), hWnd,
                                ViewTargetProc);
                break;
            }
        /**********************************************************************\
        *  WM_COMMAND, IDC_CLEAR
        *
        * Clear the SOURCE information.  May cause data to be lost.
        \**********************************************************************/
        case IDC_CLEAR:
            {
                int i;
                SetDlgItemText (hWnd, IDC_NAMETEXT, szBlank);
                SetDlgItemText (hWnd, IDC_SIZETEXT, szBlank);
                for(i=0;i<NumCodePage;i++)
                   SendDlgItemMessage(hWnd,IDC_RBUNICODE1+i, BM_SETCHECK, 0,0);

                pDestinationData= ManageMemory (MMFREE, MMSOURCE, 0, pDestinationData);
                nBytesDestination=0;
                pTempData1= ManageMemory (MMFREE, MMDESTINATION, 0, pTempData1);
                EnableControl(hWnd, IDC_VIEW, FALSE);
                EnableControl(hWnd, IDC_PASTEORCOPY, FALSE);
                EnableControl(hWnd, IDC_OPENORSAVEAS, FALSE);
                EnableControl(hWnd, IDC_CLEAR, FALSE);
                EnableControl(hWnd, IDC_SWAPHIGHLOW, FALSE);
                SendDlgItemMessage (hWnd,IDC_SWAPHIGHLOW, BM_SETCHECK, 0, 0);

                // set gDestSwapped as FALSE

                gDestSwapped = FALSE;

                EnableMenuItem (GetMenu (_hWndMain),IDM_FILE_SAVEAS,MF_GRAYED);
                  break;
            }
        /**********************************************************************\
        *  WM_COMMAND, IDC_PASTEORCOPY
        *
        * Copy destination data to the clipboard.
        \**********************************************************************/
        case IDC_PASTEORCOPY:
         {
          int i;
          if (pDestinationData == NULL) return FALSE;

          //see if user selects swap hi-low byte order
          SwapDest(FALSE);

          OpenClipboard (hWnd);
          if( EmptyClipboard()  ) {
              GlobalUnlock(hglbMem);
              GlobalFree(hglbMem);
              hglbMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE,
                                     nBytesDestination+40);
              p=(PBYTE)GlobalLock(hglbMem);
              for(i=0;i<nBytesDestination;i++)
                    *(p+i)=*(pDestinationData+i);
              *(p+i)=0;
             //if source NOT unicode, destination is, else look at dest CP
              if (gTypeDest   == TYPEUNICODE) {
                *(p+i+1)=0;
                GlobalUnlock(hglbMem);
                SetClipboardData (CF_UNICODETEXT, hglbMem);
              }
              else {
                GlobalUnlock(hglbMem);
                if (gTypeDestID == giRBInit-CODEPAGEBASE)
                        SetClipboardData (CF_TEXT, hglbMem);
                     else
                        SetClipboardData (CF_OEMTEXT, hglbMem);
              }
          }
          CloseClipboard ();
        }
        break;

        }
     }


     default:
        break;
    }
    return DefWindowProc( hWnd, message, wParam, lParam );
}

/***************************************************************************\
*    FUNCTION: ViewTargetProc
*
* Fill Text, Name, and Type information into the dialog.
*  Set a proper font to display the text depending on what type it is.
*
\***************************************************************************/

INT_PTR
ViewTargetProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
RECT rect;

  switch (message) {

    /******************************************************************\
    *  WM_INITDIALOG
    \******************************************************************/
    case WM_INITDIALOG:
        {

      GetSettings();

      // Text is unicode... use *W() variants of functions.
      if (gTypeDest == TYPEUNICODE) {
        WCHAR szBuffer[MAX_PATH];

        SetDlgItemTextW (hWnd, IDC_SHOWTEXT_EDIT, (LPCWSTR)pDestinationData);
        GetDlgItemTextW (hWndTab[1], IDC_NAMETEXT, szBuffer, MAX_PATH);
        SetDlgItemTextW (hWnd, IDC_SHOWTEXT_NAME, szBuffer);
        LoadStringW(_hModule, gTypeDestID+STRCODEPAGEBASE, szBuffer,EXTENSION_LENGTH);
        SetDlgItemTextW (hWnd, IDC_SHOWTEXT_TYPE, szBuffer);

      // Text is codepage... use *A() variants of functions.
      } else {
        char szBuffer[MAX_PATH];

        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_EDIT, (LPCSTR)pDestinationData);
        GetDlgItemTextA (hWndTab[1], IDC_NAMETEXT, szBuffer, MAX_PATH);
        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_NAME, szBuffer);
        LoadStringA(_hModule, gTypeDestID+STRCODEPAGEBASE, szBuffer,EXTENSION_LENGTH);
        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_TYPE, szBuffer);
      }
      LoadString(_hModule, IDS_VIEWTARGET, &gszExtensions[11][0], EXTENSION_LENGTH);
      SetWindowText (hWnd,&gszExtensions[11][0] );
      GetClientRect (hWnd, &rect);
      SendMessage (hWnd, WM_SIZE, 0,
                 MAKELPARAM ((rect.right - rect.left), (rect.bottom - rect.top)));
    return TRUE;
        }
    case WM_SIZE: {
      HWND hwndText;
      HWND hwndNotice;
      RECT rc;
      POINT pt;

      hwndNotice = GetDlgItem (hWnd,IDC_SHOWTEXT_FONT);
      GetWindowRect(hwndNotice,&rc);
      pt.x = 0;
      pt.y = rc.bottom;
      ScreenToClient(hWnd, &pt);

      hwndText = GetDlgItem (hWnd, IDC_SHOWTEXT_EDIT);

      MoveWindow (hwndText, DLGBORDER, pt.y+5, (int) LOWORD(lParam) - 2*DLGBORDER,
                                (int) HIWORD(lParam) - (pt.y+5) - DLGBORDER , TRUE);
    }
    break;

    case WM_COMMAND:
      switch (LOWORD (wParam)) {
        case IDCANCEL:
        case IDOK:
          EndDialog (hWnd, TRUE);
      }
    break; /* end WM_COMMAND */

    case WM_SYSCOMMAND:
      if (LOWORD (wParam) == SC_CLOSE)
          EndDialog (hWnd, FALSE);
    break;

  } /* end switch */
  return FALSE;
}
BOOL
SwapDest(
BOOL bForceSwap
)
{
          int i, end;
          BYTE temp;

          if (pDestinationData == NULL) return FALSE;

          //Is the Destination already swapped?
          if (SendDlgItemMessage(hWndTab[1], IDC_SWAPHIGHLOW,
                    BM_GETCHECK,0,0) == gDestSwapped && !bForceSwap)
                return FALSE;

          end =  nBytesDestination - 2;
          for (i = 0; i<= end; i+=2) {
            temp             = pDestinationData[i];
            pDestinationData[i]   = pDestinationData[i+1];
            pDestinationData[i+1] = temp;
          }
          //set flag that source has been swapped;
          gDestSwapped = 1 - gDestSwapped;

          return TRUE;
}

VOID
AdjustTargetTab()
{
            int i;

            GetSettings();
            //if user change swap option in source tab, we'd better reset dest.
            if (SendDlgItemMessage(hWndTab[0], IDC_SWAPHIGHLOW,
                BM_GETCHECK, 0,0) != gSourceSwapped)
                SendMessage(hWndTab[1], WM_COMMAND, IDC_CLEAR,0);

            //Do we have a source yet?
            if(IsWindowEnabled(GetDlgItem(hWndTab[0], IDC_VIEW))){
                for (i=0;i<NumCodePage;i++){
                    EnableControl(hWndTab[1], i+CODEPAGEBASE, TRUE);
                    SendDlgItemMessage (hWndTab[1],i+CODEPAGEBASE,
                        BM_SETCHECK, 0, 0);
                }

                if (gTCSCMapStatus==DONOTMAP && gFWHWMapStatus==DONOTMAP)
                    EnableControl(hWndTab[1], gTypeSourceID+CODEPAGEBASE,FALSE);

                SendDlgItemMessage (hWndTab[1],gTypeDestID+CODEPAGEBASE,
                        BM_SETCHECK, 1, 0);
            }
}

BOOL
EnableControl(
    IN HWND hWnd,
    IN int ControlId,
    IN BOOL Enable
    )

/*++

Routine Description:

    Enable or diable the specified control based on the supplied flag.

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control.
    ControlId   - Supplies the control id.
    Enable      - Supplies a flag which if TRUE causes the control to be enabled
                  and disables the control if FALSE.

Return Value:

    BOOL        - Returns TRUE if the control is succesfully enabled / disabled.

--*/

{
    HWND    hWndControl;
    BOOL    Success;

    hWndControl = GetDlgItem( hWnd, ControlId );
    if( hWndControl == NULL ) {
        return FALSE;
    }

    if( Enable == IsWindowEnabled( hWndControl )) {
      return TRUE;
  }

  Success = EnableWindow( hWndControl, Enable );
  return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=shell
MINORCOMP=accesories

TARGETNAME=chnuconv
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM
TARGETLIBS=

INCLUDES=..;$(WINDOWS_INC_PATH)

C_DEFINES=-DWIN32 -DW3 -DUNICODE -D_UNICODE

SOURCES= ..\chnuconv.rc \
         ..\chnuconv.c \
         ..\tgtproc.c \
         ..\srcproc.c

UMTYPE=windows
UMENTRY=winmain
UMLIBS= $(SDK_LIB_PATH)\comdlg32.lib  \
        $(SDK_LIB_PATH)\ntdll.lib \
        $(SDK_LIB_PATH)\user32.lib         \
        $(SDK_LIB_PATH)\advapi32.lib      \
        $(SDK_LIB_PATH)\comctl32.lib      \
        $(SDK_LIB_PATH)\shell32.lib       \
        $(SDK_LIB_PATH)\htmlhelp.lib
       
MISCFILES=chnuconv.chm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\resource.h ===
/*************************************************
 *  resource.c                                   *
 *                                               *
 *  Copyright (C) 1992-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by UCONVERT.RC
//

#define IDS_FIRST_TAB                   IDS_SOURCE_TAB                  
#define STRCODEPAGEBASE                 IDS_STRUNICODE

#define IDS_APPLICATION_NAME            1
#define IDS_SOURCE_TAB                  5
#define IDS_TARGET_TAB                  6
#define IDS_OPTION_TAB                  7
#define IDS_STRUNICODE                  10
#define IDS_STRINGGB                    11
#define IDS_STRBIG5                     12 
#define IDS_STRCNS                      13
#define IDS_STRTCA                      14
#define IDS_STRETEN                     15
#define IDS_STRIBM                      16
#define IDS_STRTELE                     17
#define IDS_STRWANG                     18

#define IDS_CTLUNICODE                  20
#define IDS_CTLGB                       21
#define IDS_CTLBIG5                     22
#define IDS_CTLCNS                      23
#define IDS_CTLTCA                      24
#define IDS_CTLETEN                     25
#define IDS_CTLIBM                      26
#define IDS_CTLTELE                     27
#define IDS_CTLWANG                     28

#define IDS_FROMCLIPBOARD               30
#define IDS_NOTSAVEYET                  32
#define IDS_OPENSOURCE                  33
#define IDS_SAVEAS                      34
#define IDS_FILETOOBIG                  35
#define IDS_OPENERROR                   36
#define IDS_READERROR                   37
#define IDS_BYTEORDER                   38
#define IDS_WRITEERROR                  39
#define IDS_CREATEERROR                 40 
#define IDS_NOTEXTCONVERT               41
#define IDS_NOTEXTSAVE                  42
#define IDS_STYPEUNKNOWN                43
#define IDS_NBYTES                      44
#define IDS_VIEWSOURCE                  45
#define IDS_VIEWTARGET                  46
#define IDS_BUT_FROMCLIPBOARD           47
#define IDS_BUT_TOCLIPBOARD             48
#define IDS_BUT_OPEN                    49
#define IDS_BUT_SAVEAS                  50
#define IDS_ANSITEXT                    51
#define IDS_ALLFILES                    52

#define IDM_FILE_OPEN                   2001
#define IDM_FILE_SAVEAS                 2002 
#define IDM_FILE_EXIT                   2010
#define IDM_HELP_CONTENT                2101
#define IDM_HELP_ABOUT                  2102

#define IDM_CHNUCONV                    1234

#define IDA_CHNUCONV                    100

#define IDD_CHNUCONV                    100
#define IDD_SOURCE_TAB                  200
#define IDD_OPTION_TAB                  400
#define IDD_SHOWTEXT                    500


#define IDI_CHNUCONV                    300

#define IDC_MAIN_TAB                    150
#define IDC_PUSH_CONVERT                200
#define IDC_PUSH_HELP                   210 
#define IDC_NAME                        1000
#define IDC_NAMETEXT                    1001
#define IDC_EDIT_SIZE                   1002
#define IDC_SIZETEXT                    1003
#define IDC_OPENORSAVEAS                1004
#define IDC_VIEW                        1005
#define IDC_PASTEORCOPY                 1006
#define IDC_CLEAR                       1007
#define IDC_SWAPHIGHLOW                 1008
#define IDC_STATIC                      1009
#define IDC_STATIC1                     1010
#define IDC_STATIC2                     1011
#define IDC_NOSCTCMAP                   1012
#define IDC_TCSCMAP                     1013
#define IDC_SCTCMAP                     1014
#define IDC_NOHWFWMAP                   1015
#define IDC_HWFWMAP                     1016
#define IDC_FWHWMAP                     1017
#define IDC_COPY                        1018
#define IDC_SAVEAS                      1019
#define IDC_RESET                       1020
#define IDC_SHOWTEXT_NAME               1021 
#define IDC_SHOWTEXT_TYPE               1022
#define IDC_SHOWTEXT_FONT               1023
#define IDC_SHOWTEXT_EDIT               1024


#define CODEPAGEBASE                    1500

#define IDC_RBUNICODE1                  1500
#define IDC_RBGB                        1501
#define IDC_RBBIG5                      1502
#define IDC_RBCNS                       1503
#define IDC_RBTCA                       1504
#define IDC_RBETEN                      1505
#define IDC_RBIBM                       1506
#define IDC_RBTELE                      1507
#define IDC_RBWANG                      1508


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chnuconv\srcproc.c ===
/*************************************************
 *  srcproc.c                                    *
 *                                               *
 *  Copyright (C) 1992-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/



#include "chnuconv.h"
#include "resource.h"


INT_PTR
SourceTabProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    TCHAR szBuffer[50];
    int i;
    switch( message ) {

    case WM_INITDIALOG:
        {

            RECT rcTab;

            //GetTab window size
             // first get the size of the tab control
            if (GetWindowRect( hMainTabControl, &rcTab )){
                // adjust it to compensate for the tabs
                TabCtrl_AdjustRect( hMainTabControl, FALSE , &rcTab);

                // convert the screen coordinates to client coordinates
                MapWindowPoints( HWND_DESKTOP, GetParent(hMainTabControl),
                (LPPOINT)&rcTab, 2);
            }

            SetWindowPos(hWnd, HWND_TOP,
                rcTab.left,
                rcTab.top,
                rcTab.right - rcTab.left,
                rcTab.bottom - rcTab.top,
                SWP_NOACTIVATE  );
            LoadString(_hModule, IDS_BUT_OPEN, szBuffer, EXTENSION_LENGTH);
            SetDlgItemText(hWnd,IDC_OPENORSAVEAS, szBuffer);

            LoadString(_hModule, IDS_BUT_FROMCLIPBOARD,szBuffer,EXTENSION_LENGTH);
            SetDlgItemText(hWnd, IDC_PASTEORCOPY, szBuffer);

            for (i=0;i<NumCodePage;i++)
            {
               LoadString(_hModule, IDS_CTLUNICODE+i,szBuffer,EXTENSION_LENGTH);
               ShowWindow(GetDlgItem(hWnd, IDC_RBUNICODE1+i), SW_SHOW);
               SetDlgItemText(hWnd, IDC_RBUNICODE1+i, szBuffer);
            }


            return(FALSE);
        }
    case WM_COMMAND:
        {
        switch (LOWORD(wParam)) {
            case IDC_OPENORSAVEAS  : {
                HANDLE hFile;
                DWORD nBytesRead;
                TCHAR szFile[MAX_PATH],szFileTitle[MAX_PATH];

                /* First set up the structure for the GetOpenFileName
                 *  common dialog.
                 */

                OPENFILENAME OpenFileName;
                /* buffers for the file names. */


                wsprintf (szFile, szBlank);
                wsprintf (szFileTitle, szBlank);

                
                OpenFileName.lStructSize       = sizeof(OPENFILENAME);
                OpenFileName.hwndOwner         = hWnd;
                OpenFileName.hInstance         = (HANDLE) _hModule;
                OpenFileName.lpstrFilter       = szFilter; // built in WM_CREATE
                OpenFileName.lpstrCustomFilter = NULL;
                OpenFileName.nMaxCustFilter    = 0L;
                OpenFileName.nFilterIndex      = 1L;
                OpenFileName.lpstrFile         = szFile;
                OpenFileName.nMaxFile          = MAX_PATH;
                OpenFileName.lpstrFileTitle    = szFileTitle;
                OpenFileName.nMaxFileTitle     = MAX_PATH;
                OpenFileName.lpstrInitialDir   = NULL;

                LoadString(_hModule, IDS_OPENSOURCE, szBuffer, 50);
                OpenFileName.lpstrTitle        = szBuffer;


                OpenFileName.nFileOffset       = 0;
                OpenFileName.nFileExtension    = 0;
                OpenFileName.lpstrDefExt       = NULL;

                OpenFileName.lCustData         = 0;
                OpenFileName.lpfnHook          = NULL;
                OpenFileName.lpTemplateName    = NULL;

                OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

                if (!GetOpenFileName(&OpenFileName)) return 0;

                SendMessage (hWnd, WM_COMMAND, IDC_CLEAR, 0);

                /* User has filled in the file information.
                 *  Try to open that file for reading.
                 */
                hFile = CreateFile(szFile,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

              if (hFile == INVALID_HANDLE_VALUE) {
                    LoadString(_hModule,IDS_OPENERROR,MBMessage,EXTENSION_LENGTH);
                    MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
                    return 0;
              }

              /* make sure file is not too big... i.e. > 2^32
               *  If it is OK, write the file size in hwndSize0
               */
              {
                  DWORD dwHigh;
                  DWORD dwLow;
              dwLow = GetFileSize(hFile,&dwHigh);

         	  if ((dwHigh > 0) || (dwLow == 0xFFFFFFFF && GetLastError() != NO_ERROR))
              {
                  LoadString(_hModule,IDS_FILETOOBIG,MBMessage,EXTENSION_LENGTH);
                  MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
                  CloseHandle (hFile);
                  return 0;
               }

                nBytesSource= dwLow;

          }

          /* Allocate space for string, including potential UNICODE_NULL */
          pSourceData = ManageMemory (MMALLOC, MMSOURCE, nBytesSource +2, pSourceData);
          if (pSourceData == NULL) {
            CloseHandle (hFile);
            return 0;
          }

          /* first read two bytes and look for BOM */
          if (!ReadFile (hFile, pSourceData,SIZEOFBOM, &nBytesRead, NULL)) {
            LoadString(_hModule,IDS_READERROR,MBMessage,EXTENSION_LENGTH);
            MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            CloseHandle (hFile);
            pSourceData = ManageMemory (MMFREE, MMSOURCE, 0, pSourceData);
            return 0;
          }



          /* If file begins with BOM, then we know the type,
           *  we'll decrement the number of bytes by two,
           *  and read the rest of the data.
           */
          if (IsBOM (pSourceData)) {
            gTypeSource = TYPEUNICODE;
            gTypeSourceID = IDC_RBUNICODE1-CODEPAGEBASE;
            gTypeDest   = TYPECODEPAGE;
            gTypeDestID   = giRBInit-CODEPAGEBASE;
            nBytesSource -=SIZEOFBOM;

          /* If file begins with Reverse BOM, then we know the type,
           *  we'll decrement the number of bytes by two,
           *  and read the rest of the data, and post a message so
           *  that we know to swap the order later.
           */
          } else if (IsRBOM (pSourceData)) {
            gTypeSource = TYPEUNICODE;
            gTypeSourceID = IDC_RBUNICODE1-CODEPAGEBASE;
            gTypeDest   = TYPECODEPAGE;
            gTypeDestID   = giRBInit-CODEPAGEBASE;

            nBytesSource -=SIZEOFBOM;
            LoadString(_hModule,IDS_BYTEORDER,MBMessage,EXTENSION_LENGTH);
            MessageBox (hWnd, MBMessage,MBTitle, MBFlags);

            SwapSource(TRUE);

          /* Oops, does not begin with BOM.
           *  Reset file pointer, and read data.
           */
          } else {
            gTypeSource = TYPEUNKNOWN;
            SetFilePointer (hFile, -SIZEOFBOM, NULL, FILE_CURRENT);
          }


          /* try to read all of it into memory */
          if (!ReadFile (hFile, pSourceData,nBytesSource, &nBytesRead, NULL)) {
            LoadString(_hModule,IDS_READERROR,MBMessage,EXTENSION_LENGTH);
            MessageBox (hWnd, MBMessage,MBTitle, MBFlags);
            CloseHandle (hFile);
            pSourceData = ManageMemory (MMFREE, MMSOURCE, 0, pSourceData);
            return 0;
          }

          CloseHandle (hFile);

          /* If we don't know the file type at this point,
           *  try to determine if it is unicode.
           */
          if (gTypeSource == TYPEUNKNOWN) {
              gTypeSource   = TYPECODEPAGE;
              gTypeSourceID = giRBInit-CODEPAGEBASE;
              gTypeDest     = TYPEUNICODE;
              gTypeDestID   = IDC_RBUNICODE1-CODEPAGEBASE;
              pSourceData[nBytesSource] = 0;
          }

            SendMessage (hWnd, WMU_ADJUSTFORNEWSOURCE, 0, (LPARAM)szFile);
            break;
        }
        /**********************************************************************\
        *  WM_COMMAND, IDC_CLEAR
        *
        * Clear the SOURCE information.  May cause data to be lost.
        \**********************************************************************/
        case IDC_CLEAR:
            {
                SetDlgItemText (hWnd, IDC_NAMETEXT, szBlank);
                SetDlgItemText (hWnd, IDC_SIZETEXT, szBlank);
                for(i=0;i<NumCodePage;i++){
                   SendDlgItemMessage(hWnd,IDC_RBUNICODE1+i, BM_SETCHECK, 0,0);
                   EnableControl(hWnd, IDC_RBUNICODE1+i, FALSE);
                   SendDlgItemMessage(hWndTab[1],IDC_RBUNICODE1+i, BM_SETCHECK, 0,0);
                   EnableControl(hWndTab[1], IDC_RBUNICODE1+i, FALSE);
                }

                pSourceData= ManageMemory (MMFREE, MMSOURCE, 0, pSourceData);
                pViewSourceData= ManageMemory (MMFREE, MMSOURCE, 0,pViewSourceData);
                nBytesSource=0;
                pTempData1= ManageMemory (MMFREE, MMDESTINATION, 0, pTempData1);
                EnableControl(hWnd, IDC_VIEW, FALSE);
                EnableControl(hWnd, IDC_CLEAR, FALSE);
                SendDlgItemMessage (hWnd,IDC_SWAPHIGHLOW, BM_SETCHECK, 0, 0);

             // set the gSourceSwapped as FALSE;

                gSourceSwapped = FALSE;

                EnableControl(hWnd, IDC_SWAPHIGHLOW, FALSE);
                EnableControl(_hWndMain, IDC_PUSH_CONVERT, FALSE);

                SendMessage (hWndTab[1], WM_COMMAND, IDC_CLEAR, 0);

                  break;
            }
        /**********************************************************************\
        *  WM_COMMAND, IDC_PASTEORCOPY
        *
        * Paste the clipboard's prefered data format into the source.
        *  Fills pSourceData.
        \**********************************************************************/
        case IDC_PASTEORCOPY: {
          UINT  iFormat;
          LPBYTE pData,pMyData;
          BOOL bClipBoardEmpty=TRUE;

          OpenClipboard (hWnd);

          iFormat = 0;
          while (iFormat = EnumClipboardFormats(iFormat))
            if ((iFormat == CF_UNICODETEXT) || (iFormat == CF_OEMTEXT) || (iFormat == CF_TEXT)) {

              bClipBoardEmpty=FALSE;

              pData = GetClipboardData (iFormat);
              pMyData = GlobalLock(pData);

              switch (iFormat) {
                case CF_UNICODETEXT:
                   {
                    int i=0;
                    while( *((LPWORD)(pMyData)+i)!=0) i++;
                    nBytesSource = i*2;
                  }
                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+2, pSourceData);
                  lstrcpyW ((LPVOID)pSourceData, (LPVOID)pMyData);
                  gTypeSource = TYPEUNICODE;
                  gTypeSourceID = IDC_RBUNICODE1-CODEPAGEBASE;
                  gTypeDest = TYPECODEPAGE;
                  gTypeDestID = giRBInit-CODEPAGEBASE;

                break;

                case CF_OEMTEXT:

                   {
                    int i=0;
                    while( *((char*)pMyData+i)!=0) i++;
                    nBytesSource = i;
                  }

                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+1, pSourceData);
                  lstrcpyA (pSourceData, pMyData);
                  gTypeSource = TYPECODEPAGE;
                  gTypeSourceID = giRBInit-CODEPAGEBASE;
                  gTypeDest = TYPEUNICODE;
                  gTypeDestID = IDC_RBUNICODE1-CODEPAGEBASE;
                break;

                case CF_TEXT:
                   {
                    int i=0;
                    while( *((char*)pMyData+i)!=0) i++;
                    nBytesSource = i;
                  }
                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+1, pSourceData);
                  lstrcpyA (pSourceData, pMyData);
                  gTypeSource = TYPECODEPAGE;
                  gTypeSourceID = giRBInit-CODEPAGEBASE;
                  gTypeDest = TYPEUNICODE;
                  gTypeDestID = IDC_RBUNICODE1-CODEPAGEBASE;
                break;

                  default: break;  // shouldn't get here
                } /* end switch (iFormat) */

                GlobalUnlock(pData);

                  break;  /* break out of while loop. */
              } /* end if iFormat */

              if (!bClipBoardEmpty)
              {
                  LoadString(_hModule, IDS_FROMCLIPBOARD, szBuffer, 50);
                  SendMessage (hWnd, WMU_ADJUSTFORNEWSOURCE, 0, (LPARAM)szBuffer);
              }
              else
              {
                  MessageBeep(0xFFFFFFFF);
              }

              CloseClipboard ();
              break;

            }
         case IDC_VIEW:
            {
                 //See if user wants to swap source
                 SwapSource(FALSE);

                 if (gTypeSource == TYPEUNICODE)
                    DialogBoxW (_hModule, MAKEINTRESOURCEW(IDD_SHOWTEXT), hWnd,
                                ViewSourceProc);
                  else
                    DialogBoxA (_hModule, MAKEINTRESOURCEA(IDD_SHOWTEXT), hWnd,
                                ViewSourceProc);
                break;
            }


         default:
            break;

        }
        break;
        }
    /**********************************************************************\
    *  WMU_ADJUSTFORNEWSOURCE
    *
    * lParam - szName of source (file, clipboard, ...)
    *
    * global - nBytesSource
    *
    * "user message."  Set the text of the Source windows
    \**********************************************************************/
    case WMU_ADJUSTFORNEWSOURCE:
        {

            LPVOID szName;
            szName = (LPVOID) lParam;

            // Set Window text appropriately
            wsprintf (szBuffer, szNBytes, nBytesSource);
            SetDlgItemText (hWnd, IDC_NAMETEXT, szName);
            SetDlgItemText (hWnd, IDC_SIZETEXT, szBuffer);

            // Clear the destination data if any to avoid user confusion.
            SendMessage (hWndTab[1], WM_COMMAND, IDC_CLEAR, 0);
            SendMessage (hWnd, WMU_SETCODEPAGEINFO, 0,0);
            EnableControl(hWnd, IDC_VIEW, TRUE);
            EnableControl(hWnd, IDC_SWAPHIGHLOW, TRUE);
            EnableControl(hWnd, IDC_CLEAR, TRUE);
            EnableControl(_hWndMain, IDC_PUSH_CONVERT, TRUE);

            break;
       }
   /**********************************************************************\
   *  WMU_SETCODEPAGEINFO
   *
   * "user message."  Set the text of the "type" windows to reflect
   *  the state stored in gTypeSource and gi*CodePage.
   *
   \**********************************************************************/
   case WMU_SETCODEPAGEINFO:
        {
            for (i=0;i<NumCodePage;i++){
                EnableControl (hWnd,IDC_RBUNICODE1+i, TRUE);
                EnableControl (hWndTab[1],IDC_RBUNICODE1+i, TRUE);
                SendDlgItemMessage (hWnd,IDC_RBUNICODE1+i, BM_SETCHECK, 0, 0);
            }

            SendDlgItemMessage (hWnd, gTypeSourceID+CODEPAGEBASE,BM_SETCHECK, 1, 0);

            break;
        }
    }
    return DefWindowProc( hWnd, message, wParam, lParam );
}



/***************************************************************************\
*    FUNCTION: ViewSourceProc
*
* Fill Text, Name, and Type information into the dialog.
*  Set a proper font to display the text depending on what type it is.
*
\***************************************************************************/
INT_PTR ViewSourceProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
RECT rect;

  switch (message) {

    /******************************************************************\
    *  WM_INITDIALOG
    \******************************************************************/
    case WM_INITDIALOG:
        {
        LOGFONTW logfont;
        HFONT hFont;

      GetSettings();

      /* Text is unicode... use *W() variants of functions. */
      if (gTypeSource == TYPEUNICODE) {
        WCHAR szBuffer[MAX_PATH];

        SetWindowTextW (GetDlgItem(hWnd, IDC_SHOWTEXT_EDIT), (LPCWSTR)pSourceData);
        GetDlgItemTextW (hWndTab[0], IDC_NAMETEXT, szBuffer, MAX_PATH);
        SetDlgItemTextW (hWnd, IDC_SHOWTEXT_NAME, szBuffer);
        LoadStringW(_hModule, gTypeSourceID+STRCODEPAGEBASE, szBuffer,EXTENSION_LENGTH);
        SetDlgItemTextW (hWnd, IDC_SHOWTEXT_TYPE, szBuffer);

      /* Text is codepage... use *A() variants of functions. */
      } else {
        char szBuffer[MAX_PATH];

        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_EDIT, (LPCSTR)pSourceData);
        GetDlgItemTextA (hWndTab[0], IDC_NAMETEXT, szBuffer, MAX_PATH);
        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_NAME, szBuffer);
        LoadStringA(_hModule, gTypeSourceID+STRCODEPAGEBASE, szBuffer,EXTENSION_LENGTH);
        SetDlgItemTextA (hWnd, IDC_SHOWTEXT_TYPE, szBuffer);
      }
      LoadString(_hModule, IDS_VIEWSOURCE, &gszExtensions[11][0], EXTENSION_LENGTH);
      SetWindowText (hWnd,&gszExtensions[11][0] );
      GetClientRect (hWnd, &rect);
      SendMessage (hWnd, WM_SIZE, 0,
                 MAKELPARAM ((rect.right - rect.left), (rect.bottom - rect.top)));
    return TRUE;
        }
    case WM_SIZE: {
      HWND hwndText;
		HWND hwndNotice;
    	RECT rc;
		POINT pt;

      hwndNotice = GetDlgItem (hWnd,IDC_SHOWTEXT_FONT);
      GetWindowRect(hwndNotice,&rc);
      pt.x = 0;
      pt.y = rc.bottom;
      ScreenToClient(hWnd, &pt);

      hwndText = GetDlgItem (hWnd, IDC_SHOWTEXT_EDIT);

      MoveWindow (hwndText, DLGBORDER, pt.y+5, (int) LOWORD(lParam) - 2*DLGBORDER,
                                (int) HIWORD(lParam) - (pt.y+5) - DLGBORDER , TRUE);
    }
    break;

    case WM_COMMAND:
      switch (LOWORD (wParam)) {
        case IDCANCEL:
        case IDOK:
          EndDialog (hWnd, TRUE);
      }
    break; /* end WM_COMMAND */

    case WM_SYSCOMMAND:
      if (LOWORD (wParam) == SC_CLOSE)
          EndDialog (hWnd, FALSE);
    break;

  } /* end switch */
  return FALSE;
}

BOOL
SwapSource(
BOOL bForceSwap
)
{
          int i, end;
          BYTE temp;

          if (pSourceData == NULL) return FALSE;

          //Is the source already swapped?
          if (bForceSwap)
                SendDlgItemMessage(hWndTab[0], IDC_SWAPHIGHLOW,BM_GETCHECK,1,0);
          else if (SendDlgItemMessage(hWndTab[0], IDC_SWAPHIGHLOW,
                    BM_GETCHECK,0,0) == gSourceSwapped)
                return FALSE;

          end =  nBytesSource - 2;
          for (i = 0; i<= end; i+=2) {
            temp             = pSourceData[i];
            pSourceData[i]   = pSourceData[i+1];
            pSourceData[i+1] = temp;
          }
          //set flag that source has been swapped;
          gSourceSwapped = 1 - gSourceSwapped;
          return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abc95def.h ===
/*************************************************
 *  abc95def.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <regstr.h>
#include <winreg.h>

/* VK from the keyboard driver */
#define VK_KANA             0x15        //1993.4.22 append from windows.h
#define VK_ROMAJI           0x16
#define VK_ZENKAKU          0x17
#define VK_HIRAGANA         0x18
#define VK_KANJI            0x19


#define VK_DANYINHAO 0xc0      // [,]  char = 0x60
#define VK_JIANHAO   0xbd      // [-]  char = 0x2d
#define VK_DENGHAO   0xbb      // [=]  char = 0x3d
#define VK_ZUOFANG   0xdb      // "["  char = 0x5b
#define VK_YOUFANG   0xdd      // "]"  char = 0x5d
#define VK_FENHAO    0xba      // [;]  char = 0x3b
#define VK_ZUODAN    0xde      // [']  char = 0x27
#define VK_DOUHAO    0xbc      // [,]  char = 0x2c
#define VK_JUHAO     0xbe      // [.]  char = 0x2d
#define VK_SHANGXIE  0xbf      // [ ]  char = 0x2f
#define VK_XIAXIE    0xdc      // [\]  char = 0x5c

#define WM_NEW_WORD 1992+0x400

#define STC FALSE
#define CLC TRUE
#define REINPUT 2
#define RECALL  3
#define BACKWORD_KEY  0x802d
#define FORWORD_KEY   0x803d
#define BIAODIAN_ONLY -2

#define SC_METHOD0  100
#define SC_METHOD1  101
#define SC_METHOD2  102
#define SC_METHOD3  103
#define SC_METHOD4  104
#define SC_METHOD5  105
#define SC_METHOD6  106
#define SC_METHOD7  107
#define SC_METHOD8  108
#define SC_METHOD9  109
#define SC_METHOD10 110
#define SC_ABOUT    111
#define SC_QUIT     112
#define SC_METHODA  113



#define    IDK_SK    211
#define    IDK_QY    212
#define    IDK_CF    213
#define    IDK_SX    214

//Input Methods definition (kb_mode)
#define CIN_QW        1
#define CIN_BX        2
#define CIN_STD       3
#define CIN_SDA       4
#define CIN_ASC       5

//  Definitions of input step_mode (STD, SD)

#define START 0          //the step_mode before pinyin inputing
#define SELECT 1         // after convert
#define RESELECT 2       // after select and can be reselect by FORCE SELECT
             // KEY.
#define ONINPUT 3        // During inputing progress.
#define ONCOVERT 4       // While converting.

//input information (in.info_flag) definitions

#define BY_RECALL 1
#define BY_WORD  0x80
#define BY_CHAR  0x81


//#define IDM_ABOUT 100
#define ABC_HEIGHT 18 //22   //24                here
#define ABC_TOP    4    //7
#define KBAR_W  5      //10
#define KHLINE_W 1
#define KDISP_X  1
#define KDISP_Y 1      //4
#define KVLINE_TOP  (ABC_TOP-1)
#define KVLINE_H   ( Rect.bottom-Rect.top/*-5-4*/-2-1)    //here
#define BLINE_Y (Rect.bottom-/*4*/2)                  //-2

#define KMAIN_X 1
#define KMAIN_Y        ( GetSystemMetrics(SM_CYSCREEN)/*-37*/-29)
#define KMAIN_W      (GetSystemMetrics(SM_CXSCREEN)-2)
#define KMAIN_H      28     //36

#define FC_X 1
#define FC_Y 1
#define FC_W  (GetSystemMetrics(SM_CXSCREEN)-2)
#define FC_H   ( GetSystemMetrics(SM_CYSCREEN)-/*37*/29)

#define KA_X (Rect.left+KBAR_W)                  /* Default horizontal position.       */
#define KA_Y (Rect.top+ABC_TOP)                  /* Default vertical position.         */
#define KA_W 32
#define KA_H ABC_HEIGHT                  /* Default height.                    */

#define KB_X (Rect.left+KBAR_W*2+KA_W)                  /* Default horizontal position.       */
#define KB_Y (Rect.top+ABC_TOP)                  /* Default vertical position.         */
#define KB_W 200                  /* Default width.                     */
#define KB_H ABC_HEIGHT

#define KD_W    32                    // IT MUST BE HERE!
#define KD_X    (Rect.right-KD_W-KBAR_W)                  /* Default horizontal position.       */
#define KD_Y   (Rect.top+ABC_TOP)                                  /* Default vertical position.         */
#define KD_H    ABC_HEIGHT                                        /* Default height.                    */


#define KC_X    (Rect.left+KA_W+KBAR_W*3+KB_W)            /* Default horizontal position.       */
#define KC_Y    (Rect.top+ABC_TOP)                  /* Default vertical position.         */
#define KC_W    (Rect.right-Rect.left-KBAR_W*5-KA_W-KB_W-KD_W)           /* Default width.                     */
#define KC_H    ABC_HEIGHT

#define KSDA_X    60
#define KSDA_Y    ( GetSystemMetrics(SM_CYSCREEN)-37)-130
#define KSDA_W    545                  //312
#define KSDA_H    130                  //83

#define XX 0

#define CUR_START_X  1     //KBAR_W+KBAR_W+KA_W+1
#define CUR_START_Y /*KVLINE_TOP+*/ KDISP_Y
#define CUR_W  2
#define CUR_H  16

  #define IN_MENU      1
  #define IN_NAME      2
  #define IN_INPUT     3
  #define IN_CANDIDATE 4
  #define IN_OPERAT    5
  #define IN_MODE      6
  #define IN_SOFTKEY   7
  #define IN_MOVE      8


#define MD_PAINT 0x1992                         //For ABC Paint
#define MD_CURX  MD_PAINT+1                         // Show chusor
#define MD_NORMAL MD_PAINT+2                         // Display Normal char
#define MD_BACK   MD_PAINT+3                     // Display BACKSPACE,ESC...
#define TN_CLS   MD_PAINT+4
#define TN_SHOW  MD_PAINT+5
#define TN_STATE MD_PAINT+6

#define MD_UPDATE       0x1993                  //1993.3 for increase user.rem

#define POST_OLD 0x11
#define TMMR_REAL_LENGTH    0x1800

//#define some corlors
#define CO_LIGHTBLUE RGB(0,255,255)
#define CO_METHOD     RGB(0,40,80)
#define CO_CAP       RGB(255,0,0)

#define TColor1  RGB(0,0,0)
#define TColor2  RGB(0,0,255)
#define TColor4  RGB(0,0,128)
#define TColor3  RGB(64,0,128)


// Input msg type definitions (STD,SD)

#define NORMAL 0        // Normal pinyin string
#define ABBR   1        // First letter is capital
#define CPAPS_NUM 2     // Capital Chinese number (identifer is "I")
#define CSMALL_NUM 3    // Small chinese number (identifer is "i")
#define USER_extern WORDS 4    // Look for user words
#define BACK_extern WORDS 12   // Reduce convert poextern inter for a word.
#define CONTINUE   13   // Continue converting.

// Converitng return msg definitions(STD and SD)

#define NO_RESULT -1    // Un-successful converting
#define SUCCESS   1     // Converting has results.


#define EXPAND_TABLE_LENGTH       0x0BBE0

//仯
//ʹõļйز

//ڱĲ(ʱİ)

#define BX_LIB_START_POINTER      0L
#define BX_LIB_LENGTH             0x5528        //7650H
// (DZSY.MB 뵽GCW.OVL)

#define DTKB_START_POINTER_LOW    0x05600                       //BX_LIB_LENGTH (c680..)
#define DTKB_START_POINTER_HI     0
#define DTKB_LENGTH               0x0A00
#define DTKB_CHECK_VALUE          0x55EB
// (Ǵ̵̬ĳ)

#define HELP_LOW                  0x06000H
#define HELP_HI                   0
#define HELP_LENGTH               0x600
//   space 180h

#define BHB_START_POINTER_LOW     0x6780                      //ԭD130H
#define BHB_START_POINTER_HI      0
#define BHB_LENGTH                0x54A0                       //ԭΪ49A0H

#define BHB_CX_LOW                0x0A1c0                                  //=3a80h
#define BHB_CX_HI                 0
#define BHB_CX_LENGTH             0x1A20
#define BHB_CHECK_VALUE           0x049FC



#define PTZ_LIB_START_POINTER      0x0BBE0L
#define PTZ_LIB_LENGTH             0x4460L       // 94/4/18  0x4430   //4FC0H
#define PTZ_LIB_LONG               0x400l

#define PD_START_POINTER           0x10040      // 94/4/18  0x10010l //
#define PD_LENGTH                  0x1160                    //
// (PD_TAB ϵڱдYCWʱ,1990.11 ģ
// ڱڼ¼˵ڴʵʹƵ.
// ݿܻҪ޸.

#define SPBX_START_POINTER         0x111E0l
#define SPBX_LENGTH                6784                   //(1A80H)
// (SPBX_TAB ϵڱдYCWʱ,1990.11 ģ
// ڱڼ¼˻ֵʼʻ(ʼ2).
// ݿܻҪ޸.

//TOTAL LENGTH OF THE OVERLAY FILE=12CA0H

#define TMMR_LIB_LENGTH             0x1800                                 //AD7Ϊ3800H(14K)
                           // ad81=3000h
#define PAREMETER_LENGTH            0x10        //1993.4 for setting paremeters

#define FRONT_LIB_START_POINTER_HI   0
#define FRONT_LIB_START_POINTER_LOW  0
#define FRONT_LIB_LENGTH             TMMR_LIB_LENGTH

#define MIDDLE_REM                   0x1400                                //ԭΪ1C00H 5/11/91 
                           //
#define BHB_PROC_OFFSET              0

#define LENGTH_OF_USER            0x0A000l                      //Ǳ׼Ϊ40K
//        ע˲"8"Ͱ汾ǰ

#define NEAR_CARET_CANDIDATE    0x0002
#define NEAR_CARET_FIRST_TIME   0x0001

#define NDX_REAL_LENGTH              0x510                                 //Added IN 1/1/1991

#define CHECK_POINT  1024+2048-4
#define CHECK_POINT2 48-4

#define input_msg_disp                0 // 6

// define for aiABC out type
#define ABC_OUT_ONE      0x1
#define ABC_OUT_MULTY    0x2
#define ABC_OUT_ASCII    0x4
#define COMP_NEEDS_END   0x100

struct INPUT_TISHI {
            unsigned char buffer[6];
            };

struct INPT_BF{
        WORD max_length;
        WORD true_length;
        BYTE info_flag;
        BYTE buffer[40];
        };


struct W_SLBL{
            BYTE dw_stack[20];
            WORD dw_count;
            WORD yj[20];
            BYTE syj[20];
            WORD tone[20];
            BYTE bx_stack[20];
            BYTE cmp_stack[20];
            WORD yj_ps[20];
            int yjs;
            int xsyjs;
            int xsyjw;
            int syyjs;
            };

struct ATTR{
            BYTE pindu;
            BYTE from;
            WORD addr;
           };


struct STD_LIB_AREA{
                     WORD two_end;
                     WORD three_end;
                     WORD four_end;
                     BYTE buffer[0x800-6];
                    };

struct INDEX{
                WORD body_start;
                WORD ttl_length;
                WORD body_length;
                WORD index_start;
                WORD index_length;
                WORD unused1;
                WORD ttl_words;
                WORD two_words;
                WORD three_words;
                WORD four_words;
                WORD fiveup_words;
                WORD unused2[13 ];
                WORD dir[((23*27)+7)/8*8];
            };

struct USER_LIB_AREA{
                     WORD two_end;
                     WORD three_end;
                     WORD four_end;
                     BYTE buffer[0x400-6];
                    };

struct TBF{
            WORD t_bf_start[8];
            WORD t_bf1[(72*94+15)/16*16];
            WORD t_bf2[PTZ_LIB_LENGTH/2-(72*94+15)/16*16];
          };

struct PD_TAB{
                WORD pd_bf0[8];
                BYTE pd_bf1[((55-16+1)*94+15)/16*16];
                BYTE pd_bf2[0x4f0];
             };


struct FMT{
            WORD fmt_group;
            WORD fmt_ttl_len;
            WORD fmt_start;
            };


struct T_REM{
                WORD stack1[512];
                WORD stack2[1024];
                WORD stack3[512];
                WORD temp_rem_area[512];
                WORD rem_area[512];
            };

struct M_NDX{
          WORD mulu_start_hi;
          WORD mulu_start_low;
          WORD mulu_length_max;
          WORD mulu_true_length;
          WORD mulu_record_length;
          WORD data_start_hi;
          WORD data_start_low;
          WORD data_record_length;
         };

struct S_HEAD{
         BYTE flag;
         BYTE name;
         WORD start_pos;
         WORD item[25];

         };

struct DEX{
                WORD body_start;
                WORD ttl_length;
                WORD body_length;
                WORD index_start;
                WORD index_length;
                WORD unused1;
                WORD ttl_words;
                WORD two_words;
                WORD three_words;
                WORD four_words;
                WORD fiveup_words;
                WORD unused2[13 ];
                struct S_HEAD dex[23];
                WORD  unuserd2[0x510/2-23*27-24];
            };


#define ParaPos  7
/******************************************************************
This part of defination is cut before CWP.c
*******************************************************************/
#define TRUE    1
#define FALSE   0
#define NUMBER  0x20
#define FUYIN   0x21
#define YUANYIN  0x22
#define SEPERATOR  0x27
#define FIRST_T    1
#define SECOND_T   2
#define THIRD_T    3
#define FORTH_T    4

// about search strutagy
#define BX_FLAG         8
#define JP_FLAG         4
#define QP_FLAG         2
#define YD_FLAG         1

// about search lib
#define BODY_START                      0
#define KZK_BODY_START          0
#define KZK_BASE                        0xa000l
#define MORE_THAN_5                     23
//#define TMMR_REAL_LENGTH                                0x1800

// mark for test
#define TEST                    0


 struct SLBL{
            WORD value;
            BYTE head;
            WORD length;
            BYTE tune;
            BYTE bx1;
            WORD bx2;
            BYTE flag;
            };

 struct N_SLBL{
        BYTE buffer[30];
        int length;
          };


// IME designer can change this file according to each IME

// resource ID
#define IDI_IME                 0x0100

#define IDS_STATUSERR           0x0200
#define IDS_CHICHAR             0x0201


#define IDS_EUDC                0x0202
#define IDS_USRDIC_FILTER       0x0210


#define IDS_FILE_OPEN_ERR       0x0220
#define IDS_MEM_LESS_ERR        0x0221


#define IDS_IMENAME             0x0320
#define IDS_IMEUICLASS          0x0321
#define IDS_IMECOMPCLASS        0x0322
#define IDS_IMECANDCLASS        0x0323
#define IDS_IMESTATUSCLASS      0x0324


#define IDD_DEFAULT_KB          0x0400
#define IDD_ETEN_KB             0x0401
#define IDD_IBM_KB              0x0402
#define IDD_CHING_KB            0x0403

#define IDD_QUICK_KEY           0x0500
#define IDD_PREDICT             0x0501


#define IME_APRS_AUTO           0x0
#define IME_APRS_FIX            0x1


#define OFFSET_MODE_CONFIG      0
#define OFFSET_READLAYOUT       4


#define  ERR01  "ȱٴʿļwinabc.cwd"
#define  ERR02  "򿪴ʿļwinabc.cwd"
#define  ERR03  "ȡʿļwinabc.cwd"
#define  ERR04  "ȱٻļwinabc.ovl"
#define  ERR05  "򿪻ļwinabc.ovl"
#define  ERR06  "ȡļwinabc.ovl"
#define  ERR07  "򿪼ļtmmr.rem"
#define  ERR08  "ȡļtmmr.rem"
#define  ERR09  "дļtmmr.rem"
#define  ERR10  "ûʿuser.rem"
#define  ERR11  "ȡûʿuser.rem"
#define  ERR12  "дûʿuser.rem"
#define  ERR13  "ļ"
#define  ERR14  "ڴ治"
#define  ERR15  "δ´ݡ"
#define  ERR16  "δ´ʱ롣"
#define  ERR17  "зǷַ"
#define  ERR18  "ظ"
#define  ERR19  "ûԶ̫ࡣ"
#define  ERR20  "ɾʧܡ"
#define  NTF21  "ûʿѾԶ¡"
#define  ERR22  "ڴ䷢"




#define ERRMSG_LOAD_0           0x0010
#define ERRMSG_LOAD_1           0x0020
#define ERRMSG_LOAD_2           0x0040
#define ERRMSG_LOAD_3           0x0080
#define ERRMSG_LOAD_USRDIC      0x0400
#define ERRMSG_MEM_0            0x1000
#define ERRMSG_MEM_1            0x2000
#define ERRMSG_MEM_2            0x4000
#define ERRMSG_MEM_3            0x8000
#define ERRMSG_MEM_USRDIC       0x00040000


// state of composition

#define CST_INIT                0
#define CST_INPUT               1
#define CST_CHOOSE              2
#define CST_TOGGLE_PHRASEWORD   3           // not in iImeState
#define CST_ALPHABET            4           // not in iImeState
#define CST_SOFTKB              99

#define CST_ALPHANUMERIC        5           // not in iImeState
#define CST_INVALID             6           // not in iImeState

// IME specific constants

#define CANDPERPAGE            9 // 10


#define MAXSTRLEN               32
#define MAXCAND                 256

// border for UI
#define UI_MARGIN               4

#define STATUS_DIM_X            20//24
#define STATUS_DIM_Y            21//24

// if UI_MOVE_OFFSET == WINDOW_NOTDRAG, not in drag operation
#define WINDOW_NOT_DRAG         0xFFFFFFFF

// window extra for composition window
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4


// the start number of candidate list
#define CAND_START              1

#define IMN_PRIVATE_TOGGLE_UI           0x0001
#define IMN_PRIVATE_CMENUDESTROYED      0x0002
#define IMN_PRIVATE_COMPOSITION_SIZE    0x0003
#define IMN_PRIVATE_UPDATE_PREDICT      0x0004
#define IMN_PRIVATE_UPDATE_SOFTKBD      0x0006
#define IMN_PRIVATE_PAGEUP              0x0007

// the flag for an opened or start UI

/*#define IMN_PRIVATE_UPDATE_SOFTKBD      0x0001

#define MSG_ALREADY_OPEN                0x000001
#define MSG_ALREADY_OPEN2               0x000002
#define MSG_OPEN_CANDIDATE              0x000010
#define MSG_OPEN_CANDIDATE2             0x000020
#define MSG_CLOSE_CANDIDATE             0x000100
#define MSG_CLOSE_CANDIDATE2            0x000200
#define MSG_CHANGE_CANDIDATE            0x001000
#define MSG_CHANGE_CANDIDATE2           0x002000
#define MSG_ALREADY_START               0x010000
#define MSG_START_COMPOSITION           0x020000
#define MSG_END_COMPOSITION             0x040000
#define MSG_COMPOSITION                 0x080000
#define MSG_IMN_COMPOSITIONPOS          0x100000
#define MSG_IMN_UPDATE_SOFTKBD          0x200000


#define MSG_GUIDELINE                   0x400000
#define MSG_IN_IMETOASCIIEX             0x800000  */

// this constant is depend on TranslateImeMessage
#define GEN_MSG_MAX             30//6

#define MSG_COMPOSITION                 0x0000001

#define MSG_START_COMPOSITION           0x0000002
#define MSG_END_COMPOSITION             0x0000004
#define MSG_ALREADY_START               0x0000008
#define MSG_CHANGE_CANDIDATE            0x0000010
#define MSG_OPEN_CANDIDATE              0x0000020
#define MSG_CLOSE_CANDIDATE             0x0000040
#define MSG_ALREADY_OPEN                0x0000080
#define MSG_GUIDELINE                   0x0000100
#define MSG_IMN_COMPOSITIONPOS          0x0000200
#define MSG_IMN_COMPOSITIONSIZE         0x0000400
#define MSG_IMN_UPDATE_PREDICT          0x0000800
#define MSG_IMN_UPDATE_SOFTKBD          0x0002000
#define MSG_ALREADY_SOFTKBD             0x0004000
#define MSG_IMN_PAGEUP                  0x0008000

// original reserve for old array, now we switch to new, no one use yet
#define MSG_CHANGE_CANDIDATE2           0x1000000
#define MSG_OPEN_CANDIDATE2             0x2000000
#define MSG_CLOSE_CANDIDATE2            0x4000000
#define MSG_ALREADY_OPEN2               0x8000000

#define MSG_STATIC_STATE                (MSG_ALREADY_START|MSG_ALREADY_OPEN|MSG_ALREADY_SOFTKBD|MSG_ALREADY_OPEN2)

#define MSG_IMN_TOGGLE_UI               0x0400000
#define MSG_IN_IMETOASCIIEX             0x0800000


// the flag for set context
/*
#define SC_SHOW_UI              0x0001
#define SC_HIDE_UI              0x0002
#define SC_ALREADY_SHOW_STATUS  0x0004
#define SC_WANT_SHOW_STATUS     0x0008
#define SC_HIDE_STATUS          0x0010
*/

#define MSG_IMN_TOGGLE_UI               0x0400000
#define MSG_IN_IMETOASCIIEX             0x0800000

#define ISC_SHOW_SOFTKBD                0x02000000
#define ISC_OPEN_STATUS_WINDOW          0x04000000
#define ISC_OFF_CARET_UI                0x08000000
#define ISC_SHOW_UI_ALL                 (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI               (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD)

#define ISC_HIDE_SOFTKBD                0x01000000

// the flag for composition string show status
#define IME_STR_SHOWED          0x0001
#define IME_STR_ERROR           0x0002

// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_WORD_PREDICT        0x0002
#define MODE_CONFIG_PREDICT             0x0004
#define MODE_CONFIG_OFF_CARET_UI        0x0008


// the different layout for Phonetic reading
#define READ_LAYOUT_DEFAULT     0
#define READ_LAYOUT_ETEN        1
#define READ_LAYOUT_IBM         2
#define READ_LAYOUT_CHINGYEAH   3


// the virtual key value
#define VK_OEM_SEMICLN                  '\xba'    //  ;    :
#define VK_OEM_EQUAL                    '\xbb'    //  =    +
#define VK_OEM_SLASH                    '\xbf'    //  /    ?
#define VK_OEM_LBRACKET                 '\xdb'    //  [    {
#define VK_OEM_BSLASH                   '\xdc'    //  \    |
#define VK_OEM_RBRACKET                 '\xdd'    //  ]    }
#define VK_OEM_QUOTE                    '\xde'    //  '    "

#define SDA_AIABC_KB  0
#define  SDA_WPS_KB   0x2
#define  SDA_STONE_KB 0x4
#define SDA_USER_KB   0x8




extern const TCHAR szRegAppUser[];
extern const TCHAR szRegModeConfig[];



#define MAX_IME_TABLES          6
#define MAX_IME_CLASS           16

#define CMENU_HUIWND            0
#define CMENU_MENU              (CMENU_HUIWND+sizeof(CMENU_HUIWND))
#define WND_EXTRA_SIZE          (CMENU_MENU+sizeof(CMENU_HUIWND))

#define WM_USER_DESTROY         (WM_USER + 0x0400)

// Defines for soft_kbd         skd #2
#define IDM_SKL1                0x0500
#define IDM_SKL2                0x0501
#define IDM_SKL3                0x0502
#define IDM_SKL4                0x0503
#define IDM_SKL5                0x0504
#define IDM_SKL6                0x0505
#define IDM_SKL7                0x0506
#define IDM_SKL8                0x0507
#define IDM_SKL9                0x0508
#define IDM_SKL10               0x0509
#define IDM_SKL11               0x050a
#define IDM_SKL12               0x050b
#define IDM_SKL13               0x050c
#define NumsSK                  13



typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef WORD  UNALIGNED FAR *LPUNAWORD;


typedef struct tagImeL {        // local structure, per IME structure
    HINSTANCE   hInst;          // IME DLL instance handle
    WORD        wImeStyle;      // What kind of display
    HWND        TempUIWnd;
    int         xCompWi;        // width
    int         yCompHi;        // height
    int         Ox;
    int         Oy;
    POINT       ptZLCand;
    POINT       ptZLComp;
    POINT       ptDefComp;      // default composition window position
    POINT       ptDefCand;      // default Cand window
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition window
    BYTE        szSetFile[16];  // .SET file name of IME
// standard table related data
    DWORD       fdwTblLoad;     // the *.TBL load status
    DWORD       fdwErrMsg;      // error message flag
    int         cRefCount;      // reference count
                                // size of standard table
    UINT        uTblSize[1];
                                // filename of tables
    BYTE        szTblFile[1][16];
                                // the IME tables
    HANDLE      hMapTbl[1];

    UINT        uUsrDicSize;    // memory size of user create words table
    HANDLE      hUsrDicMem;     // memory handle for user dictionary

// the calculated sequence mask bits
    DWORD       dwSeqMask;      // the sequence bits for one stoke
    DWORD       dwPatternMask;  // the pattern bits for one result string
    int         nSeqBytes;      // how many bytes for nMaxKey sequence chars
// key related data
    DWORD       fdwModeConfig;
    WORD        fModeConfig;    // quick key/prediction mode
    WORD        nReadLayout;    // ACER, ETen, IBM, or other - phonetic only
    WORD        nSeqBits;       // no. of sequence bits
    WORD        nMaxKey;        // max key of a Chinese word
    WORD        nSeqCode;       // no. of sequence code
    WORD        fChooseChar[4]; // valid char in choose state
    WORD        fCompChar[5];   // valid char in input state
    WORD        nRevMaxKey;

// convert sequence code to composition char
    WORD        wSeq2CompTbl[64];
// convert char to sequence code
    WORD        wChar2SeqTbl[0x40];
    TCHAR       szUIClassName[MAX_IME_CLASS];
    TCHAR       szStatusClassName[MAX_IME_CLASS];
    TCHAR       szOffCaretClassName[MAX_IME_CLASS];
    TCHAR       szCMenuClassName[MAX_IME_CLASS];
    HMENU       hSysMenu;
    HMENU       hSKMenu;

    DWORD       dwSKState[NumsSK];    // skd #1
    DWORD       dwSKWant;
    BOOL        fWinLogon;

} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;



typedef struct _tagTableFiles { // match with the IMEL
    BYTE szTblFile[MAX_IME_TABLES][16];
} TABLEFILES;

typedef TABLEFILES      *PTABLEFILES;
typedef TABLEFILES NEAR *NPTABLEFILES;
typedef TABLEFILES FAR  *LPTABLEFILES;


typedef struct _tagValidChar {  // match with the IMEL
    WORD nMaxKey;
    WORD nSeqCode;
    WORD fChooseChar[4];
    WORD fCompChar[5];
    WORD wSeq2CompTbl[64];
    WORD wChar2SeqTbl[0x40];
} VALIDCHAR;

typedef VALIDCHAR      *PVALIDCHAR;
typedef VALIDCHAR NEAR *NPVALIDCHAR;
typedef VALIDCHAR FAR  *LPVALIDCHAR;



#define NFULLABC        95
typedef struct _tagFullABC {
    WORD wFullABC[NFULLABC];
} FULLABC;

typedef FULLABC      *PFULLABC;
typedef FULLABC NEAR *NPFULLABC;
typedef FULLABC FAR  *LPFULLABC;


typedef struct _tagImeG {       // global structure, can be share by all IMEs,
                                // the seperation (IMEL and IMEG) is only
                                // useful in UNI-IME, other IME can use one
    RECT        rcWorkArea;     // the work area of applications

// Select Wide ajust value
    int         Ajust;
    int         TextLen;
    int         unchanged;
// Chinese char width & height
    int         xChiCharWi;
    int         yChiCharHi;
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window

    RECT        rcPageUp;
    RECT        rcPageDown;
    RECT        rcHome;
    RECT        rcEnd;

    HBITMAP      PageUpBmp;
    HBITMAP      PageDownBmp;
    HBITMAP      HomeBmp;
    HBITMAP      EndBmp;

    HBITMAP      PageUp2Bmp;
    HBITMAP      PgDown2Bmp;
    HBITMAP      Home2Bmp;
    HBITMAP      End2Bmp;


       HBITMAP      NumbBmp;
    HBITMAP      SnumbBmp;

    HPEN         WhitePen;
    HPEN         BlackPen;
    HPEN         GrayPen;
    HPEN         LightGrayPen;
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcInputText;    // input text relateive to status window
    RECT        rcShapeText;    // shape text relative to status window
    RECT        rcSKText;       // SK text relative to status window
    RECT        rcCmdText;
    RECT        rcPctText;
    RECT        rcFixCompText;
// full shape space (reversed internal code)
    WORD        wFullSpace;
// full shape chars (internal code)
    WORD        wFullABC[NFULLABC];
// error string
    BYTE        szStatusErr[8];
    int         cbStatusErr;

// candidate string start from 0 or 1
    int         iCandStart;
// setting of UI
    int         iPara;
    int         iPerp;
    int         iParaTol;
    int         iPerpTol;
// flag for disp style
    int         style;
    BYTE         KbType;
    BYTE         cp_ajust_flag;
    BYTE         auto_mode ;
    BYTE         cbx_flag;
    BYTE        tune_flag;
    BYTE        auto_cvt_flag;
    BYTE        SdOpenFlag ;
    int        InbxProc;
    int        First;
    int        Prop;
    int        KeepKey;
    TCHAR      szIMEUserPath[MAX_PATH];
} IMEG;

typedef IMEG      *PIMEG;
typedef IMEG NEAR *NPIMEG;
typedef IMEG FAR  *LPIMEG;


typedef struct _tagPRIVCONTEXT {// IME private data for each context

    int         iImeState;      // the composition state - input, choose, or
    BOOL        fdwImeMsg;      // what messages should be generated
    DWORD       dwCompChar;     // wParam of WM_IME_COMPOSITION
    DWORD       fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    DWORD       fdwInit;        // position init
// SK data
    HWND        hSoftKbdWnd;        // soft keyboard window
    int         nShowSoftKbdCmd;

//    DWORD       dwSKState[NumsSK];    // skd #1
//    DWORD       dwSKWant;

} PRIVCONTEXT;

typedef PRIVCONTEXT      *PPRIVCONTEXT;
typedef PRIVCONTEXT NEAR *NPPRIVCONTEXT;
typedef PRIVCONTEXT FAR  *LPPRIVCONTEXT;


typedef struct _tagUIPRIV {     // IME private UI data

    HWND    hCompWnd;           // composition window
    int     nShowCompCmd;
    HWND    hCandWnd;           // candidate window for composition
    int     nShowCandCmd;
    HWND    hSoftKbdWnd;        // soft keyboard window
    int     nShowSoftKbdCmd;

    HWND    hStatusWnd;         // status window
    HIMC    hIMC;               // the recent selected hIMC
    int     nShowStatusCmd;
    DWORD   fdwSetContext;      // the actions to take at set context time
    HWND    hCMenuWnd;          // a window owner for context menu

} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV NEAR *NPUIPRIV;
typedef UIPRIV FAR  *LPUIPRIV;

typedef struct tagNEARCARET {   // for near caret offset calculatation
    int iLogFontFacX;
    int iLogFontFacY;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;


/*typedef struct _tagNEARCARET {  // for near caret offset calculatation
    int iLogFontFac;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;*/

typedef NEARCARET      *PNEARCARET;
typedef NEARCARET NEAR *NPNEARCARET;
typedef NEARCARET FAR  *LPNEARCARET;



int WINAPI LibMain(HANDLE, WORD, WORD, LPSTR);                  // init.c
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM);         // ui.c


void PASCAL AddCodeIntoCand(LPCANDIDATELIST, WORD);             // compose.c
void PASCAL CompWord(WORD, LPINPUTCONTEXT, LPCOMPOSITIONSTRING, LPPRIVCONTEXT,
     LPGUIDELINE);                                              // compose.c
UINT PASCAL Finalize(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, BOOL);                                      // compose.c
void PASCAL CompEscapeKey(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPGUIDELINE, LPPRIVCONTEXT);                               // compose.c

UINT PASCAL PhrasePrediction(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT);                                            // chcand.c
void PASCAL SelectOneCand(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, LPCANDIDATELIST);                           // chcand.c
void PASCAL CandEscapeKey(LPINPUTCONTEXT, LPPRIVCONTEXT);       // chcand.c
void PASCAL ChooseCand(WORD, LPINPUTCONTEXT, LPCANDIDATEINFO,
     LPPRIVCONTEXT);                                            // chcand.c

void PASCAL SetPrivateFileSetting(LPBYTE, int, DWORD, LPCTSTR); // ddis.c


void PASCAL InitCompStr(LPCOMPOSITIONSTRING);                   // ddis.c
BOOL PASCAL ClearCand(LPINPUTCONTEXT);                          // ddis.c

UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST,LPINPUTCONTEXT, LPPRIVCONTEXT);        // toascii.c

void PASCAL GenerateMessage(HIMC, LPINPUTCONTEXT,
     LPPRIVCONTEXT);                                            // notify.c


void PASCAL LoadUsrDicFile(void);                               // dic.c


BOOL PASCAL LoadTable(void);                                    // dic.c
void PASCAL FreeTable(void);                                    // dic.c

DWORD PASCAL ReadingToPattern(LPCTSTR, BOOL);                   // regword.c
void  PASCAL ReadingToSequence(LPCTSTR, LPBYTE, BOOL);          // regword.c


void PASCAL DrawDragBorder(HWND, LONG, LONG);                   // uisubs.c
void PASCAL DrawFrameBorder(HDC, HWND);                         // uisubs.c


HWND    PASCAL GetCompWnd(HWND);                                // compui.c
void    PASCAL SetCompPosition(HWND, LPINPUTCONTEXT);           // compui.c
void    PASCAL SetCompWindow(HWND);                             // compui.c
void    PASCAL MoveDefaultCompPosition(HWND);                   // compui.c
void    PASCAL ShowComp(HWND, int);                             // compui.c
void    PASCAL StartComp(HWND);                                 // compui.c
void    PASCAL EndComp(HWND);                                   // compui.c
void    PASCAL UpdateCompWindow(HWND);                          // compui.c
LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c

HWND    PASCAL GetCandWnd(HWND);                                // candui.c
BOOL    PASCAL CalcCandPos(LPPOINT);                            // candui.c
LRESULT PASCAL SetCandPosition(HWND, LPCANDIDATEFORM);          // candui.c
void    PASCAL ShowCand(HWND, int);                             // candui.c
void    PASCAL OpenCand(HWND);                                  // candui.c
void    PASCAL CloseCand(HWND);                                 // candui.c
void    PASCAL UpdateCandWindow2(HWND, HDC);                    // candui.c
LRESULT CALLBACK CandWndProc(HWND, UINT, WPARAM, LPARAM);       // candui.c


HWND    PASCAL GetStatusWnd(HWND);                              // statusui.c
LRESULT PASCAL SetStatusWindowPos(HWND);                        // statusui.c
void    PASCAL ShowStatus(HWND, int);                           // statusui.c
void    PASCAL OpenStatus(HWND);                                // statusui.c
LRESULT CALLBACK StatusWndProc(HWND, UINT, WPARAM, LPARAM);     // statusui.c


void PASCAL UpdateCompCur(
    HWND hCompWnd);

void PASCAL ReInitIme(
    HWND hWnd ,
    WORD WhatStyle);
LRESULT PASCAL UIPaint2(
    HWND        hUIWnd);


LRESULT PASCAL UIPaint(
    HWND        hUIWnd);

void PASCAL AdjustStatusBoundary(
    LPPOINT lppt);

void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd);

LRESULT CALLBACK ContextMenuWndProc(

    HWND        hCMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam);


UINT PASCAL TransAbcMsg(
    LPTRANSMSGLIST lpTransBuf,
    LPPRIVCONTEXT  lpImcP,
    LPINPUTCONTEXT lpIMC,
    UINT            uVirtKey,
    UINT           uScanCode,
    WORD           wCharCode);

UINT PASCAL TransAbcMsg2(
    LPTRANSMSG     lpTransMsg,
    LPPRIVCONTEXT  lpImcP);

void PASCAL GenerateMessage2(
    HIMC           ,
    LPINPUTCONTEXT ,
    LPPRIVCONTEXT );


void PASCAL MoveCompCand(
    HWND hUIWnd);

void PASCAL UpdateSoftKbd(
    HWND hUIWnd);

void PASCAL DestroyStatusWindow(
    HWND hStatusWnd);

void PASCAL ChangeCompositionSize(
    HWND   hUIWnd);

INT_PTR  CALLBACK CvtCtrlProc(HWND hdlg,
                              UINT uMessage,
                              WPARAM wparam,
                              LPARAM lparam);

INT_PTR  CALLBACK ImeStyleProc(HWND hdlg,
                               UINT uMessage,
                               WPARAM wparam,
                               LPARAM lparam);

INT_PTR  CALLBACK KbSelectProc(HWND hdlg,
                               UINT uMessage,
                               WPARAM wparam,
                               LPARAM lparam);


LRESULT PASCAL GetCandPos(
    HWND            hUIWnd,
    LPCANDIDATEFORM lpCandForm);





/*********************************************************************/
/*   Prototype define of abc95wp.c                                   */
/*********************************************************************/


UINT WINAPI SetResultToIMC(
    HIMC                ghIMC,
    LPSTR               outBuffer, //soarce buffer (normal for out_svw)
    WORD                outCount);  //How many candidates are.


void PASCAL AbcGenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP);

int WINAPI MouseInput(HWND hWnd, WPARAM wParam, LPARAM lParam);

int WINAPI SoftKeyProc(int flag);

int WINAPI WhichRect(POINT point);

int WINAPI ConvertKey(WORD wParam);

int WINAPI CharProc(WORD ImeChar,WPARAM wParam,LPARAM lParam,
            HIMC hIMC,LPINPUTCONTEXT lpIMC,LPPRIVCONTEXT lpImcP);

int WINAPI v_proc(WORD input_char);

void WINAPI DispModeEx();

void WINAPI DispMode(HIMC);

void WINAPI DispSpecChar(int c,int n);

void WINAPI show_char(unsigned char *string,int count);

void WINAPI disp_jiyi(HANDLE xxx);

void WINAPI prompt_disp();

int WINAPI cls_prompt();

int WINAPI cls_prompt_only();

int WINAPI SetCloseCompWinMsg(int ClsFlag);

void WINAPI ABCstrnset(LPSTR bufferd,BYTE value,int n);

LPSTR WINAPI ABCstrstr(LPSTR str1,LPSTR str2);

int WINAPI back_a_space(int x);

int WINAPI cs_p(int x);

void WINAPI DrawInputCur();

void WINAPI UpdateUser();

int WINAPI STD_MODE(WORD input_char);

int WINAPI call_czh(int mtype);

void WINAPI MoveWordIntoCand(
    LPCANDIDATELIST lpCandList,
    LPBYTE            srcBuffer,
    BYTE             srcAttr,
    WORD             perLength );

UINT WINAPI SetToIMC(HIMC ghIMC,BYTE *srcBuffer,
              WORD srcCount,WORD perLength);


int WINAPI word_select(int input_char);

int WINAPI del_and_reconvert();

int WINAPI backword_proc();

int WINAPI same_as_backwords();

void WINAPI AutoMoveResult();

void WINAPI move_result();

int WINAPI pindu_ajust();

void WINAPI cls_inpt_bf(int hFunc);

void WINAPI half_init();

int WINAPI sent_chr1(int input_char);

BOOL if_biaodian(BYTE x);

int WINAPI analize();

BOOL bd_proc();

int WINAPI GetBDValue(int bd_char);

BOOL if_zimu_or_not(BYTE x);

int WINAPI if_number_or_not(BYTE c);

int WINAPI if_bx_number(BYTE c);

int WINAPI out_result(int result_type);

void WINAPI fmt_transfer();

int WINAPI sent_back_msg();

int WINAPI if_jlxw_mode();

int WINAPI disp_auto_select();


int WINAPI if_first_key(WORD input_char);

//void WINAPI add_ext_lib();

int WINAPI temp_rem_proc();

int WINAPI if_multi_rem(int c);

void WINAPI send_msg(BYTE *bf,int count);

int WINAPI send_one_char(int chr);

int WINAPI send_one_char0(int chr);

void WINAPI cap_full(WORD wParam);

int WINAPI read_kb();

/* WORD FAR PASCAL TimerFunc(HWND hWnd, WORD wMsg,
                int nIDEvent, DWORD dwTime); */

extern WORD last_size;

BX_MODE(WORD input_char,WPARAM wParam);

void WINAPI bx_proc(WORD input_char,WPARAM wParam);

int WINAPI bx_analize(WORD input_char,WPARAM wParam);

int WINAPI disp_help_and_result();

int WINAPI cmp_bx_word_exactly();

int WINAPI cmp_bx_code2();

void WINAPI conbine();

int WINAPI cmp_subr();

void WINAPI cls_bx_disp(int flag);

int WINAPI load_one_part_bxtab();

int WINAPI disp_bx_result();

void WINAPI disp_bx_prompt();

void WINAPI send_bx_result();

void WINAPI data_init();

int WINAPI QuitBefore();

int WINAPI CheckAndCreate(BYTE *tmmr_rem, BYTE *user_rem);

void WINAPI err_exit(char *err_msg);

int WINAPI enter_death(HWND hhW);

LONG FAR PASCAL Diaman(HWND hDlg, unsigned xiaoxi,
              WORD wParam, LONG lParam);

int WINAPI ok_return(WORD xiaoxi,HWND hDlg);

void WINAPI err_exit_proc( char *err_msg);

int WINAPI GetText32( HDC  hdc, LPCTSTR lpString, int  cbString);

 int WINAPI makep(LPARAM lParam,  LPPOINT oldPoint);

int WINAPI cwp_proc(int mtype);

int WINAPI find_next();

int WINAPI normal();

int WINAPI normal_1(int flag);

int WINAPI recall();

int WINAPI user_definition();

int WINAPI detail_analyse();

int WINAPI slbl(BYTE *s_buffer);

int WINAPI getattr(BYTE x,char *p);

int WINAPI neg_slbl(WORD value);

int WINAPI neg_sc(int i,BYTE x);

int WINAPI convert(int flag);

int WINAPI copy_input();

void WINAPI input_msg_type();

int WINAPI pre_nt_w1();

int WINAPI pre_nt_w1(int ps);

void WINAPI w1_no_tune();

int WINAPI sc_gb();

int WINAPI sc_gbdy();

int WINAPI get_the_one(int i);

int WINAPI cmp_bx1(int i);

int WINAPI get_the_one2(int i);

int WINAPI cmp_bx2(int i);

int WINAPI paidui(int cnt);

void WINAPI s_tune();

int WINAPI fu_sm(BYTE fy);

int WINAPI find_one_hi();

int WINAPI czcx(WORD *stack);

int WINAPI find_multy_hi();

int WINAPI find_two_hi();

int WINAPI find_three_hi();

int WINAPI cmp_2_and_3(WORD *t_stack);

void WINAPI find_that();

int WINAPI find_hz(WORD x);

int WINAPI prepare_search1();

int WINAPI search_and_read(BYTE f_ci1,BYTE f_ci2);

int WINAPI if_already_in(BYTE f_ci1,BYTE f_ci2);

int WINAPI count_basic_pera(BYTE f_ci1,BYTE f_ci2);

int WINAPI read_kzk_lib();

int WINAPI read_a_page(BYTE file_flag,LONG start_ps, WORD size);

int WINAPI abbr_s1();

void WINAPI find_new_word();

int WINAPI fczs1(BYTE *rem_p,int end,int area_flag);

int WINAPI find_long_word2(BYTE *buffer);

int WINAPI trs_new_word(int word_addr,BYTE *buffer,int area_flag);

void WINAPI pre_cmp(WORD x);

int WINAPI cmp_a_slbl_with_bx();

int WINAPI cmp_a_slbl();

int WINAPI cmp_first_letter();

int WINAPI cisu_to_py();

int WINAPI get_head(BYTE first_letter);

int WINAPI yjbx();

int WINAPI abbr_entry(BYTE *s_start,BYTE *s_end ,BYTE ComeFrom);

int WINAPI cmp_long_word2(BYTE *buffer);

int WINAPI order_result2();

int WINAPI fenli_daxie();

int WINAPI rzw();

int WINAPI abbr();

int WINAPI sfx_proc();

void WINAPI zdyb();

int WINAPI recall_rc();

int WINAPI find_long_word3(WORD *stack,int length);

void WINAPI trs_new_word3(BYTE length,int addr);

int WINAPI new_word();

int WINAPI rem_new_word();

int WINAPI AddExtLib();

void WINAPI write_new_word(int flag);

int WINAPI writefile(BYTE *file_n,LONG distance,LPSTR p,int count);

int WINAPI read_mulu();

int WINAPI look_for_code();

int WINAPI if_code_equ(int addr);

int WINAPI read_data(int rec_cnt);

int WINAPI UpdateProc();

int WINAPI rem_pd1(WORD *buffer);

int WINAPI push_down_stack1();

void WINAPI rem_pd2(WORD *buffer);

void WINAPI rem_pd3(WORD *buffer);

void WINAPI DealWithSH();
void WINAPI PopStMenu(HWND hWnd, int x, int y);
int ReDrawSdaKB(HIMC hIMC, DWORD KbIndex, DWORD ShowOp);
int InitUserSetting(void);
void InitCvtPara(void);
int DoPropertySheet(HWND hwndOwner,HWND hWnd);
int CountDefaultComp(int x, int y, RECT Area);
int CommandProc(WPARAM  wParam,HWND hWnd);
void WINAPI CenterWindow(HWND hWnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abcbx.h ===
/*************************************************
 *  abcbx.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define    ESC        1
#define    SPACE    2
#define    OTHER    3
#define    BXMA    4
#define BX_SELECT 5
#define BX_RESULT_POS    14
#define BX_CHOICE 6

RECT rectchar;

WORD bxtable_ndx[]={0,0xc3a,0x1143,0x2493,
            0x3695,0x3af0,0x3ed1,0x4aec,0x5490};        //length for each bx
                        
WORD search_pointer=0;
BYTE current_bx_code_long=0;
WORD key_bx_code_long=0;
WORD current_part_length=0;
BYTE bx_help_flag=0;
BYTE in_mem_part=0;
BYTE bx_inpt_on=0;
BYTE bx_allow=1;

BYTE inpt_bx_bf[40];
BYTE key_bx_code[40];
BYTE current_bx_code[40];
BYTE bx_help_disp_bf[40];

BYTE *lib_p;
BYTE *out_p;


//copy from abcw2.h and add extern for every global variable.

extern CHAR SKLayoutS[NumsSK];
extern CHAR SKLayout[NumsSK][48*2];
extern CHAR PcKb[48*2],SdaKb[48*2];
extern CHAR SPcKb[48*2],SSdaKb[48*2];

extern LPIMEL lpImeL;
extern IMEG sImeG ;

#define WM_NEW_DEF_CODE         1993+0x400      //1993.4.19
#define WM_NEW_DEF_RESTORE      1993+0x401      //1993.4.19

extern HIMC ghIMC;
extern LPINPUTCONTEXT glpIMC;
extern LPPRIVCONTEXT  glpIMCP; 
extern int wait_flag , waitzl_flag;
extern int TypeOfOutMsg;
extern int biaodian_len;
extern BYTE I_U_Flag;
extern struct INPUT_TISHI prompt[1];
extern struct INPT_BF in;
extern struct W_SLBL wp;
extern struct ATTR msx_area[120];
extern struct INDEX ndx;
extern struct INDEX kzk_ndx;
extern struct TBF FAR *cisu;
extern struct PD_TAB pindu;
extern struct FMT now;
extern struct T_REM tmmr;
extern int form[];
extern BYTE spbx_tab[((87-15)*94+15)/16*16+16];
extern BYTE logging_stack[0x400];
extern WORD logging_stack_size;
extern int word_long;
extern int unit_length; 
extern int disp_tail;
extern int disp_head;
extern int group_no;
extern int current_no;
extern unsigned char space_char[];
extern BYTE out_svw[400];
extern unsigned char group_counter[];
extern int input_cur;
extern int new_no;
extern int jlxw_mode;
extern int jiyi_mode;
extern int result_area_pointer;
extern BYTE result_area[40];
extern BYTE out_result_area[40];
extern WORD out_bfb[40];
extern int out_pointer;
extern int now_cs;
extern int now_cs_dot;
extern unsigned char biaodian_table[]; 
extern unsigned char cc_biaodian[];
extern int biaodian_pos;
extern WORD biaodian_value;
extern BYTE yinhao_flag;
extern BYTE step_mode;
extern BYTE bdd_flag;          
extern BOOL IfTopMost;
extern BYTE word_back_flag;
extern BYTE msg_type;
extern BYTE temp_rem_area[512];
extern BYTE rem_area[512];
extern BYTE out_length;
extern BYTE last_out_length;
extern BYTE cap_mode;
extern WORD mulu_record_length;
extern WORD data_record_length;
extern WORD mulu_true_length;
extern WORD data_start;
extern WORD mulu_max_length;
extern BYTE user_word_max_length;
extern OFSTRUCT reopen;
extern HWND active_win_keep;
extern BYTE d_yinhao_flag,book_name,book_name_sub;  
extern BYTE SdaPromptOpen,DefNewNow; 
extern FARPROC _hh1,_hh2;
extern HANDLE hInst;
extern HANDLE  cisu_hd;
extern HCURSOR hCursor;  
extern FARPROC FAR *hh1,*hh2;
extern FARPROC lpFunc,lpFunc2;
extern HANDLE mdl;
extern BYTE opt_flag;
extern BYTE kb_buffer[35];
extern int OldCaps;
extern BYTE in_buffer[1];              
extern int n,end_flg,CharHi,CharWi;
extern HFONT hFont;
extern HFONT hOldFont;
extern HFONT hSFont;
extern HPEN hPen;
extern BYTE V_Flag;                  
extern OFSTRUCT ofstruct;
extern HDC hDC;
extern HDC hMemoryDC;
extern HBITMAP cur_h;
extern int count2;
extern int pass_word;
extern HWND NowFocus,OptFocus; 
extern BOOL cur_flag,op_flag;
extern WORD old_curx,cur_hibit,cur_start_ps,cur_start_count;
extern HWND hWnd,act_focus;
extern int input_count;
extern int kb_mode,kb_flag;
extern int local_focus;
extern int timer_counter;
extern int msg_count;
extern BYTE msg_bf[50];
extern TimerCounter;
extern KeyBoardState;
extern SdaInst;
extern HWND Return;
extern HWND act_win;
extern HANDLE Hdopt;                   
extern unsigned char jiyi[];
extern WORD sda_trans[5];
extern HWND hInputWnd;
extern HWND hABCWnd;
extern char ExeCmdLine[];
extern BYTE UpdateFlag;  
extern char    jiyi_wenjian_cuo[];
extern BYTE InputBuffer[43];
extern WORD SoftKeyNum;
extern char    tmmr_rem[MAX_PATH];
extern char    user_lib[MAX_PATH];
extern HANDLE hAccTable;
extern HANDLE hImeL;
extern LPIMEL lpImeL;
extern int MoveFlag;
extern POINT pot;
extern HWND hSetOp,NewWordWin;
extern char  *szMsgStr[];
extern BYTE Sd_Open_flag;
extern BYTE kb_mode_save;
extern char TMMR_OPEN_WRONG[];
extern BYTE cpjy,bxsr,qj,bdzh;
extern OFSTRUCT ofs;
extern struct SLBL sb;
extern struct N_SLBL neg;
extern BYTE slbl_tab[];
extern OFSTRUCT openbuf;
extern OFSTRUCT openbuf_kzk,open_user,open_tmmr;
extern BYTE buffer[30];
extern BYTE cmp_head,cmp_state,cmp_bx,by_cchar_flag;
extern WORD cmp_yj,cmp_cisu;
extern LONG r_addr;
extern WORD out_svw_cnt,msx_area_cnt;
extern WORD search_start,search_end,kzk_search_start,kzk_search_end;
extern WORD item_length,kzk_item_length,last_item_name,item_addr,slib_addr;
extern BYTE word_lib_state;
extern WORD lib_w[0xa00];
extern WORD kzk_lib_w[0x400];
extern BYTE auto_mode,word_source,xs_flag,sfx_attr,jiyi_pindu,system_info;
extern BYTE stack1_move_counter;
extern WORD extb_ps;
extern char *std_dct;
extern char *user_dct;
extern BYTE last_flag;
extern LONG last_start_ps;
extern WORD last_size;
extern BYTE stack1_move_counter;
extern char fk_tab[];     
extern WORD sfx_table[];
extern WORD sfx_table_size;
int FAR PASCAL sda_proc(WORD, LPWORD, BYTE, HIMC);
int FAR PASCAL tran_data(int, HIMC, BYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abc95wp.c ===
/*************************************************
 *  abc95wp.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "windows.h"
#include "winuser.h"
#include "immdev.h"
#include "abc95def.h"
#include "abcbx.h"
struct  INPT_BF kbf={40,0,{0}};  
INT_PTR WINAPI OpenDlg(HWND,UINT,WPARAM,LPARAM);
int word_select_bx(int input_char);

int word_long;
int unit_length=2;          /* single word */
int disp_tail=0;
int disp_head=0;
int group_no=24;
int current_no;

/******************************************************************
/*  CharProc(ImeChar,wParam,lParam,hIMC,lpIMC,lpImcP)             *
/*****************************************************************/
extern HWND       hCrtDlg;    
int WINAPI CharProc(ImeChar,wParam,lParam,hIMC,lpIMC,lpImcP)
WORD           ImeChar;
WPARAM         wParam;
LPARAM         lParam;
HIMC           hIMC;
LPINPUTCONTEXT lpIMC;
LPPRIVCONTEXT  lpImcP;
{
    int x;
    
    ghIMC=hIMC;   
    glpIMCP=lpImcP;
    glpIMC=lpIMC;
    TypeOfOutMsg = 0;
    waitzl_flag = 0;                                  //waitzl 3
    
    if (cap_mode){
        if(ImeChar<0x8000){                //for mouse message pass
            send_one_char(ImeChar/*wParam*/);   // changed 94/8/6
            return(0);
        }
    }

    if(lpIMC->fdwConversion&IME_CMODE_NATIVE){
        switch(kb_mode){
            case CIN_STD:                         //stand change
                if (V_Flag)
                    v_proc(ImeChar);         // V fuction
                else {
                    if (sImeG.cbx_flag==1) {    
                        if (bx_allow) {         
                            if (BX_MODE(ImeChar,wParam))  
                                return(0);    
                        } 
                    } //if (sImeG.cbx_flag)

                    STD_MODE(ImeChar);
                }
                break;

            case CIN_SDA:                         //double hit inputing
                for (x=0; x<(sizeof sda_trans)/2; x++) //Note sizeof!! 1992 2
                    sda_trans[x]=0;                                 //clear the transport buffer

                if(((!step_mode)||(step_mode==RESELECT))&&((ImeChar == 0x60)||(ImeChar == 0x27)))
                    return (STD_MODE(ImeChar));

                if (sImeG.cbx_flag==1) {              
                    if (bx_allow){
                        if (BX_MODE(ImeChar,wParam))
                            return(0);
                    } //if (bx_allow)
                } //if (sImeG.cbx_flag)

                if ((step_mode==ONINPUT)&&(I_U_Flag==1)){
                    STD_MODE(ImeChar);
                    return(0);
                }

                if ( if_zimu_or_not((BYTE)ImeChar)/*||(wParam == 0x60)*/||(wParam == 0x27) )
                {
                    if ((step_mode==START)||/*(Return==NULL)||*/(step_mode==RESELECT))
                    {
                        if (((wParam&0xdf)=='U')||((wParam&0xdf)=='I'))
                        {
                            I_U_Flag=1;
                            STD_MODE(ImeChar);
                            return(0);
                        } else {
                            I_U_Flag=0;
                        }//else...
                    }//if (step_mode....
       
                    if (!Sd_Open_flag){
                        if(KeyBoardState){
                            SdaPromptOpen=1;
                            tran_data(
                                0,              
                                ghIMC,
                                Sd_Open_flag);
                        }//if Key
                    }//if (Sd_Open_flag)
                }//if (if_zimu_...

                if ((wParam==VK_BACK)&&(step_mode==ONINPUT)
                    &&(Return==NULL)&&(!Sd_Open_flag)){
                    if(KeyBoardState){
                        SdaPromptOpen=1;
                        tran_data(
                            0,              
                            ghIMC,
                            Sd_Open_flag);
                    }
                }//if (wParam)


                sda_proc(ImeChar, (LPWORD)sda_trans, step_mode, ghIMC);         //change the key into standed

                if (sda_trans[0]==0xff)      //change error or input more than 40 chars
                    break;

                if (sda_trans[0]==0xf0){                        //if free the dialog?

                    if(KeyBoardState){
                        tran_data(
                            2,              
                            ghIMC,
                            Sd_Open_flag);
                    }//if key

                    SdaPromptOpen=0;
                    sda_trans[0]=sda_trans[1];
                    sda_trans[1]=0;
                }

                x=0;                                                            //chinese spelling
                while (sda_trans[x]){
                    if (wait_flag && (sda_trans[x]=='h'))     //waitzl 4
                    waitzl_flag = 1;                
                    STD_MODE(sda_trans[x++]);
                }
                break;
        }
   }else
        send_one_char(ImeChar/*wParam*/);

   return (0);
     
}


/****************************************************************
v_proc():       produce the V fuction
*****************************************************************/
int WINAPI v_proc(input_char)
WORD input_char;
{
    int i, n;

    n=0;

    if (V_Flag==1) {
        switch (input_char) {
            case '0':
            case VK_BACK:
                 cls_inpt_bf(0);
                 step_mode = START;                                                           
                 V_Flag = 0;
                 return(1);
         }
    }

    if ((if_number_or_not((BYTE)input_char)) && (V_Flag!=2)){ 
        input_char &= 0x000f;           //get the QUMA
        for (i=1; i<=94; i++){          //get WEIMA
           if (input_char==2){
               if (i==1)  i=17;
               if (i==67) i=69;
               if (i==79) i=81;
           }
           out_svw[n++]=input_char+0xa0;                                  
           out_svw[n++]=i+0xa0;
        }

        group_no=94;
        if (input_char==2)  group_no=72;
        unit_length=2;
        current_no=0;
        disp_tail=0;
        V_Flag=0;
        msg_type=2;                       //94/8/22
        fmt_transfer();
        SetToIMC(ghIMC,(LPSTR)&out_svw,(WORD)group_no,(WORD)(unit_length+0x1000));                              
        move_result();
        prompt_disp();
        word_back_flag=0x55;                //93,9,4
        step_mode=SELECT;
    } //if (if_number_or_not)
    else {
        V_Flag=2;
        step_mode=ONINPUT;
        STD_MODE(input_char);
    }

    return (1);

}

int ReDrawSdaKB(hIMC, KbIndex, ShowOp)
HIMC hIMC;
DWORD KbIndex;
DWORD ShowOp;
{
//return 0;
if (KbIndex)                    // if not PC KB
    return 0;
if (kb_mode != CIN_SDA)
    return 0;            // if not SDA mode
if (ShowOp==SW_HIDE)  
    return 0;            // if SW_SHOW....

if (SdaInst){
    tran_data(
                       0x5678,              //Return,
                       ghIMC,//hWnd,
                       Sd_Open_flag);
    return 1;}
 return 0;
}

void WINAPI DispModeEx()  
{
    cls_inpt_bf(0);
    step_mode=START;
}

/****************************************************************
    FUNCTION: disp_mode(hW)
    PORPUSE: display the mode item at the input window.
*****************************************************************/
void WINAPI DispMode(HIMC hIMC)
{
    LPINPUTCONTEXT   lpIMC;
    LPPRIVCONTEXT    lpImcP;
    UINT             fdwConversion; 

    if (!hIMC)
        return;
    lpIMC =(LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC)
        return;
    lpImcP =(LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP)
        return;

    DispModeEx();                    //zl#3(hW);

    if (SdaInst&&(kb_mode!=CIN_SDA)){

        Sd_Open_flag=0;
        SdaPromptOpen=0;
        SdaInst=0;
  
    }
    if ((kb_mode==CIN_SDA)&&(!SdaInst)) {

        SdaInst = 1;   // The ABCSDA.DLL is Load In.
       
    }  
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);
}






void WINAPI DispSpecChar(c,n)
int c,n;
{
   int i;
   for (i=now_cs;i<n+now_cs;i++)
    InputBuffer[i]=(BYTE)c;
    ImeSetCompositionString(ghIMC,SCS_SETSTR,NULL,0,
                  &InputBuffer,now_cs+i);


}

//////////////////////////////////////////////////////////////////////////



void WINAPI show_char(string,count)
unsigned char *string;
int count;
{

    int i;
    BOOL fdwImeMsgKeep;

    if(count==0) {
      ImeSetCompositionString(ghIMC,SCS_SETSTR,NULL,0,
                  &InputBuffer,now_cs);
      return ; }


    for(i=0; i<count; i++)
        InputBuffer[now_cs+i]=string[i];
    now_cs+=count;
    if (!(wait_flag | waitzl_flag )){              //waitzl 5

    ImeSetCompositionString(ghIMC,SCS_SETSTR,NULL,0,
                  &InputBuffer,now_cs);
        }

}


/******************************************************
disp_jiyi(): display the word "jiyi" in the windows
*******************************************************/
void WINAPI disp_jiyi(xxx)
HANDLE xxx;
{
}


/*********************************************************************
PROMPT_DISP(): display the result of changing.
**********************************************************************/
void WINAPI prompt_disp()
{

    int i;

    pass_word=0;

    disp_head=disp_tail;


    n=0;
    for(i=0; i<now.fmt_group; i++){

         disp_tail++;

        if (disp_tail>=group_no){
            pass_word=1;
            if (disp_head==0)
             pass_word=2;
            break;}
       }//for (i=...

   if (pass_word<1){
           pass_word=3;
           if (disp_head==0)
           pass_word=4;
         }


 SetToIMC(ghIMC,NULL,(WORD)pass_word,(WORD)disp_head);

}


/****************************************************
 cls_prompt
*****************************************************/
int WINAPI cls_prompt()
{
   int i;


    for (i=0;i<sizeof InputBuffer;i++) InputBuffer[i]=0x20;   //Clear the display buffer.



    now_cs = 0;
    //DispSpecChar((BYTE)0x20,sizeof InputBuffer);

    cs_p(0);

    SetCloseCompWinMsg(0);
    cls_prompt_only();   

    return 0; 

}

int WINAPI cls_prompt_only(){
   int i;
   LPINPUTCONTEXT       lpIMC;
   LPPRIVCONTEXT   lpImcP;
    

    if (!ghIMC) return (0); // The IMC must be a valid one.
   
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(ghIMC);
    if(!lpIMC)  return 0; 
  
  
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
   
    if ( lpImcP != NULL )
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                            ~(MSG_OPEN_CANDIDATE);
    
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(ghIMC);

    return 0; 
}

                      
int WINAPI SetCloseCompWinMsg(int ClsFlag)
{
   LPINPUTCONTEXT       lpIMC;
   LPPRIVCONTEXT   lpImcP;
    

    if (!ghIMC) return (0); // The IMC must be a valid one.
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(ghIMC);
    if(!lpIMC)  return 0; 
  
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!ClsFlag )
    {
        if ( lpImcP != NULL )
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION ) &
                                ~(MSG_COMPOSITION) ;
    }
    

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(ghIMC);

    return 0; 
}




void WINAPI ABCstrnset(bufferd,value,n)
LPSTR bufferd;
BYTE value;
{
  int i;
  for (i=0; i<n; i++) bufferd[i]=value;
  return;
}

LPSTR WINAPI ABCstrstr(str1,str2)
LPSTR str1,str2;
{
 int i,m,n,j,pos;
 m=lstrlen(str1);
 n=lstrlen(str2);
 if(!n) return str1;

 pos=0xffff0;
 for(i=0;i<m-n; i++){
     pos=i;
    for(j=0;j<n;j++) {
       if (str1[i+j]!=str2[j])
          { pos=0xffff0;break;}}
    if (pos!=0xffff0) break;
    }
 if (pos==0xffff0) return NULL;
 return str1+pos;
 }
          

/*****************************************************
back_a_space(x): do a BACKSPACE command
******************************************************/
int WINAPI back_a_space(x)
int x;
{

    if (x<=0){
         x=0;
         MessageBeep(0);}
    else{
        x--;
        InputBuffer[x]=' ';
        cs_p(x);
    }
    return(x);
}


/******************************************************
cs_p
*******************************************************/
int WINAPI cs_p(x)
int x;
{
        int xx,yy,zz,kk,i;
        now_cs=x;

        cur_hibit=1;
        hDC=GetDC(hInputWnd);
        kk=(WORD)(GetText32(hDC, InputBuffer, x))
                    +CUR_START_X;
        cur_start_ps=(WORD)(GetText32(hDC, InputBuffer,cur_start_count ))
                    +CUR_START_X;
        zz=kk-cur_start_ps;

        if (x<cur_start_count){
         cur_start_count=(WORD)x;
         now_cs_dot=CUR_START_X;
        ReleaseDC(hInputWnd,hDC);
         UpdateCompCur(hInputWnd);
        cur_hibit=0;
        return 0;}

        if (zz>=(CUR_START_X+(lpImeL->rcCompText.right-4))){
            xx=CUR_START_X;
            for (i =now_cs; i>0; i--)
            { yy=GetText32(hDC, &InputBuffer[i-1], 1);
            if ( (xx+yy) >= (CUR_START_X+(lpImeL->rcCompText.right-4)))
              break;
            else xx+=yy;
            }                                                                                                        
          cur_start_count=(WORD)i;

         // Adgust for Chines Word Display

            kk=0;
            for (i=0; i<cur_start_count; i++){
              if (InputBuffer[i]>0xa0){
                  kk++;
                  kk&=1;
                  } else
                    kk=0;}
            if (kk){
                xx=xx- GetText32(hDC, &InputBuffer[cur_start_count], 1);
                cur_start_count++;
                }

          cur_start_ps=(WORD)GetText32(hDC, &InputBuffer[0], i);
           now_cs_dot=xx;
        ReleaseDC(hInputWnd,hDC);
        UpdateCompCur(hInputWnd);
        cur_hibit=0;
        return 0;
        }

        cur_hibit=0;
        ReleaseDC(hInputWnd,hDC);

        if (zz<(CUR_START_X+(lpImeL->rcCompText.right-4))){
            now_cs_dot=kk-cur_start_ps;
                    DrawInputCur();
                    }
        return 0;

}
/********************************************************************
  Function:DrawInputCur
********************************************************************/
void WINAPI DrawInputCur()
{
 

    HDC OldDC;
    if (!hInputWnd) return;

    if ((WORD)now_cs_dot!=old_curx)
    {
           if (cur_flag)
           {
            hDC=GetDC(hInputWnd);
            OldDC=SelectObject(hMemoryDC,cur_h);
            BitBlt(hDC,old_curx+lpImeL->rcCompText.left,
              lpImeL->rcCompText.top+3,
               CUR_W,CUR_H,hMemoryDC,0,0,SRCINVERT);
            SelectObject(hMemoryDC,OldDC);
            ReleaseDC(hInputWnd,hDC);
            cur_flag=!cur_flag;
           }
           old_curx=(WORD)now_cs_dot;
    }
    hDC=GetDC(hInputWnd);
    OldDC=SelectObject(hMemoryDC,cur_h);
    BitBlt(hDC,now_cs_dot+lpImeL->rcCompText.left,
          lpImeL->rcCompText.top+3,
          CUR_W,CUR_H,hMemoryDC,0,0,SRCINVERT);
        SelectObject(hMemoryDC,OldDC);
    ReleaseDC(hInputWnd,hDC);
    cur_flag=!cur_flag;

    return;
}//#0

/************************************************************
UpdateUser(): if the user.rem has changed, clear the tmmr.rem_area
        and read the user.rem's index once again.
*************************************************************/
void WINAPI UpdateUser()
{
// 94/4/16      HANDLE hd;
    int hd;
    int i;
    WORD op_count;
    OFSTRUCT ofs;


    if (UpdateFlag) {               //increase the user.rem
        for (i=0; i<0x200; i++)          //1993.3
            tmmr.rem_area[i] = 0;
        last_item_name=0;               //clear the date in memory flag
        UpdateFlag = 0;

        hd = OpenFile (user_lib, &ofs, OF_READ);      //1993.4.15
        if (hd==-1)
            err_exit_proc(jiyi_wenjian_cuo);
        _llseek(hd,0xa000l,0);
        op_count=(WORD)_lread(hd,&kzk_ndx,NDX_REAL_LENGTH);
        if (op_count!=NDX_REAL_LENGTH)
            err_exit_proc(jiyi_wenjian_cuo);
        _lclose(hd);
        }
}




//##!!extern void AddExtLib();


///////////////////////////////////////////////////////////////////////////
//             STD_MODE
//      Deels with stdandard Chinese Pinyin input with some written_stroke
//         attributes when neccerry.
//
//////////////////////////////////////////////////////////////////////////

int WINAPI STD_MODE(input_char)
WORD input_char;
{
  int leibie,input_char_type,i;
  sImeG.InbxProc = 0;
  wait_flag=0;
  if (input_char==BACKWORD_KEY)
        return(backword_proc());
  if (input_char==FORWORD_KEY){
     if ((step_mode!=ONINPUT)&&(group_no>1))
        step_mode=SELECT;
        return(0);}

  switch(step_mode){             //step_mode indicate the input step
                 // step_mode take this value:
                 //  START=0  first input pinyin
                 //  SELECT=1 can select/cansel the result
                 //  RESELECT=2 use FORCE SELECT KEY
                 //  ONINPUT=3 just in inputing step
    case SELECT:
        if ((input_char==VK_HOME*0x100)||
            (input_char==VK_END*0x100)||
            (input_char==VK_PRIOR*0x100)||
            (input_char==VK_NEXT*0x100)){
                word_select(input_char);
                break;}

        if (input_char>=0x8000)
            input_char-=0x8000;

        if ((input_char==VK_SPACE)||(input_char==VK_RETURN)){
           if(!out_result(0))
                step_mode=RESELECT;             //92/12/14 SZ
            break;
            }

        if (input_char==VK_ESCAPE){
            cls_inpt_bf(0);
            step_mode=START;
            break;
            }

        if (input_char==VK_BACK){
             if (word_back_flag!=0x55)
                del_and_reconvert();
            break;
            }

        if (if_zimu_or_not((BYTE)input_char)){
            wait_flag=1;
            while(out_result(0));
            step_mode=START;
            }
        else{
            word_select(input_char);
            break;
            }

    case RESELECT:
    case START:

        if (input_char >= 0x8000){
            input_char -= 0x8000;
            if ( word_select(input_char) == 1 )
                return(0);
            else
                return(send_one_char(input_char));
            }//if (input_char)

        else{
            if (if_first_key(input_char)){
                if (input_char=='v')
                V_Flag = 1;
                else {
                V_Flag = 0;        }     //93,9,3
                step_mode=ONINPUT;
                sent_back_msg();
                if (wait_flag) cls_inpt_bf(1);
                    else cls_inpt_bf(1);         //1993. cock
                }

            else{
               if ((kb_mode==CIN_SDA)&&(input_char==0x27)){  //1993. cock
                step_mode=ONINPUT;      //1993. cock
                sent_back_msg();       //1993. cock
                if (wait_flag) cls_inpt_bf(1);
                    else cls_inpt_bf(1);         //1993. cock
                }//if(kb_mode)         //1993. cock
               else
                return(send_one_char(input_char));
               }
             }

    case ONINPUT:
         input_char_type=sent_chr1(input_char);

         switch(input_char_type){
            case REINPUT:
             ImeSetCompositionString(ghIMC,SCS_SETSTR,NULL,0,&InputBuffer,now_cs);//#52224

             step_mode=START;
             return(0);
             break;

            case CLC:
             return(0);       // Continue input.

            case STC:              // input finished
             if (V_Flag){
                msg_type=2;   //94/8/22
                send_msg(&in.buffer[1], in.true_length-1); //1993.3 skip the 'v'
                V_Flag = 0;
                step_mode = 0;
                return(0);}

             step_mode=4 ;    // enter proccessing step
             leibie=analize();
             if (leibie==BIAODIAN_ONLY){
                  out_result_area[0]=(BYTE)biaodian_value;
                  out_pointer=2;    // may not used
                  msg_type=0;
                  out_result(0);
                  step_mode=0;
                  return(0);
                  }             //only bioadian case

             return(call_czh(leibie));
        }// switch (sent_chr1)

    } //switch step_mode

    return 0;
}
/*******************************************************************
&2:
DealWithSH():
********************************************************************/
void WINAPI DealWithSH()
{
 int len,p;

if (group_no <= 1)
    return;
if (unit_length > 2)
    return;
if (in.true_length != 2) return;
 
if (in.buffer[0] !=     's') return;
if (in.buffer[1] != 'h') return ;

current_no = 1; 
}

/*******************************************************************
&2:
call_czh():
********************************************************************/
int WINAPI call_czh(mtype)
int mtype;
{
        int x;
        unsigned char prompt_flag_wu[]="ޣ";


        jiyi_mode=0;
        in.buffer[in.true_length]=0;
        sImeG.cp_ajust_flag = 0;
        group_no=0;
        unit_length=0;

        if (cwp_proc(mtype)!=1){
            MessageBeep((UINT)-1);
            MessageBeep(0);                       //word exchange is wrong
            MessageBeep(0);
            MessageBeep(0);                       //word exchange is wrong

            if (result_area_pointer>=0){
            //      jiyi_mode=0;
            //      group_no =0;
            //      cls_prompt_only();
            //      unit_length=result_area_pointer;
            //      out_result(1);
            //      step_mode=0;
            //      return(9);
            //      }//result_area
            //else{
            //      show_char(prompt_flag_wu,4);

                step_mode=ONINPUT;
                return(0);
                }
            } //cwp_proc=-1


            disp_jiyi(0);
            if (msg_type==2){
                current_no=0;
                move_result();
                out_result(1);   /* special change*/
                return(0);
                }
            if_jlxw_mode();
            fmt_transfer();
            current_no=0;
            DealWithSH();
            if (group_no==1){
                if (sImeG.cp_ajust_flag!=0)
                    result_area_pointer-=unit_length;
                move_result();
                step_mode=1;
                return(0);
                }//if (group_no=1)
            else{

                disp_tail=0;
                if (sImeG.cp_ajust_flag==1)
                    AutoMoveResult();
                else
                    move_result();

                SetToIMC(ghIMC,(BYTE *)&out_svw,(WORD)group_no,(WORD)unit_length);
                prompt_disp();
                step_mode=1;
                return(0);
                }//else
}

/**********************************************************************/
/* MoveWordIntoCand()                                                  */
/**********************************************************************/
void WINAPI MoveWordIntoCand(
    LPCANDIDATELIST lpCandList,
    LPBYTE            srcBuffer,
    BYTE             srcAttr,
    WORD             perLength )
{
  
    int i;

    if (lpCandList->dwCount >= MAXCAND) {
    return;
    }


                // add this string into candidate list
    for (i=0; i<perLength; i++)   
    *(LPBYTE)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]+i) =srcBuffer[i] ;
    
                // null terminator

    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
    lpCandList->dwCount] + i ) = '\0';

    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
    lpCandList->dwCount] + i+1 ) = srcAttr;

    
    
    lpCandList->dwOffset[lpCandList->dwCount + 1] =
    lpCandList->dwOffset[lpCandList->dwCount] +
    i + sizeof(TCHAR)+1;
    lpCandList->dwCount++;

    return;
}

/**********************************************************************/
/* SetToIMC()                                                  */
/* Return vlaue                                                       */
/*      the number of candidates in the candidate list                */
/**********************************************************************/
UINT WINAPI SetToIMC(ghIMC,srcBuffer,srcCount,perLength)
    HIMC                ghIMC;
    BYTE               *srcBuffer; //soarce buffer (normal for out_svw) 
    WORD                srcCount;  //How many candidates are.            
    WORD                perLength; //How long of each of that? 
{
    LPINPUTCONTEXT      lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    INT             i,j,nRecord,where;
    WORD                    temp[20],xx,yy;
    LPSTR           ppt;
    static      int CandiCount;

    where = 0 ;
    if (perLength>0x1000){
        perLength -=0x1000;  // if where = 1, msg_type = 2
        where = 1;} 
     

    if (!ghIMC) return (0); // The IMC must be a valid one.
   
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(ghIMC);
    if(!lpIMC)  return 0; 
  
    if (srcBuffer) ClearCand(lpIMC);

    if (!lpIMC->hCandInfo){
    ImmUnlockIMC(ghIMC);
     return (0); }
                        // The CandInfo must...

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
    ImmUnlockIMC(ghIMC);
    return (0);}


    lpCandList = (LPCANDIDATELIST)
    ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
if(srcBuffer){
    CandiCount = srcCount;
    lpCandList->dwCount = 0;
    for (i=0; i<(int)srcCount; i++){
        if ( where ) {
             ppt = (LPSTR)temp;
         for (j=0; j<perLength; j++)
                ppt[j] = srcBuffer[i*perLength+j];
                      }
         else {
              for(j=0; j<perLength; j=j+2){
                xx = srcBuffer[i*perLength+j];
                yy = srcBuffer[i*perLength+j+1]*0x100;
                yy = yy + xx;
             temp[j/2]=(WORD)find_hz(yy);
                } // for j loop
              }  // else loop

        MoveWordIntoCand(lpCandList,
                 (LPSTR)temp,
                         0,//NULL,
                         perLength);
    } //for i loop
                                    // default start from 0
    lpCandList->dwSelection = 0;
                                    // for showing phrase prediction string(s)
    nRecord = lpCandInfo->dwCount;

} else {

           lpCandList->dwSelection = perLength;
           //Hack for IME aware application 9/13/96
           lpCandInfo->dwCount = CandiCount;    
           // for showing phrase prediction string(s)
           nRecord = lpCandInfo->dwCount;
         }


    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
   
    if ( lpImcP != NULL )
    {
        if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
            (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                                    ~(MSG_CLOSE_CANDIDATE);
        } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        } else {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                                ~(MSG_CLOSE_CANDIDATE);
        }
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(ghIMC);
    return (nRecord);    /* The real number of being moved */
}




/********************************************************************
  word_select(wParam): select the word or turn to the next or up page
*********************************************************************/
int WINAPI word_select(input_char)
int input_char;
{
    int x;

    switch (input_char){

       case VK_END*0x100:
       case VK_NEXT*0x100:
       case '=':                               //94/8/22
       case ']':
      if (disp_tail>=group_no)
          MessageBeep(0);
      else{

          if(input_char == VK_END*0x100 ){
              disp_head = (group_no - 1)/now.fmt_group*now.fmt_group;
              disp_tail = disp_head;}

          fmt_transfer();
          current_no=disp_tail;
        result_area_pointer-=unit_length;       //if recall, unit_length=8
        if (in.info_flag==1)                    //result_area_pointer maybe small
            result_area_pointer=0;                  //than zero, so reset it =0

          move_result();
          prompt_disp();}
      return(1);                            //means break the STD MODE

       case VK_HOME*0x100:
       case '-':                                //94/8/22
       case '[':
       case VK_PRIOR*0x100:
       if (disp_head==0)

           MessageBeep(0);
       else{
          
          if(input_char == VK_HOME*0x100 )
            disp_head = 0;
          else
           disp_head=disp_head-now.fmt_group;
           
           disp_tail=disp_head;
           fmt_transfer();
          current_no=disp_tail;
        result_area_pointer-=unit_length;       //if recall, unit_length=8
        if (in.info_flag==1)                    //result_area_pointer maybe small
            result_area_pointer=0;                  //than zero, so reset it =0
          move_result();
           prompt_disp();
           }
       return(1);

    default:
       if (if_biaodian((BYTE)input_char)){                //1993.1.15 cock
        if (!biaodian_value){
        sent_chr1(input_char);          //this produce the situation
        bd_proc();                      //when the result had display
        while(out_result(0));           //94-4-22
            step_mode=START;
        return(1);                      //1993.1.15 cock
        }
           }

        if ( !if_number_or_not((BYTE)input_char))  {      //1993.4.22
        while(out_result(0));       //94-4-22                    //if input is not number
        step_mode = START;                      //send the result and set start step
        return(1);
        }                                       //1993.4.22

        if(input_char=='0') x=disp_head+9;                  //92/12/21 SZ
        else
        x=(input_char-0x30-1)+disp_head;

        if (x>=group_no)                 //1994.4
            current_no=group_no-1;
        else
            current_no=x;
        result_area_pointer-=unit_length;       //if recall, unit_length=8
        if (in.info_flag==1)                    //result_area_pointer maybe small
            result_area_pointer=0;                  //than zero, so reset it =0
        else{
             if((step_mode==RESELECT)
                &&biaodian_value
                &&(result_area_pointer>=biaodian_len))
                result_area_pointer-=biaodian_len;
            }

        move_result();
        pindu_ajust();
        step_mode=RESELECT;                         //Note: pindu_ajust
        out_result(0);                              // must above out_result
        return(1);                                 // step_mode must be set to 2(Re..)
    }
}

/*********************************************
del_and_reconvert()
**********************************************/
int WINAPI del_and_reconvert()
{
    int x;

    if (word_back_flag==0xaa)
        return(same_as_backwords());

    wp.dw_count--;
    x=wp.dw_stack[wp.dw_count+1]-wp.dw_stack[wp.dw_count];
    if (x==1){                      //if the single word exchange
        if (!wp.dw_count)
            return(same_as_backwords());
        else{
            wp.dw_count--;
            x=wp.dw_stack[wp.dw_count+1]-wp.dw_stack[wp.dw_count]+1;
            }
        }
    result_area_pointer-=x*2;
    word_back_flag=x-1;
    wp.xsyjw=wp.dw_stack[wp.dw_count];
    return(call_czh(13));

}

/***********************************************
backword_proc()
************************************************/
int WINAPI backword_proc()
{
    switch(step_mode){
        case SELECT:
            return(same_as_backwords());
            break;

        case RESELECT:
        case START:
              if ((!msg_type)&&((kb_mode==CIN_STD)||(kb_mode==CIN_SDA)))
                return(same_as_backwords());
               else
                send_msg(msg_bf,msg_count);
               break;
        case ONINPUT:
            return(call_czh(14));
            break;
        }

    return 0;
}

/***********************************************
same_as_backwords()
************************************************/
int WINAPI same_as_backwords()
{
    int i;

    if (in.buffer[0]!='v'){
        cls_prompt_only();
        if (in.true_length>=1)
            if (in.buffer[0]!='U')
                if (!cap_mode){
                    cs_p(input_msg_disp);
                    show_char(in.buffer,in.true_length);
                    cs_p(input_msg_disp+in.true_length);
                    half_init();
                    if (kb_mode==CIN_STD||kb_mode==CIN_SDA){                                //STD_MODE
                        step_mode=ONINPUT;
                        return(0);
                        }//if (kb_mode)
                    return(read_kb());                              //double hit input_mode
                    }//if (cap_mode)

        }//if (in.buffer[0])
    out_length=last_out_length;
    return(REINPUT);

}
/*******************************************
 AutoMoveResult()
********************************************/
void WINAPI AutoMoveResult()
{
     int i,j,ct;
     WORD x;
     BYTE *ps,*pd;

     x=(WORD)unit_length;
     j=unit_length*current_no;

     for (i=0;i<group_no;i++){
        ct=0;
        for (j=0; j<x; j++)
           if (result_area[result_area_pointer+i]==out_svw[j*unit_length+i])
              ct++;
           if (ct == x){
              current_no=i;
              break;}
        }

    disp_auto_select();

}


/*******************************************
 move_result()
********************************************/
void WINAPI move_result()
{
     int i,j;
     WORD x;
     BYTE *p;

     p=(BYTE *)msx_area;
     if (in.info_flag==1){                                              // recall statue
        x=*(p+current_no*22);
        j=current_no*22+1;
        for (i=0; i<x; i++)
            result_area[result_area_pointer++]=*(p+j+i);
        }
     else{
        x=(WORD)unit_length;
        j=unit_length*current_no;
        for (i=0; i<x; i++)
        result_area[result_area_pointer++]=out_svw[j+i];
        }

     if (now.fmt_start!=12)
        disp_auto_select();

}

/********************************************
pindu_ajust()
********************************************/
int WINAPI pindu_ajust()
{
    if (sImeG.auto_mode!=1)
        return(0);                              //if the pindu_ajust mode is set
    if (group_no<=1)
        return(0);
    if (unit_length>6)
        return(0);
    if (msg_type&2)
        return(0);

    switch (unit_length){
        case 2:
            rem_pd1((WORD *)&out_svw[current_no*unit_length]);
            break;
        case 4:
            rem_pd2((WORD *)&out_svw[current_no*unit_length]);
            break;
        default:
            rem_pd3((WORD *)&out_svw[current_no*unit_length]);
            break;
        }
    return (0);
}




/***********************************************************
cls_inpt_bf():  inputing information init. clear the display
        area, and give the init_value to processing
        paraments.
************************************************************/
void WINAPI cls_inpt_bf(int hFunc)
{
    int i;
     cls_prompt_only();
     input_cur=0;//input_msg_disp;

     for (i=0;i<in.max_length;i++)
         in.buffer[i]=0;

     for (i=0;i<sizeof InputBuffer; i++) InputBuffer[i]=' ';
     SetCloseCompWinMsg(hFunc); 
     cs_p(0/*input_msg_disp*/);
     

     pass_word=0;
     group_no=0;
     now.fmt_group=0;
     disp_head=0;
     disp_tail=0;

     in.true_length=0;
     in.info_flag=0;

     result_area_pointer=0;

     word_back_flag=0;

     biaodian_value=0;

     msg_type=0;
     jiyi_mode=0;
     new_no=0;
     end_flg=0;

}


void InitCvtPara(void){
     int i;

     input_cur=0;//input_msg_disp;

     for (i=0;i<in.max_length;i++)
         in.buffer[i]=0;

     for (i=0;i<sizeof InputBuffer; i++) InputBuffer[i]=' ';
     now_cs = 0;
     cs_p(now_cs);
     
     step_mode = 0;
     pass_word=0;

     in.true_length=0;
     in.info_flag=0;

     result_area_pointer=0;

     word_back_flag=0;

     biaodian_value=0;

     msg_type=0;
     jiyi_mode=0;
     new_no=0;
     end_flg=0;

     V_Flag = 0;
     bx_inpt_on = 0;
}


/*****************************************
half_init()
******************************************/
void WINAPI half_init()
{
    step_mode=ONINPUT;
    result_area_pointer=0;
    biaodian_value=0;
    new_no=0;
    msg_type=0;
    word_back_flag=0;
    jiyi_mode=0;
    input_cur=now_cs;
}

/*******************************************************
sent_chr1(): send the string received from the keyboard
         to the received buffer.
         "JMP K1":     return(REINPUT)
         "JMP RECALL": return(RECALL)
         "STC":        return(STC)
         "CLC":        return(CLC)
********************************************************/
int WINAPI sent_chr1(input_char)
int  input_char;
{
    int bd_find=0,i;

    if ((input_char < 0x21)||(input_char == 0x12e)){
    switch(input_char){

       case VK_ESCAPE:               //VK_ESCAPE=0x1b:
        cls_inpt_bf(0);
        return(REINPUT);              /* JMP K1 */

       case VK_SPACE:                 //CK_SPACE=0x20
        in.info_flag=BY_WORD;
        return(STC);                  /* STC */

       case VK_DELETE+0X100:
        if (in.true_length>input_cur){
            for (i=0;i<in.true_length-input_cur-1;i++)
             in.buffer[input_cur+i]
                =in.buffer[input_cur+i+1];
            in.true_length--;

           in.buffer[in.true_length]=0x20;
            cs_p(0);
            show_char(in.buffer,in.true_length+1);
            cs_p(input_cur);
            return(CLC);}               /* CLC */
        else{
             MessageBeep(0);
             return(CLC);}


       case VK_BACK:                                //VK_BACK=0x08
        if (!input_cur){
            if (in.true_length){
            MessageBeep(0);
            return(CLC); }     //1993.4 oringal return(CLC)
            else {
            MessageBeep(0);
            return(REINPUT); }     //1993.4 oringal return(CLC)
            }

        in.true_length--;                  //1993.4.16
        if ( !in.true_length ) {           //1993.4.16
            end_flg=0;                     //????
            input_cur=0;
            cls_inpt_bf(0);
            V_Flag=0;                           //93.9.4
            return(REINPUT);}                  /* JMP K1 */
        else{
            input_cur--;
            for (i=0;i<in.true_length-input_cur;i++)
             in.buffer[input_cur+i]
                =in.buffer[input_cur+i+1];
           in.buffer[in.true_length]= 0; //0x20;         //95/8/22 zst
            cs_p(0);                                                     
            show_char(in.buffer,in.true_length/*+1*/);   //95/8/22 zst
            cs_p(input_cur);
            return(CLC);}               /* CLC */

       case VK_RETURN:                 //VK_RETURN=0x0d:
        in.info_flag=BY_CHAR;
        new_no=0;
        return(STC);                   /* STC */
       default:
        MessageBeep(0);
        return(CLC);                   /* CLC */
      }
       }

    else{
    switch(input_char){
       case VK_LEFT+0x100:
            if (input_cur>0) input_cur--;
            cs_p(input_cur);
            return (CLC);
       case VK_RIGHT+0x100:
            if (input_cur<in.true_length) input_cur++;
            cs_p(input_cur);
            return (CLC);
       case VK_UP+0x100:
               input_cur=0;
               cs_p(input_cur);
            return(CLC);
       case VK_DOWN+0x100:
               input_cur=in.true_length;
               cs_p(input_cur);
            return (CLC);

        case ']':
        case '[':
    if (!V_Flag)
        {
          if (input_char==']')
             jlxw_mode=1;
          else
             jlxw_mode=-1;
          in.info_flag=BY_WORD;
          return(STC);                    /* STC */
        }

        default:
        if (if_biaodian((BYTE)input_char) && (!V_Flag))     //1993,3
              bd_find=1;

        if (in.max_length<=in.true_length){
                              // in.true_length=in.max_length;
            MessageBeep(0);
            return(CLC);       //1994.4  old =STC               // changed 12-12 SZ
            }

        else{
            if(input_cur>=in.true_length){
            in.buffer[in.true_length++]=(BYTE)input_char;
            show_char(&in.buffer[input_cur],1); //1994.4.5
            input_cur++;
            cs_p(input_cur); // zst 95.54

            if (bd_find==1)
                return(STC);                               /* STC */
            else
                return(CLC);}
            else{

            if((!input_cur)&&((input_char&0xdf)=='V'))
                        return(CLC);   //1994.7.24

            for (i=0; i<in.true_length-input_cur;i++)
                in.buffer[in.true_length-i]
                =in.buffer[in.true_length-i-1];                                                        /* CLC */
            in.buffer[input_cur++]=(BYTE)input_char;
            if (!bd_find){
                    in.true_length++;
                    cs_p(0);
                    show_char(in.buffer,in.true_length);
                    cs_p(input_cur);
                    return(CLC);
                      }
             else{
                       for(i=input_cur;i<in.true_length;i++)
                       in.buffer[i]=0x20;  //1993.4.20
                    cs_p(0);
                    show_char(in.buffer,in.true_length);
                    cs_p(input_cur);
                       in.true_length=(WORD)input_cur;  //1993.4.20
                    return(STC);
                  }

             }//#4 if now_cs...else
              }//#3 if max...else
        }//#2 case
    }//#1 if..else
}//#0


/*******************************************************
&4:
if_biaodian(x): judge if the input is "biaodian"
        return(FALSE): NO
        return(TRUE):  YES
********************************************************/
BOOL if_biaodian(x)
BYTE x;
{
    int i;
    if ((step_mode==ONINPUT)&&(x==0x27)) return(FALSE); //94/8/22

    if (x=='$') {
          if((in.buffer[0]&0xdf)=='I')
                if((step_mode!=START)&&(step_mode!=RESELECT))
                    return (FALSE);}

    for (i=0; i<lstrlen(biaodian_table); i++){
        if (x==biaodian_table[i]){
            biaodian_pos=i;        /* record the porsition in biaodian_table */
            return(TRUE);
        }
    }
     return(FALSE);
}

/******************************************************
&3:
analize(): analize the input information
        process the biaodian , and analize the
        first byte of the input information.
        return(BIAODIAN_ONLY): chinese biaodian
        return(0):             standard change
        return(1):             ABBR
        return(2):             "I" change
        return(3):                              "i" change
        return(4):             "u" change
        return(0xff):           trun to "remember forced"
*******************************************************/
int WINAPI analize()
{
    if (bd_proc())
    return(BIAODIAN_ONLY);     /* only have the chinese biaodian */


    switch (in.buffer[0]){
    case 'I':
        return(2);             /* special change: "l" change */

    case 'i':

       return(3);              /* special change: "i" change */
    case 'u':
    case 'U':   //in.buffer[0]='U';
       if (in.true_length==1)
           return(0xff);       /* CTRL_F4_ENTRY: trun to the "remember forced" */
       else
           return(4);          /* special change: "u" change */
    }
    if ((in.buffer[0]&0x20)==0)                 /*1992 9 5 &&->& */
        return(1);                          /* ABBR */
    else
        return(0);                      /* mark of the standard change */


}

/***************************************************
&4:
 bd_proc(): process the chinese biaodian
        return(FALES):  have chinese biaodian and another char
        return(TRUE): only have the chinese biaodian
****************************************************/
BOOL bd_proc()
{          
   BYTE x;

   x=in.buffer[in.true_length-1];

   if(!GetBDValue(x)) return(FALSE);

   in.true_length--;
   if (in.true_length==0)
    return(TRUE);
   else
    return(FALSE);
}

int WINAPI GetBDValue(bd_char)
int bd_char;
{
   if (!if_biaodian((BYTE)bd_char))
    return(FALSE);

   biaodian_len =2;
   if ((bd_char=='^')||(bd_char=='^'))
       biaodian_len =4;

   biaodian_value=cc_biaodian[biaodian_pos*2]+
            cc_biaodian[biaodian_pos*2+1]*0x100;
   if (bd_char==0x22){
      if (yinhao_flag==1)
    biaodian_value=cc_biaodian[(biaodian_pos+2)*2]
            +cc_biaodian[(biaodian_pos+2)*2+1]*0x100;
      yinhao_flag=!yinhao_flag;                  //92-12-21 SZ
      }
   if (bd_char==0x27){
      if (d_yinhao_flag==1)
    biaodian_value=cc_biaodian[(biaodian_pos+2)*2]
            +cc_biaodian[(biaodian_pos+2)*2+1]*0x100;
      d_yinhao_flag=!d_yinhao_flag;                  //92-12-21 SZ
      }

  if(bd_char=='<'){
      if(book_name==1){
               biaodian_value=cc_biaodian[(biaodian_pos+10)*2]
            +cc_biaodian[(biaodian_pos+10)*2+1]*0x100;
              book_name_sub++;
               }
      else{
     book_name=1;
     book_name_sub=0;
        }
     }

  if(bd_char=='>'){
      if(book_name_sub){
               biaodian_value=cc_biaodian[(biaodian_pos+10)*2]
            +cc_biaodian[(biaodian_pos+10)*2+1]*0x100;
              book_name_sub--;
               }
     else
    book_name=0;
        }

     return(TRUE);
}

/*******************************************************
&4:
 if_zimu_or_not(): judge if the input is char or number
           return(TRUE):  is char
           return(FALSE): is number
********************************************************/
BOOL if_zimu_or_not(x)
BYTE x;
{
    if (('A'<=x) && (x<='Z'))
    return(TRUE);
    if (('a'<=x) && (x<='z'))
        return(TRUE);

    return(FALSE);
}


/***************************************************
if_number_or_not(c)
****************************************************/
int WINAPI if_number_or_not(c)
BYTE c;
{
if ((c<'0')||(c>'9'))
   return(STC);
else
  return(CLC);

 }

/***************************************************
if_bx_number(c)
****************************************************/
int WINAPI if_bx_number(c)
BYTE c;
{
if ((c<'1')||(c>'8'))    
   return(STC);
else
  return(CLC);

 }


/*********************************************************
&3:
 out_result(result_type): output the change result.
**********************************************************/

int WINAPI out_result(result_type)
int result_type;
{
    int i;

    if ((jiyi_mode==1)){
        if (word_back_flag==0x99){
            word_back_flag=2;
            return(call_czh(13));}
        else{

              if  (call_czh(12)==9){
                step_mode=START;
                }
              else
            step_mode=SELECT;
            return(1);
            }
        } // if (jiyi)

    else{
        if (result_area_pointer!=unit_length)
            if (msg_type!=2)
                if (in.info_flag!=1)
                    new_no=result_area_pointer;

    if (biaodian_value!=0){
        result_area[result_area_pointer++]=LOBYTE(biaodian_value);
        result_area[result_area_pointer++]=HIBYTE(biaodian_value);
    
       if (biaodian_len==4)
        {
            result_area[result_area_pointer++]=LOBYTE(biaodian_value);
            result_area[result_area_pointer++]=HIBYTE(biaodian_value);
            }

        }

    if (!(msg_type&2)){
        if (result_area_pointer>0){
            temp_rem_proc();
            for (i=0; i<result_area_pointer; i=i+2)
                out_bfb[i/2]=(WORD)find_hz((WORD)(result_area[i]+result_area[i+1]*0x100));
            } // if (result_area_pointer)
        last_out_length=out_length;
        out_length=result_area_pointer/2;
        AddExtLib();
        send_msg((BYTE *)out_bfb,result_area_pointer);
        } // if (msg_type)
    else{
        last_out_length=out_length;
        out_length=result_area_pointer/2;
        send_msg(result_area,result_area_pointer);
        if (in.buffer[0]!='v'){
            step_mode=0;
            return(0);}
        }

    return(0);

    }
}
//////////////////////////////////////////////////////////////////////////

void WINAPI fmt_transfer()
{

   if (lpImeL->wImeStyle == IME_APRS_FIX){
    if (in.info_flag==BY_RECALL)
          { now.fmt_group=3;  //5;
           now.fmt_start=26;
           now.fmt_ttl_len=54;
           word_back_flag=0x55;        //back convert is not allowed.
          }
     else
          { now.fmt_group=(WORD)form[unit_length/2];
           now.fmt_start=27;
           now.fmt_ttl_len=53;
          }

    } else {

      now.fmt_group = CANDPERPAGE ;
      if (in.info_flag==BY_RECALL)
              word_back_flag=0x55;
        }

}
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

int WINAPI sent_back_msg()
{
    if (new_no<=2)
        return(0);
    if (new_no>18)
        return(0);
    new_word();
    return(0);

}

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
int WINAPI if_jlxw_mode()
{
      int x,i,j;
      WORD *out_svw_p;

    out_svw_p=(WORD *)out_svw;

    if (jlxw_mode==0)
        return(0);
    if (jlxw_mode<0){
        if (sImeG.cp_ajust_flag==1)
            result_area_pointer=result_area_pointer-unit_length+2;
        x=0;
        } // if (jlxw)
    else{
        if (sImeG.cp_ajust_flag==1){
            x=result_area_pointer-unit_length;
            result_area[x++]=result_area[result_area_pointer-2];
            result_area[x++]=result_area[result_area_pointer-1];
            result_area_pointer=x;
            }// if (cp_ajust)
        x=unit_length-2;
        }// else

    jlxw_mode=0;
    word_back_flag=0xaa;
    if (unit_length<=2)
        return(0);

    j=0;
    x=x/2;                          //out_svw_p transmit by word;
    for (i=0; i<group_no; i++){
        out_svw_p[j++]=out_svw_p[x];
        x+=unit_length/2;
        }// for
    unit_length=2;

    for (i=0; i<group_no; i++)
        out_svw_p[i+100]=out_svw_p[i];

    x=0;
    for (i=0; i<group_no; i++){
        if (out_svw_p[i+100]){
            out_svw_p[x]=out_svw_p[i+100];
            for (j=i+1; j<group_no; j++){
               if (out_svw_p[j+100]==out_svw_p[x])
                out_svw_p[j+100]=0;
               }//for(j)
            x++;
            }//if(out_svw_p)
        }//for(i)

    group_no=x;
    return(0);

}
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

int WINAPI disp_auto_select()

{
    WORD x,y,lng;
    int i,j;
    BYTE disp_bf[80];

    if (result_area_pointer==0)
        return(0);
    cs_p(input_msg_disp);
    if (msg_type==2){
        show_char(result_area, result_area_pointer);
    cs_p(input_msg_disp+result_area_pointer);
        }
    else{
         for (i=0; i<result_area_pointer; i=i+2){
          x=result_area[i]+result_area[i+1]*0x100;
          y=(WORD)find_hz(x);
              disp_bf[i]=LOBYTE(y);
              disp_bf[i+1]=HIBYTE(y);
              }// for
         lng=in.true_length;
         if (jiyi_mode!=0){
        if (wp.xsyjw!=0){
            if (wp.yj_ps[wp.xsyjw-1]<in.true_length){
                    j=wp.yj_ps[wp.xsyjw-1];
                    x=in.true_length-wp.yj_ps[wp.xsyjw-1];
                    for (n=0; n<x; n++){
                        disp_bf[i++]=in.buffer[j++];
                        }//for
                    }// if (yj_ps)
                }//if(wp.xsyjw)
            }// if (jiyi)

        show_char(disp_bf, i);

         cs_p(input_msg_disp+result_area_pointer);
         }// else


    return (0);
}


//////////////////////////////////////////////////////////////////////////


int WINAPI if_first_key(input_char)
WORD input_char;
{

    if (input_char=='U') return(STC);

    if(if_number_or_not((BYTE)input_char))
             return(STC);                               //the first key is number,it's not allowed

    if(if_zimu_or_not((BYTE)input_char))
             return(CLC);                               //the first key is zimu


    return(STC);
}


/*****************************************************************
temp_rem_proc(): save the output in logging_stack for recall process
********************************************************************/
int WINAPI temp_rem_proc()
{
    int c,i;

    if (in.true_length<2)
        if (in.info_flag!=1)
            return(0);

    if (biaodian_value){
        c=result_area_pointer-2+1;              //-2 biaodian isn't consider
        if ((c>=2)&&(biaodian_len==4))
              c = c-2;
        }
    else                                                            //+1 logging_stack struck is
        c=result_area_pointer+1;                //   result_area_pointer plus
                                        //    one byte counter

    CopyMemory/*memmove*/(&logging_stack[c],&logging_stack[0],(logging_stack_size-c));

    logging_stack[0]=c-1;                           //length of storing string
    for (i=0; i<logging_stack[0]; i++)
        logging_stack[i+1]=result_area[i];

    if_multi_rem(c);
    return(0);

}

/*******************************************
if_multi_rem()
********************************************/
int WINAPI if_multi_rem(c)
int c;
{
    BYTE cmp_buffer[25]={0};     //max input is 10 chinese words
    int i,cn;
    char *p;

    for (i=0; i<c; i++)
        cmp_buffer[i]=logging_stack[i];
    cmp_buffer[i]=0;

    p=(LPSTR)ABCstrstr(&logging_stack[c],cmp_buffer);
    if (p!=NULL){
        c=(INT)(p-logging_stack);
        cn=logging_stack[c]+1;   //cn is the length a group in logging_stack
        CopyMemory/*memmove*/(&logging_stack[c],&logging_stack[c+cn],logging_stack_size-c-cn);
        }
    return(0);

}


/////////////////////////////////////////////////////////////////////
void WINAPI send_msg(bf,count)
BYTE *bf;
int count;
{
    int i,j;
    unsigned int focus,xx;

    TypeOfOutMsg = ABC_OUT_MULTY ;
    msg_count=count;             //Keep msg for repeat.
    for (i=0;i<count;i++){
         msg_bf[i]=bf[i];            //send msg for Edit class W.
         if (bf[i]<0x80)  TypeOfOutMsg = ABC_OUT_ASCII;
         }
   SetResultToIMC(ghIMC,msg_bf,(WORD)count);
   

}

 /*******************************************
 Popurse: To send a single char as message .
 *******************************************/
int WINAPI send_one_char(chr)
 int  chr;
 {
 int scn;
    if(glpIMC->fdwConversion&IME_CMODE_SYMBOL)
         if(GetBDValue(chr)){
             unsigned char buffer[4];
             int num = 2; 

         buffer[0]=LOBYTE(biaodian_value);
             buffer[1]=HIBYTE(biaodian_value);
    
       if ((chr == '_')||   (chr == '^'))
       {
            buffer[2]=LOBYTE(biaodian_value);
            buffer[3]=HIBYTE(biaodian_value);
            num = 4 ;
       }
       send_msg(buffer,num);
       return(0);
    }

    if(glpIMC->fdwConversion&IME_CMODE_FULLSHAPE)
         cap_full((WORD)chr);
    else
        TypeOfOutMsg = ABC_OUT_ONE ;
    return(0);

 }

int WINAPI send_one_char0(chr)
int chr;
{
        TypeOfOutMsg = ABC_OUT_ONE ;
        return (0);
}



/**********************************************************************/
/* SetResultToIMC()                                                  */
/* Return vlaue                                                       */
/*      the number of candidates in the candidate list                */
/**********************************************************************/
 UINT WINAPI SetResultToIMC(
    HIMC                ghIMC,
    LPSTR               outBuffer, //soarce buffer (normal for out_svw) 
    WORD                outCount)  //How many candidates are.            
{
    LPINPUTCONTEXT      lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    LPCOMPOSITIONSTRING lpCompStr;
    WORD                        dwCompStrLen;
    WORD                        dwReadClauseLen;
    WORD                        dwReadStrLen;

    if (!ghIMC) return (0); // The IMC must be a valid one.
   
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(ghIMC);
    if(!lpIMC)  return 0; 
  
    if (!lpIMC->hCandInfo){
    ImmUnlockIMC(ghIMC);
     return (0); }
                        // The CandInfo must...

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
    ImmUnlockIMC(ghIMC);
    return (0);}


    lpCandList = (LPCANDIDATELIST)
    ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);


    if (!lpCompStr) {
    MessageBeep((UINT)-1);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(ghIMC);
    return (0);
    }


    dwCompStrLen = 0;
    dwReadClauseLen = 0;
    dwReadStrLen = 0;

    InitCompStr(lpCompStr);

    // the result reading clause = compsotion reading clause
    CopyMemory((LPSTR)lpCompStr + lpCompStr->dwResultReadClauseOffset,
    (LPSTR)lpCompStr + lpCompStr->dwCompReadClauseOffset,
    dwReadClauseLen);
    lpCompStr->dwResultReadClauseLen = dwReadClauseLen;
    *(LPSTR)((LPSTR)lpCompStr+lpCompStr->dwResultReadClauseOffset+dwReadClauseLen) = '\0';

    // the result reading string = compsotion reading string
    CopyMemory((LPSTR)lpCompStr + lpCompStr->dwResultReadStrOffset,
    (LPSTR)lpCompStr + lpCompStr->dwCompReadStrOffset,
    dwReadStrLen);
    lpCompStr->dwResultReadStrLen = dwReadStrLen;
    *(LPSTR)((LPSTR)lpCompStr+lpCompStr->dwResultReadStrOffset+dwReadStrLen) = '\0';
   
    // calculate result string length
    lpCompStr->dwResultStrLen = outCount;

    // the result string = outBuffer;
    CopyMemory((LPSTR)lpCompStr + lpCompStr->dwResultStrOffset,
        (LPSTR)outBuffer,outCount);
    *(LPSTR)((LPSTR)lpCompStr+lpCompStr->dwResultStrOffset+outCount) = '\0';

    lpCompStr->dwResultClauseLen = 0;
    *(LPUNADWORD)((LPBYTE)lpCompStr + lpCompStr->dwResultClauseOffset +
    sizeof(DWORD)) = 0;


    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    // tell application, there is a reslut string
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar =  (DWORD)0;
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
    GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

    if(TypeOfOutMsg == ABC_OUT_ASCII)
        lpImcP->fdwGcsFlag &=(~GCS_RESULT);


    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
    lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
        ~(MSG_OPEN_CANDIDATE);
    }

    // no candidate now, the right candidate string already be finalized
    lpCandList->dwCount = 0;

    lpImcP->iImeState = CST_INIT;


    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(ghIMC);
    return (0) ;    /* The real number of being moved */
}



/**********************************************************
    FUNCTION: cap_full()
    PURPOES:  if the full_switch on, and in the Caps status,
              change the English into Chinese mode
************************************************************/
void WINAPI cap_full(wParam)
WORD wParam;
{

         if (wParam==VK_BACK){
                  //        send_one_char(VK_BACK);
                 send_one_char0(VK_BACK);
                 return;
                     }

         if (wParam==VK_SPACE){
                result_area[0]=0xa1; //94-8-6!
                result_area[1]=0xa1; //04-8-6!
                send_msg(result_area,2);
                return;
                }

     if (wParam== '~'){
                result_area[0]=0xa1; //94-8-6!
                result_area[1]=0xab; //04-8-6!
                send_msg(result_area,2);
                return;
                }


         if (wParam=='$'){
                result_area[0]=0xa1; //94-8-6!
                result_area[1]=0xe7; //04-8-6!
                send_msg(result_area,2);
                return;
                }


        if ((wParam>0x20) && (wParam<=0x7e)){
            result_area[0]=0xa3;
            result_area[1]=((wParam-0x20)*0x100+0xa0a3)/0x100;

            send_msg(result_area,2);
            return;
            }

            send_one_char0(wParam);
}

/*********************************************
read_kb()
**********************************************/
int WINAPI read_kb()
{
  return(0);
}


/////////////////////////////////////////////////////////////////////////
//                              BX_MODE                                                                                            //
//              Deel with pure bx input                                                                            //
/////////////////////////////////////////////////////////////////////////

extern WORD last_size;

BX_MODE(input_char,wParam)
WORD input_char;
WPARAM wParam;
{

    if (if_number_or_not((BYTE)input_char)
            &&(input_char!='9')
            &&(input_char!='0')){
        if (step_mode==START||step_mode==RESELECT){
            if (input_char >= 0x8000)       //1993.4.19
                return(STC);           //when RESELECT use the mouse reselect result
            else {
                if (!bx_inpt_on)
                  { cls_bx_disp(1);
                    sent_back_msg();
                  }
                step_mode=ONINPUT;
                bx_inpt_on=1; }//else
        } //if (step_mode)
      }//if (if_number...)

    if (bx_inpt_on){
        bx_proc(input_char,wParam);
        return(CLC);
            }

    return(STC);

}

/**********************************************************************
    FUNTION:        bx_proc(WORD)
    PURPOSE:        when the pure bx were inputed, find one chinese word
                corespond with it and eight related words with it.
***********************************************************************/
void WINAPI bx_proc(input_char,wParam)
WORD input_char;
WPARAM wParam;
{
    int i;

    lib_p=(BYTE *)lib_w;                    //lib_p point to the lib_buffer

    switch (bx_analize(input_char,wParam))
    {
 
    case BX_CHOICE:
        if (input_char>=0x8000){
            current_no=(input_char - 0x8000-0x31)+disp_head;
        sImeG.InbxProc = 0;
    }else
        current_no=((INT)wParam - 0x31)+disp_head;           
        if(current_no>=group_no){     
            MessageBeep(0);
            disp_help_and_result();
        }else
            send_bx_result();
        break;

        case BX_SELECT:
        word_select_bx(input_char);
        break;

        case ESC:
        cls_bx_disp(0);
        break;

        case OTHER:
        MessageBeep(0);
        disp_help_and_result();
        break;

       
        case SPACE:
        send_bx_result();
        break;

        case BXMA:
        if(!disp_help_and_result()){
            if(in.true_length>1){
                 in.true_length--;
                     MessageBeep(0);
                     disp_help_and_result();
                     }
           }
        break;

        default:
        break;
    }//swith
}




/********************************************************************
  word_select(wParam): select the word or turn to the next or up page
*********************************************************************/
 word_select_bx(input_char)
int input_char;
{
    int x;
     

    switch (input_char){

       case VK_END*0x100:
       case VK_DOWN*0x100:
       case '=':                               //94/8/22
       case ']':
      if (disp_tail>=group_no)
          MessageBeep(0);
      else{

          if(input_char == VK_END*0x100 ){
              disp_head = (group_no - 1)/now.fmt_group*now.fmt_group;
              disp_tail = disp_head;}

          fmt_transfer();
          current_no=disp_tail;
          prompt_disp();}
      return(1);                            //means break the STD MODE

       case VK_HOME*0x100:
       case '-':                                //94/8/22
       case '[':
       case VK_UP*0x100:
       if (disp_head==0)

           MessageBeep(0);
       else{
          
          if(input_char == VK_HOME*0x100 )
            disp_head = 0;
          else
           disp_head=disp_head-now.fmt_group;
           
           disp_tail=disp_head;
           fmt_transfer();
          current_no=disp_tail;
           prompt_disp();
           }
       return(1);

    default:
        return(1);                      //1993.1.15 cock
        }
}


/************************************************************************
    FUNTION:        bx_analize(WORD)
    PURPOSE:        analize the input char. find out if it is pure bx
*************************************************************************/
int WINAPI bx_analize(input_char,wParam)
WORD input_char;
WPARAM wParam;
{
    if(input_char>=0x8000) return(BX_CHOICE);

    if (input_char == VK_UP*0x100)
          return(BX_SELECT);

    if (input_char == VK_DOWN*0x100)
          return(BX_SELECT);

    if (input_char == VK_HOME*0x100)
          return(BX_SELECT);

    if (input_char == VK_END*0x100)
          return(BX_SELECT);

    if (input_char == ']')
          return(BX_SELECT);

    if (input_char == '[')
          return(BX_SELECT);

    if (input_char == '-')
          return(SELECT);

    if (input_char == '=')
          return(SELECT);


    if (input_char==VK_ESCAPE)
        return(ESC);

    if (input_char==VK_SPACE)
    {
        in.info_flag=0x80;                      //standard end flag
        return(SPACE);
    }

    if (input_char==VK_RETURN)
    {
        in.info_flag=0x80;                      //standard end flag
        return(SPACE);
    }

    if (input_char==VK_BACK)
    {
        if (in.true_length==1)
        {
        input_char=VK_ESCAPE;   //if it has inputed only one word
        return(ESC);
        }                   //cls the display
        in.true_length--;
        key_bx_code_long=in.true_length;
        return(BXMA);
    }

    if (!if_bx_number((BYTE)input_char))
    {
       if( ((BYTE)wParam>'0') && ((BYTE)wParam <= CANDPERPAGE+0x30))
         return (BX_CHOICE);   
    
        in.info_flag=(BYTE)input_char;    //rest key is put into the end_flag position
        return(OTHER);
    }

    if ((input_char>0x30)||(input_char<0x39))
    {
        if (in.true_length>6)
        {
        in.info_flag=(BYTE)input_char;
        return(OTHER);
        }
        else
        {
        in.buffer[in.true_length++]=(BYTE)input_char;
        key_bx_code_long=in.true_length;
        return(BXMA);
        }
    }
    else{
        in.info_flag=(BYTE)input_char;
        return(OTHER);
    }

}

/************************************************************************
    FUCTION:        disp_help_and_result()
    PURPOSE:        seach the bx_table and display the tishi result
    ENTRY:          bx string is in inpt_bx.bf
    RESULT:         display the result and tishi information
**************************************************************************/
int WINAPI disp_help_and_result()
{
    int i, pass_flag;

    if (in.true_length==1)
       if (in.buffer[0]!=in_mem_part)               //if this part of table is in memory
          load_one_part_bxtab();

    for (i=0; i<in.true_length; i++)
          key_bx_code[i]=in.buffer[i]&0x0f;         // 'and' high 4 bit

    search_pointer=0;
    current_bx_code_long=0;
    pass_flag=0;
    while (search_pointer<current_part_length)
    {
        if (cmp_bx_word_exactly())
        {                                           //search correct result
        pass_flag=1;
        break;
        }
    }
    if (!pass_flag)
                return 0;


    for (i=0; i<8*2; i++)
        out_svw[i]=0;           //clear the prompt result buffer

    search_pointer=0;
    current_bx_code_long=0;
    pass_flag=0;
    while (search_pointer<current_part_length)
        if (cmp_bx_code2())                 //search the related prompt result
        pass_flag=1;                    //if found it, set the flag and continue

    if (pass_flag)
    {
        disp_bx_result();
        disp_bx_prompt();
    }
    else
    {
        if (group_no>1){                            //1993.3
            disp_bx_result();               //1993.3
            disp_bx_prompt();
            }
        else                                    //1993.3
            send_bx_result();
    }
   return 1;
}

/***********************************************************************
    FUCTION:        cmp_bx_word_exactly()
    PURPOSE:        find the correct result position, and send the result
                into buffer.
    ENTRY:          the input bx is in the key_bx_code buffer
    RESULT:         CLC--- the input bx is matched with the current bx in the table
                       the correct result is in the out_svw buffer
                STC--- not match
                the search_pointer points the position the next bx in
                the table.
************************************************************************/
int WINAPI cmp_bx_word_exactly()
{
    BYTE x;
    int i;

    for (i=0;i<20;i++)
        result_area[i]= 0;
    conbine();              //get the bx from the bx_table

    result_area_pointer=0;
    if (key_bx_code_long==current_bx_code_long){
        if (cmp_subr()){
            group_no=0;
            search_pointer++;
            while (lib_p[search_pointer]>0xa0){
            //      result_area[result_area_pointer++]=group_no|0x40;
            //      result_area[result_area_pointer++]=0x2e;
                result_area[result_area_pointer++]=lib_p[search_pointer++];     //save the "quma"
                result_area[result_area_pointer++]=lib_p[search_pointer++];     //save the "weima"
            //      result_area[result_area_pointer++]=0x20;
                group_no++;                                             //sum of chinese word
                }//while
            return(CLC);
            }//if (cmp_subr())
        }//if(key_bx_code_long)

    search_pointer++;
    while (lib_p[search_pointer]>=0xa0)
        search_pointer+=2;                              //move the pointer to the beginning
    return(STC);                                            //of the next bx in the table

}

/**************************************************************************
    FUCTION:        cmp_bx_code2()
    PURPOSE:        search the prompt information and get the chinese word
                which is related with the input.
**************************************************************************/
int WINAPI cmp_bx_code2()
{
    WORD x;

    conbine();                      //get the bx from the bx_table

    if (key_bx_code_long==(current_bx_code_long-1)){
        if (cmp_subr()){
            bx_help_flag|=0x80;

            x=(lib_p[search_pointer++]&0x0f)-1;
            if (x>7)                //if the bx overflow
                x=7;

            out_svw[x*2]=lib_p[search_pointer++];   //get the prompt bx
            out_svw[x*2+1]=lib_p[search_pointer++];

            while (lib_p[search_pointer]>0xa0)
                search_pointer+=2;      //move the pointer to the next string

            return(CLC);
            }//if (cmp_subr())
        }//if (key_bx_code_long)

    search_pointer++;
    while (lib_p[search_pointer]>0xa0)
        search_pointer+=2;                      //move the pointer to the next string
    return(STC);

}

/************************************************************************
    FUCTION:        conbine()
    PURPOSE:        get the bx from the table and change the high 4 bit into
                the position where the last bit of bx should put in and
                get this string of bx's length.
*************************************************************************/
void WINAPI conbine()
{
    int x;

    x=(lib_p[search_pointer]>>4)&0x0f;
    current_bx_code[x]=lib_p[search_pointer]&0x0f;
    current_bx_code_long=x+1;

}


/***********************************************************************
    FUCTION:        cmp_surb()
    PURPOSE:        compare the input bx with the bx in the table
************************************************************************/
int WINAPI cmp_subr()
{
    int i;

    for (i=0; i<key_bx_code_long; i++)
        if(key_bx_code[i]!=current_bx_code[i])
            return(STC);

    return(CLC);

}

void WINAPI cls_bx_disp(int flag)
{
  if(!flag)
    cls_prompt();
 
    input_cur=input_msg_disp;
    cs_p(input_msg_disp);
    in.true_length=0;
    in.info_flag=0;
    bx_inpt_on=0;
    group_no=0;
    current_no = 0;
    step_mode=START;
}


int WINAPI load_one_part_bxtab()
{
    int hd, close_hd;
    int op_count,i;
    WORD distance;


    in_mem_part=in.buffer[0]&0x0f;          //save the current first bx ma
    distance=bxtable_ndx[in_mem_part-1];    //get the beginning position
    current_part_length=bxtable_ndx[in_mem_part]-distance; //get the read length
    hd=OpenFile("winabc.ovl",&reopen,OF_READ);
    if (hd==-1)
    {
       err_exit_proc("OPEN WINABC.OVL ERROR!");
       return (FALSE);
    }

    _llseek(hd,distance,0);
    last_size=0;
    last_item_name=0;
    op_count=_lread(hd,&lib_w,current_part_length);
    
    lib_p[op_count]=0;
    lib_p[op_count+1]=0;    // cls the below limited

    if (op_count!=current_part_length)
    {
       err_exit_proc("READ WINABC.OVL ERROR!");
       close_hd = _lclose(hd);
       return (FALSE);
    }

    
    close_hd = _lclose(hd);

    return (TRUE);
}

int WINAPI disp_bx_result()
{
    BYTE buffer[50];
    int keep_cs, i;

    for (i=0; i<50; i++) buffer[i] = ' ' ;
     
    input_cur=input_msg_disp;
    cs_p(input_msg_disp);
    for (i=0; i<in.true_length; i++)
         buffer[i]= in.buffer[i];

    show_char(buffer, i);
    now_cs= i;                      //restore
    cs_p(now_cs);                   //disp cs
    return (0);
}

void WINAPI disp_bx_prompt()
{
    int i,j,n;
    HWND hhh;
    int GroupCounter;
    BYTE buffer [100];


    disp_head=0;
    disp_tail=8;

    j=0,n=0;
    GroupCounter= 0;
    if (group_no) {             //if the results are more the 5
    for (i=0; i<group_no*2; i=i+2)      //display the rest in the prompt area
       if(result_area[i]){
        buffer[j++]=result_area[i];
        buffer[j++]=result_area[i+1];
        buffer[j++]=0xa1;
        buffer[j++]=0xa1;} 
    }

    n =group_no*2;
    for(i=0; i<16; i = i+2){
        if(out_svw[i]){
         buffer[j++] = out_svw[i];
         result_area[n++] = out_svw[i];
         buffer[j++] =   out_svw[i+1];
         result_area[n++] = out_svw[i+1];
         buffer[j++] = 0xa2;
         buffer[j++] = 0xd9+GroupCounter;}
        GroupCounter++;
        }//for
    

    group_no = j/4;

    unit_length = 4;
       current_no=0;
           disp_tail=0;
           V_Flag=0;
           msg_type=2;                       //94/8/22
           fmt_transfer();
           SetToIMC(ghIMC,(LPSTR)&buffer,(WORD)group_no,(WORD)(unit_length+0x1000));                            
           prompt_disp();
           step_mode=SELECT;
}

void WINAPI send_bx_result()
{
    out_length=1;
    send_msg(&result_area[current_no*2],2);
    cls_bx_disp(1);

}





////////////////////////////////////////////////////////////////////////
//          ʼ data_init()                                  //
//   : ļ                                               //
//          1. ?MMR.REM                                           //
//              2. , Ƶȱ,ʻ              //
//              3. ׼ʿûʿĲ.                      //
//              4. TMMR.REM, ûʿⲻ,֮.           //
//              5. ûʿ                                       //
//  ڲ:                                                       //
//  ڲ: TURE  ʼɹ                                        //
//            FALSE ʼʧ                                        //
////////////////////////////////////////////////////////////////////////


void WINAPI data_init()
{

BYTE    new_flag=0;                     //һδûļ?
BYTE    the_para='U';                   //Ĳ
BYTE    disp_mode=0;
BYTE    current_dd=0;
BYTE    current_disk='C';
BYTE    current_path[64];
HFILE   hd;
DWORD   op_count;
BYTE    tmp_buffer[16]={0};
int     i;

char    god[]="WINABC.CWD";
char    cw_ovr[]="WINABC.OVL";
char    no_file[]=ERR01;                    //ȱٴʿļWINABC.CWD
char    read_ndx_wrong[]=ERR03;             //"ļ";
char    m_short[]=ERR14;                    //"ڴ治";
char    no_cw_ovr[]=ERR04;                  //"ȱٻļWINABC.OVL";
char    jiyi_wenjian_cuo[]=ERR13;           //"ûļ!";
char    TMMR_WRITE_WRONG[]=ERR09;           // "ļд";

OFSTRUCT ofs;

LPSTR cisu_1;

    memset(tmmr_rem, 0, sizeof(tmmr_rem));
    memset(user_lib, 0, sizeof(user_lib));

// support  multi-user

    lstrcpy(tmmr_rem,  sImeG.szIMEUserPath);
    lstrcat(tmmr_rem,  TEXT("\\tmmr.rem") );

    lstrcpy(user_lib,  sImeG.szIMEUserPath);
    lstrcat(user_lib,  TEXT("\\user.rem") );

    hd =OpenFile(god, &ofs, OF_READ|OF_SHARE_COMPAT|GENERIC_READ);
    if ( hd==HFILE_ERROR)
        err_exit(no_file);
    op_count = _lread(hd,&ndx,NDX_REAL_LENGTH);
        
    if(op_count!=NDX_REAL_LENGTH)
        err_exit(read_ndx_wrong);

    _lclose(hd);

    hd = OpenFile(cw_ovr, &ofs, OF_READ|OF_SHARE_COMPAT|GENERIC_READ);
    if (hd==HFILE_ERROR)
        err_exit(no_cw_ovr);
    
    _llseek(hd, PTZ_LIB_START_POINTER, FILE_BEGIN); // ָ

    cisu_hd=GlobalAlloc(GMEM_MOVEABLE,(DWORD)PTZ_LIB_LENGTH);
    if (!cisu_hd)
    {
        err_exit(ERR22);       //Memory Alloc Wrong!");
        _lclose(hd);
        return;
    }
 
    cisu_1=GlobalLock(cisu_hd); /*GlobalWire* for v32*/
                                                 
    if (!cisu_1)
        err_exit(ERR22);     //"Memory Alloc Wrong!");

    cisu=(struct TBF FAR *)cisu_1;
    op_count=_lread((HFILE)hd,(LPSTR)&cisu->t_bf_start,PTZ_LIB_LENGTH);    // 

    if (op_count!=PTZ_LIB_LENGTH)
        err_exit(ERR06);  //"Read WINABC.OVL Wrong!");

    _llseek((HFILE)hd, PD_START_POINTER, 0);        //ָ
    op_count=_lread((HFILE)hd,(LPSTR)&pindu.pd_bf0,PD_LENGTH);            //ӡƵȱ
    if (op_count!=PD_LENGTH)
        err_exit(ERR06);  //("Read WINABC.OVL Wrong!");

    _llseek(hd, SPBX_START_POINTER, 0);        //ָ
    op_count=_lread(hd,(LPSTR)&spbx_tab,SPBX_LENGTH);        // α
    if (op_count!=SPBX_LENGTH)
        err_exit(ERR06);   //("Read WINABC.OVL Wrong!");
    _lclose((HFILE)hd);


    if (CheckAndCreate(tmmr_rem,user_lib)){
        hd = OpenFile(tmmr_rem, &ofs, OF_READWRITE);           //1993.4.15
        if (hd==HFILE_ERROR)
            err_exit(ERR13);   //(jiyi_wenjian_cuo);
        op_count=_lread(hd,(LPSTR)&tmmr,TMMR_REAL_LENGTH);
        if (op_count!=TMMR_REAL_LENGTH)
            err_exit(ERR06);  //(jiyi_wenjian_cuo);

        _llseek(hd,TMMR_REAL_LENGTH,0); //move the pointer to the paremeter area
        op_count=_lread(hd,tmp_buffer, PAREMETER_LENGTH); //read the paremeters to the buffer
        if (!op_count) {                                    //1993.4.15 if old tmmr.rem hasn't this ten parameters
            memset(tmp_buffer, 0 , PAREMETER_LENGTH);

            tmp_buffer[0] = (BYTE)IfTopMost;                  //transfer the peremeters
            tmp_buffer[1] = sImeG.auto_mode ;
            tmp_buffer[2] = bdd_flag;
            tmp_buffer[3] = sImeG.cbx_flag;

            op_count = _lwrite((HFILE)hd, rem_area, PAREMETER_LENGTH);   //writer the file
            if (op_count!=PAREMETER_LENGTH)
                err_exit (ERR09);   //(TMMR_WRITE_WRONG);
        }//if (!op_count)
        else {
            if (op_count!=PAREMETER_LENGTH)
                err_exit(ERR08);      //(jiyi_wenjian_cuo);
        }//else

        _lclose(hd);

        IfTopMost = tmp_buffer[0];                      //transfer the paremeter
        sImeG.auto_mode = tmp_buffer[1];                 //1993.4
        bdd_flag = tmp_buffer[2];
        sImeG.cbx_flag = tmp_buffer[3];

        hd = OpenFile(user_lib, &ofs, OF_READ);           //1993.4.15
        if (hd==-1)
            err_exit(ERR10);     //(jiyi_wenjian_cuo);
        _llseek(hd,0xa000l,0);
        op_count=_lread(hd,(LPSTR)&kzk_ndx,NDX_REAL_LENGTH);
        if (op_count!=NDX_REAL_LENGTH)
            err_exit(ERR11);    //(jiyi_wenjian_cuo);
        _lclose(hd);
    }

}




//
//Popose: check user_word dictionary files "TMMR.REM"
//                                         "USER.REM"
//         If they are not exist, created.
//

int WINAPI CheckAndCreate(tmmr_rem,user_rem)
BYTE *tmmr_rem,*user_rem;
{
struct INDEX user_file_head;
struct M_NDX mulu_head={
            0,
            0,       //MULU_START_LOW                Ŀ¼дֽ
            0x1800,  //MULU_LENGTH_MAX   SIZELIB+SIZELIB_KZK   Ŀ¼󳤶=صĳ
            0x10,    //MULU_TRUE_LENGTH  10H      Ŀ¼ʵʳ,ʼֻв.
            0xA,     //MULU_RECORD_LENGTH  10  Ŀ¼ÿ¼ĳȡ
            0,       //DATA_START_HI  0  ûļ64K֮.
            0x1800,   //DATA_START_LOW DW SIZE LIB_W      Ŀ¼ν.
            0x20};   //DATA_RECORD_LENGTH 32 ÿ¼ĳ.

OFSTRUCT ofs;
int hd,i,count;
HANDLE hMem;
LPSTR rem_area,p;
WORD *pp;

char TMMR_OPEN_WRONG[]= ERR07;    //"ļ򿪴";
char TMMR_READ_WRONG[]= ERR08;    //"ļ";
char TMMR_WRITE_WRONG[]=ERR09;    // "ļд";
char USER_OPEN_WRONG[]= ERR10;    //"ûʿ򿪴";
char USER_READ_WRONG[]= ERR11;    //"ûʿ";
char USER_WRITE_WRONG[]=ERR12;    // "ûʿд";


hMem=GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT ,TMMR_LIB_LENGTH );

if ( hMem == NULL )
   return 0;

rem_area=GlobalLock(hMem);

hd = OpenFile(tmmr_rem, &ofs, OF_READ);
if (hd!=-1){
    count = _lread(hd, rem_area, TMMR_LIB_LENGTH);
    if ((rem_area[CHECK_POINT]=='T')&& (rem_area[CHECK_POINT+1]=='X')
                    && (rem_area[CHECK_POINT+2]=='L')
                    && (rem_area[CHECK_POINT+3]=='N'))
                    _lclose(hd);
    else
        _lclose(hd),hd=-1;
       } // if (hd!=-1)....

if (hd==-1){
     hd = OpenFile(tmmr_rem, &ofs, OF_CREATE|OF_SHARE_DENY_NONE);
          if (hd==-1)
             err_exit(TMMR_OPEN_WRONG);
          else{
            for (i = 0; i<TMMR_LIB_LENGTH; i++)
                rem_area[i]=0;                  // Init the temp rem
                                // area by zero.
            rem_area[CHECK_POINT]='T';
            rem_area[CHECK_POINT+1]='X';
            rem_area[CHECK_POINT+2]='L';
            rem_area[CHECK_POINT+3]='N';
                                //give Mark!

             count = _lwrite(hd, rem_area, TMMR_LIB_LENGTH);
            if (count!=TMMR_LIB_LENGTH)
                 err_exit(TMMR_WRITE_WRONG);

            for (i=0; i<PAREMETER_LENGTH; i++)
                rem_area[0]=0;          //clear the buffer

            rem_area[0] = (CHAR)IfTopMost;        //transfer the peremeters
            rem_area[1] = sImeG.auto_mode =0;
            rem_area[2] = bdd_flag=0;
            rem_area[3] = sImeG.cbx_flag=0;

            count = _lwrite(hd, rem_area, PAREMETER_LENGTH);   //writer the file
            if (count!=PAREMETER_LENGTH)
                err_exit (TMMR_WRITE_WRONG);

            _lclose(hd);               //close the file
          } //else...
         }//if (hd==-1)...


//
// Check or create TMMR.REM file is over. Now, deel with USER.REM.
//
hd = OpenFile(user_rem, &ofs, OF_READ);
if (hd!=-1){
    _llseek(hd,(LONG)LENGTH_OF_USER, 0);
    count = _lread(hd, rem_area, NDX_REAL_LENGTH);

    if ((rem_area[CHECK_POINT2]=='T')&&(rem_area[CHECK_POINT2+1]=='X')
                     &&(rem_area[CHECK_POINT2+2]=='L')
                     && (rem_area[CHECK_POINT2+3]=='N'))
                    _lclose(hd);
    else
        _lclose(hd),hd=-1;
       } // if (hd!=-1)....

if (hd==-1){
     hd = OpenFile(user_rem, &ofs, OF_CREATE|OF_SHARE_DENY_NONE);
          if (hd==-1)
             err_exit(USER_OPEN_WRONG);
          else{
            for (i = 0; i<TMMR_LIB_LENGTH ; i++)
                rem_area[i]=0;                  // Init the temp rem
                                // area by zero.
 // First, write file para for force remenber.

           p=(BYTE *)&mulu_head.mulu_start_hi;
           for (i=0; i<16; i++) rem_area[i]=p[i];

// Init force rem file

          for (i=0; i<LENGTH_OF_USER/0x1000; i++){
            count = _lwrite(hd, rem_area, 0x1000);
            if (count!=0x1000 )
                 err_exit(USER_WRITE_WRONG);}

//Init user dictionary file
          p=(BYTE *)&user_file_head.body_start;
          for (i=0; i<sizeof user_file_head;i++)  p[i]=0;

          user_file_head.body_start=NDX_REAL_LENGTH/16;
          user_file_head.ttl_length=NDX_REAL_LENGTH/16;
          user_file_head.body_length=0;
          user_file_head.index_start=3;
          user_file_head.index_length=NDX_REAL_LENGTH/16-3;
          user_file_head.unused1=0x2000;


          p[CHECK_POINT2]='T';
          p[CHECK_POINT2+1]='X';
          p[CHECK_POINT2+2]='L';
          p[CHECK_POINT2+3]='N';
                                //give Mark!

             count = _lwrite(hd,(LPSTR)&user_file_head, NDX_REAL_LENGTH  );
            if (count!=NDX_REAL_LENGTH  )
                 err_exit(TMMR_WRITE_WRONG);
           _lclose(hd);
          } //else...
         }//if (hd==-1)...

    GlobalUnlock(hMem);
    GlobalFree(hMem);
    return(CLC);
}// create and check



//
// ,ĿǰΪģ, ΪһԻ
// صϢ: RETRY, IGNORE, CANCEL
//

void WINAPI err_exit(err_msg)
char *err_msg;
{

   MessageBox(hWnd, err_msg, "ERR", MB_OKCANCEL);
   PostMessage(hWnd,WM_DESTROY,0,0l);
}


void WINAPI err_exit_proc( err_msg)
char *err_msg;
{

   MessageBox(NULL, err_msg, "ERR", MB_OKCANCEL);
   return ;
}


 int WINAPI GetText32(   HDC  hdc,LPCTSTR  lpString,int  cbString)
 {
     
    
    SIZE  lSize;  
   
    GetTextExtentPoint32(hdc,lpString,cbString,(LPSIZE)&lSize);

    return lSize.cx;
 }


 int WINAPI makep(LPARAM lParam,  LPPOINT oldPoint)
 {
   
   POINTS newPoint;
     newPoint=MAKEPOINTS(lParam);
     oldPoint->x=(WORD)newPoint.x;
     oldPoint->y=(WORD)newPoint.y;
     return 0;
}         



/*******************************************************
&3:
 cwp_proc():
********************************************************/
int WINAPI cwp_proc(mtype)
int mtype;
{
    int i, j, m;
    BYTE x;
    switch (mtype){
        case 0:
            return(normal());                   //normal pinyin convert

        case 1:
            abbr();                            //ABBR
            return(normal());

        case 2:                                 // "I" capital chinese number
        case 3:                                 // "i" small chinese number
            if (in.true_length==1){
                in.buffer[1]='1';
                in.true_length++;}
            if (in.true_length>20) in.true_length=20;

            m=0;
            for(i=1; i<in.true_length; i++){
                x=in.buffer[i];
                if (if_number_or_not(in.buffer[i])){
                if (mtype==2)
                   x=in.buffer[i]-0x30;
                }
                if (if_zimu_or_not(in.buffer[i])){
                x=in.buffer[i]&0xdf;
                   if (mtype==2)
                      if (x=='S' || x=='B' || x=='Q')
                    x=x|0x20;
                }

                for (j=0; j<160; j=j+3){
                if (x==fk_tab[j]){
                     out_svw[m++]=fk_tab[j+1];
                     out_svw[m++]=fk_tab[j+2];
                     x=0xff;              // found it
                     break;}
                }// for(j)
             if (x!=0xff)
               goto err_back;

             } // for(i)

             group_no=1;
             unit_length=m;
             msg_type=2;
             return(1);                 // success!

        case 4:                                 // "u" user define word
            return(user_definition());

        case 12:                                //continue to change
            return(find_next());

        case 13:                                // backword
            return(normal_1(word_back_flag));

        case 14:
            return(recall());

        default:
          err_back:
            return(-1);

    }// switch
}



/************************************************
find_next()
*************************************************/
int WINAPI find_next()
{
    if (wp.yjs<=wp.xsyjw)
        return(STC);

    return( normal_1(0) );
    
}


/*************************************************
normal()
**************************************************/
int WINAPI normal()
{
    extb_ps=0xffff;
    by_cchar_flag=0;
    wp.yjs=0;
    wp.xsyjw=0;
    wp.dw_count=0;
    wp.dw_stack[0]=0;

    if (in.info_flag==0x81)
        by_cchar_flag=1;
    detail_analyse();
    
    if (!convert(0)){
        zdyb();
        return(STC);
        }
        
    wp.xsyjs=wp.xsyjw;
    wp.xsyjw+=word_long;
    wp.dw_stack[++wp.dw_count]=(BYTE)wp.xsyjw;

    if (by_cchar_flag!=1){
        if (wp.yjs==wp.xsyjw){
            if (wp.xsyjs!=0){
                sfx_attr=2;                     //mark for finding sfx_table
                rzw();}
                }//if (wp.xsyjs)
        
        else{
            if (word_long<=1){
                if (wp.xsyjs==0){                                                                               
                    sfx_attr=1;                     //mark for finding sfx_table
                    rzw();}//if (wp.xsyjs)
                }//if (word_long)
            }//else

        }//if (by_cchar...
        
    if (wp.yjs<=wp.xsyjw)
        jiyi_mode=0;
    else
        jiyi_mode=1;

    return(CLC);
                
}

/*******************************************************
normal_1()
********************************************************/
int WINAPI normal_1(flag)
int flag;
{
    if (in.info_flag==0x81)
        by_cchar_flag=1;

    if (!convert(flag)){
        zdyb();
        return(STC);
        }

    wp.xsyjs=wp.xsyjw;
    wp.xsyjw+=word_long;
    wp.dw_stack[++wp.dw_count]=(BYTE)wp.xsyjw;

    if (by_cchar_flag!=1){
        if (wp.yjs==wp.xsyjw){
            if (wp.xsyjs!=0){
                sfx_attr=2;                     //mark for finding sfx_table
                rzw();}
                }//if (wp.xsyjs)
        
        else{
            if (word_long<=1){
                if (wp.xsyjs==0){                                                                               
                    sfx_attr=1;                     //mark for finding sfx_table
                    rzw();}//if (wp.xsyjs)
                }//if (word_long)
            }//else
                                
        }//if (by_cchar...

        
    if (wp.yjs<=wp.xsyjw)
        jiyi_mode=0;
    else
        jiyi_mode=1;

    return(CLC);

}

//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////

int WINAPI recall()
{
    cls_prompt_only();
    in.info_flag=1;
    wp.yjs=0;
    wp.xsyjw=0;
    by_cchar_flag=0;
    detail_analyse();
    if (!recall_rc())
        return(-1);

    return (0);
    
}

/*************************************************************
user_definition(): produce the user define word
**************************************************************/
int WINAPI user_definition()
{
    int i,rec_cnt;

    kbf.max_length=in.max_length;
    kbf.true_length=in.true_length-1;               //delete the word "u"

    for (i=0; i<kbf.true_length; i++)
        kbf.buffer[i]=in.buffer[i+1];

    read_mulu();
    if (!(rec_cnt=look_for_code()))
        return(STC);                                            //not found
    if (!read_data(rec_cnt-1))                      //-1 get the real record count
        return(STC);                                            //not found

    unit_length=out_svw[0]-0x30;                            //plus 1 is plus the mark
    word_long=(out_svw[0]-0x30)/2;
    group_no=1;
    CopyMemory/*memmove*/(out_svw,&out_svw[2],unit_length);
    msg_type|=2;
    return(CLC);

}



/***************************************************************
detail_analyse()
***************************************************************/

int WINAPI detail_analyse()
{
    int i=0,j=0;
    BYTE *p;

    copy_input();

    p=(BYTE *)kbf.buffer;
    do{
        if (!slbl(p)){
            if (i==0)
                return(STC);
            else
                break;
            }

        if (sb.length==0)
            break;

        p+=sb.length;
        if (LOBYTE(sb.value)=='V')
            if (sb.head=='J'||sb.head=='Q'||sb.head=='X')
                (BYTE)sb.value='U';
        
        wp.syj[i]=sb.head;
        wp.bx_stack[i]=sb.bx1;
        wp.tone[i]=sb.tune;
        wp.yj[j]=sb.value;                          //WORD transport
        wp.yj_ps[j]=(int)(p-(BYTE *)kbf.buffer);
       
        i++, j++;
        if (i>=10)                      //10 1994.4
            break;

        if (sb.flag==TRUE)
            break;

      }while(1);

    wp.yjs=i;

    input_msg_type();

    return (0);
}




int WINAPI slbl(s_buffer)
BYTE *s_buffer;
{

    int i=0,j;
    BYTE cmp_buffer[5]={0};
    char *p;
    BYTE x,attr,y;

/*    analize the SHENGMU   */
    x=s_buffer[i++];
    attr=(BYTE)getattr(x,&x);                        // get char's attribute
    if (!attr){
        sb.length=i-1;
        sb.flag=TRUE;
        return(1);}

    if (attr==NUMBER)
        return(0);                   // error
    if (x=='I' || x=='U' || x=='V')
        return(0);                   // error
    switch (attr) {                    //1993.4.22
        case FIRST_T:
        case SECOND_T:
        case THIRD_T:
        case FORTH_T:
             return (0);            //error
        }                           //1993.4.22

    sb.value=0;
    sb.head=0;
    sb.length=0;
    sb.tune=0;
    sb.bx1=0;
    sb.bx2=0;
    sb.flag=FALSE;

    sb.head=x;
    if (attr==FUYIN){
         if (x=='Z' || x=='C' || x=='S' ){
        if ((s_buffer[i]&0xdf)==0x48){
               for (j=0; j<15; j=j+5){
                if (x==slbl_tab[j]){
                    sb.value=(WORD)slbl_tab[j+4]<<8;
                        sb.head=slbl_tab[j+4];
                        break;}
                     }// for()
               i++;
               }// if (s_buffer)
             else
            sb.value=(WORD)x<<8;
             }// if (x=='z')
         else
             sb.value=(WORD)x<<8;
         }//if (attr==FUYIN)
    else{
         i--;
         sb.value=0;
        } //else


/*    analize the YUNMU   */
    x=s_buffer[i];
    attr=(BYTE)getattr(x,&x);
    if (!attr){
         sb.length=(WORD)i;
         sb.flag=TRUE;
         return(1);}

    if (attr==YUANYIN){             //if no YUANYIN, goto step3
        (BYTE)sb.value=x;
        cmp_buffer[0]=x;
        i++;
        for (j=1; j<4; j++){
        x=s_buffer[i++];
        attr=(BYTE)getattr(x,&x);
        if (!attr){
            for (j=j; j<4; j++)
            cmp_buffer[j]='0';
            i--;
            sb.flag=TRUE;
            break;}

        if (attr==NUMBER){
            for (j=j; j<4; j++)
                cmp_buffer[j]='0';
            i--;
            break;
            }// if
        else
            cmp_buffer[j]=x;
        }//for

        for (j=3; j>0; j--){
           p=(LPSTR)ABCstrstr((LPSTR)slbl_tab,cmp_buffer);           //search the YUNMU
           if (p!=NULL){
           (BYTE)sb.value=*(p+4);               //get the YUNMU value
               break;
               }// if (p)
           if (cmp_buffer[j]!=0x30){
           cmp_buffer[j]='0';
               i--;}//if (cmp)
           }// for(j)


       }//if (x!=YUANYIN)
    else
         (BYTE)sb.value=0;


/*   see if the next is YUANYIN    */
    x=s_buffer[i];
    attr=(BYTE)getattr(x,&x);
    if (!attr){
       sb.length=(WORD)i;
       sb.flag=TRUE;
       if (sb.value<=0xff)
           sb.value=sb.value<<8;
       return(1);}
    if (attr==YUANYIN){
        y=s_buffer[i-1]&0xdf;
        if (y=='R'||y=='N'||y=='G'){
            i--;
            (BYTE)sb.value=0;
            for (j=3; j>0; j--){
                if (cmp_buffer[j]!=0x30){
                    cmp_buffer[j]='0';
                    break;}//if
                    }//for
        for (j=3; j>0; j--){
            p=(LPSTR)ABCstrstr((LPSTR)slbl_tab,cmp_buffer);           //search the YUNMU
            if (p!=NULL){
               (BYTE)sb.value=*(p+4);               //get the YUNMU value
                   break;
                   }// if (p)
            if (cmp_buffer[j]!=0x30){
               cmp_buffer[j]='0';
               i--;}//if (cmp)
            }// for(j)
            if (!(BYTE)sb.value)
               (BYTE)sb.value=cmp_buffer[0];
            }//if (y=='R')
        }//if (attr==YUANYIN)

    if (sb.value<=0xff)
        sb.value=sb.value<<8;

/*   analize the tune   */
    x=s_buffer[i];
    attr=(BYTE)getattr(x,&x);
    if (!attr){
       sb.length=(WORD)i;
       sb.flag=TRUE;
       return(1);}
    if (attr==FIRST_T||attr==SECOND_T||attr==THIRD_T||attr==FORTH_T){
        sb.tune=attr;
        i++;}



/*   analize the BIXING   */
    for (j=0; j<6; j++){
      x=s_buffer[i++];
      attr=(BYTE)getattr(x,&x);
      if (!attr){
        sb.flag=TRUE;
        sb.length=i-1;
        return(1);}

      if (attr==SEPERATOR){
          sb.flag=FALSE;
          sb.length=(WORD)i;
          return(1);                // if the string has seperator, move the
         }                  // pointer to the beginning of next YINJIE

      if (attr!=NUMBER){
        do{                     //1993.4.22
            if (attr==YUANYIN || attr==FUYIN){
                sb.flag=FALSE;
                sb.length=i-1;
                return(1);}

            x=s_buffer[i++];
            attr=(BYTE)getattr(x,&x);

            if (!attr){
                sb.flag=TRUE;
                sb.length=i-1;
                return(1);}
        }while(i<100);
        return (1);
      }                          //1993.4.22


      if (x>'0' && x<'9'){
          switch(j){
         case 0:
            sb.bx1=x<<4;
            break;
         case 1:
            sb.bx1+=x&0x0f;
            break;
         case 2:
            sb.bx2=(WORD)x;
            sb.bx2<<=12;
            break;
         case 3:
            sb.bx2=sb.bx2+(WORD)((x&0xf)<<8);
            break;
         case 4:
            (BYTE)sb.bx2=x<<4;
            break;
         case 5:
            (BYTE)sb.bx2+=x&0x0f;
            break;
         }//switch

      }//if(x)

    }// for

    do{
        x=s_buffer[i++];
        attr=(BYTE)getattr(x,&x);

    if (!attr){
        sb.flag=TRUE;
        sb.length=i-1;
        return(1);}

    if (attr==YUANYIN || attr==FUYIN){
        sb.flag=FALSE;
        sb.length=(WORD)i;
        return(1);}

    }while(i<100);

    return (0);

}



/*******************************************************
getchr(x)
*******************************************************/
int WINAPI getattr(x,p)
BYTE x;
char *p;
{
    if (x==0)
       return(FALSE);

    if (if_number_or_not(x))
       return(NUMBER);

    if (if_zimu_or_not(x)){
       x=x&0xdf;
       *p=x;
       if (x=='A'||x=='E'||x=='I'||x=='O'||x=='U'||x=='V')
        return(YUANYIN);
       else
        return(FUYIN);
       }

    if (x==SEPERATOR)
       return(SEPERATOR);


    switch(x){
        case '-':
        return(FIRST_T);
        case '/':
        return(SECOND_T);
        case '~':
        case '^':
        return(THIRD_T);
        case '\\':
          return(FORTH_T);

       }

    return (FALSE);
}



/*******************************************************
neg_slbl()
********************************************************/
int WINAPI neg_slbl(value)
WORD value;
{
    int i=0;
    BYTE x;

    s_tune();
    x=HIBYTE(value);
    if (x>=0x41)
        neg.buffer[i++]=x;
    else{
            if (x!=0)
                i=neg_sc(i,x);
        }

    x=LOBYTE(value);
    if (x>=0x41)
        neg.buffer[i++]=x;
    else{
        if (x!=0)
            i=neg_sc(i,x);
        }

    neg.buffer[i]=sb.tune;
    neg.length=i;
    for (x=0; x<i+1; x++)
        neg.buffer[x]=neg.buffer[x]|0x20;
    return(1);

}


/******************************************
neg_sc(i,x)
*******************************************/
int WINAPI neg_sc(i,x)
int i;
BYTE x;
{
    int j,n;

    n=(x-1)*5;
    for (j=0; j<4; j++){
        if (slbl_tab[n+j]!=0x30)
              neg.buffer[i++]=slbl_tab[n+j];
        else
            break;
        }
    return(i);
}



//      if (in.buffer[2]==1)
//              return(recall_rc());
//========================================================================
//     Covert
//========================================================================
//

int WINAPI convert(flag)
int flag;
{
    int j;

//      if (sb.bx2!=0)
//              return(0);

    if (!flag)
        word_long=wp.yjs-wp.xsyjw;
    else
        word_long=flag;

    if (word_long>9)                                                   //?
        word_long=9;                                            //?

    if (by_cchar_flag==1)
        word_long=1;

    if (word_long==1)
        return(pre_nt_w1(wp.xsyjw));



    for (j=word_long; j>1; j--){
        word_long=j;
        prepare_search1();
         abbr_s1();
        if (group_no){
            unit_length=j*2;
            return(CLC);
            }// if ()
        }// for()

    return(pre_nt_w1(wp.xsyjw));

}

/*********************************************
copy_input()
**********************************************/
int WINAPI copy_input()
{
    int i=0, j=0;

    if (in.info_flag==VK_MULTIPLY)                  //if "*"
        return(0);

    kbf.true_length=in.true_length;
    if (in.buffer[0]==SEPERATOR){
            kbf.true_length=in.true_length-1;
            i=1;
            }// if ((in.buffer)

    for (i=i; i<in.true_length+2; i++)
            kbf.buffer[j++]=in.buffer[i];

    kbf.max_length=in.max_length;
    kbf.info_flag=in.info_flag;

    return (0);

}

/**************************************************
input_msg_type()
**************************************************/
void WINAPI input_msg_type()
{
    int i;
    for (i=0; i<wp.yjs; i++){
        wp.cmp_stack[i]=QP_FLAG;
        if (LOBYTE(wp.yj[i])==0)
            if (wp.syj[i]==HIBYTE(wp.yj[i]))
                wp.cmp_stack[i]=JP_FLAG;

        if (wp.tone[i]!=0)
            wp.cmp_stack[i]|=YD_FLAG;

        if (wp.bx_stack[i]!=0)
            wp.cmp_stack[i]|=BX_FLAG;

        }// for


}

/*****************************************************
pre_nt_w1()
******************************************************/
int WINAPI pre_nt_w1(ps)
int ps;
{
    unit_length=2;
    word_long=1;
    cmp_yj=wp.yj[ps];
    cmp_head=wp.syj[ps];
    cmp_bx=wp.bx_stack[ps];
    cmp_state=wp.cmp_stack[ps];

    find_one_hi();

    w1_no_tune();
    return(group_no);

}

/********************************************************
w1_no_tune()
*********************************************************/
void WINAPI w1_no_tune()
{
    out_svw_cnt=0;
    sc_gb();
    sc_gbdy();
    group_no=out_svw_cnt;
    paidui(group_no);

}

/*********************************************************
sc_gb()
**********************************************************/
int WINAPI sc_gb()
{
    BYTE x;
    int cnt,i;

    cnt=(87-15)*94;
    if (cmp_state&4){
        if (cmp_bx==0){
            x=HIBYTE(cmp_yj);
            if (x!='A'&&x!='O'&&x!='E'){
                cnt=(55-15)*94;
                cmp_state=cmp_state|0x80;
                }// if (x=='A')
            else
                cmp_state=(cmp_state&0xfb)|QP_FLAG;

            }// if (!cmp_bx)
        }// if (cmp_state)

    for (i=0; i<cnt; i++){
        if (cmp_yj==cisu->t_bf1[i])
            get_the_one(i);
        else{
            if (cmp_state&4){
                if (cmp_head==HIBYTE(cisu->t_bf1[i]))
                    get_the_one(i);
                else
                     if ( cmp_head==fu_sm(HIBYTE(cisu->t_bf1[i])) )
                    get_the_one(i);

                }// if (cmp_state)
            }//else
        }//for()

    return(0);

}

/*******************************************************
sc_gbdy()
*******************************************************/
int WINAPI sc_gbdy()
{
    int cnt,i;

    cnt=cisu->t_bf_start[2]/2;
    for (i=0; i<cnt; i=i+2){
        if (cmp_yj==cisu->t_bf2[i])
            get_the_one2(i);
        else{
            if (cmp_state&4){
                if (cmp_head==HIBYTE(cisu->t_bf2[i]))
                    get_the_one2(i);
                else {
                 if (cmp_head==fu_sm(HIBYTE(cisu->t_bf2[i])))
                    get_the_one2(i);}
                }// if (cmp_state)
            }//else
        }//for()

    return(0);

}

/********************************************************
get_the_one()
*********************************************************/
int WINAPI get_the_one(i)
int i;
{
    BYTE x;

    WORD *out_svw_p=(WORD *)out_svw;
    BYTE *msx_p=(BYTE *)msx_area;

    if (cmp_bx1(i)!=0)
        return(0);

    out_svw_p[out_svw_cnt]=i+0x2020;

    if (i>=(55-16+1)*94)
        x=0x20;
    else
        x=pindu.pd_bf1[i];

    if (cmp_state&0x80){
        if (x<=(154+50)){
            return(0);
            }// if (x)
        }// if (cmp_state)
    msx_p[out_svw_cnt]=x;
    out_svw_cnt++;
    return(0);

}

/***********************************************************
cmp_bx1()
************************************************************/
int WINAPI cmp_bx1(i)
int i;
{
    BYTE x;

    if (cmp_bx==0)
        return(0);

    x=spbx_tab[i];
    if (x==cmp_bx)
        return(0);

    x=x&0xf0;
    if (x==cmp_bx)
        return(0);

    return(1);

}


/********************************************************
get_the_one2()
*********************************************************/
int WINAPI get_the_one2(i)
int i;
{
    BYTE x;

    WORD *out_svw_p=(WORD *)out_svw;
    BYTE *msx_p=(BYTE *)msx_area;

    if (cmp_bx2(i)!=0)
        return(0);

    out_svw_p[out_svw_cnt]=i+0x8000;

    if ((i/2)>=pindu.pd_bf0[2])
        x=0x20;
    else
        x=pindu.pd_bf2[i/2];

    if (cmp_state&0x80){
        if (x<=(154+50)){
            return(0);
            }// if (x)
        }// if (cmp_state)
    msx_p[out_svw_cnt]=x;
    out_svw_cnt++;
    return(0);

}

/***********************************************************
cmp_bx2()
************************************************************/
int WINAPI cmp_bx2(i)
int i;
{
    BYTE x;
    WORD y;

    if (cmp_bx==0)
        return(0);

    i++;
    y=cisu->t_bf2[i];
    y=((BYTE)y-0xb0)*94+(HIBYTE(y)-0xa1);

    x=spbx_tab[y];
    if (x==cmp_bx)
        return(0);

    x=x&0xf0;
    if (x==cmp_bx)
        return(0);

    return(1);

}

/***********************************************************
paidui()
************************************************************/
int WINAPI paidui(cnt)
int cnt;
{
    int i,j,n,flag;
    BYTE x1,y1;
    WORD x,y;
    WORD *out_p;
    BYTE *msx_p=(BYTE *)msx_area;

    out_p=(WORD *)out_svw;
    if (cnt<=1)
        return(0);

    for (n=cnt-1; n>0; n--){
        flag=0;
        for (i=0; i<n; i++){
        if (msx_p[i]==msx_p[i+1]){
            if (out_p[i]>out_p[i+1]){
                x=out_p[i];
                out_p[i]=out_p[i+1];
                out_p[i+1]=x;
                flag++;
                }//if (out_p)
            }// if (msx_p)
        else{
            if (msx_p[i]<msx_p[i+1]){
                x1=msx_p[i];
                msx_p[i]=msx_p[i+1];
                msx_p[i+1]=x1;
                x=out_p[i];
                out_p[i]=out_p[i+1];
                out_p[i+1]=x;
                flag++;
                }
            }//else
        }// for(i)
    if (flag==0)
        break;

    }// for(n)

    return (0);
}



void WINAPI s_tune()
{
}

int WINAPI fu_sm(fy)
BYTE fy;
{
    switch(fy){
        case 1:
            return('Z');
        case 2:
            return('S');
        case 3:
            return('C');
        default:
            return(fy);
    }
}



/**********************************************
find_one_hi()
***********************************************/
int WINAPI find_one_hi()
{
    WORD foh_save=0;
    int i;

    if (!cmp_bx)
        if (cmp_state&4)
            return(0);

    sImeG.cp_ajust_flag=0;

    i=0;
    do{
        if (czcx(&tmmr.stack1[i])){
            if (!foh_save)
                foh_save=cmp_cisu;
            else{
                if (foh_save==cmp_cisu){
                    sImeG.cp_ajust_flag=1;
                    result_area[result_area_pointer++]=LOBYTE(cmp_cisu);
                    result_area[result_area_pointer++]=HIBYTE(cmp_cisu);
                    return(0);
                    }//if (foh_save)
                }//else
            }//if (czcx)
        i++;
      }while(i<(sizeof tmmr.stack1)/2);     //94.1 add div 2

      return (0);
}

/*************************************************
czcx()
**************************************************/
int WINAPI czcx(stack)
WORD *stack;
{

        cmp_cisu=stack[0];

        if (!cmp_cisu)
            return(STC);

        if (cmp_bx)
            if (HIBYTE(cmp_cisu)&0x40)
                cmp_cisu&=0xbfff;

        if (cmp_a_slbl_with_bx())
            return(CLC);

        return(STC);

}

/********************************************
find_multy_hi()
*********************************************/
int WINAPI find_multy_hi()
{
    if (word_long==2)
        find_two_hi();
    if (word_long==3)
        find_three_hi();
    return(0);

}

/********************************************
find_two_hi()
*********************************************/
int WINAPI find_two_hi()
{
    int i,j;
    WORD *result_p;

    result_p=(WORD *)result_area;

    for (i=0; i<(sizeof tmmr.stack2)/(2*2); i=i+2){    //94.1 add *2
        if (!tmmr.stack2[i]){
            sImeG.cp_ajust_flag=0;
            return(0);
            }

        if (cmp_2_and_3(&tmmr.stack2[i])){
            sImeG.cp_ajust_flag=1;
            for (j=0; j<word_long; j++)
                result_p[result_area_pointer/2+j]=tmmr.stack2[j+i]&0xbfff;
            result_area_pointer+=word_long*2;
            return(0);
            }//if
        }//for

    sImeG.cp_ajust_flag=0;
    return(0);

}

/********************************************
find_three_hi()
*********************************************/
int WINAPI find_three_hi()
{
    int i,j;
    WORD *result_p;

    result_p=(WORD *)result_area;

    for (i=0; i<(sizeof tmmr.stack3)/(3*2); i=i+3){    //94.1 add *2
        if (!tmmr.stack3[i]){
            sImeG.cp_ajust_flag=0;
            return(0);
            }

        if (cmp_2_and_3(&tmmr.stack3[i])){
            sImeG.cp_ajust_flag=1;
            for (j=0; j<word_long; j++)
                result_p[result_area_pointer/2+j]=tmmr.stack3[j+i]&0xbfff;
            result_area_pointer+=word_long*2;
            return(0);
            }// if (cmp_2_and_3)
        }//for

    sImeG.cp_ajust_flag=0;
    return(0);

}

/***********************************************
cmp_2_and_3()
************************************************/
int WINAPI cmp_2_and_3(t_stack)
WORD *t_stack;
{
    int i,yj_p;

    yj_p=wp.xsyjw;                          //1993,10,8
    for (i=0; i<word_long; i++){
        cmp_cisu=t_stack[i];
        pre_cmp((WORD)yj_p);
        if (word_long==2)
            if (cmp_state&4)
                if (!(HIBYTE(cmp_cisu)&0x40))
                    return(STC);
                else
                    cmp_cisu&=0xbfff;

        if (!cmp_a_slbl_with_bx())
            return(STC);
        yj_p++;
        }
    return(CLC);

}


void WINAPI find_that()
{
}

int WINAPI find_hz(x)
WORD x;
{
    if (x>0xa000 || x<0x2020)
        return(x);

    if (x>=0x8000){
        x=(x-0x8000)+1;
        return(cisu->t_bf2[x]);
        }

    return((x-0x2020)/94+0xb0+((x-0x2020)%94+0xa1)*0x100);


}

/*************************************************
prepare_search1()
**************************************************/
int WINAPI prepare_search1()
{
    BYTE f_ci1,f_ci2,x;

    f_ci1=wp.syj[wp.xsyjw];
    f_ci2=wp.syj[wp.xsyjw+1];
    f_ci1=(BYTE)fu_sm(f_ci1);
    f_ci2=(BYTE)fu_sm(f_ci2);

    if(f_ci1<0x41)
        f_ci1=0x41;
    if (word_long>=5)
        f_ci2=(BYTE)word_long;

    search_and_read(f_ci1,f_ci2);
//
// After reading, counting the search place is needed
// First, count the STD dictionary buffers
//
    search_start=6;
    search_end=6;
    if (word_lib_state&1){
        x=word_long-2;
        if (x>=3){
            x-=3;
            search_start+=4;}

        if (x>0)
             {
            if (sizeof lib_w<lib_w[x-1])
                search_start=sizeof lib_w;
            else
                search_start=lib_w[x-1];
            }

        search_end=lib_w[x];
        if (sizeof lib_w<search_end)
            search_end=sizeof lib_w;

        }//if (word_lib_state)

 //
 // Second, count the User dic. area.
 //

    kzk_search_start=6;
    kzk_search_end=6;
    if (!(word_lib_state&2))                //Note exp: !word...&2
        return(1);                      // and !(word&2)

    x=word_long-2;
    if (x>=3){
        x-=3;
        kzk_search_start+=4;}

    if (x>0)
        {
        if (sizeof kzk_lib_w<kzk_lib_w[x-1])
            kzk_search_start=sizeof kzk_lib_w;
        else
            kzk_search_start=kzk_lib_w[x-1];
        }

    kzk_search_end=kzk_lib_w[x];
    if (sizeof kzk_lib_w<kzk_search_end)
        kzk_search_end=sizeof kzk_lib_w;

    return (0);
}


/********************************************
search_and_read()
    entry: LOBYTE(f_ci)=the first letter,
           HIBYTE(f_ci)=the second letter,
    exit:  NC success; C not success;
**********************************************/
int WINAPI search_and_read(f_ci1,f_ci2)
BYTE f_ci1,f_ci2;
{
    if (if_already_in(f_ci1,f_ci2))
        return(0);

    count_basic_pera(f_ci1,f_ci2);
    if (item_length!=0)
        if (read_a_page(0,r_addr,item_length))
            word_lib_state=word_lib_state|1;
    read_kzk_lib();

    return (1);
}

/***************************************************************
if_already_in():        adjust if the page has already in the memory
*****************************************************************/
int WINAPI if_already_in(f_ci1,f_ci2)
BYTE f_ci1,f_ci2;
{
    WORD x;

    (BYTE)x=f_ci2;
    x=x*0x100+f_ci1;

    if (x==last_item_name)
        return(CLC);

    if (f_ci1==(BYTE)last_item_name)
        if (f_ci2>9)
            return(STC);
        else
            if (HIBYTE(last_item_name)>9)
                return(STC);
            else
                return(CLC);

    return(STC);

}

/********************************************************
count_basic_pera():     count the sub_library address;
                    count the page address;
                    count the read_write length;
********************************************************/
int WINAPI count_basic_pera(f_ci1,f_ci2)
BYTE f_ci1,f_ci2;
{
    BYTE x;

    word_lib_state=0;
    item_addr=0xffff;
    item_length=0;
    (BYTE)last_item_name=f_ci2;
    last_item_name=last_item_name*0x100+f_ci1;

    if (f_ci1>'I'&& f_ci1<'U')
        slib_addr=(f_ci1-0x41-1)*27;
    else
        if (f_ci1>'V')
            slib_addr=(f_ci1-0x41-3)*27;
        else
            slib_addr=(f_ci1-0x41)*27;

    r_addr=ndx.dir[slib_addr+1];
    r_addr+=ndx.body_start;
    r_addr=r_addr*16;

    if (f_ci2<'A')
        item_addr=slib_addr+MORE_THAN_5;
    else
        if (f_ci2>'I' && f_ci2<'U')
            item_addr=slib_addr+(f_ci2-0x41-1);
        else
            if (f_ci2>'V')
                item_addr=slib_addr+(f_ci2-0x41-3);
            else
                item_addr=slib_addr+(f_ci2-0x41);

    r_addr=r_addr+ndx.dir[item_addr+1+1];
    item_length=ndx.dir[item_addr+1+1+1];
    item_length-=ndx.dir[item_addr+1+1];
    return(0);

}

/***********************************************************
read_kzk_lib(): search the expended lib
************************************************************/
int WINAPI read_kzk_lib()
{
    r_addr=kzk_ndx.dir[slib_addr+1];
    r_addr+=kzk_ndx.body_start;
    r_addr=r_addr*16+KZK_BASE;
    r_addr=r_addr+kzk_ndx.dir[item_addr+1+1];
    kzk_item_length=kzk_ndx.dir[item_addr+1+1+1];
    item_length-=kzk_ndx.dir[item_addr+1+1];
    if (kzk_item_length<0)
        kzk_item_length=0;
    if (!kzk_item_length)
        return(STC);
    if (!read_a_page(1,r_addr,kzk_item_length))
        return(STC);
    word_lib_state|=2;
    return(CLC);

}


///////////////////////////////////////////////////////////////////////////
//     ʿ             READ_A_PAGE()                                  //
//     : ҪĴʿҳָĻ                              //
//     : START_PS  ʿʼλ                                  //
//           FILE_FLAG  =0  ׼                                     //
//                      =1  չ                                       //
//           SIZE       ҳ(ֽ)                                 //
//     : TRUE  ɹ                                                  //
//           FALSE ʧ                                                  //
//     ע:ҪжSIZEĴСǷԽ,Էֹ.                   //
//          Խ,ջĴСض.                             //
///////////////////////////////////////////////////////////////////////////

int WINAPI read_a_page(file_flag, start_ps, size)
BYTE file_flag;
LONG start_ps;
WORD size;
{
// 94/4/16 HANDLE hd;
int hd = -1;

if ((last_flag==file_flag)&&(last_start_ps==start_ps)&&(last_size==size))
       return(1);
        //ζдʹȫͬ,̲;



if (file_flag==0)
{
     if (size> sizeof lib_w) size=sizeof lib_w;
     hd=OpenFile(std_dct,&openbuf,OF_READ);
     if (hd == -1) return(0);
     _llseek(hd,start_ps,0);
     if(_lread(hd,(LPSTR)lib_w,size)<=0)
     {
     _lclose(hd);
     return(0);
     }
}


if (file_flag==1)
{
     hd=OpenFile(user_lib,&openbuf_kzk,OF_READ);
     if (hd == -1) return(0);
     if (size>sizeof kzk_lib_w) size=sizeof kzk_lib_w;
             //жϻǷԽ

     _llseek(hd,start_ps,0);
     if(_lread(hd,(LPSTR)kzk_lib_w,size)<=0)
     {
    _lclose(hd);
    return(0);
     }
}

if ( hd != -1 )
  _lclose(hd);

last_flag=file_flag;
last_start_ps=start_ps;   // 
last_size=size;
return(1);
}

/**********************************************************************
Name:     abbr_s1()
Popurse:  Find match words arrcoding to the given input message.
      Search order is:
            Temp_rem area
            Standard Dictionary
            User Dictionary
      If there are more than one words, judge what is the
         suitable one.

**********************************************************************/
int WINAPI abbr_s1()
{
    group_no=0;
    msx_area_cnt=0;
    out_svw_cnt=0;

    find_new_word();                                    // Search temp rem_area

    abbr_entry((BYTE *)kzk_lib_w+kzk_search_start,(BYTE *)kzk_lib_w+kzk_search_end,4);
                        // Search User dic.
    abbr_entry((BYTE *)lib_w+search_start, (BYTE *)lib_w+search_end,0);
                        // Search stndard dic.

    if (!group_no) return(STC);                 // Without any results...
    if (group_no==1) return(CLC);          // Only one!

    order_result2();                                    // Results more than one...
    if (sImeG.auto_mode) find_multy_hi();     // If in frenquency ajust mode...
     return(CLC);                        // Return OK.
}

/********************************************************
find_new_word()
*********************************************************/
void WINAPI find_new_word()
{
    fczs1((LPSTR)tmmr.temp_rem_area,sizeof tmmr.temp_rem_area,2);
    fczs1((LPSTR)tmmr.rem_area,sizeof tmmr.rem_area,0x82);

}

/*****************************************************
fczs1()
******************************************************/
int WINAPI fczs1(rem_p,end,area_flag)
BYTE *rem_p;                                        //92-12-18 SZ
int end,area_flag;
{
    int i=0,w_long,j;
    WORD *p;

    w_long=word_long*2;

    while(i<end){
        if (w_long==rem_p[i]){
            if (find_long_word2(&rem_p[i])){
                group_no+=1;
                if (!trs_new_word(i,&rem_p[i],area_flag))         //
                    return(0);
            }// if (find_long_word2)
            }// if (w_long)

        if (rem_p[i]==0)
            return(0);

        if (rem_p[i]>18||(rem_p[i]&1)){
            p=(WORD *)&rem_p[i];
            for (j=0; j<(end-i)/2; j++){       //94.2.3 ZHU  (end-i)/2
                if (p[j]!=0)
                    p[j]=0;
                else
                    return(0);
                }// for
            }//if (rem_p)

        i+=rem_p[i]+2;

        }//while

  return (0);
}

/************************************************
find_long_word2()
*************************************************/
int WINAPI find_long_word2(buffer)
BYTE *buffer;
{
    int yj_p,i;

    yj_p=wp.xsyjw;
    for (i=0; i<word_long*2; i=i+2){
        cmp_cisu=buffer[i+2]+buffer[i+2+1]*0x100;
        pre_cmp((WORD)yj_p);
        if (!cmp_a_slbl_with_bx())
            return(STC);
        yj_p++;
        }

    return(CLC);

}


/*************************************************
trs_new_word()
**************************************************/
int WINAPI trs_new_word(word_addr,buffer,area_flag)
int word_addr,area_flag;
BYTE *buffer;
{
    int i;

    if (out_svw_cnt>=sizeof out_svw){
        group_no--;
        return(STC);
        }// if (out_svw_cnt)

    for (i=0;i<word_long*2; i++)
        out_svw[out_svw_cnt++]=buffer[i+2];

    msx_area[msx_area_cnt].pindu=0x70+(BYTE)group_no;
    msx_area[msx_area_cnt].from=(BYTE)area_flag;                  //come from temp_area
    msx_area[msx_area_cnt].addr=(WORD)word_addr;
    if (buffer[1]&0x80)
        msx_area[msx_area_cnt].pindu=0x31;

    msx_area_cnt++;

    return(CLC);
}

/****************************************
pre_cmp()
*****************************************/
void WINAPI pre_cmp(x)
WORD x;
{
    cmp_yj=wp.yj[x];
    cmp_head=wp.syj[x];
    cmp_state=wp.cmp_stack[x];
    cmp_bx=wp.bx_stack[x];
}

/******************************************
cmp_a_slbl_with_bx()
*******************************************/
int WINAPI cmp_a_slbl_with_bx()
{
    if (cmp_cisu<0x2020)
        return(STC);

    if (cmp_cisu>=0x8000){
        if ((cmp_cisu-0x8000)>=cisu->t_bf_start[2]/2)
            return(STC);}
    else{
        if ((cmp_cisu-0x2020)>=cisu->t_bf_start[1]/2)
            return(STC);}

    if (!cmp_a_slbl())
        return(STC);

    if (!cmp_bx)
        return(CLC);


    if (!yjbx())
        return(STC);

    return(CLC);

}

/*******************************************
cmp_a_slbl()
********************************************/
int WINAPI cmp_a_slbl()
{

    if (cmp_state&2)  {

        if (cmp_cisu>=0x8000){
            if (cmp_yj==cisu->t_bf2[cmp_cisu-0x8000])
                return(CLC);
            else
                return(STC);
                //??               return(cmp_first_letter());
            } //if (cmp_cisu...

        else{
            if (cmp_yj==cisu->t_bf1[cmp_cisu-0x2020])
                return(CLC);
            else
                return(STC);
            }//else
      }// if (cmp_state...

    return(cmp_first_letter());

}

/************************************************
cmp_first_letter()
*************************************************/
int WINAPI cmp_first_letter()
{
    WORD py_nm;
    if (!(cmp_state&4))                             //NOte!!!
        return(STC);

    py_nm=(WORD)cisu_to_py();
    if ((HIBYTE(py_nm)&0x5f)==cmp_head)
        return(CLC);
    else{
        py_nm=(WORD)get_head(HIBYTE(py_nm));
        if ((LOBYTE(py_nm)&0xdf)==cmp_head)
            return(CLC);
        else
            return(STC);
        }

}

/***********************************************
cisu_to_py()
************************************************/
int WINAPI cisu_to_py()
{
    if (cmp_cisu>=0x8000)
        return(cisu->t_bf2[(cmp_cisu-0x8000)]);
    else
        return(cisu->t_bf1[(cmp_cisu-0x2020)]);
                
}

/**************************************************
get_head()
***************************************************/
int WINAPI get_head(first_letter)
BYTE first_letter;
{
    if (first_letter>=0x41)
        return(first_letter);
    
    first_letter=(first_letter-1)*5;
    return(slbl_tab[first_letter]);
    
}

/******************************************************
yjbx()
*******************************************************/
int WINAPI yjbx()
{
    BYTE bx;
    WORD pos;

    if (cmp_cisu<0x8000)
           pos = cmp_cisu-0x2020;
    else{
        pos =cisu->t_bf2[(cmp_cisu-0x8000)+1];
        pos =(HIBYTE(pos)-0xa1)+(LOBYTE(pos)-0xb0)*94;
        }
    if (pos>= 94*94)  return (STC);
    bx=spbx_tab[pos];
    if (cmp_bx==bx)
        return(CLC);
    else
        if (cmp_bx==(bx&0xf0))
            return(CLC);
        else
            return(STC);

}


/****************************************************
abbr_entry()
*****************************************************/
int WINAPI abbr_entry(s_start,s_end,ComeFrom)
BYTE *s_start,*s_end,ComeFrom;                                                   //Search start and Ending

{                                                                                               // position
int i;

    while (s_start<s_end){
        if (cmp_long_word2(s_start)){                                    //Compare word by word.
            if (out_svw_cnt>=sizeof out_svw)    // If buffer out_svw
                                //   is full, sorry... 
                return(STC);
                for (i=0; i<word_long*2; i++)   
                    out_svw[out_svw_cnt++]=s_start[i];  //Move the words    

                msx_area[msx_area_cnt].pindu=s_start[i];
                msx_area[msx_area_cnt].from=ComeFrom; //come from ...
                msx_area[msx_area_cnt].addr=(WORD)s_start; // Where is the ...

                msx_area_cnt++;                  // Increae the pointer 
                                 // for the attribue area
    
            group_no+=1;                                            // In case of OK, increaase 
                                                // results counter.
        }//if(cmp..                 
        
         s_start+=(word_long+word_long+1);          // Push down the search pointer
                            // by word_long*2+1 
        }

    return(CLC);                                                            // The value of return is no
                            // use for the route.
}

/******************************************************
cmp_long_word2()
*******************************************************/
int WINAPI cmp_long_word2(buffer)
BYTE *buffer;
{
    int yj_p,i;
    
    yj_p=wp.xsyjw;
    for (i=0; i<word_long*2; i=i+2){
        cmp_cisu=buffer[i]+buffer[i+1]*0x100;
        if (cmp_cisu<0x2020)
            return(STC);
        pre_cmp((WORD)yj_p);
        if (!cmp_a_slbl_with_bx())
            return(STC);
        yj_p++;
        }
    
    return(CLC);
            
}

/*******************************************************
order_result2()
********************************************************/
int WINAPI order_result2()
{
    int lng,i,j,n;
    BYTE x,flag;
    WORD y;

    lng=word_long*2;
    if (xs_flag==1){
        xs_flag=0;
        if (!fenli_daxie())
        return(0);
        }

    if (msx_area_cnt==1)
        return(0);


    for (i=group_no-1; i>0; i--){
        flag=0;
    for (j=0; j<i; j++){
        if (msx_area[j].pindu<msx_area[j+1].pindu){
            for (n=j*lng; n<j*lng+lng; n++){
                x=out_svw[n];
                out_svw[n]=out_svw[n+lng];
                out_svw[n+lng]=x;
                }//for
            x=msx_area[j].pindu;
            msx_area[j].pindu=msx_area[j+1].pindu;
            msx_area[j+1].pindu=x;
            x=msx_area[j].from;
            msx_area[j].from=msx_area[j+1].from;
            msx_area[j+1].from=x;
            y=msx_area[j].addr;
            msx_area[j].addr=msx_area[j+1].addr;
            msx_area[j+1].addr=y;
            flag=1;

        }// if (msx)
         }//for(j)
         
         if (!flag)
        break;
    }// for(i)


    return (0);

}

/*****************************************************
fenli_daxie()
******************************************************/
int WINAPI fenli_daxie()
{
    int i,j,n,lng;

    j=0;
    lng=word_long*2;
    for (i=0; i<msx_area_cnt; i++){
        if (msx_area[i].pindu==0x31){
            msx_area[j].pindu=msx_area[i].pindu;
            msx_area[j].from=msx_area[i].from;
            msx_area[j].addr=msx_area[i].addr;
            for (n=0; n<lng; n++)
                out_svw[j*lng+n]=out_svw[i*lng+n];
            j++;                                                                            
            }//if
        }// for
    
    if (!j)
        return(CLC);            // there is no Caps;
    group_no=j;
    return(STC);                    // there has Caps;

}
    
/*************************************************
rzw()
**************************************************/
int WINAPI rzw()
{
    if (!(system_info&1))           //if strength mode, ret
        sfx_proc();
    return(0);
    
}

/************************************************
abbr()
*************************************************/
int WINAPI abbr()
{
    int i;
    WORD x;
    WORD *kbf_p;
    
    if (in.true_length<2){
        xs_flag=1;
        jiyi_pindu|=0x80;
        return(0);              
        }

    for (i=0; i<in.true_length; i++){
        if (in.buffer[i]&0x20){                 //if not Caps
            xs_flag=1;
            jiyi_pindu|=0x80;
            return(0);
            }// if 
        }//for
    
    kbf_p=(WORD *)kbf.buffer;
    x=0x2d*0x100;
        
    kbf.true_length=in.true_length*2;
    for (i=0; i<in.true_length; i++){
        (BYTE)x=in.buffer[i];
        *(LPUNAWORD)&kbf_p[i]=x;                
        }
    kbf.buffer[in.true_length*2]=0;
    in.info_flag=VK_MULTIPLY;
    return(0);
        
}


/***************************************************
sfx_proc()
****************************************************/
int WINAPI sfx_proc()
{
    int i,j;
    WORD x,save_xsyjw;
    WORD *result_p;
    BYTE *sfx_p;

    result_p=(WORD *)result_area;
    sfx_p=(BYTE *)sfx_table;
    
    if (sImeG.cp_ajust_flag==1)
        return(0);
    if (word_long>=3)
        return(0);

    save_xsyjw=(WORD)wp.xsyjw;
    wp.xsyjw=wp.xsyjs;
    
    i=0;
    do{
        x=sfx_table[i];
        if (HIBYTE(x)&sfx_attr)
            if (LOBYTE(x)==word_long*2)
                if (cmp_long_word2(&sfx_p[i*2+2])){
                    for (j=0; j<word_long; j++)
                         result_p[result_area_pointer/2+j]=sfx_table[i+1+j];
                    result_area_pointer+=word_long*2;
                    wp.xsyjw=save_xsyjw;
                    sImeG.cp_ajust_flag=1;
                    return(0);
                    }//if (cmp_...
        
        i+=LOBYTE(x)/2+1;

        }while(i<sfx_table_size);
            
    wp.xsyjw=save_xsyjw;

    return (0);
    
}


void WINAPI zdyb()
{
}

/************************************************
recall_rc()
*************************************************/
int WINAPI recall_rc()
{
    int i;
    BYTE x;

    word_long=wp.yjs-wp.xsyjw;
    unit_length=word_long*2;
            
    i=0;
    do{
        x=logging_stack[i];
        if (!x)
            break;
        if (word_long*2>x)
            i+=x+1;
        else{
            if (x>20)                       //if more than 10 chinese words?
                break;
            if ((i+x)>=logging_stack_size)                  
                break;                  //if the last word is not completely
            if (find_long_word3((WORD *)&logging_stack[i+1],(int)(x/2))){
                trs_new_word3(x,i);
                group_no++;
                if (group_no>5)
                    break;
                }
            i+=x+1;
            }//else
        }while(i<logging_stack_size);
    
    if (group_no){
        word_long=4;
        unit_length=8;
        return(CLC);
        }
            
    return(STC);                            
}

/*********************************************
find_long_word3()
**********************************************/
int WINAPI find_long_word3(stack,length)
WORD *stack;
int length;
{
    int yj_p,i,err_flg,m;
    
    
    yj_p=wp.xsyjw;
    
    m=0;
    while ((length-m)>=word_long){
        err_flg=0;
        for (i=0; i<word_long; i++){
            cmp_cisu=stack[m+i];
            pre_cmp((WORD)(yj_p+i));
            if (!cmp_a_slbl_with_bx()){
                m++, err_flg=1;
                break;
                }
            }//for
        if (!err_flg)
            return(CLC);
            
        }
    return(STC);
        
}


/*************************************************
trs_new_word3()
**************************************************/
void WINAPI trs_new_word3(length,addr)
int addr;
BYTE length;
{
    int cnt,i;
    char *msx_area_p;

    cnt=8*group_no;
    
    msx_area_p=(BYTE *)msx_area;
    msx_area_p[22*group_no]=length;
    addr++;
    for (i=0; i<length; i++)
        msx_area_p[22*group_no+1+i]=logging_stack[addr+i];                                              
    for (i=0; i<8; i++)
        out_svw[cnt+i]=0xa1;
    if ((length/2)<=4){
        for (i=0; i<length; i++)
            out_svw[cnt+i]=logging_stack[addr+i];
        }
    else{
        for (i=0; i<4; i++)
            out_svw[cnt+i]=logging_stack[addr+i];
        out_svw[cnt+i]=0xa1,i++;
        out_svw[cnt+i]=0xad,i++;
        out_svw[cnt+i]=logging_stack[addr+length-2],i++;
        out_svw[cnt+i]=logging_stack[addr+length-1],i++;
        }

}

/******************************************************
new_word():
*******************************************************/
int WINAPI new_word()
{
    WORD temp_save,suc_flag,i,j;

    by_cchar_flag=0;
    wp.xsyjw=0;
    temp_save=sImeG.cp_ajust_flag;

    suc_flag=0;

    if (convert(0)){
        sImeG.cp_ajust_flag=(BYTE)temp_save;
        if (unit_length==new_no){
            for (i=0; i<group_no; i++){
                suc_flag = 0;        //1993 11 4
                for(j=0; j<new_no; j++){
                    if (result_area[j]!=out_svw[i*unit_length+j])
                        suc_flag=1;
                    }//for(j)
                if (!suc_flag){
                    return(0);}
                }//for(i)
            }//if (unit_length)
        }//if(convert)

    sImeG.cp_ajust_flag=(BYTE)temp_save;
    by_cchar_flag=1;
    return(rem_new_word());

}


/***********************************************************
rem_new_word(): fill the new word in temp_rem_area
************************************************************/
int WINAPI rem_new_word()
{
    WORD i,count;                            //SZ
    WORD *result_area_p;

    count=(WORD)( (sizeof tmmr.temp_rem_area)-(new_no+2) );  //92-12-18 SZ
    CopyMemory/*memmove*/(&tmmr.temp_rem_area[(new_no+2)/2],
        tmmr.temp_rem_area,
        count);

    tmmr.temp_rem_area[0]=new_no+jiyi_pindu*0x100;

    result_area_p=(WORD *)result_area;
    for (i=0; i<new_no/2; i++)
        tmmr.temp_rem_area[i+1]=result_area_p[i];

    write_new_word(1);
   
    return(0);

}

/**********************************************************************
 Function: AddExtLib()
 Purpose:  Get a temperary rem word into high level depanding
       how many times it has been used.
  Entry:   Must be called from out_result.
  Out  :   None.
***********************************************************************/
int WINAPI AddExtLib(){
 
    int x,count,i;


    if((unit_length>=4)&&(unit_length<=18))  //rem word limited
         if(msx_area[current_no].from==2)
         {     // If a rem word?
            x=msx_area[current_no].addr/2;     //get word addr in temp...

            if (x<sizeof tmmr.temp_rem_area/2)
            {   //Insure random errof out limited
                if ((tmmr.temp_rem_area[x]&0xff)!=unit_length)
                        return(STC);

               tmmr.temp_rem_area[x]+=0x100;    //Increase used times.

               if((tmmr.temp_rem_area[x]&0xf00)>=0x300)
               {                            
                  count=(sizeof tmmr.rem_area)
                          -(unit_length+2);     // Push down middle rem area
                  CopyMemory(&tmmr.rem_area[(unit_length+2)/2],
                            tmmr.rem_area,
                            count);

                  for(i=0; i<unit_length/2+1; i++)
                     tmmr.rem_area[i]=tmmr.temp_rem_area[x+i]; 
                                       //move to middle rem area.

                  count=sizeof tmmr.temp_rem_area-x*2
                         -(unit_length+2);   //delete it from temp ...
                  CopyMemory(&tmmr.temp_rem_area[x],
                             &tmmr.temp_rem_area[x+unit_length/2+1],
                             count);

                  write_new_word(0);
                  if(tmmr.rem_area[50])   //[400])          //1994.4.21
                  {
                    UpdateProc();
                  }
               }                //write changes
               else
                  write_new_word(1);
            }

         }

    return (0);
}

/********************************************************
write_new_word():
*********************************************************/
void WINAPI write_new_word(flag)
int flag;
{
    int count;
    LONG distance;
    WORD *p;

    distance=sizeof tmmr.stack1+sizeof tmmr.stack2+sizeof tmmr.stack3;
    count=sizeof tmmr.temp_rem_area;
    p=tmmr.temp_rem_area;

    if (flag!=1){
        distance=sizeof tmmr.stack1+sizeof tmmr.stack2
                    +sizeof tmmr.stack3+sizeof tmmr.temp_rem_area;
        p=tmmr.rem_area;
        if (flag<1){
            distance=sizeof tmmr.stack1
                 +sizeof tmmr.stack2
                 +sizeof tmmr.stack3;       //92-12-18 SZ
            p=tmmr.temp_rem_area;
            count=(sizeof tmmr.temp_rem_area)+(sizeof tmmr.rem_area);
            }
        }

    writefile(tmmr_rem,distance,(LPSTR)p,count);


}

/*******************************************************
writefile(): write file in disk
********************************************************/
int WINAPI writefile(file_n,distance,p,count)
BYTE *file_n;
LONG distance;
LPSTR p;                                   //WORD *p;
int count;
{
    int hd;
    int write_c;

    hd=OpenFile(file_n,&open_tmmr,OF_WRITE);
    if (hd==-1) return(STC);

    _llseek(hd,distance,0);
    write_c=_lwrite(hd,(LPSTR)p,count);
    if (write_c!=count)
    {
       _lclose(hd);
       return(STC);
    }
    hd=_lclose(hd);
    return(CLC);
}

/***************************************************************
look_for_code(): search if the code is in the index
****************************************************************/
int WINAPI look_for_code()
{
    int i,rec_cnt;

    rec_cnt=0;
    for (i=0x10; i<(mulu_true_length+0x10); i=i+mulu_record_length){
        if (if_code_equ(i))
            return(rec_cnt+1);   //find the code, rec_cnt+1 in order to avoid
        else                     //confusing with STC
            rec_cnt++;
        }
    return(STC);                 // not found

}


/**************************************************************
read_data(): read the record correspond to the code
***************************************************************/
int WINAPI read_data(rec_cnt)
int rec_cnt;
{
    int hd;
    int op_count;

    hd=OpenFile(user_lib,&open_user, OF_READ);
    if (hd==-1)
        return(FALSE);
    _llseek(hd,(data_start+rec_cnt*data_record_length), 0);
    op_count=_lread(hd,(LPSTR)&out_svw,data_record_length);
    if (op_count!=data_record_length)
    {
        _lclose(hd);
        return(FALSE);
    }
    _lclose(hd);

    if (out_svw[0]<2)
        return(STC);
    if ((out_svw[0]-0x30)>30)
        return(STC);

    return(CLC);

}

int WINAPI UpdateProc()
{


         UpdateFlag=1;
         ExeCmdLine[ParaPos]='7';
         WinExec(ExeCmdLine,SW_SHOW);
         return(0);

}


/***********************************************
rem_pd1()
************************************************/
int WINAPI rem_pd1(buffer)
WORD *buffer;
{
    WORD temp;                     

    temp=buffer[0];                 

    if (wp.bx_stack[wp.xsyjs])
        temp|=0x4000;           
    else
        if (wp.cmp_stack[wp.xsyjs]==4)
            return(0);

    push_down_stack1();

    tmmr.stack1[0]=temp;            
    return(0);

}

/**********************************************
push_down_stack1()
***********************************************/
int WINAPI push_down_stack1()
{
    int i;

    i=(sizeof tmmr.stack1-2);                 

    CopyMemory/*memmove*/((BYTE *)&tmmr.stack1[1],(BYTE *)&tmmr.stack1[0],i);
    stack1_move_counter++;
    if (stack1_move_counter>=4)
        writefile(tmmr_rem, 0l, (LPSTR)&tmmr.stack1, sizeof tmmr.stack1);
    return(0);

}

/***********************************************
rem_pd2()
************************************************/
void WINAPI rem_pd2(buffer)
WORD *buffer;
{

    WORD temp1,temp2;                       

    int i;

    temp1=buffer[0], temp2=buffer[1];       

    if (wp.cmp_stack[wp.xsyjs]!=2)
        temp1|=0x4000;                   
    if (wp.cmp_stack[wp.xsyjs+1]!=2)
        temp2|=0x4000;                   

    i=(sizeof tmmr.stack2-4-4);       
    CopyMemory/*memmove*/((BYTE *)&tmmr.stack2[2],(BYTE *)&tmmr.stack2[0],i);
    tmmr.stack2[0]=temp1;                    
    tmmr.stack2[1]=temp2;                    
    writefile(tmmr_rem, (LONG)sizeof tmmr.stack1,
                (LPSTR)&tmmr.stack2, sizeof tmmr.stack2);


}

/***********************************************
rem_pd3()
************************************************/
void WINAPI rem_pd3(buffer)
WORD *buffer;
{
    int i;
    i=(sizeof tmmr.stack3-6);                       
    CopyMemory/*memmove*/((BYTE *)&tmmr.stack3[3],(BYTE *)&tmmr.stack3[0],i);
    for (i=0; i<3; i++)
    tmmr.stack3[i]=buffer[i];
    writefile(tmmr_rem, (LONG)(sizeof tmmr.stack1+sizeof tmmr.stack2),
                (LPSTR)&tmmr.stack3, sizeof tmmr.stack3);

}

//this module is come from ABCWIN.EXE
BOOL CALLBACK ImeAboutDlgProc(hDlg, message, wParam, lParam)
HWND hDlg;                            /* window handle of the dialog box */
UINT message;                         /* type of message                 */
WPARAM  wParam;                       /* message-specific information    */
LPARAM  lParam;
{
    RECT rc;
    LONG DlgWidth, DlgHeight;

    switch (message) {
    case WM_INITDIALOG:                /* message: initialize dialog box */
        hCrtDlg = hDlg;            
        CenterWindow(hDlg);

    return (TRUE);          // don't want to set focus to special control

    case WM_CLOSE:
        EndDialog(hDlg, TRUE);  
        return (TRUE);

    case WM_PAINT:
        {
        RECT Rect;
        HDC hDC;  
        PAINTSTRUCT ps;

        GetClientRect(hDlg, &Rect);         //get the whole window area
        InvalidateRect(hDlg, &Rect, 1);
        hDC=BeginPaint(hDlg, &ps);


       // FillRect(hDC, &Rect, GetStockObject(LTGRAY_BRUSH)); //paint the whole area
        Rect.left+=10;//5;
        Rect.top+=8;//5;
        Rect.right-=10;//5;
        Rect.bottom-=40;//5;

        DrawEdge(hDC, &Rect, EDGE_RAISED,/*EDGE_SUNKEN,*/ BF_RECT);

        //FrameRect(hDC, &Rect, GetStockObject(WHITE_BRUSH)); //draw the frame
        EndPaint(hDlg, &ps);


        break;      
        }
    case WM_COMMAND:
    switch (wParam) {
    case IDOK:
        EndDialog(hDlg, FALSE);
        break;
    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        break;
    default:
        return (FALSE);
        break;
    }
    return (TRUE);
    }
    return (FALSE);                           /* Didn't process a message    */
}

int CommandProc(WPARAM wParam,HWND hWnd)
 
{

    lpImeL->TempUIWnd = hWnd;
    switch(wParam){
        case IDM_SKL1:
        case IDM_SKL2:
        case IDM_SKL3:
        case IDM_SKL4:
        case IDM_SKL5:
        case IDM_SKL6:
        case IDM_SKL7:
        case IDM_SKL8:
        case IDM_SKL9:
        case IDM_SKL10:
        case IDM_SKL11:
        case IDM_SKL12:
        case IDM_SKL13:
        {
            HIMC           hIMC;
            LPINPUTCONTEXT lpIMC;
            LPPRIVCONTEXT  lpImcP;
            DWORD          fdwConversion;

            hIMC =(HIMC)GetWindowLongPtr(GetWindow(hWnd,GW_OWNER),IMMGWLP_IMC);
            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {          
               return (0L);
            }

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
            if (!lpImcP) {
               return (0L);
            }

            {
                UINT i;

                lpImeL->dwSKWant = LOWORD(wParam) - IDM_SKL1;
                lpImeL->dwSKState[lpImeL->dwSKWant] = 
                lpImeL->dwSKState[lpImeL->dwSKWant]^1;
            
                // clear other SK State
                for(i=0; i<NumsSK; i++) {
                    if(i == lpImeL->dwSKWant) continue;
                    lpImeL->dwSKState[i] = 0;
                }

                if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
                    if(LOWORD(wParam) == IDM_SKL1)
                        lpImcP->iImeState = CST_INIT;
                    else
                        lpImcP->iImeState = CST_SOFTKB;
                    fdwConversion = lpIMC->fdwConversion | IME_CMODE_SOFTKBD;
                } else {
                    lpImcP->iImeState = CST_INIT;
                    fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_SOFTKBD);
                }
                
            }
            ImmSetConversionStatus(hIMC, (fdwConversion & ~(IME_CMODE_SOFTKBD)),
            lpIMC->fdwSentence);
            ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);

            ImmUnlockIMCC(lpIMC->hPrivate);
            ImmUnlockIMC(hIMC);
            break;
        }


        case SC_METHOD0:
            break;
        case SC_METHOD9:
            DoPropertySheet(GetActiveWindow(),hWnd);
            ReInitIme( hWnd , lpImeL->wImeStyle );

            break;
        case SC_METHOD4:

            WinExec("ABCWM.exe", SW_SHOW); 
            break;

        case SC_METHOD6:
            return 0; // 4.20 94

        case SC_METHOD7:
            WinHelp(hWnd,"winabc.hlp", HELP_FINDER ,0l);
            return 0;
        case SC_METHOD8:
            MessageBeep(0);
            return 0;

        case SC_METHOD10:
            {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;
                HWND hUIWnd;

                hUIWnd = GetWindow(hWnd, GW_OWNER);

                if (!hUIWnd) {
                    return (0L);
                }

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {          
                    return (0L);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          
                    return (0L);
                }

                DialogBox(hInst,"wfc", lpIMC->hWnd, OpenDlg);

                ImmUnlockIMC(hIMC);
                break;
            }

        case SC_METHODA:
            return(0);

        case SC_ABOUT:
            {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;
                HWND hUIWnd;

                hUIWnd = GetWindow(hWnd, GW_OWNER);

                if (!hUIWnd) {
                    return (0L);
                }

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {          
                    return (0L);
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {         
                    return (0L);
                }

                DialogBox(hInst, "ABOUT",lpIMC->hWnd,(DLGPROC)ImeAboutDlgProc);

                ImmUnlockIMC(hIMC);
                break;
            }

        default:
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abc95ui.c ===
/*************************************************
 *  abc95ui.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


#include <windows.h>                                                      
#include <winerror.h>
#include <winuser.h> 
#include <windowsx.h>
#include <immdev.h>
#include <stdio.h>
#include <shlobj.h>

#include "abc95def.h"
#include "resource.h"
#include "resrc1.h"
#include "data.H"


#define IME_CMODE_SDA 0x80000000
HWND  hCrtDlg = NULL;

LONG  lLock = 0;   // this var is for Lock and unLock.
 
void PASCAL ReInitIme2(HWND ,WORD);

// Get the current user's EMB file path, and IME's MB path
// fill global variable sImeG.szIMEUserPath

void GetCurrentUserEMBPath(  )
{


    TCHAR   szModuleName[MAX_PATH], *lpszStart, *lpszDot;
    int     i;

    // Get the path for MB and EMB

 
    GetModuleFileName(hInst, szModuleName, sizeof(szModuleName)/sizeof(TCHAR) );
   
    lpszStart = szModuleName + lstrlen(szModuleName) - 1;

    while ( (lpszStart != szModuleName) && ( *lpszStart != TEXT('\\') ) ) {
          
          if ( *lpszStart == TEXT('.') ) {
             lpszDot = lpszStart;
             *lpszDot = TEXT('\0');
          }

          lpszStart --;
    }

    if ( *lpszStart == TEXT('\\') ) {
         lpszStart ++;
    }

    if ( lpszStart != szModuleName ) {
       for (i=0; i<lstrlen(lpszStart); i++) 
           szModuleName[i] = lpszStart[i];

       szModuleName[i] = TEXT('\0');
    }


    SHGetSpecialFolderPath(NULL,sImeG.szIMEUserPath,CSIDL_APPDATA, FALSE);

    if ( sImeG.szIMEUserPath[lstrlen(sImeG.szIMEUserPath)-1] == TEXT('\\') )
         sImeG.szIMEUserPath[lstrlen(sImeG.szIMEUserPath) - 1] = TEXT('\0');

    // Because CreateDirectory( ) cannot create directory like \AA\BB, 
    // if AA and BB both do not exist. It can create only one layer of 
    // directory each time. so we must call twice CreateDirectory( ) for 
    // \AA\BB

    lstrcat(sImeG.szIMEUserPath, TEXT("\\Microsoft") );

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY) 
       CreateDirectory(sImeG.szIMEUserPath, NULL);

    lstrcat(sImeG.szIMEUserPath, TEXT("\\IME") );

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
       CreateDirectory(sImeG.szIMEUserPath, NULL);

    lstrcat(sImeG.szIMEUserPath, TEXT("\\") );
    lstrcat(sImeG.szIMEUserPath, szModuleName);
    
    //
    // Create the directory, so that CreateFile( ) can work fine later. 
    // ortherwise, if the directory does not exist, and you try to create 
    // a file under that dir,  CreateFile will return error.
    //

    if ( GetFileAttributes(sImeG.szIMEUserPath) != FILE_ATTRIBUTE_DIRECTORY)
        CreateDirectory(sImeG.szIMEUserPath, NULL);


    return;
}


//**************************************************************************
//* Name        :                                                          *
//*     void DrawConvexRect()                                              *
//* Description :                                                          *
//*     draw a convex rectangle                                            *
//* Parameters  :                                                          *
//*     hDC - the handle of DC be drawed                                   *
//*              (x1,y1)                                                   *
//*               +------------+                                           *
//*               |+----1----> |                                           *
//*               ||2      x2-2|                                           *
//*               |Vy2-2       |                                           *
//*               |            |                                           *
//*               +------------+                                           *
//*                          (x2,y2)                                       *
//* Return Value:                                                          *
//*     none                                                               *
//**************************************************************************
void DrawConvexRect(
    HDC hDC,
    int x1,
    int y1,
    int x2,
    int y2)
{
// draw the most outer color =light gray and black  

    SelectObject(hDC,sImeG.LightGrayPen);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2-1, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2-1);

    SelectObject(hDC,sImeG.BlackPen);               //GetStockObject(BLACK_PEN));
    MoveToEx(hDC, x1, y2,NULL);
    LineTo(hDC, x2+1, y2);
    MoveToEx(hDC, x2, y1,NULL);
    LineTo(hDC, x2, y2);

 
// draw the second line color = white and grary 
    SelectObject(hDC, sImeG.WhitePen);                 //GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1+1, y1+1,NULL);
    LineTo(hDC, x2-1, y1+1);
    MoveToEx(hDC, x1+1, y1+1,NULL);
    LineTo(hDC, x1+1, y2-1);
        
    
    SelectObject(hDC,sImeG.GrayPen);
    MoveToEx(hDC, x1+1, y2-1,NULL);
    LineTo(hDC, x2, y2-1);
    MoveToEx(hDC, x2-1, y1+1,NULL);
    LineTo(hDC, x2-1, y2-1);


// draw the fourth line color = gray and white

    SelectObject(hDC,sImeG.GrayPen);                  // CreatePen(PS_SOLID, 1, 0x00808080));
    MoveToEx(hDC, x1+3, y1+3,NULL);
    LineTo(hDC, x2-3, y1+3);
    MoveToEx(hDC, x1+3, y1+3,NULL);
    LineTo(hDC, x1+3, y2-3);

    SelectObject(hDC, sImeG.WhitePen);
    MoveToEx(hDC, x1+3, y2-3,NULL);
    LineTo(hDC, x2-2, y2-3);
    MoveToEx(hDC, x2-3, y1+3,NULL);
    LineTo(hDC, x2-3, y2-3);                              
    
  }

//**************************************************************************
//* Name        :                                                          *
//*     void DrawConcaveRect()                                             *
//* Description :                                                          *
//*     draw a concave rectangle                                           *
//* Parameters  :                                                          *
//*     hDC - the handle of DC be drawed                                   *
//*              (x1,y1)     x2-1                                          *
//*               +-----1----->+                                           *
//*               |            ^ y1+1                                      *
//*               2            |                                           *
//*               |            3                                           *
//*         y2-1  V            |                                           *
//*               <-----4------+                                           *
//*              x1          (x2,y2)                                       *
//* Return Value:                                                          *
//*     none                                                               *
//**************************************************************************
void DrawStatusRect(
    HDC hDC,
    int x1,
    int y1,
    int x2,
    int y2)
{
    SelectObject(hDC,sImeG.LightGrayPen);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2-1, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2-1);

    SelectObject(hDC,sImeG.BlackPen);               //GetStockObject(BLACK_PEN));
    MoveToEx(hDC, x1, y2,NULL);
    LineTo(hDC, x2+1, y2);
    MoveToEx(hDC, x2, y1,NULL);
    LineTo(hDC, x2, y2);

 
// draw the second line color = white and grary 
    SelectObject(hDC, sImeG.WhitePen);                 //GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1+1, y1+1,NULL);
    LineTo(hDC, x2-1, y1+1);
    MoveToEx(hDC, x1+1, y1+1,NULL);
    LineTo(hDC, x1+1, y2-1);
        
    
    SelectObject(hDC,sImeG.GrayPen);
    MoveToEx(hDC, x1+1, y2-1,NULL);
    LineTo(hDC, x2, y2-1);
    MoveToEx(hDC, x2-1, y1+1,NULL);
    LineTo(hDC, x2-1, y2-1);
}


/**********************************************************************/
/* ShowBitmap2()                                                      */
/*   a subprgm for ShowBitmap                                                                             */
/**********************************************************************/


void ShowBitmap2(
    HDC hDC, 
    int x,
    int y,
    int Wi,
    int Hi,
    HBITMAP hBitmap)
{

    HDC hMemDC ;
    HBITMAP  hOldBmp;

    hMemDC = CreateCompatibleDC(hDC);

    if ( hMemDC == NULL )
        return;

    hOldBmp = SelectObject(hMemDC, hBitmap);

    BitBlt(hDC,
           x,
           y,
           Wi,
           Hi,
           hMemDC,
           0, 
           0,
           SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    return ;
}


/**********************************************************************/
/* ShowBitmap()                                                       */
/**********************************************************************/
void ShowBitmap(
        HDC hDC, 
        int x,
        int y,
        int Wi,
        int Hi,
    LPSTR BitmapName)
{
    HBITMAP hBitmap ;

    hBitmap = LoadBitmap(hInst, BitmapName);

    if ( hBitmap )
    {
        ShowBitmap2(hDC, x,y,Wi,Hi,hBitmap);
        DeleteObject(hBitmap);
    }

    return ;
}

/**********************************************************************/
/* CreateUIWindow()                                                   */
/**********************************************************************/
void PASCAL CreateUIWindow(             // create composition window
        HWND hUIWnd)
{
    HGLOBAL hUIPrivate;

    // create storage for UI setting
    hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);

    // set the default position for UI window, it is hide now
    SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

    return;
}


//ui.c    skd #5
/**********************************************************************/
/* ShowSoftKbd                                                        */
/**********************************************************************/
void PASCAL ShowSoftKbd(   // Show the soft keyboard window
    HWND          hUIWnd,
    int           nShowSoftKbdCmd)
{
    HIMC     hIMC;
        LPINPUTCONTEXT  lpIMC;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
        LPPRIVCONTEXT lpImcP;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
        if (!hIMC)
                return;

        lpIMC =(LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC)
                return;

        lpImcP =(LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP){
              ImmUnlockIMC(hIMC);
                        return;
        }


        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL1, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL2, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL3, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL4, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL5, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL6, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL7, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL8, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL9, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL10, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL11, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL12, MF_UNCHECKED);
        CheckMenuItem(lpImeL->hSKMenu, IDM_SKL13, MF_UNCHECKED);

    if (!lpUIPrivate->hSoftKbdWnd) {
        // not in show status window mode
    } else if (lpUIPrivate->nShowSoftKbdCmd != nShowSoftKbdCmd) {
        ImmShowSoftKeyboard(lpUIPrivate->hSoftKbdWnd, nShowSoftKbdCmd);
                if (nShowSoftKbdCmd != SW_HIDE){
                      SendMessage(lpUIPrivate->hSoftKbdWnd,WM_PAINT,0,0l);
                      ReDrawSdaKB(hIMC, lpImeL->dwSKWant,     nShowSoftKbdCmd);
                }
        lpUIPrivate->nShowSoftKbdCmd = nShowSoftKbdCmd;
                lpImcP->nShowSoftKbdCmd = nShowSoftKbdCmd; 

                if(!(lpImcP == NULL)) {
                    if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
                                if(!(lpImeL->hSKMenu)) {
                                        lpImeL->hSKMenu = LoadMenu (hInst, "SKMENU");
                                }

                            CheckMenuItem(lpImeL->hSKMenu,
                                 lpImeL->dwSKWant + IDM_SKL1, MF_CHECKED);

                    }
                }
    } 
    
        ImmUnlockIMCC(lpIMC->hPrivate);
        ImmUnlockIMC(hIMC);

    GlobalUnlock(hUIPrivate);
    return;
}



 /**********************************************************************/
/* ChangeCompositionSize()                                            */
/**********************************************************************/
void PASCAL ChangeCompositionSize(
    HWND   hUIWnd)
{
    HWND            hCompWnd, hCandWnd;
    RECT            rcWnd;
    UINT            nMaxKey;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return;
    }

    GetWindowRect(hCompWnd, &rcWnd);

    if ((rcWnd.right - rcWnd.left) != lpImeL->xCompWi) {
    } else if ((rcWnd.bottom - rcWnd.top) != lpImeL->yCompHi) {
    } else {
        return;
    }

    SetWindowPos(hCompWnd, NULL,
        0, 0, lpImeL->xCompWi, lpImeL->yCompHi,
        SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);

    if (lpImeL->nRevMaxKey >= lpImeL->nMaxKey) {
        nMaxKey = lpImeL->nRevMaxKey;
    } else {
        nMaxKey = lpImeL->nMaxKey;
    }

    SetWindowLong(hCompWnd, UI_MOVE_XY, nMaxKey);

//    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
//        return;
//    }

    hCandWnd = GetCandWnd(hUIWnd);

    if (!hCandWnd) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    CalcCandPos((LPPOINT)&rcWnd);

    ImmUnlockIMC(hIMC);

    SetWindowPos(hCandWnd, NULL,
        rcWnd.left, rcWnd.top,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    return;
}


/**********************************************************************/
/* ShowUI()                                                           */
/**********************************************************************/
void PASCAL ShowUI(             // show the sub windows
    HWND   hUIWnd,
    int    nShowCmd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    if (nShowCmd == SW_HIDE) {
    } else if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
        nShowCmd = SW_HIDE;
    } else {
    }

    if (nShowCmd == SW_HIDE) {
        ShowStatus(
            hUIWnd, nShowCmd);
        ShowComp(
            hUIWnd, nShowCmd);
        ShowCand(
            hUIWnd, nShowCmd);
        ShowSoftKbd(hUIWnd, nShowCmd);
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        goto ShowUIUnlockIMCC;
    }

    if( /*(lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW)&& */
        (lpImcP->fdwImeMsg & MSG_ALREADY_START)
        && (step_mode &1)){
        if (lpUIPrivate->hCompWnd) {
            if ((UINT)GetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY) !=
                lpImeL->nRevMaxKey) {
                ChangeCompositionSize(hUIWnd);
            }

            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
               // RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                 //   RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            SendMessage(lpUIPrivate->hCompWnd, WM_IME_NOTIFY,
                IMN_SETCOMPOSITIONWINDOW, 0);

            if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
                ShowComp(hUIWnd, nShowCmd);
            }
        } else {
            StartComp(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
    } else {
        ShowComp(hUIWnd, SW_HIDE);
    }

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)&&(step_mode == 1)) {
        if (lpUIPrivate->hCandWnd) {
            if (lpUIPrivate->nShowCandCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
                RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            SendMessage(lpUIPrivate->hCandWnd, WM_IME_NOTIFY,
                IMN_SETCANDIDATEPOS, 0x0001);

            if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
                ShowCand(hUIWnd, nShowCmd);
            }
        } else {
            OpenCand(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
    } else {
        ShowCand(hUIWnd, SW_HIDE);
    }

    if (lpIMC->fdwInit & INIT_SENTENCE) {
        // app set the sentence mode so we should not change it
        // with the configure option set by end user
    } else if (lpImeL->fdwModeConfig & MODE_CONFIG_PREDICT) {
        if ((WORD)lpIMC->fdwSentence != IME_SMODE_PHRASEPREDICT) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPUNAWORD)&fdwSentence = IME_SMODE_PHRASEPREDICT;

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    } else {
        if ((WORD)lpIMC->fdwSentence == IME_SMODE_PHRASEPREDICT) {
            DWORD fdwSentence;

            fdwSentence = lpIMC->fdwSentence;
            *(LPUNAWORD)&fdwSentence = IME_SMODE_NONE;

            ImmSetConversionStatus(hIMC, lpIMC->fdwConversion, fdwSentence);
        }
    }

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(hUIWnd);
        }
        if (lpUIPrivate->nShowStatusCmd != SW_HIDE) {
            // some time the WM_NCPAINT is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
        }

        SendMessage(lpUIPrivate->hStatusWnd, WM_IME_NOTIFY,
            IMN_SETSTATUSWINDOWPOS, 0);
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE) {
            ShowStatus(hUIWnd, nShowCmd);
        }
                else     // add for bug 34131, a-zhanw, 1996-4-15
                        ShowStatus(hUIWnd, nShowCmd);
          } else if (lpUIPrivate->hStatusWnd) 
             DestroyWindow(lpUIPrivate->hStatusWnd);

        if (!lpIMC->fOpen) {
                if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                        ShowSoftKbd(hUIWnd, SW_HIDE);
                }
    } else if ((lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) &&
        (lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
                        if (!lpUIPrivate->hSoftKbdWnd) {
                                UpdateSoftKbd(hUIWnd);
                } else if ((UINT)SendMessage(lpUIPrivate->hSoftKbdWnd,
                    WM_IME_CONTROL, IMC_GETSOFTKBDSUBTYPE, 0) !=
                            lpImeL->nReadLayout) {
                                        UpdateSoftKbd(hUIWnd);
                        } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
                                ShowSoftKbd(hUIWnd, nShowCmd);
                        } else if (lpUIPrivate->hIMC != hIMC) {
                                UpdateSoftKbd(hUIWnd);
                        } else {
                                RedrawWindow(lpUIPrivate->hSoftKbdWnd, NULL, NULL,
                                        RDW_FRAME|RDW_INVALIDATE);
                        }
        } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_SOFTKBD;
                ShowSoftKbd(hUIWnd, SW_HIDE);
        } else {
                ShowSoftKbd(hUIWnd, SW_HIDE);
        }

                // we switch to this hIMC
        lpUIPrivate->hIMC = hIMC;

        GlobalUnlock(hUIPrivate);

ShowUIUnlockIMCC:
        ImmUnlockIMCC(lpIMC->hPrivate);
        ImmUnlockIMC(hIMC);

        return;
}





/**********************************************************************/
/* MoveCompCand()                                                           */
/**********************************************************************/
void PASCAL MoveCompCand(             // show the sub windows
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;

        if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC)))
                return;
       
    if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) 
                return ; 
        
    if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
         return ; 
        }


        {
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }


    // composition window need to be destroyed
    if (lpUIPrivate->hCandWnd) {
                if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) 
                        MoveWindow(lpUIPrivate->hCandWnd,
            lpImeL->ptDefCand.x,
                        lpImeL->ptDefCand.y,
            sImeG.xCandWi,
            sImeG.yCandHi,
                        TRUE);
    }

    // candidate window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
   
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START)
                    MoveWindow(
            lpUIPrivate->hCompWnd,
            lpImeL->ptDefComp.x,
                        lpImeL->ptDefComp.y,
            lpImeL->xCompWi,lpImeL->yCompHi,
                        TRUE );
    }

    GlobalUnlock(hUIPrivate);
        }
    
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);
    return;
}

/**********************************************************************/
/* CheckSoftKbdPosition()                                             */
/**********************************************************************/
void PASCAL CheckSoftKbdPosition(
        LPUIPRIV       lpUIPrivate,
    LPINPUTCONTEXT lpIMC)
{
    UINT fPortionBits = 0;
    UINT fPortionTest;
    int  xPortion, yPortion, nPortion;
    RECT rcWnd;

    // portion of dispaly
    // 0  1
    // 2  3

    if (lpUIPrivate->hCompWnd) {
        GetWindowRect(lpUIPrivate->hCompWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    if (lpUIPrivate->hStatusWnd) {
        GetWindowRect(lpUIPrivate->hStatusWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    // start from portion 3
    for (nPortion = 3, fPortionTest = 0x0008; fPortionTest;
        nPortion--, fPortionTest >>= 1) {
        if (fPortionTest & fPortionBits) {
            // someone here!
            continue;
        }

        if (nPortion % 2) {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.right -
                (rcWnd.right - rcWnd.left) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.left;
        }

        if (nPortion / 2) {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.bottom -
                (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.top;
        }

        lpIMC->fdwInit |= INIT_SOFTKBDPOS;

        break;
    }

    return;
}


// sdk #6
/**********************************************************************/
/* SetSoftKbdData()                                                   */
/**********************************************************************/
void PASCAL SetSoftKbdData(
    HWND           hSoftKbdWnd,
    LPINPUTCONTEXT lpIMC)
{
    int         i;
    LPSOFTKBDDATA lpSoftKbdData;
    LPPRIVCONTEXT  lpImcP;

    HGLOBAL hsSoftKbdData;

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
                return;
        }
    
    hsSoftKbdData = GlobalAlloc(GHND, sizeof(SOFTKBDDATA) * 2);
    if (!hsSoftKbdData) {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData = (LPSOFTKBDDATA)GlobalLock(hsSoftKbdData);
    if (!lpSoftKbdData) {         // can not draw soft keyboard window
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData->uCount = 2;

    for (i = 0; i < 48; i++) {
        BYTE bVirtKey;

        bVirtKey = VirtKey48Map[i];

        if (!bVirtKey) {
            continue;
        }

        {
                        WORD CHIByte, CLOByte;

                CHIByte = SKLayout[lpImeL->dwSKWant][i*2] & 0x00ff;
                        CLOByte = SKLayout[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
                lpSoftKbdData->wCode[0][bVirtKey] = (CHIByte << 8) | CLOByte;
                CHIByte = SKLayoutS[lpImeL->dwSKWant][i*2] & 0x00ff;
                        CLOByte = SKLayoutS[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
                lpSoftKbdData->wCode[1][bVirtKey] = (CHIByte << 8) | CLOByte;
                }
    }

    SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDDATA,
        (LPARAM)lpSoftKbdData);

    GlobalUnlock(hsSoftKbdData);

    // free storage for UI settings
    GlobalFree(hsSoftKbdData);
    ImmUnlockIMCC(lpIMC->hPrivate);
    return;
}

//sdk #7
/**********************************************************************/
/* UpdateSoftKbd()                                                    */
/**********************************************************************/
void PASCAL UpdateSoftKbd(
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
        LPPRIVCONTEXT  lpImcP;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP){
                ImmUnlockIMC(hIMC);
                return;
        }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw soft keyboard window
                ImmUnlockIMCC(lpIMC->hPrivate);
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw soft keyboard window
                ImmUnlockIMCC(lpIMC->hPrivate);        
        ImmUnlockIMC(hIMC);
        return;
    }


    if (!(lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (lpUIPrivate->hSoftKbdWnd) {
            ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
            lpImcP->hSoftKbdWnd = NULL;
            lpUIPrivate->hSoftKbdWnd = NULL;
        }

        lpUIPrivate->nShowSoftKbdCmd = SW_HIDE;
        lpImcP->nShowSoftKbdCmd = SW_HIDE;
    } else if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowSoftKbdCmd != SW_HIDE) {
                ShowSoftKbd(hUIWnd, SW_HIDE/*, NULL*/);
        }
    } else {
        if (!lpUIPrivate->hSoftKbdWnd) {
            // create soft keyboard
            lpUIPrivate->hSoftKbdWnd =
                ImmCreateSoftKeyboard(SOFTKEYBOARD_TYPE_C1, hUIWnd,
                0, 0);
                lpImcP->hSoftKbdWnd = lpUIPrivate->hSoftKbdWnd;
        }

        if (!(lpIMC->fdwInit & INIT_SOFTKBDPOS)) {
            CheckSoftKbdPosition(lpUIPrivate, lpIMC);
        }

        SetSoftKbdData(lpUIPrivate->hSoftKbdWnd, lpIMC);
        if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            SetWindowPos(lpUIPrivate->hSoftKbdWnd, NULL,
                lpIMC->ptSoftKbdPos.x, lpIMC->ptSoftKbdPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

            // only show, if the application want to show it
            //if (lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) {      //zst 95/9/28
                ShowSoftKbd(hUIWnd, SW_SHOWNOACTIVATE/*, lpImcP*/);
           // }    zst 95/9/28
        }                                                                                                                 
    
    } 

    GlobalUnlock(hUIPrivate);
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}        

/**********************************************************************/
/* ShowGuideLine                                                      */
/**********************************************************************/
void PASCAL ShowGuideLine(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPGUIDELINE    lpGuideLine;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
        MessageBeep((UINT)-1);
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_WARNING) {
        MessageBeep((UINT)-1);
    } else {
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* StatusWndMsg()                                                     */
/**********************************************************************/
void PASCAL StatusWndMsg(       // set the show hide state and
    HWND        hUIWnd,
    BOOL        fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    HWND     hStatusWnd;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
        if(!hIMC){
            return;
    }
                         
    if (fOn) {
        lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(
                hUIWnd);
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OPEN_STATUS_WINDOW);
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);

    if (!hStatusWnd) {
        return;
    }

    if (!fOn) {
        register DWORD fdwSetContext;

/*
        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOW_SOFTKBD|ISC_HIDE_SOFTKBD);

        if (fdwSetContext == ISC_HIDE_SOFTKBD) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }

        ShowStatus(
            hUIWnd, SW_HIDE);
*/
        ShowComp(hUIWnd, SW_HIDE);
        ShowCand(hUIWnd, SW_HIDE);
//        ShowSoftKbd(hUIWnd, SW_HIDE);
        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOW_SOFTKBD|ISC_HIDE_SOFTKBD);

        if (fdwSetContext == ISC_HIDE_SOFTKBD) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
            ShowSoftKbd(hUIWnd, SW_HIDE);
        }

        ShowStatus(hUIWnd, SW_HIDE);
    } else if (hIMC) {
        ShowStatus(
            hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowStatus(
            hUIWnd, SW_HIDE);
    }

    return;
}


/**********************************************************************/
/* NotifyUI()                                                         */
/**********************************************************************/
void PASCAL NotifyUI(
    HWND   hUIWnd,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hStatusWnd;

    switch (wParam) {
    case IMN_OPENSTATUSWINDOW:
        StatusWndMsg(hUIWnd, TRUE);
        break;
    case IMN_CLOSESTATUSWINDOW:
        StatusWndMsg(hUIWnd, FALSE);
        break;
    case IMN_OPENCANDIDATE:
        if (lParam & 0x00000001) {
            OpenCand(hUIWnd);
        }
        break;
    case IMN_CHANGECANDIDATE:
        if (lParam & 0x00000001) {
            HWND hCandWnd;
            HDC  hDC;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }
            hDC = GetDC(hCandWnd);
            UpdateCandWindow2(hCandWnd, hDC);
            ReleaseDC(hCandWnd, hDC);
        }
        break;
    case IMN_CLOSECANDIDATE:
        if (lParam & 0x00000001) {
            CloseCand(hUIWnd);
        }
        break;
    case IMN_SETSENTENCEMODE:
        break;
    case IMN_SETCONVERSIONMODE:
    case IMN_SETOPENSTATUS:
        hStatusWnd = GetStatusWnd(hUIWnd);

        if (hStatusWnd) {
            InvalidateRect(hStatusWnd, &sImeG.rcStatusText, FALSE);
            UpdateWindow(hStatusWnd);
        }
        break;
    case IMN_SETCOMPOSITIONFONT:
        // we are not going to change font, but an IME can do this if it want
        break;
    case IMN_SETCOMPOSITIONWINDOW:
        SetCompWindow(hUIWnd);
        break;
    case IMN_SETSTATUSWINDOWPOS:
       // SetStatusWindowPos(hUIWnd);
                SetStatusWindowPos(GetStatusWnd(hUIWnd));
        break;
    case IMN_GUIDELINE:
        ShowGuideLine(hUIWnd);
        break;
    case IMN_PRIVATE:
        switch (lParam) {
        case IMN_PRIVATE_UPDATE_SOFTKBD:
            UpdateSoftKbd(hUIWnd);
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    return;
}

/**********************************************************************/
/* SetContext()                                                       */
/**********************************************************************/
void PASCAL SetContext(         // the context activated/deactivated
    HWND   hUIWnd,
    BOOL   fOn,
    LPARAM lShowUI)
{
    HGLOBAL  hUIPrivate;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (fOn) {
        HIMC           hIMC;
        LPINPUTCONTEXT lpIMC;

           if(!sImeG.Prop) 
                  InitUserSetting();
                ReInitIme2(lpUIPrivate->hStatusWnd, lpImeL->wImeStyle);

        lpUIPrivate->fdwSetContext = (lpUIPrivate->fdwSetContext &
            ~ISC_SHOWUIALL) | ((DWORD)lShowUI & ISC_SHOWUIALL) | ISC_SHOW_SOFTKBD;

        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

        if (!hIMC) {
            goto SetCxtUnlockUIPriv;
        }

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);

        if (!lpIMC) {
            goto SetCxtUnlockUIPriv;
        }

        if (lpIMC->cfCandForm[0].dwIndex != 0) {
            lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
        }

        ImmUnlockIMC(hIMC);
    } else {
        lpUIPrivate->fdwSetContext &= ~ISC_SETCONTEXT_UI;
    }

        if(fOn){
        BOOL x;
        HIMC hIMC;
        LPINPUTCONTEXT lpIMC;
        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

        if (!hIMC) {
                goto SetCxtUnlockUIPriv;
                }

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                 
                if (!lpIMC)
                        goto   SetCxtUnlockUIPriv;
                
                x = GetKeyState(VK_CAPITAL)&1;
                if(!x && (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION)){
                        lpIMC->fdwConversion = lpIMC->fdwConversion & (~IME_CMODE_NOCONVERSION)|IME_CMODE_NATIVE;
                }
                if(x && (lpIMC->fdwConversion & IME_CMODE_NATIVE)){
                        lpIMC->fdwConversion = lpIMC->fdwConversion & (~IME_CMODE_NATIVE) |(IME_CMODE_NOCONVERSION);
                        InitCvtPara();
                }
                //lpIMC->fdwConversion = IME_CMODE_NOCONVERSION;
                ImmUnlockIMC(hIMC);
                        
        }

SetCxtUnlockUIPriv:
    GlobalUnlock(hUIPrivate);

        UIPaint(hUIWnd);
   // PostMessage(hUIWnd, WM_PAINT, 0, 0);  //zl3
    
    return;
}



/**********************************************************************/
/* GetConversionMode()                                                */
/* Return Value :                                                     */
/*      the conversion mode                                           */
/**********************************************************************/
LRESULT PASCAL GetConversionMode(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    DWORD          fdwConversion;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (LRESULT)NULL;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (LRESULT)NULL;
    }

    fdwConversion = lpIMC->fdwConversion;

    ImmUnlockIMC(hIMC);

    return (LRESULT)fdwConversion;
}

/**********************************************************************/
/* SetConversionMode()                                                */
/* Return Value :                                                     */
/*      NULL - successful, else - failure                             */
/**********************************************************************/
LRESULT PASCAL SetConversionMode(       // set conversion mode
    HWND  hUIWnd,
    DWORD dwNewConvMode)
{
    HIMC  hIMC;
    DWORD dwOldConvMode, fdwOldSentence;
    
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    if (!ImmGetConversionStatus(hIMC, &dwOldConvMode, &fdwOldSentence))
        return (LRESULT)(1L);
    return (LRESULT)!ImmSetConversionStatus(hIMC, dwNewConvMode,
        fdwOldSentence);
}

/**********************************************************************/
/* GetSentenceMode()                                                  */
/* Return Value :                                                     */
/*      the sentence mode                                             */
/**********************************************************************/
LRESULT PASCAL GetSentenceMode(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    DWORD          fdwSentence;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (LRESULT)NULL;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (LRESULT)NULL;
    }

    fdwSentence = lpIMC->fdwSentence;

    ImmUnlockIMC(hIMC);

    return (LRESULT)fdwSentence;
}

/**********************************************************************/
/* SetSentenceMode()                                                  */
/* Return Value :                                                     */
/*      NULL - successful, else - failure                             */
/**********************************************************************/
LRESULT PASCAL SetSentenceMode( // set the sentence mode
    HWND  hUIWnd,
    DWORD dwNewSentence)
{
    HIMC  hIMC;
    DWORD dwOldConvMode, fdwOldSentence;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    if (!ImmGetConversionStatus(hIMC, &dwOldConvMode, &fdwOldSentence)) {
        return (LRESULT)(1L);
    }

    return (LRESULT)!ImmSetConversionStatus(hIMC, dwOldConvMode,
        dwNewSentence);
}

/**********************************************************************/
/* GetOpenStatus()                                                    */
/* Return Value :                                                     */
/*      the open status                                               */
/**********************************************************************/
LRESULT PASCAL GetOpenStatus(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    BOOL           fOpen;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (LRESULT)NULL;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (LRESULT)NULL;
    }

    fOpen = (BOOL)lpIMC->fOpen;

    ImmUnlockIMC(hIMC);

    return (LRESULT)fOpen;
}

/**********************************************************************/
/* SetOpenStatus()                                                    */
/* Return Value :                                                     */
/*      NULL - successful, else - failure                             */
/**********************************************************************/
LRESULT PASCAL SetOpenStatus(   // set open/close status
    HWND  hUIWnd,
    BOOL  fNewOpenStatus)
{
    HIMC           hIMC;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }
    return (LRESULT)!ImmSetOpenStatus(hIMC, fNewOpenStatus);
}

/**********************************************************************/
/* SetCompFont()                                                      */
/**********************************************************************/
LRESULT PASCAL SetCompFont(
    HWND      hUIWnd,
    LPLOGFONT lplfFont)
{
    HIMC           hIMC;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    return (LRESULT)!ImmSetCompositionFont(hIMC, lplfFont);
}

/**********************************************************************/
/* GetCompWindow()                                                    */
/**********************************************************************/
LRESULT PASCAL GetCompWindow(
    HWND              hUIWnd,
    LPCOMPOSITIONFORM lpCompForm)
{
    HWND hCompWnd;
    RECT rcCompWnd;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCompWnd, &rcCompWnd)) {
        return (1L);
    }

    lpCompForm->dwStyle = CFS_POINT|CFS_RECT;
    lpCompForm->ptCurrentPos = *(LPPOINT)&rcCompWnd;
    lpCompForm->rcArea = rcCompWnd;

    return (0L);
}

/**********************************************************************/
/* SelectIME()                                                        */
/**********************************************************************/
void PASCAL SelectIME(          // switch IMEs
    HWND hUIWnd,
    BOOL fSelect)
{
    if (!fSelect) {
        ShowUI(hUIWnd, SW_HIDE);
    } else {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;
                
                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {
                    MessageBeep((UINT)-1);
                        return;
                }

            if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
                    MessageBeep((UINT)-1);
                        return;
                }

                if(GetKeyState(VK_CAPITAL)&1){
                        lpIMC->fdwConversion |= IME_CMODE_NOCONVERSION;
                        lpIMC->fdwConversion &= ~IME_CMODE_NATIVE; 
                        cap_mode = 1;   
                }else{
                        lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                        lpIMC->fdwConversion &= ~IME_CMODE_NOCONVERSION;       
                        cap_mode = 0;   
                }

                ImmUnlockIMC(hIMC);

        UpdateSoftKbd(hUIWnd);
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    }

    return;
}

 /**********************************************************************/
/* ToggleUI()                                                         */
/**********************************************************************/
/*
void PASCAL ToggleUI(
    HWND   hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    DWORD          fdwFlag;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HWND           hDestroyWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    //if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
      //  if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
     //       goto ToggleUIOvr;
     //   } else {
     //       fdwFlag = 0;
     //   }
    //} else {
    //    if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
    //        fdwFlag = ISC_OFF_CARET_UI;
    //    } else {
    //        goto ToggleUIOvr;
    //    }
    //}

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto ToggleUIOvr;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto ToggleUIOvr;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto CreateUIOvr;
    }

    if (fdwFlag & ISC_OFF_CARET_UI) {
        lpUIPrivate->fdwSetContext |= (ISC_OFF_CARET_UI);
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OFF_CARET_UI);
    }

    hDestroyWnd = NULL;

    // we need to dsetroy status first because lpUIPrivate->hStatusWnd
    // may be NULL out in OffCreat UI destroy time
    if (lpUIPrivate->hStatusWnd) {
        if (lpUIPrivate->hStatusWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hStatusWnd;
            DestroyWindow(lpUIPrivate->hStatusWnd);
        }
        lpUIPrivate->hStatusWnd = NULL;
    }

    // destroy all off caret UI
    if (lpUIPrivate->hCompWnd) {
        if (lpUIPrivate->hCompWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hCompWnd;
            DestroyWindow(lpUIPrivate->hCompWnd);
        }
        lpUIPrivate->hCompWnd = NULL;
        lpUIPrivate->nShowCompCmd = SW_HIDE;
    }

    if (lpUIPrivate->hCandWnd) {
        if (lpUIPrivate->hCandWnd != hDestroyWnd) {
            hDestroyWnd = lpUIPrivate->hCandWnd;
            DestroyWindow(lpUIPrivate->hCandWnd);
        }
        lpUIPrivate->hCandWnd = NULL;
        lpUIPrivate->nShowCandCmd = SW_HIDE;
    }

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
                OpenStatus(hUIWnd);
    }

    if (!(lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW)) {
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        StartComp(hUIWnd);
    } else {
    }

    if (!(lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW)) {
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        if (!(fdwFlag & ISC_OFF_CARET_UI)) {
            NotifyIME(hIMC, NI_SETCANDIDATE_PAGESIZE, 0, CANDPERPAGE);
        }

        OpenCand(hUIWnd);

    } else {
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

CreateUIOvr:
    ImmUnlockIMC(hIMC);

ToggleUIOvr:
    GlobalUnlock(hUIPrivate);
    return;
}

*/
/**********************************************************************/
/* UIPaint()                                                          */
/**********************************************************************/
LRESULT PASCAL UIPaint(
    HWND        hUIWnd)
{
    PAINTSTRUCT ps;
    MSG         sMsg;
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;

    // for safety
    BeginPaint(hUIWnd, &ps);
    EndPaint(hUIWnd, &ps);

    // some application will not remove the WM_PAINT messages
    PeekMessage(&sMsg, hUIWnd, WM_PAINT, WM_PAINT, PM_REMOVE|PM_NOYIELD);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (0L);
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return (0L);
    }

    if (lpUIPrivate->fdwSetContext & ISC_SHOW_UI_ALL) {   //ZL1
    //if (lpUIPrivate->fdwSetContext & ISC_SETCONTEXT_UI) { 
                /*
        if (lpUIPrivate->fdwSetContext & ISC_OFF_CARET_UI) {
            
            if (!(lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI)){
                ToggleUI(hUIWnd);
            }
        } else {
            if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
                ToggleUI(hUIWnd);
            }
        }
                */
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowUI(hUIWnd, SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);

    return (0L);
}



/**********************************************************************/
/* UIWndProc()                                                        */
/**********************************************************************/
LRESULT CALLBACK UIWndProc(             // maybe not good but this UI
                                        // window also is composition window
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
        lpImeL->TempUIWnd = hUIWnd ;
    switch (uMsg) {
    
    case WM_NEW_WORD:
//              DefNewNow = 0;
                UpdateUser();
                break;

    case WM_CREATE:
        CreateUIWindow(hUIWnd);
        break;
    case WM_DESTROY:
        DestroyUIWindow(hUIWnd);
        break;
    case WM_IME_STARTCOMPOSITION:
        // you can create a window as the composition window here
        StartComp(hUIWnd);
                if (lParam==0x6699)
                show_char(NULL,0);
        break;
    case WM_IME_COMPOSITION:
        if (lParam & GCS_RESULTSTR) {
            MoveDefaultCompPosition(hUIWnd);
        }
        UpdateCompWindow(hUIWnd);
        break;
    case WM_IME_ENDCOMPOSITION:
        // you can destroy the composition window here
        EndComp(hUIWnd);
        break;
    case WM_IME_NOTIFY:
        NotifyUI(hUIWnd, wParam, lParam);
        break;
    case WM_IME_SETCONTEXT:
        SetContext(hUIWnd, (BOOL)wParam, lParam);
        break;
    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_SETCONVERSIONMODE:
            return SetConversionMode(hUIWnd, (DWORD)lParam);
        case IMC_SETSENTENCEMODE:
            return SetSentenceMode(hUIWnd, (DWORD)lParam);
        case IMC_SETOPENSTATUS:
            return SetOpenStatus(hUIWnd, (BOOL)lParam);
        case IMC_GETCANDIDATEPOS:
          return GetCandPos(hUIWnd,(LPCANDIDATEFORM)lParam);
            return (1L);                    // not implemented yet
        case IMC_SETCANDIDATEPOS:
            return SetCandPosition(hUIWnd, (LPCANDIDATEFORM)lParam);
        case IMC_GETCOMPOSITIONFONT:
            return (1L);                    // not implemented yet
        case IMC_SETCOMPOSITIONFONT:
            return SetCompFont(hUIWnd, (LPLOGFONT)lParam);
        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompWindow(hUIWnd, (LPCOMPOSITIONFORM)lParam);
        case IMC_SETCOMPOSITIONWINDOW:
            {
                HIMC            hIMC;

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {
                    return (1L);
                }

                return (LRESULT)!ImmSetCompositionWindow(hIMC,
                    (LPCOMPOSITIONFORM)lParam);
            }
            return (1L);
        case IMC_GETSTATUSWINDOWPOS:
            {
                HWND   hStatusWnd;
                RECT   rcStatusWnd;
                LPARAM lParam;

                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd) {
                    return (0L);    // fail, return (0, 0)?
                }

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd)) {
                     return (0L);    // fail, return (0, 0)?
                }

                lParam = MAKELRESULT(rcStatusWnd.left, rcStatusWnd.right);

                return (lParam);
            }
            return (0L);
        case IMC_SETSTATUSWINDOWPOS:
            {
                HIMC  hIMC;
                POINT ptPos;

                ptPos.x = ((LPPOINTS)&lParam)->x;
                ptPos.y = ((LPPOINTS)&lParam)->y;

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {
                    return (1L);
                }

                return ImmSetStatusWindowPos(hIMC, &ptPos);
            }
            return (1L);
        default:
            return (1L);
        }
        break;
    case WM_IME_COMPOSITIONFULL:
        return (0L);
    case WM_IME_SELECT:
        SelectIME(hUIWnd, (BOOL)wParam);
        return (0L);
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_PAINT:
            UIPaint(hUIWnd);
        return 0L;    //ZL2
    default:
        return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }
    return (0L);
}

/**********************************************************************/
/* DrawFrameBorder()                                                  */
/**********************************************************************/
void PASCAL DrawFrameBorder(    // border of IME
    HDC  hDC,
    HWND hWnd)                  // window of IME
{
    RECT rcWnd;
    int  xWi, yHi;

    GetWindowRect(hWnd, &rcWnd);

    xWi = rcWnd.right - rcWnd.left;
    yHi = rcWnd.bottom - rcWnd.top;

    // 1, ->
    PatBlt(hDC, 0, 0, xWi, 1, WHITENESS);

    // 1, v
    PatBlt(hDC, 0, 0, 1, yHi, WHITENESS);

    // 1, _>
    PatBlt(hDC, 0, yHi, xWi, -1, BLACKNESS);

    // 1,  v
    PatBlt(hDC, xWi, 0, -1, yHi, BLACKNESS);

    xWi -= 2;
    yHi -= 2;

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 2, ->
    PatBlt(hDC, 1, 1, xWi, 1, PATCOPY);

    // 2, v
    PatBlt(hDC, 1, 1, 1, yHi, PATCOPY);

    // 2,  v
    PatBlt(hDC, xWi + 1, 1, -1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // 2, _>
    PatBlt(hDC, 1, yHi + 1, xWi, -1, PATCOPY);

    xWi -= 2;
    yHi -= 2;

    // 3, ->
    PatBlt(hDC, 2, 2, xWi, 1, PATCOPY);

    // 3, v
    PatBlt(hDC, 2, 2, 1, yHi, PATCOPY);

    // 3,  v
    PatBlt(hDC, xWi + 2, 3, -1, yHi - 1, WHITENESS);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 3, _>
    PatBlt(hDC, 2, yHi + 2, xWi, -1, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    xWi -= 2;
    yHi -= 2;

    // 4, ->
    PatBlt(hDC, 3, 3, xWi, 1, PATCOPY);

    // 4, v
    PatBlt(hDC, 3, 3, 1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 4,  v
    PatBlt(hDC, xWi + 3, 4, -1, yHi - 1, PATCOPY);

    // 4, _>
    PatBlt(hDC, 3, yHi + 3, xWi, -1, WHITENESS);

    return;
}


/**********************************************************************/
/* GetCompWnd                                                         */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/
HWND PASCAL GetCompWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCompWnd = lpUIPrivate->hCompWnd;

    GlobalUnlock(hUIPrivate);
    return (hCompWnd);
}
 
/**********************************************************************/
/* GetNearCaretPosition()                                             */
/**********************************************************************/
void PASCAL GetNearCaretPosition(   // decide a near caret position according
                                    // to the caret position
    LPPOINT lpptFont,
    UINT    uEsc,
    UINT    uRot,
    LPPOINT lpptCaret,
    LPPOINT lpptNearCaret,
    BOOL    fFlags)
{
    
    LONG lFontSize;
    LONG xWidthUI, yHeightUI, xBorder, yBorder;
        
    if ((uEsc + uRot) & 0x0001) {
        lFontSize = lpptFont->x;
    } else {
        lFontSize = lpptFont->y;
    }

    if (fFlags & NEAR_CARET_CANDIDATE) {
        xWidthUI = sImeG.xCandWi;
        yHeightUI = sImeG.yCandHi;
        xBorder = sImeG.cxCandBorder;
        yBorder = sImeG.cyCandBorder;
    } else {
        xWidthUI = lpImeL->xCompWi;
        yHeightUI = lpImeL->yCompHi;
        xBorder = lpImeL->cxCompBorder;
        yBorder = lpImeL->cyCompBorder;
    }

    if (fFlags & NEAR_CARET_FIRST_TIME) {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

        if (ptInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY;

        if (ptInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    } else {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacX;

        if (ptAltInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacY;

        if (ptAltInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    }

    if (lpptNearCaret->x < sImeG.rcWorkArea.left) {
        lpptNearCaret->x = sImeG.rcWorkArea.left;
    } else if (lpptNearCaret->x + xWidthUI > sImeG.rcWorkArea.right) {
        lpptNearCaret->x = sImeG.rcWorkArea.right - xWidthUI;
    } else {
    }

    if (lpptNearCaret->y < sImeG.rcWorkArea.top) {
        lpptNearCaret->y = sImeG.rcWorkArea.top;
    } else if (lpptNearCaret->y + yHeightUI > sImeG.rcWorkArea.bottom) {
        lpptNearCaret->y = sImeG.rcWorkArea.bottom - yHeightUI;
    } else {
    }

    return;
}

/**********************************************************************/
/* FitInLazyOperation()                                               */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInLazyOperation( // fit in lazy operation or not

    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,      // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{       
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE); 
}         


/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form

    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptNearCaret, ptOldNearCaret, ptCompWnd;
    UINT  uEsc, uRot;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;
        
    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfWidth < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.x = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.x = lpImeL->yCompHi;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.y = ptFont.x;
    }

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        LONG tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        LONG tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;                                                               
    }

    GetNearCaretPosition(

        &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, NEAR_CARET_FIRST_TIME);

    // 1st, use the adjust point
    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    ptCompWnd = ptOldNearCaret = ptNearCaret;

    // OK, no intersect between the near caret position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (CalcCandPos(

        /*lpIMC,*/ &ptCompWnd)) {
        // can not fit the candidate window
    } else if (FitInLazyOperation(

      lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy case
    GetNearCaretPosition(&ptFont, uEsc, uRot, lpptNew, &ptNearCaret, 0);

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    ptCompWnd = ptNearCaret;

    // OK, no intersect between the adjust position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (CalcCandPos(
        /*lpIMC,*/ &ptCompWnd)) {
        // can not fit the candidate window
    } else if (FitInLazyOperation(
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        // happy ending!!!, don't chaqge position
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy ending! :-(
    *lpptOrg = ptOldNearCaret;

    return (TRUE);
}

/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
/*BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptAdjust, ptDelta;
    UINT  uEsc;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;

    ptAdjust.x = lpptNew->x;
    ptAdjust.y = lpptNew->y;

    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth;
    } else if (lpIMC->lfFont.A.lfWidth == 0) {
        ptFont.x = lpImeL->yCompHi;
    } else {
        ptFont.x = -lpIMC->lfFont.A.lfWidth;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfWidth == 0) {
        ptFont.y = lpImeL->yCompHi;
    } else {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    }

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    // find the location after IME do an adjustment
    ptAdjust.x = ptAdjust.x + sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

    ptAdjust.y = ptAdjust.y + ptFont.y * ncUIEsc[uEsc].iLogFontFac +
        sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY - lpImeL->cyCompBorder;

    // Is the current location within tolerance?
    ptDelta.x = lpptOrg->x - ptAdjust.x;
    ptDelta.y = lpptOrg->y - ptAdjust.y;

    ptDelta.x = (ptDelta.x > 0) ? ptDelta.x : -ptDelta.x;
    ptDelta.y = (ptDelta.y > 0) ? ptDelta.y : -ptDelta.y;

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        int tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        int tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    // will it within lazy operation range (tolerance)
    if (ptDelta.x > sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX) {
    } else if (ptDelta.y > sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY) {
    } else if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
        // If there are intersection, we need to fix that
    } else {
        // happy ending!!!, don't chaqge position
        return (FALSE);
    }

    ptAdjust.x -= lpImeL->cxCompBorder;
    ptAdjust.y -= lpImeL->cyCompBorder;

    // lazy guy, move!
    // 1st, use the adjust point
    if (ptAdjust.x < sImeG.rcWorkArea.left) {
        ptAdjust.x = sImeG.rcWorkArea.left;
    } else if (ptAdjust.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
        ptAdjust.x = sImeG.rcWorkArea.right - lpImeL->xCompWi;
    }
    
    if (ptAdjust.y < sImeG.rcWorkArea.top) {
        ptAdjust.y = sImeG.rcWorkArea.top;
    } else if (ptAdjust.y + lpImeL->yCompHi > sImeG.rcWorkArea.bottom) {
        ptAdjust.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi;
    }

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptAdjust.x;
    rcUIRect.top = ptAdjust.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    // OK, no intersect between the adjust position and input char
    if (!IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
        // happy ending!!
        lpptOrg->x = ptAdjust.x;
        lpptOrg->y = ptAdjust.y;
        return (TRUE);
    }

    // unhappy case
    ptAdjust.x = lpptNew->x;
    ptAdjust.y = lpptNew->y;
    ClientToScreen((HWND)lpIMC->hWnd, &ptAdjust);

    // IME do another adjustment
    ptAdjust.x = ptAdjust.x + ptFont.x * ncUIEsc[uEsc].iParaFacX -
        sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX - lpImeL->cxCompBorder;

    ptAdjust.y = ptAdjust.y + ptFont.y * ncUIEsc[uEsc].iLogFontFac -
        sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY - lpImeL->cyCompBorder;

    if (ptAdjust.x < sImeG.rcWorkArea.left) {
        ptAdjust.x = sImeG.rcWorkArea.left;
    } else if (ptAdjust.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
        ptAdjust.x = sImeG.rcWorkArea.right - lpImeL->xCompWi;
    }
    
    if (ptAdjust.y < sImeG.rcWorkArea.top) {
        ptAdjust.y = sImeG.rcWorkArea.top;
    } else if (ptAdjust.y + lpImeL->yCompHi > sImeG.rcWorkArea.bottom) {
        ptAdjust.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi;
    }

    // unhappy ending! :-(
    lpptOrg->x = ptAdjust.x;
    lpptOrg->y = ptAdjust.y;

    return (TRUE);
} */

/**********************************************************************/
/* SetCompPosFix()                                                  */
/**********************************************************************/
void PASCAL SetCompPosFix(    // set the composition window position
    HWND           hCompWnd,
    LPINPUTCONTEXT lpIMC)
{
    POINT    ptWnd;
    BOOL     fChange = FALSE;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // the client coordinate position (0, 0) of composition window
    ptWnd.x = 0;
    ptWnd.y = 0;
    // convert to screen coordinates
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;

     if (ptWnd.x != lpImeL->ptDefComp.x) {
            ptWnd.x = lpImeL->ptDefComp.x;
            fChange = TRUE;
        }
        if (ptWnd.y != lpImeL->ptDefComp.y) {
            ptWnd.y = lpImeL->ptDefComp.y;
            fChange = TRUE;
        }

         if (!fChange )  return; 
         //## 8
    SetWindowPos(hCompWnd, NULL,
        ptWnd.x, ptWnd.y,
        lpImeL->xCompWi, lpImeL->yCompHi, SWP_NOACTIVATE/*|SWP_NOSIZE*/|SWP_NOZORDER);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (!lpUIPrivate->hCandWnd) {
        GlobalUnlock(hUIPrivate);
        return;
    }

    // decide the position of candidate window by UI's position
    
        // ##1
    SetWindowPos(lpUIPrivate->hCandWnd, NULL,
        lpImeL->ptDefCand.x, lpImeL->ptDefCand.y ,
        sImeG.xCandWi,sImeG.yCandHi, SWP_NOACTIVATE|/*SWP_NOSIZE|*/SWP_NOZORDER);

    GlobalUnlock(hUIPrivate);

    return;
}


/**********************************************************************/
/* SetCompPosition()                                                  */
/**********************************************************************/
void PASCAL SetCompPosition(    // set the composition window position
    HWND           hCompWnd,
    LPINPUTCONTEXT lpIMC)
{
    POINT    ptWnd, ptCaret;
    BOOL     fChange = FALSE;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
        HWND     hCandWnd;

   
   
        if (lpImeL->wImeStyle == IME_APRS_FIX){
        SetCompPosFix(hCompWnd, lpIMC);
        return; 
        }

    // the client coordinate position (0, 0) of composition window
    ptWnd.x = 0;
    ptWnd.y = 0;
    // convert to screen coordinates
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;

    if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION) {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }
        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }
        if (fChange) {
            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        }
    } else if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
        // aplication tell us the position, we need to adjust
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        fChange = AdjustCompPosition(lpIMC, &ptWnd, &ptNew);
    } else {
        POINT ptNew;            // new position of UI

        /*ptNew.x = lpIMC->ptStatusWndPos.x + sImeG.xStatusWi + UI_MARGIN;

        if (ptNew.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
            ptNew.x = lpIMC->ptStatusWndPos.x -
                lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                UI_MARGIN;
                        }

        ptNew.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi;// - 2 * UI_MARGIN ;*/
                ptNew.x = lpImeL->ptZLComp.x;
                ptNew.y = lpImeL->ptZLComp.y;
        
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
                }

        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
                }

        if (fChange) {
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
                }
    }

    /*if (GetCaretPos(&ptCaret)) {
        // application don't set position, OK we need to near caret
        ClientToScreen(lpIMC->hWnd, &ptCaret);
        fChange = AdjustCompPosition(lpIMC, &ptWnd, &ptCaret);
    } else {
        // no caret information!
        if (ptWnd.x != lpImeL->ptDefComp.x) {
            ptWnd.x = lpImeL->ptDefComp.y;
            fChange = TRUE;
        }
        if (ptWnd.y != lpImeL->ptDefComp.x) {
            ptWnd.y = lpImeL->ptDefComp.y;
            fChange = TRUE;
        } 
     if (ptWnd.x != lpImeL->ptDefComp.x) {
            ptWnd.x =lpIMC->ptStatusWndPos.x + sImeG.TextLen+8;//lpImeL->ptDefComp.y;
            fChange = TRUE;
        }
        if (ptWnd.y != lpImeL->ptDefComp.x) {
            ptWnd.y =lpIMC->ptStatusWndPos.
         } y ;//lpImeL->ptDefComp.y;
            fChange = TRUE;               
     }  */

        
        if (!(fChange|CandWndChange)) {
        return;
    }
        CandWndChange = 0;
   

        // ##2
        if(TypeOfOutMsg & COMP_NEEDS_END){
                CloseCand(GetWindow(hCompWnd, GW_OWNER));
                EndComp(GetWindow(hCompWnd, GW_OWNER));
                //CloseCand(GetWindow(hCandWnd, GW_OWNER));
                TypeOfOutMsg = TypeOfOutMsg & ~(COMP_NEEDS_END);
    }
   
        SetWindowPos(hCompWnd, NULL,
        ptWnd.x, ptWnd.y,
        lpImeL->xCompWi,lpImeL->yCompHi, SWP_NOACTIVATE/*|SWP_NOSIZE*/|SWP_NOZORDER);
        
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (!lpUIPrivate->hCandWnd) {
        GlobalUnlock(hUIPrivate);
        return;
    }   
   
        // decide the position of candidate window by UI's position
    CalcCandPos(&ptWnd);
        //##3
    SetWindowPos(lpUIPrivate->hCandWnd, NULL,
        ptWnd.x, ptWnd.y,
        sImeG.xCandWi,sImeG.yCandHi , SWP_NOACTIVATE/*|SWP_NOSIZE*/|SWP_NOZORDER);

    GlobalUnlock(hUIPrivate); 

        return;
}

/**********************************************************************/
/* SetCompWindow()                                                    */
/**********************************************************************/
void PASCAL SetCompWindow(              // set the position of composition window
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    SetCompPosition(hCompWnd, lpIMC);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* MoveDefaultCompPosition()                                          */
/**********************************************************************/
void PASCAL MoveDefaultCompPosition(    // the default comp position
                                        // need to near the caret
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

        if (lpImeL->wImeStyle == IME_APRS_FIX ) return ;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION) {
    } else if (!lpIMC->hPrivate) {
    } else {
        LPPRIVCONTEXT lpImcP;

        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

        if (!lpImcP) {
        } else if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS) {
        } else {
            lpImcP->fdwImeMsg |= MSG_IMN_COMPOSITIONPOS;
//                  lpImcP->fdwGcsFlag =lpImcP->fdwGcsFlag &~( GCS_RESULTREAD|GCS_RESULTSTR);
      //  if(sImeG.InbxProc){
                   /* sImeG.InbxProc = 0;*///}
        //      else{   
           // GenerateMessage(hIMC, lpIMC, lpImcP);//}    //CHG4
        }

        ImmUnlockIMCC(lpIMC->hPrivate);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowComp()                                                         */
/**********************************************************************/
void PASCAL ShowComp(           // Show the composition window
    HWND hUIWnd,
    int  nShowCompCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // show or hid the UI window
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (!lpUIPrivate->hCompWnd) {
        // not in show candidate window mode
    } else if (lpUIPrivate->nShowCompCmd != nShowCompCmd) {
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
    } else {
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* StartComp()                                                        */
/**********************************************************************/
void PASCAL StartComp(
    HWND hUIWnd)
{
    HIMC           hIMC;
    HGLOBAL        hUIPrivate;
    LPINPUTCONTEXT lpIMC;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {           // Oh! Oh!
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {          // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // can not draw composition window
        ImmUnlockIMC(hIMC);
        return;
    }
        lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;//zl 95.9.14
    if (!lpUIPrivate->hCompWnd) {
 
        lpUIPrivate->hCompWnd = CreateWindowEx(
           /* WS_EX_CLIENTEDGE|WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME|WS_EX_TOPMOST,*/
                    0,
            szCompClassName, NULL, WS_POPUP|WS_DISABLED,//|WS_BORDER,
            0, 0, lpImeL->xCompWi, lpImeL->yCompHi,
            hUIWnd, (HMENU)NULL, hInst, NULL);


        if ( lpUIPrivate->hCompWnd != NULL ) 
        {
            SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_OFFSET,
                WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY, 0L);
        }
    }

    // try to set the position of composition UI window near the caret
    SetCompPosition(lpUIPrivate->hCompWnd, lpIMC);

    ImmUnlockIMC(hIMC);

    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* EndComp()                                                          */
/**********************************************************************/
void PASCAL EndComp(
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    // hide the composition window
    ShowWindow(lpUIPrivate->hCompWnd, SW_HIDE);
    lpUIPrivate->nShowCompCmd = SW_HIDE;

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* DestroyCompWindow()                                                */
/**********************************************************************/
void PASCAL DestroyCompWindow(          // destroy composition window
    HWND hCompWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->nShowCompCmd = SW_HIDE;

    lpUIPrivate->hCompWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CompSetCursor()                                                    */
/**********************************************************************/
void PASCAL CompSetCursor(
    HWND   hCompWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    GetCursorPos(&ptCursor);
    ScreenToClient(hCompWnd, &ptCursor);
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (HIWORD(lParam) == WM_RBUTTONDOWN) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
        return;
    } else if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        // start dragging
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
    } else {
        return;
    }

    SetCapture(hCompWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCompWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCompWnd, &rcWnd);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CompButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CompButtonUp(       // finish drag, set comp  window to this
                                // position
    HWND   hCompWnd)
{
    LONG            lTmpCursor, lTmpOffset;
    POINT           pt;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    HWND            hFocusWnd;
    COMPOSITIONFORM cfCompForm;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCompWnd, UI_MOVE_XY);
    pt.x = (*(LPPOINTS)&lTmpCursor).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y;

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCompWnd, UI_MOVE_OFFSET);
    pt.x -= (*(LPPOINTS)&lTmpOffset).x;
    pt.y -= (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCompWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
    ReleaseCapture();

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    hFocusWnd = (HWND)lpIMC->hWnd;

    ImmUnlockIMC(hIMC);

    if (pt.x < sImeG.rcWorkArea.left) {
        pt.x = sImeG.rcWorkArea.left;
    } else if (pt.x + lpImeL->xCompWi > sImeG.rcWorkArea.right) {
        pt.x = sImeG.rcWorkArea.right - lpImeL->xCompWi;
    }

    if (pt.y < sImeG.rcWorkArea.top) {
        pt.y = sImeG.rcWorkArea.top;
    } else if (pt.y + lpImeL->yCompHi > sImeG.rcWorkArea.bottom) {
        pt.y = sImeG.rcWorkArea.bottom - lpImeL->yCompHi;
    }

    ScreenToClient(hFocusWnd, &pt);

    cfCompForm.dwStyle = CFS_POINT|CFS_FORCE_POSITION;
    cfCompForm.ptCurrentPos.x = pt.x + lpImeL->cxCompBorder;
    cfCompForm.ptCurrentPos.y = pt.y + lpImeL->cyCompBorder;

    // set composition window to the new poosition
    SendMessage(hUIWnd, WM_IME_CONTROL, IMC_SETCOMPOSITIONWINDOW,
        (LPARAM)&cfCompForm);

    return (TRUE);
}

#define SHENHUI RGB(0x80,0x80,0x80)
#define QIANHUI RGB(0xe0,0xe0,0x80)   

/**********************************************************************/
/* CurMovePaint()                                                     */
/* Function: While the string is longer than the Comp Window....      */  
/*           keep the cursor inside the Comp Window                   */
/* Called: By UpdateCompWindow2                                       */  
/**********************************************************************/

void WINAPI CurMovePaint(
HDC   hDC, 
LPSTR srBuffer,          // the source sting that to be showed...
int   StrLen)            // the length of that...
{
  int i,xx,yy;

    //SetBkColor(hDC, QIANHUI);

  if(!StrLen)
      return;

  for (i=0; i<StrLen; i++)
      InputBuffer[i] = srBuffer[i]; 

  xx= 0;
  if (InputBuffer[0]>0xa0){
      for (i =0; i<StrLen; i++){
          if(InputBuffer[i]<0xa0) break;
      } 
                    
      yy = i;

      for (i=yy; i>0; i=i-2) { 
          //xx =sImeG.xChiCharWi*i/2; 
          xx=GetText32(hDC,&InputBuffer[0],i);
          if ( xx <= lpImeL->rcCompText.right-4)
              break;
      }
      i=0;
      cur_start_ps=0;
      cur_start_count=0;

  }else {
    for (i =now_cs; i>0; i--){
        yy=GetText32(hDC, &InputBuffer[i-1], 1);
        if ( (xx+yy) >= (lpImeL->rcCompText.right-4))
            break;
        else 
            xx+=yy;
    }
    cur_start_count=(WORD)i;
    cur_start_ps=(WORD)GetText32(hDC, &InputBuffer[0], i);
            //      true_len = StrLen-cur_start_count ;
  }

  for(i=StrLen-cur_start_count; i>0; i--){
      yy=GetText32(hDC,&InputBuffer[cur_start_count],i);
          if (yy <= lpImeL->rcCompText.right-4)
              break;
  }

  {
        LOGFONT         lfFont;
        HGDIOBJ         hOldFont;
        int Top = 2;
        if (sImeG.yChiCharHi > 0x10)
            Top = 0;

        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        GetObject(hOldFont, sizeof(lfFont), &lfFont);
        lfFont.lfWeight = FW_DONTCARE;
        SelectObject(hDC, CreateFontIndirect(&lfFont));

        ExtTextOut(hDC, 
                   lpImeL->rcCompText.left, lpImeL->rcCompText.top + Top,
                   ETO_OPAQUE, &lpImeL->rcCompText,
                   &InputBuffer[cur_start_count],
                   i, NULL);

        DeleteObject(SelectObject(hDC, hOldFont));
  }
//          TextOut(hDC,0,0,&InputBuffer[cur_start_count],
//               (sizeof InputBuffer)-cur_start_count);
    now_cs_dot = xx;
    cur_hibit=0,cur_flag=0;

    return;
}

/**********************************************************************/
/* UpdateCompWindow2()                                                */
/**********************************************************************/
void PASCAL UpdateCompWindow2(
    HWND hUIWnd,
    HDC  hDC)
{
    HIMC                hIMC;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;
    BOOL                fShowString;
    LOGFONT             lfFont;
    HGDIOBJ             hOldFont;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);
    lfFont.lfWeight = FW_DONTCARE;
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    fShowString = (BOOL)0;


    if (lpImeL->wImeStyle == IME_APRS_FIX){
           RECT rcSunken;
           DrawConvexRect(hDC,
                          0,
                          0,
                          lpImeL->xCompWi-1,
                          lpImeL->yCompHi-1);
        
           rcSunken.left =0;
           rcSunken.top =0;
           rcSunken.right =lpImeL->xCompWi-1;
           rcSunken.bottom = lpImeL->yCompHi-1;
  //  DrawEdge(hDC, &rcSunken, EDGE_RAISED,/*EDGE_SUNKEN,*/ BF_RECT);
        
  
        }else
                DrawConvexRect(hDC,
                               0,
                               0,
                               lpImeL->xCompWi-1,
                               lpImeL->yCompHi-1);
        
        /*      DrawConvexRect(hDC,
                               lpImeL->rcCompText.left-4,
                               lpImeL->rcCompText.top-4,
                               lpImeL->rcCompText.right+4,
                               lpImeL->rcCompText.bottom+4); */

   /* DrawConcaveRect(hDC,
                      lpImeL->rcCompText.left-1,
                      lpImeL->rcCompText.top-1,
                      lpImeL->rcCompText.right+1,
                      lpImeL->rcCompText.bottom+1);           */

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
    } else if (!lpGuideLine->dwStrLen) {
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            fShowString |= IME_STR_ERROR;
        }
    } else {
        // if there is information string, we will show the information
        // string
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            // red text for error
            SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, QIANHUI);
        }

        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset,
            (UINT)lpGuideLine->dwStrLen, NULL);
        fShowString |= IME_STR_SHOWED;
    }

    if (fShowString & IME_STR_SHOWED) {
        // already show it, don't need to show
    } else if (lpCompStr) {
       // ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
        //    ETO_OPAQUE, &lpImeL->rcCompText,
        //    (LPSTR)lpCompStr + lpCompStr->dwCompStrOffset,
        //    (UINT)lpCompStr->dwCompStrLen, NULL);
       
                CurMovePaint(hDC,
                                          (LPSTR)lpCompStr + lpCompStr->dwCompStrOffset,
                                          (UINT)lpCompStr->dwCompStrLen);

        if (fShowString & IME_STR_ERROR) {
            // red text for error
            SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, QIANHUI);
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                (LPSTR)lpCompStr + lpCompStr->dwCompStrOffset +
                lpCompStr->dwCursorPos,
                (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else if (lpCompStr->dwCursorPos < lpCompStr->dwCompStrLen) {
            // light gray background for cursor start
            SetBkColor(hDC, QIANHUI);
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                (LPSTR)lpCompStr + lpCompStr->dwCompStrOffset +
                lpCompStr->dwCursorPos,
                (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else {
        }
    } else {
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPSTR)NULL, 0, NULL);
    }

    DeleteObject(SelectObject(hDC, hOldFont));

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
    return;
}


/**********************************************************************/
/* UpdateCompWindow()                                                 */
/**********************************************************************/
void PASCAL UpdateCompWindow(
    HWND hUIWnd)
{
    HWND hCompWnd;
    HDC  hDC;

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) return ;                              //Modify 95/7.1

    hDC = GetDC(hCompWnd);
    UpdateCompWindow2(hUIWnd, hDC);
    ReleaseDC(hCompWnd, hDC);
}


/**********************************************************************/
/* UpdateCompCur()                                                 */
/**********************************************************************/
void PASCAL UpdateCompCur(
    HWND hCompWnd)
{
    HDC         hDC;
        int yy,i;
    HGDIOBJ         hOldFont;
    LOGFONT         lfFont;
      
    cur_hibit=1;

    if (!hCompWnd) return ;                              //Modify 95/7.1

    hDC = GetDC(hCompWnd);
  
    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(lfFont), &lfFont);
    lfFont.lfWeight = FW_DONTCARE;
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

                
        for (i =43-cur_start_count; i>0; i--){
                yy=GetText32(hDC, &InputBuffer[cur_start_count], i);
                if ( yy < lpImeL->rcCompText.right-4)
                        break;
        }

        ExtTextOut(hDC, 
                  lpImeL->rcCompText.left, lpImeL->rcCompText.top,
                  ETO_OPAQUE, &lpImeL->rcCompText,
                  &InputBuffer[cur_start_count],
                  i,
                   NULL);

    DeleteObject(SelectObject(hDC, hOldFont));
    ReleaseDC(hCompWnd, hDC);
        cur_hibit=0,cur_flag=0;
    return ;
}


/**********************************************************************/
/* PaintCompWindow()                                                  */
/**********************************************************************/
void PASCAL PaintCompWindow(            // get WM_PAINT message
    HWND hCompWnd)
{
    HDC         hDC;
    PAINTSTRUCT ps;
        RECT pt;


        if(CompWndChange){
                CompWndChange = 0;
                SetCompWindow(GetWindow(hCompWnd,GW_OWNER));
        };

        cur_hibit=1;

    hDC = BeginPaint(hCompWnd, &ps);
    UpdateCompWindow2(GetWindow(hCompWnd, GW_OWNER), hDC);
    EndPaint(hCompWnd, &ps);
        cur_hibit=0,cur_flag=0;
    return;
}

/**********************************************************************/
/* CompWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CompWndProc(           // composition window proc
    HWND   hCompWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC hDC;
    switch (uMsg) {
                case WM_CREATE:
                        hDC=GetDC(hCompWnd);
                        hMemoryDC=CreateCompatibleDC(hDC);
                        cur_h=LoadBitmap(hInst,CUR_HB);
                        ReleaseDC(hCompWnd,hDC);

                        SetTimer(hCompWnd ,1,400,(TIMERPROC)NULL);
                        ShowCandTimerCount=0;
                        break;

                case WM_TIMER:
                        hInputWnd = hCompWnd;
                        TimerCounter++;
                        ShowCandTimerCount++;
                        if (TimerCounter==3){
                                TimerCounter=0;
                        }
                        if (!kb_flag) return(0);

                        if (cur_hibit||(cap_mode&&(!cur_flag)))  return(0);
                        DrawInputCur();
                        break;

                case WM_DESTROY:
                        KillTimer(hCompWnd,1);
                        DeleteObject(cur_h);
                        DeleteObject(hMemoryDC);
                        DestroyCompWindow(hCompWnd);
                        break;
                case WM_SETCURSOR:
                        CompSetCursor(hCompWnd, lParam);
                        break;
                case WM_MOUSEMOVE:
                        if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
                                if(lpImeL->wImeStyle == IME_APRS_AUTO){   
                                        POINT ptCursor;

                                        DrawDragBorder(hCompWnd,
                                                GetWindowLong(hCompWnd, UI_MOVE_XY),
                                                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
                                        GetCursorPos(&ptCursor);
                                        SetWindowLong(hCompWnd, UI_MOVE_XY,
                                                MAKELONG(ptCursor.x, ptCursor.y));
                                        DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
                                        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
                                }else  MessageBeep(0);
                        } else {
                                return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
                        }
                        break;
                case WM_LBUTTONUP:
                        if (!CompButtonUp(hCompWnd)) {
                                return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
                        }
                        break;

                case WM_SHOWWINDOW:
                        if (wParam) cur_hibit = 0;
                        else cur_hibit = 1;
                        break;

                case WM_PAINT:
                if (wParam == 0xa )
                                UpdateCompCur(hCompWnd);
                        else
                        PaintCompWindow(hCompWnd);
                        break;
                case WM_MOUSEACTIVATE:
                        return (MA_NOACTIVATE);
                default:
                        return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
    return (0L);
}


/**********************************************************************/
/* GetCandWnd                                                         */
/* Return Value :                                                     */
/*      window handle of candidatte                                   */
/**********************************************************************/
HWND PASCAL GetCandWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

/**********************************************************************/
/* CalcCandPos                                                        */
/**********************************************************************/
void PASCAL CalcCandPos2(
    LPPOINT lpptWnd)            // the composition window position
{
    POINT ptNew;

    ptNew.x = lpptWnd->x + UI_MARGIN * 2;
    if (ptNew.x + sImeG.xCandWi > sImeG.rcWorkArea.right) {
        // exceed screen width
        ptNew.x = lpptWnd->x - sImeG.xCandWi - UI_MARGIN * 2;
    }

    ptNew.y = lpptWnd->y;// + lpImeL->cyCompBorder - sImeG.cyCandBorder;
    if (ptNew.y + sImeG.yCandHi > sImeG.rcWorkArea.bottom) {
        // exceed screen high
        ptNew.y = sImeG.rcWorkArea.bottom - sImeG.yCandHi;
    }

    lpptWnd->x = ptNew.x;
    lpptWnd->y = ptNew.y;

    return;
}


/**********************************************************************/
/* CalcCandPos                                                        */
/**********************************************************************/
BOOL PASCAL CalcCandPos(
    LPPOINT lpptWnd)            // the composition window position
{
    POINT ptNew;

    ptNew.x = lpptWnd->x + lpImeL->xCompWi + UI_MARGIN * 2;
    if (ptNew.x + sImeG.xCandWi > sImeG.rcWorkArea.right) {
        // exceed screen width
        ptNew.x = lpptWnd->x - sImeG.xCandWi - UI_MARGIN * 2;
    }

    ptNew.y = lpptWnd->y;// + lpImeL->cyCompBorder - sImeG.cyCandBorder;
    if (ptNew.y + sImeG.yCandHi > sImeG.rcWorkArea.bottom) {
        // exceed screen high
        ptNew.y = sImeG.rcWorkArea.bottom - sImeG.yCandHi;
    }

    lpptWnd->x = ptNew.x;
    lpptWnd->y = ptNew.y;

    return 0;
}

/**********************************************************************/
/* AdjustCandBoundry                                                  */
/**********************************************************************/
void PASCAL AdjustCandBoundry(
    LPPOINT lpptCandWnd)            // the position
{
    if (lpptCandWnd->x < sImeG.rcWorkArea.left) {
        lpptCandWnd->x = sImeG.rcWorkArea.left;
    } else if (lpptCandWnd->x + sImeG.xCandWi > sImeG.rcWorkArea.right) {
        lpptCandWnd->x = sImeG.rcWorkArea.right - sImeG.xCandWi;
    }

    if (lpptCandWnd->y < sImeG.rcWorkArea.top) {
        lpptCandWnd->y = sImeG.rcWorkArea.top;
    } else if (lpptCandWnd->y + sImeG.yCandHi > sImeG.rcWorkArea.bottom) {
        lpptCandWnd->y = sImeG.rcWorkArea.bottom - sImeG.yCandHi;
    }

    return;
}

/**********************************************************************/
/* GetCandPos()                                                  */
/**********************************************************************/
LRESULT PASCAL GetCandPos(
    HWND            hUIWnd,
    LPCANDIDATEFORM lpCandForm)
{
    HWND           hCandWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptNew;

    //DebugShow("GetCand...%x",hUIWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (1L);
    }

    if (!(hCandWnd = GetCandWnd(hUIWnd))) {
        return (1L);
    }

    if (lpCandForm->dwStyle & CFS_FORCE_POSITION) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

    } else if (lpCandForm->dwStyle & CFS_CANDIDATEPOS) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

    } else if (lpCandForm->dwStyle & CFS_EXCLUDE) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

    }

    ImmUnlockIMC(hIMC);

    return (0L);
}
/**********************************************************************/
/* SetCandPosition()                                                  */
/**********************************************************************/
LRESULT PASCAL SetCandPosition(
    HWND            hUIWnd,
    LPCANDIDATEFORM lpCandForm)
{
    HWND           hCandWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptNew;

        // DebugShow("SetCand...%x",hUIWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (1L);
    }

    if (!(hCandWnd = GetCandWnd(hUIWnd))) {
        return (1L);
    }

    if (lpCandForm->dwStyle & CFS_FORCE_POSITION) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
          //##4
        SetWindowPos(hCandWnd, NULL,
            ptNew.x, ptNew.y,
            sImeG.xCandWi,sImeG.yCandHi, SWP_NOACTIVATE|/*SWP_NOSIZE|*/SWP_NOZORDER);
    } else if (lpCandForm->dwStyle & CFS_CANDIDATEPOS) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

        AdjustCandBoundry(&ptNew);
           // ##5
        SetWindowPos(hCandWnd, NULL,
            ptNew.x, ptNew.y,
            sImeG.xCandWi,sImeG.yCandHi, SWP_NOACTIVATE/*|SWP_NOSIZE*/|SWP_NOZORDER);
    } else if (lpCandForm->dwStyle & CFS_EXCLUDE) {
        ptNew.x = (int)lpCandForm->ptCurrentPos.x;
        ptNew.y = (int)lpCandForm->ptCurrentPos.y;

        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

        AdjustCandBoundry(&ptNew);
           // ##6
        SetWindowPos(hCandWnd, NULL,
            ptNew.x, ptNew.y,
            sImeG.xCandWi,sImeG.yCandHi, SWP_NOACTIVATE|/*SWP_NOSIZE|*/SWP_NOZORDER);
        
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_DEFAULT) {
        HWND hCompWnd;

        if (hCompWnd = GetCompWnd(hUIWnd)) {
            ptNew.x = 0;
            ptNew.y = 0;

            ClientToScreen(hCompWnd, &ptNew);

            CalcCandPos(&ptNew);
        } else {
            AdjustCandBoundry(&ptNew);
     
        }
                SetWindowPos(hCandWnd, NULL,
            ptNew.x, ptNew.y,
            sImeG.xCandWi,sImeG.yCandHi, SWP_NOACTIVATE|/*SWP_NOSIZE|*/SWP_NOZORDER);
    
    }

    ImmUnlockIMC(hIMC);

    return (0L);
}


/**********************************************************************/
/* ShowCand()                                                         */
/**********************************************************************/
void PASCAL ShowCand(           // Show the candidate window
    HWND hUIWnd,
    int  nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

//      if (ShowCandTimerCount<5) {ShowCandTimerCount = 0; return 0;}

//      ShowCandTimerCount = 0 ;


    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    if (!lpUIPrivate->hCandWnd) {
        // not in show candidate window mode
    } else if (lpUIPrivate->nShowCandCmd != nShowCandCmd) {
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
    } else {
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenCand                                                           */
/**********************************************************************/
void PASCAL OpenCand(
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    POINT    ptWnd;
        int      value;

//      DebugShow("In Open Cand",0);
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

        lpUIPrivate->fdwSetContext |= ISC_SHOWUICANDIDATEWINDOW;

    ptWnd.x = 0;
    ptWnd.y = 0;
        
//      DebugShow("OpenCand ..->hCompWnd=%X",lpUIPrivate);

    value = ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);

  //  DebugShow("OpenCand ..value", value);

        if (!value){                                                    // if there no Comp wndows
                GetCaretPos(&ptWnd);
                ClientToScreen(GetFocus(),&ptWnd); 
                CalcCandPos2(&ptWnd);
        } else {
        ptWnd.x -= lpImeL->cxCompBorder;
    //  ptWnd.y -= lpImeL->cyCompBorder;
        CalcCandPos(&ptWnd);
        }

    if (lpImeL->wImeStyle == IME_APRS_FIX) {
                ptWnd.x = lpImeL->ptDefCand.x;
        ptWnd.y = lpImeL->ptDefCand.y;
        }

         // ##7
    if (lpUIPrivate->hCandWnd) {
        SetWindowPos(lpUIPrivate->hCandWnd, NULL,
            ptWnd.x, ptWnd.y,
            sImeG.xCandWi, sImeG.yCandHi,
            SWP_NOACTIVATE/*|SWP_NOSIZE*/|SWP_NOZORDER);
    } else {
        lpUIPrivate->hCandWnd = CreateWindowEx(
        /* WS_EX_TOPMOST*/ /*|*/  /* WS_EX_CLIENTEDGE|WS_EX_WINDOWEDGE/*|WS_EX_DLGMODALFRAME*/
            0,
            szCandClassName, NULL, WS_POPUP|WS_DISABLED,   //|WS_BORDER,
            ptWnd.x,
            ptWnd.y,
            sImeG.xCandWi, sImeG.yCandHi,
            hUIWnd, (HMENU)NULL, hInst, NULL);

        if ( lpUIPrivate->hCandWnd )
        {
            SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_OFFSET,
                WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_XY, 0L);
        }
    }

    ShowCand(hUIWnd, SW_SHOWNOACTIVATE);

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CloseCand                                                          */
/**********************************************************************/
void PASCAL CloseCand(
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    ShowWindow(lpUIPrivate->hCandWnd, SW_HIDE);
    lpUIPrivate->nShowCandCmd = SW_HIDE;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* DestroyCandWindow                                                  */
/**********************************************************************/
void PASCAL DestroyCandWindow(
    HWND hCandWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->nShowCandCmd = SW_HIDE;

    lpUIPrivate->hCandWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* MouseSelectCandStr()                                               */
/**********************************************************************/
void PASCAL MouseSelectCandStr(
    HWND    hCandWnd,
    LPPOINT lpCursor)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwValue, value = 0 ;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }
        
    if (PtInRect(&sImeG.rcHome, *lpCursor))
                     value = VK_HOME*0x100;
     
    if (PtInRect(&sImeG.rcEnd, *lpCursor))
                     value = VK_END*0x100;
    if (PtInRect(&sImeG.rcPageUp, *lpCursor))
                     value = VK_PRIOR*0x100;
    if (PtInRect(&sImeG.rcPageDown, *lpCursor)) 
                     value = VK_NEXT*0x100;
    if (PtInRect(&sImeG.rcCandText, *lpCursor)){
       if (lpImeL->wImeStyle == IME_APRS_AUTO )                       
            value = 0x8030 + 1 + (lpCursor->y - sImeG.rcCandText.top) / sImeG.yChiCharHi;
           else
                value = 0x8030+1+ (lpCursor->x - sImeG.rcCandText.left)/
                                (sImeG.xChiCharWi*unit_length/2+ sImeG.Ajust);
        }
        if(value) {
                LPPRIVCONTEXT lpImcP;
    
                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                lpImcP->fdwImeMsg =lpImcP->fdwImeMsg  & ~MSG_IN_IMETOASCIIEX;
        ImmUnlockIMCC(lpIMC->hPrivate);
        NotifyIME(hIMC, NI_SELECTCANDIDATESTR, 0, value);
   }
   ImmUnlockIMCC(lpIMC->hCandInfo);

   ImmUnlockIMC(hIMC);

   return;
}

/**********************************************************************/
/* CandSetCursor()                                                    */
/**********************************************************************/
void PASCAL CandSetCursor(
    HWND   hCandWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)||
            PtInRect(&sImeG.rcHome, ptCursor)||
            PtInRect(&sImeG.rcEnd, ptCursor)||
            PtInRect(&sImeG.rcPageUp, ptCursor)||
            PtInRect(&sImeG.rcPageDown, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
            MouseSelectCandStr(hCandWnd, &ptCursor);
            return;
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }
    } else {
        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)||
            PtInRect(&sImeG.rcHome, ptCursor)||
            PtInRect(&sImeG.rcEnd, ptCursor)||
            PtInRect(&sImeG.rcPageUp, ptCursor)||
            PtInRect(&sImeG.rcPageDown, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }

        return;
    }

    SetCapture(hCandWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCandWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCandWnd, &rcWnd);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCandWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CandButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CandButtonUp(
    HWND hCandWnd)
{
    LONG           lTmpCursor, lTmpOffset;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hFocusWnd;
    CANDIDATEFORM  cfCandForm;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCandWnd, UI_MOVE_XY);
    pt.x = (*(LPPOINTS)&lTmpCursor).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y;

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCandWnd, UI_MOVE_OFFSET);
    pt.x -= (*(LPPOINTS)&lTmpOffset).x;
    pt.y -= (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCandWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
    ReleaseCapture();

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    hFocusWnd = lpIMC->hWnd;

    ImmUnlockIMC(hIMC);

    AdjustCandBoundry(&pt);

    ScreenToClient(hFocusWnd, &pt);

    cfCandForm.dwStyle = CFS_CANDIDATEPOS;
    cfCandForm.ptCurrentPos.x = pt.x;
    cfCandForm.ptCurrentPos.y = pt.y;

    SendMessage(hUIWnd, WM_IME_CONTROL, IMC_SETCANDIDATEPOS,
        (LPARAM)&cfCandForm);

    return (TRUE);
}

/**********************************************************************/
/* PaintOP()                                                 */
/**********************************************************************/
void PASCAL PaintOP(
HDC  hDC,
HWND hWnd)
{
RECT rcSunken;
int x1,y1,x2,y2;

        rcSunken = sImeG.rcCandText;
   
    x1=rcSunken.left-2;
        y1=rcSunken.top-1;//2;
        x2=rcSunken.right+7;
        y2=rcSunken.bottom+5;
        
    rcSunken.left =x1;
    rcSunken.top =y1;
    rcSunken.right =x2;
    rcSunken.bottom = y2;
   
 //   ShowBitmap(hDC,x2-50,y2,49,20, szUpDown); 
        if(lpImeL->wImeStyle == IME_APRS_AUTO ){
                DrawConvexRect(hDC,0,0,sImeG.xCandWi-1, sImeG.yCandHi-1);
           // DrawConcaveRect(hDC ,x1,y1,x2,y2); 

                if(bx_inpt_on){
                        ShowBitmap2(hDC,
                           sImeG.xCandWi/2-25,
                           sImeG.rcHome.top,
                           50,
                           15,
                           sImeG.SnumbBmp);
                }else {
                        ShowBitmap2(hDC,
                           sImeG.xCandWi/2-25,
                           sImeG.rcHome.top,
                           50,
                           15,
                           sImeG.NumbBmp);
                }

                ShowBitmap2(hDC,
                           sImeG.rcHome.left,
                           sImeG.rcHome.top,
                           14,
                           14,
                           sImeG.HomeBmp);

                ShowBitmap2(hDC,
                           sImeG.rcEnd.left,
                           sImeG.rcEnd.top,
                           14,
                           14,
                           sImeG.EndBmp);

                ShowBitmap2(hDC,
                           sImeG.rcPageUp.left,
                           sImeG.rcPageUp.top,
                           14,
                           14,
                           sImeG.PageUpBmp);

                ShowBitmap2(hDC,
                           sImeG.rcPageDown.left,
                           sImeG.rcPageDown.top,
                           14,
                           14,
                           sImeG.PageDownBmp);
   
        }else{ 
                ShowBitmap2(hDC,
                           sImeG.rcHome.left,
                           sImeG.rcHome.top,
                           14,
                           14,
                           sImeG.Home2Bmp);

                ShowBitmap2(hDC,
                           sImeG.rcEnd.left,
                           sImeG.rcEnd.top,
                           14,
                           14,
                           sImeG.End2Bmp);

                ShowBitmap2(hDC,
                           sImeG.rcPageUp.left,
                           sImeG.rcPageUp.top,
                           14,
                           14,
                           sImeG.PageUp2Bmp);

                ShowBitmap2(hDC,
                           sImeG.rcPageDown.left,
                           sImeG.rcPageDown.top,
                           14,
                           14,
                           sImeG.PgDown2Bmp);
   
        }

        return ;
}

int keep =9; 
/**********************************************************************/
/* UpdateCandWindow()                                                 */
/**********************************************************************/
void PASCAL UpdateCandWindow2(
    HWND hCandWnd,
    HDC  hDC)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    DWORD           dwStart, dwEnd;
    TCHAR           szStrBuf[30* sizeof(WCHAR) / sizeof(TCHAR)];
    int             i , LenOfAll;
    HGDIOBJ         hOldFont;
    LOGFONT         lfFont;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
                ImmUnlockIMC(hIMC);
                return ;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmUnlockIMC(hIMC);
                return ;
    }

    if (!lpIMC->hPrivate) {
            ImmUnlockIMCC(lpIMC->hCandInfo);
        ImmUnlockIMC(hIMC);
                return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
            ImmUnlockIMCC(lpIMC->hCandInfo);
                ImmUnlockIMC(hIMC);
                return;
    }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

        if(lpImeL->wImeStyle == IME_APRS_FIX)
                lpCandList->dwPageSize = now.fmt_group;
        else
                lpCandList->dwPageSize = CANDPERPAGE ;
        if (!lpCandList->dwPageSize)
                lpCandList->dwPageSize = keep;
        keep = lpCandList->dwPageSize;

    dwStart = lpCandList->dwSelection /
        lpCandList->dwPageSize * lpCandList->dwPageSize;
              
    dwEnd = dwStart + lpCandList->dwPageSize;
    
    if (dwEnd > lpCandList->dwCount) {
        dwEnd = lpCandList->dwCount;
    }

        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        GetObject(hOldFont, sizeof(lfFont), &lfFont);
        lfFont.lfWeight = FW_DONTCARE;
        SelectObject(hDC, CreateFontIndirect(&lfFont));

        if(lpImeL->wImeStyle != IME_APRS_FIX){ 

        PaintOP(hDC,hCandWnd); 
                if (lpImcP->iImeState == CST_INIT) {
        // phrase prediction
                        SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
                } else if (lpImcP->iImeState != CST_CHOOSE) {
        // quick key
                        SetTextColor(hDC, RGB(0x80, 0x00, 0x80));
                } else {
                }

                SetBkColor(hDC, RGB(0xc0, 0xc0, 0xc0));

                sImeG.rcCandText.bottom+=3;
                ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top,
                        ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
                sImeG.rcCandText.bottom-=3;
                szStrBuf[0] = '1';
                szStrBuf[1] = ':';

                for (i = 0; dwStart < dwEnd; dwStart++, i++) {
                    int  iLen;

                    szStrBuf[0] = szDigit[i + CAND_START];

                    iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                                    lpCandList->dwOffset[dwStart]));

                    // according to init.c, 7 DBCS char
                    if (iLen > 6 * sizeof(WCHAR) / sizeof(TCHAR)) {
                         iLen = 6 * sizeof(WCHAR) / sizeof(TCHAR);
                         CopyMemory(&szStrBuf[2],
                                   ((LPBYTE)lpCandList+lpCandList->dwOffset[dwStart]),
                                   iLen * sizeof(TCHAR) - sizeof(TCHAR) * 2);
                         // maybe not good for UNICODE
                         szStrBuf[iLen] = '.';
                         szStrBuf[iLen + 1] = '.';
                    } else {
                         CopyMemory(&szStrBuf[2],
                                   ((LPBYTE)lpCandList+lpCandList->dwOffset[dwStart]),
                                   iLen);
                    }

                    ExtTextOut(hDC, sImeG.rcCandText.left,
                               sImeG.rcCandText.top + i * sImeG.yChiCharHi,
                               (UINT)0, NULL,
                               szStrBuf,
                               iLen + 2, NULL);
               }
        } else {
        PaintOP(hDC,hCandWnd); 

        SetTextColor(hDC, RGB(0xa0, 0x00, 0x80));
        SetBkColor(hDC, RGB(0xc0, 0xc0, 0xc0));

            ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top,
                    ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
                szStrBuf[0] = '1';
                szStrBuf[1] = ':';
                LenOfAll = 0;
                for (i = 0; dwStart < dwEnd; dwStart++, i++) {
                        int  iLen;

                        szStrBuf[LenOfAll++] = szDigit[i + CAND_START];
                        szStrBuf[LenOfAll++] = '.' ;

                        iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                                lpCandList->dwOffset[dwStart]));

                        CopyMemory(&szStrBuf[LenOfAll],
                                ((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                iLen);
                        LenOfAll += iLen;

                        szStrBuf[LenOfAll] = '.';
                        szStrBuf[LenOfAll] = '.';
       
                }

                DrawConvexRect(hDC,0,0,sImeG.xCandWi-1,sImeG.yCandHi-1);        //zl
                PaintOP(hDC,hCandWnd);
         
                {
                        int TopOfText = 2;
                        if (sImeG.yChiCharHi >0x10)
                                TopOfText = 0;
                        ExtTextOut(hDC, sImeG.rcCandText.left,
                                sImeG.rcCandText.top + TopOfText,
                                (UINT)0, NULL,
                                szStrBuf,
                                LenOfAll, NULL);
                }


        }
        
    DeleteObject(SelectObject(hDC, hOldFont));

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* PaintCandWindow()                                                  */
/**********************************************************************/
void PASCAL PaintCandWindow(        // handle WM_PAINT message
    HWND hCandWnd)
{
    HDC         hDC;
    PAINTSTRUCT ps;
        
        hDC = BeginPaint(hCandWnd, &ps);
    UpdateCandWindow2(hCandWnd, hDC);
    EndPaint(hCandWnd, &ps);
    return;
}

/**********************************************************************/
/* CandWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CandWndProc(
    HWND   hCandWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
                case WM_CREATE:
                        sImeG.HomeBmp = LoadBitmap(hInst, szHome);      //zl
                        sImeG.EndBmp = LoadBitmap(hInst, szEnd);
                        sImeG.PageUpBmp = LoadBitmap(hInst, szPageUp);
                        sImeG.PageDownBmp = LoadBitmap(hInst, szPageDown);
                        sImeG.NumbBmp  =  LoadBitmap(hInst, szNumb);
                        sImeG.SnumbBmp  =  LoadBitmap(hInst, szSnumb);
                        sImeG.Home2Bmp = LoadBitmap(hInst, szHome2);
                        sImeG.End2Bmp = LoadBitmap(hInst, szEnd2);
                        sImeG.PageUp2Bmp = LoadBitmap(hInst, szPageUp2);
                        sImeG.PgDown2Bmp = LoadBitmap(hInst, szPgDown2);
                        break;

                case WM_DESTROY:
                        DeleteObject(sImeG.HomeBmp);
                        DeleteObject(sImeG.EndBmp);
                        DeleteObject(sImeG.PageUpBmp);
                        DeleteObject(sImeG.PageDownBmp);
                        DeleteObject(sImeG.NumbBmp );
                        DeleteObject(sImeG.SnumbBmp );
                        DeleteObject(sImeG.Home2Bmp);
                        DeleteObject(sImeG.End2Bmp);
                        DeleteObject(sImeG.PageUp2Bmp);
                        DeleteObject(sImeG.PgDown2Bmp);
                        DestroyCandWindow(hCandWnd);    
                        break;

                case WM_SETCURSOR:
                        CandSetCursor(hCandWnd, lParam);
                        break;
                case WM_MOUSEMOVE:
                        if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
                                POINT ptCursor;
                        
                                if (lpImeL->wImeStyle == IME_APRS_AUTO){

                                        DrawDragBorder(hCandWnd,
                                                GetWindowLong(hCandWnd, UI_MOVE_XY),
                                                        GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
                                        GetCursorPos(&ptCursor);
                                        SetWindowLong(hCandWnd, UI_MOVE_XY,
                                                MAKELONG(ptCursor.x, ptCursor.y));
                                        DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
                                                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
                                }else MessageBeep(0);

                        } else {
                                return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
                        }
                        break;
                case WM_LBUTTONUP:
                        if (!CandButtonUp(hCandWnd)) {
                                return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
                        }
                        break;
                case WM_PAINT:
                        InvalidateRect(hCandWnd,0,1);
                        PaintCandWindow(hCandWnd);
                        break;
                case WM_MOUSEACTIVATE:
                        return (MA_NOACTIVATE);
            
                /* case WM_IME_NOTIFY:
        if (wParam != IMN_SETCANDIDATEPOS) {
        } else if (lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI) {
        } else if (lParam & 0x0001) {
            return SetCandPosition(hCandWnd);
        } else {
        }
        break;*/

                default:
                        return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }

    return (0L);
}


/**********************************************************************/
/* ImeInquire()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeInquire(         // initialized data structure of IME
    LPIMEINFO lpImeInfo,        // IME specific data report to IMM
    LPTSTR    lpszWndCls,       // the class name of UI
    DWORD     dwSystemInfoFlags)
{
    if (!lpImeInfo) {
        return (FALSE);
    }

    lpImeInfo->dwPrivateDataSize = sizeof(PRIVCONTEXT);
    lpImeInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST|IME_PROP_IGNORE_UPKEYS|IME_PROP_CANDLIST_START_FROM_1;
    lpImeInfo->fdwConversionCaps = IME_CMODE_NATIVE|IME_CMODE_FULLSHAPE|
       /* IME_CMODE_CHARCODE|*/IME_CMODE_SOFTKBD|IME_CMODE_NOCONVERSION/*|
        IME_CMODE_EUDC*/;

    lpImeInfo->fdwSentenceCaps = TRUE;

    // IME will have different distance base multiple of 900 escapement
    lpImeInfo->fdwUICaps = UI_CAP_ROT90|UI_CAP_SOFTKBD;
    // composition string is the reading string for simple IME
    lpImeInfo->fdwSCSCaps = SCS_CAP_COMPSTR|SCS_CAP_MAKEREAD;
    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD)0;

    lstrcpy(lpszWndCls, (LPSTR)szUIClassName);

    if ( lpImeL )
    {
       if ( dwSystemInfoFlags & IME_SYSINFO_WINLOGON )
       {
            //  the client app is running in logon mode.
            lpImeL->fWinLogon = TRUE;
       }
       else
            lpImeL->fWinLogon = FALSE;

    }

    return (TRUE);
}

BOOL FAR PASCAL ConfigDlgProc(  // dialog procedure of configuration
    HWND hDlg,
    UINT uMessage,
    WORD wParam,
    LONG lParam)
{
    return (TRUE);
}

/**********************************************************************/
/* ImeConfigure()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeConfigure(      // configurate the IME setting
    HKL     hKL,               // hKL of this IME
    HWND    hAppWnd,           // the owner window
    DWORD   dwMode,
    LPVOID  lpData)            // mode of dialog
{
    switch (dwMode) {
    case IME_CONFIG_GENERAL:
        DoPropertySheet(hAppWnd,NULL);
        ReInitIme(hAppWnd,lpImeL->wImeStyle); //#@1
        break;
    default:
        return (FALSE);
        break;
    }
    return (TRUE);
}

/**********************************************************************/
/* ImeConversionList()                                                */
/**********************************************************************/
DWORD WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD            uBufLen,
    UINT            uFlag)
{
    return (UINT)0;
}

/**********************************************************************/
/* ImeDestroy()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeDestroy(         // this dll is unloaded
    UINT uReserved)
{
    if (uReserved) {
        return (FALSE);
    }

    // free the IME table or data base
        // FreeTable();
    return (TRUE);
}

/**********************************************************************/
/* SetPrivateSetting()                                                */
/**********************************************************************/
void PASCAL SetPrivateFileSetting(
    LPBYTE  szBuf,
    int     cbBuf,
    DWORD   dwOffset,
    LPCTSTR szSettingFile)      // file for IME private related settings
{
    TCHAR  szSettingPath[MAX_PATH];
    UINT   uLen;
    HANDLE hSettingFile;
    DWORD  dwWriteByte;

    return;
}



/**********************************************************************/
/* Input2Sequence                                                     */
/* Return Value:                                                      */
/*      LOWORD - Internal Code, HIWORD - sequence code                */
/**********************************************************************/
LRESULT PASCAL Input2Sequence(
    DWORD  uVirtKey,
    LPBYTE lpSeqCode)
{
    return 0;
}


/**********************************************************************/
/* ImeEscape()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define IME_INPUTKEYTOSEQUENCE  0x22

LRESULT WINAPI ImeEscape(       // escape function of IMEs
    HIMC   hIMC,
    UINT   uSubFunc,
    LPVOID lpData)
{
    LRESULT lRet;

    switch (uSubFunc) {
    case IME_ESC_QUERY_SUPPORT:

        if ( lpData == NULL )
           return FALSE;

        switch (*(LPUINT)lpData) {
        case IME_ESC_QUERY_SUPPORT:
        case IME_ESC_SEQUENCE_TO_INTERNAL:
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_SET_EUDC_DICTIONARY:
        case IME_INPUTKEYTOSEQUENCE:      
         // will not supported in next version
                                          
        // and not support 32 bit applications        case IME_ESC_MAX_KEY:
        case IME_ESC_IME_NAME:
        case IME_ESC_GETHELPFILENAME:
            return (TRUE);
        default:
            return (FALSE);
        }
        break;

    case IME_ESC_SEQUENCE_TO_INTERNAL:
                lRet = 0;
                return (lRet);

    case IME_ESC_GET_EUDC_DICTIONARY:
                return (FALSE);
    case IME_ESC_SET_EUDC_DICTIONARY:
                return (FALSE);

    case IME_INPUTKEYTOSEQUENCE:
                return 0;

    case IME_ESC_MAX_KEY:
                return (lpImeL->nMaxKey);

    case IME_ESC_IME_NAME:
             {

               TCHAR   szIMEName[MAX_PATH];
        
               if ( lpData == NULL )
                  return FALSE;

               LoadString(hInst, IDS_IMENAME, szIMEName, sizeof(szIMEName) );
               lstrcpy(lpData, szIMEName);
               return (TRUE);
             }

    case IME_ESC_GETHELPFILENAME:
        
                if ( lpData == NULL )
                    return FALSE;

                lstrcpy(lpData, TEXT("winabc.hlp") );
                return TRUE;

    default:
        return (FALSE);
    }

    return (lRet);
}

/**********************************************************************/
/* InitCompStr()                                                      */
/**********************************************************************/
void PASCAL InitCompStr(                // init setting for composing string
    LPCOMPOSITIONSTRING lpCompStr)
{
    if (!lpCompStr) {
        return;
    }

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompStrLen = 0;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    return;
}

/**********************************************************************/
/* ClearCompStr()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCompStr(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC               hMem;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD               dwSize =
        // header length
        sizeof(COMPOSITIONSTRING) +
        // composition reading attribute plus NULL terminator
        lpImeL->nMaxKey * sizeof(BYTE) + sizeof(BYTE) +
        // composition reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // composition reading string plus NULL terminator
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result reading string plus NULL terminateor
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result string plus NULL terminateor
        MAXSTRLEN * sizeof(WORD) + sizeof(WORD);

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        // it maybe free by other IME, init it
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCompStr, dwSize)) {
        lpIMC->hCompStr = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    lpCompStr->dwSize = dwSize;

     // 1. composition (reading) string - simple IME
     // 2. result reading string
     // 3. result string

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadAttrOffset = sizeof(COMPOSITIONSTRING);
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadClauseOffset = lpCompStr->dwCompReadAttrOffset +
        lpImeL->nMaxKey * sizeof(BYTE) + sizeof(BYTE);
    lpCompStr->dwCompReadStrLen = 0;
    lpCompStr->dwCompReadStrOffset = lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // composition string is the same with composition reading string 
    // for simple IMEs
    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompAttrOffset = lpCompStr->dwCompReadAttrOffset;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompClauseOffset = lpCompStr->dwCompReadClauseOffset;
    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompStrOffset = lpCompStr->dwCompReadStrOffset;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadClauseOffset = lpCompStr->dwCompStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultReadStrOffset = lpCompStr->dwResultReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultClauseOffset = lpCompStr->dwResultReadStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultStrOffset = 0;
    lpCompStr->dwResultStrOffset = lpCompStr->dwResultClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    GlobalUnlock((HGLOBAL)lpIMC->hCompStr);
    return (TRUE);
}

/**********************************************************************/
/* ClearCand()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCand(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND) +
        // string plus NULL terminator
        (sizeof(WORD) + sizeof(WORD)) * MAXCAND;

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        // it maybe free by other IME, init it
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCandInfo, dwSize)) {
        lpIMC->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        return (FALSE);
    } 

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND - 1);

    ImmUnlockIMCC(lpIMC->hCandInfo);
    return (TRUE);
}

/**********************************************************************/
/* ClearGuideLine()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearGuideLine(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC       hMem;
    LPGUIDELINE lpGuideLine;
    DWORD       dwSize = sizeof(GUIDELINE) + sImeG.cbStatusErr;

    if (!lpIMC->hGuideLine) {
        // it maybe free by IME
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hGuideLine, dwSize)) {
        lpIMC->hGuideLine = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hGuideLine);
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {
        return (FALSE);
    }

    lpGuideLine->dwSize = dwSize;
    lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
    lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    lpGuideLine->dwStrLen = 0;
    lpGuideLine->dwStrOffset = sizeof(GUIDELINE);

    CopyMemory((LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset,
        sImeG.szStatusErr, sImeG.cbStatusErr);

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return (TRUE);
}


/**********************************************************************/
/* InitContext()                                                      */
/**********************************************************************/
void PASCAL InitContext(
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    //if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    //} else if (!lpIMC->hWnd) {
    //} else if (lpImcP->fdwInit & INIT_STATUSWNDPOS) {
    //} else {
    if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    } else if (!lpIMC->hWnd) {
    } else {
        POINT ptWnd;

        ptWnd.x = 0;
        ptWnd.y = 0;
        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (ptWnd.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (ptWnd.x + sImeG.xStatusWi > sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                sImeG.xStatusWi;
        } else {
            lpIMC->ptStatusWndPos.x = ptWnd.x;
        }

        //   DebugShow2 ("ptst.y,", lpIMC->ptStatusWndPos.y, "bottom" , sImeG.rcWorkArea.bottom);

                if(!lpIMC->ptStatusWndPos.y)     // == sImeG.rcWorkArea.bottom)
                        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
                                sImeG.yStatusHi;// - 2 * UI_MARGIN;// - 20;
                else
                        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
                                sImeG.yStatusHi;// - 2 * UI_MARGIN;


        //lpImcP->fdwInit |= INIT_STATUSWNDPOS;
        lpIMC->fdwInit |= INIT_STATUSWNDPOS;
    }

    if (!(lpIMC->fdwInit & INIT_COMPFORM)) {
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
    }

    if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
    } else if (!lpIMC->hWnd) {
    } else if (lpImcP->fdwInit & INIT_COMPFORM) {
    } else {
        if (0/*lpImeL->fdwModeConfig & MODE_CONFIG_OFF_CARET_UI*/) {
         //   lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x +
         //       lpImeL->rcStatusText.right + lpImeL->cxCompBorder * 2 +
         //       UI_MARGIN;

        //    if (lpIMC->cfCompForm.ptCurrentPos.x + (lpImeL->nRevMaxKey *
        //        sImeG.xChiCharWi) > sImeG.rcWorkArea.right) {
        //        lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x -
        //            lpImeL->nRevMaxKey * sImeG.xChiCharWi -
        //            lpImeL->cxCompBorder * 3;
        //    }
        } else {
            lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x +
                sImeG.xStatusWi + UI_MARGIN;

            if (lpIMC->cfCompForm.ptCurrentPos.x + lpImeL->xCompWi >
                sImeG.rcWorkArea.right) {
                lpIMC->cfCompForm.ptCurrentPos.x = lpIMC->ptStatusWndPos.x -
                    lpImeL->xCompWi - lpImeL->cxCompBorder * 2 -
                    UI_MARGIN;
            }
        }

        lpIMC->cfCompForm.ptCurrentPos.y = sImeG.rcWorkArea.bottom -
            lpImeL->yCompHi;// - 2 * UI_MARGIN;

        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

        lpImcP->fdwInit |= INIT_COMPFORM;
    }

    return;
}



 
/**********************************************************************/
/* Select()                                                           */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL Select(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    BOOL           fSelect)
{
    LPPRIVCONTEXT  lpImcP;

        sImeG.First = 0;
    if (fSelect) {      // init "every" fields of hPrivate, please!!!
    
        if (lpIMC->cfCompForm.dwStyle == CFS_DEFAULT) {
        } else {
        }

        if (!ClearCompStr(lpIMC)) {
            return (FALSE);
        }

        if (!ClearCand(lpIMC)) {
            return (FALSE);
        }

        ClearGuideLine(lpIMC);
    }

    if (!lpIMC->hPrivate) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return (FALSE);
    }

    if (fSelect) {      // init "every" fields of hPrivate, please!!!


        static  bFirstTimeCallHere = TRUE;


        InterlockedIncrement( &lLock );

        if ( bFirstTimeCallHere == TRUE ) {

           // we move the following code here from the DLL_ATTACH_PROCESS to 
           // avoid application hang.

           // With static variable bFirstTimeCallHere, we ensure the following
           // code will be called only when the ImeSelect( ) is first called.

            GetCurrentUserEMBPath( );
            data_init( );                 

            bFirstTimeCallHere = FALSE;
        }

        InterlockedDecrement( &lLock );

        lpImcP->iImeState = CST_INIT;    // init the IME state machine
        lpImcP->fdwImeMsg = (DWORD)0;    // no UI windpws show
        lpImcP->dwCompChar = (DWORD)0;
        lpImcP->fdwGcsFlag = (DWORD)0;
        lpImcP->hSoftKbdWnd = NULL;      // soft keyboard window
        lpImcP->nShowSoftKbdCmd = 0;

        lpIMC->fOpen = TRUE;

        if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
                        if(GetKeyState(VK_CAPITAL)&1)
                                lpIMC->fdwConversion = IME_CMODE_NOCONVERSION;
                        else
                                lpIMC->fdwConversion = IME_CMODE_NATIVE;
   
                        kb_mode = CIN_STD;
                        DispMode(hIMC);

                        lpIMC->fdwConversion |= IME_CMODE_SYMBOL;

            lpIMC->fdwInit |= INIT_CONVERSION;
        }else {

                if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD)
                   {
                   sImeG.First = 1;
                   }
                }



        if (lpIMC->fdwInit & INIT_SENTENCE) {
        } else if (lpImeL->fModeConfig & MODE_CONFIG_PREDICT) {
            lpIMC->fdwSentence = IME_SMODE_PHRASEPREDICT;
            lpIMC->fdwInit |= INIT_SENTENCE;
        } else {
        }


        if (!(lpIMC->fdwInit & INIT_LOGFONT)) {
            HDC hDC;
            HGDIOBJ hSysFont;

            hDC = GetDC(NULL);
            hSysFont = GetStockObject(SYSTEM_FONT);
            GetObject(hSysFont, sizeof(LOGFONT), &lpIMC->lfFont.A);
            ReleaseDC(NULL, hDC);
            lpIMC->fdwInit |= INIT_LOGFONT;
        }

        // Get Current User's specific phrase table path

        
        InitContext(lpIMC,lpImcP);
    }
        else    
        {
                if(hCrtDlg) {
                        SendMessage(hCrtDlg, WM_CLOSE, (WPARAM)NULL, (LPARAM)NULL);
                        hCrtDlg = NULL;                  
                }
        }
        
    ImmUnlockIMCC(lpIMC->hPrivate);

    return (TRUE);
}

/**********************************************************************/
/* ImeSelect()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSelect(
    HIMC hIMC,
    BOOL fSelect)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;


    // to load/free IME table
    if (fSelect) {
                InitCvtPara();
        if (!lpImeL->cRefCount++) {
          /* zst   LoadTable() */ ;
        }
    } else {
        
        if (!lpImeL->cRefCount) {
           /* zst FreeTable() */ ;
        }
    }


    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    fRet = Select(hIMC, lpIMC, fSelect);

    ImmUnlockIMC(hIMC);
        
    return (fRet);
}

/**********************************************************************/
/* ImeSetActiveContext()                                              */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(
    HIMC   hIMC,
    BOOL   fOn)
{
    if (!fOn) {
    } else if (!hIMC) {
    } else {
        LPINPUTCONTEXT lpIMC;
                LPPRIVCONTEXT   lpImcP;                   //zl
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                
        if (!lpIMC) {
            return (FALSE);

        }

                if(lpIMC->hPrivate){
        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);  //zl
        
        if (!lpImcP){                                                                            //zl
                        return (FALSE);                                                                    //zl
                   }                                                                                                     //zl
                }else return(FALSE);
       
        InitContext(lpIMC,lpImcP);                                                       //zl
        //      DispModeEx(0);
        ImmUnlockIMCC(lpIMC->hPrivate);                                                          //zl
        ImmUnlockIMC(hIMC);
    }

    return (TRUE);
}

 

/**********************************************************************/
/* ReInitIme()                                                */
/**********************************************************************/

void PASCAL ReInitIme(
        HWND hWnd ,
    WORD WhatStyle)
{

    HWND hStatusWnd,MainWnd;
    POINT ptPos;
    RECT  rcStatusWnd,TempRect;
        int cxBorder, cyBorder;

        if (sImeG.unchanged)
            return ;
    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) +
        GetSystemMetrics(SM_CXEDGE) * 2;
    cyBorder = GetSystemMetrics(SM_CYBORDER) +
        GetSystemMetrics(SM_CYEDGE) * 2;


        //if (!WhatStyle){
        if (WhatStyle==IME_APRS_AUTO){
                lpImeL->rcCompText.left = 4;
                lpImeL->rcCompText.top =4;
                lpImeL->rcCompText.right = sImeG.TextLen+5;
                lpImeL->rcCompText.bottom = sImeG.yStatusHi-4;//6;
                lpImeL->cxCompBorder = cxBorder;
                lpImeL->cyCompBorder = cyBorder;

            // set the width & height for composition window
                lpImeL->xCompWi = lpImeL->rcCompText.right + /*lpImeL->cxCompBorder*/3 * 2;
                //lpImeL->yCompHi = lpImeL->rcCompText.bottom +/* lpImeL->cyCompBorder*/3 * 2+1;//zl
                lpImeL->yCompHi = sImeG.yStatusHi;//lpImeL->rcCompText.bottom +/* lpImeL->cyCompBorder*/3 * 2+1;//zl
  
         } else {

                // text position relative to the composition window
                lpImeL->rcCompText.left = 4;
                lpImeL->rcCompText.top = 4;
                lpImeL->rcCompText.right = sImeG.TextLen+5;
                lpImeL->rcCompText.bottom = sImeG.yStatusHi-4;//6;/*cyBorder;*/
                lpImeL->cxCompBorder = cxBorder;
            lpImeL->cyCompBorder = cyBorder;

                // set the width & height for composition window
                lpImeL->xCompWi = lpImeL->rcCompText.right + /*lpImeL->cxCompBorder*/3 * 2;  
                lpImeL->yCompHi = sImeG.yStatusHi;   //zl
  
        }


        // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) +
        GetSystemMetrics(SM_CXEDGE) /* 2*/;
    cyBorder = GetSystemMetrics(SM_CYBORDER) +
        GetSystemMetrics(SM_CYEDGE) /* 2*/;

  

        //if (!WhatStyle){
        if (WhatStyle==IME_APRS_AUTO){
 
                sImeG.rcCandText.left = 4;
                sImeG.rcCandText.top = 4;
                sImeG.rcCandText.right = sImeG.xChiCharWi * 7;
                sImeG.rcCandText.bottom = sImeG.yChiCharHi * CANDPERPAGE+1;//zl

            sImeG.cxCandBorder = cxBorder+3;
                sImeG.cyCandBorder = cyBorder+3;

                sImeG.xCandWi = sImeG.rcCandText.right + sImeG.cxCandBorder * 2+3;//zl
                sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder *2+12;

                sImeG.rcHome.left = 4 ;
                sImeG.rcHome.top = sImeG.rcCandText.bottom+6 ;
                sImeG.rcHome.right = sImeG.rcHome.left + 14 ;
                sImeG.rcHome.bottom = sImeG.rcHome.top +14 ;

                sImeG.rcEnd.left = sImeG.rcHome.right ;
                sImeG.rcEnd.top = sImeG.rcHome.top ;
                sImeG.rcEnd.right = sImeG.rcEnd.left + 14 ;
                sImeG.rcEnd.bottom = sImeG.rcHome.bottom ;

                sImeG.rcPageDown.top = sImeG.rcHome.top ;
                sImeG.rcPageDown.right = sImeG.xCandWi-4;
                sImeG.rcPageDown.left = sImeG.rcPageDown.right - 14 ;
                sImeG.rcPageDown.bottom = sImeG.rcHome.bottom ;

                sImeG.rcPageUp.top = sImeG.rcHome.top ;
                sImeG.rcPageUp.right = sImeG.rcPageDown.left ;
                sImeG.rcPageUp.left = sImeG.rcPageUp.right -14 ;
                sImeG.rcPageUp.bottom = sImeG.rcHome.bottom ;

        }else{
                sImeG.cxCandBorder = cxBorder;
                sImeG.cyCandBorder = cyBorder;

                sImeG.xCandWi = lpImeL->xCompWi + sImeG.xStatusWi - cxBorder+1;
                sImeG.yCandHi = sImeG.yStatusHi; //sImeG.yChiCharHi+3 + sImeG.cyCandBorder *2;

                sImeG.rcHome.left = 3;    //2;
                sImeG.rcHome.top =  4;//7;
                sImeG.rcHome.right = sImeG.rcHome.left + 10; //14;
                sImeG.rcHome.bottom = sImeG.rcHome.top +8;   //14 ;

                sImeG.rcEnd.left =sImeG.rcHome.left; //sImeG.rcHome.right ;
                sImeG.rcEnd.top = sImeG.rcHome.top+9;   //14 ;
                sImeG.rcEnd.right =sImeG.rcHome.right; //sImeG.rcEnd.left + 14 ;
                sImeG.rcEnd.bottom = sImeG.rcHome.bottom+10;  //14 ;
    
                sImeG.rcPageDown.top = sImeG.rcEnd.top;//sImeG.rcHome.top ;
                sImeG.rcPageDown.right = sImeG.xCandWi-1;//2;
                sImeG.rcPageDown.left = sImeG.rcPageDown.right - 14 ;
                sImeG.rcPageDown.bottom = sImeG.rcEnd.bottom ;//sImeG.rcHome.bottom ;

                sImeG.rcPageUp.top = sImeG.rcHome.top -1;        //zl
                sImeG.rcPageUp.right = sImeG.rcPageDown.right+1;//zl;sImeG.rcPageDown.left ;
                sImeG.rcPageUp.left = sImeG.rcPageDown.left;//sImeG.rcPageUp.right -14 ;
                sImeG.rcPageUp.bottom = sImeG.rcHome.bottom ;
   
                sImeG.rcCandText.left = sImeG.rcEnd.right+2;//1;//4;//sImeG.rcEnd.right;
                sImeG.rcCandText.top = 4;
                sImeG.rcCandText.right = sImeG.rcPageUp.left-4;//2;//sImeG.rcPageUp.left-2;
                sImeG.rcCandText.bottom = sImeG.yChiCharHi+7;//6;//3;
                
        }

                /*      ptPos.x = 0 ;
                        ptPos.y = 0 ;

                        ClientToScreen(hWnd, &ptPos);

                        lpImeL->ptDefComp.x =   ptPos.x + sImeG.xStatusWi - cxBorder*2;  
                        lpImeL->ptDefComp.y =   ptPos.y - cyBorder;
   
                        lpImeL->ptDefCand.x = ptPos.x - cxBorder;
                        lpImeL->ptDefCand.y = ptPos.y - sImeG.yCandHi-2;

                        if ((sImeG.rcWorkArea.right-lpImeL->ptDefComp.x -lpImeL->xCompWi)<10)
                                {lpImeL->ptDefComp.x =  ptPos.x - lpImeL->xCompWi;
                                lpImeL->ptDefCand.x = lpImeL->ptDefComp.x ;}

                        if ((ptPos.y - sImeG.yCandHi)< (sImeG.rcWorkArea.top+5))
                                lpImeL->ptDefCand.y = ptPos.y + sImeG.yStatusHi; //sImeG.yCandHi+2;    

                  */
        if (hWnd){  
                ptPos.x = 0 ;
                ptPos.y = 0 ;

                ClientToScreen(hWnd, &ptPos);

                CountDefaultComp(ptPos.x,ptPos.y,sImeG.rcWorkArea);
                        
                lpImeL->ptDefComp.x =   ptPos.x + sImeG.xStatusWi - cxBorder*2+4;//zl  
                lpImeL->ptDefComp.y =   ptPos.y - cyBorder+3;//2;//3;  //zl
                lpImeL->ptDefCand.x = ptPos.x - cxBorder+3;  //zl
                lpImeL->ptDefCand.y = ptPos.y - sImeG.yCandHi-2+2;//zl

                if ((sImeG.rcWorkArea.right-lpImeL->ptDefComp.x -lpImeL->xCompWi)<10){
                        lpImeL->ptDefComp.x =   ptPos.x - lpImeL->xCompWi;
                        lpImeL->ptDefCand.x = lpImeL->ptDefComp.x ;
                }

                if ((ptPos.y - sImeG.yCandHi)< (sImeG.rcWorkArea.top+5))
                        lpImeL->ptDefCand.y = ptPos.y + sImeG.yStatusHi-4; //sImeG.yCandHi+2;    
        }else{
                ptPos.x = lpImeL->Ox ;
                ptPos.y = lpImeL->Oy ;

                lpImeL->ptDefComp.x = sImeG.xStatusWi - cxBorder*2;  
                lpImeL->ptDefComp.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
   
                lpImeL->ptDefCand.x = lpImeL->ptDefComp.x + lpImeL->xCompWi;
                lpImeL->ptDefCand.y = lpImeL->ptDefComp.y ;
                 
                  /*
                        if ((sImeG.rcWorkArea.right-lpImeL->ptDefComp.x -lpImeL->xCompWi)<10)
                                {lpImeL->ptDefComp.x =  ptPos.x - lpImeL->xCompWi;
                                lpImeL->ptDefCand.x = lpImeL->ptDefComp.x ;}

                        if ((ptPos.y - sImeG.yCandHi)< (sImeG.rcWorkArea.top+5))
                                lpImeL->ptDefCand.y = ptPos.y + sImeG.yCandHi+2;    
                        
                   */
        }         
        fmt_transfer();
        CandWndChange = 1;
        CompWndChange = 1;
        return  ;
}

void PASCAL ReInitIme2(
        HWND hWnd ,
    WORD WhatStyle)
{

    HWND hStatusWnd,MainWnd;
    POINT ptPos;
    RECT  rcStatusWnd,TempRect;
        int cxBorder, cyBorder;

        if (sImeG.unchanged)
            return ;
    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) +
        GetSystemMetrics(SM_CXEDGE) * 2;
    cyBorder = GetSystemMetrics(SM_CYBORDER) +
        GetSystemMetrics(SM_CYEDGE) * 2;


        if (!WhatStyle){
                lpImeL->rcCompText.left = 4;
                lpImeL->rcCompText.top =4;
                lpImeL->rcCompText.right = sImeG.TextLen+5;
                lpImeL->rcCompText.bottom = sImeG.yStatusHi-4;//6;
    
                lpImeL->cxCompBorder = cxBorder;
                lpImeL->cyCompBorder = cyBorder;

                // set the width & height for composition window
                lpImeL->xCompWi = lpImeL->rcCompText.right + /*lpImeL->cxCompBorder*/3 * 2;
                //lpImeL->yCompHi = lpImeL->rcCompText.bottom +/* lpImeL->cyCompBorder*/3 * 2+1;//zl
                lpImeL->yCompHi = sImeG.yStatusHi;//lpImeL->rcCompText.bottom +/* lpImeL->cyCompBorder*/3 * 2+1;//zl
  
        } else {

                // text position relative to the composition window
                lpImeL->rcCompText.left = 4;
                lpImeL->rcCompText.top = 4;
                lpImeL->rcCompText.right = sImeG.TextLen+5;
                lpImeL->rcCompText.bottom = sImeG.yStatusHi-4;//6;/*cyBorder;*/

                lpImeL->cxCompBorder = cxBorder;
                lpImeL->cyCompBorder = cyBorder;

                // set the width & height for composition window
                lpImeL->xCompWi = lpImeL->rcCompText.right + /*lpImeL->cxCompBorder*/3 * 2;  
                lpImeL->yCompHi = sImeG.yStatusHi;   //zl
  
        }


        // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) +
        GetSystemMetrics(SM_CXEDGE) /* 2*/;
    cyBorder = GetSystemMetrics(SM_CYBORDER) +
        GetSystemMetrics(SM_CYEDGE) /* 2*/;

        if (!WhatStyle){
            sImeG.rcCandText.left = 4;
                sImeG.rcCandText.top = 4;
                sImeG.rcCandText.right = sImeG.xChiCharWi * 7;
                sImeG.rcCandText.bottom = sImeG.yChiCharHi * CANDPERPAGE+1;//zl

                sImeG.cxCandBorder = cxBorder+3;
                sImeG.cyCandBorder = cyBorder+3;

                sImeG.xCandWi = sImeG.rcCandText.right + sImeG.cxCandBorder * 2+3;//zl
                sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder *2+12;

                sImeG.rcHome.left = 4 ;
                sImeG.rcHome.top = sImeG.rcCandText.bottom+6 ;
                sImeG.rcHome.right = sImeG.rcHome.left + 14 ;
                sImeG.rcHome.bottom = sImeG.rcHome.top +14 ;

                sImeG.rcEnd.left = sImeG.rcHome.right ;
                sImeG.rcEnd.top = sImeG.rcHome.top ;
                sImeG.rcEnd.right = sImeG.rcEnd.left + 14 ;
                sImeG.rcEnd.bottom = sImeG.rcHome.bottom ;

                sImeG.rcPageDown.top = sImeG.rcHome.top ;
                sImeG.rcPageDown.right = sImeG.xCandWi-4;
                sImeG.rcPageDown.left = sImeG.rcPageDown.right - 14 ;
                sImeG.rcPageDown.bottom = sImeG.rcHome.bottom ;

                sImeG.rcPageUp.top = sImeG.rcHome.top ;
                sImeG.rcPageUp.right = sImeG.rcPageDown.left ;
                sImeG.rcPageUp.left = sImeG.rcPageUp.right -14 ;
                sImeG.rcPageUp.bottom = sImeG.rcHome.bottom ;

        }else{
                sImeG.cxCandBorder = cxBorder;
                sImeG.cyCandBorder = cyBorder;

                sImeG.xCandWi = lpImeL->xCompWi + sImeG.xStatusWi - cxBorder+1;
                sImeG.yCandHi = sImeG.yStatusHi; //sImeG.yChiCharHi+3 + sImeG.cyCandBorder *2;

                sImeG.rcHome.left = 3;    //2;
                sImeG.rcHome.top =  4;//7;
                sImeG.rcHome.right = sImeG.rcHome.left + 10; //14;
                sImeG.rcHome.bottom = sImeG.rcHome.top +8;   //14 ;

                sImeG.rcEnd.left =sImeG.rcHome.left; //sImeG.rcHome.right ;
                sImeG.rcEnd.top = sImeG.rcHome.top+9;   //14 ;
                sImeG.rcEnd.right =sImeG.rcHome.right; //sImeG.rcEnd.left + 14 ;
                sImeG.rcEnd.bottom = sImeG.rcHome.bottom+10;  //14 ;
    
                sImeG.rcPageDown.top = sImeG.rcEnd.top;//sImeG.rcHome.top ;
                sImeG.rcPageDown.right = sImeG.xCandWi-1;//2;
                sImeG.rcPageDown.left = sImeG.rcPageDown.right - 14 ;
                sImeG.rcPageDown.bottom = sImeG.rcEnd.bottom ;//sImeG.rcHome.bottom ;

                sImeG.rcPageUp.top = sImeG.rcHome.top -1;        //zl
                sImeG.rcPageUp.right = sImeG.rcPageDown.right+1;//zl;sImeG.rcPageDown.left ;
                sImeG.rcPageUp.left = sImeG.rcPageDown.left;//sImeG.rcPageUp.right -14 ;
                sImeG.rcPageUp.bottom = sImeG.rcHome.bottom ;
   
                sImeG.rcCandText.left = sImeG.rcEnd.right+2;//1;//4;//sImeG.rcEnd.right;
                sImeG.rcCandText.top = 4;
                sImeG.rcCandText.right = sImeG.rcPageUp.left-4;//2;//sImeG.rcPageUp.left-2;
                sImeG.rcCandText.bottom = sImeG.yChiCharHi+7;//6;//3;
                
        }

        if (hWnd){  
                ptPos.x = 0 ;
                ptPos.y = 0 ;

                ClientToScreen(hWnd, &ptPos);

                lpImeL->ptDefComp.x =   ptPos.x + sImeG.xStatusWi - cxBorder*2+4;//zl  
                lpImeL->ptDefComp.y =   ptPos.y - cyBorder+3;//2;//3;  //zl
                lpImeL->ptDefCand.x = ptPos.x - cxBorder+3;  //zl
                lpImeL->ptDefCand.y = ptPos.y - sImeG.yCandHi-2+2;//zl

                if ((sImeG.rcWorkArea.right-lpImeL->ptDefComp.x -lpImeL->xCompWi)<10){
                        lpImeL->ptDefComp.x =   ptPos.x - lpImeL->xCompWi;
                        lpImeL->ptDefCand.x = lpImeL->ptDefComp.x ;
                }

                if ((ptPos.y - sImeG.yCandHi)< (sImeG.rcWorkArea.top+5))
                        lpImeL->ptDefCand.y = ptPos.y + sImeG.yStatusHi-4; //sImeG.yCandHi+2;    
        }else{
                
                ptPos.x = lpImeL->Ox ;
                ptPos.y = lpImeL->Oy ;

                lpImeL->ptDefComp.x = sImeG.xStatusWi - cxBorder*2;  
                lpImeL->ptDefComp.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
   
                lpImeL->ptDefCand.x = lpImeL->ptDefComp.x + lpImeL->xCompWi;
                lpImeL->ptDefCand.y = lpImeL->ptDefComp.y ;
        }         

        return  ;
}

/**********************************************************************/
/* InitUserSetting()                                                  */
/**********************************************************************/
int InitUserSetting(void)
{ 
        HKEY hKey,hFirstKey;
        DWORD dwSize, dx;
    int lRet;

    RegCreateKey(HKEY_CURRENT_USER, szRegNearCaret, &hFirstKey);

    RegCreateKey(hFirstKey, szAIABC, &hKey);

    RegCloseKey(hFirstKey);

        //1 KeyType
    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey, szKeyType, NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey,szKeyType , 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {

                sImeG.KbType =(BYTE)dx ;
        } 

// 2 ImeStyle  
        dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey,szImeStyle , NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey,szImeStyle, 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {
                lpImeL->wImeStyle = (WORD)dx ;
        } 

// 3 AutoCp

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey, szCpAuto, NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey,szCpAuto, 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {

                sImeG.auto_mode =(BYTE)dx ;
        } 


// 4  BxFlag

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey, szBxFlag , NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey, szBxFlag , 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {

                sImeG.cbx_flag =(BYTE)dx ;
        } 


// 5  TuneFlag

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey, szTuneFlag , NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey, szTuneFlag , 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {

                sImeG.tune_flag=(BYTE)dx ;
        }         


// 6  AutoCvt

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey, szAutoCvt , NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey, szAutoCvt, 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {

                sImeG.auto_cvt_flag=(BYTE)dx ;
        } 


// 7  SdaHelp

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKey,  szSdaHelp , NULL, NULL,
        (LPBYTE)&dx, &dwSize);
                                          
    if (lRet != ERROR_SUCCESS) {
        dx = 0;
        RegSetValueEx(hKey,  szSdaHelp, 0, REG_DWORD,
            (LPBYTE)&dx, sizeof(int));
    }else {
                sImeG.SdOpenFlag=(BYTE)dx ;
        } 


    RegCloseKey(hKey);
        //ReInitIme2(NULL, lpImeL->wImeStyle);
        return 0;
}


/**********************************************************************/
/* ChangeUserSetting()                                                  */
/**********************************************************************/
ChangeUserSetting()
{ 
        HKEY hKey,hFirstKey;
        DWORD dwSize, dx;
    int lRet;

    RegCreateKey(HKEY_CURRENT_USER, szRegNearCaret, &hFirstKey);

    RegCreateKey(hFirstKey, szAIABC, &hKey);

    RegCloseKey(hFirstKey);

    RegSetValueEx(hKey, szKeyType, 0, REG_DWORD,
        (LPBYTE)&sImeG.KbType, sizeof(int));

    RegSetValueEx(hKey, szImeStyle, 0, REG_DWORD,
        (LPBYTE)&lpImeL->wImeStyle, sizeof(int));

    RegSetValueEx(hKey, szCpAuto, 0, REG_DWORD,
        (LPBYTE)&sImeG.auto_mode, sizeof(int));

        RegSetValueEx(hKey, szBxFlag, 0, REG_DWORD,
        (LPBYTE)&sImeG.cbx_flag, sizeof(int));


    RegSetValueEx(hKey, szTuneFlag, 0, REG_DWORD,
        (LPBYTE)&sImeG.tune_flag, sizeof(int));

    RegSetValueEx(hKey, szAutoCvt, 0, REG_DWORD,
        (LPBYTE)&sImeG.auto_cvt_flag, sizeof(int));
        RegSetValueEx(hKey, szSdaHelp, 0, REG_DWORD,
        (LPBYTE)&sImeG.SdOpenFlag, sizeof(int));

    RegCloseKey(hKey);
        return 0;
}

/**********************************************************************/
/* InitImeGlobalData()                                                */
/**********************************************************************/
void PASCAL InitImeGlobalData(
    HINSTANCE hInstance)
{
    int     cxBorder, cyBorder;
    HDC     hDC;
    BYTE    szChiChar[4];
    SIZE    lTextSize;
    HGLOBAL hResData;
    int     i;
    DWORD   dwSize;
    HKEY    hKeyIMESetting;
    LONG    lRet;
    BYTE    NumChar[]="1.2.3.4.5.6.7.8.9.";
    BYTE    CNumChar[]="ԭϲһһ";
    SIZE    hSize;
                                                                   
    sImeG.WhitePen =  GetStockObject(WHITE_PEN);
    sImeG.BlackPen =  GetStockObject(BLACK_PEN);
    sImeG.GrayPen  =  CreatePen(PS_SOLID, 1, 0x00808080);
    sImeG.LightGrayPen  =  CreatePen(PS_SOLID, 1, 0x00c0c0c0);
    
    hInst = hInstance;
    // get the UI class name
    LoadString(hInst, IDS_IMEUICLASS, szUIClassName, sizeof(szUIClassName));


    // get the composition class name
    LoadString(hInst, IDS_IMECOMPCLASS, szCompClassName, sizeof(szCompClassName));

    // get the candidate class name
    LoadString(hInst, IDS_IMECANDCLASS, szCandClassName, sizeof(szCandClassName));


    // get the status class name
    LoadString(hInst, IDS_IMESTATUSCLASS, szStatusClassName, sizeof(szStatusClassName));

    // work area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) + GetSystemMetrics(SM_CXEDGE) /* 2*/;
    cyBorder = GetSystemMetrics(SM_CYBORDER) + GetSystemMetrics(SM_CYEDGE) /* 2*/;


    // get the Chinese char
    LoadString(hInst, IDS_CHICHAR, szChiChar, sizeof(szChiChar));

    // get size of Chinese char
    hDC = GetDC(NULL);
    GetTextExtentPoint32(hDC, "", 2, &lTextSize);
    if (sImeG.rcWorkArea.right < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.left = 0;
        sImeG.rcWorkArea.right = GetDeviceCaps(hDC, HORZRES);
    }
    if (sImeG.rcWorkArea.bottom < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.top = 0;
        sImeG.rcWorkArea.bottom = GetDeviceCaps(hDC, VERTRES);
    }

        GetTextExtentPoint32(hDC,(LPCTSTR)"2.", 2, &hSize);
        sImeG.Ajust = hSize.cx;

    // get text metrics to decide the width & height of composition window
    // these IMEs always use system font to show
        GetTextExtentPoint32(hDC,(LPCTSTR)&CNumChar, 20, &hSize);

        sImeG.TextLen = hSize.cx +2;//zl
    sImeG.xChiCharWi = lTextSize.cx;
    sImeG.yChiCharHi = lTextSize.cy;

        
          // the width/high and status position relative to status window
    sImeG.rcStatusText.left = 0;
    sImeG.rcStatusText.top = 0;
    sImeG.rcStatusText.right = STATUS_DIM_X * 5+6+20;//4;       // chg
    sImeG.rcStatusText.bottom = STATUS_DIM_Y;

    sImeG.xStatusWi = STATUS_DIM_X * 5 + cxBorder * 2+3+18 ; //chg
        if(sImeG.yChiCharHi==0x10)
                sImeG.yStatusHi = STATUS_DIM_Y + cyBorder * 2-1;        //zl
        else
            sImeG.yStatusHi = STATUS_DIM_Y + cyBorder * 2-1+2;

    // left bottom of status
    sImeG.rcInputText.left = sImeG.rcStatusText.left+3;//2;     //zl
    sImeG.rcInputText.top = sImeG.rcStatusText.top ;  //zl
    sImeG.rcInputText.right = sImeG.rcInputText.left + STATUS_DIM_X; //z
    sImeG.rcInputText.bottom = sImeG.rcStatusText.bottom;


    // no. 2 bottom of status
    sImeG.rcCmdText.left = sImeG.rcInputText.right+1;//95.9.23+1;
    sImeG.rcCmdText.top = sImeG.rcStatusText.top -1;       //zl
    sImeG.rcCmdText.right = sImeG.rcCmdText.left + STATUS_DIM_X+20; //zl
    sImeG.rcCmdText.bottom = sImeG.rcStatusText.bottom;

    // no. 3 bottom of status
    sImeG.rcShapeText.left =sImeG.rcCmdText.right;//+1; 
    sImeG.rcShapeText.top = sImeG.rcStatusText.top - 1;          //zl
    sImeG.rcShapeText.right = sImeG.rcShapeText.left + STATUS_DIM_X; //zl
    sImeG.rcShapeText.bottom = sImeG.rcStatusText.bottom;
  

    // no 4 bottom of status
  
    sImeG.rcPctText.left =sImeG.rcShapeText.right;
    sImeG.rcPctText.top = sImeG.rcStatusText.top -1;     //zl
    sImeG.rcPctText.right = sImeG.rcPctText.left + STATUS_DIM_X; //zl
    sImeG.rcPctText.bottom = sImeG.rcStatusText.bottom;

  
        //        5
    // right bottom of status
    sImeG.rcSKText.left = sImeG.rcPctText.right;
    sImeG.rcSKText.top = sImeG.rcStatusText.top - 1;
    sImeG.rcSKText.right = sImeG.rcSKText.left + STATUS_DIM_X; //zl
    sImeG.rcSKText.bottom = sImeG.rcStatusText.bottom;


  
    // full shape space
    sImeG.wFullSpace = sImeG.wFullABC[0];

    // reverse internal code to internal code, NT don't need it
    for (i = 0; i < (sizeof(sImeG.wFullABC) / 2); i++) {
        sImeG.wFullABC[i] = (sImeG.wFullABC[i] << 8) |
            (sImeG.wFullABC[i] >> 8);
    }

    LoadString(hInst, IDS_STATUSERR, sImeG.szStatusErr,
        sizeof(sImeG.szStatusErr));
    sImeG.cbStatusErr = lstrlen(sImeG.szStatusErr);

    sImeG.iCandStart = CAND_START;
        
        sImeG.Prop = 0;

     // get the UI offset for near caret operation
    RegCreateKey(HKEY_CURRENT_USER, szRegIMESetting, &hKeyIMESetting);

    dwSize = sizeof(dwSize);
    lRet  = RegQueryValueEx(hKeyIMESetting, szPara, NULL, NULL,
        (LPBYTE)&sImeG.iPara, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPara = 0;
        RegSetValueEx(hKeyIMESetting, szPara, (DWORD)0, REG_BINARY,
            (LPBYTE)&sImeG.iPara, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyIMESetting, szPerp, NULL, NULL,
        (LPBYTE)&sImeG.iPerp, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerp = sImeG.yChiCharHi;
        RegSetValueEx(hKeyIMESetting, szPerp, (DWORD)0, REG_BINARY,
            (LPBYTE)&sImeG.iPerp, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyIMESetting, szParaTol, NULL, NULL,
        (LPBYTE)&sImeG.iParaTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iParaTol = sImeG.xChiCharWi * 4;
        RegSetValueEx(hKeyIMESetting, szParaTol, (DWORD)0, REG_BINARY,
            (LPBYTE)&sImeG.iParaTol, sizeof(int));
    }

    dwSize = sizeof(dwSize);
    lRet = RegQueryValueEx(hKeyIMESetting, szPerpTol, NULL, NULL,
        (LPBYTE)&sImeG.iPerpTol, &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerpTol = lTextSize.cy;
        RegSetValueEx(hKeyIMESetting, 
                      szPerpTol, 
                      (DWORD)0, 
                      REG_BINARY,
                      (LPBYTE)&sImeG.iPerpTol, 
                      sizeof(int));
    }

    RegCloseKey(hKeyIMESetting);
    ReleaseDC(NULL, hDC);

    return;
}

/**********************************************************************/
/* InitImeLocalData()                                                 */
/**********************************************************************/
BOOL PASCAL InitImeLocalData(
    HINSTANCE hInstL)
{

    HGLOBAL  hResData;
    int      cxBorder, cyBorder;

    register int    i;
    register WORD   nSeqCode;

    lpImeL->hInst = hInstL;

    // load valid char in choose/input state
    lpImeL->nMaxKey = 20 ; 

    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER) +
        GetSystemMetrics(SM_CXEDGE) * 2;
    cyBorder = GetSystemMetrics(SM_CYBORDER) +
        GetSystemMetrics(SM_CYEDGE) * 2;

    // text position relative to the composition window
    lpImeL->rcCompText.left = 3;
    lpImeL->rcCompText.top = 3;
    lpImeL->rcCompText.right = sImeG.xChiCharWi * lpImeL->nMaxKey/2+3;
    lpImeL->rcCompText.bottom = sImeG.yChiCharHi+3;

    lpImeL->cxCompBorder = cxBorder;
    lpImeL->cyCompBorder = cyBorder;

    // set the width & height for composition window
    lpImeL->xCompWi = lpImeL->rcCompText.right + /*lpImeL->cxCompBorder*/3 * 2;
    lpImeL->yCompHi = lpImeL->rcCompText.bottom +/* lpImeL->cyCompBorder*/3 * 2;

    // default position of composition window
    lpImeL->ptDefComp.x = sImeG.rcWorkArea.right -
        lpImeL->yCompHi - cxBorder;
    lpImeL->ptDefComp.y = sImeG.rcWorkArea.bottom -
        lpImeL->xCompWi - cyBorder;

        lpImeL->Ox =  lpImeL->ptDefComp.x;
        lpImeL->Oy =  lpImeL->ptDefComp.y;

        return (TRUE);
}

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
void PASCAL RegisterImeClass(
    HINSTANCE hInstance,
    HINSTANCE hInstL)
{
    WNDCLASSEX wcWndCls;

    // IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(LONG) * 2; 
    wcWndCls.hIcon         = LoadImage(hInstL, MAKEINTRESOURCE(IDI_IME),
        IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
    wcWndCls.hInstance     = hInstance;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH/*NULL_BRUSH*/);
    wcWndCls.lpszMenuName  = (LPSTR)NULL;
    wcWndCls.hIconSm       = LoadImage(hInstL, MAKEINTRESOURCE(IDI_IME),
        IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

    // IME UI class
    if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
        wcWndCls.style         = CS_IME;
        wcWndCls.lpfnWndProc   = UIWndProc;
        wcWndCls.lpszClassName = (LPSTR)szUIClassName;

        RegisterClassEx(&wcWndCls);
    }

    wcWndCls.style         = CS_IME|CS_HREDRAW|CS_VREDRAW;


    // IME composition class
    if (!GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = CompWndProc;
        wcWndCls.lpszClassName = (LPSTR)szCompClassName;

        RegisterClassEx(&wcWndCls);
    }

    // IME candidate class
    if (!GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = CandWndProc;
            wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    
        wcWndCls.lpszClassName = (LPSTR)szCandClassName;

        RegisterClassEx(&wcWndCls);
    }


    // IME status class
    if (!GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
        wcWndCls.lpfnWndProc   = StatusWndProc;
        wcWndCls.lpszClassName = (LPSTR)szStatusClassName;

        RegisterClassEx(&wcWndCls);
    }

    if (!GetClassInfoEx(hInstance, "Abc95Menu", &wcWndCls)) {
        wcWndCls.style         = 0;
        wcWndCls.cbWndExtra    = WND_EXTRA_SIZE; 
        wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
        wcWndCls.lpfnWndProc   = ContextMenuWndProc;
        wcWndCls.lpszClassName = "Abc95Menu";

        RegisterClassEx(&wcWndCls);
        }

    return;
}

/**********************************************************************/
/* QuitBefore()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/

int WINAPI QuitBefore()
{
        GlobalUnlock(cisu_hd);
        if(cisu_hd)
                GlobalFree(cisu_hd);
        return 0;
}

/**********************************************************************/
/* ImeDllInit()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/
BOOL CALLBACK ImeDllInit(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    // DebugShow("Init Stat",NULL);

    switch (fdwReason) {
            case DLL_PROCESS_ATTACH:

                    if (!hInst) {
                            InitImeGlobalData(hInstance);
 //                         data_init();  /* move to the Select( )  to avoid app hang */
                    }
        
                    if (!lpImeL) {
                           lpImeL = &sImeL;
                           InitImeLocalData(hInstance);
                    }

                    InitUserSetting();
                    RegisterImeClass(hInstance, hInstance);
                    break;
            case DLL_PROCESS_DETACH:
                {
                    WNDCLASSEX wcWndCls;

                    DeleteObject (sImeG.WhitePen);
                    DeleteObject (sImeG.BlackPen);
                    DeleteObject (sImeG.GrayPen);
                    DeleteObject (sImeG.LightGrayPen);

                    QuitBefore();
                    if (GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
                       UnregisterClass(szStatusClassName, hInstance);
                    }

                    if (GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
                       UnregisterClass(szCandClassName, hInstance);
                    }

                    if (GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
                       UnregisterClass(szCompClassName, hInstance);
                    }

                    if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
                    } else if (!UnregisterClass(szUIClassName, hInstance)) {
                           } else {
                                 DestroyIcon(wcWndCls.hIcon);
                                 DestroyIcon(wcWndCls.hIconSm);
                           }
                    break;
               }
            default:
                    break;                                                                                                                 
    }

    return (TRUE);
}

/**********************************************************************/
/* GenerateMessage2()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage2(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    LPTRANSMSG lpMsgBuf;
    HIMCC   hMem;
    BOOL    bCantReSize;

    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    bCantReSize = FALSE;

    if (!lpIMC->hMsgBuf) {
        // it maybe free by IME, up to GEN_MSG_MAX messages for max case
        lpIMC->hMsgBuf = ImmCreateIMCC(GEN_MSG_MAX * sizeof(TRANSMSG));
    } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf, (lpIMC->dwNumMsgBuf
        + GEN_MSG_MAX) * sizeof(TRANSMSG))) {
        lpIMC->hMsgBuf = hMem;
    } else {
        bCantReSize = TRUE;
    }

    if (!lpIMC->hMsgBuf) {
        lpIMC->dwNumMsgBuf = 0;
        return;
    }

    lpMsgBuf = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
    if (!lpMsgBuf) {
        return;
    }

    if (bCantReSize) {
        LPTRANSMSG lpNewBuf;

        hMem = ImmCreateIMCC((lpIMC->dwNumMsgBuf + GEN_MSG_MAX) *
            sizeof(TRANSMSG));
        if (!hMem) {
            ImmUnlockIMCC(lpIMC->hMsgBuf);
            return;
        }

        lpNewBuf = (LPTRANSMSG)ImmLockIMCC(hMem);
        if (!lpMsgBuf) {
            ImmUnlockIMCC(lpIMC->hMsgBuf);
            return;
        }

        CopyMemory(lpNewBuf, lpMsgBuf, lpIMC->dwNumMsgBuf *
            sizeof(TRANSMSG));

        ImmUnlockIMCC(lpIMC->hMsgBuf);
        ImmDestroyIMCC(lpIMC->hMsgBuf);

        lpIMC->hMsgBuf = hMem;
        lpMsgBuf = lpNewBuf;
    }

    if(TypeOfOutMsg){

        lpIMC->dwNumMsgBuf += TransAbcMsg2(lpMsgBuf, lpImcP); 
    }else{
        lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);
    }

    // lpIMC->dwNumMsgBuf += TransAbcMsg(lpMsgBuf, lpImcP,lpIMC,0,0,0);

    ImmUnlockIMCC(lpIMC->hMsgBuf);

    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag &= (GCS_RESULTREAD|GCS_RESULT);     // ?

    ImmGenerateMessage(hIMC);
    return;
}

/**********************************************************************/
/* GenerateMessage()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    LPTRANSMSG lpMsgBuf;
    HIMCC   hMem;
    BOOL    bCantReSize;

    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    bCantReSize = FALSE;

    if (!lpIMC->hMsgBuf) {
        // it maybe free by IME, up to GEN_MSG_MAX messages for max case
        lpIMC->hMsgBuf = ImmCreateIMCC(GEN_MSG_MAX * sizeof(TRANSMSG));
    } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf, (lpIMC->dwNumMsgBuf
        + GEN_MSG_MAX) * sizeof(TRANSMSG))) {
        lpIMC->hMsgBuf = hMem;
    } else {
        bCantReSize = TRUE;
    }

    if (!lpIMC->hMsgBuf) {
        lpIMC->dwNumMsgBuf = 0;
        return;
    }

    lpMsgBuf = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
    if (!lpMsgBuf) {
        return;
    }

    if (bCantReSize) {
        LPTRANSMSG lpNewBuf;

        hMem = ImmCreateIMCC((lpIMC->dwNumMsgBuf + GEN_MSG_MAX) *
            sizeof(TRANSMSG));
        if (!hMem) {
            ImmUnlockIMCC(lpIMC->hMsgBuf);
            return;
        }

        lpNewBuf = (LPTRANSMSG)ImmLockIMCC(hMem);
        if (!lpMsgBuf) {
            ImmUnlockIMCC(lpIMC->hMsgBuf);
            return;
        }

        CopyMemory(lpNewBuf, lpMsgBuf, lpIMC->dwNumMsgBuf *
            sizeof(TRANSMSG));

        ImmUnlockIMCC(lpIMC->hMsgBuf);
        ImmDestroyIMCC(lpIMC->hMsgBuf);

        lpIMC->hMsgBuf = hMem;
        lpMsgBuf = lpNewBuf;
    }

    lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hMsgBuf);

    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag &= (GCS_RESULTREAD|GCS_RESULT);     // ?

    ImmGenerateMessage(hIMC);
    return;
}

/**********************************************************************/
/* SetString()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetString(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPSTR               lpszRead,
    DWORD               dwReadLen)
{
    DWORD dwPattern;
    DWORD i;

    if (dwReadLen > (lpImeL->nMaxKey * sizeof(WORD)+20)) {
        return (FALSE);
    }

    // compoition/reading attribute
    lpCompStr->dwCompReadAttrLen = dwReadLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompReadAttrLen;
    for (i = 0; i < dwReadLen; i++) {   // The IME has converted these chars
        *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset + i) =
            ATTR_TARGET_CONVERTED;
    }

    // composition/reading clause, 1 clause only
    lpCompStr->dwCompReadClauseLen = 2 * sizeof(DWORD);
    lpCompStr->dwCompClauseLen = lpCompStr->dwCompReadClauseLen;
    *(LPUNADWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD)) = dwReadLen;

    lpCompStr->dwCompReadStrLen = dwReadLen;
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;
    CopyMemory((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset, lpszRead,
        dwReadLen);

    // dlta start from 0;
    lpCompStr->dwDeltaStart = 0;
    // cursor is next to composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    // set private input context
    lpImcP->iImeState = CST_INPUT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
   //zst lpImcP->dwCompChar = (DWORD)lpImeL->wSeq2CompTbl[
 //zst       lpImcP->bSeq[lpCompStr->dwCompReadStrLen / 2 - 1]];
    lpImcP->dwCompChar = HIBYTE(lpImcP->dwCompChar) |
        (LOBYTE(lpImcP->dwCompChar) << 8);
    lpImcP->fdwGcsFlag = GCS_COMPREAD|GCS_COMP|
        GCS_DELTASTART|GCS_CURSORPOS;

    if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        if (lpCompStr->dwCompReadStrLen >= sizeof(WORD) * lpImeL->nMaxKey) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
            lpImcP->fdwGcsFlag |= GCS_RESULTREAD|GCS_RESULTSTR;
        }
    } else {
        if (dwReadLen < sizeof(WORD) * lpImeL->nMaxKey) {
            // quick key
            if (lpImeL->fModeConfig & MODE_CONFIG_QUICK_KEY) {
                                //zst  Finalize(lpIMC, lpCompStr, lpImcP, FALSE);
            }

        } else {
            UINT        nCand;
            LPGUIDELINE lpGuideLine;

       //zst     nCand = Finalize(lpIMC, lpCompStr, lpImcP, TRUE);

            if (!lpIMC->hGuideLine) {
                goto SeStGenMsg;
            }

            lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

            if (!lpGuideLine) {
                goto SeStGenMsg;
            /*
                        } else if (nCand == 1) {
            } else if (nCand > 1) {
                        */
            } else {
                // nothing found, end user, you have an error now

                lpGuideLine->dwLevel = GL_LEVEL_ERROR;
                lpGuideLine->dwIndex = GL_ID_TYPINGERROR;

                lpImcP->fdwImeMsg |= MSG_GUIDELINE;
            }

            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
    }


SeStGenMsg:

    GenerateMessage(hIMC, lpIMC, lpImcP);

    return (TRUE);
}

/**********************************************************************/
/* CompEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CompEscapeKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    if (!lpGuideLine) {
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
    } else {
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        lpGuideLine->dwStrLen = 0;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    }

    if (lpImcP->iImeState != CST_INIT) {
    } else if (lpCompStr->dwCompStrLen) {
        // clean the compose string
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
            ~(MSG_START_COMPOSITION);
    } else {
    }

    lpImcP->iImeState = CST_INIT;
   // *(LPDWORD)lpImcP->bSeq = 0;

   // lpImcP->wPhraseNextOffset = lpImcP->wWordNextOffset = 0;

        InitCvtPara();
        if (lpCompStr) {         
        InitCompStr(lpCompStr);
        lpImcP->fdwImeMsg |= MSG_END_COMPOSITION;
        lpImcP->dwCompChar = VK_ESCAPE;
        lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART);
    }
   
    return;
}


/**********************************************************************/
/* CandEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CandEscapeKey(
    LPINPUTCONTEXT  lpIMC,
    LPPRIVCONTEXT   lpImcP)
{
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;

    // clean all candidate information
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        ClearCand(lpIMC);
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    lpImcP->iImeState = CST_INPUT;

    // if it start composition, we need to clean composition
    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}



/**********************************************************************/
/* CompCancel()                                                       */
/**********************************************************************/
void PASCAL CompCancel(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    if (!lpIMC->hPrivate) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwGcsFlag = (DWORD)0;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        CandEscapeKey(lpIMC, lpImcP);
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

        if ( lpCompStr && lpGuideLine )
            CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

        ImmUnlockIMCC(lpIMC->hGuideLine);
        ImmUnlockIMCC(lpIMC->hCompStr);
    } else {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }
    lpImcP->fdwImeMsg |= MSG_COMPOSITION; //#52224
    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
        InitCvtPara();
    return;
}


/**********************************************************************/
/* ImeSetCompositionString()                                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(
    HIMC   hIMC,
    DWORD  dwIndex,
    LPVOID lpComp,
    DWORD  dwCompLen,
    LPVOID lpRead,
    DWORD  dwReadLen)
{

    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    BOOL                fRet;

    if (!hIMC) {
        return (FALSE);
    }

    // composition string must  == reading string
    // reading is more important
    if (!dwReadLen) {
        dwReadLen = dwCompLen;
    }

    // composition string must  == reading string
    // reading is more important
    if (!lpRead) {
        lpRead = lpComp;
    }

    if (!dwReadLen) {
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        CompCancel(hIMC, lpIMC);
        ImmUnlockIMC(hIMC);
        return (TRUE);
    } else if (!lpRead) {
        return (FALSE);
    } else if (!dwCompLen) {
    } else if (!lpComp) {
    } else if (dwReadLen != dwCompLen) {
        return (FALSE);
    } else if (lpRead == lpComp) {
    } else if (!lstrcmp(lpRead, lpComp)) {
        // composition string must  == reading string
    } else {
        // composition string != reading string
        return (FALSE);
    }

    if (dwIndex != SCS_SETSTR) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);

    fRet = SetString(hIMC, lpIMC, lpCompStr, lpImcP, lpRead, dwReadLen);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);

    return (fRet);

}


/**********************************************************************/
/* ToggleSoftKbd()                                                    */
/**********************************************************************/
void PASCAL ToggleSoftKbd(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* NotifySelectCand()                                                 */
/**********************************************************************/
void PASCAL NotifySelectCand( // app tell IME that one candidate string is
                              // selected (by mouse or non keyboard action
                              // - for example sound)
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    DWORD           dwIndex,
    DWORD           dwValue)
{

    LPPRIVCONTEXT       lpImcP;

    if (!lpCandInfo) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
 
    CharProc((WORD)dwValue,0,0,hIMC,lpIMC,lpImcP);

    GenerateMessage2(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}


/**********************************************************************/
/* NotifySetMode()                                                 */
/**********************************************************************/
void PASCAL NotifySetMode( 
    HIMC            hIMC)
{
        LPINPUTCONTEXT        lpIMC;
    LPPRIVCONTEXT       lpImcP;

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if(!lpIMC) return ;    

    
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP){
                ImmUnlockIMC(hIMC);
                return ; 
        }
        
    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* GenerateImeMessage()                                               */
/**********************************************************************/
void PASCAL GenerateImeMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          fdwImeMsg)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= fdwImeMsg;

    if (fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE);
    } else {
    }

    if (fdwImeMsg & MSG_END_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_START_COMPOSITION);
    } else if (fdwImeMsg & MSG_START_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    } else {
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}



/**********************************************************************/
/* NotifyIME()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI NotifyIME(
    HIMC  hIMC,
    DWORD dwAction,
    DWORD dwIndex,
    DWORD dwValue)
{
    LPINPUTCONTEXT  lpIMC;
        DWORD           fdwImeMsg;
        LPPRIVCONTEXT   lpImcP;

    if (!hIMC) {
        return (TRUE);
    }

    switch (dwAction) {
    case NI_OPENCANDIDATE:      // after a composition string is determined
                                // if an IME can open candidate, it will.
                                // if it can not, app also can not open it.
    case NI_CLOSECANDIDATE:
        return (FALSE);
    case NI_SELECTCANDIDATESTR:

        break;                  // need to handle it

    case NI_CHANGECANDIDATELIST:
        return (TRUE);          // not important to the IME
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
        case IMC_SETSENTENCEMODE:
        case IMC_SETOPENSTATUS:
            break;              // need to handle it
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            return (TRUE);      // not important to the IME
        default:
            return (FALSE);     // not supported
        }
        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {


        case CPS_CONVERT:       // all composition string can not be convert
        case CPS_REVERT:        // any more, it maybe work for some
                                // intelligent phonetic IMEs
            return (FALSE);
        case CPS_CANCEL:
            break;              // need to handle it

        default:
            return (FALSE);     // not supported
        }
        break;                  // need to handle it
    default:
        return (FALSE);         // not supported
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    switch (dwAction) {
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
                 
            if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_FULLSHAPE) {
                break;
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SOFTKBD) {

                ToggleSoftKbd(hIMC, lpIMC);

                if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_SOFTKBD) {
                    break;
                }
            }

            if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_NATIVE) {
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_EUDC);
            }

           // if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_CHARCODE) {
           //     lpIMC->fdwConversion &= ~(IME_CMODE_EUDC);
           // }


            CompCancel(hIMC, lpIMC);

            break;
                /*
        if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_CHARCODE) {
                // reject CHARCODE
                lpIMC->fdwConversion &= ~IME_CMODE_CHARCODE;
                MessageBeep((UINT)-1);
                break;
            }

            fdwImeMsg = 0;

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_NOCONVERSION) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_EUDC) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_SYMBOL);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SOFTKBD) {
                LPPRIVCONTEXT lpImcP;

                if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
                    MessageBeep((UINT)-1);
                    break;
                }

                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

                if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                    lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
                } else {
                }

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    goto NotifySKOvr;
                }

                if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                    // now we already in soft keyboard state by
                    // this change

                    // even end user finish the symbol, we should not
                    // turn off soft keyboard

                    lpImcP->fdwImeMsg |= MSG_ALREADY_SOFTKBD;
                } else {
                    // now we are not in soft keyboard state by
                    // this change

                    // after end user finish the symbol, we should
                    // turn off soft keyboard

                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_SOFTKBD);
                }

                ImmUnlockIMCC(lpIMC->hPrivate);
NotifySKOvr:
                ;   // NULL statement for goto
            }

            if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_NATIVE) {
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_EUDC|IME_CMODE_SYMBOL);
                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SYMBOL) {
                LPCOMPOSITIONSTRING lpCompStr;
                LPPRIVCONTEXT       lpImcP;

                if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
                    lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
                    MessageBeep((UINT)-1);
                    break;
                }

                if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
                    lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
                    lpIMC->fdwConversion |= (dwIndex & IME_CMODE_SYMBOL);
                    MessageBeep((UINT)-1);
                    break;
                }

                lpCompStr = ImmLockIMCC(lpIMC->hCompStr);

                if (lpCompStr) {
                    if (!lpCompStr->dwCompStrLen) {
                    } else if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                        // if there is a string we could not change
                        // to symbol mode
                        lpIMC->fdwConversion &= ~(IME_CMODE_SYMBOL);
                        MessageBeep((UINT)-1);
                        break;
                    } else { 
                    }

                    ImmUnlockIMCC(lpIMC->hCompStr);
                }

                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_EUDC);

                if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                    lpIMC->fdwConversion |= IME_CMODE_SOFTKBD;
                } else if (lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate)) {
                    // we borrow the bit for this usage
                    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_SOFTKBD)) {
                        lpIMC->fdwConversion &= ~(IME_CMODE_SOFTKBD);
                    }

                    ImmUnlockIMCC(lpIMC->hPrivate);
                } else {
                }

                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
            }

            if (fdwImeMsg) {
                                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                                if(!lpImcP){
                                   lpImcP->fdwImeMsg = lpImcP->fdwImeMsg &~(MSG_IN_IMETOASCIIEX);
                                     }
                                 ImmUnlockIMCC(lpIMC->hPrivate);
                                 ImmUnlockIMC(hIMC);

                GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
           
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & ~(IME_CMODE_FULLSHAPE|
                IME_CMODE_SOFTKBD)) {
            } else {
                break;
            }

            CompCancel(hIMC, lpIMC);
            break;
                                         */
        case IMC_SETOPENSTATUS:

            CompCancel(hIMC, lpIMC);

            break;
        default:
            break;
        }
        break;

    case NI_SELECTCANDIDATESTR:
        if (!lpIMC->fOpen) {
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            break;
        } else if (!lpIMC->hCandInfo) {
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

            NotifySelectCand(hIMC, lpIMC, lpCandInfo, dwIndex, dwValue);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_CANCEL:
            CompCancel(hIMC, lpIMC);
            break;
        default:
            break;
        }
        break;

    default:
        break;
    }

    ImmUnlockIMC(hIMC);
    return (TRUE);
}  

/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeRegisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{

    return (0);
}



/**********************************************************************/
/* ImeUnregsisterWord                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeUnregisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{

    return (0);
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle                                           */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
UINT WINAPI ImeGetRegisterWordStyle(
    UINT       nItem,
    LPSTYLEBUF lpStyleBuf)
{

    return (1);
}


/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{

    return (0);
}
                                                                                                                        

/**********************************************************************/
/* GetStatusWnd                                                       */
/* Return Value :                                                     */
/*      window handle of status window                                */
/**********************************************************************/
HWND PASCAL GetStatusWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return (HWND)NULL;
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

 /**********************************************************************/
/* SetStatusWindowPos()                                               */
/**********************************************************************/
LRESULT PASCAL SetStatusWindowPos(
    HWND   hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    RECT           rcStatusWnd;
    POINT          ptPos;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {           // Oh! Oh!
        return (1L);
    }

    GetWindowRect(hStatusWnd, &rcStatusWnd);
        
        //DebugShow2( "ptPos=",lpIMC->ptStatusWndPos.x,"ptPos.y", rcStatusWnd.left);
    if (lpIMC->ptStatusWndPos.x != rcStatusWnd.left) {
    } else if (lpIMC->ptStatusWndPos.y != rcStatusWnd.top) {
    } else {
        ImmUnlockIMC(hIMC);
        return (0L);
    }
        //DebugShow2( "ptPos111=",NULL,"ptPos.y",NULL);
        // ptPos = lpIMC->ptStatusWndPos;

    // display boundary adjust
    
    ptPos.x = lpIMC->ptStatusWndPos.x;
    ptPos.y = lpIMC->ptStatusWndPos.y;
 
    
    AdjustStatusBoundary(&ptPos);
    
    SetWindowPos(hStatusWnd, NULL,
        ptPos.x, ptPos.y,
        0, 0, /*SWP_SHOWWINDOW|*/SWP_NOACTIVATE/*|SWP_NOCOPYBITS*/|SWP_NOSIZE|SWP_NOZORDER);

        CountDefaultComp(ptPos.x,ptPos.y,sImeG.rcWorkArea);
    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* CountDefaultComp()                                                       */
/**********************************************************************/
int CountDefaultComp(int x, int y, RECT Area)
{
POINT  Comp,Cand;

        Comp.x = lpImeL->ptZLComp.x;
        Comp.y = lpImeL->ptZLComp.y;
        Cand.x = lpImeL->ptZLCand.x;
        Cand.y = lpImeL->ptZLCand.y;
                                                                                                                         
        lpImeL->ptZLComp.x = x  + sImeG.xStatusWi+4;
        lpImeL->ptZLComp.y      = y;
        if ((Area.right-lpImeL->ptZLComp.x -lpImeL->xCompWi)<10){
                lpImeL->ptZLComp.x = x - lpImeL->xCompWi-4;
        }
        
        //      lpImeL->ptZLCand.x = lpImeL->ptZLComp.x - lpImeL->xCandWi -4;}
        
        return 0;
}

/**********************************************************************/
/* ShowStatus()                                                       */
/**********************************************************************/
void PASCAL ShowStatus(         // Show the status window - shape / soft KBD
                                // alphanumeric ...
    HWND hUIWnd,
    int  nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    if (!lpUIPrivate->hStatusWnd) {
        // not in show status window mode
    } else if (lpUIPrivate->nShowStatusCmd != nShowStatusCmd) {

                RECT Area;
           
                SystemParametersInfo(SPI_GETWORKAREA, 0, &Area, 0);
                if((sImeG.rcWorkArea.bottom != Area.bottom)
                 ||(sImeG.rcWorkArea.top != Area.top)
                 ||(sImeG.rcWorkArea.left != Area.left)
                 ||(sImeG.rcWorkArea.right != Area.right))
                {
                        HIMC hIMC;
                        LPINPUTCONTEXT lpIMC;

                        hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                        if(hIMC){
                                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                                if (lpIMC){
                                        if (((lpIMC->ptStatusWndPos.y + sImeG.yStatusHi)==sImeG.rcWorkArea.bottom)
                                                ||((lpIMC->ptStatusWndPos.y + sImeG.yStatusHi)>Area.bottom)){ 
                                                        lpIMC->ptStatusWndPos.y = Area.bottom - sImeG.yStatusHi;
                                        } else if ((lpIMC->ptStatusWndPos.y ==sImeG.rcWorkArea.top)
                                                ||(lpIMC->ptStatusWndPos.y < Area.top)){ 
                                                        lpIMC->ptStatusWndPos.y = Area.top;
                                        }
                                                                
                                        if ((lpIMC->ptStatusWndPos.x==sImeG.rcWorkArea.left)
                                                ||(lpIMC->ptStatusWndPos.x<Area.left)){ 
                                                        lpIMC->ptStatusWndPos.x = Area.left;
                                        }else if (((lpIMC->ptStatusWndPos.x + sImeG.xStatusWi)==sImeG.rcWorkArea.right)
                                                ||((lpIMC->ptStatusWndPos.x + sImeG.xStatusWi)>Area.right)){ 
                                                        lpIMC->ptStatusWndPos.x = Area.right - sImeG.xStatusWi;
                                        }

                                        SetWindowPos(lpUIPrivate->hStatusWnd, NULL,
                                                lpIMC->ptStatusWndPos.x,
                            lpIMC->ptStatusWndPos.y,
                        0, 0,
                        SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
                                    CountDefaultComp(lpIMC->ptStatusWndPos.x,lpIMC->ptStatusWndPos.y,Area);
                                    ImmUnlockIMC(hIMC);
                
                                        sImeG.rcWorkArea.bottom = Area.bottom;
                                        sImeG.rcWorkArea.top = Area.top;
                                        sImeG.rcWorkArea.left = Area.left;
                                        sImeG.rcWorkArea.right = Area.right;
                        }
                        }                 
        }
                ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);
                lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
        } else {
        }

        GlobalUnlock(hUIPrivate);
        return;
}

/**********************************************************************/
/* OpenStatus()                                                       */
/**********************************************************************/
void PASCAL OpenStatus(         // open status window
    HWND hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptPos;
    int            nShowStatusCmd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        ptPos.x = sImeG.rcWorkArea.left;
        ptPos.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
        nShowStatusCmd = SW_HIDE;
    } else if (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) {
        if (lpIMC->ptStatusWndPos.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (lpIMC->ptStatusWndPos.x + sImeG.xStatusWi >
            sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                sImeG.xStatusWi;
        }

        if (lpIMC->ptStatusWndPos.y < sImeG.rcWorkArea.top) {
            lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.top;
        } else if (lpIMC->ptStatusWndPos.y + sImeG.yStatusHi >
            sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
                sImeG.yStatusHi;
        }
        ptPos.x = lpIMC->ptStatusWndPos.x;
        ptPos.y = lpIMC->ptStatusWndPos.y,
        ImmUnlockIMC(hIMC);
        nShowStatusCmd = SW_SHOWNOACTIVATE;
    } else {
        ptPos.x = sImeG.rcWorkArea.left;
        ptPos.y = sImeG.rcWorkArea.bottom - sImeG.yStatusHi;
        nShowStatusCmd = SW_HIDE;
    }

    if (lpUIPrivate->hStatusWnd) {
        SetWindowPos(lpUIPrivate->hStatusWnd, NULL,
            ptPos.x, ptPos.y,
            0, 0,
            SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {                            // create status window
        lpUIPrivate->hStatusWnd = CreateWindowEx(
            0,
            szStatusClassName, NULL, WS_POPUP|WS_DISABLED/*|WS_BORDER*/, 
            ptPos.x, ptPos.y,
            sImeG.xStatusWi, sImeG.yStatusHi,
            hUIWnd, (HMENU)NULL, hInst, NULL);

        if ( lpUIPrivate->hStatusWnd ) 
        {

            ReInitIme(lpUIPrivate->hStatusWnd, lpImeL->wImeStyle); //#@2
            SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET,
                WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);
        }
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* DestroyStatusWindow()                                              */
/**********************************************************************/
void PASCAL DestroyStatusWindow(
    HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* SetStatus                                                          */
/**********************************************************************/
void PASCAL SetStatus(
    HWND    hStatusWnd,
    LPPOINT lpptCursor)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->fOpen) {
        ImmSetOpenStatus(hIMC, TRUE);
    } else if (PtInRect(&sImeG.rcInputText, *lpptCursor)) {

                DWORD fdwConversion;
        if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
            // change to alphanumeric mode
            fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_NATIVE );

                        { 
                    LPPRIVCONTEXT lpImcP;
                        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                    
                    ghIMC=hIMC;   
                glpIMCP=lpImcP;
                glpIMC=lpIMC;
            lpImcP->fdwImeMsg=lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX; 
            cls_prompt();
                        InitCvtPara();
                        GenerateMessage(hIMC, lpIMC, lpImcP);
                        ImmUnlockIMCC(lpIMC->hPrivate);
                        }
        } else {

                        if(lpIMC->fdwConversion & IME_CMODE_NOCONVERSION){

                        // Simulate a key press
                        keybd_event( VK_CAPITAL,
                                        0x3A,
                                        KEYEVENTF_EXTENDEDKEY | 0,
                                        0 );
 
                        // Simulate a key release
                        keybd_event( VK_CAPITAL,
                                        0x3A,
                                        KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP,
                                        0);

                                cap_mode = 0;
                                fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                                        ~(IME_CMODE_NOCONVERSION);
                        }else
                                fdwConversion = lpIMC->fdwConversion |IME_CMODE_NATIVE;

        }

        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);

        }

    if (PtInRect(&sImeG.rcShapeText, *lpptCursor)) {
        DWORD dwConvMode;

        dwConvMode = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
        ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);
    }

    if (PtInRect(&sImeG.rcSKText, *lpptCursor)) {
        DWORD fdwConversion;

                KeyBoardState = ~KeyBoardState ;
        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SOFTKBD;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    }

        if (PtInRect(&sImeG.rcPctText, *lpptCursor)) { 
                DWORD fdwConversion;

        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SYMBOL;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    }

        if (PtInRect(&sImeG.rcCmdText, *lpptCursor)) {
                if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
                DWORD fdc;
                                
                        if (kb_mode==CIN_STD){
                                kb_mode = CIN_SDA;
                                fdc = lpIMC->fdwConversion|IME_CMODE_SDA;       
                        }else{
                                kb_mode = CIN_STD;
                        fdc = lpIMC->fdwConversion&~IME_CMODE_SDA;      
                        }
                         
                ImmSetConversionStatus(hIMC, fdc, lpIMC->fdwSentence);
                        {
                        LPPRIVCONTEXT lpImcP;
                        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                    
                    ghIMC=hIMC;   
                glpIMCP=lpImcP;
                glpIMC=lpIMC;
            lpImcP->fdwImeMsg=lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX; 
            cls_prompt();
                        InitCvtPara();
                        GenerateMessage(hIMC, lpIMC, lpImcP);
                        ImmUnlockIMCC(lpIMC->hPrivate);
                        }
                        DispMode(hIMC);
                }else
                MessageBeep((UINT)-1);
        } 
        
    ImmUnlockIMC(hIMC);

    return;
}



/**********************************************************************/
/* PaintStatusWindow()                                                */
/**********************************************************************/
void PASCAL PaintStatusWindow(
    HDC  hDC,
    HWND hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HBITMAP        hInputBmp, hShapeBmp, hSKBmp, hCmdBmp, hPctBmp;
    HBITMAP        hOldBmp;
    HDC            hMemDC;
        int  TopOfBmp = 2;

        if (sImeG.yChiCharHi > 0x10)
                TopOfBmp = 3;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        MessageBeep((UINT)-1);
        return;
    }

    hInputBmp = (HBITMAP)NULL;
    hShapeBmp = (HBITMAP)NULL;
    hSKBmp = (HBITMAP)NULL;
    hCmdBmp = (HBITMAP)NULL;
    hPctBmp = (HBITMAP)NULL;

    if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
        hInputBmp = LoadBitmap(hInst, szChinese);
    } else {
        hInputBmp = LoadBitmap(hInst, szEnglish);
    }

    if (!lpIMC->fOpen) {
        hShapeBmp = LoadBitmap(hInst, szNone);
                hPctBmp = LoadBitmap(hInst, szNone);
        hSKBmp = LoadBitmap(hInst, szNone);
                if (kb_mode == CIN_SDA){
            hCmdBmp = LoadBitmap(hInst, szNoSDA);
                }else{
            hCmdBmp = LoadBitmap(hInst, szNoSTD);
            } 

        }else{
        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            hShapeBmp = LoadBitmap(hInst, szFullShape);
        } else {
            hShapeBmp = LoadBitmap(hInst, szHalfShape);
        }

        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
            hSKBmp = LoadBitmap(hInst, szSoftKBD);
                if (sImeG.First){
                                DWORD fdw;
                                fdw = lpIMC->fdwConversion;
                            ImmSetConversionStatus(hIMC,lpIMC->fdwConversion^IME_CMODE_SOFTKBD, lpIMC->fdwSentence);
                                ImmSetConversionStatus(hIMC, fdw, lpIMC->fdwSentence);
                                sImeG.First = 0;
                        }
        } else {
            hSKBmp = LoadBitmap(hInst, szNoSoftKBD);
        }

                if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) 
                        hPctBmp = LoadBitmap(hInst, szCPCT);
                else
                        hPctBmp = LoadBitmap(hInst, szEPCT);
     
                if (kb_mode == CIN_SDA){
            hCmdBmp = LoadBitmap(hInst, szSDA);
                }else{
            hCmdBmp = LoadBitmap(hInst, szSTD);
            } 

        }
    
    ImmUnlockIMC(hIMC);

        DrawStatusRect(hDC, 0,0,sImeG.xStatusWi-1, sImeG.yStatusHi-1);

    hMemDC = CreateCompatibleDC(hDC);

    if ( hMemDC )
    {

        hOldBmp = SelectObject(hMemDC, hInputBmp);

        BitBlt(hDC, sImeG.rcInputText.left,TopOfBmp,
            sImeG.rcInputText.right,
            sImeG.yStatusHi,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hCmdBmp);
        BitBlt(hDC, sImeG.rcCmdText.left, TopOfBmp,
            sImeG.rcCmdText.right - sImeG.rcCmdText.left,
            sImeG.yStatusHi,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hPctBmp);
        BitBlt(hDC, sImeG.rcPctText.left, TopOfBmp,
            sImeG.rcPctText.right - sImeG.rcPctText.left,
            sImeG.yStatusHi,
            hMemDC, 0, 0, SRCCOPY);


        SelectObject(hMemDC, hShapeBmp);
        BitBlt(hDC, sImeG.rcShapeText.left, TopOfBmp,
            sImeG.rcShapeText.right - sImeG.rcShapeText.left,
            sImeG.yStatusHi,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hSKBmp);

        BitBlt(hDC, sImeG.rcSKText.left, TopOfBmp,
            sImeG.rcSKText.right  - sImeG.rcSKText.left,       //zl 95.8.25
            sImeG.yStatusHi,
            hMemDC, 0, 0, SRCCOPY);

        SelectObject(hMemDC, hOldBmp);

        DeleteDC(hMemDC);
    }

    DeleteObject(hInputBmp);
    DeleteObject(hShapeBmp);
    DeleteObject(hSKBmp);
    DeleteObject(hCmdBmp);
    DeleteObject(hPctBmp);

    return;
}

/**********************************************************************/
/* NeedsKey()                                                         */
/* Function: Sub route for Proccesskey proc                               */
/* Return Value:                                                      */
/*      The converted key value or 0 for not needs.                   */
/**********************************************************************/

WORD
NeedsKey(kv)
WORD kv;
{
WORD ascnum;

        if((kv>='0')&&(kv<='9'))
                return(kv);

        if((kv>='A')&&(kv<='Z'))
                if (cap_mode)
                        return(kv);
                else
                        return(kv|0x20);

        switch(kv){
                case VK_RETURN:
                case VK_SPACE:
                case VK_ESCAPE:
                case VK_BACK:
                        return(kv);

                case VK_NUMPAD0:      // 0x60
                        return('0');
                case VK_NUMPAD1:      // 0x61
                case VK_NUMPAD2:      // 0x62
                case VK_NUMPAD3:      // 0x63
                case VK_NUMPAD4:      // 0x64
                case VK_NUMPAD5:      // 0x65
                case VK_NUMPAD6:      // 0x66
                case VK_NUMPAD7:      // 0x67
                case VK_NUMPAD8:      // 0x68
                case VK_NUMPAD9:      // 0x69
                    ascnum = kv - VK_NUMPAD1 + '1';
                    break;

//     case VK_MULTIPLY:     // 0x6A
//         return '*';
//      case VK_ADD     :             // 0x6B
//         return '+';

//      case VK_SEPARATOR:            // 0x6C
//      case VK_SUBTRACT:     // 0x6D
//      case VK_DECIMAL :     // 0x6E
//      case VK_DIVIDE  :     // 0x6F
//         ascnum = kv - 0x40;
//         break;
                case VK_DANYINHAO:    // 0xc0      // [,]  char = // 0x60
                        ascnum = 0x60;
                        break;
                case VK_JIANHAO  :    // 0xbd      // [-]  char = // 0x2d
                        ascnum = 0x2d;
                        break;
                case VK_DENGHAO  :    // 0xbb      // [=]  char = // 0x3d
                        ascnum = 0x3d;
                        break;
                case VK_ZUOFANG  :    // 0xdb      // "["  char = // 0x5b
                        ascnum = 0x5b;
                        break;
                case VK_YOUFANG  :    // 0xdd      // "]"  char = // 0x5d
                        ascnum = 0x5d;
                        break;
                case VK_FENHAO   :    // 0xba      // [;]  char = // 0x3b
                        ascnum = 0x3B;
                        break;
                case VK_ZUODAN   :    // 0xde      // [']  char = // 0x27
                        ascnum = 0x27;
                        break;
                case VK_DOUHAO   :    // 0xbc      // [,]  char = // 0x2c
                        ascnum = 0x2c;
                        break;
                case VK_JUHAO    :     // 0xbe      // [.]  char = // 0x2d
                        ascnum = '.';
                        break;
                case VK_SHANGXIE :    // 0xbf      // [/]  char = // 0x2f
                        ascnum = 0x2f;
                        break;
                case VK_XIAXIE   :    // 0xdc      // [\]  char = // 0x5c
                        ascnum = 0x5c;
                        break;

                case VK_SHIFT:
                        return(2);
                default:
                        return(0);
        }
    return(ascnum);
}


/**********************************************************************/
/* NeedsKeyShift()                                                    */
/* Function: Deels with the case of Shift key Down                        */
/* Return Value:                                                      */
/*      The converted key value.                                      */
/**********************************************************************/
WORD
NeedsKeyShift(kv)
WORD kv;
{
WORD xx=0;

        if((kv>='A')&&(kv<='Z'))
                if (cap_mode)
                        return(kv|0x20);
                else
                        return(kv);

        switch(kv){
                case '1':
                        xx='!';
                        break;

                case '2':
                        xx='@';
                        break;

                case '3':
                        xx='#';
                        break;

                case '4':
                        xx='$';
                        break;

                case '5':
                        xx='%';
                        break;

                case '6':
                        xx='^';
                        break;

            case '7':
                        xx='&';
                        break;

                case '8':
                        xx='*';
                        break;

                case '9':
                        xx='(';
                        break;

                case '0':
                        xx=')';
                        break;

                case VK_DANYINHAO:    // 0xc0      // [,]  char = // 0x60
                        xx = '~';
                        break;
      
                case VK_JIANHAO  :    // 0xbd      // [-]  char = // 0x2d
                        xx = '_';
                        break;
      
                case VK_DENGHAO  :    // 0xbb      // [=]  char = // 0x3d
                        xx = '+';
                        break;
      
                case VK_ZUOFANG  :    // 0xdb      // "["  char = // 0x5b
                        xx = '{';
                        break;
      
                case VK_YOUFANG  :    // 0xdd      // "]"  char = // 0x5d
                        xx = '}';
                        break;
      
                case VK_FENHAO   :    // 0xba      // [;]  char = // 0x3b
                        xx = ':';
                        break;
      
                case VK_ZUODAN   :    // 0xde      // [']  char = // 0x27
                        xx = '"';
                        break;
      
                case VK_DOUHAO   :    // 0xbc      // [,]  char = // 0x2c
                        xx = '<';
                        break;
      
                case VK_JUHAO    :     // 0xbe      // [.]  char = // 0x2d
                        xx = '>';
                        break;
      
                case VK_SHANGXIE :    // 0xbf      // [/]  char = // 0x2f
                        xx = '?';
                        break;
      
                case VK_XIAXIE   :    // 0xdc      // [\]  char = // 0x5c
                        xx = '|';
                        break;
        }

    return xx;
}


  
/**********************************************************************/
/* ProcessKey()                                                       */
/* Function: Check a key if needs for the current processing              */
/* Return Value:                                                      */
/*      different state which input key will change IME to            */
/**********************************************************************/
UINT PASCAL ProcessKey(     // this key will cause the IME go to what state
    WORD           nCode,
    UINT           wParam,                      //uVirtKey,
    UINT           uScanCode,
    LPBYTE         lpbKeyState,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP,
    HIMC           hIMC)
{

    int x;
    WORD w,op;

    if (!lpIMC) {
        return (CST_INVALID);
    }

    if (!lpImcP) {
        return (CST_INVALID);
    }

    if (wParam == VK_MENU) {       // no ALT key
        return (CST_INVALID);
    } else if (uScanCode & KF_ALTDOWN) {    // no ALT-xx key
        return (CST_INVALID);
    } else if (!lpIMC->fOpen) {
        return (CST_INVALID);
    }

        if (wParam == VK_CAPITAL){

                x=cap_mode;
                // Change to comply with NT 3.51 VK_CAPITAL check style        6
#ifdef LATER
                if (!GetKeyState(VK_CAPITAL)&1){                  //if the Caps Lock status
#else
            if (GetKeyState(VK_CAPITAL)&1){                  //if the Caps Lock status
#endif //LATER
                        DWORD fdwConversion;

                        cap_mode=1;

                        if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
                                // change to alphanumeric mode
                                fdwConversion = (lpIMC->fdwConversion|IME_CMODE_NOCONVERSION) 
                                        & ~(IME_CMODE_NATIVE);
                
                                ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                                {
                                        BOOL hbool;

                                        hbool = ImmGetOpenStatus(hIMC);
                                        //ImmSetOpenStatus(hIMC, !hbool);
                                        ImmSetOpenStatus(hIMC, hbool);

                                        ghIMC=hIMC;   
                                glpIMCP=lpImcP;
                                        glpIMC=lpIMC;
                                        lpImcP->fdwImeMsg=lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX; 
                                        cls_prompt();
                                        lpImcP->fdwImeMsg=lpImcP->fdwImeMsg|MSG_END_COMPOSITION;
                                        GenerateMessage(ghIMC, glpIMC,glpIMCP);
                        
                                        V_Flag = 0;
                                        bx_inpt_on = 0;

                                }
                                step_mode = 0;
                        }
                }else{
                        DWORD fdwConversion;

                        cap_mode=0;

                        if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
                                // change to alphanumeric mode
                                fdwConversion = (lpIMC->fdwConversion |IME_CMODE_NATIVE)
                                 & ~(IME_CMODE_NOCONVERSION);
                
                                ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
                                {
                                        BOOL hbool;

                                        hbool = ImmGetOpenStatus(hIMC);
                                        //ImmSetOpenStatus(hIMC, !hbool);
                                        ImmSetOpenStatus(hIMC, hbool);
                        
                                        ghIMC=hIMC;   
                                glpIMCP=lpImcP;
                                        glpIMC=lpIMC;
                                lpImcP->fdwImeMsg=lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX;
                                        cls_prompt();
                                        lpImcP->fdwImeMsg=lpImcP->fdwImeMsg|MSG_END_COMPOSITION;
                                        GenerateMessage(ghIMC, glpIMC,glpIMCP);
                                }
                        }
                }
                return (CST_INVALID);
        }

        if (lpbKeyState[VK_CONTROL]&0x80)               // If CTRL pressed
//            if (!((HIBYTE(HIWORD(lParam)))&0x80))
        {
//                         DebugShow("In ProcessKey Keystate %X",*lpbKeyState);
                op=0xffff;
                if (nCode==VK_F2){
                     return TRUE;
            }

                if (!(lpIMC->fdwConversion &IME_CMODE_NOCONVERSION))
                        switch(nCode){
                                case '1':
                                        op=SC_METHOD1;
                                        break;

                                case '2':
                                        op=SC_METHOD2;
                                        break;

                                case '3':
                                        op=SC_METHOD3;
                                        break;

                                case '4':
                                        op=SC_METHOD4;
                                        break;

                                case '5':
                                        op=SC_METHOD5;
                                        break;

                                case '6':
                                        op=SC_METHOD6;
                                        break;

                                case '7':
                                        op=SC_METHOD7;
                                        break;

                                case '8':
                                        op=SC_METHOD8;
                                        break;

                                case '9':
                                        op=SC_METHOD9;
                                        break;
                                
                                case '0':
                                    op=SC_METHOD10;
                                    break;
                                
                                case 0xbd:
                                        op='-'|0x8000;
                                        break;
                                
                                case 0xbb:
                                        op='='|0x8000;
                                        break;
                                
                                //case 0xdb:
                                //      op='['|0x8000;
                                //      break;
                                //case 0xdd:
                                //      op=']'|0x8000;
                                //      break;
                                default:
                                        op=0xffff;
                }//switch
                if(op!=0xffff){
                        return(TRUE);
                }
                return(CST_INVALID);
        }

//      if((nCode == VK_TAB)&&SdaPromptOpen) return 0;


        if(!step_mode&&!(lpIMC->fdwConversion&IME_CMODE_FULLSHAPE))
                if(nCode == ' ') return(CST_INVALID);

        switch(wParam){
                case VK_END:
                case VK_HOME:
                case VK_PRIOR:
                case VK_NEXT:
                        if (step_mode == SELECT)
                                return(TRUE);
                       
//             case VK_SHIFT:
                case VK_CONTROL:
//             case VK_PRIOR:
//             case VK_NEXT:
            case VK_TAB:
//             case VK_DELETE:
            case VK_INSERT:
            case VK_F1:
            case VK_F2:
            case VK_F3:
            case VK_F4:
            case VK_F5:
            case VK_F6:
            case VK_F7:
            case VK_F8:
            case VK_F9:
            case VK_F10:
            case VK_F11:
            case VK_F12:
            case VK_F13:
            case VK_F14:
            case VK_F15:
            case VK_F16:
            case VK_F17:
            case VK_F18:
            case VK_F19:
            case VK_F20:
            case VK_F21:
                case VK_F22:
            case VK_F23:
            case VK_F24:
            case VK_NUMLOCK:
            case VK_SCROLL:
                        return(CST_INVALID);
        }



//      if ((cap_mode)&&(lpIMC->fdwConversion & IME_CMODE_FULLSHAPE)) //zl
//              return(CST_INVALID);



        switch(nCode){
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                case VK_DELETE:
                        if (step_mode!=ONINPUT)
                                return(CST_INVALID);
                        else
                                return(TRUE);
        }
        
        if((step_mode==START)||(step_mode==RESELECT))
                switch(nCode){
                        case VK_SHIFT:
                        case VK_RETURN:
                        case VK_CANCEL:
                        case VK_BACK:
                        case VK_ESCAPE:
                                return(CST_INVALID);
                }

        if (lpbKeyState[VK_SHIFT]&0x80){
                // If candidate windows is already opened, stop further process.
                // Keep 'shift' for stroke input mode   4/17
                if (sImeG.cbx_flag) {}
                else
                if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)return(CST_INVALID);
                if ((w=NeedsKeyShift(nCode))!=0)
                        return(TRUE);
                else
                        return(CST_INVALID);
                      
        } else{
                w=NeedsKey(nCode);
                if( w != 0)
                        return(TRUE);
        }
        return(CST_INVALID);
}


/**********************************************************************/
/* ImeProcessKey()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeProcessKey(   // if this key is need by IME?
    HIMC   hIMC,
    UINT   uVirtKey,
    LPARAM lParam,
    CONST LPBYTE lpbKeyState)
{
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    BYTE           szAscii[4];
    int            nChars;
    BOOL           fRet;

    // can't compose in NULL hIMC
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    nChars = ToAscii(uVirtKey, HIWORD(lParam), lpbKeyState,
                (LPVOID)szAscii, 0);


    if (!nChars) {
        szAscii[0] = 0;
    }

    if (ProcessKey((WORD)uVirtKey, uVirtKey, HIWORD(lParam), lpbKeyState,
                    lpIMC, lpImcP, hIMC) == CST_INVALID) {
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* TranslateFullChar()                                                */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateFullChar(          // convert to Double Byte Char
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    LPTRANSMSG lpTransMsg;
    // if your IME is possible to generate over ? messages,
    // you need to take care about it

    wCharCode = sImeG.wFullABC[wCharCode - ' '];

    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wCharCode);
    lpTransMsg->lParam = 1UL;
    lpTransMsg++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wCharCode);
    lpTransMsg->lParam  = 1UL;
    return (2);         // generate two messages
}

/**********************************************************************/
/* TranslateTo     ()                                                 */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateToAscii(       // translate the key to WM_CHAR
                                    // as keyboard driver
    UINT    uVirtKey,
    UINT    uScanCode,
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    LPTRANSMSG lpTransMsg;

    lpTransMsg = lpTransBuf->TransMsg;

    if (wCharCode) {                    // one char code
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = wCharCode;
        lpTransMsg->lParam  = (uScanCode << 16) | 1UL;
        return (1);
    }

    // no char code case
    return (0);
}

/**********************************************************************/
/* TranslateImeMessage()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TranslateImeMessage(
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;
    UINT i;
    BOOL bLockMsgBuf;
    LPTRANSMSG lpTransMsg;

    uNumMsg = 0;
    bLockMsgBuf = FALSE;

    for (i = 0; i < 2; i++) {
        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONSIZE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_COMPOSITION_SIZE;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_START_COMPOSITION) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_STARTCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_START;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_SETCOMPOSITIONWINDOW;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_COMPOSITION;
                lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
                lpTransMsg->lParam  = (DWORD)lpImcP->fdwGcsFlag;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_GUIDELINE;
                lpTransMsg->lParam  = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_PAGEUP) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_PAGEUP;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_OPENCANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_OPEN;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_CHANGE_CANDIDATE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_CHANGECANDIDATE;
                lpTransMsg->lParam  = 0x0001;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_PREDICT) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_PREDICT;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_SOFTKBD) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_UPDATE_SOFTKBD;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_END_COMPOSITION) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam  = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_START);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_TOGGLE_UI) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam  = IMN_PRIVATE_TOGGLE_UI;
                lpTransMsg++;
            }
        }

        if (!i) {
            HIMCC hMem;

            if (!uNumMsg) {
                return (uNumMsg);
            }

            if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
                UINT uNumMsgLimit;

                // ++ for the start position of buffer to strore the messages
                uNumMsgLimit = lpTransBuf->uMsgCount;

                if (uNumMsg <= uNumMsgLimit) {
                    lpTransMsg = lpTransBuf->TransMsg;
                    continue;
                }
            }

            // we need to use message buffer
            if (!lpIMC->hMsgBuf) {
                lpIMC->hMsgBuf = ImmCreateIMCC(uNumMsg * sizeof(TRANSMSG));
                lpIMC->dwNumMsgBuf = 0;
            } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf,
                (lpIMC->dwNumMsgBuf + uNumMsg) * sizeof(TRANSMSG))) {
                if (hMem != lpIMC->hMsgBuf) {
                    ImmDestroyIMCC(lpIMC->hMsgBuf);
                    lpIMC->hMsgBuf = hMem;
                }
            } else {
                return (0);
            }

            lpTransMsg = (LPTRANSMSG)ImmLockIMCC(lpIMC->hMsgBuf);
            if (!lpTransMsg) {
                return (0);
            }

            lpTransMsg += lpIMC->dwNumMsgBuf;

            bLockMsgBuf = TRUE;
        } else {
            if (bLockMsgBuf) {
                ImmUnlockIMCC(lpIMC->hMsgBuf);
            }
        }
    }

    return (uNumMsg);
}

/**********************************************************************/
/* TransAbcMsg2()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TransAbcMsg2(
    LPTRANSMSG     lpTransMsg,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;

    uNumMsg = 0;

    if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
        lpTransMsg->message = WM_IME_COMPOSITION;
        lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
        lpTransMsg->lParam  = (DWORD)lpImcP->fdwGcsFlag;
        lpTransMsg++;

        uNumMsg++;
    }

    if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpTransMsg->message = WM_IME_NOTIFY;
            lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
            lpTransMsg->lParam = 0x0001;
            lpTransMsg++;
            uNumMsg++;
            lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
        }
    }

    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
    lpTransMsg->wParam  = 0;
    lpTransMsg->lParam = 0;
    uNumMsg++;
    lpImcP->fdwImeMsg = 0;
        
    return (uNumMsg);
}

/**********************************************************************/
/* TransAbcMsg()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TransAbcMsg(
    LPTRANSMSGLIST lpTransBuf,
    LPPRIVCONTEXT  lpImcP,
    LPINPUTCONTEXT lpIMC,
    UINT                   uVirtKey,
    UINT           uScanCode,
    WORD           wCharCode)    
{
        
    LPCOMPOSITIONSTRING  lpCompStr ;
    UINT uNumMsg;
    int i;
    int MsgCount;
    LPSTR pp;
    LPTRANSMSG lpTransMsg;

    lpTransMsg = lpTransBuf->TransMsg;

    uNumMsg = 0;
    
    if (TypeOfOutMsg&ABC_OUT_ONE){
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,wCharCode);
        lpTransMsg++;
        return (uNumMsg);    
    }else{ 
        if (TypeOfOutMsg&ABC_OUT_ASCII){        
            lpTransMsg = lpTransBuf->TransMsg;
            lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
            if (!lpCompStr)
                 uNumMsg = 0;
            else{
                MsgCount = lpCompStr->dwResultStrLen;
                pp = (LPSTR)lpCompStr + lpCompStr->dwResultStrOffset;
                for (i = 0; i < MsgCount; i++){
                    if((BYTE)pp[i]<0x80){
                        WORD x;
                        x =(WORD)VkKeyScan((TCHAR)(BYTE)pp[i]);


                        lpTransMsg->message = WM_KEYUP;
                        lpTransMsg->wParam  = (DWORD)(BYTE)x;//(DWORD)(BYTE)pp[i];
                        lpTransMsg->lParam = 1UL;
                        lpTransMsg++;
                        uNumMsg++;


                    }else{          
                        lpTransMsg->message = WM_CHAR;
                        lpTransMsg->wParam  = (DWORD)(BYTE)pp[i];
                        lpTransMsg->lParam = 1UL;
                        lpTransMsg++;
                        uNumMsg++;
                    }
                }
                    
                ImmUnlockIMCC(lpIMC->hCompStr);
            }    
        }else{
            lpTransMsg = lpTransBuf->TransMsg;
        }
    }
           
    if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
        lpTransMsg->message = WM_IME_COMPOSITION;
        lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
        lpTransMsg->lParam  = (DWORD)lpImcP->fdwGcsFlag;
        lpTransMsg++;
        uNumMsg++;
    } 

    if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpTransMsg->message = WM_IME_NOTIFY;
            lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
            lpTransMsg->lParam  = 0x0001;
            lpTransMsg++;
            uNumMsg++;
            lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
        }
    }
    
    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
    lpTransMsg->wParam  = 0;
    lpTransMsg->lParam  = 0;
    lpTransMsg++;
    uNumMsg++;
    lpImcP->fdwImeMsg = 0;
        
    TypeOfOutMsg = TypeOfOutMsg | COMP_NEEDS_END;    

    if (wait_flag||waitzl_flag){                                                                      //waitzl 2

        lpTransMsg->message = WM_IME_NOTIFY;
        lpTransMsg->wParam  = IMN_SETCOMPOSITIONWINDOW;
        lpTransMsg->lParam  = 0;
        lpTransMsg++;
        uNumMsg++;

        lpTransMsg->message = WM_IME_STARTCOMPOSITION;
        lpTransMsg->wParam  = 0;
        lpTransMsg->lParam  = 0x6699;
        lpTransMsg++;

        uNumMsg++;
        lpImcP->fdwImeMsg |= MSG_ALREADY_START;
    }

    return (uNumMsg);
}


/**********************************************************************/
/* KeyFilter()                                                        */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/

WORD  KeyFilter(nCode,wParam,lParam,lpImcP , lpbKeyState )
WORD nCode;
WORD wParam;
DWORD lParam;
LPPRIVCONTEXT  lpImcP;
LPBYTE lpbKeyState;
{
        int x;
    WORD w,op;

        if (lpbKeyState[VK_CONTROL]&0x80)               // If CTRL pressed
        {
                op=0xffff;
                if (nCode==VK_F2){
        //zst futur                  PostMessage(hMenuWnd,WM_COMMAND,SC_METHODA,0);
                        return 0;
                }

                switch(nCode){
                        case '1':
                                op=SC_METHOD1;
                                break;

                        case '2':
                                op=SC_METHOD2;
                                break;

                        case '3':
                                op=SC_METHOD3;
                                break;

                        case '4':
                                op=SC_METHOD4;
                                break;

                        case '5':
                                op=SC_METHOD5;
                                break;

                        case '6':
                                op=SC_METHOD6;
                                break;

                         case '7':
                                op=SC_METHOD7;
                                break;

                         case '8':
                                op=SC_METHOD8;
                                break;

                        case '9':
                                op=SC_METHOD9;
                                break;
                
                        case '0':
                            op=SC_METHOD10;
                            break;
                        
                        case 0xbd:
                                op='-'|0x8000;
                                break;
                        
                        case 0xbb:
                                op='='|0x8000;
                                break;
                        
                        //case 0xdb:
                        //      op='['|0x8000;
                        //      break;
                        //case 0xdd:
                        //      op=']'|0x8000;
                        //      break;
                        
                        default:
                                op=0xffff;
                }//switch
                if(op!=0xffff){
                        if(op&(WORD)0x8000)
                             return op;
                        else{

                        //zst future                 PostMessage(hMenuWnd,WM_COMMAND,op,0);
                        //zst future                 EventFrom = 1;
                    }
                        return(0);
                }
                return(0);

        }

        switch(nCode){
                case VK_PRIOR:
                case VK_NEXT:
                case VK_HOME:
                case VK_END:
                        if(step_mode == SELECT)
                                return(nCode*0x100);
                        else return(0);

                case VK_LEFT:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_DELETE:

                        if (step_mode!=ONINPUT)
                                return(0);
                        else
                                return(nCode+0x100);
        }

        if (lpbKeyState/*GetKeyState*/[VK_SHIFT]&0x80){
                if ((w=NeedsKeyShift(nCode))!=0)
                        return (w);
                else
                        return (0);
                      
        } else{
                if((w=NeedsKey(nCode)) != 0)
                        return (w);
        }
        return(0);

}

 /**********************************************************************/
/* TranslateSymbolChar()                                              */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateSymbolChar(
    LPTRANSMSGLIST lpTransBuf,
    WORD    wSymbolCharCode)

{
    UINT uRet;
    LPTRANSMSG lpTransMsg;

    uRet = 0;

    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wSymbolCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wSymbolCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;


    return (uRet);         // generate two messages
}



/**********************************************************************/
/* ImeToAsciiEx()                                                     */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/
UINT WINAPI ImeToAsciiEx(
    UINT    uVirtKey,
    UINT    uScanCode,
    CONST LPBYTE  lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT    fuState,
    HIMC    hIMC)
{
    WORD                wCharCode;
    WORD                wCharZl;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    UINT                uNumMsg;
    int                 iRet;

    wCharCode = HIBYTE(uVirtKey);
    uVirtKey = LOBYTE(uVirtKey);

    if (!hIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

        lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|
        MSG_ALREADY_START) | MSG_IN_IMETOASCIIEX;

        // deal with softkbd
    if ((lpIMC->fdwConversion & IME_CMODE_SOFTKBD)
                && (lpImeL->dwSKWant != 0) &&
                (wCharCode >= ' ' && wCharCode <= '~')) {
    
            WORD wSymbolCharCode;
                WORD CHIByte, CLOByte;
                int  SKDataIndex;

                // Mapping VK
                if(uVirtKey == 0x20) {
                        SKDataIndex = 0;
                } else if(uVirtKey >= 0x30 && uVirtKey <= 0x39) {
                        SKDataIndex = uVirtKey - 0x30 + 1;
                } else if (uVirtKey >= 0x41 && uVirtKey <= 0x5a) {
                        SKDataIndex = uVirtKey - 0x41 + 0x0b;
                } else if (uVirtKey >= 0xba && uVirtKey <= 0xbf) {
                        SKDataIndex = uVirtKey - 0xba + 0x25;
                } else if (uVirtKey >= 0xdb && uVirtKey <= 0xde) {
                        SKDataIndex = uVirtKey - 0xdb + 0x2c;
                } else if (uVirtKey == 0xc0) {
                        SKDataIndex = 0x2b;
                } else {
                        SKDataIndex = 0;
                }

                //
                if (lpbKeyState[VK_SHIFT] & 0x80) {
                CHIByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
                        CLOByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
                } else {
                CHIByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
                        CLOByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
                        
                }

                wSymbolCharCode = (CHIByte << 8) | CLOByte;
                if(wSymbolCharCode == 0x2020) {
                    MessageBeep((UINT) -1);
                    uNumMsg = 0;
                } else {
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode);
                }               
                lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX;

                ImmUnlockIMCC(lpIMC->hPrivate);
                ImmUnlockIMC(hIMC);

                return (uNumMsg);
        
        } 

        sImeG.KeepKey = 0;
        if(wCharZl=KeyFilter(/*wCharCode*/uVirtKey,uVirtKey,uScanCode,lpImcP , lpbKeyState )){
                if(wCharZl<0x100)
                        wCharZl = wCharCode;
            CharProc(wCharZl,/*wCharCode*/uVirtKey,uScanCode,hIMC,lpIMC,lpImcP);
        }

        if(TypeOfOutMsg){

                uNumMsg = TransAbcMsg(lpTransBuf, lpImcP,lpIMC,uVirtKey,uScanCode, wCharCode); 
        }else {
                uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
        }

        lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & ~MSG_IN_IMETOASCIIEX;

        ImmUnlockIMCC(lpIMC->hPrivate);
        ImmUnlockIMC(hIMC);

    return (uNumMsg);
}



/**********************************************************************/
/* CancelCompCandWindow()                                                  */
/**********************************************************************/
void PASCAL CancelCompCandWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) return ;     

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) return;

    if (lpUIPrivate->hCompWnd) {
                //  DestroyWindow(lpUIPrivate->hCompWnd);
        ShowWindow(lpUIPrivate->hCompWnd,SW_HIDE);
    }

    if (lpUIPrivate->hCandWnd) {
                DestroyWindow(lpUIPrivate->hCandWnd);
   //     ShowWindow(lpUIPrivate->hCandWnd,SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);
//      SendMessage(hUIWnd,WM_IME_ENDCOMPOSITION,0,0L);
    return;
}

int DoPropertySheet(HWND hwndOwner,HWND hWnd)
{
    PROPSHEETPAGE psp[3];
    PROPSHEETHEADER psh;

    BYTE         KbType;
        BYTE         cp_ajust_flag;
    BYTE         auto_mode ;
        BYTE         cbx_flag;
        BYTE        tune_flag;
        BYTE        auto_cvt_flag;                
        BYTE        SdOpenFlag ;
        WORD            wImeStyle ;

    HIMC            hIMC;
        HWND           hUIWnd;

        
        if (sImeG.Prop)  return 0;
                        
    //Fill out the PROPSHEETPAGE data structure for the Background Color
    //sheet

        sImeG.Prop = 1;
    if(hWnd){
                hUIWnd =  GetWindow(hWnd,GW_OWNER);  
                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    }else
            hIMC = 0;

        wImeStyle = lpImeL->wImeStyle;
        KbType = sImeG.KbType;
        cp_ajust_flag=sImeG.cp_ajust_flag;
        auto_mode=sImeG.auto_mode;
        cbx_flag=sImeG.cbx_flag;
        tune_flag=sImeG.tune_flag;
        auto_cvt_flag=sImeG.auto_cvt_flag;
        SdOpenFlag=sImeG.SdOpenFlag;
        
    sImeG.unchanged = 0;
        if(hIMC)
                ImmSetOpenStatus(hIMC,FALSE);
   
        if(hIMC)
        {
                LPINPUTCONTEXT lpIMC;

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          // Oh! Oh!
                        return (0L);
                }

                DialogBox(hInst,(LPCTSTR)ImeStyleDlg, lpIMC->hWnd, ImeStyleProc);
                
                ImmUnlockIMC(hIMC);
        }else{
                DialogBox(hInst,(LPCTSTR)ImeStyleDlg, hwndOwner, ImeStyleProc);
        }

        if(hIMC)
                ImmSetOpenStatus(hIMC,TRUE);

        if (sImeG.unchanged){
                lpImeL->wImeStyle = wImeStyle ;
                sImeG.KbType = KbType;
                sImeG.cp_ajust_flag = cp_ajust_flag;    
                sImeG.auto_mode = auto_mode;
                sImeG.cbx_flag = cbx_flag;
                sImeG.tune_flag = tune_flag;
                sImeG.auto_cvt_flag = auto_cvt_flag;
                sImeG.SdOpenFlag = SdOpenFlag;
        }else{
                ChangeUserSetting();
        }
        sImeG.Prop = 0;
        return (!sImeG.unchanged);
}

void WINAPI CenterWindow(HWND hWnd)
{
RECT WorkArea;
RECT rcRect;
int x,y,mx,my;

  SystemParametersInfo(SPI_GETWORKAREA, 0, &WorkArea, 0);
  GetWindowRect(hWnd,&rcRect);

  mx = WorkArea.left + (WorkArea.right - WorkArea.left)/2;

  my = WorkArea.top + (WorkArea.bottom - WorkArea.top)/2;

  x =  mx - (rcRect.right - rcRect.left)/2;
  y =  my - (rcRect.bottom - rcRect.top)/2;
  SetWindowPos (hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
  return;
}


INT_PTR  CALLBACK ImeStyleProc(HWND hdlg, 
                               UINT uMessage, 
                               WPARAM wparam, 
                               LPARAM lparam)
{
    switch (uMessage) {

        case WM_INITDIALOG:                /* message: initialize dialog box */
             hCrtDlg = hdlg;
             CenterWindow(hdlg);
             if (lpImeL->wImeStyle == IME_APRS_FIX)
                SendMessage(GetDlgItem(hdlg, IDC_FIX),
                            BM_SETCHECK,
                            TRUE,
                            0L);
             else
                SendMessage(GetDlgItem(hdlg, IDC_NEAR),
                            BM_SETCHECK,
                            TRUE,
                            0L);

             if(sImeG.auto_mode)        
                SendMessage(GetDlgItem(hdlg, IDC_CP),
                            BM_SETCHECK,
                            TRUE,
                            0L);
                                        
             if(sImeG.cbx_flag)        
                SendMessage(GetDlgItem(hdlg, IDC_CBX),
                            BM_SETCHECK,
                            TRUE,
                            0L);

             return (TRUE);

       case WM_PAINT:
            {
             RECT Rect;
             HDC hDC;
             PAINTSTRUCT ps;

             GetClientRect(hdlg, &Rect);         //get the whole window area
             InvalidateRect(hdlg, &Rect, 1);
             hDC=BeginPaint(hdlg, &ps);

             Rect.left+=10;//5;
             Rect.top+=8;//5;
             Rect.right-=10;//5;
             Rect.bottom-=52;//5;
             DrawEdge(hDC, &Rect, EDGE_RAISED,/*EDGE_SUNKEN,*/ BF_RECT);

             EndPaint(hdlg, &ps);
             break;  
            }

       case WM_CLOSE:          
            EndDialog(hdlg, FALSE);
            return (TRUE);

       case WM_COMMAND:
            switch (wparam){
                 case IDC_BUTTON_OK:
                        EndDialog(hdlg, TRUE);
                        return (TRUE);
                 case IDC_BUTTON_ESC:
                        sImeG.unchanged = 1;
                        EndDialog(hdlg, TRUE);
                        return (TRUE);
                     
                 case IDC_NEAR:
                        lpImeL->wImeStyle = IME_APRS_AUTO;
                        break;

                 case IDC_FIX:
                        lpImeL->wImeStyle = IME_APRS_FIX;
                         break;
                 case IDC_CP:
                        if (sImeG.auto_mode ==0){
                              sImeG.auto_mode = 1;
                              break;
                         } else 
                              sImeG.auto_mode = 0;     
                         break;
                 case IDC_CBX:
                         if (sImeG.cbx_flag==0)
                            sImeG.cbx_flag = 1;
                         else 
                            sImeG.cbx_flag = 0;
                         break;
            }
   }
   return (FALSE);                           /* Didn't process a message    */
}

INT_PTR  CALLBACK KbSelectProc(HWND hdlg, 
                            UINT uMessage, 
                            WPARAM wparam, 
                            LPARAM lparam)
{
    HWND hWndApp;
    WORD wID;
    LPNMHDR lpnmhdr;

    return FALSE;
}

INT_PTR  CALLBACK CvtCtrlProc(HWND hdlg, 
                           UINT uMessage, 
                           WPARAM wparam, 
                           LPARAM lparam)
{
    return FALSE;
}

/**********************************************************************/
/* ContextMenu()                                                      */
/**********************************************************************/
void PASCAL ContextMenu(
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HMENU          hMenu, hCMenu;
        POINT          ptCursor;                         //zl #2

    ptCursor.x = x;
        ptCursor.y = y;
//      DebugShow2("ptCursor.x", x, "ptCursor.y" ,y);
    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    if (!lpUIPrivate->hCMenuWnd) {
        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hCMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
                "Abc95Menu",
            /*lpImeL->szCMenuClassName,*/ "Context Menu",
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, lpImeL->hInst, NULL);
                        
                if (!lpUIPrivate->hCMenuWnd) {
            goto ContextMenuUnlockIMC;
        }
    }

        ScreenToClient(hStatusWnd ,     &ptCursor);
        if (PtInRect(&sImeG.rcSKText, ptCursor)){ 
                hMenu = LoadMenu(hInst,"SKMenu");
                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if(lpImcP){
                        CheckMenuItem(hMenu,lpImeL->dwSKWant+IDM_SKL1,MF_CHECKED);
                        ImmUnlockIMCC(lpIMC->hPrivate);                 
                 }
        }       
    else hMenu = LoadMenu(hInst,"MMenu");
                    
    hCMenu = GetSubMenu(hMenu, 0);

    if ( lpImeL->fWinLogon == TRUE )
    {
        // In Logon Mode, we don't want to show help and configuration dialog

        EnableMenuItem(hCMenu, 107, MF_BYCOMMAND | MF_GRAYED );
        EnableMenuItem(hCMenu, 110, MF_BYCOMMAND | MF_GRAYED );
        EnableMenuItem(hCMenu, 109, MF_BYCOMMAND | MF_GRAYED );
    }

    SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_MENU, (LONG_PTR)hMenu);
/*
    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
   //     EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
   //     EnableMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_GRAYED);
    } else if (lpIMC->fOpen) {
        // can not go into symbol mode
        if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        //    EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
        } else {
            if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
          //      CheckMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_CHECKED);
            }
        }

        if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
           // CheckMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_CHECKED);
        }
    } else {
      //  EnableMenuItem(hCMenu, IDM_SYMBOL, MF_BYCOMMAND|MF_GRAYED);
      //  EnableMenuItem(hCMenu, IDM_SOFTKBD, MF_BYCOMMAND|MF_GRAYED);
    }
          */

    TrackPopupMenu(hCMenu, TPM_LEFTBUTTON,
        lpIMC->ptStatusWndPos.x ,
        lpIMC->ptStatusWndPos.y ,
        0,
                lpUIPrivate->hCMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

    GlobalUnlock(hUIPrivate);

ContextMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* StatusSetCursor()                                                  */
/**********************************************************************/
void PASCAL StatusSetCursor(
    HWND        hStatusWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;
        RECT  rcSt;

    rcSt.left = sImeG.rcStatusText.left+3;
    rcSt.top = sImeG.rcStatusText.top + 3;
    rcSt.right = sImeG.rcStatusText.right-3;
    rcSt.bottom = sImeG.rcStatusText.bottom;    
    
    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }
    
    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hStatusWnd, &ptCursor);

    if (PtInRect(&rcSt, ptCursor)) {
        SetCursor(LoadCursor(hInst,szHandCursor ));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            SetStatus(hStatusWnd, &ptCursor);
        } else if (HIWORD(lParam) == WM_RBUTTONUP) {
            static BOOL fImeConfigure = FALSE;

            // prevent recursive
            if (fImeConfigure) {
                // configuration already bring up
                return;
            }

            fImeConfigure = TRUE;
 
       // PopStMenu(hStatusWnd, lpIMC->ptStatusWndPos.x + sImeG.xStatusWi,
       //                         lpIMC->ptStatusWndPos.y);

 
                ContextMenu(hStatusWnd, ptSavCursor.x, ptSavCursor.y);

            fImeConfigure = FALSE;
        } else {
        }

        return;
    } else {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));

        if (HIWORD(lParam) == WM_LBUTTONDOWN) {
            // start drag
            SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
        } else {
            return;
        }
    }

    SetCapture(hStatusWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_XY,
        MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hStatusWnd, &rcWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_OFFSET,
        MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hStatusWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));

    return;
}


/**********************************************************************/
/* StatusWndProc()                                                    */
/**********************************************************************/
//#if defined(UNIIME)
//LRESULT CALLBACK UniStatusWndProc(
//    LPINSTDATAL lpInstL,
//    LPIMEL      lpImeL,
//#else
LRESULT CALLBACK StatusWndProc(
//#endif
    HWND   hStatusWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    
    case WM_DESTROY:
       if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            LONG   lTmpCursor, lTmpOffset;
            POINT  ptCursor;
            HWND   hUIWnd;

            lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);

            // calculate the org by the offset
            lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            DrawDragBorder(hStatusWnd, lTmpCursor, lTmpOffset);
            ReleaseCapture();
                }
      
        DestroyStatusWindow(hStatusWnd);
        break;
    case WM_SETCURSOR:

        StatusSetCursor(
            hStatusWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hStatusWnd,
                GetWindowLong(hStatusWnd, UI_MOVE_XY),
                GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hStatusWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hStatusWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            LONG   lTmpCursor, lTmpOffset;
            POINT  ptCursor;
            HWND   hUIWnd;

            lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);

            // calculate the org by the offset
            lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

            DrawDragBorder(hStatusWnd, lTmpCursor, lTmpOffset);

            ptCursor.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
            ptCursor.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

            SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            ReleaseCapture();

            AdjustStatusBoundary(&ptCursor);

            hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

                   /* SendMessage(GetWindow(hStatusWnd, GW_OWNER), WM_IME_CONTROL,
                IMC_SETSTATUSWINDOWPOS, NULL); */
                        
                    ImmSetStatusWindowPos((HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC),
                &ptCursor);

                        if (lpImeL->wImeStyle == IME_APRS_FIX){         //003
                                 ReInitIme(hStatusWnd,lpImeL->wImeStyle); //#@3
                                 MoveCompCand(GetWindow(hStatusWnd, GW_OWNER));
                        } 

        } else {
            return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETSTATUSWINDOWPOS) {
            SetStatusWindowPos(hStatusWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hStatusWnd, &ps);
            PaintStatusWindow(
                hDC,hStatusWnd);          //zl
            EndPaint(hStatusWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }

    return (0L);
}


/**********************************************************************/
/* DrawDragBorder()                                                   */
/**********************************************************************/
void PASCAL DrawDragBorder(
    HWND hWnd,                  // window of IME is dragged
    LONG lCursorPos,            // the cursor position
    LONG lCursorOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // get cursor position
    x = (*(LPPOINTS)&lCursorPos).x;
    y = (*(LPPOINTS)&lCursorPos).y;

    // calculate the org by the offset
    x -= (*(LPPOINTS)&lCursorOffset).x;
    y -= (*(LPPOINTS)&lCursorOffset).y;

    // check for the min boundary of the display
    if (x < sImeG.rcWorkArea.left) {
        x = sImeG.rcWorkArea.left;
    }

    if (y < sImeG.rcWorkArea.top) {
        y = sImeG.rcWorkArea.top;
    }

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

    if (x + rcWnd.right - rcWnd.left > sImeG.rcWorkArea.right) {
        x = sImeG.rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > sImeG.rcWorkArea.bottom) {
        y = sImeG.rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }

    // draw the moving track
    hDC = CreateDC("DISPLAY", NULL, NULL, NULL);

    if ( hDC == NULL )
        return;

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // ->
    PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
        PATINVERT);
    // v
    PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
        cyBorder, PATINVERT);
    // _>
    PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
        rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
    //  v
    PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
        - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

    DeleteDC(hDC);
    return;
}

/**********************************************************************/
/* AdjustStatusBoundary()                                             */
/**********************************************************************/
void PASCAL AdjustStatusBoundary(
    LPPOINT lppt)
{
    // display boundary check
    if (lppt->x < sImeG.rcWorkArea.left) {
        lppt->x = sImeG.rcWorkArea.left;
    } else if (lppt->x + sImeG.xStatusWi > sImeG.rcWorkArea.right) {
        lppt->x = (sImeG.rcWorkArea.right - sImeG.xStatusWi);
    }

    if (lppt->y < sImeG.rcWorkArea.top) {
        lppt->y = sImeG.rcWorkArea.top;
    } else if (lppt->y + sImeG.yStatusHi > sImeG.rcWorkArea.bottom) {
        lppt->y = (sImeG.rcWorkArea.bottom - sImeG.yStatusHi);
    }

    return;
}

/**********************************************************************/
/* ContextMenuWndProc()                                               */
/**********************************************************************/
LRESULT CALLBACK ContextMenuWndProc(
    HWND        hCMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
            case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_CMENUDESTROYED);
            }
                    break;
            }
                case WM_USER_DESTROY:
        {
            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hCMenuWnd);
                    break;
            }
                case WM_COMMAND:
                {
                        HWND  hUIWnd;
                hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);
                    CommandProc(wParam , GetStatusWnd(hUIWnd));
                        break;
                }
                // switch (wParam) {
                /*
        case IDM_SOFTKBD:
        case IDM_SYMBOL:
            {
                HWND  hUIWnd;
                HIMC  hIMC;
                DWORD fdwConversion;
                DWORD fdwSentence;

                hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);
                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

                ImmGetConversionStatus(hIMC, &fdwConversion,
                    &fdwSentence);

                if (wParam == IDM_SOFTKBD) {
                    ImmSetConversionStatus(hIMC, fdwConversion ^
                        IME_CMODE_SOFTKBD, fdwSentence);
                }

                if (wParam == IDM_SYMBOL) {
                    ImmSetConversionStatus(hIMC, fdwConversion ^
                        IME_CMODE_SYMBOL, fdwSentence);
                }

                SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            }
            break; 
        case IDM_PROPERTIES:

            ImeConfigure(GetKeyboardLayout(0), hCMenuWnd,
                IME_CONFIG_GENERAL, NULL);

            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            break; */
       // default:
       //     return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
       // }
       // break;
                case WM_CLOSE:
        {
            HMENU hMenu;

            GetMenu(hCMenuWnd);

            hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    default:
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/**********************************************************************/
/* DestroyUIWindow()                                                  */
/**********************************************************************/
void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    if (lpUIPrivate->hCMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hCMenuWnd, WM_USER_DESTROY, 0, 0);
    }

    // composition window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
        DestroyWindow(lpUIPrivate->hCompWnd);
    }

    // candidate window need to be destroyed
    if (lpUIPrivate->hCandWnd) {
        DestroyWindow(lpUIPrivate->hCandWnd);
    }

    // status window need to be destroyed
    if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    }

    // soft keyboard window need to be destroyed
    if (lpUIPrivate->hSoftKbdWnd) {
        ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
    }

    GlobalUnlock(hUIPrivate);

    // free storage for UI settings
    GlobalFree(hUIPrivate);

    return;
}
 
/**********************************************************************/
/* CMenuDestryed()                                                    */
/**********************************************************************/
void PASCAL CMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     // Oh! Oh!
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // Oh! Oh!
        return;
    }

    lpUIPrivate->hCMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abcdsp.h ===
/*************************************************
 *  abcdsp.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define IDM_ABOUT       100
#define IDM_HOTKEY      999
/* #define MyIcon               888 */

#define WM_FONTLOAD     WM_USER+0x100

int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
BOOL InitApplication(HANDLE);
BOOL FAR PASCAL About(HWND, unsigned, WORD, LONG);
int FAR PASCAL EnumFunc(LPLOGFONT, LPTEXTMETRIC, short, LPSTR);
int FAR PASCAL EditAdjust(HWND,HFONT);

LONG FAR PASCAL CEditWndProc(HWND,unsigned,WORD,LONG);
PASCAL RedrawScr(int,HWND);
int PASCAL EditPrevChar(int);

#define WM_IMCHANGE     WM_USER+0x200
#define WM_CODE         WM_USER+0x201
#define WM_IMRESET      WM_USER+0x202
#define WM_BACKSPACE    WM_USER+0x203
#define WM_CCREPEAT     WM_USER+0x204

#define DLL_PROLOG 3
#define DBCS_MIN   0xa1
#define SIGN_MASK  0x8000


#define  szGDI        "GDI"
#define  szKBD        "KEYBOARD"
#define  szThisModule    "ABCDSP"  /* It must be the name listed in .def file
                     LIBRARY statement. */
#define  MAXFONTSIZE    128
#define  BITFONT    1
#define  NOTRUETYPE    4
#define  JMP_FAR    (BYTE)0xea    /* Machine code of far jmp */



typedef LONG (FAR PASCAL *LFARPROC) ();


typedef  DWORD (WINAPI *DFARPROC)();

typedef struct tagProCode
{
    BYTE  OneByte;
    DWORD FourByte;
} PROCODE, FAR* LPPROCODE;

typedef struct tagCodeInfo
{
    HANDLE    hCode;
    LPPROCODE CodeAddr;
    PROCODE   OldCode;
    PROCODE   NewCode;
} CODEINFO, FAR* LPCODEINFO;

typedef struct tagDBCFontInfo
{
   TEXTMETRIC tm;
   int     fBold;
   int     fItalicOffset;         /* Use in doing Italic style */
   double  fta;
} DBCFONTINFO, FAR* LPDBCFONTINFO;

typedef struct tagDispDBCInfo
{
    HDC     hDC;
    HDC     hMemDC;
    int     x;
    int     y;
    WORD    DBCode;
    int     FrameWidth;
    int     FrameHeight;
    int     FontSize;
} DISPDBCINFO, FAR* LPDISPDBCINFO;



/* Functions called by CWIN.EXE */
BOOL  WINAPI InitChdisp(HWND);
BOOL  WINAPI QuitChdisp();
void  WINAPI CwinNotify(BOOL, UINT);

/* Substitution functions */
BOOL  WINAPI NewExtTextOut(HDC, int, int, UINT, LPRECT, LPSTR, UINT, LPINT);
DWORD WINAPI NewGetTextExtent(HDC, LPSTR, int);
BOOL  WINAPI NewGetCharWidth(HDC, UINT, UINT, LPINT);
void  WINAPI NewXlat(char _huge*, char _huge*);
void  WINAPI NewXlatBuff(LPSTR, LPSTR, UINT);

/* Now, character set is not changed. ZHX 1-6-1993
HFONT WINAPI B7(int,int,int,int,int,BYTE,BYTE,BYTE,
                      BYTE,BYTE,BYTE,BYTE,BYTE,LPSTR);
HFONT WINAPI B8(LPLOGFONT);
*/

void ChangeCode(HANDLE, HANDLE, LPCODEINFO, char*, char*);
void ChangeProcCode(FARPROC,LPBYTE,FARPROC);
//int    ChangeProcCode2(FARPROC,LPBYTE,FARPROC);
BOOL  OldExtTextOut(HDC, int, int, WORD, LPRECT, LPSTR, WORD, LPINT);
BOOL  OldGetCharWidth(HDC, WORD, WORD, LPINT);
DWORD OldGetTextExtent(HDC, LPSTR, WORD);

void  BitBltChineseChar(void);
int   DoFontStyle(int, int, LPDBCFONTINFO);
void  GetFontStyle(HDC, LPDBCFONTINFO);
BOOL  RestoreProcCode(FARPROC, LPBYTE);
//int    JudgeFont(HDC);
//int    IsPrintDC(HDC);
void  GetChnFace(HDC);

WORD  WINAPI AllocCSToDSAlias(WORD);
//short WINAPI GET_HZ(short,short,short,short,short,LPSTR);
short WINAPI GET_HZ(short,short,short,short,short,char _huge*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abcsda.c ===
/*************************************************
 *  abcsda.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <windows.h>                              
#include <winerror.h>
#include <winuser.h> 
#include <windowsx.h>
#include <immdev.h>
#include <stdio.h>

#include "abc95def.h"
#include "resource.h"
#include "resrc1.h"
//#include "data.H"
#include "abcsda.h"

/*****************************************************
FUCTION: find if the input char is yuanyin or fuyin

ENTRY:     input char
RESULT: STC----fuyin
        CLC----yuanyin
******************************************************/
BOOL WINAPI yuan_or_fu(input_char)
 WORD input_char;
{
    switch (input_char&0xdf){    //change the xiaoxie to Cap, cock
        case 'A':
        case 'E':
        case 'I':
        case 'O':
        case 'U':
            return(CLC);
        default:
            return(STC);
        }
}

/**********************************************************
FUCTION: match the fuyin or fuher fuyin

ENTRY:  input char
RESULT: fill the correct spelling in the communicated buffer
    currect_number
    STC----not match
    CLC----match
************************************************************/
BOOL WINAPI match_and_find_0(input_char)
 WORD input_char;
{
    WORD tmp_chr;
    int i,cnt,begin_pos;
    //if (input_char == 'u')
    //    DebugShow ("match and find 0",0);
    tmp_chr=input_char&0xdf;                //change it to CAP
    for (i=0; i<sizeof sound_cvt_table_index; i++){
        if (tmp_chr==sound_cvt_table_index[i]){
            tmp_chr=0xff;
            break;}//if
        }//for

    if (tmp_chr!=0xff){        //not fuher shengmu
//        if (tmp_chr == 'U' )
/* Because 'I' also dont stand for any ShengMu, so when you type in a ShengMu, 
   'I' should also be ignored.  ,  Fix Bug  27914
   Weibing Zhan,  3-15-1996
*/
        if (tmp_chr == 'U' || tmp_chr == 'I')
            {current_number=0;
            MessageBeep(0);
            return(STC);}
        current_number=1;
        sda_out[0]=input_char;
        return(CLC);
        }

    tmp_chr=sound_cvt_table_value[i];
    if (tmp_chr==DK_RP){
        current_number=1;
        sda_out[0]=DK_RP;
        return(CLC);
        }

    begin_pos=(tmp_chr-1)*5;
    cnt=0;
    while (slbl_tab[begin_pos]!=0x30){
        sda_out[cnt++]=(WORD)(slbl_tab[begin_pos++]|0x20);    //change to small letter
        }        //get the fuher shengmu
    current_number=(BYTE)cnt;
    return(CLC);

}


/**********************************************************
FUCTION: match the fuyin or fuher fuyin

ENTRY:  input char
RESULT: fill the correct spelling in the communicated buffer
    currect_number
    STC----not match
    CLC----match
************************************************************/
BOOL WINAPI match_and_find_1(input_char)
WORD input_char;
{
    WORD tmp_chr,sy_pos;

    tmp_chr=input_char;
    tmp_chr=(tmp_chr&0xdf)-0x41;    //sub "a"
    tmp_chr&=0xff;

    sy_pos=rule_buf[rule_pointer-1].chr;
    sy_pos-=0x61;    //sub "a"
    sy_pos=sy_tab_base[sy_pos*26+tmp_chr];
    if (!sy_pos){
        MessageBeep(0);
        sda_out[0]=0xff;
        return(STC);
        }

    tmp_chr=input_char&0xdf;
    tmp_chr-=0x41;        //sub "A"
    tmp_chr=sy_tab1[tmp_chr*2+sy_pos-1];
    got_py(tmp_chr);
    return(CLC);

}

BOOL WINAPI got_py(tmp_chr)
 WORD tmp_chr;
{
    int begin_pos,i;

    if (tmp_chr>=0x41){
        sda_out[0]=tmp_chr|0x20;
        current_number=1;
        }
    else{
        begin_pos=(tmp_chr-1)*5;
        i=0;
        while (slbl_tab[begin_pos]>0x30)
            sda_out[i++]=(WORD)(slbl_tab[begin_pos++]|0x20);    //change to small letter
        current_number=(BYTE)i;
        }

return 0;

}



/****************************************************
FUCTION: change the input char to correct spelling.

ENTRY:  STC-----not match
        CLC-----match
*****************************************************/
BOOL WINAPI match_and_find(input_char)
WORD input_char;
{
    if (current_flag&0x10)
    {
        if (match_and_find_1(input_char))
            return(1);            //display shengmu tishi
        else
            return(-1);
    }//if
    else
    {
        if (!(match_and_find_0(input_char)))    //find yumu
            return(-1);
        else {
            find_tishi_pp(input_char);
            return(0);
            }
        }//else
}


/*******************************************************
find_tish_pp(): find the yumu which can match with the
        shengmu.

ENTRY: input char
RESULT: yumu in the yu_tishi[] buffer.
*********************************************************/
BOOL WINAPI find_tishi_pp(input_char)
WORD input_char;
{
    int n,i,cnt,tmp_num;
    int begin_pos,match_flag;
    BYTE key_match;

    for (i=0; i<34*4; i++){
        Key_Exc_Value[i]=0x20;
        }

    key_match='a';
    begin_pos=(input_char-0x61)*26;
    for (i=begin_pos; i<begin_pos+26; i++){
        match_flag=sy_tab_base[i];
        if (match_flag){
            tmp_num=sy_tab1[(key_match-0x61)*2+match_flag-1];

            cnt=Key_Pos_Array[key_match-'a']*4;    //one key has 4 units

            if (tmp_num>=0x30){
                Key_Exc_Value[cnt]=(BYTE)tmp_num;
                }//if(tmp_num)
            else{
                n=(tmp_num-1)*5;
                while (slbl_tab[n]>0x30)
                    Key_Exc_Value[cnt++]=slbl_tab[n++];
                }//else

            }//if(match_flag)
        key_match++;
        }//for
return 0;                        //##!!
}

/*******************************************************
FUCTION: fill the ruler buffer.
********************************************************/
BOOL WINAPI fill_rule(input_char)
WORD input_char;
{
    input_sum+=current_number;
    if (input_sum>40){             //94/4/21 >=40
        sda_out[0]=0xff;    //if input are more than 40 chars,
        input_sum -= current_number;
        MessageBeep(0);
        return(STC);}        //don't input anymore
    else{
        rule_buf[rule_pointer].length=current_number;
        rule_buf[rule_pointer].type=current_flag;
        rule_buf[rule_pointer].chr=input_char;
        rule_pointer++;
        return(CLC);
         }
}

/********************************************************
FUNCTION: find out the input char's character

ENTRY: input_char
RESULT: current_flag & char identification
        current_flag definication:
            7         6             5         4             3         2             1         0
            |      |        |      |     |      |        |      |________1=fuyin
            |      |        |      |        |      |        |______________0
            |      |        |      |        |      |____________________0
            |      |        |      |        |__________________________0
            |      |        |      |___________________0=this key is fuyin
            |      |        |                  1=this key is yunmu
            |      |        |_________________________1=number
            |      |_______________________________0
            |_____________________________________1=zimu


********************************************************/
int WINAPI chr_type(input_char)
WORD input_char;
{

    if (!rule_pointer)
        current_flag=0;
    else
        current_flag=rule_buf[rule_pointer-1].type&0x10;

    if (input_char==VK_BACK)
        return(SDA_DELETE);

    switch (input_char) {             //1993.4.20 omit the arrow key
    
        case VK_SPACE:          //can't edit in SDA method
            return(SPACE);
        case VK_LEFT+0x100:        //in C_input, VK_LEFT etc plus 0x100
        case VK_UP+0x100:
        case VK_RIGHT+0x100:
        case VK_DOWN+0x100:
            return(CURSOR);
    
        }

    if (input_char==VK_ESCAPE)
        return(ESCAPE);

    if (input_char<0x20)
        return(FUC_CHR);    //function key, just return key value

    if ((input_char>=0x30) && (input_char<0x3a)){
        current_flag|=0x30;         //00110000b mark number and set this key
//94 4,8        current_flag = 0x20;
        return(SDA_NUMBER);}            //is yumu

    if ((input_char>=0x61) && (input_char<=0x7a)){
        if (rule_pointer){
            if (current_flag)        //if last current_flag need fuyn
                current_flag=0;        //current_flag need yuanyin.
            else                     //vice versa
                current_flag=0x10;
            }
        if (yuan_or_fu(input_char))        //yuan=CLC
            current_flag|=0x88;          //10001000b   yuan
        else
            current_flag|=0x81;          //10000001b      fu
        return(CHR);}

    if ((input_char>=0x41) && (input_char<=0x5a)){
        current_flag=0x90;        //10010000b;   CAP=yunmu
        return(CAP_CHR);}

    if ((input_char==DK_SUB)||(input_char==DK_ZHENGX)||(input_char==DK_FANX))
    {
        current_flag=0x30;         //produce like number
 //94 4,8        current_flag = 0x20;
        return(SDA_NUMBER);
    }

    if ((input_char==DK_LP)||(input_char==DK_RP)){
        current_flag=0x88;    //input is yuanyin 'o',
        return(CHR);            //and we need yumu at this time
        }

    return(FUC_CHR);    //rest key return

}


/******************************************************
disp_tishi(): send WM_PAINT message to the dialog
          in order to display the help
*******************************************************/
void WINAPI disp_tishi(hIMC, mark)
HIMC hIMC;
int mark;
{
    int i, j /*cnt*/,k;

//DebugShow("mark",mark);
if (mark == 9) {mark = disp_mark;}

disp_mark = mark; 

j=0;
if (mark){        //Shengmu tishi
    for (i=0; i<34; i++)
        for (k=0; k<4; k++)
            
        Key_Exc_Value[j++]=Sheng_Tishi[i][k];

    /*for (i=0; i<4; i++){
        cnt=Key_Pos_Array[Sheng_Mu[i]-'A']*4;
        Key_Exc_Value[cnt++]=Sheng_Tishi[j++]; //get fuhe shengmu
        Key_Exc_Value[cnt++]=Sheng_Tishi[j++];
        cnt+=2;   //4 units for one sheng mu
        }//for*/
    }//if

//SendMessage(hSdaKeyBWnd,MD_PAINT, 0x80, 0l);

return ;
}


FAR PASCAL tran_data(hdSdaFlag, hIMC, Sd_Open_flag)
int hdSdaFlag;            //HWND Return;
HIMC hIMC;
BYTE Sd_Open_flag;
{

    Sd_Open=Sd_Open_flag;
    if (hdSdaFlag==0)
    {
    // ShowWindow(hSdaKeyBWnd, SW_SHOWNOACTIVATE);
    // UpdateWindow(hSdaKeyBWnd);

     return TRUE;
    }
    if (hdSdaFlag==1)
    {
    // DestroyWindow(hSdaKeyBWnd);
     return TRUE;
    }

    if (hdSdaFlag==2)
    {
    // ShowWindow(hSdaKeyBWnd, SW_HIDE);
    // UpdateWindow(hSdaKeyBWnd);
     return TRUE;
    }
     disp_tishi(hIMC,9);
   // sda_ts(hIMC,WM_PAINT, 0, 0l);
return TRUE;    //InitKeyWindow(hdSdaProc, hIMC, hCursor);
}


int FAR PASCAL sda_proc(input_char,sda_trans,step_mode,hIMC)
WORD input_char;
LPWORD sda_trans;                //sda_out is WORD
BYTE step_mode;
HIMC hIMC;

{
    int i;
    int disp_flag;

    sda_out=sda_trans;

    if (step_mode==SELECT){
        if ((input_char>=0x61) && (input_char<=0x7a)){
            input_sum=0;
            rule_pointer=0;     //if on SELECT step, and input ascii
            current_number=0;}  //reset the pointer
        }

    if ((step_mode==START)||(step_mode==RESELECT)){
        input_sum=0;
        rule_pointer=0;
        current_number=0;
        }

    switch(chr_type(input_char)){

        case FUC_CHR:
            sda_out[0]=input_char;
            if (step_mode==ONINPUT){
               if (!Sd_Open){      //for display keyboard
                sda_out[0]=0xf0;    //sign for main progress destroy the dialog
                sda_out[1]=input_char;
//                DestroyWindow(hSdaKeyBWnd);
                }//if (Sd_Open)
               }
            return(CLC);

        case SDA_NUMBER:
        case CAP_CHR:
            if ( input_sum >= 40 )
            {
               sda_out[0] = input_char;
               return(STC);
            }

            current_number=1;
            if (fill_rule(input_char)){
                sda_out[0]=input_char;
                disp_tishi(hIMC, 1);
                return(CLC);}
            else
                return(STC);

        case SDA_DELETE:
            if ((!rule_pointer) || (step_mode!=ONINPUT)){
                sda_out[0]=VK_BACK;
                return(CLC);
                }

            rule_pointer--;        //rule_pointer go back one key
            for (i=0; i<rule_buf[rule_pointer].length; i++)
                sda_out[i]=VK_BACK;

            input_sum -= (BYTE)i;          /* 94/4/21 input sum should sub when del */

            if(!rule_pointer)
            {
                if (!Sd_Open)
                {
                sda_out[0]=0xf0;
                sda_out[1]=VK_ESCAPE;
//                DestroyWindow(hSdaKeyBWnd);
                return (CLC);
                }
                else
                {
                sda_out[0] = VK_BACK;
                disp_tishi(hIMC, 1);
                return (CLC);
                }
            }
            if ( rule_buf[rule_pointer-1].type&0x30 )
                disp_tishi(hIMC, 1);
            else
            {
                find_tishi_pp(rule_buf[rule_pointer-1].chr);
                disp_tishi(hIMC, 0);

            }

            return(CLC);

        case ESCAPE:
            sda_out[0]=VK_ESCAPE;
            if (!Sd_Open){
                sda_out[0]=0xf0;
                sda_out[1]=VK_ESCAPE;
//                DestroyWindow(hSdaKeyBWnd);
                }
            else
                disp_tishi(hIMC, 1);        //1993.4

            return(CLC);

        case SPACE:
            sda_out[0]=VK_SPACE;
            if (step_mode==ONINPUT){
                if (!Sd_Open){
                sda_out[0]=0xf0;    //sign for main progress destroy the dialog
                sda_out[1]=VK_SPACE;
//                DestroyWindow(hSdaKeyBWnd);
                }
                else
                disp_tishi(hIMC, 1);        //1993,4
                }
            return(CLC);
        case CURSOR:
            sda_out[0]=0;
            MessageBeep((UINT)-1);
            return(STC);
        case CHR:
            if ( input_sum >= 40 )
            {
               sda_out[0] = input_char;
               return(STC);
            }

            if ((input_char==DK_LP)||(input_char==DK_RP)){
              if(rule_buf[rule_pointer-1].chr!='o')
                input_char='o';        //1993.2 if left and right pie
              else {
                   MessageBeep(0);
                   return(STC);
                   }
              }

                            //produce like shengmu "o"
            disp_flag = match_and_find(input_char);
            if (disp_flag == -1 )
               return(STC);
            else
            {
               if (fill_rule(input_char))
               {
                   disp_tishi(hIMC, disp_flag);
                   return(CLC);
               }
               else
                   return(STC);
            }
        }

        return STC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abcsda.h ===
/*************************************************
 *  abcsda.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


#define CHR        1
#define SDA_NUMBER    2
#define SDA_DELETE    3
#define CAP_CHR    4
#define FUC_CHR    5
#define SPACE   6
#define ESCAPE    7
#define DK_SUB    0x2d           //    "-"seperator
#define DK_FANX 0x5c           //       "\"
#define DK_ZHENGX 0x2f           //    "/"
#define DK_LP    0x60
#define DK_RP    0x27           //       " ' " seperator
#define CURSOR  8
#define ZH        1
#define SH        2
#define VH         3
#define S        2

#define FIRST_KEY_TOP    4//10
#define FIRST_KEY_LEFT  5//10
#define KEY_WIDTH    24//25//20//32  //35
#define KEY_HIGH    28//7
#define KEY_GAP        -1//0
#define INC        3

#define KEYBOARD_W      546
#define KEYBOARD_H    128    //135

BYTE current_flag=0;
BYTE current_number=0;
BYTE rule_pointer=0;
BYTE input_sum=0;

BYTE sound_cvt_table_index[]="AEVO\0";
BYTE sound_cvt_table_value[]={ZH,VH,SH,DK_RP};

RECT Rect;
RECT here;
RECT Base_key;
RECT Special_key;
RECT Middle_key;
RECT rectMax;                         //Mouse move validate area.


HANDLE old_brush;
HANDLE front_brush;
HANDLE old_pen;
HPEN pen;
HFONT T_font,B_font,S_font;

HWND hW, hSdaKeyBWnd;
HWND Re;
FARPROC FAR *lp;
HCURSOR Hand_Cursor;
LPRECT win_size;
BYTE Sd_Open;

unsigned char key_array[]={8,12,11,10};
int    f_key[5]={24,36,42,60};

BYTE Sheng_Mu[]="AEVO\0";
BYTE Sheng_Tishi[34][5]={"Q    ",
                         "W    ",
                         "CH   ",
                         "R    ",    
                         "T    ",
                         "Y    ",
                         "U    ",
                         "I    ",    
                         "'    ",
                         "P    ",
                         "     ",
                         "     ",
                         //"\\    ",
                         "ZH   ",
                         "S    ",
                         "D    ",    
                         "F    ",
                         "G    ",
                         "H    ",
                         "J    ",    
                         "K    ",
                         "L    ",
                         "     ", 
                         "     ",
                         "Z    ",
                         "X    ",
                         "C    ",    
                         "SH   ",
                         "B    ",
                         "N    ",
                         "M    ",    
                         "     ",
                         "     ",
                         "     "};


//BYTE Sheng_Tishi[]="ZHCHSH' \0";
BYTE bx_tishi[]="һدؼʮ"
        "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20";
BYTE jianpan[]="`1234567890"
           "\x2d"
           "=\x5c";
BYTE left_key[]="Esc  "
        "Tab  "
        "Caps "
        "Shift";
BYTE left_key_cnt[]={3,3,4,5};
BYTE right_key[]="Back "
         "Enter"
         "Space"
         "Ctrl+'-'";
BYTE right_key_cnt[]={4,5,5,8};

BYTE Key_Pos_Array[]={0xc,0x1b,0x19,0xe,0x2,0xf,0x10,0x11,0x7,0x12,
            0x13,0x14,0x1d,0x1c,0x8,0x9,0x0,0x3,0xd,
            0x4,0x6,0x1a,0x1,0x18,0x5,0x17};
BYTE Key_Exc_Value[34*4]={0};
BYTE Key_Real_Value[33]="QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,./";


BYTE unused [40];
BYTE index;

LPWORD sda_out;

FARPROC FAR *lp;
HWND Re;

int PointFlag=0;
WORD NowFocus;
RECT Push_b;
int disp_mark = 1;


BYTE xxxx[40]={0};

extern BYTE slbl_tab[];  
/*  Because this var is defined already in abcw2.h, do not duplicate definition
    to avoid build warning 
            ="ZH00\1"
             "SH00\2"
             "CH00\3"
             "ING0\4"
             "AI00\5"
             "AN00\6"
             "ANG0\7"
     "AO00\x8"
     "EI00\x9"
     "EN00\xa"
     "ENG0\xb"
     "IA00\xc"
     "IAN0\xd"
     "IANG\xe"
     "IAO0\xf"
     "IE00\x10"
     "IN00\x11"
     "IU00\x12"
     "ONG0\x13"
     "OU00\x14"
     "UA00\x15"
     "UAI0\x16"
     "UAN0\x17"
     "UE00\x18"
     "UN00\x19"
     "UENG\x1a"                     //SC4K6c?*DBASE={<I5D1AH
     "UI00\x1b"
     "UO00\x1c" 
     "UANG\x1d"
     "ER00\x1e"
     "IONG\x1f"
     "VE00\x18"
     "UEN0\x19"
     "VEN0\x19"
     "UEI0\x1b"
     "IOU0\x12";  */

BYTE sy_tab1[]={'A',0,                //a
         20,0,                //b=ou
         17,22,                //c=in
         21,12,                //d=ua,ia 1993.2.1
         'E',0,             //e="E"
         10,0,                       //f=en
         11,0,                       //g=eng
         7,0,                      //h=ang
         'I',0,                     //i=i
         6,0,                       //j=an
         8,0,                        //k=ao
         5,0,                       //l=ai
         24,27,                       //m=ue,ui
         25,'N',                     //n=un,"N'
         'O',28,                //o='O'
         23,23,                  //p=uan,uan
         9,0,                        //Q=ei
         18,30,                        //R=ui,er
         31,19,                     //s=iong,ong
         29,14,                      //t=uang,iang
         'U',0,                        //u="U"
         'V',0,                          //Q="V"
         13,0,                        //w=ian
         16,0,                        //k=ie
         4,0,                        //g=ing
         15,0};                        //z=iao


///////////////////////////////////////////////////////////////////////
//      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
///////////////////////////////////////////////////////////////////////
BYTE sy_tab_base[]={
        1,1,S,1,1,1,1,1,1,1,1,1,S,1,S,S,1,0,S,1,1,0,0,0,0,0,     //FK_A
        1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,     //FK_B
        1,1,0,0,1,1,1,1,1,1,1,1,S,1,S,1,1,0,S,0,1,0,0,0,0,0,     //FK_C
        1,1,0,S,1,1,1,1,1,1,1,1,S,1,S,S,1,1,S,0,1,0,1,1,1,1,     //FK_D
        1,1,S,0,1,1,1,1,1,1,1,1,S,1,S,S,0,0,S,1,1,0,0,0,0,0,     //FK_E
        1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,     //FK_F
        1,1,S,1,1,1,1,1,0,1,1,1,S,1,S,S,1,0,S,1,1,0,0,0,0,0,     //FK_G
        1,1,S,1,1,1,1,1,0,1,1,1,S,1,S,S,1,0,S,1,1,0,0,0,0,0,     //FK_H
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,     //FK_I
        0,0,1,S,0,0,0,0,1,0,0,0,1,1,0,1,0,1,1,S,0,1,1,1,1,1,     //FK_J
        1,1,S,1,1,1,1,1,0,1,1,1,S,1,S,S,1,0,S,1,1,0,0,0,0,0,     //FK_K
        1,1,1,S,1,0,1,1,1,1,1,1,1,1,S,S,1,1,S,S,1,1,1,1,1,1,     //FK_L
        1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,1,1,     //FK_M
        1,1,1,0,1,1,1,1,1,1,1,1,1,1,S,S,1,1,S,S,1,1,1,1,1,1,     //FK_N
        1,1,0,0,1,1,1,1,0,1,1,1,0,0,1,0,1,S,0,0,0,0,0,0,0,0,     //FK_O
        1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,     //FK_P
        0,0,1,S,0,0,0,0,1,0,0,0,1,1,0,1,0,1,1,S,1,1,1,1,1,1,     //FK_Q
        0,1,0,1,1,1,1,1,1,1,1,0,S,1,S,S,0,0,S,0,1,0,0,0,0,0,     //FK_R
        1,1,0,0,1,1,1,1,1,1,1,1,S,1,S,S,0,0,S,0,1,0,0,0,0,0,     //FK_S
        1,1,0,0,1,0,1,1,1,1,1,1,S,1,S,S,1,0,S,0,1,0,1,1,1,1,     //FK_T
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,     //FK_U
        1,1,S,1,1,1,1,1,1,1,1,1,S,1,S,S,1,S,0,1,1,0,0,0,0,0,     //FK_V
        1,0,0,0,0,1,1,1,0,1,0,1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,     //FK_W
        0,0,1,S,0,0,0,0,1,0,0,0,1,1,1,1,0,1,1,S,0,1,1,1,1,1,     //FK_X
        1,1,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,S,0,1,0,0,0,1,0,     //FK_Y
        1,1,0,0,1,1,1,1,1,1,1,1,S,1,S,S,1,0,S,0,1,0,0,0,0,0};     //FK_Z
///////////////////////////////////////////////////////////////////////
//      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
///////////////////////////////////////////////////////////////////////

struct RULE{
    BYTE length;
    BYTE type;
    WORD chr;
    }rule_buf[30];



int WINAPI DebugShow( LPSTR msg1, int msg2);

int FAR PASCAL sda_proc(WORD, LPWORD, BYTE, HIMC);
void WINAPI sda_ts(HIMC, UINT, WPARAM, LPARAM);
int FAR PASCAL tran_data(int, HIMC, BYTE);
int FAR PASCAL tran_data2(int);
LONG FAR PASCAL Diaman(HWND,unsigned int,WORD,LONG);

int WINAPI chr_type(WORD);
BOOL WINAPI yuan_or_fu(WORD);
BOOL WINAPI fill_rule(WORD);
BOOL WINAPI match_and_find(WORD);
BOOL WINAPI match_and_find_0(WORD);
BOOL WINAPI match_and_find_1(WORD);
BOOL WINAPI got_py(WORD);
BOOL WINAPI find_tishi_pp(WORD);
void WINAPI disp_tishi(HIMC hIMC, int mark);
void WINAPI get_rect_base();
BOOL WINAPI get_rect_left(BYTE);
BOOL WINAPI get_rect_right(BYTE);
BOOL WINAPI get_rect_mid(BYTE);
void WINAPI paint_key(HDC hDC);
void WINAPI paint_key2(HDC hDC);
void WINAPI paint_first_line(HDC hDC);
void WINAPI paint_mid_key(HDC hDC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\new.h ===
/*************************************************
 *  new.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define ID_ADD                      101
#define ID_DEL                      102
#define ID_NEWCHR                   104
#define ID_SHU                      106
#define ID_LISTBOX                  109
#define ID_TS1                      103
#define ID_TS2                      105
#define ID_TS3                      108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\abcw2.h ===
/*************************************************
 *  abcw2.h                                      *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

extern CHAR SKLayoutS[NumsSK];
extern CHAR SKLayout[NumsSK][48*2]; 
extern CHAR PcKb[48*2],SdaKb[48*2];
extern CHAR SPcKb[48*2],SSdaKb[48*2];

extern LPIMEL lpImeL;
extern IMEG sImeG ;


#define WM_NEW_DEF_CODE         1993+0x400      //1993.4.19
#define WM_NEW_DEF_RESTORE      1993+0x401      //1993.4.19


HIMC ghIMC = 0;
LPINPUTCONTEXT glpIMC;
LPPRIVCONTEXT  glpIMCP; 
int wait_flag , waitzl_flag;                   //waitzl    6
int TypeOfOutMsg;
int biaodian_len;

BYTE I_U_Flag=0;        //produce the "i, u" input

            


struct INPUT_TISHI prompt[1];

struct INPT_BF in={40,0,{0}};
struct W_SLBL wp;
struct ATTR msx_area[120];
struct INDEX ndx;
struct INDEX kzk_ndx;
struct TBF FAR *cisu;
struct PD_TAB pindu;
struct FMT now={10,53,27};
struct T_REM tmmr;

int form[]  ={10,/*9*/8,5,/*4*/4,3,2,2,1,1,1};        //form[0] not used

BYTE spbx_tab[((87-15)*94+15)/16*16+16]={0};

BYTE logging_stack[0x400]={0};
WORD logging_stack_size=sizeof logging_stack;
                        

/*******************************************
 display result area DATA
**********************************************/
unsigned char space_char[]={0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20};
BYTE out_svw[400];
unsigned char group_counter[]="0.";
    
/*********************************************
 input area DATA
**********************************************/
int input_cur;
int new_no;
int jlxw_mode;
int jiyi_mode;

/******************************************************
 result area DATA
*******************************************************/
int result_area_pointer;
BYTE result_area[40];
BYTE out_result_area[40];
WORD out_bfb[40];
int out_pointer;
int now_cs;
int now_cs_dot;


/********************************************
 biaodian table
*********************************************/
//unsigned char biaodian_table[]="~`!@?():<>,.;_\x22\x27";                 //Note \0x22 will be 0 x 2 2
//unsigned char cc_biaodian[]="";

unsigned char biaodian_table[]="@&$^\\!@?():<>,.;_\x22\x27";                 //Note \0x22 will be 0 x 2 2
unsigned char cc_biaodian[]="";


int biaodian_pos;
WORD biaodian_value;
BYTE yinhao_flag=0;

/*******************************************
 control variabe
********************************************/
//BYTE int_asc_mode=0;    // int or half character switch
extern BYTE step_mode;
//BYTE cp_ajust_flag;
BYTE bdd_flag;          // the function of punctuation switch
//BYTE cbx_flag =0;       // for written-stroke input flag
            // =0 NO writen-stroke input module
            // =1 the method with STD_MODE
            // =2 ............... SDA_MODE
BOOL IfTopMost;        // top window flag

BYTE word_back_flag;
BYTE msg_type;

/*****************************************
temp memory area
******************************************/
BYTE temp_rem_area[512];
BYTE rem_area[512];

/**************************************
display buffer parameter
***************************************/
BYTE out_length;
BYTE last_out_length;
BYTE cap_mode;


/******************************************
user_definition parameter
*******************************************/
WORD mulu_record_length=10;
WORD data_record_length=32;
WORD mulu_true_length=56;
WORD data_start=0x1000;
WORD mulu_max_length=0x1000;
BYTE user_word_max_length=32;


OFSTRUCT reopen;
HWND active_win_keep;
BYTE d_yinhao_flag=0,book_name=0,book_name_sub=0;  


/*******************************************************************
This part of defination is cut from the beginning of ABCW.c
********************************************************************/



BYTE SdaPromptOpen=0,DefNewNow=0;             //cock

FARPROC _hh1,_hh2;
HANDLE hInst;
HANDLE  cisu_hd;
HCURSOR hCursor;        //1993.2

FARPROC FAR *hh1,*hh2;

FARPROC lpFunc,lpFunc2;
HANDLE mdl;
BYTE opt_flag;

BYTE kb_buffer[35];
int OldCaps;

BYTE in_buffer[1];              /* buffer for input */

int n,end_flg,CharHi,CharWi;
HFONT hFont;
HFONT hOldFont;
HFONT hSFont=0;
HPEN hPen;

BYTE V_Flag=0;                  // V input flag

OFSTRUCT ofstruct;

HDC hDC;
HDC hMemoryDC;
HBITMAP cur_h;
int count2;

int pass_word=0;
HWND NowFocus,OptFocus;                    //keep the user's focus

BOOL cur_flag=0,op_flag;
WORD old_curx=CUR_START_X,cur_hibit=1,cur_start_ps=0,cur_start_count=0;

HWND hWnd,act_focus;

int input_count=0;
int kb_mode=CIN_STD,kb_flag = 0xffff;
int local_focus=0;
int timer_counter=0;
int msg_count=0;
BYTE msg_bf[50];
TimerCounter=2;

KeyBoardState=0;
SdaInst = 0;
HWND Return;
HWND act_win;

HANDLE Hdopt;                   //for dynamic call .dll proc
unsigned char jiyi[]="{}";
WORD sda_trans[5]={9,9,9,9,0};

HWND hInputWnd;
HWND hABCWnd;

char ExeCmdLine[]="abcwin 0";
BYTE UpdateFlag=0;              //1993.3 increase the user.rem
char jiyi_wenjian_cuo[]="ģûļ!";

BYTE InputBuffer[43];
WORD SoftKeyNum=0;

TCHAR    tmmr_rem[MAX_PATH];
TCHAR    user_lib[MAX_PATH];

HANDLE hAccTable;

HANDLE hImeL;
LPIMEL lpImeL;

int MoveFlag = 0;
POINT pot;
HWND hSetOp =0,NewWordWin=0;

char  *szMsgStr[] = { "0","0"};          // messages shown on diff sections

BYTE Sd_Open_flag=0;            //flag for display the keyboard
BYTE kb_mode_save=0;            //1993.4.19

/******************************************************************
This part of defination is cut from ABCWM.c
*******************************************************************/
char TMMR_OPEN_WRONG[]= "ļ򿪴";

/******************************************************************
This part of defination is cut before DIAMAN.c
*******************************************************************/
BYTE cpjy,bxsr,qj,bdzh;

/******************************************************************
This part of defination is cut before OKRETURN.c
*******************************************************************/
OFSTRUCT ofs;

struct SLBL sb;
struct N_SLBL neg;

BYTE slbl_tab[]="ZH00\1"
             "SH00\2"
             "CH00\3"
             "ING0\4"
             "AI00\5"
             "AN00\6"
             "ANG0\7"
     "AO00\x8"
     "EI00\x9"
     "EN00\xa"
     "ENG0\xb"
     "IA00\xc"
     "IAN0\xd"
     "IANG\xe"
     "IAO0\xf"
     "IE00\x10"
     "IN00\x11"
     "IU00\x12"
     "ONG0\x13"
     "OU00\x14"
     "UA00\x15"
     "UAI0\x16"
     "UAN0\x17"
     "UE00\x18"
     "UN00\x19"
     "UENG\x1a"                     //SC4K6c?*DBASE={<I5D1AH
     "UI00\x1b"
     "UO00\x1c"
     "UANG\x1d"
     "ER00\x1e"
     "IONG\x1f"
     "VE00\x18"
     "UEN0\x19"
     "VEN0\x19"
     "UEI0\x1b"
     "IOU0\x12";

OFSTRUCT openbuf;
OFSTRUCT openbuf_kzk,open_user,open_tmmr;


BYTE buffer[30];

BYTE cmp_head,cmp_state,cmp_bx,by_cchar_flag;
WORD cmp_yj,cmp_cisu;

// about search lib
LONG r_addr;
WORD out_svw_cnt,msx_area_cnt;
WORD search_start,search_end,kzk_search_start,kzk_search_end;
WORD item_length,kzk_item_length,last_item_name,item_addr,slib_addr;
BYTE word_lib_state;
WORD lib_w[0xa00];
WORD kzk_lib_w[0x400];
BYTE auto_mode,word_source,xs_flag,sfx_attr,jiyi_pindu,system_info;
BYTE stack1_move_counter;
WORD extb_ps;

/******************************************************************
This part of defination is cut before READ_A_PAGE.c
*******************************************************************/
char *std_dct="winabc.cwd";
char *user_dct="user.rem";
BYTE last_flag;
LONG last_start_ps;
WORD last_size;

/******************************************************************
This part of defination is cut before REM_PD1.c
*******************************************************************/
BYTE stack1_move_counter;



//................................................................
//               function tables definition
//
char fk_tab[]="01һ23456789SʮBQǧ"
           "\0\1Ҽ\2\3\4\5\6½\7\x8\x9sʰbqǪ"
           "G" 
           "W" 
           "Z" 
           "N" 
           "Y" 
           "R" 
           "J" 
           "D" 
           "$Ԫ" 
           "K" 
           "M" 
           "F" 
           "L" 
           "T" 
           "E" 
           "O" 
           "Hʱ" 
           "P" 
           "C" 
           "U΢" 
           "A" 
           "I" 
           "X" 
           "+"                  
           "-" 
           "*" 
           "/";    
          
          

WORD sfx_table[]={
                //    DA-                 1 
    0x102, 0x80CC,              //0x80C4,
                //     DE-                  1
    0x202, 0x80E6,              //0x80DE,
                //     BA-                  1
    0x202, 0x2048,
                //     BAI-                1 
    0x102, 0x2056,
                //     BAN-                 1
    0x202, 0x205F,
                //     BAN-                1 
    0x102, 0x206A,
                //     BAO-                 1
    0x202, 0x2085,
                //     BEN-                1 
    0x102, 0x209B,
                //     BIAN-                1
    0x202, 0x20BC,
                //     BIAO-                1
    0x202, 0x20CA,
                //     BU-                 1 
    0x102, 0x8058,               //0x8054,
                //     BU-                  1
    0x202, 0x20FA,
                //     C,ANG-              1 
    0x102, 0x8088,               //0x8080,
                //     C,ANG-               1
    0x202, 0x808E,              //0x8086,
                //     C,AO-               1 
    0x102, 0x2145,
                //     C,E-                 1
    0x202, 0x8098,               //0x8090,
                // 3    C,U-                 1
    0x202, 0x218F,
                //     C,U-                 1
    0x202, 0x219D,
                //     C,UN-               1 
    0x102, 0x21B6,
                //     CONG-                1
    0x202, 0x21CB,
                //     CUN-                 1
    0x202, 0x21DC,
                //     DAI-                 1
    0x202, 0x21EF,
                //     DAN-                1 
    0x102, 0x80D6,              //0x80CE,
                //     DANG-                1
    0x202, 0x2208,
                //     DAO-                 1
    0x202, 0x2212,
                //     DI-                 1 
    0x102, 0x2222,
                //     DI-                 1 
    0x102, 0x80F4,              //0x80EC,
                //     DI-                  1
    0x202, 0x80F8,              //0x80F0,
                //     DIAN-                1
    0x202, 0x2238,
                //     DIAN-               1 
    0x102, 0x223C,
                //   DIAN-ZI-            1 
    0x104, 0x223C, 0x2EA4,
                //     DIAO-                1
    0x202, 0x2249,
                // ,    DU-                  1
    0x202, 0x8116,               //0x810E,
                //     DUAN-               1 
    0x102, 0x227F,
                //     DUI-                 1
    0x202, 0x2286,
                //     DUO-                11
    0x302, 0x2293,
                //     E-                   1
    0x202, 0x22A1,
                //     FA-                  1
    0x202, 0x22B9,
                //     FANG-               1 
    0x102, 0x22D1,
                //     FEI-                1 
    0x102, 0x22D8,
                //     FEI-                 1
    0x202, 0x22E2,
                //     FEN-                 1
    0x202, 0x22EC,
                //     FENG-                1
    0x202, 0x22F8,
                //     FU-                 1 
    0x102, 0x2320,
                //     GAI-                1 
    0x102, 0x2332,
                //     GAN-                 1
    0x202, 0x233F,
                //     GAO-                1 
    0x102, 0x234E,
                //     GE-                 1 
    0x102, 0x2366,
                //     GENG-               1 
    0x102, 0x236B,
                //     GONG-                1
    0x202, 0x2371,
                //     GONG-               1 
    0x102, 0x237F,
                //     GU-                 1 
    0x102, 0x2392,
                //     GUAN-                1
    0x202, 0x23A8,
                //     GUO-                 1
    0x202, 0x23C7,
                //     ,AO-                1 
    0x102, 0x23EE,
                //     ,EI-                1 
    0x102, 0x2405,
                //     ,EN-                1 
    0x102, 0x2407,
                //     ,ONG-               1 
    0x102, 0x819E,              //0x8194,
                //     ,OU-                 1
    0x202, 0x241E,
                // ;    ,U-                  1
    0x202, 0x2430,
                //     ,UA-                 1
    0x202, 0x2438,
                //     ,UAI-               1 
    0x102, 0x243E,
                //     ,UI-                 1
    0x202, 0x81B0,              //0x81A6,
                //     ,UO-                 1
    0x202, 0x247E,
                //     JI-                  1
    0x202, 0x2483,
                //     JIA-                 1
    0x202, 0x81CC,              //0x81C2,
                //     JIAN-                1
    0x202, 0x24E5,
                //     JIANG-               1
    0x202, 0x24F6,
                //     JIE-                 1
    0x202, 0x252C,
                //     JIN-                 1
    0x202, 0x2535,
                //     JIU-                1 
    0x102, 0x256C,
                //     JU-                  1
    0x202, 0x2579,
                //     JUN-                 1
    0x202, 0x259F,
                //     KE-                  1
    0x202, 0x25C4,
                //     KE-                  1
    0x202, 0x25C6,
                //     KE-                  1
    0x202, 0x25C7,
                //     KE-                 1 
    0x102, 0x25CA,
                //     KE-                  1
    0x202, 0x25CF,
                //     KOU-                 1
    0x202, 0x25DB,
                //     LAO-                1 
    0x102, 0x262E,
                //     LE-                  1
    0x202, 0x827A,              //0x826C,
                //     LEI-                 1
    0x202, 0x263F,
                //     LI-                  1
    0x202, 0x264E,
                //     LI-                  1
    0x202, 0x2663,
                //   LI-LUN-              1
    0x204, 0x264C, 0x26F6,
                //     LIANG-               1
    0x202, 0x267C,
                //     LIN-                 1
    0x202, 0x2693,
                //     LUN-                 1
    0x202, 0x26F6,
                //     LV-                  1
    0x202, 0x828E,              //0x8280,
                // ÿ    MEI-                1 
    0x102, 0x2738,
                //     MEN-                 1
    0x202, 0x2740,
                //     MI-                  1
    0x202, 0x274D,
                //     MIAN-               1 
    0x102, 0x2757,
                //     MIAN-                1
    0x202, 0x275F,
                // ĳ    MOU-                1 
    0x102, 0x278A,
                //     NAN-                1 
    0x102, 0x27A7,
                //     NAO-                1 
    0x102, 0x27AD,
                //     NEI-                11
    0x302, 0x27B1,
                //     NIAN-                1
    0x202, 0x27C1,
                // Ů    NV-                 1 
    0x102, 0x27E3,
                //     PAI-                 1
    0x202, 0x8320,               //0x8312,
                //     PANG-                1
    0x202, 0x2809,
                // Ƥ    PI-                  1
    0x202, 0x2837,
                // Ƭ    PIAN-                1
    0x202, 0x283F,
                // Ʒ    PIN-                 1
    0x202, 0x284A,
                // ,    QAUN-               1 
    0x102, 0x28FA,
                //     QI-                 1 
    0x102, 0x8354,               //0x8346,
                //     QI-                  1
    0x202, 0x288A,
                // ǰ    QIAN-                1
    0x202, 0x28A1,
                //     QU-                  1
    0x202, 0x8388,               //0x837A,
                // ,    QUAN-                1
    0x202, 0x28F7,
                // ,    QUN-                 1
    0x202, 0x2909,
                // ,    REN-                 1
    0x202, 0x291A,
                // ,    RI-                  1
    0x202, 0x2924,
                //     S,ANG-              11
    0x302, 0x297C,
                //     S,E-                 1
    0x202, 0x2994,
                //     S,ENG-               1
    0x202, 0x29A6,
                // ʡ    S,ENG-               1
    0x202, 0x83BE,              //0x83B0,
                //     S,I-                 1
    0x202, 0x83E2,              //0x83D4,
                //     S,I-                 1
    0x202, 0x29DD,
                //     S,OU-                1
    0x202, 0x29E1,
                //     S,OU-               1 
    0x102, 0x29E7,
                //     S,U-                 1
    0x202, 0x29F4,
                // ˫    S,UANG-             1 
    0x102, 0x2A14,
                // ˮ    S,UI-                1
    0x202, 0x2A17,
                // ˾    SI-                  1
    0x202, 0x2A27,
                // ˼  SI-XIANG-            1
    0x204, 0x8404, 0x2BCC,  //0x83F8, 0x2BCC,
                //     SUO-                 1
    0x202, 0x2A62,
                // ̨    TAI-                 1
    0x202, 0x2A6F,
                //     TI-                  1
    0x202, 0x2AAC,
                //     TIAO-                1
    0x202, 0x2ABC,
                //     TIE-                1 
    0x102, 0x2AC1,
                // ͷ    TOU-                 1
    0x202, 0x2ADC,
                //     WAI-                11
    0x302, 0x2B07,
                // Ϊ    WEI-                 1
    0x202, 0x2B2D,
                //     WU-                 1 
    0x102, 0x8450,               //0x8444,
                //     WU-                  1
    0x202, 0x2B72,
                // ϵ    XI-                  1
    0x202, 0x8458,               //0x844C,
                //     XIA-                11
    0x302, 0x2BA3,
                //     XIAN-                1
    0x202, 0x2BB9,
                //     XIANG-               1
    0x202, 0x2BC8,
                // Ŀ  XIANG-MU-            1
    0x204, 0x2BCF, 0x2796,
                // С    XIAO-               1 
    0x102, 0x2BE0,
                //     XIN-                1 
    0x102, 0x2C01,
                //     XIN-                 1
    0x202, 0x2C03,
                //     XING-                1
    0x202, 0x2C13,

                //     XING-                1
    0x202, 0x2C0C,
                //   XING-Z,I-            1
    0x204, 0x2C13, 0x2E3D,
                // ѧ    XUE-                 1
    0x202, 0x2C44,
                // ѧ˵  XUE-S,UO-            1
    0x204, 0x2C44, 0x83FE,   //0x83F2,
                //     YAN-                 1
    0x202, 0x2C78,
                //     YANG-               1 
    0x102, 0x2C90,
                // ҵ    YE-                  1
    0x202, 0x2CB0,
                //     YI-                  1
    0x202, 0x2CC2,
                //     YOU-                1 
    0x102, 0x2D29,
                //     YU-                  1
    0x202, 0x2D33,
                // ԭ    YUAN-               1 
    0x102, 0x2D64,
                // Ա    YUAN-                1
    0x202, 0x84C0,              //0x84B4,
                // Ժ    YUAN-                1
    0x202, 0x2D71,
                // ˶  YUN-DONG-            1
    0x204, 0x2D82, 0x2262,
                //     ZI-                  1
    0x202, 0x2EA4,

                //     ZAI-                1 
    0x102, 0x2D90,
                //     ZAI-                1 
    0x102, 0x2D91,
                // վ    Z,AN-                1
    0x202, 0x2DD3,
                //     Z,ANG-               1
    0x202, 0x808A,              //0x8082,
                //     Z,E-                 1
    0x202, 0x2DF4,
                //     Z,E-                 1
    0x202, 0x8532,               //0x8526,
                //     Z,EN-               1 
    0x102, 0x2DFB,
                //     Z,EN-                1
    0x202, 0x2E07,
                //     Z,ENG-              1 
    0x102, 0x2E12,
                //     Z,I-                 1
    0x202, 0x2E39,
                //     Z,ONG-              11
    0x302, 0x2E43,
                //     Z,U-                1 
    0x102, 0x2E6A,
                // ס    Z,U-                 1
    0x202, 0x2E72,
                //   Z,U-YI-              1
    0x204, 0x2E6A, 0x2CE0,
                // רҵ  Z,UAN-YE-            1
    0x204, 0x2E79, 0x2CB0,
                // ״    Z,UANG-              1
    0x202, 0x2E85,
                // ׼    Z,UN-               1 
    0x102, 0x2E8D,
                //     ZONG-               1 
    0x102, 0x2EAD,
                //     ZU-                  1
    0x202, 0x2EBA,
                //     ZUI-                1 
    0x102, 0x2EBF,
                //     ZUO-                1 
    0x102, 0x2EC8};

WORD sfx_table_size=sizeof sfx_table;

int FAR PASCAL sda_proc(WORD, LPWORD, BYTE, HIMC);
int FAR PASCAL tran_data(int, HIMC, BYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\candui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    candui.c

++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* GetCandWnd                                                         */
/* Return Value :                                                     */
/*      window handle of candidatte                                   */
/**********************************************************************/
HWND PASCAL GetCandWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCandWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCandWnd = lpUIPrivate->hCandWnd;

    GlobalUnlock(hUIPrivate);
    return (hCandWnd);
}

void PASCAL CalcCandPos(
    HIMC    hIMC,
    HWND    hUIWnd,
    LPPOINT lpptWnd)            // the composition window position
{
    POINT          ptNew, ptSTWPos;
    RECT           rcWorkArea;

#ifdef MUL_MONITOR
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif


    ptNew.x = lpptWnd->x + lpImeL->xCompWi + UI_MARGIN;
    if (ptNew.x + sImeG.xCandWi > rcWorkArea.right) {
        // exceed screen width
        ptNew.x = lpptWnd->x - sImeG.xCandWi - UI_MARGIN;
    }

    ptNew.y = lpptWnd->y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
    if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
        // exceed screen high
        ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
    }

    if(!sImeG.IC_Trace) {
        HWND hCompWnd;

           ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        hCompWnd = GetCompWnd(hUIWnd);
        if (hCompWnd) {
            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + lpImeL->xCompWi + 2 * UI_MARGIN;
            if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN)>
              rcWorkArea.right) {
              if (ptSTWPos.x >= (sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN)) { 
                ptNew.x = ptSTWPos.x - lpImeL->xCompWi - sImeG.xCandWi - 2 * UI_MARGIN;
              } else {
                ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
              }
            }


            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
            if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
                ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
            }
        } else {
            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
            if(((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + UI_MARGIN)>=
              rcWorkArea.right)
              && (ptSTWPos.x >= sImeG.xCandWi + UI_MARGIN)) { 
                ptNew.x = ptSTWPos.x - sImeG.xCandWi - UI_MARGIN;
            }

            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder - sImeG.cyCandBorder;
            if (ptNew.y + sImeG.yCandHi > rcWorkArea.bottom) {
                ptNew.y = rcWorkArea.bottom - sImeG.yCandHi;
            }
        }
    }
    
    lpptWnd->x = ptNew.x;
    lpptWnd->y = ptNew.y;

    return;
}

/**********************************************************************/
/* AdjustCandPos                                                      */
/**********************************************************************/
void AdjustCandPos(
    HIMC    hIMC,
    LPPOINT lpptWnd)            // the composition window position
{
    LPINPUTCONTEXT lpIMC;
    LONG           ptFontHi;
    UINT           uEsc;
    RECT           rcWorkArea;

#ifdef MUL_MONITOR
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFontHi = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfWidth == 0) {
        ptFontHi = lpImeL->yCompHi;
    } else {
        ptFontHi = -lpIMC->lfFont.A.lfHeight;
    }

    if (ptFontHi > lpImeL->yCompHi * 8) {
        ptFontHi = lpImeL->yCompHi * 8;
    }

    if (ptFontHi < sImeG.yChiCharHi) {
        ptFontHi = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    // find the location after IME do an adjustment
    ptFontHi = ptFontHi * ptInputEsc[uEsc].y;

    if(lpptWnd->y + ptFontHi + sImeG.yCandHi <= rcWorkArea.bottom) {
        lpptWnd->y += ptFontHi;
    } else {
        lpptWnd->y -= (ptFontHi + sImeG.yCandHi);
    }

    ImmUnlockIMC(hIMC);
    return;
}

/**********************************************************************/
/* AdjustCandRectBoundry                                              */
/**********************************************************************/
void PASCAL AdjustCandRectBoundry(
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptCandWnd)            // the caret position
{
    RECT  rcExclude, rcUIRect, rcInterSect;
    UINT  uEsc;
    RECT  rcWorkArea;

#ifdef MUL_MONITOR

    {
        RECT rcCandWnd;

        *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;

        rcCandWnd.right = rcCandWnd.left + sImeG.xCandWi;
        rcCandWnd.bottom = rcCandWnd.top + sImeG.yCandHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcCandWnd);
    }

#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    // be a normal rectangle, not a negative rectangle
    if (lpIMC->cfCandForm[0].rcArea.left > lpIMC->cfCandForm[0].rcArea.right) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.left;
        lpIMC->cfCandForm[0].rcArea.left = lpIMC->cfCandForm[0].rcArea.right;
        lpIMC->cfCandForm[0].rcArea.right = tmp;
    }

    if (lpIMC->cfCandForm[0].rcArea.top > lpIMC->cfCandForm[0].rcArea.bottom) {
        LONG tmp;

        tmp = lpIMC->cfCandForm[0].rcArea.top;
        lpIMC->cfCandForm[0].rcArea.top = lpIMC->cfCandForm[0].rcArea.bottom;
        lpIMC->cfCandForm[0].rcArea.bottom = tmp;
    }

    // translate from client coordinate to screen coordinate
    rcExclude = lpIMC->cfCandForm[0].rcArea;

    rcExclude.left += lpptCandWnd->x - lpIMC->cfCandForm[0].ptCurrentPos.x;
    rcExclude.right += lpptCandWnd->x - lpIMC->cfCandForm[0].ptCurrentPos.x;

    rcExclude.top += lpptCandWnd->y - lpIMC->cfCandForm[0].ptCurrentPos.y;
    rcExclude.bottom += lpptCandWnd->y - lpIMC->cfCandForm[0].ptCurrentPos.y;

    // if original point is OK, we use it
    *(LPPOINT)&rcUIRect = *lpptCandWnd;

    if (rcUIRect.left < rcWorkArea.left) {
        rcUIRect.left = rcWorkArea.left;
    } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
    } else {
    }

    if (rcUIRect.top < rcWorkArea.top) {
        rcUIRect.top = rcWorkArea.top;
    } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
    } else {
    }

    rcUIRect.right = rcUIRect.left + sImeG.xCandWi;
    rcUIRect.bottom = rcUIRect.top + sImeG.yCandHi;

    if (!IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
        *lpptCandWnd = *(LPPOINT)&rcUIRect;
        return;
    }

    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);

    if (uEsc & 0x0001) {
        // 900 & 2700 we need change x coordinate
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }
    } else {
        // 0 & 1800 we do not change x coordinate
        rcUIRect.left = lpptCandWnd->x;
    }

    if (rcUIRect.left < rcWorkArea.left) {
        rcUIRect.left = rcWorkArea.left;
    } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
    } else {
    }

    if (uEsc & 0x0001) {
        // 900 & 2700 we do not change y coordinate
        rcUIRect.top = lpptCandWnd->y;
    } else {
        // 0 & 1800 we need change y coordinate
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }
    }

    if (rcUIRect.top < rcWorkArea.top) {
        rcUIRect.top = rcWorkArea.top;
    } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
    } else {
    }

    rcUIRect.right = rcUIRect.left + sImeG.xCandWi;
    rcUIRect.bottom = rcUIRect.top + sImeG.yCandHi;

    // the candidate window not overlapped with exclude rectangle
    // so we found a position
    if (!IntersectRect(&rcInterSect, &rcExclude, &rcUIRect)) {
        *lpptCandWnd = *(LPPOINT)&rcUIRect;
        return;
    }

    // adjust according to
    *(LPPOINT)&rcUIRect = *lpptCandWnd;

    if (uEsc & 0x0001) {
        // 900 & 2700 we prefer adjust x
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        } else {
            if (rcUIRect.top < rcWorkArea.top) {
                rcUIRect.top = rcWorkArea.top;
            } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
                rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        } else {
            rcUIRect.left = rcExclude.right;
        }

        if (rcUIRect.left < rcWorkArea.left) {
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
        } else {
            if (rcUIRect.top < rcWorkArea.top) {
                rcUIRect.top = rcWorkArea.top;
            } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
                rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try failure again, we use positive plus display adjust
        if (ptInputEsc[uEsc].x > 0) {
            rcUIRect.left = rcExclude.right;
        } else {
            rcUIRect.left = rcExclude.left - sImeG.xCandWi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
            rcUIRect.left = rcWorkArea.left;
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
            rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
        }

        if (rcUIRect.top < rcWorkArea.top) {
            rcUIRect.top = rcWorkArea.top;
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
            rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
        }

        *lpptCandWnd = *(LPPOINT)&rcUIRect;
    } else {
        // 0 & 1800 we prefer adjust y
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }

        if (rcUIRect.top < rcWorkArea.top) {
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
        } else {
            if (rcUIRect.left < rcWorkArea.left) {
                rcUIRect.left = rcWorkArea.left;
            } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
                rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        } else {
            rcUIRect.top = rcExclude.bottom;
        }

        if (rcUIRect.top < rcWorkArea.top) {
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.right) {
        } else {
            if (rcUIRect.left < rcWorkArea.left) {
                rcUIRect.left = rcWorkArea.left;
            } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
                rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
            }

            *lpptCandWnd = *(LPPOINT)&rcUIRect;
            return;
        }

        // negative try failure again, we use positive plus display adjust
        if (ptInputEsc[uEsc].y > 0) {
            rcUIRect.top = rcExclude.bottom;
        } else {
            rcUIRect.top = rcExclude.top - sImeG.yCandHi;
        }

        if (rcUIRect.left < rcWorkArea.left) {
            rcUIRect.left = rcWorkArea.left;
        } else if (rcUIRect.left + sImeG.xCandWi > rcWorkArea.right) {
            rcUIRect.left = rcWorkArea.right - sImeG.xCandWi;
        }

        if (rcUIRect.top < rcWorkArea.top) {
            rcUIRect.top = rcWorkArea.top;
        } else if (rcUIRect.top + sImeG.yCandHi > rcWorkArea.bottom) {
            rcUIRect.top = rcWorkArea.bottom - sImeG.yCandHi;
        }

        *lpptCandWnd = *(LPPOINT)&rcUIRect;
    }

    return;
}

/**********************************************************************/
/* AdjustCandBoundry                                                  */
/**********************************************************************/
void PASCAL AdjustCandBoundry(
    LPPOINT lpptCandWnd)            // the position
{

    RECT  rcWorkArea;

#ifdef MUL_MONITOR
    {
        RECT rcCandWnd;

        *(LPPOINT)&rcCandWnd = *(LPPOINT)lpptCandWnd;

        rcCandWnd.right = rcCandWnd.left + sImeG.xCandWi;
        rcCandWnd.bottom = rcCandWnd.top + sImeG.yCandHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcCandWnd);
    }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif
    if (lpptCandWnd->x < rcWorkArea.left) {
        lpptCandWnd->x = rcWorkArea.left;
    } else if (lpptCandWnd->x + sImeG.xCandWi > rcWorkArea.right) {
        lpptCandWnd->x = rcWorkArea.right - sImeG.xCandWi;
    }

    if (lpptCandWnd->y < rcWorkArea.top) {
        lpptCandWnd->y = rcWorkArea.top;
    } else if (lpptCandWnd->y + sImeG.yCandHi > rcWorkArea.bottom) {
        lpptCandWnd->y = rcWorkArea.bottom - sImeG.yCandHi;
    }

    return;
}

/**********************************************************************/
/* SetCandPosition()                                                  */
/**********************************************************************/
LRESULT PASCAL SetCandPosition(
    HWND hCandWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptNew;

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (1L);
    }

    ptNew = lpIMC->cfCandForm[0].ptCurrentPos;

    ClientToScreen((HWND)lpIMC->hWnd, &ptNew);

    if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
        AdjustCandBoundry(&ptNew);
    } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
           if(!sImeG.IC_Trace) {
               CalcCandPos(hIMC, hUIWnd, &ptNew);
        }
        AdjustCandBoundry(&ptNew);
    }

    SetWindowPos(hCandWnd, NULL, ptNew.x, ptNew.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowCand()                                                         */
/**********************************************************************/
void PASCAL ShowCand(           // Show the candidate window
    HWND    hUIWnd,
    int     nShowCandCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    if (lpUIPrivate->nShowCandCmd == nShowCandCmd) {
        goto SwCandNoChange;
    }

    if (nShowCandCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
    }

    if (!lpUIPrivate->hCandWnd) {
        // not in show candidate window mode
    } else if (lpUIPrivate->nShowCandCmd == nShowCandCmd) {
    } else {
        if(nShowCandCmd == SW_HIDE) {
            uOpenCand = 0;
        } else {
            HIMC           hIMC;
            POINT          ptSTWPos;
            int            Comp_CandWndLen;
            RECT           rcWorkArea;

            uOpenCand = 1;

            // reset status window for LINE_UI(FIX_UI)
            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {
                goto ShowCand;
            }

               ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
#ifdef MUL_MONITOR
            rcWorkArea = ImeMonitorWorkAreaFromPoint(ptSTWPos);
#else
            rcWorkArea = sImeG.rcWorkArea;
#endif
            Comp_CandWndLen = 0;
            if(uOpenCand) {
                Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
                if(uStartComp) {
                    Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
                }
                if(ptSTWPos.x + sImeG.xStatusWi + Comp_CandWndLen > rcWorkArea.right) {
                    PostMessage(GetCompWnd(hUIWnd), 
                                WM_IME_NOTIFY, 
                                IMN_SETCOMPOSITIONWINDOW, 
                                0);
                }
            }
        }
        
ShowCand:
        ShowWindow(lpUIPrivate->hCandWnd, nShowCandCmd);
        lpUIPrivate->nShowCandCmd = nShowCandCmd;
    }

SwCandNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenCand                                                           */
/**********************************************************************/
void PASCAL OpenCand(
    HWND hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICANDIDATEWINDOW;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        goto OpenCandUnlockUIPriv;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        goto OpenCandUnlockUIPriv;
    }

    if (lpIMC->cfCandForm[0].dwIndex == 0) {
        
        ptWnd = lpIMC->cfCandForm[0].ptCurrentPos;

        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (lpIMC->cfCandForm[0].dwStyle & CFS_FORCE_POSITION) {
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_EXCLUDE) {
               POINT ptCaret;

            AdjustCandBoundry(&ptWnd);
            if((!sImeG.IC_Trace) || (!GetCaretPos(&ptCaret))) {

                if(GetCompWnd(hUIWnd)) {
                    ptWnd.x = ptWnd.y = 0;
                    ClientToScreen(lpIMC->hWnd, &ptWnd);
                    ptWnd.x -= lpImeL->cxCompBorder + 1;
                    ptWnd.y -= lpImeL->cyCompBorder + 1;
                } else {
                    ptWnd.x = lpImeL->cxCompBorder + 1;
                    ptWnd.y = lpImeL->cyCompBorder + 1;
                }

                   CalcCandPos(hIMC, hUIWnd, &ptWnd);

                lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
                lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
                ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
            } else {
                AdjustCandPos(hIMC, &ptWnd);
            }
        } else if (lpIMC->cfCandForm[0].dwStyle == CFS_CANDIDATEPOS) {
            AdjustCandBoundry(&ptWnd);
        } else {
            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                ptWnd.x = ptWnd.y = 0;
                ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);
            } else {
                ptWnd = lpIMC->cfCompForm.ptCurrentPos;
                ClientToScreen(lpIMC->hWnd, &ptWnd);
            }

            ptWnd.x -= lpImeL->cxCompBorder + 1;
            ptWnd.y -= lpImeL->cyCompBorder + 1;

               CalcCandPos(hIMC, hUIWnd, &ptWnd);

            lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
            lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
        }
    } else {
        // make cand windows trace comp window !
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ptWnd.x = ptWnd.y = 0;
            ClientToScreen(lpUIPrivate->hCompWnd, &ptWnd);
        } else {
            ptWnd = lpIMC->cfCompForm.ptCurrentPos;
            ClientToScreen(lpIMC->hWnd, &ptWnd);
        }

        ptWnd.x -= lpImeL->cxCompBorder + 1;
        ptWnd.y -= lpImeL->cyCompBorder + 1;

           CalcCandPos(hIMC, hUIWnd, &ptWnd);

        lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
        lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;
        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCandForm[0].ptCurrentPos);
    }

    ImmUnlockIMC(hIMC);

    if (lpUIPrivate->hCandWnd) {
        SetWindowPos(lpUIPrivate->hCandWnd, 
                     NULL,
                     ptWnd.x, 
                     ptWnd.y,
                     0, 
                     0, 
                     SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {
        lpUIPrivate->hCandWnd = CreateWindowEx(
                                     WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                     szCandClassName, 
                                     NULL, 
                                     WS_POPUP|WS_DISABLED,
                                     ptWnd.x,
                                     ptWnd.y,
                                     sImeG.xCandWi, 
                                     sImeG.yCandHi,
                                     hUIWnd, 
                                     (HMENU)NULL, 
                                     hInst, 
                                     NULL);

        SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        SetWindowLong(lpUIPrivate->hCandWnd, UI_MOVE_XY, 0L);
    }

    ShowCand(hUIWnd, SW_SHOWNOACTIVATE);

OpenCandUnlockUIPriv:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CloseCand                                                          */
/**********************************************************************/
void PASCAL CloseCand(
    HWND hUIWnd)
{
    uOpenCand = 0;
    ShowCand(hUIWnd, SW_HIDE);
    return;
}

/**********************************************************************/
/* DestroyCandWindow                                                  */
/**********************************************************************/
void PASCAL DestroyCandWindow(
    HWND hCandWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCandWnd,
            GetWindowLong(hCandWnd, UI_MOVE_XY),
            GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return;
    }

    lpUIPrivate->nShowCandCmd = SW_HIDE;

    lpUIPrivate->hCandWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* MouseSelectCandStr()                                               */
/**********************************************************************/
void PASCAL MouseSelectCandStr(
    HWND    hCandWnd,
    LPPOINT lpCursor)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwValue;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmUnlockIMC(hIMC);
        return;
    }

    dwValue = (lpCursor->y - sImeG.rcCandText.top) / sImeG.yChiCharHi;

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwValue = dwValue + lpCandList->dwSelection /
        lpCandList->dwPageSize * lpCandList->dwPageSize;

    if (dwValue >= lpCandList->dwCount) {
        // invalid choice
        MessageBeep((UINT)-1);
    } else {
        NotifyIME(hIMC, NI_SELECTCANDIDATESTR, 0, dwValue);
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandPageDownUP()                                                   */
/**********************************************************************/
void PASCAL CandPageDownUP(
    HWND hCandWnd,
    UINT uCandDownUp)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPPRIVCONTEXT   lpImcP;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    HDC             hDC;
    HBITMAP         hCandHpBmp, hCandUpBmp, hCandDpBmp, hCandEpBmp;
    HBITMAP         hOldBmp;
    HDC             hMemDC;

    // change candlist
    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    // get lpImcP
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    // get lpCandInfo
    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return;
    }
                                                 
    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    
    switch(uCandDownUp) {
    case uCandHome:
        ChooseCand(0x24, lpIMC, lpCandInfo, lpImcP);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandUp:
        ChooseCand('-', lpIMC, lpCandInfo, lpImcP);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandDown:
        ChooseCand('=', lpIMC, lpCandInfo, lpImcP);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    case uCandEnd:
        ChooseCand(0x23, lpIMC, lpCandInfo, lpImcP);
        NotifyIME(hIMC, NI_CHANGECANDIDATELIST, 0, 0);
        break;
    default:
        break;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCandInfo);
    ImmUnlockIMC(hIMC);

    // draw button down
    hDC = GetDC(hCandWnd);
    if ( hDC == NULL )
       return;

    hMemDC = CreateCompatibleDC(hDC);
    
    if ( hMemDC == NULL )
    {
       ReleaseDC(hCandWnd, hDC); 
       return;
    }

    hOldBmp = NULL;

    switch(uCandDownUp) {
    case uCandHome:

        hCandHpBmp = LoadBitmap(hInst, TEXT("CandHp"));
        if ( hCandHpBmp != NULL)
        {
            hOldBmp = SelectObject(hMemDC, hCandHpBmp);
            BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
                   sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
                   STATUS_DIM_Y,
                   hMemDC, 0, 0, SRCCOPY);
            DeleteObject(hCandHpBmp);
        }
            
        break;
    case uCandUp:

        hCandUpBmp = LoadBitmap(hInst, TEXT("CandUp"));
        if ( hCandUpBmp != NULL )
        {
            hOldBmp = SelectObject(hMemDC, hCandUpBmp);
            BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
                sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);
            DeleteObject(hCandUpBmp);
        }
        break;
    case uCandDown:
        hCandDpBmp = LoadBitmap(hInst, TEXT("CandDp"));
        if ( hCandDpBmp != NULL)
        {
            hOldBmp = SelectObject(hMemDC, hCandDpBmp);
            BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
                sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);
            DeleteObject(hCandDpBmp);
        }
        break;
    case uCandEnd:
        hCandEpBmp = LoadBitmap(hInst, TEXT("CandEp"));
        if ( hCandEpBmp != NULL)
        {
            hOldBmp = SelectObject(hMemDC, hCandEpBmp);
            BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
                sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);
            DeleteObject(hCandEpBmp);
        }
        break;
    default:
        break;
    }
       
    if ( hOldBmp != NULL) 
        SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);
    ReleaseDC(hCandWnd, hDC);

    return;
}

/**********************************************************************/
/* CandSetCursor()                                                    */
/**********************************************************************/
void PASCAL CandSetCursor(
    HWND   hCandWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)
           && sImeG.IC_Trace) {
            SetCursor(LoadCursor(hInst, szHandCursor));
            MouseSelectCandStr(hCandWnd, &ptCursor);
            return;
        } else if (PtInRect(&sImeG.rcCandBTH, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandHome);
            return;
        } else if (PtInRect(&sImeG.rcCandBTU, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandUp);
            return;
        } else if (PtInRect(&sImeG.rcCandBTD, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandDown);
            return;
        } else if (PtInRect(&sImeG.rcCandBTE, ptCursor)) {
            CandPageDownUP(hCandWnd, uCandEnd);
            return;
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }
    } else if (HIWORD(lParam) == WM_LBUTTONUP) {
        HDC             hDC;
        HBITMAP         hCandHBmp, hCandUBmp, hCandDBmp, hCandEBmp;
        HBITMAP         hOldBmp;
        HDC             hMemDC;

        hDC = GetDC(hCandWnd);

        hMemDC = CreateCompatibleDC(hDC);

        if ( hMemDC )
        {

            hCandHBmp = LoadBitmap(hInst, TEXT("CandH"));

            if ( hCandHBmp )
            {
                hOldBmp = SelectObject(hMemDC, hCandHBmp);
                BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
                    sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
                    STATUS_DIM_Y,
                    hMemDC, 0, 0, SRCCOPY);
                SelectObject(hMemDC, hOldBmp);

                DeleteObject(hCandHBmp);
            }


            hCandUBmp = LoadBitmap(hInst, TEXT("CandU"));

            if ( hCandUBmp )
            {

                hOldBmp=SelectObject(hMemDC, hCandUBmp);
                BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
                    sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
                    STATUS_DIM_Y,
                    hMemDC, 0, 0, SRCCOPY);
                SelectObject(hMemDC, hOldBmp);

                DeleteObject(hCandUBmp);
            }

            hCandDBmp = LoadBitmap(hInst, TEXT("CandD"));
            
            if ( hCandDBmp )
            {
                hOldBmp=SelectObject(hMemDC, hCandDBmp);
                BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
                    sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
                    STATUS_DIM_Y,
                    hMemDC, 0, 0, SRCCOPY);
                SelectObject(hMemDC, hOldBmp);
                DeleteObject(hCandDBmp);
            }


            hCandEBmp = LoadBitmap(hInst, TEXT("CandE"));

            if ( hCandEBmp )
            {

                hOldBmp=SelectObject(hMemDC, hCandEBmp);
                BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
                    sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
                    STATUS_DIM_Y,
                    hMemDC, 0, 0, SRCCOPY);

                SelectObject(hMemDC, hOldBmp);
                DeleteObject(hCandEBmp);
            }

            DeleteDC(hMemDC);
        }


        ReleaseDC(hCandWnd, hDC);

        return;
    } else {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

        GetCursorPos(&ptCursor);
        ScreenToClient(hCandWnd, &ptCursor);

        if (PtInRect(&sImeG.rcCandText, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
            return;
        } else if (PtInRect(&sImeG.rcCandBTH, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTU, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTD, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else if (PtInRect(&sImeG.rcCandBTE, ptCursor)) {
            SetCursor(LoadCursor(hInst, szHandCursor));
        } else {
            SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        }

        return;
    }

    SetCapture(hCandWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCandWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCandWnd, &rcWnd);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCandWnd, UI_MOVE_OFFSET));

    return;
}

/**********************************************************************/
/* CandButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CandButtonUp(
    HWND hCandWnd)
{
    LONG           lTmpCursor, lTmpOffset;
    POINT          pt;
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCandWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCandWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCandWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCandWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
    ReleaseCapture();

    hUIWnd = GetWindow(hCandWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    AdjustCandBoundry(&pt);

    ScreenToClient(lpIMC->hWnd, &pt);

    lpIMC->cfCandForm[0].dwStyle |= CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = pt;

    ImmUnlockIMC(hIMC);

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return (TRUE);
}

/**********************************************************************/
/* UpdateCandWindow()                                                 */
/**********************************************************************/
void PASCAL PaintCandWindow(
    HWND hCandWnd,
    HDC  hDC)
{
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    LPPRIVCONTEXT   lpImcP;
    HGDIOBJ         hOldFont;
    DWORD           dwStart, dwEnd;
    TCHAR           szStrBuf[2 * MAXSTRLEN * sizeof(WCHAR) / sizeof(TCHAR) + 1];
    int             i;
    HBITMAP         hCandIconBmp, hCandInfBmp;
    HBITMAP         hOldBmp, hCandHBmp, hCandUBmp, hCandDBmp, hCandEBmp;
    HDC             hMemDC;

    hIMC = (HIMC)GetWindowLongPtr(GetWindow(hCandWnd, GW_OWNER), IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!lpIMC->hCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        goto UpCandW2UnlockIMC;
    }

    if (!lpIMC->hPrivate) {
        goto UpCandW2UnlockCandInfo;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        goto UpCandW2UnlockCandInfo;
    }

    // set font
    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;
        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }

    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);

    dwStart = lpCandList->dwSelection;
    dwEnd = dwStart + lpCandList->dwPageSize;

    if (dwEnd > lpCandList->dwCount) {
        dwEnd = lpCandList->dwCount;
    }

    // draw CandWnd Layout
    if (sImeG.IC_Trace) {
        RECT rcWnd;

        GetClientRect(hCandWnd, &rcWnd);
        DrawConcaveRect(hDC,
            rcWnd.left,
            rcWnd.top + UI_CANDINF,
            rcWnd.right - 1,
            rcWnd.bottom - 1);
    } else {
        RECT rcWnd;

        GetClientRect(hCandWnd, &rcWnd);
        DrawConcaveRect(hDC,
            sImeG.rcCandText.left - 1,
            rcWnd.top,
            sImeG.rcCandText.right + 1,
            rcWnd.bottom - 1);
    }

    SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    if (sImeG.IC_Trace) {
        ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top,
            ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
        szStrBuf[0] = TEXT('1');
        szStrBuf[1] = TEXT(':');

        for (i = 0; dwStart < dwEnd; dwStart++, i++) {
            int  iLen;

            iLen = 0;

            szStrBuf[0] = szDigit[i + CAND_START];

#if defined(COMBO_IME)
            if(sImeL.dwRegImeIndex == INDEX_GB || sImeL.dwRegImeIndex == INDEX_GBK){
                iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                    lpCandList->dwOffset[dwStart]));

                if (iLen > 10 * 2 / sizeof(TCHAR)) {
                    iLen = 10 * 2 / sizeof(TCHAR);
                    CopyMemory(&szStrBuf[2],
                        ((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart])),
                        (iLen - 2) * sizeof(TCHAR));
                    // maybe not good for UNICODE
                    szStrBuf[iLen] = TEXT('.');
                    szStrBuf[iLen+1] = TEXT('.');
                    szStrBuf[iLen+2] = TEXT('\0');
                } else {
                    CopyMemory(&szStrBuf[2],
                        (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                        iLen*sizeof(TCHAR));
                }
            }else if(sImeL.dwRegImeIndex == INDEX_UNICODE){
                WORD  wCode;
                wCode = *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]);

#ifdef UNICODE
                szStrBuf[2]= wCode;
                szStrBuf[3]=TEXT('\0');
#else
                szStrBuf[2]= LOBYTE(wCode);
                szStrBuf[3]= HIBYTE(wCode);
                szStrBuf[4]=TEXT('\0');
#endif
                iLen = 2/sizeof(TCHAR);
            }

#else
            iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                lpCandList->dwOffset[dwStart]));

            if (iLen > 10 * 2 / sizeof(TCHAR)) {
                iLen = 10 * 2 / sizeof(TCHAR);
                CopyMemory(&szStrBuf[2],
                    ((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                    (iLen - 2) * sizeof(TCHAR));
                szStrBuf[iLen] = TEXT('.');
                szStrBuf[iLen+1] = TEXT('.');
                szStrBuf[iLen+2] = TEXT('\0');
            } else {
                CopyMemory(&szStrBuf[2],
                    ((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                    iLen*sizeof(TCHAR));
            }
#endif //COMBO_IME

            ExtTextOut(hDC, sImeG.rcCandText.left,
                sImeG.rcCandText.top + i * sImeG.yChiCharHi,
                (UINT)0, NULL,
                szStrBuf,
                iLen + 2, NULL);
    
           // QW/GB info
           {

             int   iMyLen;
             WORD  wCode, wGB;
             TCHAR  AbSeq[5];
             TCHAR  GbSeq[5];
             TCHAR szMyStrBuf[12 * sizeof(WCHAR) / sizeof(TCHAR)];
             RECT  GBARInfo;

#ifdef UNICODE


             wCode = *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]);
             AbSeq[0] = wCode;
             AbSeq[1] = TEXT('\0');
             //  change the CP_ACP to 936, so that it can work under Multilingul Env.
             WideCharToMultiByte(NATIVE_ANSI_CP, WC_COMPOSITECHECK, AbSeq, 1, (BYTE*)GbSeq, sizeof(GbSeq), NULL, NULL);
                          
             wGB = HIBYTE(GbSeq[0]) | (LOBYTE(GbSeq[0]) << 8);

             wsprintf (GbSeq,TEXT("%04lx"),wGB);    // get GB string
             wGB -= 0xa0a0;
             wsprintf (AbSeq,TEXT("%02d%02d"),HIBYTE(wGB),LOBYTE(wGB));
#else
             wCode = *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]);
             MultiByteToWideChar(CP_ACP, NULL, &wCode, 2, &wGB, 1);    
                          
             wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

             wsprintf (GbSeq,"%04lx",wCode);    // get GB string
            
             wCode -= 0xa0a0;

             wsprintf (AbSeq,"%02d%02d",HIBYTE(wCode),LOBYTE(wCode));
#endif
//             if (lpImcP->fdwGB & IME_SELECT_GB) {
#if defined(COMBO_IME)
        switch(sImeL.dwRegImeIndex){
        case INDEX_GB:
                lstrcpy (szMyStrBuf,TEXT("("));
                lstrcat (szMyStrBuf,GbSeq);
                lstrcat (szMyStrBuf,TEXT(", "));
                lstrcat (szMyStrBuf,AbSeq);
                lstrcat (szMyStrBuf,TEXT(")"));
                iMyLen = 12;

            break;
        case INDEX_GBK:
                lstrcpy (szMyStrBuf,TEXT("    "));
                lstrcat (szMyStrBuf,TEXT("("));
                lstrcat (szMyStrBuf,GbSeq);
                lstrcat (szMyStrBuf,TEXT(")"));
                iMyLen = 10;

            break;
        case INDEX_UNICODE:        //adjust code display info
                lstrcpy (szMyStrBuf,TEXT("("));
                lstrcat (szMyStrBuf,GbSeq);
                lstrcat (szMyStrBuf,TEXT(", "));
                wsprintf (AbSeq,TEXT("%04lx"),wCode);
                lstrcat (szMyStrBuf, AbSeq);
                lstrcat (szMyStrBuf,TEXT(")"));
                iMyLen = lstrlen(szMyStrBuf);
            break;
        }
#else //COMBO_IME
#ifdef GB
                lstrcpy (szMyStrBuf,TEXT("("));
                lstrcat (szMyStrBuf,GbSeq);
                lstrcat (szMyStrBuf,TEXT(", "));
                lstrcat (szMyStrBuf,AbSeq);
                lstrcat (szMyStrBuf,TEXT(")"));
                iMyLen = 12;

#else
                lstrcpy (szMyStrBuf,TEXT("    "));
                lstrcat (szMyStrBuf,TEXT("("));
                lstrcat (szMyStrBuf,GbSeq);
                lstrcat (szMyStrBuf,TEXT(")"));
                iMyLen = 10;

#endif //GB        
#endif //COMBO_IME
        
             GBARInfo.top = sImeG.rcCandText.top + i * sImeG.yChiCharHi;
             GBARInfo.left = sImeG.rcCandText.left;
             GBARInfo.right = sImeG.rcCandText.right;
             GBARInfo.bottom = sImeG.rcCandText.bottom;
             DrawText(hDC, szMyStrBuf, lstrlen(szMyStrBuf),
                     &GBARInfo, DT_RIGHT | DT_SINGLELINE);
           }
        }

    } else {
        int  nX;

        ExtTextOut(hDC, sImeG.rcCandText.left, sImeG.rcCandText.top + 1,
            ETO_OPAQUE, &sImeG.rcCandText, NULL, 0, NULL);
        nX = 0;
        for (i = 0; dwStart < dwEnd; dwStart++, i++) {
            int  iLen;
            int j, k;
            TCHAR AnsiStr[MAXCODE+1];
            SIZE StrSize;

            // display numbers
            AnsiStr[0] = szDigit[i + CAND_START];
            AnsiStr[1] = TEXT(':');
            AnsiStr[2] = 0;
            ExtTextOut(hDC, sImeG.rcCandText.left + nX,
                    sImeG.rcCandText.top + 1,
                    ETO_CLIPPED, &sImeG.rcCandText,
                    AnsiStr,
                    lstrlen(AnsiStr), NULL);
            if(!GetTextExtentPoint(hDC, (LPCTSTR)AnsiStr, lstrlen(AnsiStr), &StrSize))
                memset(&StrSize, 0, sizeof(SIZE));
            nX += StrSize.cx;

            // display chinese word and code
            iLen = lstrlen((LPTSTR)((LPBYTE)lpCandList +
                lpCandList->dwOffset[dwStart]));

            CopyMemory(szStrBuf,
                ((LPBYTE)lpCandList + lpCandList->dwOffset[dwStart]),
                iLen*sizeof(TCHAR));

            for(j=0; j<iLen; j++) {
#ifdef UNICODE
                if(szStrBuf[j] > 0x100) {
#else
                if(szStrBuf[j] & 0x80) {
#endif
                    j++;
                    continue;
                }
                break;
            }
            
            k = j-1;
            for(j=0; j<iLen - k; j++) {
                AnsiStr[j] = szStrBuf[j+k];
            }
            AnsiStr[j] = 0;
            szStrBuf[k] = 0;


            ExtTextOut(hDC, sImeG.rcCandText.left + nX,
                    sImeG.rcCandText.top + 1,
                    ETO_CLIPPED, &sImeG.rcCandText,
                    szStrBuf,
                    lstrlen(szStrBuf), NULL);

            if(!GetTextExtentPoint(hDC, (LPCTSTR)szStrBuf, lstrlen(szStrBuf), &StrSize))
                memset(&StrSize, 0, sizeof(SIZE));
            nX += StrSize.cx;

            ExtTextOut(hDC, sImeG.rcCandText.left + nX,
                    sImeG.rcCandText.top + 1,
                    ETO_CLIPPED, &sImeG.rcCandText,
                    AnsiStr,
                    lstrlen(AnsiStr), NULL);

            if(!GetTextExtentPoint(hDC, (LPCTSTR)AnsiStr, lstrlen(AnsiStr), &StrSize))
                memset(&StrSize, 0, sizeof(SIZE));
            nX += StrSize.cx;

        }
    }
    
    // load all bitmap
    if (sImeG.IC_Trace) {
        hCandInfBmp = LoadBitmap(hInst, TEXT("Candinf"));
    } else {
        hCandInfBmp = NULL;
    }


    hMemDC = CreateCompatibleDC(hDC);

    if ( hMemDC != NULL )
    {

        hCandIconBmp = LoadBitmap(hInst, TEXT("CandSel"));

        if ( hCandIconBmp )
        {

            hOldBmp = SelectObject(hMemDC, hCandIconBmp);

            BitBlt(hDC, sImeG.rcCandIcon.left, sImeG.rcCandIcon.top,
                sImeG.rcCandIcon.right - sImeG.rcCandIcon.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);

            DeleteObject(hCandIconBmp);
        }

        if(hCandInfBmp) {
            
            hOldBmp = SelectObject(hMemDC, hCandInfBmp);

            BitBlt(hDC, sImeG.rcCandInf.left, sImeG.rcCandInf.top,
                sImeG.rcCandInf.right - sImeG.rcCandInf.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);
        }

        hCandHBmp = LoadBitmap(hInst, TEXT("CandH"));

        if ( hCandHBmp )
        {
            hOldBmp = SelectObject(hMemDC, hCandHBmp);

            BitBlt(hDC, sImeG.rcCandBTH.left, sImeG.rcCandBTH.top,
                sImeG.rcCandBTH.right - sImeG.rcCandBTH.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);

            DeleteObject(hCandHBmp);
        }


        hCandUBmp = LoadBitmap(hInst, TEXT("CandU"));

        if ( hCandUBmp )
        {
            hOldBmp = SelectObject(hMemDC, hCandUBmp);

            BitBlt(hDC, sImeG.rcCandBTU.left, sImeG.rcCandBTU.top,
                sImeG.rcCandBTU.right - sImeG.rcCandBTU.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);

            DeleteObject(hCandUBmp);
        }


        hCandDBmp = LoadBitmap(hInst, TEXT("CandD"));
        
        if ( hCandDBmp )
        {

            hOldBmp = SelectObject(hMemDC, hCandDBmp);

            BitBlt(hDC, sImeG.rcCandBTD.left, sImeG.rcCandBTD.top,
                sImeG.rcCandBTD.right - sImeG.rcCandBTD.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);

            DeleteObject(hCandDBmp);
        }

        hCandEBmp = LoadBitmap(hInst, TEXT("CandE"));
        
        if ( hCandEBmp )
        {
            hOldBmp = SelectObject(hMemDC, hCandEBmp);

            BitBlt(hDC, sImeG.rcCandBTE.left, sImeG.rcCandBTE.top,
                sImeG.rcCandBTE.right - sImeG.rcCandBTE.left,
                STATUS_DIM_Y,
                hMemDC, 0, 0, SRCCOPY);

            SelectObject(hMemDC, hOldBmp);
            
            DeleteObject(hCandEBmp);
        }
        
        DeleteDC(hMemDC);

    }

    if ( hCandInfBmp )
        DeleteObject(hCandInfBmp);

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
UpCandW2UnlockCandInfo:
    ImmUnlockIMCC(lpIMC->hCandInfo);
UpCandW2UnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* CandWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CandWndProc(
    HWND   hCandWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCandWindow(hCandWnd);
        break;
    case WM_SETCURSOR:
        CandSetCursor(hCandWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCandWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCandWnd,
                GetWindowLong(hCandWnd, UI_MOVE_XY),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCandWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCandWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCandWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CandButtonUp(hCandWnd)) {
            return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam == IMN_SETCANDIDATEPOS) {
            return SetCandPosition(hCandWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCandWnd, &ps);
            PaintCandWindow(hCandWnd, hDC);
            EndPaint(hCandWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCandWnd, uMsg, wParam, lParam);
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\chcand.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    chcand.c

++*/

#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

#if defined(CROSSREF)
//*******************************************************************
// The parameters are inherited from SelectOneCand
//    CrossReverseConv()
//*******************************************************************
void CrossReverseConv(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    LPGUIDELINE lpGuideLine;

    if (!sImeG.hRevKL) {
        return;
    }


    lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
        return;
    }

    if (lpCompStr->dwResultStrLen != sizeof(WORD)/sizeof(TCHAR)) {
        // we only can reverse convert one DBCS character for now
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    } else {
        TCHAR szStrBuf[4];
        UINT uSize;
         LPCANDIDATELIST     lpRevCandList;

        if(lpImcP->hRevCandList == (HIMCC)NULL){
            // we alloc memory in lpImcP->hRevCandList, 
            // for reverse convert result codes; When finish reconvert, 
            // should read out this info.
REALLOC:
            lpImcP->hRevCandList = (HIMCC)GlobalAlloc(GHND,sizeof(CANDIDATELIST)+1*sizeof(DWORD)+(MAXCODE+1)*sizeof(TCHAR)); 
            if (lpImcP->hRevCandList == (HIMCC)NULL) {
                return ;
            }
               lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
            if (lpRevCandList == NULL) {
                return ;
            }
           }else{
               lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
               if (lpRevCandList == NULL) {
                goto REALLOC;
               }
        }

        *(LPUNAWORD)szStrBuf = *(LPUNAWORD)((LPBYTE)lpCompStr +
            lpCompStr->dwResultStrOffset);
        szStrBuf[1] = TEXT('\0');

        memset(lpRevCandList, 0, sizeof(CANDIDATELIST)+1*sizeof(DWORD)+(MAXCODE+1)*sizeof(TCHAR));
        lpRevCandList->dwSize = sizeof(CANDIDATELIST)+1*sizeof(DWORD)+(MAXCODE+1)*sizeof(TCHAR);

        uSize = ImmGetConversionList(sImeG.hRevKL, (HIMC)NULL, szStrBuf,
            (LPCANDIDATELIST)lpRevCandList, 
            lpRevCandList->dwSize, GCL_REVERSECONVERSION);

        GlobalUnlock((HGLOBAL)lpImcP->hRevCandList);
        

        if (uSize) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION|
                    MSG_START_COMPOSITION);
            } else {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg|
                    MSG_START_COMPOSITION) & ~(MSG_END_COMPOSITION);
            }
        } else {
            GlobalFree((HGLOBAL)lpImcP->hRevCandList);
        }
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
}
#endif //CROSSREF

/**********************************************************************/
/* SelectOneCand()                                                    */
/**********************************************************************/
void PASCAL SelectOneCand(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPCANDIDATELIST     lpCandList)
{
    DWORD dwCompStrLen;
    DWORD dwReadStrLen;

    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    if (!lpImcP) {
        MessageBeep((UINT)-1);
        return;
    }

    // backup the dwCompStrLen, this value decide whether
    // we go for phrase prediction
    dwCompStrLen = lpCompStr->dwCompStrLen;
    dwReadStrLen = lpCompStr->dwCompReadStrLen;

    InitCompStr(lpCompStr);

    // calculate result string length
    lpCompStr->dwResultStrLen = lstrlen(
        (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwSelection]));

    // the result string = the selected candidate;
    lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
        (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwSelection]));

    // tell application, there is a reslut string
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD)0;
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    // no candidate now, the right candidate string already be finalized
    lpCandList->dwCount = 0;

    lpImcP->iImeState = CST_INIT;
    
    
    // init Engine private data
    *(LPDWORD)lpImcP->bSeq = 0;

#ifdef CROSSREF
    CrossReverseConv(lpIMC, lpCompStr, lpImcP, lpCandList);
#endif

    return;
}

/**********************************************************************/
/* CandEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CandEscapeKey(
    LPINPUTCONTEXT  lpIMC,
    LPPRIVCONTEXT   lpImcP)
{
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;

    // clean all candidate information
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        ClearCand(lpIMC);
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }


    // if it start composition, we need to clean composition
    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        return;
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {          
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {          
        return;
    }

    CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}

/**********************************************************************/
/* ChooseCand()                                                       */
/**********************************************************************/
void PASCAL ChooseCand(         // choose one of candidate strings by
                                // input char
    WORD            wCharCode,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    LPPRIVCONTEXT   lpImcP)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;

    if (wCharCode == VK_ESCAPE) {           // escape key
        CandEscapeKey(lpIMC, lpImcP);
        return;
    }

    if (!lpCandInfo) {
        MessageBeep((UINT)-1);
        return;
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    if (wCharCode == TEXT(' ')) {      // circle selection
        if ((lpCandList->dwSelection += lpCandList->dwPageSize) >=
            lpCandList->dwCount) {
            // no more candidates, restart it!
            lpCandList->dwSelection = 0;
            MessageBeep((UINT)-1);
        }
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == TEXT('=')) {      // next selection
#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex == INDEX_GB){
            if (lpCandList->dwSelection >= ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }
           }else if(sImeL.dwRegImeIndex == INDEX_GBK){
            if (lpCandList->dwSelection >= ((IME_XGB_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }
           }else if(sImeL.dwRegImeIndex == INDEX_UNICODE){
            if (lpCandList->dwSelection >= ((IME_UNICODE_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }
        }
#else //COMBO_IME
#if defined(GB)
        if (lpCandList->dwSelection >= ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
#else
        if (lpCandList->dwSelection >= ((IME_XGB_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
#endif
            MessageBeep((UINT)-1);
            return;
           }
#endif //COMBO_IME
        lpCandList->dwSelection += lpCandList->dwPageSize;
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == TEXT('-')) {      // previous selection
        if (lpCandList->dwSelection < lpCandList->dwPageSize) {
            MessageBeep((UINT)-1);
            return;
        }
        lpCandList->dwSelection -= lpCandList->dwPageSize;
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == 0x23) {      // previous selection
#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex == INDEX_GB){
            if (lpCandList->dwSelection >= ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }else{
                lpCandList->dwSelection = ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize;
            }
           }else if(sImeL.dwRegImeIndex == INDEX_GBK){
            if (lpCandList->dwSelection >= ((IME_XGB_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }else{
                lpCandList->dwSelection = ((IME_XGB_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize;
            }
           }else if(sImeL.dwRegImeIndex == INDEX_UNICODE){
            if (lpCandList->dwSelection >= ((IME_UNICODE_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
                MessageBeep((UINT)-1);
                return;
            }else{
                lpCandList->dwSelection = ((IME_UNICODE_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize;
            }
        }
#else //COMBO_IME
        #if defined(GB)
        if (lpCandList->dwSelection >= ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize) {
        #else
        if (lpCandList->dwSelection >= ((IME_XGB_MAXCAND-1)/CANDPERPAGE - 1)*lpCandList->dwPageSize) {
        #endif
            MessageBeep((UINT)-1);
            return;
        }
        #if defined(GB)
        lpCandList->dwSelection = ((IME_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize;
        #else
        lpCandList->dwSelection = ((IME_XGB_MAXCAND-1)/CANDPERPAGE)*lpCandList->dwPageSize;
        #endif
#endif //COMBO_IME
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == 0x24) {
        if (lpCandList->dwSelection < lpCandList->dwPageSize) {
            MessageBeep((UINT)-1);
            return;
        }
        lpCandList->dwSelection = 0;
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if (wCharCode == TEXT('?')) {      // home selection
        if (lpCandList->dwSelection == 0) {
            MessageBeep((UINT)-1);      // already home!
            return;
        }
        lpCandList->dwSelection = 0;
        // inform UI, dwSelectedCand is changed
        lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        return;
    }

    if ((wCharCode >= TEXT('0')) && wCharCode <= TEXT('9')) {

        DWORD dwSelCand;

        dwSelCand = wCharCode - TEXT('0') - CAND_START;
        if(wCharCode == TEXT('0')) {
            dwSelCand = 9;
        }

        if (dwSelCand >= CANDPERPAGE) {
            // out of candidate page range
            MessageBeep((UINT)-1);
            return;
        }

        if ((lpCandList->dwSelection + dwSelCand) >=
            lpCandList->dwCount) {
            // out of range
            MessageBeep((UINT)-1);
            return;
        }

        lpCandList->dwSelection = lpCandList->dwSelection + dwSelCand;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if (!lpCompStr) {          
            return;
        }

        // translate into translate buffer
        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

        ImmUnlockIMCC(lpIMC->hCompStr);

        return;
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\data.h ===
/*************************************************
 *  data.h                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/


extern WORD KeyBoardState;
extern HDC hMemoryDC;
extern HBITMAP cur_h;
extern BYTE cap_mode;
extern int  kb_mode;
extern HANDLE hInputWnd;
extern WORD TimerCounter;
extern WORD cur_hibit;
extern int kb_flag , wait_flag ,waitzl_flag;        //waitzl 1
extern BOOL cur_flag;
extern int TypeOfOutMsg;
extern char SoftKeyDef[3][100];
extern struct FMT now ;
extern WORD SoftKeyNum;
extern int unit_length;
extern    HIMC ghIMC;
extern  LPPRIVCONTEXT glpIMCP;
extern    LPINPUTCONTEXT glpIMC;
extern  BYTE bx_inpt_on;
extern  BYTE InputBuffer[];
extern  int now_cs_dot,now_cs;
extern  WORD cur_start_ps;
extern  WORD cur_start_count;
extern  BYTE V_Flag,bx_inpt_on;
extern  HANDLE cisu_hd;

BYTE step_mode =0;

int ShowCandTimerCount;
int CandWndChange = 0;
int CompWndChange = 0;


HINSTANCE hInst;
IMEG      sImeG;
IMEL      sImeL;
LPIMEL    lpImeL;
BYTE      szUIClassName[16];
BYTE      szCompClassName[24];
BYTE      szCandClassName[24];
BYTE      szStatusClassName[24];
BYTE      szHandCursor[] = "Hand";
BYTE      szChinese[] = "Chinese";
BYTE      szEnglish[] = "English";
BYTE      szCode[] = "Code";
BYTE      szEudc[] = "Eudc";
BYTE      szFullShape[] = "FullShape";
BYTE      szHalfShape[] = "HalfShape";
BYTE      szNone[] = "None";
BYTE      szNoSTD[] = "NOSTD";
BYTE      szNoSDA[] = "NOSDA";
BYTE      szSoftKBD[] = "SoftKBD";
BYTE      szNoSoftKBD[] = "NoSoftKBD";
BYTE      szDigit[] = "01234567890";
BYTE      szSTD[] ="MODESTD";
BYTE      szSDA[] ="MODESDA";
BYTE      szCPCT[] ="CPCT";
BYTE      szEPCT[] ="EPCT";
BYTE      CUR_HB[]    = "CUR_BMP";
BYTE      szUpDown[] = "UPDOWN";
BYTE      szFlower[] = "FLOWER";
BYTE      szPageUp[] = "BPAGEUP";
BYTE      szPageDown[] = "BPAGEDOWN";
BYTE      szHome[] = "BHOME";
BYTE      szEnd[]  = "BEND";
BYTE      szPageUp2[] = "BPAGEUP2";
BYTE      szPgDown2[] = "BPGDOWN2";
BYTE      szHome2[] = "BHOME2";
BYTE      szEnd2[]  = "BEND2";

BYTE      szNumb[]  = "NUMB";
BYTE      szSnumb[] = "SNUMB";

// convert char to upper case
BYTE bUpper[] = {
// 0x20 - 0x27
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
// 0x28 - 0x2F
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
// 0x30 - 0x37
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
// 0x38 - 0x3F
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
// 0x40 - 0x47
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
// 0x48 - 0x4F
    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
// 0x50 - 0x57
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
// 0x58 - 0x5F
    0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
//   '    a    b    c    d    e    f    g
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   h    i    j    k    l    m    n    o
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   p    q    r    s    t    u    v    w
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   x    y    z    {    |    }    ~
    'X', 'Y', 'Z'
};

WORD fMask[] = {         // offset of bitfield
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
};

BYTE szRegIMESetting[] = "Control Panel\\Input Method";


// decide UI offset base on escapement
NEARCARET ncUIEsc[] = {
   // LogFontHi   ParaX   PerpX   ParaY   PerpY
    { 1,          1,      0,      0,      1},           // 0
    { 0,          0,      1,      1,      0},           // 900
    { 0,         -1,      0,      0,      1},           // 1800
    { 0,          0,     -1,      1,      0}            // 2700
};

// decide input rectangle base on escapement
POINT ptInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,            1},                                  // 0
    {1,           -1},                                  // 900
    {-1,          -1},                                  // 1800
    {-1,           1}                                   // 2700
};


// all shift keys are not for typing reading characters
BYTE bChar2VirtKey[] = {
//   ' '        !    "    #    $    %    &    '
     VK_SPACE,  0,   0,   0,   0,   0,   0, VK_OEM_QUOTE,
//   (    )    *    +    ,             -             .              /
     0,   0,   0,   0, VK_OEM_COMMA, VK_OEM_MINUS, VK_OEM_PERIOD, VK_OEM_SLASH,
//   0    1    2    3    4    5    6    7
    '0', '1', '2', '3', '4', '5', '6', '7',
//   8    9    :    ;              <    =            >   ?
    '8', '9',  0, VK_OEM_SEMICLN,  0, VK_OEM_EQUAL,  0,  0,
//   @    A    B    C    D    E    F    G
    '!', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   H    I    J    K    L    M    N    O
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   P    Q    R    S    T    U    V    W
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   X    Y    Z     [                \              ]               ^   _
    'X', 'Y', 'Z', VK_OEM_LBRACKET, VK_OEM_BSLASH, VK_OEM_RBRACKET,  0,  0
};

// this table will convert key of other layout to the standard layout
// '!' for invalid key
BYTE bStandardLayout[4][0x41] = {
    {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', '!',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', ',', '-', '.', '/',
//   0    1    2    3    4    5    6    7
    '0', '1', '2', '3', '4', '5', '6', '7',
//   8    9    :    ;    <    =    >    ?
    '8', '9', '!', ';', '<', '!', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   H    I    J    K    L    M    N    O
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   P    Q    R    S    T    U    V    W
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   X    Y    Z    [    \    ]    ^    _    `
    'X', 'Y', 'Z', '!', '!', '!', '!', '!', '!'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', 'H',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', '5', '/', 'T', 'G',
//   0    1    2    3    4    5    6    7
    ';', '7', '6', '3', '4', '!', '!', 'F',
//   8    9    :    ;    <    =    >    ?
    '0', 'P', '!', 'Y', '<', '-', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', '8', '1', 'V', '2', 'U', 'Z', 'R',
//   H    I    J    K    L    M    N    O
    'C', '9', 'B', 'D', 'X', 'A', 'S', 'I',
//   P    Q    R    S    T    U    V    W
    'Q', 'O', 'K', 'N', 'W', 'M', 'E', ',',
//   X    Y    Z    [    \    ]    ^    _    `
    'J', '.', 'L', '!', '!', '!', '!', '!', '!'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', '!',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', '3', 'C', '4', '7',
//   0    1    2    3    4    5    6    7
    'D', '1', 'Q', 'A', 'Z', '2', 'W', 'S',
//   8    9    :    ;    <    =    >    ?
    'X', 'E', '!', 'L', '<', '!', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', 'U', '/', 'P', 'M', 'V', '8', 'I',
//   H    I    J    K    L    M    N    O
    'K', 'Y', ',', '9', 'O', '6', '-', 'H',
//   P    Q    R    S    T    U    V    W
    'N', 'R', '5', 'J', 'T', 'B', ';', 'F',
//   X    Y    Z    [    \    ]    ^    _    `
    '0', 'G', '.', '!', '!', '!', '!', '!', '!'
    }
    , {
//  ' '   !    "    #    $    %    &    '
    ' ', '!', '!', '!', '!', '!', '!', 'M',
//   (    )    *    +    ,    -    .    /
    '!', '!', '!', '!', ',', 'U', '.', '/',
//   0    1    2    3    4    5    6    7
    '0', '7', '1', '2', '!', '!', '5', '!',
//   8    9    :    ;    <    =    >    ?
    '8', '9', '!', ';', '<', '-', '>', '?',
//   @    A    B    C    D    E    F    G
    '!', '3', 'V', 'X', 'S', 'W', 'D', 'F',
//   H    I    J    K    L    M    N    O
    'G', 'I', 'H', 'K', 'L', 'N', 'B', 'O',
//   P    Q    R    S    T    U    V    W
    'P', '6', 'E', 'A', 'R', 'Y', 'C', 'Q',
//   X    Y    Z    [    \    ]    ^    _    `
    'Z', 'T', '4', 'J', '!', '!', '!', '!', '!'
    }
};


// the index (position) of bo, po, mo, and fo.
// only 0 to 3 is a valid value
char cIndexTable[] = {
//  ' '   !    "    #    $    %    &    '
     3,   -1,  -1,  -1,  -1,  -1,  -1,  -1,
//   (    )    *    +    ,    -    .    /
     -1,  -1,  -1,  -1,  2,   2,   2,   2,
//   0    1    2    3    4    5    6    7
     2,   0,   0,   3,   3,   0,   3,   3,
//   8    9    :    ;    <    =    >    ?
     2,   2,   -1,  2,   -1,  -1,  -1,  -1,
//   @    A    B    C    D    E    F    G
     -1,  0,   0,   0,   0,   0,   0,   0,
//   H    I    J    K    L    M    N    O
     0,   2,   1,   2,   2,   1,   0,   2,
//   P    Q    R    S    T    U    V    W
     2,   0,   0,   0,   0,   1,   0,   0,
//   X    Y    Z    [    \    ]    ^    _    `
     0,   0,   0,   -1,  -1,  -1,  -1,  -1,  -1
};

// convert sequence code to index [position]
char cSeq2IndexTbl[] = {
//    0   1   2   3   4   5   6   7
     -1,  0,  0,  0,  0,  0,  0,  0,
//    8   9  10  11  12  13  14  15
      0,  0,  0,  0,  0,  0,  0,  0,
//   16  17  18  19  20  21  22  23
      0,  0,  0,  0,  0,  0,  1,  1,
//   24  25  26  27  28  29  30  31
      1,  2,  2,  2,  2,  2,  2,  2,
//   32  33  34  35  36  37  38  39
      2,  2,  2,  2,  2,  2,  3,  3,
//   40  41  42
      3,  3,  3
};


const TCHAR szRegAppUser[] = REGSTR_PATH_SETUP;
const TCHAR szRegModeConfig[] = "Mode Configuration";

const TCHAR szRegNearCaret[] = REGSTR_PATH_SETUP ;
const TCHAR szAIABC[] = "ABC";
//"Control Panel\\Input Method";
const TCHAR szPara[] = "Parallel Distance";
const TCHAR szPerp[] = "Perpendicular Distance";
const TCHAR szParaTol[] = "Parallel Tolerance";
const TCHAR szPerpTol[] = "Perpendicular Tolerance";
const TCHAR szKeyType[]="˫";
const TCHAR szImeStyle[] = "";
const TCHAR szCpAuto[] = "Ƶ";
const TCHAR szBxFlag[] = "";
const TCHAR szTuneFlag[] ="";
const TCHAR szAutoCvt[]  = "Զת";
const TCHAR szSdaHelp[]  = "˫ʾ";

//DATA.C   sdk #4

const CHAR VirtKey48Map[48]
    ={VK_SPACE,'0','1','2','3','4','5','6','7','8','9',
      'A','B','C','D','E','F','G','H','I','J','K',
      'L','M','N','O','P','Q','R','S','T','U','V',
      'W','X','Y','Z',
      VK_OEM_SEMICLN,
      VK_OEM_EQUAL,
      //VK_OEM_PERIOD,
      (CHAR)VK_OEM_COMMA,
      (CHAR)VK_OEM_MINUS,
      (CHAR)VK_OEM_PERIOD,
      //VK_OEM_COMMA,
      VK_OEM_SLASH,// '/'
      (CHAR)VK_OEM_3,      // '`' '~'
      VK_OEM_LBRACKET, //'['
      VK_OEM_BSLASH,     //'\'
      VK_OEM_RBRACKET,  // ']'
      VK_OEM_QUOTE        // [']
      };

CHAR SKLayout[NumsSK][48*2] = {
    "ۣܣݣ",
    "                    ʦ֦Ԧ̦æͦΦϦȦЦ  ئצ  Ħ˦ŦǦզ¦ӦƦ                      ",
    "                      ݧߧӧا٧ڧѧԧާէקҧ֧        ܧ",
    "        ڨިǨ֨ϨΨͨѨըبۨܨ٨ߨƨШ˨ԨҨ  רȨ            ",
    "                                            ",
    "  ʤ̤ͤΤϤĤҤդؤäƤˤᤷߤޤ  򤡤  ",
    "ʥ̥ͥΥϥĥҥեإåƥ˥᥷ߥޥۥ򥡥ȥ",
    "áۣݡࡨ",
    "ɢǢ碳ꢸˢʢ梵ȢƢŢ  ̢͢΢        ",
    "  ԡ٣ܡݣڡۡġѡϡƣǡȡɡҡ  ߡסաӡءš  УΣ͡    ˡ  ֡      ",
    "꣤룥  ׼̫İ    ˾šǧ΢һ            ʮ      ",
    "  Щҩ©өԩթǩ֩    éѩĩƩũ    穬        ",
    "                    ޣߡܡ                      ",
    };

CHAR SKLayoutS[NumsSK][48*2] = {
    "磥ޣ£ãģţƣǣȣɣʣˣ̣ͣΣϣУѣңӣԣգ֣ףأ٣ڣߣ",
    "                                                ",
    "                              ",
    "                                                                                                ",
    "                                                                                                ",
    "    ѤפڤݤФŤӤ֤٤  ǤԤ¤줸            ",
    "      ѥץڥݥХťӥ֥٥  ǥԥ¥쥸ܥ          ",
    "                                                                                                ",
    "                      ٢ӢѢۢܢݢޢ¢ߢբԢâĢڢҢТϢ    ע          ",
    "                                                                                                ",
    "                                            ƾǪ½  Ҽ                  ʰ      ",
    "    ةکʩ۩ܩݩϩީ    ȩ˩٩̩Ωɩͩ    舘        ",
    "                                                                                                ",
    };

BYTE PcKb[48*2] =
    "ۣܣݣ";
BYTE SdaKb[48*2]=
    "";


BYTE SPcKb[48*2]=
    "磥ޣ£ãģţƣǣȣɣʣˣ̣ͣΣϣУѣңӣԣգ֣ףأ٣ڣߣ";
BYTE SSdaKb[48*2]={'\xa1', '\xa1'};

 const NEARCARET ncAltUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        0,        1,      0,      0,     -1},       // 0
    { 0,        0,        0,     -1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,     -1},       // 1800
    { 0,        0,        0,      1,     -1,      0}        // 2700
};

const POINT ptAltInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,           -1},                                  // 0
    {-1,          -1},                                  // 900
    {1,           -1},                                  // 1800
    {1,            1}                                   // 2700
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\resrc1.h ===
/*************************************************
 *  resrc1.h                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WINABC.rc
//
#define CvtCtrlDlg                      18
#define ImeStyleDlg                     101
#define IDR_ACC                         101
#define KbSelectDlg                     102
#define cvtctrl                         103
#define IDC_RADIO1                      1005
#define IDC_USERKB                      1005
#define IDC_BUTTON1                     1006
#define IDC_DEFKB                       1006
#define IDC_BUTTON_OK                   1006
#define IDC_BUTTON2                     1007
#define IDC_LOOKUP                      1007
#define IDC_BUTTON_ESC                  1007
#define IDC_RADIO2                      1008
#define IDC_KBHELP                      1008
#define IDC_DH                          1009
#define IDC_AUTOCVT                     1009
#define IDC_CBX                         1010
#define IDC_CP                          1011
#define IDC_BD                          1012
#define IDC_RADIO3                      1013
#define IDC_NEAR                        1015
#define IDC_FIX                         1016
#define IDC_AIABC                       1017
#define IDC_WPS                         1018
#define IDC_STONE                       1019
#define IDC_BUTTON3                     1020
#define IDC_CHECK1                      1028
#define IDC_CHECK2                      1029
#define IDC_CHECK3                      1030

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PROPSHET.RC
//
#define IDS_APPNAME                     1
#define IDS_DESCRIPTION                 2
#define IDD_VERFIRST                    100
#define dlgbackcolor                    101
#define dlgshape                        102
#define IDI_BACKCOLOR                   103
#define IDI_SHAPES                      104
#define IDD_VERLAST                     104
#define IDI_APPICON                     105
#define IDC_RED                         1000
#define IDM_EXIT                        1000
#define IDC_GREEN                       1001
#define IDC_BLUE                        1002
#define IDC_RECTSQUARE                  1002
#define IDC_TRAPEZOID                   1003
#define IDC_RECTANGLE                   1004
#define IDM_ABOUT                       1100
#define IDM_PROPSHET                    40001
#define IDC_STATIC                      -1

//for ADDWORD "WFC"
#define ID_ADD                      101
#define ID_DEL                      102
#define ID_NEWCHR                   104
#define ID_SHU                      106
#define ID_LISTBOX                  109
#define ID_TS1                      103
#define ID_TS2                      105
#define ID_TS3                      108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntabc\winabc\addword.c ===
/*************************************************
 *  addword.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "windows.h"
#include "winuser.h"
#include "immdev.h"
#include "abc95def.h"
#include "abcw2.h"
#include "resource.h"

BOOL WINAPI ErrExit(HWND hDlg, int err_number);
WORD s_buf[0x1000];
extern struct INPT_BF kbf;    
extern HWND       hCrtDlg;    
OFSTRUCT s_open;

BYTE str[45]={0};
/*******************************************************
write_data(): add the new word defined by the user into
              the user.rem
********************************************************/
BOOL WINAPI write_data(count,temp_bf)
int count;
BYTE *temp_bf;
{
    int hd;
    int op_count;

    hd=OpenFile(user_lib,&s_open,OF_WRITE);
    if (hd==-1)
        return(ErrExit(NULL,1));
    _llseek(hd,(data_start+count*data_record_length),0);
    op_count=_lwrite(hd,(LPSTR)temp_bf,data_record_length);
    if (op_count!=data_record_length)
           {_lclose(hd);
        return(ErrExit(NULL,1));
           }
    _lclose(hd);
    return(TRUE);

}

/****************************************************
write_mulu(): write the changed index on the disk
*****************************************************/
BOOL WINAPI write_mulu()
{
    int hd;
    int op_count;

    hd=OpenFile(user_lib,&s_open,OF_WRITE);
    if (hd==-1)
        return(ErrExit(NULL,1));

    op_count=_lwrite(hd,(LPSTR)&s_buf,mulu_true_length);
    if (op_count!=mulu_true_length)
        {_lclose(hd);
        return(ErrExit(NULL,1));
        }
    _lclose(hd);
    return(TRUE);

}


int WINAPI find_empty_item()
{
    int i;
    BYTE *p;

    read_mulu();
    p = (BYTE *)&s_buf[8];
    i = 0;

    while ( i < mulu_true_length )
    {
    if ( p[i] & 0x80 )
        return( i );
    i += mulu_record_length;
    }
    return(-1);
}


//---------------------------------------------------------
// ErrExit()
//    for file operating erorrs
//---------------------------------------------------------
BOOL WINAPI ErrExit(hDlg,err_number)
HWND hDlg;
int err_number;
{
     MessageBox(hDlg, "ļ",
          NULL, MB_OK | MB_ICONHAND);
     return(FALSE);
}


/***********************************************************
read_mulu(): read the user definition index from the tmmr.rem
*************************************************************/
BOOL WINAPI read_mulu()
{
    int hd;
    int op_count;

    hd=OpenFile(user_lib,&reopen,OF_READ);
    if (hd==-1)
        return(ErrExit(NULL,1));                                                                //error
    op_count=_lread(hd,&s_buf,16);
    if (op_count!=16)
    {
        _lclose(hd);
        return(ErrExit(NULL,1));         //error
    }

    mulu_true_length=s_buf[3];
    op_count=_lread(hd,&s_buf[8],mulu_true_length-16);
    if (op_count!=mulu_true_length-16){
        _lclose(hd);
        return(ErrExit(NULL,1));                                                                //error
    }
    _lclose(hd);
    return(TRUE);

}


/*****************************************************************
listbox(hDlg): list the new word definated by the user.
******************************************************************/
int WINAPI listbox(hDlg)
HWND hDlg;
{
    int i,c;
    BYTE *p;

    read_mulu();

    i=0x10;
    while (i<mulu_true_length){
        if (!read_data((i-0x10)/mulu_record_length)){
            MessageBox(hDlg, "ļ",
          NULL, MB_OK | MB_ICONHAND);
            break;
            }
        p=(BYTE *)&s_buf[i/2];
        for (c=1; c<10; c++)
            out_svw[31+c]=p[c];
        out_svw[41]=0;
        {
        char temp_bf[42];
        {
         int i;
         for (i=0;i<41;i++)
                temp_bf[i]=0x20;
        //strnset(temp_bf,0x20,41);
        }
        temp_bf[41]=0;
        for (c=0; c<9; c++)
            temp_bf[c]=out_svw[32+c];
        temp_bf[9]=0x20;
        for(c=0; c<30;c++)
          temp_bf[c+10]=out_svw[2+c];

        if (out_svw[1]!=0x2a) {  //1993.4.18 if the string has deleted, don't display it
            SendDlgItemMessage(hDlg,ID_LISTBOX,
                               LB_ADDSTRING,        // add these new word
                               0,                   // onto the listbox
                               (LPARAM)((LPSTR *)temp_bf));
            }//if (out_svw)
         }
        i+=mulu_record_length;
        }

        return 0;
}

/***************************************************************
if_code_equ(): search if the code in the index
****************************************************************/
BOOL WINAPI if_code_equ(addr)
int addr;
{
    int i;
    BYTE *p;

    p=(BYTE *)s_buf;

    if (kbf.true_length!=(p[addr++]-0x30))  //minuse the 0x30 in order to get the record length
        return(STC);            //if the length is not equal, exit
    for (i=0; i<kbf.true_length; i++){
        if ((kbf.buffer[i]!=p[addr])
            && ((kbf.buffer[i]&0xdf)!=p[addr]))
                return(STC);
        addr++;
        }
    return(CLC);                    //find the code in the index
}

/**************************************************************
    FUNCTION: OpenDlg(HWND,UNSIGNED,WORD,LONG)
    PURPOSE: let the user add a new term in the liberty
***************************************************************/

INT_PTR WINAPI OpenDlg(hDlg, message, wParam, lParam)
HWND   hDlg;
UINT   message;                 //##!!unsigned message;
WPARAM wParam;                 //##!!WORD wParam;
LPARAM lParam;
{
    WORD index;
    BYTE *p;
                   //##!!PSTR pTptr;
    int i,count;
                   //##!!HBRUSH OldBrush;
    HDC hDC;
    RECT Rect;
                   //##!!RECT Rect1;
    int find_empty_flag;           /*94.7.30*/

    switch (message) {
    case WM_COMMAND:
        
        switch (LOWORD(wParam)) {
        case ID_LISTBOX:
            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,FALSE);
            ImmReleaseContext(hDlg,hIMC);
            }

            switch (HIWORD(lParam)) {

            case LBN_SELCHANGE:
            
                   index=(WORD)SendDlgItemMessage(hDlg,ID_LISTBOX,
                                                  LB_GETCURSEL,0,0l);
                   SendDlgItemMessage(hDlg,ID_LISTBOX,
                                      LB_GETTEXT,index,
                                      (LPARAM)(LPSTR *)str);
                   break;

            case LBN_DBLCLK:
                break;
            }                                                     
            return (TRUE);


        
        case ID_ADD:
        
               for (i=0; i<sizeof str; i++)
                str[i]=0;               //1993.4.20 clear the buffer

               count = GetDlgItemText(hDlg, ID_NEWCHR, str, 31);

               i=0;
               while(str[i]==0x20) i++;

               if ((i==count)||(!str[0])){
                MessageBox(hDlg, "δ´",
                          NULL, MB_OK | MB_ICONHAND);
                return (TRUE);
                }


               memmove(&str[2], &str[0], 30);
               str[0]=count+0x30;                       //save the string count
               str[1]=0x20;

               count+=2;
               while (count<user_word_max_length)
                 str[count++]=0x20;

               GetDlgItemText(hDlg, ID_SHU, kbf.buffer, 10);
               if (!kbf.buffer[0]){
                MessageBox(hDlg, "δ",
                NULL, MB_OK | MB_ICONHAND);
                return (TRUE);
                   }

               {
               int j=0;
               while (kbf.buffer[j]>0x20) j++;
               i=j;
               if(j>0)
             for(j=0;j<i; j++)
                 if (kbf.buffer[j]>0xa0) i=0;
               if(!i) {
                MessageBox(hDlg, "зǷַ",
                          NULL, MB_OK | MB_ICONHAND);
                return (TRUE);
                }
            for (j=0;j<i;j++)
                str[count+j]=kbf.buffer[j];
               }


               kbf.true_length=(WORD)i;

               read_mulu();
               for (i=0x10; i<(mulu_true_length+0x10); i=i+mulu_record_length){
                if (if_code_equ(i)){
                    MessageBox(hDlg, "ظ",
                        NULL, MB_OK | MB_ICONHAND);
                        SendDlgItemMessage(hDlg,ID_SHU,
                                 EM_SETSEL,
                                 0,
                                 MAKELONG(0,0x7fff));
                    return FALSE;
                    }
                }

               mulu_true_length+=mulu_record_length;

               if (mulu_true_length>mulu_max_length)
               {
              find_empty_flag = find_empty_item();
              if ( find_empty_flag == -1 )
              {
                MessageBox(hDlg,"û",
                    NULL, MB_OK | MB_ICONHAND);
                mulu_true_length-=mulu_record_length;
                return FALSE;
              }
              p=(BYTE *)(&s_buf[8]) + find_empty_flag;
              count=find_empty_flag/mulu_record_length;
               }

             else
             {
            p=(BYTE *)&s_buf[s_buf[3]/2];
            count=(mulu_true_length-0x10)/mulu_record_length-1;
             }

             s_buf[3]=mulu_true_length;
             p[0]=kbf.true_length+0x30;              /* fill string index length */
             for (i=0; i<kbf.true_length; i++)
            p[i+1]=kbf.buffer[i];                /* fill string index code   */
             for (i=i; i<(mulu_record_length-1); i++)        /* minuse the p[0]  */
            p[i+1]=0x20;                         /* clear the rest part of index */
             for (i=0; i<user_word_max_length; i++)  /* 32->user_word_max_length */
            kbf.buffer[i]=str[i];           /* move the string into writting buffer */

            if (write_mulu() == -1)
             return FALSE;
            if (write_data(count,kbf.buffer) == -1)
             return FALSE;
            {
            char temp_bf[41];
            WORD ndx;
            for(ndx=0; ndx<41;ndx++)
            temp_bf[ndx]=0x20;
            strncpy(&temp_bf[0],&p[1],kbf.true_length);
            strncpy(&temp_bf[10],&str[2],30);
            temp_bf[40]=0;
            ndx=(WORD)SendDlgItemMessage(hDlg,ID_LISTBOX,  // add these new word
                                         LB_ADDSTRING,     // onto the listbox
                                         0,       //1993.4.16 &str[2]->str[1]
                                         (LPARAM)((LPSTR *)&temp_bf[0]));     //disp the space for deleting word
            SendDlgItemMessage(hDlg,
                       ID_LISTBOX,
                       LB_SETCURSEL,
                       ndx,
                       0L);

            }
            break;


        case ID_DEL:
            index=(WORD)SendDlgItemMessage(hDlg,ID_LISTBOX,
                                           LB_GETCURSEL,0,0L);
            SendDlgItemMessage(hDlg,ID_LISTBOX,
                               LB_GETTEXT,index,
                               (LPARAM)(LPSTR *)str);

            i=0;               //pointer the begining of string code
            while (str[i]&&(str[i]!=0x20)){
                kbf.buffer[i]=str[i];      //get the string index code
                i++;
                }
            kbf.true_length=(WORD)i;                   //get code length

            read_mulu();
            for (i=0x10; i<(mulu_true_length+0x10); i=i+mulu_record_length){
                if (if_code_equ(i)){
                    p=(BYTE *)s_buf;
                    p[i]|=0x80;
                    write_mulu();

                    count=(i-0x10)/mulu_record_length;
                    if (!read_data(count))
                        break;                          //break from the cycle
                    out_svw[1]=0x2a;
                    write_data(count,out_svw);


                    SendDlgItemMessage(hDlg,ID_LISTBOX,
                            LB_DELETESTRING,             // add these new word
                            index,                       // onto the listbox
                            (LPARAM)((LPSTR *)str));


                    return(TRUE);
                    }
                }
                MessageBox(hDlg, "ɾʧ",
                NULL, MB_OK | MB_ICONHAND);

                break;

        case IDOK:                      

            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,TRUE);
            ImmDestroyContext(hIMC);
            ImmReleaseContext(hDlg,hIMC);
            }
            
            Return=NULL;
            EndDialog(hDlg, TRUE);

            return (TRUE);

            break;

        case IDCANCEL: 
            Return=NULL;
            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,TRUE);
            ImmDestroyContext(hIMC);
            ImmReleaseContext(hDlg,hIMC);
            }
            EndDialog(hDlg, TRUE);

            return (TRUE);

        case ID_NEWCHR:         //1993.4.19
            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,TRUE);
            ImmReleaseContext(hDlg,hIMC);
            }

            break;

        case ID_SHU:            //1993.4.19
            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,FALSE);
            ImmReleaseContext(hDlg,hIMC);
            }

    
            break;

        }
        break;

    case WM_INITDIALOG:             // message: initialize
        hCrtDlg = hDlg;        
        SendDlgItemMessage(hDlg,               // dialog handle
        ID_NEWCHR,                         // where to send message
        EM_SETSEL,                         // select characters
        0,                              // additional information
        MAKELONG(0, 0x7fff));              // entire contents
        SetFocus(GetDlgItem(hDlg, ID_NEWCHR));
        listbox(hDlg);

        CenterWindow(hDlg);

        return (0);   //##!!(NULL) Indicates the focus is set to a control

    case WM_PAINT:
        {
    PAINTSTRUCT ps;

        GetClientRect(hDlg, &Rect);         //get the whole window area
        
        InvalidateRect(hDlg, &Rect, 1);
        hDC=BeginPaint(hDlg, &ps);


        Rect.left+=10;//5;
        Rect.top+=8;//5;
        Rect.right-=10;//5;
        Rect.bottom-=12;//5;

        DrawEdge(hDC, &Rect, EDGE_RAISED,/*EDGE_SUNKEN,*/ BF_RECT);

        EndPaint(hDlg, &ps);

        }
        break;      

  case WM_DESTROY:
            {
            HIMC hIMC;
            hIMC = ImmGetContext(hDlg);
            ImmSetOpenStatus(hIMC,TRUE);
            ImmDestroyContext(hIMC);
            ImmReleaseContext(hDlg,hIMC);
            }
            
        return (TRUE); 

  case WM_QUIT:
  case WM_CLOSE:

            Return=NULL;
            EndDialog(hDlg, TRUE); 
            return (TRUE);

 
  
    }


    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\ddis.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ddis.c

++*/


#include <windows.h>
#include <windowsx.h>
#include <winerror.h>
#include <immdev.h>
#include <imedefs.h>
#include <resource.h>
#include <regstr.h>
#include <winuser.h>    
HWND  hCrtDlg = NULL;
/**********************************************************************/
/* ImeInquire()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeInquire(         // initialized data structure of IME
    LPIMEINFO lpImeInfo,        // IME specific data report to IMM
    LPTSTR    lpszWndCls,       // the class name of UI
    DWORD     dwSystemInfoFlags)
{
    if (!lpImeInfo) {
        return (FALSE);
    }

    lpImeInfo->dwPrivateDataSize = sizeof(PRIVCONTEXT);
    lpImeInfo->fdwProperty = IME_PROP_KBD_CHAR_FIRST|
#ifdef UNICODE
                             IME_PROP_UNICODE|
#endif
                             IME_PROP_CANDLIST_START_FROM_1|
                             IME_PROP_IGNORE_UPKEYS;

    lpImeInfo->fdwConversionCaps = IME_CMODE_NATIVE|IME_CMODE_FULLSHAPE|
        IME_CMODE_CHARCODE|IME_CMODE_SOFTKBD|IME_CMODE_NOCONVERSION;
    lpImeInfo->fdwSentenceCaps = 0;
    // IME will have different distance base multiple of 900 escapement
    lpImeInfo->fdwUICaps = UI_CAP_ROT90|UI_CAP_SOFTKBD;
    // composition string is the reading string for simple IME
    lpImeInfo->fdwSCSCaps = SCS_CAP_COMPSTR|SCS_CAP_MAKEREAD;
    // IME want to decide conversion mode on ImeSelect
    lpImeInfo->fdwSelectCaps = (DWORD)0;

    lstrcpy(lpszWndCls, (LPTSTR)szUIClassName);

    if ( lpImeL )
    {
       if ( dwSystemInfoFlags & IME_SYSINFO_WINLOGON )
       {
            //  the client app is running in logon mode.
            lpImeL->fWinLogon = TRUE;
       }
       else
            lpImeL->fWinLogon = FALSE; 

    }

    return (TRUE);
}
#if defined(CROSSREF)
/**********************************************************************/
/* ReverseConversionList()                                            */
/**********************************************************************/
void PASCAL ReverseConversionList(HWND   hLayoutListBox)
{
    int      nLayouts, i, nIMEs;
    TCHAR    szTmpImeName[24];
    HKL FAR *lpKLMem;

    LoadString(hInst, IDS_NONE, szTmpImeName, sizeof(szTmpImeName)/sizeof(TCHAR));

    SendMessage(hLayoutListBox, LB_INSERTSTRING,
        0, (LPARAM)szTmpImeName);

    SendMessage(hLayoutListBox, LB_SELECTSTRING,
        0, (LPARAM)szTmpImeName);

    SendMessage(hLayoutListBox, LB_SETITEMDATA,
        0, (LPARAM)(HKL)NULL);

    nLayouts = GetKeyboardLayoutList(0, NULL);

    lpKLMem = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);
    if (!lpKLMem) {
        return;
    }

    GetKeyboardLayoutList(nLayouts, lpKLMem);

    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        HKL hKL;

        hKL = *(lpKLMem + i);

        if (LOWORD(hKL) != NATIVE_LANGUAGE) {
            // not support other language
            continue;
        }

        if (!ImmGetConversionList(hKL, (HIMC)NULL, NULL,
            NULL, 0, GCL_REVERSECONVERSION)) {
            // this IME not support reverse conversion
            continue;
        }

        if (!ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME,
            szTmpImeName)) {
            // this IME does not report the IME name
            continue;
        }
        if( lstrcmp(szTmpImeName, szImeName) == 0)
            continue;

        nIMEs++;

        SendMessage(hLayoutListBox, LB_INSERTSTRING,
            nIMEs, (LPARAM)szTmpImeName);

        if (hKL == sImeG.hRevKL) {
            SendMessage(hLayoutListBox, LB_SELECTSTRING, nIMEs,
                (LPARAM)szTmpImeName);
        }

        SendMessage(hLayoutListBox, LB_SETITEMDATA,
            nIMEs, (LPARAM)hKL);
    }

    GlobalFree((HGLOBAL)lpKLMem);

    return;
}
#endif //CROSSREF

/**********************************************************************/
/* ImeSetDlgProc()                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL ImeSetDlgProc(  // dialog procedure of configuration
    HWND hDlg,
    UINT uMessage,
    WORD wParam,
    LONG lParam)
{
    RECT         rc;
    LONG         DlgWidth, DlgHeight;
    static DWORD TempParam;

#ifdef CROSSREF
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND          hLayoutListBox;
    static HIMC   hOldIMC;
#endif //CROSSREF

    switch (uMessage) {
    case WM_INITDIALOG:
        hCrtDlg = hDlg;
        // reset position
        GetWindowRect(hDlg, &rc);
        DlgWidth =  rc.right - rc.left;
        DlgHeight =  rc.bottom - rc.top;

    
        SetWindowPos(hDlg, HWND_TOP,
            (int)(sImeG.rcWorkArea.right - DlgWidth)/2,
            (int)(sImeG.rcWorkArea.bottom - DlgHeight)/2,
            (int)0, (int)0, SWP_NOSIZE);

        TempParam = sImeG.IC_Trace;
        CheckDlgButton (hDlg, IDC_TRACE, sImeG.IC_Trace);
#ifdef CROSSREF
        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

        hIMC = ImmGetContext(hLayoutListBox);
        if(hIMC){
            ImmSetOpenStatus(hIMC, FALSE);
        }
        ImmReleaseContext(hLayoutListBox, hIMC);

        // put all reverse conversion hKL into this list
        ReverseConversionList(hLayoutListBox);
#endif //CROSSREF

        return (TRUE);          // don't want to set focus to special control
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            {
                HKEY  hKeyCurrVersion;
                HKEY  hKeyGB;
                DWORD retCode;
                //CHAR  Buf[LINE_LEN];

                sImeG.IC_Trace = TempParam;
                
                retCode = OpenReg_PathSetup(&hKeyCurrVersion);

                if (retCode) {
                    RegCreateKey(HKEY_CURRENT_USER, 
                                 REGSTR_PATH_SETUP, 
                                 &hKeyCurrVersion);
                }

#if defined(COMBO_IME)

                if ( hKeyCurrVersion != NULL )
                {
                    retCode = RegCreateKeyEx(hKeyCurrVersion, 
                                         szImeRegName, 
                                         0,
                                         NULL,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL, 
                                         &hKeyGB, 
                                         NULL);
                }
#else

                if ( hKeyCurrVersion != NULL )
                {
                    retCode = RegCreateKeyEx(hKeyCurrVersion, 
                                         szImeName, 
                                         0,
                                         NULL, 
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hKeyGB,
                                         NULL);
                }
#endif //COMBO_IME

                if (hKeyGB != NULL){

                    RegSetValueEx (hKeyGB, 
                               szTrace,
                               (DWORD)0,
                               REG_DWORD,
                               (LPBYTE)&sImeG.IC_Trace,
                               sizeof(DWORD));

                    RegCloseKey(hKeyGB);
                }

                if ( hKeyCurrVersion )
                   RegCloseKey(hKeyCurrVersion);
#ifdef CROSSREF
    {
        HWND hLayoutListBox;
        int  iCurSel;
        HKL  hKL;
        DWORD retCode;

        hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);

        iCurSel = (int)SendMessage(hLayoutListBox, LB_GETCURSEL, 0, 0);

        hKL = (HKL)SendMessage(hLayoutListBox, LB_GETITEMDATA,
            iCurSel, 0);

        if (sImeG.hRevKL != hKL) {
            WORD nRevMaxKey;
            HKEY hKeyAppUser, hKeyIMEUser;
            LPPRIVCONTEXT  lpImcP;

            sImeG.hRevKL = hKL;


            //set reverse layout to registry
            retCode = OpenReg_PathSetup(&hKeyAppUser);
            if (retCode) {
                RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
            }

#if defined(COMBO_IME)
            retCode = RegCreateKeyEx(hKeyAppUser, szImeRegName, 0,
                NULL, REG_OPTION_NON_VOLATILE,    KEY_ALL_ACCESS    , NULL, &hKeyIMEUser, NULL);

            if (retCode) {
                DWORD   dwDisposition;
        
                retCode = RegCreateKeyEx (hKeyCurrVersion,
                                 szImeRegName,
                              0,
                              0,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyGB,
                              &dwDisposition);
            }
#else
            retCode = RegCreateKeyEx(hKeyAppUser, szImeName, 0,
                NULL, REG_OPTION_NON_VOLATILE,    KEY_ALL_ACCESS    , NULL, &hKeyIMEUser, NULL);

            if (retCode) {
                DWORD   dwDisposition;
        
                retCode = RegCreateKeyEx (hKeyCurrVersion,
                                 szImeName,
                              0,
                              0,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyGB,
                              &dwDisposition);
            }
#endif //COMBO_IME

            RegSetValueEx(hKeyIMEUser, szRegRevKL, 0, REG_DWORD, (LPBYTE)&hKL,sizeof(hKL));

            // get the new size
            nRevMaxKey = (WORD)ImmEscape(hKL, (HIMC)NULL, IME_ESC_MAX_KEY,
                NULL);

            if (lpImeL->nMaxKey != nRevMaxKey) {
                if(lpImeL->nMaxKey < nRevMaxKey)
                    lpImeL->nMaxKey = nRevMaxKey;

                // set the width & height for composition window
                 lpImeL->rcCompText.right = lpImeL->rcCompText.left +
                    sImeG.xChiCharWi * ((lpImeL->nMaxKey+2)/2);
                lpImeL->xCompWi = lpImeL->rcCompText.right + lpImeL->cxCompBorder * (2 + 4);

                //generate message to broadcast change comp win size
                hIMC = (HIMC)ImmGetContext(hDlg);
                if (!hIMC) {
                    return TRUE;
                }
                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {
                    return TRUE;
                }
                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    goto ChgConfigUnlockIMC;
                }
                lpImcP->fdwImeMsg |= MSG_IMN_COMPOSITIONPOS;
                GenerateMessage(hIMC, lpIMC, lpImcP);
                ImmUnlockIMCC(lpIMC->hPrivate);
ChgConfigUnlockIMC:
                ImmUnlockIMC(hIMC);
            } //end of change nMaxKey

            RegSetValueEx(hKeyIMEUser, szRegRevMaxKey, 0, REG_DWORD, (LPBYTE)&lpImeL->nMaxKey,sizeof(DWORD));

            RegCloseKey(hKeyAppUser);
            RegCloseKey(hKeyIMEUser);

        } //end of change RegRevKL
    }
#endif    //CROSSREF

            }
#ifdef CROSSREF
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
            hIMC = ImmGetContext(hLayoutListBox);
            if(hIMC) {
                   ImmSetOpenStatus(hIMC, TRUE);
            }
            ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
            EndDialog(hDlg, FALSE);
            break;
        case IDCANCEL:
#ifdef CROSSREF
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
            hIMC = ImmGetContext(hLayoutListBox);
            if(hIMC) {
                   ImmSetOpenStatus(hIMC, TRUE);
            }
            ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
            EndDialog(hDlg, FALSE);
            break;
        case IDC_TRACE:
            // Set Current InputMode Param(temp)
            TempParam = (TempParam ^ 0x00000001) & 0x00000001;
            break;
        default:
            return (FALSE);
        }
        return (TRUE);
    case WM_PAINT:
        {
            RECT rc;

            GetClientRect(hDlg, &rc);
            DrawConvexRect(GetDC(hDlg),
                rc.left + 7,
                rc.top + 7,
                rc.right - 7 - 1,
                rc.bottom - 40 - 1);

            DrawConvexRectP(GetDC(hDlg),
                rc.left + 7,
                rc.top + 7,
                rc.right - 7,
                rc.bottom - 40);
        }
        
        return (FALSE);
    case WM_CLOSE:
#ifdef CROSSREF
            hLayoutListBox = GetDlgItem(hDlg, IDD_LAYOUT_LIST);
            hIMC = ImmGetContext(hLayoutListBox);
            if(hIMC) {
                   ImmSetOpenStatus(hIMC, TRUE);
            }
            ImmReleaseContext(hLayoutListBox, hIMC);
#endif //CROSSREF
        EndDialog(hDlg, FALSE);
        return (TRUE);
    default:
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* ImeConfigure()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
/*BOOL WINAPI ImeConfigure(      // configurate the IME setting
    HKL     hKL,               // hKL of this IME
    HWND    hAppWnd,           // the owner window
    DWORD   dwMode)            // mode of dialog
{*/
BOOL WINAPI ImeConfigure(      // configurate the IME setting
    HKL     hKL,               // hKL of this IME
    HWND    hAppWnd,           // the owner window
    DWORD   dwMode,
    LPVOID  lpData)            // mode of dialog
{
    switch (dwMode) {
    case IME_CONFIG_GENERAL:
        DialogBox(hInst, TEXT("ImeSet"), (HWND)hAppWnd, (DLGPROC)ImeSetDlgProc);
        break;
    default:
        return (FALSE);
        break;
    }
    return (TRUE);
}


/**********************************************************************/
/* XGBConversion()                                                       */
/**********************************************************************/
DWORD PASCAL XGBConversion(
    LPCTSTR         lpszReading,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    UINT        MAX_COMP;
    UINT        uMaxCand;
    UINT        iRet;
    WORD        wCode;
    LPPRIVCONTEXT lpImcP;
    HGLOBAL       hImcP;
    int         i;
    DWORD       dwSize;
    if (!(lstrlen (lpszReading) == 4)) {
      return (0);
    }

    hImcP = GlobalAlloc (GMEM_MOVEABLE,sizeof (PRIVCONTEXT));
    if(!hImcP){
        return(0);
    }
    lpImcP= GlobalLock (hImcP);
    if(!lpImcP){
        GlobalFree(hImcP);
        return(0);
    }
    lstrcpy (lpImcP->bSeq,lpszReading);
    if(lpImcP->bSeq[3] == TEXT('?')){
      MAX_COMP = 178;
    } else {
      MAX_COMP = 1;
      }
    dwSize =        // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(WORD) + sizeof(TCHAR)) * MAX_COMP;
    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + sizeof(WORD) + sizeof(TCHAR);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);
      lpImcP->bSeq[0] = 0;
      lpImcP->bSeq[1] = 0;
      lpImcP->bSeq[2] = 0;
      lpImcP->bSeq[3] = 0;

    for (i=0;i<4;i++) {
       iRet = XGBProcessKey(*(LPBYTE)((LPBYTE)lpszReading+i),lpImcP);
       if (iRet == CST_INPUT) {
          lpImcP->bSeq[i] = *(LPBYTE)((LPBYTE)lpszReading+i);
       } else {
          return (DWORD)0;
       }
    }
                        wCode = XGBEngine(lpImcP);
    
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }

     GlobalUnlock (hImcP);
     GlobalFree (hImcP);
    return (dwSize);
}

/**********************************************************************/
/* Conversion()                                                       */
/**********************************************************************/
DWORD PASCAL Conversion(
    LPCTSTR         lpszReading,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    UINT        MAX_COMP,i;
    UINT        uMaxCand;
    UINT        iRet;
    WORD        wCode;
    LPPRIVCONTEXT lpImcP;
    HGLOBAL       hImcP;
    
    DWORD       dwSize;
    if (!(lstrlen (lpszReading) == 4)) {
      return (0);
    }

    hImcP = GlobalAlloc (GMEM_MOVEABLE,sizeof (PRIVCONTEXT));
    if(!hImcP){
        return(0);
    }
    lpImcP= GlobalLock (hImcP);
    if(!lpImcP){
        GlobalFree(hImcP);
        return(0);
    }
    lstrcpy (lpImcP->bSeq,lpszReading);
    if(lpImcP->bSeq[3] == TEXT('?')){
      MAX_COMP = 94;
    } else {
      MAX_COMP = 1;
      }
    dwSize =        // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(WORD) + sizeof(TCHAR)) * MAX_COMP;
    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) + sizeof(WORD) + sizeof(TCHAR);
    if (!uMaxCand) {
        // can not even put one string
        return (0);
    }

    lpCandList->dwSize = dwSize;
    lpCandList->dwStyle = IME_CAND_READ;    // candidate having same reading
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) *
        (uMaxCand - 1);
      lpImcP->bSeq[0] = 0;
      lpImcP->bSeq[1] = 0;
      lpImcP->bSeq[2] = 0;
      lpImcP->bSeq[3] = 0;

    for (i=0;i<4;i++) {
       iRet = GBProcessKey(*(LPBYTE)((LPBYTE)lpszReading+i),lpImcP);
       if (iRet == CST_INPUT) {
          lpImcP->bSeq[i] = *(LPBYTE)((LPBYTE)lpszReading+i);
       } else {
          return (DWORD)0;
       }
    }
       wCode = GBEngine (lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < MAX_COMP;i++, wCode++) {
                AddCodeIntoCand(lpCandList, wCode);
            }

     GlobalUnlock (hImcP);
     GlobalFree (hImcP);
    return (dwSize);
}
/**************************************************************************
BOOL DBCSToGBCode ( WORD    wCode, BYTE    AbSeq[5])
***************************************************************************/
BOOL DBCSToGBCode (
        WORD    wCode,
        TCHAR   AbSeq[5])
{        
    WORD    AreaCode;

#ifdef UNICODE
    //Converte Unicode to GBK
    // change CP_ACP to 936, so that it can work under Multilingul Env.
    WideCharToMultiByte(NATIVE_ANSI_CP, WC_COMPOSITECHECK, &wCode, 1, (char *)&AreaCode, 2, NULL, NULL);
    wCode = AreaCode;
#endif

//check valid GB range code first
#if defined(COMBO_IME)
    if(sImeL.dwRegImeIndex==INDEX_GB){
        if(LOBYTE(wCode) < 0xa1 || LOBYTE(wCode) > 0xfe 
        || HIBYTE(wCode) < 0xa1 || HIBYTE(wCode) > 0xfe)
            return FALSE;
       AbSeq[1] = ((wCode -0xa0) % 256) % 10;
       AbSeq[0] = ((wCode -0xa0) % 256) / 10;
       AreaCode = (wCode - 0xa0 -AbSeq[0] * 10 -AbSeq[1])/256;
       AbSeq[3] = ((AreaCode -0xa0) % 256) % 10;
       AbSeq[2] = ((AreaCode -0xa0) % 256) / 10; 
       AbSeq[4] = TEXT('\0';)
    }else if(sImeL.dwRegImeIndex==INDEX_GBK || sImeL.dwRegImeIndex==INDEX_UNICODE){
        WORD    tmp;
        tmp = HIBYTE(wCode) | (LOBYTE(wCode)<<8);
        wsprintf(AbSeq,TEXT("%04x"), tmp);
    }
    else
        return FALSE;

#else //COMBO_IME
#ifdef GB
        if(LOBYTE(wCode) < 0xa1 || LOBYTE(wCode) > 0xfe 
        || HIBYTE(wCode) < 0xa1 || HIBYTE(wCode) > 0xfe)
            return FALSE;
       AbSeq[1] = ((wCode -0xa0) % 256) % 10;
       AbSeq[0] = ((wCode -0xa0) % 256) / 10;
       AreaCode = (wCode - 0xa0 -AbSeq[0] * 10 -AbSeq[1])/256;
       AbSeq[3] = ((AreaCode -0xa0) % 256) % 10;
       AbSeq[2] = ((AreaCode -0xa0) % 256) / 10; 
       AbSeq[4] = TEXT('\0');
#else
       {
        WORD    tmp;
        tmp = HIBYTE(wCode) | (LOBYTE(wCode)<<8);
        wsprintf(AbSeq,TEXT("%04x"), tmp);
       }
#endif //GB
#endif //COMBO_IME
       return TRUE;
}
/***************************************************************************
BOOL AreaToGB ( BYTE    AbSeq[5],BYTE    GbSeq[5])
***************************************************************************/
BOOL AreaToGB (
        TCHAR    AbSeq[5],
        TCHAR    GbSeq[5])
{
        TCHAR    MbSeq[3]; // Temp string
        // Area turn
        wsprintf (MbSeq,TEXT("%lx"),(AbSeq[0] * 10 + AbSeq[1]+0xa0));
        GbSeq[0] = MbSeq[0];
        GbSeq[1] = MbSeq[1];
        //position turn
        wsprintf (MbSeq,TEXT("%lx"),(AbSeq[2] * 10 + AbSeq[3]+0xa0));
        GbSeq[2] = MbSeq[0];
        GbSeq[3] = MbSeq[1];
        GbSeq[4] = TEXT('\0');
        return TRUE;
}

#if defined(COMBO_IME)
/**********************************************************************/
/* UnicodeReverseConversion()                                                */
/**********************************************************************/
DWORD PASCAL UnicodeReverseConversion(
    WORD            wCode,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    UINT   MAX_COMP = 1;
    UINT   nMaxKey  = 4;
    TCHAR  AbSeq[5];
    UINT   uMaxCand;
    DWORD  dwSize =         // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));

    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    if (uMaxCand == 0) {
        // can not put one string
        return (0);
    }

    lpCandList->dwSize = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * uMaxCand +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    //lpCandList->dwPageSize = CANDPERPAGE; New Spac
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) ;

#ifndef UNICODE
    {
        WCHAR szWideStr[2];
        int i;

        memset(szWideStr, 0, sizeof(szWideStr));
        // change CP_ACP to 936, so that it can work under Multilingul Env.
        MultiByteToWideChar(NATIVE_ANSI_CP, 0, (LPCSTR)&wCode, sizeof(WORD), szWideStr, sizeof(szWideStr));

        wCode = HIBYTE((WORD)szWideStr[0]) | (LOBYTE((WORD)szWideStr[0]) << 8 );
    }
    if(!DBCSToGBCode (wCode, AbSeq))
        return 0;  //actual is DBCSToGBInternalCode
#endif

    wsprintf(AbSeq,TEXT("%04x"), wCode);
    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),AbSeq);
     

    // string count ++
    lpCandList->dwCount = 1;

    return (dwSize);
}
#endif //COMBO_IME

/**********************************************************************/
/* XGBReverseConversion()                                                */
/**********************************************************************/
DWORD PASCAL XGBReverseConversion(
    WORD            wCode,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    UINT   MAX_COMP = 1;
    UINT   nMaxKey  = 4;
    TCHAR    AbSeq[5];
    UINT   uMaxCand;
    DWORD  dwSize =         // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));

    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    if (uMaxCand == 0) {
        // can not put one string
        return (0);
    }

    lpCandList->dwSize = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * uMaxCand +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    //lpCandList->dwPageSize = CANDPERPAGE; New Spac
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) ;

    if(!DBCSToGBCode (wCode, AbSeq))
        return 0;  //actual is DBCSToGBInternalCode


    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),AbSeq);
     

    // string count ++
    lpCandList->dwCount = 1;

    return (dwSize);
}


/**********************************************************************/
/* ReverseConversion()                                                */
/**********************************************************************/
DWORD PASCAL ReverseConversion(
    WORD            wCode,
    LPCANDIDATELIST lpCandList,
    UINT            uBufLen)
{
    UINT   MAX_COMP = 2;
    UINT   nMaxKey  = 4;
    TCHAR  AbSeq[5];
    TCHAR  GbSeq[5];
    UINT   uMaxCand;
    DWORD  dwSize =         // similar to ClearCand
        // header length
        sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * MAX_COMP +
        // string plus NULL terminator
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));

    if (!uBufLen) {
        return (dwSize);
    }

    uMaxCand = uBufLen - sizeof(CANDIDATELIST);

    uMaxCand /= sizeof(DWORD) +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    if (uMaxCand == 0) {
        // can not put one string
        return (0);
    }

    lpCandList->dwSize = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * uMaxCand +
        (sizeof(TCHAR) * nMaxKey + sizeof(TCHAR));
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    //lpCandList->dwPageSize = CANDPERPAGE; New Spac
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) + sizeof(DWORD) ;

    if(!DBCSToGBCode (wCode, AbSeq))
        return 0;
    AreaToGB (AbSeq, GbSeq);
       AbSeq[1] +=TEXT('0');
       AbSeq[0] +=TEXT('0');
       AbSeq[3] +=TEXT('0');
       AbSeq[2] +=TEXT('0');

    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]),AbSeq);
    lpCandList->dwOffset[1] =
     lpCandList->dwOffset[0] + 4*sizeof(TCHAR) + sizeof(TCHAR);

    lstrcpy((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[1]),GbSeq);
     

    // string count ++
    lpCandList->dwCount = 2;

    return (dwSize);
}

/**********************************************************************/
/* ImeConversionList()                                                */
/**********************************************************************/
DWORD WINAPI ImeConversionList(
    HIMC            hIMC,
    LPCTSTR         lpszSrc,
    LPCANDIDATELIST lpCandList,
    DWORD           uBufLen,
    UINT            uFlag)
{
    WORD wCode;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;

    if (!uBufLen) {
    } else if (!lpszSrc) {
        return (0);
    } else if (!*lpszSrc) {
        return (0);
    } else if (!lpCandList) {
        return (0);
    } else if (uBufLen <= sizeof(CANDIDATELIST)) {
        // buffer size can not even put the header information
        return (0);
    } 

    switch (uFlag) {
    case GCL_CONVERSION:
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }
        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            ImmUnlockIMC(hIMC);
            return (FALSE);
        }
#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex==INDEX_GB)
            return (Conversion(lpszSrc, lpCandList, uBufLen));
        else if(sImeL.dwRegImeIndex==INDEX_GBK)
            return (XGBConversion(lpszSrc, lpCandList, uBufLen));
        else if(sImeL.dwRegImeIndex==INDEX_UNICODE)
            return (XGBConversion(lpszSrc, lpCandList, uBufLen));
#else //COMBO_IME
#ifdef GB
        return (Conversion(lpszSrc, lpCandList, uBufLen));

#else

        return (XGBConversion(lpszSrc, lpCandList, uBufLen));
#endif //GB
#endif //COMBO_IME
        break;
    case GCL_REVERSECONVERSION:
        if (!uBufLen) {
#if defined(COMBO_IME)
            return 1;
#else //COMBO_IME
#ifdef GB
            return 1;

#else
            return 1;

#endif //GB
#endif //COMBO_IME
        }

        // only support one DBCS char reverse conversion
        if (*(LPTSTR)((LPBYTE)lpszSrc + sizeof(WORD)) != TEXT('\0')) {
            return (0);
        }

        wCode = *(LPWORD)lpszSrc;

        // swap lead byte & second byte, UNICODE don't need it
        // wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);  For Big5

#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex==INDEX_GB)
            return (ReverseConversion(wCode, lpCandList, uBufLen));
        else if(sImeL.dwRegImeIndex==INDEX_GBK)
            return (XGBReverseConversion(wCode, lpCandList, uBufLen));
        else if(sImeL.dwRegImeIndex==INDEX_UNICODE)
            return (UnicodeReverseConversion(wCode, lpCandList, uBufLen));
#else //COMBO_IME
#ifdef GB
            return (ReverseConversion(wCode, lpCandList, uBufLen));

#else
            return (XGBReverseConversion(wCode, lpCandList, uBufLen));

#endif //GB
#endif //COMBO_IME

        break;
    default:
        return (0);
        break;
    }

    return (0);
}

/**********************************************************************/
/* ImeDestroy()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeDestroy(         // this dll is unloaded
    UINT uReserved)
{
    if (uReserved) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* ImeEscape()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
#define IME_INPUTKEYTOSEQUENCE  0x22

LRESULT WINAPI ImeEscape(       // escape function of IMEs
    HIMC   hIMC,
    UINT   uSubFunc,
    LPVOID lpData)
{
    LRESULT lRet;

    switch (uSubFunc) {
    case IME_ESC_QUERY_SUPPORT:

        if ( lpData == NULL )
           return FALSE;

        switch (*(LPUINT)lpData) {
        case IME_ESC_QUERY_SUPPORT:
        case IME_ESC_MAX_KEY:
        case IME_ESC_IME_NAME:
        case IME_ESC_GETHELPFILENAME:
            return (TRUE);
        case IME_ESC_SEQUENCE_TO_INTERNAL:
        case IME_ESC_GET_EUDC_DICTIONARY:
        case IME_ESC_SET_EUDC_DICTIONARY:
        case IME_INPUTKEYTOSEQUENCE:      // will not supported in next version
            return (FALSE);               // will not supported in GB IME
        default:
            return (FALSE);

        }
        break;
    case IME_ESC_SEQUENCE_TO_INTERNAL:
    case IME_ESC_GET_EUDC_DICTIONARY:
    case IME_ESC_SET_EUDC_DICTIONARY:
    case IME_INPUTKEYTOSEQUENCE:
        return (FALSE);
    case IME_ESC_MAX_KEY:
        return ((WORD) 4);
    case IME_ESC_IME_NAME:
        
        if ( lpData == NULL )
           return  FALSE;

        lstrcpy(lpData, szImeName);
        return (TRUE);

    case IME_ESC_GETHELPFILENAME:
        {
           TCHAR szIMEGUDHlpName[MAX_PATH];

           if (lpData == NULL )
              return FALSE;

           szIMEGUDHlpName[0] = 0;
           GetWindowsDirectory((LPTSTR)szIMEGUDHlpName, MAX_PATH);
           lstrcat((LPTSTR)szIMEGUDHlpName, TEXT("\\HELP\\WINGB.CHM"));

           lstrcpy(lpData, szIMEGUDHlpName);

           return TRUE;

        }

    default:
        return (FALSE);
    }

    return (lRet);
}

/**********************************************************************/
/* InitCompStr()                                                      */
/**********************************************************************/
void PASCAL InitCompStr(                // init setting for composing string
    LPCOMPOSITIONSTRING lpCompStr)
{
    if (!lpCompStr) {
        return;
    }

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadStrLen = 0;

    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompStrLen = 0;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    return;
}

/**********************************************************************/
/* ClearCompStr()                                                     */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCompStr(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC               hMem;
    LPCOMPOSITIONSTRING lpCompStr;
    DWORD               dwSize;

    if(!lpIMC) {
        return (FALSE);
    }

    dwSize =
        // header length
        sizeof(COMPOSITIONSTRING) +
        // composition reading attribute plus NULL terminator
        lpImeL->nMaxKey * sizeof(BYTE) + sizeof(BYTE) +
        // composition reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // composition reading string plus NULL terminator
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result reading clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result reading string plus NULL terminateor
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD) +
        // result clause
        sizeof(DWORD) + sizeof(DWORD) +
        // result string plus NULL terminateor
        MAXSTRLEN * sizeof(WORD) + sizeof(WORD);

    if (!lpIMC->hCompStr) {
        // it maybe free by other IME, init it
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCompStr, dwSize)) {
        lpIMC->hCompStr = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmDestroyIMCC(lpIMC->hCompStr);
        lpIMC->hCompStr = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    lpCompStr->dwSize = dwSize;

     // 1. composition (reading) string - simple IME
     // 2. result reading string
     // 3. result string

    lpCompStr->dwCompReadAttrLen = 0;
    lpCompStr->dwCompReadAttrOffset = sizeof(COMPOSITIONSTRING);
    lpCompStr->dwCompReadClauseLen = 0;
    lpCompStr->dwCompReadClauseOffset = lpCompStr->dwCompReadAttrOffset +
        lpImeL->nMaxKey * sizeof(TCHAR) + sizeof(TCHAR);
    lpCompStr->dwCompReadStrLen = 0;
    lpCompStr->dwCompReadStrOffset = lpCompStr->dwCompReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    // composition string is the same with composition reading string 
    // for simple IMEs
    lpCompStr->dwCompAttrLen = 0;
    lpCompStr->dwCompAttrOffset = lpCompStr->dwCompReadAttrOffset;
    lpCompStr->dwCompClauseLen = 0;
    lpCompStr->dwCompClauseOffset = lpCompStr->dwCompReadClauseOffset;
    lpCompStr->dwCompStrLen = 0;
    lpCompStr->dwCompStrOffset = lpCompStr->dwCompReadStrOffset;

    lpCompStr->dwCursorPos = 0;
    lpCompStr->dwDeltaStart = 0;

    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadClauseOffset = lpCompStr->dwCompStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultReadStrOffset = lpCompStr->dwResultReadClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultClauseOffset = lpCompStr->dwResultReadStrOffset +
        lpImeL->nMaxKey * sizeof(WORD) + sizeof(WORD);
    lpCompStr->dwResultStrOffset = 0;
    lpCompStr->dwResultStrOffset = lpCompStr->dwResultClauseOffset +
        sizeof(DWORD) + sizeof(DWORD);

    GlobalUnlock((HGLOBAL)lpIMC->hCompStr);
    return (TRUE);
}

/**********************************************************************/
/* ClearCand()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearCand(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC           hMem;
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    DWORD           dwSize =
        // header length
        sizeof(CANDIDATEINFO) + sizeof(CANDIDATELIST) +
        // candidate string pointers
        sizeof(DWORD) * (MAXCAND + 1) +
        // string plus NULL terminator
        (sizeof(WORD) + sizeof(WORD)) * (MAXCAND + 1);

    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        // it maybe free by other IME, init it
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hCandInfo, dwSize)) {
        lpIMC->hCandInfo = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    if (!lpIMC->hCandInfo) {
        return (FALSE);
    } 

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        ImmDestroyIMCC(lpIMC->hCandInfo);
        lpIMC->hCandInfo = ImmCreateIMCC(dwSize);
        return (FALSE);
    }

    // ordering of strings are
    // buffer size
    lpCandInfo->dwSize = dwSize;
    lpCandInfo->dwCount = 0;
    lpCandInfo->dwOffset[0] = sizeof(CANDIDATEINFO);
    lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
        lpCandInfo->dwOffset[0]);
    // whole candidate info size - header
    lpCandList->dwSize = lpCandInfo->dwSize - sizeof(CANDIDATEINFO);
    lpCandList->dwStyle = IME_CAND_READ;
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;
    lpCandList->dwPageSize = CANDPERPAGE;
    lpCandList->dwOffset[0] = sizeof(CANDIDATELIST) +
        sizeof(DWORD) * (MAXCAND );

    ImmUnlockIMCC(lpIMC->hCandInfo);
    return (TRUE);
}

/**********************************************************************/
/* ClearGuideLine()                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL ClearGuideLine(
    LPINPUTCONTEXT lpIMC)
{
    HIMCC       hMem;
    LPGUIDELINE lpGuideLine;
    DWORD       dwSize = sizeof(GUIDELINE) + sImeG.cbStatusErr;

    if (!lpIMC->hGuideLine) {
        // it maybe free by IME
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    } else if (hMem = ImmReSizeIMCC(lpIMC->hGuideLine, dwSize)) {
        lpIMC->hGuideLine = hMem;
    } else {
        ImmDestroyIMCC(lpIMC->hGuideLine);
        lpIMC->hGuideLine = ImmCreateIMCC(dwSize);
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {
        return (FALSE);
    }

    lpGuideLine->dwSize = dwSize;
    lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
    lpGuideLine->dwIndex = GL_ID_UNKNOWN;
    lpGuideLine->dwStrLen = 0;
    lpGuideLine->dwStrOffset = sizeof(GUIDELINE);

    CopyMemory((LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset,
        sImeG.szStatusErr, sImeG.cbStatusErr);

    ImmUnlockIMCC(lpIMC->hGuideLine);

    return (TRUE);
}

/**********************************************************************/
/* InitContext()                                                      */
/**********************************************************************/
void PASCAL InitContext(
    LPINPUTCONTEXT lpIMC)
{
    if (lpIMC->fdwInit & INIT_STATUSWNDPOS) {
    } else if (!lpIMC->hWnd) {
    } else {

#ifdef MUL_MONITOR
        RECT rcWorkArea;

        rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

        lpIMC->ptStatusWndPos.x = rcWorkArea.left;

        lpIMC->ptStatusWndPos.y = rcWorkArea.bottom -
            sImeG.yStatusHi;
#else
        POINT ptWnd;

        ptWnd.x = 0;
        ptWnd.y = 0;
        ClientToScreen(lpIMC->hWnd, &ptWnd);

        if (ptWnd.x < sImeG.rcWorkArea.left) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.left;
        } else if (ptWnd.x + sImeG.xStatusWi > sImeG.rcWorkArea.right) {
            lpIMC->ptStatusWndPos.x = sImeG.rcWorkArea.right -
                sImeG.xStatusWi;
        } else {
            lpIMC->ptStatusWndPos.x = ptWnd.x;
        }

        lpIMC->ptStatusWndPos.y = sImeG.rcWorkArea.bottom -
            sImeG.yStatusHi;
#endif

        lpIMC->fdwInit |= INIT_STATUSWNDPOS;
    }

    if (lpIMC->fdwInit & INIT_COMPFORM) {
    } else if (!lpIMC->hWnd) {
    } else {
        POINT ptWnd;

        ptWnd = lpImeL->ptDefComp;
        ScreenToClient(lpIMC->hWnd, &ptWnd);
        lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
        lpIMC->cfCompForm.ptCurrentPos = ptWnd;
        lpIMC->fdwInit |= INIT_COMPFORM;
    }

    return;
}

/**********************************************************************/
/* Select()                                                           */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL Select(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    BOOL           fSelect)
{
    LPPRIVCONTEXT  lpImcP;
    UINT           i;

    if (fSelect) {

        if (!ClearCompStr(lpIMC))
            return FALSE;

        if (!ClearCand(lpIMC))
            return FALSE;

        ClearGuideLine(lpIMC);
    }

    if (lpIMC->cfCandForm[0].dwIndex != 0)
        lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;

    // We add this hack for switching from other IMEs, this IME has a bug.
    // Before this bug fixed in this IME, it depends on this hack.
    if (lpIMC->cfCandForm[0].dwStyle == CFS_DEFAULT) {
        lpIMC->cfCandForm[0].dwIndex = (DWORD)-1;
    }

    if (!lpIMC->hPrivate)
        return FALSE;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP)
        return FALSE;

    if (fSelect) {
        //
        // init fields of hPrivate
        //
        lpImcP->iImeState  = CST_INIT;
        lpImcP->fdwImeMsg  = (DWORD)0;
        lpImcP->dwCompChar = (DWORD)0;
        lpImcP->fdwGcsFlag = (DWORD)0;

        lpImcP->uSYHFlg    = (UINT)0;
        lpImcP->uDYHFlg    = (UINT)0;
        lpImcP->uDSMHCount = (UINT)0;
        lpImcP->uDSMHFlg   = (UINT)0;

        //lpImcP->fdwSentence = (DWORD)NULL;

        //
        // reset SK State
        //

        *(LPDWORD)lpImcP->bSeq = 0;

#ifdef CROSSREF
        lpImcP->hRevCandList   = (HIMCC) NULL;
#endif //CROSSREF
        
        lpIMC->fOpen = TRUE;

        if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
            lpIMC->fdwConversion = (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) |
                IME_CMODE_NATIVE;
            lpIMC->fdwInit |= INIT_CONVERSION;
        }

        if (lpIMC->fdwInit & INIT_SENTENCE) {
        } else if (lpImeL->fModeConfig & MODE_CONFIG_PREDICT) {
            lpIMC->fdwSentence = IME_SMODE_PHRASEPREDICT;
            lpIMC->fdwInit |= INIT_SENTENCE;
        } 

        if (!(lpIMC->fdwInit & INIT_LOGFONT)) {
            HDC hDC;
            HGDIOBJ hSysFont;

            //hSysFont = GetStockObject(SYSTEM_FONT);
            hDC = GetDC(NULL);
            hSysFont = GetCurrentObject(hDC, OBJ_FONT);
            GetObject(hSysFont, sizeof(LOGFONT), &lpIMC->lfFont.A);
            ReleaseDC(NULL, hDC);

            lpIMC->fdwInit |= INIT_LOGFONT;
        }

        InitContext(lpIMC);

        //
        // Set Caps status
        //
        {
            DWORD fdwConversion;
        
            if (GetKeyState(VK_CAPITAL) & 0x01) {

                //
                // Change to alphanumeric mode.
                //
               fdwConversion = lpIMC->fdwConversion &
                        ~(IME_CMODE_NATIVE | IME_CMODE_CHARCODE | IME_CMODE_EUDC);
            } else {

                //
                // Change to native mode
                //
                fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC );
            }

            ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        }

    } else {

        if (lpImeL->hSKMenu) {
            DestroyMenu(lpImeL->hSKMenu);
            lpImeL->hSKMenu = NULL;
        }

        if (lpImeL->hPropMenu) {
            DestroyMenu(lpImeL->hPropMenu);
            lpImeL->hPropMenu = NULL;
        }

        if (hCrtDlg) {
            SendMessage(hCrtDlg, WM_CLOSE, (WPARAM)NULL, (LPARAM)NULL);
            hCrtDlg = NULL;
        }
    }

    ImmUnlockIMCC(lpIMC->hPrivate);

    return (TRUE);
}

/**********************************************************************/
/* ImeSelect()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSelect(
    HIMC hIMC,
    BOOL fSelect)
{
    LPINPUTCONTEXT lpIMC;
    BOOL           fRet;


    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    fRet = Select(hIMC, lpIMC, fSelect);

    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ImeSetActiveContext()                                              */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetActiveContext(
    HIMC   hIMC,
    BOOL   fOn)
{
    if (!fOn) {
    } else if (!hIMC) {
    } else {
        LPINPUTCONTEXT lpIMC;

        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        InitContext(lpIMC);

        ImmUnlockIMC(hIMC);
    }

    return (TRUE);
}

/**********************************************************************/
//OpenReg_PathSetup(HKEY *phKey);
/**********************************************************************/
LONG OpenReg_PathSetup(HKEY *phKey)
{
    return RegOpenKeyEx (HKEY_CURRENT_USER,
                         REGSTR_PATH_SETUP,
                         0,
                         KEY_ENUMERATE_SUB_KEYS |
                         KEY_EXECUTE |
                         KEY_QUERY_VALUE,
                         phKey);
}
/**********************************************************************/
//LONG OpenReg_User(HKEY hKey,        // handle of open key 
//                LPCTSTR  lpszSubKey,    // address of name of subkey to open 
//                PHKEY  phkResult);     // address of handle of open key 
/**********************************************************************/
LONG OpenReg_User(HKEY hKey,        // handle of open key 
LPCTSTR  lpszSubKey,    // address of name of subkey to open 
PHKEY  phkResult)     // address of handle of open key 
{
    return RegOpenKeyEx (hKey,
                         lpszSubKey,
                         0,
                         KEY_ALL_ACCESS, 
                         phkResult);
}

VOID InfoMessage(HANDLE hWnd,WORD wMsgID)
{
   TCHAR   szStr[256];

   LoadString(NULL,wMsgID,szStr, sizeof(szStr)/sizeof(TCHAR));
   MessageBox(hWnd,szStr,szWarnTitle,MB_ICONINFORMATION|MB_OK);
}

VOID FatalMessage(HANDLE hWnd,WORD wMsgID)
{
    TCHAR   szStr[256];

    LoadString(NULL,wMsgID,szStr, sizeof(szStr)/sizeof(TCHAR));
    MessageBox(hWnd,szStr,szErrorTitle,MB_ICONSTOP|MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\imedefs.h ===
/*************************************************
 *  imedefs.h                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#define NATIVE_CHARSET          GB2312_CHARSET
#define NATIVE_ANSI_CP          936
#define NATIVE_LANGUAGE         0x0804
// resource ID
#define IDI_IME                 0x0100

#define IDS_STATUSERR           0x0200
#define IDS_CHICHAR             0x0201

#define IDS_EUDC                0x0202
#if defined(CROSSREF)
#define IDS_NONE                0x0204
#endif //CROSSREF

#define IDS_USRDIC_FILTER       0x0210

#define IDS_FILE_OPEN_ERR       0x0220
#define IDS_MEM_LESS_ERR        0x0221

#define IDS_SETFILE             0x0300
#define IDS_IMENAME             0x0320
#define IDS_IMEUICLASS          0x0321
#define IDS_IMECOMPCLASS        0x0322
#define IDS_IMECANDCLASS        0x0323
#define IDS_IMESTATUSCLASS      0x0324
#define IDS_IMECMENUCLASS       0x0325
#define IDS_IMESOFTKEYMENUCLASS 0x0326
#define IDS_IMEREGNAME          0x0327
#define IDS_IMENAME_QW          0x0328
#define IDS_IMENAME_NM          0x0329
#define IDS_IMENAME_UNI         0x0330

#define IDS_WARN_OPENREG        0x0602


#define IDC_STATIC              -1

#define IDM_HLP                 0x0400
#define IDM_OPTGUD              0x0403
#define IDM_IMEGUD              0x0405
#define IDM_VER                 0x0401
#define IDM_PROP                0x0402

#define IDM_IME                 0x0450

#define IDM_SKL1                0x0500
#define IDM_SKL2                0x0501
#define IDM_SKL3                0x0502
#define IDM_SKL4                0x0503
#define IDM_SKL5                0x0504
#define IDM_SKL6                0x0505
#define IDM_SKL7                0x0506
#define IDM_SKL8                0x0507
#define IDM_SKL9                0x0508
#define IDM_SKL10               0x0509
#define IDM_SKL11               0x050a
#define IDM_SKL12               0x050b
#define IDM_SKL13               0x050c

#define DlgPROP                 101
#define DlgUIMODE               102
#define IDC_UIMODE1             1001
#define IDC_UIMODE2             1002
#define IDC_USER1               1003

// setting offset in .SET file
#define OFFSET_MODE_CONFIG      0
#define OFFSET_READLAYOUT       4

// state of composition
#define CST_INIT                0
#define CST_INPUT               1
#define CST_CHOOSE              2
#define CST_SYMBOL              3
#define CST_SOFTKB              4           // not in iImeState
#define CST_TOGGLE_PHRASEWORD   5           // not in iImeState
#define CST_ALPHABET            6           // not in iImeState
#define CST_ALPHANUMERIC        7           // not in iImeState
#define CST_INVALID             8           // not in iImeState
#define CST_INVALID_INPUT       9           // not in iImeState
#define CST_ONLINE_CZ           10
#define CST_CAPITAL             11

// state engin
#define ENGINE_COMP             0
#define ENGINE_ASCII            1
#define ENGINE_RESAULT          2
#define ENGINE_CHCAND           3
#define ENGINE_BKSPC            4
#define ENGINE_MULTISEL         5
#define ENGINE_ESC              6

#define CANDPERPAGE             9

#define MAXSTRLEN               40
#define MAXCAND                 256
#define IME_MAXCAND             94
#define IME_XGB_MAXCAND         190
#if defined(COMBO_IME)
#define IME_UNICODE_MAXCAND     256
#endif //COMBO_IME
#define MAXCODE                 12
#define MAXSOFTKEYS             48

// set ime character
#define SIC_INIT                0
#define SIC_SAVE2               1
#define SIC_READY               2
#define SIC_MODIFY              3
#define SIC_SAVE1               4

#define BOX_UI                  0
#define LIN_UI                  1

#if defined(COMBO_IME)

#define IMEINDEXNUM             3

#define IME_CMODE_INDEX_FIRST   0x1000

#define INDEX_GB                0
#define INDEX_GBK               1
#define INDEX_UNICODE           2

#endif

// border for UI
#define UI_MARGIN               4
#define COMP_TEXT_Y             17

#define UI_CANDINF              20
#define UI_CANDBTW              13
#define UI_CANDBTH              13
#define UI_CANDICON             16
#define UI_CANDSTR              300

#define STATUS_DIM_X            20
#define STATUS_DIM_Y            20
#define STATUS_NAME_MARGIN      20

// if UI_MOVE_OFFSET == WINDOW_NOTDRAG, not in drag operation
#define WINDOW_NOT_DRAG         0xFFFFFFFF

// window extra for composition window
#define UI_MOVE_OFFSET          0
#define UI_MOVE_XY              4

// the start number of candidate list
#define CAND_START              1
#define uCandHome               0
#define uCandUp                 1
#define uCandDown               2
#define uCandEnd                3
#define CandGBinfoLen           64
// the flag for an opened or start UI
#define IMN_PRIVATE_UPDATE_STATUS             0x0001
#define IMN_PRIVATE_COMPOSITION_SIZE          0x0002
#define IMN_PRIVATE_UPDATE_QUICK_KEY          0x0004
#define IMN_PRIVATE_UPDATE_SOFTKBD            0x0005
#define IMN_PRIVATE_DESTROYCANDWIN            0x0006
#define IMN_PRIVATE_CMENUDESTROYED            0x0007
#define IMN_PRIVATE_SOFTKEYMENUDESTROYED      0x0008

#define MSG_ALREADY_OPEN                0x000001
#define MSG_ALREADY_OPEN2               0x000002
#define MSG_OPEN_CANDIDATE              0x000010
#define MSG_OPEN_CANDIDATE2             0x000020
#define MSG_CLOSE_CANDIDATE             0x000100
#define MSG_CLOSE_CANDIDATE2            0x000200
#define MSG_CHANGE_CANDIDATE            0x001000
#define MSG_CHANGE_CANDIDATE2           0x002000
#define MSG_ALREADY_START               0x010000
#define MSG_START_COMPOSITION           0x020000
#define MSG_END_COMPOSITION             0x040000
#define MSG_COMPOSITION                 0x080000
#define MSG_IMN_COMPOSITIONPOS          0x100000
#define MSG_IMN_UPDATE_SOFTKBD          0x200000
#define MSG_IMN_UPDATE_STATUS           0x000400
#define MSG_GUIDELINE                   0x400000
#define MSG_IN_IMETOASCIIEX             0x800000
#define MSG_IMN_DESTROYCAND             0x004000
#define MSG_BACKSPACE                   0x000800
// this constant is depend on TranslateImeMessage
#define GEN_MSG_MAX             6

// the flag for set context
#define SC_SHOW_UI              0x0001
#define SC_HIDE_UI              0x0002
#define SC_ALREADY_SHOW_STATUS  0x0004
#define SC_WANT_SHOW_STATUS     0x0008
#define SC_HIDE_STATUS          0x0010

// the new flag for set context
#define ISC_SHOW_SOFTKBD        0x02000000
#define ISC_OPEN_STATUS_WINDOW  0x04000000
#define ISC_OFF_CARET_UI        0x08000000
#define ISC_SHOW_UI_ALL         (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD|ISC_OPEN_STATUS_WINDOW)
#define ISC_SETCONTEXT_UI       (ISC_SHOWUIALL|ISC_SHOW_SOFTKBD)

#define ISC_HIDE_COMP_WINDOW            0x00400000
#define ISC_HIDE_CAND_WINDOW            0x00800000
#define ISC_HIDE_SOFTKBD                0x01000000
// the flag for composition string show status
#define IME_STR_SHOWED          0x0001
#define IME_STR_ERROR           0x0002

// the mode configuration for an IME
#define MODE_CONFIG_QUICK_KEY           0x0001
#define MODE_CONFIG_WORD_PREDICT        0x0002
#define MODE_CONFIG_PREDICT             0x0004

// the virtual key value
#define VK_OEM_SEMICLN                  0xba    //  ;    :
#define VK_OEM_EQUAL                    0xbb    //  =    +
#define VK_OEM_SLASH                    0xbf    //  /    ?
#define VK_OEM_LBRACKET                 0xdb    //  [    {
#define VK_OEM_BSLASH                   0xdc    //  \    |
#define VK_OEM_RBRACKET                 0xdd    //  ]    }
#define VK_OEM_QUOTE                    0xde    //  '    "

#define MAXMBNUMS                       40

// for ime property info
#define MAXNUMCODES                     48

#define LINE_LEN                80
#define CLASS_LEN               24

#define NumsSK                  13

// mb file for create word
#define ID_LENGTH 28
#define NUMTABLES 7
#define TAG_DESCRIPTION           0x00000001
#define TAG_RULER                 0x00000002
#define TAG_CRTWORDCODE           0x00000004

// window extra for context menu owner
#define CMENU_HUIWND            0
#define CMENU_MENU              4
#define SOFTKEYMENU_HUIWND      0
#define SOFTKEYMENU_MENU        4

#define WM_USER_DESTROY         (WM_USER + 0x0400)

// the flags for GetNearCaretPosition
#define NEAR_CARET_FIRST_TIME   0x0001
#define NEAR_CARET_CANDIDATE    0x0002

typedef DWORD UNALIGNED FAR *LPUNADWORD;
typedef WORD  UNALIGNED FAR *LPUNAWORD;

typedef struct tagImeL {        // local structure, per IME structure
    DWORD       dwSKState[NumsSK];
    DWORD       dwSKWant;
    HMENU       hSKMenu;        // SoftKeyboard Menu
    HMENU       hPropMenu;      // Property Menu
    HINSTANCE   hInst;          // IME DLL instance handle
    int         xCompWi;        // width
    int         yCompHi;        // height
    POINT       ptDefComp;      // default composition window position
    int         cxCompBorder;   // border width of composition window
    int         cyCompBorder;   // border height of composition window
    RECT        rcCompText;     // text position relative to composition
                                // window key related data
    WORD        fModeConfig;    // quick key/prediction mode
    WORD        nMaxKey;        // max key of compsiton str
#if defined(COMBO_IME)
    DWORD           dwRegImeIndex;  // this value defers in different
                                    // process, so can not set in sImeG
#endif
   BOOL         fWinLogon;
} IMEL;

typedef IMEL      *PIMEL;
typedef IMEL NEAR *NPIMEL;
typedef IMEL FAR  *LPIMEL;

#define NFULLABC        95
typedef struct _tagFullABC {   // match with the IMEG
    WORD wFullABC[NFULLABC];
} FULLABC;

typedef FULLABC      *PFULLABC;
typedef FULLABC NEAR *NPFULLABC;
typedef FULLABC FAR  *LPFULLABC;

// global sturcture for ime init data
typedef struct _tagImeG {       // global structure, can be share by all IMEs,
                                // the seperation (IMEL and IMEG) is only
                                // useful in UNI-IME, other IME can use one
// the system charset is not NATIVE_CHARSET
    BOOL        fDiffSysCharSet;
// IME Charact
    TCHAR       UsedCodes[17];
    WORD        wNumCodes;
    DWORD       IC_Enter;
    DWORD       IC_Trace;

    RECT        rcWorkArea;     // the work area of applications
// Chinese char width & height
    int         xChiCharWi;
    int         yChiCharHi;
// candidate list of composition
    int         xCandWi;        // width of candidate list
    int         yCandHi;        // high of candidate list
    int         cxCandBorder;   // border width of candidate list
    int         cyCandBorder;   // border height of candidate list
    RECT        rcCandText;     // text position relative to candidate window
    RECT        rcCandBTD;
    RECT        rcCandBTU;
    RECT        rcCandBTE;
    RECT        rcCandBTH;
    RECT        rcCandInf;
    RECT        rcCandIcon;
// status window
    int         xStatusWi;      // width of status window
    int         yStatusHi;      // high of status window
    RECT        rcStatusText;   // text position relative to status window
    RECT        rcImeIcon;      // ImeIcon position relative to status window
    RECT        rcImeName;      // ImeName position relative to status window
    RECT        rcShapeText;    // shape text relative to status window
    RECT        rcSymbol;       // symbol relative to status window
    RECT        rcSKText;       // SK text relative to status window
// full shape space (reversed internal code)
    WORD        wFullSpace;
// full shape chars (internal code)
    WORD        wFullABC[NFULLABC];
// error string
    TCHAR        szStatusErr[8];
    int         cbStatusErr;
// candidate string start from 0 or 1
    int         iCandStart;
// setting of UI
    int         iPara;
    int         iPerp;
    int         iParaTol;
    int         iPerpTol;
#if defined(CROSSREF)
// reverse conversion
    HKL         hRevKL;         // the HKL of reverse mapping IME
    DWORD        nRevMaxKey;
#endif //CROSSREF
} IMEG;

typedef IMEG      *PIMEG;
typedef IMEG NEAR *NPIMEG;
typedef IMEG FAR  *LPIMEG;


#define IME_SELECT_GB     0x0001
#define IME_SELECT_XGB    0x0002
#define IME_SELECT_AREA   0x0004

typedef struct _tagPRIVCONTEXT {// IME private data for each context
    int         iImeState;      // the composition state - input, choose, or
    BOOL        fdwImeMsg;      // what messages should be generated
    DWORD       dwCompChar;     // wParam of WM_IME_COMPOSITION
    DWORD       fdwGcsFlag;     // lParam for WM_IME_COMPOSITION
    UINT        uSYHFlg;
    UINT        uDYHFlg;
    UINT        uDSMHCount;
    UINT        uDSMHFlg;
// input data
    TCHAR       bSeq[13];        // sequence code of input char
    DWORD       fdwGB;
#ifdef CROSSREF
    HIMCC           hRevCandList;   // memory for reconsion result
#endif //CROSSREF
} PRIVCONTEXT;

typedef PRIVCONTEXT      *PPRIVCONTEXT;
typedef PRIVCONTEXT NEAR *NPPRIVCONTEXT;
typedef PRIVCONTEXT FAR  *LPPRIVCONTEXT;

typedef struct _tagUIPRIV {     // IME private UI data
    HWND    hCompWnd;           // composition window
    int     nShowCompCmd;
    HWND    hCandWnd;           // candidate window for composition
    int     nShowCandCmd;
    HWND    hSoftKbdWnd;        // soft keyboard window
    int     nShowSoftKbdCmd;
    HWND    hStatusWnd;         // status window
    int     nShowStatusCmd;
    DWORD   fdwSetContext;      // the actions to take at set context time
    HIMC    hIMC;               // the recent selected hIMC
    HWND    hCMenuWnd;          // a window owner for context menu
    HWND    hSoftkeyMenuWnd;    // a window owner for softkeyboard menu
} UIPRIV;

typedef UIPRIV      *PUIPRIV;
typedef UIPRIV NEAR *NPUIPRIV;
typedef UIPRIV FAR  *LPUIPRIV;


typedef struct tagNEARCARET {   // for near caret offset calculatation
    int iLogFontFacX;
    int iLogFontFacY;
    int iParaFacX;
    int iPerpFacX;
    int iParaFacY;
    int iPerpFacY;
} NEARCARET;

typedef NEARCARET      *PNEARCARET;
typedef NEARCARET NEAR *NPNEARCARET;
typedef NEARCARET FAR  *LPNEARCARET;

extern HINSTANCE hInst;
extern IMEG      sImeG;
extern IMEL      sImeL;
extern LPIMEL    lpImeL;
extern HDC       ST_UI_hDC;
extern UINT      uStartComp;
extern UINT      uOpenCand;
extern UINT      uCaps;
extern DWORD     SaTC_Trace;
extern TCHAR     szUIClassName[];
extern TCHAR     szCompClassName[];
extern TCHAR     szCandClassName[];
extern TCHAR     szStatusClassName[];
extern TCHAR     szCMenuClassName[];
extern TCHAR     szSoftkeyMenuClassName[];
extern TCHAR     szHandCursor[];
extern TCHAR     szChinese[];
extern TCHAR     szCandInf[];
#if defined(COMBO_IME)
extern TCHAR    pszImeName[IMEINDEXNUM][MAX_PATH];
extern TCHAR    *szImeName;
extern TCHAR    szImeRegName[];
#else
extern TCHAR      szImeName[];
#endif //COMBO_IME
extern TCHAR      szImeXGBName[];
extern TCHAR      szSymbol[];
extern TCHAR      szNoSymbol[];
extern TCHAR      szEnglish[];
extern TCHAR      szCode[];
extern TCHAR      szEudc[];
extern TCHAR      szFullShape[];
extern TCHAR      szHalfShape[];
extern TCHAR      szNone[];
extern TCHAR      szSoftKBD[];
extern TCHAR      szNoSoftKBD[];
extern TCHAR      szDigit[];
extern BYTE      bUpper[];
extern WORD      fMask[];
extern TCHAR      szRegIMESetting[];
extern TCHAR      szPerp[];
extern TCHAR      szPara[];
extern TCHAR      szPerpTol[];
extern TCHAR      szParaTol[];
#if defined(COMBO_IME)
extern TCHAR      szRegImeIndex[];
#endif
extern const NEARCARET ncUIEsc[], ncAltUIEsc[];
extern const POINT ptInputEsc[], ptAltInputEsc[];
extern BYTE      VirtKey48Map[];
extern TCHAR     szTrace[];
extern TCHAR     szWarnTitle[];
extern TCHAR     szErrorTitle[];
#if defined(CROSSREF)
extern TCHAR szRegRevKL[];
extern TCHAR szRegRevMaxKey[];
#endif

int WINAPI LibMain(HANDLE, WORD, WORD, LPTSTR);         // init.c
LRESULT CALLBACK UIWndProc(HWND, UINT, WPARAM, LPARAM); // ui.c
LRESULT PASCAL UIPaint(HWND);                           // ui.c

// for engine
WORD PASCAL GBEngine(LPPRIVCONTEXT);
WORD PASCAL AsciiToGB(LPPRIVCONTEXT);
WORD PASCAL AsciiToArea(LPPRIVCONTEXT);
WORD PASCAL CharToHex(TCHAR);

void PASCAL AddCodeIntoCand(LPCANDIDATELIST, WORD);             // compose.c
void PASCAL CompWord(WORD, LPINPUTCONTEXT, LPCOMPOSITIONSTRING, LPPRIVCONTEXT,
     LPGUIDELINE);                                              // compose.c
UINT PASCAL Finalize(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, WORD);                                      // compose.c
void PASCAL CompEscapeKey(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPGUIDELINE, LPPRIVCONTEXT);                               // compose.c

void PASCAL SelectOneCand(LPINPUTCONTEXT, LPCOMPOSITIONSTRING,
     LPPRIVCONTEXT, LPCANDIDATELIST);                           // chcand.c
void PASCAL CandEscapeKey(LPINPUTCONTEXT, LPPRIVCONTEXT);       // chcand.c
void PASCAL ChooseCand(WORD, LPINPUTCONTEXT, LPCANDIDATEINFO,
     LPPRIVCONTEXT);                                            // chcand.c

void PASCAL SetPrivateFileSetting(LPBYTE, int, DWORD, LPCTSTR); // ddis.c

void PASCAL InitCompStr(LPCOMPOSITIONSTRING);                   // ddis.c
BOOL PASCAL ClearCand(LPINPUTCONTEXT);                          // ddis.c
LONG OpenReg_PathSetup(HKEY *);
LONG OpenReg_User(HKEY ,LPCTSTR ,PHKEY);
VOID InfoMessage(HANDLE ,WORD );                                 //ddis.c
VOID FatalMessage(HANDLE ,WORD);                                 //ddis.c
#if defined(CROSSREF)
void PASCAL ReverseConversionList(HWND);                         // ddis.c
void CrossReverseConv(LPINPUTCONTEXT, LPCOMPOSITIONSTRING, LPPRIVCONTEXT, LPCANDIDATELIST);
#endif

UINT PASCAL TranslateImeMessage(LPTRANSMSGLIST, LPINPUTCONTEXT, LPPRIVCONTEXT);        // toascii.c

void PASCAL GenerateMessage(HIMC, LPINPUTCONTEXT,LPPRIVCONTEXT);  // notify.c

DWORD PASCAL ReadingToPattern(LPCTSTR, BOOL);                   // regword.c
void  PASCAL ReadingToSequence(LPCTSTR, LPBYTE, BOOL);          // regword.c

void PASCAL DrawDragBorder(HWND, LONG, LONG);                   // uisubs.c
void PASCAL DrawFrameBorder(HDC, HWND);                         // uisubs.c

void PASCAL ContextMenu(HWND, int, int);                        // uisubs.c
void PASCAL SoftkeyMenu(HWND, int, int);                        // uisubs.c
LRESULT CALLBACK ContextMenuWndProc(HWND, UINT, WPARAM,LPARAM); // uisubs.c
LRESULT CALLBACK SoftkeyMenuWndProc(HWND, UINT, WPARAM,LPARAM); // uisubs.c

HWND    PASCAL GetCompWnd(HWND);                                // compui.c
void    PASCAL SetCompPosition(HWND, HIMC, LPINPUTCONTEXT);     // compui.c
void    PASCAL SetCompWindow(HWND);                             // compui.c
void    PASCAL MoveDefaultCompPosition(HWND);                   // compui.c
void    PASCAL ShowComp(HWND, int);                             // compui.c
void    PASCAL StartComp(HWND);                                 // compui.c
void    PASCAL EndComp(HWND);                                   // compui.c
void    PASCAL UpdateCompWindow(HWND);                          // compui.c
LRESULT CALLBACK CompWndProc(HWND, UINT, WPARAM, LPARAM);       // compui.c
void    PASCAL CompCancel(HIMC, LPINPUTCONTEXT);

HWND    PASCAL GetCandWnd(HWND);                                // candui.c
void    PASCAL CalcCandPos(HIMC, HWND, LPPOINT);                            // candui.c
LRESULT PASCAL SetCandPosition(HWND);                           // candui.c
void    PASCAL ShowCand(HWND, int);                             // candui.c
void    PASCAL OpenCand(HWND);                                  // candui.c
void    PASCAL CloseCand(HWND);                                 // candui.c
void    PASCAL PaintCandWindow(HWND, HDC);                      // candui.c
LRESULT CALLBACK CandWndProc(HWND, UINT, WPARAM, LPARAM);       // candui.c
void    PASCAL UpdateSoftKbd(HWND);

HWND    PASCAL GetStatusWnd(HWND);                              // statusui.c
LRESULT PASCAL SetStatusWindowPos(HWND);                        // statusui.c
void    PASCAL ShowStatus(HWND, int);                           // statusui.c
void    PASCAL OpenStatus(HWND);                                // statusui.c
LRESULT CALLBACK StatusWndProc(HWND, UINT, WPARAM, LPARAM);     // statusui.c
void DrawConvexRect(HDC, int, int, int, int);
void DrawConvexRectP(HDC, int, int, int, int);
void DrawConcaveRect(HDC, int, int, int, int);
BOOL IsUsedCode(WORD);
void PASCAL InitStatusUIData(int, int);
void PASCAL InitCandUIData(int, int, int);
BOOL UpdateStatusWindow(HWND);
void PASCAL EngChCand(LPCOMPOSITIONSTRING, LPCANDIDATELIST, LPPRIVCONTEXT, LPINPUTCONTEXT, WORD);
void PASCAL CandPageDownUP(HWND, UINT);
void PASCAL GenerateImeMessage(HIMC, LPINPUTCONTEXT, DWORD);
UINT PASCAL TranslateSymbolChar(LPTRANSMSGLIST, WORD, BOOL);
UINT PASCAL TranslateFullChar(LPTRANSMSGLIST, WORD);
UINT PASCAL ConvListProcessKey(BYTE,LPPRIVCONTEXT);     //ddis.c
UINT PASCAL GBProcessKey(WORD, LPPRIVCONTEXT);
UINT PASCAL XGBProcessKey(WORD, LPPRIVCONTEXT);
WORD PASCAL XGBEngine(LPPRIVCONTEXT);
void PASCAL XGBAddCodeIntoCand(LPCANDIDATELIST, WORD);             // compose.c
UINT PASCAL UnicodeProcessKey(WORD wCharCode, LPPRIVCONTEXT  lpImcP);
WORD PASCAL UnicodeEngine(LPPRIVCONTEXT lpImcP);
#if defined(COMBO_IME)
void PASCAL UnicodeAddCodeIntoCand(LPCANDIDATELIST, WORD);
#endif
// dialog procedure
BOOL FAR PASCAL ImeVerDlgProc(HWND, UINT, WORD, LONG);
BOOL FAR PASCAL CrtWordDlgProc(HWND, UINT, WORD, LONG);
BOOL FAR PASCAL SetImeDlgProc(HWND, UINT, WORD, LONG);

#ifdef MUL_MONITOR  //  Multi-Monitor Support
RECT PASCAL ImeMonitorWorkAreaFromWindow(HWND);                 // mmonitor.c
RECT PASCAL ImeMonitorWorkAreaFromPoint(POINT);                 // mmonitor.c
RECT PASCAL ImeMonitorWorkAreaFromRect(LPRECT);                 // mmonitor.c
#endif

#ifdef UNICODE
extern TCHAR SKLayout[NumsSK][MAXSOFTKEYS];
extern TCHAR SKLayoutS[NumsSK][MAXSOFTKEYS];
#else
extern BYTE SKLayout[NumsSK][MAXSOFTKEYS*2];
extern BYTE SKLayoutS[NumsSK][MAXSOFTKEYS*2];
#endif  //UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\init.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    init.c

++*/


#include <windows.h>
#include <winerror.h>
#include <memory.h>
#include <immdev.h>
#include <imedefs.h>
#include <regstr.h>

int strbytelen (LPTSTR);

void PASCAL InitStatusUIData(
    int     cxBorder,
    int     cyBorder)
{
    int   iContentHi;


    // iContentHi is to get the maximum value of predefined STATUS_DIM_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = STATUS_DIM_Y;

    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;

    // right bottom of status
    sImeG.rcStatusText.left = 0;
    sImeG.rcStatusText.top = 0;

    sImeG.rcStatusText.right = sImeG.rcStatusText.left +
        strbytelen(szImeName) * sImeG.xChiCharWi/2 + STATUS_NAME_MARGIN + STATUS_DIM_X * 4;
    sImeG.rcStatusText.bottom = sImeG.rcStatusText.top + iContentHi;

    sImeG.xStatusWi = STATUS_DIM_X * 4 + STATUS_NAME_MARGIN +
        strbytelen(szImeName) * sImeG.xChiCharWi/2 + 6 * cxBorder;
    sImeG.yStatusHi = iContentHi + 6 * cxBorder;
    
    // left bottom of imeicon bar
    sImeG.rcImeIcon.left = sImeG.rcStatusText.left;
    sImeG.rcImeIcon.top = sImeG.rcStatusText.top;
    sImeG.rcImeIcon.right = sImeG.rcImeIcon.left + STATUS_DIM_X;
    sImeG.rcImeIcon.bottom = sImeG.rcImeIcon.top + iContentHi;

    // left bottom of imename bar
    sImeG.rcImeName.left = sImeG.rcImeIcon.right;
    sImeG.rcImeName.top = sImeG.rcStatusText.top;
    sImeG.rcImeName.right = sImeG.rcImeName.left +
            strbytelen(szImeName) * sImeG.xChiCharWi/2 + STATUS_NAME_MARGIN;
    sImeG.rcImeName.bottom = sImeG.rcImeName.top + iContentHi;
    

    // middle bottom of Shape bar
    sImeG.rcShapeText.left = sImeG.rcImeName.right;
    sImeG.rcShapeText.top = sImeG.rcStatusText.top;
    sImeG.rcShapeText.right = sImeG.rcShapeText.left + STATUS_DIM_X;
    sImeG.rcShapeText.bottom = sImeG.rcShapeText.top + iContentHi;

    // middle bottom of Symbol bar
    sImeG.rcSymbol.left = sImeG.rcShapeText.right;
    sImeG.rcSymbol.top = sImeG.rcStatusText.top;
    sImeG.rcSymbol.right = sImeG.rcSymbol.left + STATUS_DIM_X;
    sImeG.rcSymbol.bottom = sImeG.rcSymbol.top + iContentHi;

    // right bottom of SK bar
    sImeG.rcSKText.left = sImeG.rcSymbol.right;  
    sImeG.rcSKText.top = sImeG.rcStatusText.top;
    sImeG.rcSKText.right = sImeG.rcSKText.left + STATUS_DIM_X;
    sImeG.rcSKText.bottom = sImeG.rcSKText.top + iContentHi;

    return;
}

void PASCAL InitCandUIData(
    int     cxBorder,
    int     cyBorder,
    int     UIMode)
{
    int   iContentHi;


    // iContentHi is to get the maximum value of predefined COMP_TEXT_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = COMP_TEXT_Y;

    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;


    sImeG.cxCandBorder = cxBorder * 2;
    sImeG.cyCandBorder = cyBorder * 2;

    if(UIMode == LIN_UI) {
        sImeG.rcCandIcon.left = 0;
        sImeG.rcCandIcon.top = cyBorder + 2;
        sImeG.rcCandIcon.right = sImeG.rcCandIcon.left + UI_CANDICON;
        sImeG.rcCandIcon.bottom = sImeG.rcCandIcon.top + UI_CANDICON;
                          
        sImeG.rcCandText.left = sImeG.rcCandIcon.right + 3;
        sImeG.rcCandText.top =  cyBorder ;
        sImeG.rcCandText.right = sImeG.rcCandText.left + UI_CANDSTR;
        sImeG.rcCandText.bottom = sImeG.rcCandText.top + iContentHi;

        sImeG.rcCandBTH.top = cyBorder * 4;
        sImeG.rcCandBTH.left = sImeG.rcCandText.right + 5;
        sImeG.rcCandBTH.right = sImeG.rcCandBTH.left + UI_CANDBTW;
        sImeG.rcCandBTH.bottom = sImeG.rcCandBTH.top + UI_CANDBTH;

        sImeG.rcCandBTU.top = cyBorder * 4;
        sImeG.rcCandBTU.left = sImeG.rcCandBTH.right;
        sImeG.rcCandBTU.right = sImeG.rcCandBTU.left + UI_CANDBTW;
        sImeG.rcCandBTU.bottom = sImeG.rcCandBTU.top + UI_CANDBTH;

        sImeG.rcCandBTD.top = cyBorder * 4;
        sImeG.rcCandBTD.left = sImeG.rcCandBTU.right;
        sImeG.rcCandBTD.right = sImeG.rcCandBTD.left + UI_CANDBTW;
        sImeG.rcCandBTD.bottom = sImeG.rcCandBTD.top + UI_CANDBTH;

        sImeG.rcCandBTE.top = cyBorder * 4;
        sImeG.rcCandBTE.left = sImeG.rcCandBTD.right;
        sImeG.rcCandBTE.right = sImeG.rcCandBTE.left + UI_CANDBTW;
        sImeG.rcCandBTE.bottom = sImeG.rcCandBTE.top + UI_CANDBTH;

        sImeG.xCandWi = sImeG.rcCandBTE.right + sImeG.cxCandBorder * 2 + cxBorder * 4;
        sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder * 2 + cyBorder * 4;

    } else {
        sImeG.rcCandText.left = cxBorder;
        sImeG.rcCandText.top = 2 * cyBorder + UI_CANDINF;
        if(sImeG.xChiCharWi*9 > (UI_CANDICON*6 + UI_CANDBTH*4))
            sImeG.rcCandText.right = sImeG.rcCandText.left + sImeG.xChiCharWi * 9;
        else
            sImeG.rcCandText.right = sImeG.rcCandText.left + (UI_CANDICON*6 + UI_CANDBTH*4);
        sImeG.rcCandText.bottom = sImeG.rcCandText.top + sImeG.yChiCharHi * CANDPERPAGE;

        sImeG.xCandWi = sImeG.rcCandText.right + sImeG.cxCandBorder * 2 + cxBorder * 4;
        sImeG.yCandHi = sImeG.rcCandText.bottom + sImeG.cyCandBorder * 2 + cyBorder * 4;

        sImeG.rcCandIcon.left = cxBorder;
        sImeG.rcCandIcon.top = cyBorder + 2;
        sImeG.rcCandIcon.right = sImeG.rcCandIcon.left + UI_CANDICON;
        sImeG.rcCandIcon.bottom = sImeG.rcCandIcon.top + UI_CANDICON;
                          
        sImeG.rcCandInf.left = sImeG.rcCandIcon.right;
        sImeG.rcCandInf.top = cyBorder + 3;
        sImeG.rcCandInf.right = sImeG.rcCandInf.left + UI_CANDICON * 5;
        sImeG.rcCandInf.bottom = sImeG.rcCandInf.top + UI_CANDBTH;

        sImeG.rcCandBTE.top = cyBorder * 5;
        sImeG.rcCandBTE.right = sImeG.rcCandText.right + cxBorder;
        sImeG.rcCandBTE.bottom = sImeG.rcCandBTE.top + UI_CANDBTH;
        sImeG.rcCandBTE.left = sImeG.rcCandBTE.right - UI_CANDBTW;

        sImeG.rcCandBTD.top = cyBorder * 5;
        sImeG.rcCandBTD.right = sImeG.rcCandBTE.left;
        sImeG.rcCandBTD.bottom = sImeG.rcCandBTD.top + UI_CANDBTH;
        sImeG.rcCandBTD.left = sImeG.rcCandBTD.right - UI_CANDBTW;

        sImeG.rcCandBTU.top = cyBorder * 5;
        sImeG.rcCandBTU.right = sImeG.rcCandBTD.left;
        sImeG.rcCandBTU.bottom = sImeG.rcCandBTU.top + UI_CANDBTH;
        sImeG.rcCandBTU.left = sImeG.rcCandBTU.right - UI_CANDBTW;

        sImeG.rcCandBTH.top = cyBorder * 5;
        sImeG.rcCandBTH.right = sImeG.rcCandBTU.left;
        sImeG.rcCandBTH.bottom = sImeG.rcCandBTH.top + UI_CANDBTH;
        sImeG.rcCandBTH.left = sImeG.rcCandBTH.right - UI_CANDBTW;
    }

}
/**********************************************************************/
/* InitImeGlobalData()                                                */
/**********************************************************************/
void PASCAL InitImeGlobalData(
    HINSTANCE hInstance)
{
    int     cxBorder, cyBorder;
    int     UI_MODE;
    HDC     hDC;
    HGDIOBJ hOldFont;
    LOGFONT lfFont;
    TCHAR   szChiChar[4];
    SIZE    lTextSize;
    HGLOBAL hResData;
    int     i;
    DWORD   dwSize;
    HKEY    hKeyIMESetting;
    LONG    lRet;

    hInst = hInstance;
    LoadString(hInst, IDS_IMEREGNAME, szImeRegName, MAX_PATH);    
    LoadString(hInst, IDS_IMENAME_QW, pszImeName[0], MAX_PATH);    
    LoadString(hInst, IDS_IMENAME_NM, pszImeName[1], MAX_PATH);    
    LoadString(hInst, IDS_IMENAME_UNI, pszImeName[2], MAX_PATH);    
    // get the UI class name
    LoadString(hInst, IDS_IMEUICLASS, szUIClassName,
    CLASS_LEN);

    // get the composition class name
    LoadString(hInst, IDS_IMECOMPCLASS, szCompClassName,
    CLASS_LEN);

    // get the candidate class name
    LoadString(hInst, IDS_IMECANDCLASS, szCandClassName,
    CLASS_LEN);

    // get the status class name
    LoadString(hInst, IDS_IMESTATUSCLASS, szStatusClassName,
    CLASS_LEN);

    //get the ContextMenu class name
    LoadString(hInst, IDS_IMECMENUCLASS, szCMenuClassName,
    CLASS_LEN);

    //get the softkeyboard Menu class name
    LoadString(hInst, IDS_IMESOFTKEYMENUCLASS, szSoftkeyMenuClassName,
    CLASS_LEN);

    // work area
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    // border
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    // get the Chinese char
    LoadString(hInst, IDS_CHICHAR, szChiChar, sizeof(szChiChar)/sizeof(TCHAR));

    // get size of Chinese char
    hDC = GetDC(NULL);
    
    hOldFont = GetCurrentObject(hDC, OBJ_FONT);
    GetObject(hOldFont, sizeof(LOGFONT), &lfFont);
    sImeG.fDiffSysCharSet = TRUE;
    ZeroMemory(&lfFont, sizeof(lfFont));
    lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
    lfFont.lfCharSet = NATIVE_CHARSET;
    lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
    SelectObject(hDC, CreateFontIndirect(&lfFont));

    if(!GetTextExtentPoint(hDC, (LPTSTR)szChiChar, lstrlen(szChiChar), &lTextSize))
        memset(&lTextSize, 0, sizeof(SIZE));
    if (sImeG.rcWorkArea.right < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.left = 0;
        sImeG.rcWorkArea.right = GetDeviceCaps(hDC, HORZRES);
    }
    if (sImeG.rcWorkArea.bottom < 2 * UI_MARGIN) {
        sImeG.rcWorkArea.top = 0;
        sImeG.rcWorkArea.bottom = GetDeviceCaps(hDC, VERTRES);
    }

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ReleaseDC(NULL, hDC);

    // get text metrics to decide the width & height of composition window
    // these IMEs always use system font to show
    sImeG.xChiCharWi = lTextSize.cx;
    sImeG.yChiCharHi = lTextSize.cy;

    if(sImeG.IC_Trace) {
        UI_MODE = BOX_UI;
    } else {
        UI_MODE = LIN_UI;
    }

    InitCandUIData(cxBorder, cyBorder, UI_MODE);

    InitStatusUIData(cxBorder, cyBorder);

    // load full ABC table
    hResData = LoadResource(hInst, FindResource(hInst,
        TEXT("FULLABC"), RT_RCDATA));
    *(LPFULLABC)sImeG.wFullABC = *(LPFULLABC)LockResource(hResData);
    UnlockResource(hResData);
    FreeResource(hResData);

    // full shape space
    sImeG.wFullSpace = sImeG.wFullABC[0];

#ifndef UNICODE
    // reverse internal code to internal code, NT don't need it
    for (i = 0; i < (sizeof(sImeG.wFullABC) / 2); i++) {
        sImeG.wFullABC[i] = (sImeG.wFullABC[i] << 8) |
            (sImeG.wFullABC[i] >> 8);
    }
#endif

    LoadString(hInst, IDS_STATUSERR, sImeG.szStatusErr,
        sizeof(sImeG.szStatusErr)/sizeof(TCHAR));
    sImeG.cbStatusErr = lstrlen(sImeG.szStatusErr);

    sImeG.iCandStart = CAND_START;

    // get the UI offset for near caret operation
    RegCreateKey(HKEY_CURRENT_USER, szRegIMESetting, &hKeyIMESetting);

    dwSize = sizeof(DWORD);
    lRet  = RegQueryValueEx(hKeyIMESetting, 
                            szPara, 
                            NULL, 
                            NULL,
                            (LPBYTE)&sImeG.iPara, 
                            &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPara = 0;
        RegSetValueEx(hKeyIMESetting, 
                      szPara, 
                      (DWORD)0, 
                      REG_BINARY,
                      (LPBYTE)&sImeG.iPara, 
                      sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, 
                           szPerp, 
                           NULL, 
                           NULL,
                           (LPBYTE)&sImeG.iPerp, 
                           &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerp = sImeG.yChiCharHi;
        RegSetValueEx(hKeyIMESetting, 
                      szPerp, 
                      (DWORD)0, 
                      REG_BINARY,
                      (LPBYTE)&sImeG.iPerp, 
                      sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, 
                           szParaTol, 
                           NULL, 
                           NULL,
                           (LPBYTE)&sImeG.iParaTol, 
                           &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iParaTol = sImeG.xChiCharWi * 4;
        RegSetValueEx(hKeyIMESetting, 
                      szParaTol, 
                      (DWORD)0, 
                      REG_BINARY,
                      (LPBYTE)&sImeG.iParaTol, 
                      sizeof(int));
    }

    dwSize = sizeof(DWORD);
    lRet = RegQueryValueEx(hKeyIMESetting, 
                           szPerpTol, 
                           NULL, 
                           NULL,
                           (LPBYTE)&sImeG.iPerpTol, 
                           &dwSize);

    if (lRet != ERROR_SUCCESS) {
        sImeG.iPerpTol = lTextSize.cy;
        RegSetValueEx(hKeyIMESetting, 
                      szPerpTol,
                     (DWORD)0, 
                     REG_BINARY,
                     (LPBYTE)&sImeG.iPerpTol, 
                     sizeof(int));
    }

    RegCloseKey(hKeyIMESetting);

    return;
}

/**********************************************************************/
/* InitImeLocalData()                                                 */
/**********************************************************************/
BOOL PASCAL InitImeLocalData(
    HINSTANCE hInstL)
{
    int      cxBorder, cyBorder;

    int   iContentHi;


    // iContentHi is to get the maximum value of predefined COMP_TEXT_Y and
    // a real Chinese character's height in the current HDC.

    iContentHi = COMP_TEXT_Y;

    if ( iContentHi < sImeG.yChiCharHi )
       iContentHi = sImeG.yChiCharHi ;


    lpImeL->hInst = hInstL;

    lpImeL->nMaxKey = 4;

    // border + raising edge + sunken edge
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);
                                        
    // text position relative to the composition window
    lpImeL->cxCompBorder = cxBorder * 2;
    lpImeL->cyCompBorder = cyBorder * 2;

    lpImeL->rcCompText.left = cxBorder;
    lpImeL->rcCompText.top = cyBorder;

    lpImeL->rcCompText.right = lpImeL->rcCompText.left + sImeG.xChiCharWi * ((lpImeL->nMaxKey + 2) / 2);
    lpImeL->rcCompText.bottom = lpImeL->rcCompText.top + iContentHi;
    // set the width & height for composition window
    lpImeL->xCompWi=lpImeL->rcCompText.right+lpImeL->cxCompBorder*2+cxBorder*4;
    lpImeL->yCompHi=lpImeL->rcCompText.bottom+lpImeL->cyCompBorder*2+cyBorder*4;

    // default position of composition window
    lpImeL->ptDefComp.x = sImeG.rcWorkArea.right -
    lpImeL->xCompWi - cxBorder * 2;
    lpImeL->ptDefComp.y = sImeG.rcWorkArea.bottom -
    lpImeL->yCompHi - cyBorder * 2;

    lpImeL->fModeConfig = MODE_CONFIG_QUICK_KEY|MODE_CONFIG_PREDICT;

    return (TRUE);
}

/**********************************************************************/
/* RegisterIme()                                                      */
/**********************************************************************/
void PASCAL RegisterIme(
    HINSTANCE hInstance)
{
    HKEY  hKeyCurrVersion;
    HKEY  hKeyGB;
    DWORD retCode;
    TCHAR Buf[LINE_LEN];
    DWORD ValueType;
    DWORD ValueSize;

    // init ime charact
    lstrcpy(sImeG.UsedCodes, TEXT("0123456789abcdef"));
    sImeG.wNumCodes = (WORD)lstrlen(sImeG.UsedCodes);
    sImeG.IC_Enter = 0;
    sImeG.IC_Trace = 0;
    
    retCode = OpenReg_PathSetup(&hKeyCurrVersion);
    if (retCode) {
        RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SETUP, &hKeyCurrVersion);
    }

    retCode = OpenReg_User (hKeyCurrVersion,
                            szImeRegName,
                            &hKeyGB);
    if (retCode != ERROR_SUCCESS) {
        DWORD dwDisposition;
        DWORD Value;
        
        retCode = RegCreateKeyEx (hKeyCurrVersion,
                                  szImeRegName,
                                  0,
                                  0,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyGB,
                                  &dwDisposition);
        if ( retCode  == ERROR_SUCCESS)
        {

            Value = 1;
            RegSetValueEx(hKeyGB, 
                      szTrace,
                      (DWORD)0,
                      REG_DWORD,
                      (LPBYTE)&Value,
                      sizeof(DWORD));
        }
        else
        {
           // error to create hKeyGB key.
           // return here;
           RegCloseKey(hKeyCurrVersion);
           return;
        }
    }

    ValueSize = sizeof(DWORD);
    if (RegQueryValueEx(hKeyGB, 
                        szTrace,
                        NULL,
                        (LPDWORD)&ValueType,
                        (LPBYTE)&sImeG.IC_Trace,
                        (LPDWORD)&ValueSize) != ERROR_SUCCESS)
    {
        DWORD Value = 1;
        RegSetValueEx(hKeyGB,
                      szTrace,
                      (DWORD)0,
                      REG_DWORD,
                      (LPBYTE)&Value,
                      sizeof(DWORD));

        RegQueryValueEx(hKeyGB, 
                        szTrace,
                        NULL,
                        (LPDWORD)&ValueType,
                        (LPBYTE)&sImeG.IC_Trace,
                        (LPDWORD)&ValueSize);
    }
        
        

#ifdef CROSSREF                 
    if(RegQueryValueEx(hKeyGB, 
                       szRegRevKL,
                       NULL,
                       NULL,                  // null-terminate string
                       (LPBYTE)&sImeG.hRevKL, // &bData,
                       &ValueSize) != ERROR_SUCCESS)
    sImeG.hRevKL = NULL;
    if(RegQueryValueEx (hKeyGB, 
                        szRegRevMaxKey,
                        NULL,
                        NULL,                       //null-terminate string
                        (LPBYTE)&sImeG.nRevMaxKey,  //&bData,
                        &ValueSize) != ERROR_SUCCESS)
    sImeG.hRevKL = NULL;
#endif

    RegCloseKey(hKeyGB);
    RegCloseKey(hKeyCurrVersion);

    return;
}

/**********************************************************************/
/* RegisterImeClass()                                                 */
/**********************************************************************/
void PASCAL RegisterImeClass(
    HINSTANCE hInstance,
    HINSTANCE hInstL)
{
    WNDCLASSEX wcWndCls;

    // IME UI class
    // Register IME UI class
    wcWndCls.cbSize        = sizeof(WNDCLASSEX);
    wcWndCls.cbClsExtra    = 0;
    wcWndCls.cbWndExtra    = sizeof(INT_PTR) * 2;
    wcWndCls.hIcon         = LoadImage(hInstL, MAKEINTRESOURCE(IDI_IME),
    IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
    wcWndCls.hInstance     = hInstance;
    wcWndCls.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
    wcWndCls.lpszMenuName  = (LPTSTR)NULL;
    wcWndCls.hIconSm       = LoadImage(hInstL, MAKEINTRESOURCE(IDI_IME),
    IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

    // IME UI class
    if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
    wcWndCls.style         = CS_IME;
    wcWndCls.lpfnWndProc   = UIWndProc;
    wcWndCls.lpszClassName = (LPTSTR)szUIClassName;

    RegisterClassEx(&wcWndCls);
    }

    wcWndCls.style         = CS_IME|CS_HREDRAW|CS_VREDRAW;
    wcWndCls.hbrBackground = GetStockObject(LTGRAY_BRUSH);


    // IME composition class
    // register IME composition class
    if (!GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
       wcWndCls.lpfnWndProc   = CompWndProc;
       wcWndCls.lpszClassName = (LPTSTR)szCompClassName;

       RegisterClassEx(&wcWndCls);
    }

    // IME candidate class
    // register IME candidate class
    if (!GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
       wcWndCls.lpfnWndProc   = CandWndProc;
       wcWndCls.lpszClassName = (LPTSTR)szCandClassName;

       RegisterClassEx(&wcWndCls);
    }

    // IME status class
    // register IME status class
    if (!GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
       wcWndCls.lpfnWndProc   = StatusWndProc;
       wcWndCls.lpszClassName = (LPTSTR)szStatusClassName;

       RegisterClassEx(&wcWndCls);
    }

    // IME context menu class
    if (!GetClassInfoEx(hInstance, szCMenuClassName, &wcWndCls)) {
       wcWndCls.style         = 0;
       wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
       wcWndCls.lpfnWndProc   = ContextMenuWndProc;
       wcWndCls.lpszClassName = (LPTSTR)szCMenuClassName;

       RegisterClassEx(&wcWndCls);
    }
    // IME softkeyboard menu class
    if (!GetClassInfoEx(hInstance, szSoftkeyMenuClassName, &wcWndCls)) {
       wcWndCls.style         = 0;
       wcWndCls.hbrBackground = GetStockObject(NULL_BRUSH);
       wcWndCls.lpfnWndProc   = SoftkeyMenuWndProc;
       wcWndCls.lpszClassName = (LPTSTR)szSoftkeyMenuClassName;

       RegisterClassEx(&wcWndCls);
    }

    return;
}

/**********************************************************************/
/* ImeDllInit()                                                       */
/* Return Value:                                                      */
/*      TRUE - successful                                             */
/*      FALSE - failure                                               */
/**********************************************************************/
BOOL CALLBACK ImeDllInit(
    HINSTANCE hInstance,        // instance handle of this library
    DWORD     fdwReason,        // reason called
    LPVOID    lpvReserve)       // reserve pointer
{
    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
         RegisterIme(hInstance);

    // init globaldata & load globaldata from resource
#if defined(COMBO_IME)
         {
            HKEY  hKeyCurrVersion;
            HKEY  hKeyGB;
            LONG  retCode;
            DWORD ValueType;
            DWORD ValueSize;

            retCode = OpenReg_PathSetup(&hKeyCurrVersion);

            if (retCode) {
               RegCreateKey(HKEY_CURRENT_USER, 
                            REGSTR_PATH_SETUP, 
                            &hKeyCurrVersion);
            }

            if ( hKeyCurrVersion )
            {

                retCode = RegCreateKeyEx(hKeyCurrVersion, 
                             szImeRegName, 
                             0,
                             NULL, 
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKeyGB, 
                             NULL);

                ValueSize = sizeof(DWORD);

                if ( hKeyGB )
                {
                    retCode = RegQueryValueEx(hKeyGB,
                              szRegImeIndex,
                              NULL,
                              (LPDWORD)&ValueType,
                              (LPBYTE)&sImeL.dwRegImeIndex,
                              (LPDWORD)&ValueSize);

                    if ( retCode != ERROR_SUCCESS )  {
                         //set GB/QW as default

                       sImeL.dwRegImeIndex = 0;
                       RegSetValueEx (hKeyGB, szRegImeIndex,
                                   (DWORD)0,
                                   REG_DWORD,
                                   (LPBYTE)&sImeL.dwRegImeIndex,
                                   sizeof(DWORD));  
                    }
    
                    //readout current ImeName
                    szImeName = pszImeName[sImeL.dwRegImeIndex];

                    RegCloseKey(hKeyGB);
                }

                RegCloseKey(hKeyCurrVersion);
             }
         }

#endif  //COMBO_IME

         if (!hInst) {
            InitImeGlobalData(hInstance);
         }

         if (!lpImeL) {
            lpImeL = &sImeL;
            InitImeLocalData(hInstance);
         }

         RegisterImeClass(hInstance, hInstance);

         break;
    case DLL_PROCESS_DETACH:
         {
            WNDCLASSEX wcWndCls;

            if (GetClassInfoEx(hInstance, szCMenuClassName, &wcWndCls)) {
                UnregisterClass(szCMenuClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szSoftkeyMenuClassName, &wcWndCls)) {
               UnregisterClass(szSoftkeyMenuClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szStatusClassName, &wcWndCls)) {
               UnregisterClass(szStatusClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szCandClassName, &wcWndCls)) {
               UnregisterClass(szCandClassName, hInstance);
            }

            if (GetClassInfoEx(hInstance, szCompClassName, &wcWndCls)) {
               UnregisterClass(szCompClassName, hInstance);
            }

            if (!GetClassInfoEx(hInstance, szUIClassName, &wcWndCls)) {
            } else if (!UnregisterClass(szUIClassName, hInstance)) {
            } else {
                      DestroyIcon(wcWndCls.hIcon);
                      DestroyIcon(wcWndCls.hIconSm);
                   }
         }
         break;
    default:
         break;
    }

    return (TRUE);
}

int strbytelen (LPTSTR lpStr)
{
#ifdef UNICODE
    int i, len, iRet;

    len = lstrlen(lpStr);
    for (i = 0, iRet = 0; i < len; i++, iRet++) {
        if (lpStr[i] > 0x100)
            iRet++;
    }
    return iRet;
#else
    return lstrlen(lpStr);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\compui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    compui.c

++*/


#include <windows.h>
#include <immdev.h>
#include "imedefs.h"
#include <regstr.h>

/**********************************************************************/
/* GetCompWnd                                                         */
/* Return Value :                                                     */
/*      window handle of composition                                  */
/**********************************************************************/
HWND PASCAL GetCompWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hCompWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw candidate window
        return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw candidate window
        return (HWND)NULL;
    }

    hCompWnd = lpUIPrivate->hCompWnd;

    GlobalUnlock(hUIPrivate);
    return (hCompWnd);
}

/**********************************************************************/
/* FitInLazyOperation()                                               */
/* Return Value :                                                     */
/*      TRUE or FALSE                                                 */
/**********************************************************************/
BOOL PASCAL FitInLazyOperation( // fit in lazy operation or not
    LPPOINT lpptOrg,
    LPPOINT lpptNearCaret,      // the suggested near caret position
    LPRECT  lprcInputRect,
    UINT    uEsc)
{
    POINT ptDelta, ptTol;
    RECT  rcUIRect, rcInterRect;

    ptDelta.x = lpptOrg->x - lpptNearCaret->x;

    ptDelta.x = (ptDelta.x >= 0) ? ptDelta.x : -ptDelta.x;

    ptTol.x = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacX +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacX;

    ptTol.x = (ptTol.x >= 0) ? ptTol.x : -ptTol.x;

    if (ptDelta.x > ptTol.x) {
        return (FALSE);
    }

    ptDelta.y = lpptOrg->y - lpptNearCaret->y;

    ptDelta.y = (ptDelta.y >= 0) ? ptDelta.y : -ptDelta.y;

    ptTol.y = sImeG.iParaTol * ncUIEsc[uEsc].iParaFacY +
        sImeG.iPerpTol * ncUIEsc[uEsc].iPerpFacY;

    ptTol.y = (ptTol.y >= 0) ? ptTol.y : -ptTol.y;

    if (ptDelta.y > ptTol.y) {
        return (FALSE);
    }

    // build up the UI rectangle (composition window)
    rcUIRect.left = lpptOrg->x;
    rcUIRect.top = lpptOrg->y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    if (IntersectRect(&rcInterRect, &rcUIRect, lprcInputRect)) {
        return (FALSE);
    }

    return (TRUE);
}

/**********************************************************************/
/* GetNearCaretPosition()                                             */
/**********************************************************************/
void PASCAL GetNearCaretPosition(   // decide a near caret position according
                                    // to the caret position
    LPPOINT lpptFont,
    UINT    uEsc,
    UINT    uRot,
    LPPOINT lpptCaret,
    LPPOINT lpptNearCaret,
    BOOL    fFlags)
{
    LONG lFontSize;
    LONG xWidthUI, yHeightUI, xBorder, yBorder;
    RECT rcWorkArea;

    if ((uEsc + uRot) & 0x0001) {
        lFontSize = lpptFont->x;
    } else {
        lFontSize = lpptFont->y;
    }

    xWidthUI  = lpImeL->xCompWi;
    yHeightUI = lpImeL->yCompHi;
    xBorder   = lpImeL->cxCompBorder;
    yBorder   = lpImeL->cyCompBorder;

    if (fFlags & NEAR_CARET_FIRST_TIME) {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacX;

        if (ptInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncUIEsc[uEsc].iPerpFacY;

        if (ptInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    } else {
        lpptNearCaret->x = lpptCaret->x +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacX +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacX +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacX;

        if (ptAltInputEsc[uEsc].x >= 0) {
            lpptNearCaret->x += xBorder * 2;
        } else {
            lpptNearCaret->x -= xWidthUI - xBorder * 2;
        }

        lpptNearCaret->y = lpptCaret->y +
            lFontSize * ncAltUIEsc[uEsc].iLogFontFacY +
            sImeG.iPara * ncAltUIEsc[uEsc].iParaFacY +
            sImeG.iPerp * ncAltUIEsc[uEsc].iPerpFacY;

        if (ptAltInputEsc[uEsc].y >= 0) {
            lpptNearCaret->y += yBorder * 2;
        } else {
            lpptNearCaret->y -= yHeightUI - yBorder * 2;
        }
    }

#ifdef MUL_MONITOR 
    rcWorkArea = ImeMonitorWorkAreaFromPoint(*lpptCaret);
#else
    rcWorkArea = sImeG.rcWorkArea; 
#endif

    if (lpptNearCaret->x < rcWorkArea.left) {
        lpptNearCaret->x = rcWorkArea.left;
    } else if (lpptNearCaret->x + xWidthUI > rcWorkArea.right) {
        lpptNearCaret->x = rcWorkArea.right - xWidthUI;
    } 

    if (lpptNearCaret->y < rcWorkArea.top) {
        lpptNearCaret->y = rcWorkArea.top;
    } else if (lpptNearCaret->y + yHeightUI > rcWorkArea.bottom) {
        lpptNearCaret->y = rcWorkArea.bottom - yHeightUI;
    } 

    return;
}

/**********************************************************************/
/* AdjustCompPosition()                                               */
/* Return Value :                                                     */
/*      the position of composition window is changed or not          */
/**********************************************************************/
BOOL PASCAL AdjustCompPosition(         // IME adjust position according to
                                        // composition form
    LPINPUTCONTEXT lpIMC,
    LPPOINT        lpptOrg,             // original composition window
                                        // and final position
    LPPOINT        lpptNew)             // new expect position
{
    POINT ptNearCaret, ptOldNearCaret;
    UINT  uEsc, uRot;
    RECT  rcUIRect, rcInputRect, rcInterRect;
    POINT ptFont;

    // we need to adjust according to font attribute
    if (lpIMC->lfFont.A.lfWidth > 0) {
        ptFont.x = lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfWidth < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfWidth * 2;
    } else if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.x = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.x = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.x = lpImeL->yCompHi;
    }

    if (lpIMC->lfFont.A.lfHeight > 0) {
        ptFont.y = lpIMC->lfFont.A.lfHeight;
    } else if (lpIMC->lfFont.A.lfHeight < 0) {
        ptFont.y = -lpIMC->lfFont.A.lfHeight;
    } else {
        ptFont.y = ptFont.x;
    }

    // if the input char is too big, we don't need to consider so much
    if (ptFont.x > lpImeL->yCompHi * 8) {
        ptFont.x = lpImeL->yCompHi * 8;
    }
    if (ptFont.y > lpImeL->yCompHi * 8) {
        ptFont.y = lpImeL->yCompHi * 8;
    }

    if (ptFont.x < sImeG.xChiCharWi) {
        ptFont.x = sImeG.xChiCharWi;
    }

    if (ptFont.y < sImeG.yChiCharHi) {
        ptFont.y = sImeG.yChiCharHi;
    }

    // -450 to 450 index 0
    // 450 to 1350 index 1
    // 1350 to 2250 index 2
    // 2250 to 3150 index 3
    uEsc = (UINT)((lpIMC->lfFont.A.lfEscapement + 450) / 900 % 4);
    uRot = (UINT)((lpIMC->lfFont.A.lfOrientation + 450) / 900 % 4);

    // decide the input rectangle
    rcInputRect.left = lpptNew->x;
    rcInputRect.top = lpptNew->y;

    // build up an input rectangle from escapemment
    rcInputRect.right = rcInputRect.left + ptFont.x * ptInputEsc[uEsc].x;
    rcInputRect.bottom = rcInputRect.top + ptFont.y * ptInputEsc[uEsc].y;

    // be a normal rectangle, not a negative rectangle
    if (rcInputRect.left > rcInputRect.right) {
        LONG tmp;

        tmp = rcInputRect.left;
        rcInputRect.left = rcInputRect.right;
        rcInputRect.right = tmp;
    }

    if (rcInputRect.top > rcInputRect.bottom) {
        LONG tmp;

        tmp = rcInputRect.top;
        rcInputRect.top = rcInputRect.bottom;
        rcInputRect.bottom = tmp;
    }

    GetNearCaretPosition(
        &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, NEAR_CARET_FIRST_TIME);

    // 1st, use the adjust point
    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    ptOldNearCaret = ptNearCaret;

    // OK, no intersect between the near caret position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        // happy ending!!!, don't change position
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        // happy ending!!
        return (TRUE);
    }

    // unhappy case
    GetNearCaretPosition(
            &ptFont, uEsc, uRot, lpptNew, &ptNearCaret, 0);

    // build up the new suggest UI rectangle (composition window)
    rcUIRect.left = ptNearCaret.x;
    rcUIRect.top = ptNearCaret.y;
    rcUIRect.right = rcUIRect.left + lpImeL->xCompWi;
    rcUIRect.bottom = rcUIRect.top + lpImeL->yCompHi;

    // OK, no intersect between the adjust position and input char
    if (IntersectRect(&rcInterRect, &rcUIRect, &rcInputRect)) {
    } else if (FitInLazyOperation(
        lpptOrg, &ptNearCaret, &rcInputRect, uEsc)) {
        return (FALSE);
    } else {
        *lpptOrg = ptNearCaret;

        return (TRUE);
    }

    *lpptOrg = ptOldNearCaret;

    return (TRUE);
}

/**********************************************************************/
/* SetCompPosition()                                                  */
/**********************************************************************/
void PASCAL SetCompPosition(    // set the composition window position
    HWND           hCompWnd,
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC)
{
    POINT ptWnd;
    POINT ptSTWPos;
    HWND  hCandWnd;
    BOOL  fChange = FALSE;
    RECT  rcWorkArea;


#ifdef MUL_MONITOR 
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    // the client coordinate position (0, 0) of composition window
    ptWnd.x = 0;
    ptWnd.y = 0;
    // convert to screen coordinates
    ClientToScreen(hCompWnd, &ptWnd);
    ptWnd.x -= lpImeL->cxCompBorder;
    ptWnd.y -= lpImeL->cyCompBorder;
    
    if (!sImeG.IC_Trace) {
        int  Comp_CandWndLen;

           ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);

        // reset status window for LINE_UI(FIX_UI)
        Comp_CandWndLen = 0;
        if(uStartComp) {
            Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
            if(uOpenCand) {
                Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
            }
            if(ptSTWPos.x+sImeG.xStatusWi+Comp_CandWndLen>rcWorkArea.right) {
                ptSTWPos.x=rcWorkArea.right-sImeG.xStatusWi-Comp_CandWndLen;
            }

            SetWindowPos(GetStatusWnd(GetWindow(hCompWnd, GW_OWNER)), NULL,
                (int)ptSTWPos.x, (int)ptSTWPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);
            ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        }

        ptWnd.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
        ptWnd.y = ptSTWPos.y;
        lpIMC->cfCompForm.ptCurrentPos = ptWnd;
        ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        fChange = TRUE;

    } else if (lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION) {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }
        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }
        if (fChange) {
            ptWnd.x -= lpImeL->cxCompBorder;
            ptWnd.y -= lpImeL->cyCompBorder;
        }
    } else if (lpIMC->cfCompForm.dwStyle != CFS_DEFAULT) {
        POINT ptNew;            // new position of UI

        ptNew.x = lpIMC->cfCompForm.ptCurrentPos.x;
        ptNew.y = lpIMC->cfCompForm.ptCurrentPos.y;
        ClientToScreen((HWND)lpIMC->hWnd, &ptNew);
        fChange = AdjustCompPosition(lpIMC, &ptWnd, &ptNew);
    } else {
        POINT ptNew;            // new position of UI

        ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);
        ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
        if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN) >=
          rcWorkArea.right) { 
            ptNew.x = ptSTWPos.x - lpImeL->xCompWi - UI_MARGIN;
        }
        ptNew.y = ptSTWPos.y;
        if (ptWnd.x != ptNew.x) {
            ptWnd.x = ptNew.x;
            fChange = TRUE;
        }

        if (ptWnd.y != ptNew.y) {
            ptWnd.y = ptNew.y;
            fChange = TRUE;
        }

        if (fChange) {
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
        }
    }

    if (!fChange) {
        return;
    }
    SetWindowPos(hCompWnd, NULL,
        ptWnd.x, ptWnd.y,
        0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

    hCandWnd = GetCandWnd(GetWindow(hCompWnd, GW_OWNER));

    if (!hCandWnd) {
        return;
    }


    // decide the position of candidate window by UI's position
    CalcCandPos(hIMC, GetWindow(hCompWnd, GW_OWNER), &ptWnd);

    ScreenToClient(lpIMC->hWnd, &ptWnd);

    lpIMC->cfCandForm[0].dwStyle = CFS_CANDIDATEPOS;
    lpIMC->cfCandForm[0].ptCurrentPos = ptWnd;

    if (!IsWindowVisible(hCandWnd)) {
        return;
    }

    PostMessage(hCandWnd, WM_IME_NOTIFY, IMN_SETCANDIDATEPOS, 0x0001);

    return;
}


/**********************************************************************/
/* SetCompWindow()                                                    */
/**********************************************************************/
void PASCAL SetCompWindow(              // set the position of composition window
    HWND hCompWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hUIWnd;

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);
    if (!hUIWnd) {
        return;
    }
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    SetCompPosition(hCompWnd, hIMC, lpIMC);

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* MoveDefaultCompPosition()                                          */
/**********************************************************************/
void PASCAL MoveDefaultCompPosition(    // the default comp position
                                        // need to near the caret
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HWND           hCompWnd;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    hCompWnd = GetCompWnd(hUIWnd);
    if (!hCompWnd) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (!(lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)) {
        SetCompPosition(hCompWnd, hIMC, lpIMC);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowComp()                                                         */
/**********************************************************************/
void PASCAL ShowComp(           // Show the composition window
    HWND hUIWnd,
    int  nShowCompCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    // show or hid the UI window
    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    if (lpUIPrivate->nShowCompCmd == nShowCompCmd) {
        goto SwCompNoChange;
    }

    if (nShowCompCmd == SW_HIDE) {
        lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
    }

    if (lpUIPrivate->hCompWnd) {
        if(nShowCompCmd == SW_HIDE) {
            uStartComp = 0;
        } else {
            uStartComp = 1;
        }
        
        ShowWindow(lpUIPrivate->hCompWnd, nShowCompCmd);
        lpUIPrivate->nShowCompCmd = nShowCompCmd;
    }

SwCompNoChange:
    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* StartComp()                                                        */
/**********************************************************************/
void PASCAL StartComp(
    HWND hUIWnd)
{
    HIMC           hIMC;
    HGLOBAL        hUIPrivate;
    LPINPUTCONTEXT lpIMC;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {           
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {          
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    // can not draw composition window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    if(!lpUIPrivate->hCompWnd) {
        lpUIPrivate->hCompWnd = CreateWindowEx(
                                      WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                      szCompClassName, 
                                      NULL, 
                                      WS_POPUP|WS_DISABLED,
                                      0, 
                                      0, 
                                      lpImeL->xCompWi, 
                                      lpImeL->yCompHi,
                                      hUIWnd, 
                                      (HMENU)NULL, 
                                      hInst, 
                                      NULL);

        if ( lpUIPrivate->hCompWnd )
        {
            SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hCompWnd, UI_MOVE_XY, lpImeL->nMaxKey);
        }
    }

       uStartComp = 1;
    // try to set the position of composition UI window near the caret
    SetCompPosition(lpUIPrivate->hCompWnd, hIMC, lpIMC);

    ImmUnlockIMC(hIMC);

    ShowComp(hUIWnd, SW_SHOWNOACTIVATE);

    GlobalUnlock(hUIPrivate);

    return;
}

/**********************************************************************/
/* EndComp()                                                          */
/**********************************************************************/
void PASCAL EndComp(
    HWND hUIWnd)
{
    ShowComp(hUIWnd, SW_HIDE);

    return;
}

/**********************************************************************/
/* DestroyCompWindow()                                                */
/**********************************************************************/
void PASCAL DestroyCompWindow(          // destroy composition window
    HWND hCompWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        // undo the drag border
        DrawDragBorder(hCompWnd,
            GetWindowLong(hCompWnd, UI_MOVE_XY),
            GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(GetWindow(hCompWnd, GW_OWNER),
        IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    
        return;
    }

    lpUIPrivate->nShowCompCmd = SW_HIDE;

    lpUIPrivate->hCompWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CompSetCursor()                                                    */
/**********************************************************************/
void PASCAL CompSetCursor(
    HWND   hCompWnd,
    LPARAM lParam)
{
    POINT ptCursor;
    RECT  rcWnd;

    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) !=
        WINDOW_NOT_DRAG) {
        return;
    }

    if (HIWORD(lParam) != WM_LBUTTONDOWN) {
        return;
    }

    // start dragging
    SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    SetCapture(hCompWnd);
    GetCursorPos(&ptCursor);
    SetWindowLong(hCompWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
    GetWindowRect(hCompWnd, &rcWnd);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET,
        MAKELONG(ptCursor.x - rcWnd.left, ptCursor.y - rcWnd.top));

    DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hCompWnd, UI_MOVE_OFFSET));

    return;
}


/**********************************************************************/
/* CompButtonUp()                                                     */
/**********************************************************************/
BOOL PASCAL CompButtonUp(       // finish drag, set comp  window to this
                                // position
    HWND   hCompWnd)
{
    LONG            lTmpCursor, lTmpOffset;
    POINT           pt;
    HWND            hUIWnd;
    HIMC            hIMC;
    LPINPUTCONTEXT  lpIMC;
    RECT            rcWorkArea;

    if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) == WINDOW_NOT_DRAG) {
        return (FALSE);
    }

    lTmpCursor = GetWindowLong(hCompWnd, UI_MOVE_XY);

    // calculate the org by the offset
    lTmpOffset = GetWindowLong(hCompWnd, UI_MOVE_OFFSET);

    pt.x = (*(LPPOINTS)&lTmpCursor).x - (*(LPPOINTS)&lTmpOffset).x;
    pt.y = (*(LPPOINTS)&lTmpCursor).y - (*(LPPOINTS)&lTmpOffset).y;

    DrawDragBorder(hCompWnd, lTmpCursor, lTmpOffset);
    SetWindowLong(hCompWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);

    SetWindowLong(hCompWnd, UI_MOVE_XY, lpImeL->nMaxKey);

    ReleaseCapture();

    hUIWnd = GetWindow(hCompWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

#ifdef MUL_MONITOR
    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    if (pt.x < rcWorkArea.left) {
        pt.x = rcWorkArea.left;
    } else if (pt.x + lpImeL->xCompWi > rcWorkArea.right) {
        pt.x = rcWorkArea.right - lpImeL->xCompWi;
    }

    if (pt.y < rcWorkArea.top) {
        pt.y = rcWorkArea.top;
    } else if (pt.y + lpImeL->yCompHi > rcWorkArea.bottom) {
        pt.y = rcWorkArea.bottom - lpImeL->yCompHi;
    }

    lpIMC->cfCompForm.dwStyle = CFS_FORCE_POSITION;
    lpIMC->cfCompForm.ptCurrentPos.x = pt.x + lpImeL->cxCompBorder;
    lpIMC->cfCompForm.ptCurrentPos.y = pt.y + lpImeL->cyCompBorder;

    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);

    ImmUnlockIMC(hIMC);

    // set composition window to the new poosition
    PostMessage(hCompWnd, WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

    return (TRUE);
}

/**********************************************************************/
/* PaintCompWindow()                                                */
/**********************************************************************/
void PASCAL PaintCompWindow(
    HWND   hUIWnd,
    HWND   hCompWnd,
    HDC    hDC)
{
    HIMC                hIMC;
    LPINPUTCONTEXT      lpIMC;
    HGDIOBJ             hOldFont;
    LPCOMPOSITIONSTRING lpCompStr;
    LPGUIDELINE         lpGuideLine;
    BOOL                fShowString;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;
        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {          
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (!lpGuideLine) {          
        return;
    }


    // draw CompWnd Layout
    {
      RECT rcWnd;

      GetClientRect(hCompWnd, &rcWnd);
      DrawConcaveRect(hDC,
                      rcWnd.left,
                      rcWnd.top,
                      rcWnd.right - 1,
                      rcWnd.bottom - 1);
    }
    
    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

    fShowString = (BOOL)0;

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
    } else if (!lpGuideLine->dwStrLen) {
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            fShowString |= IME_STR_ERROR;
        }
    } else {
        // if there is information string, we will show the information
        // string
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            // red text for error
            SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
        }

        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPCTSTR)((LPBYTE)lpGuideLine + lpGuideLine->dwStrOffset),
            (UINT)lpGuideLine->dwStrLen, NULL);
        fShowString |= IME_STR_SHOWED;
    }

    if (fShowString & IME_STR_SHOWED) {
        // already show it, don't need to show
    } else if (lpCompStr->dwCompStrLen > 0) {
        ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, 0, NULL);
        DrawText(hDC, (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),
                (int)lpCompStr->dwCompStrLen, &lpImeL->rcCompText,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE);
        if (fShowString & IME_STR_ERROR) {
            // red text for error
            //SetTextColor(hDC, RGB(0xFF, 0, 0));
            // light gray background for error
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset +
                lpCompStr->dwCursorPos),
                (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else if (lpCompStr->dwCursorPos < lpCompStr->dwCompStrLen) {
            // light gray background for cursor start
            SetBkColor(hDC, RGB(0x80, 0x80, 0x80));
            ExtTextOut(hDC, lpImeL->rcCompText.left +
                lpCompStr->dwCursorPos * sImeG.xChiCharWi/ 2,
                lpImeL->rcCompText.top,
                ETO_CLIPPED, &lpImeL->rcCompText,
                (LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset +
                lpCompStr->dwCursorPos),
                (UINT)lpCompStr->dwCompStrLen - lpCompStr->dwCursorPos, NULL);
        } else {
        }
    } else {
#ifdef CROSSREF
        {    
            LPCANDIDATELIST lpRevCandList;
            LPPRIVCONTEXT       lpImcP;

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
            if (lpImcP) {
                if(lpImcP->hRevCandList){    
                       lpRevCandList = (LPCANDIDATELIST)GlobalLock((HGLOBAL)lpImcP->hRevCandList);
                       if (lpRevCandList != NULL && lpRevCandList->dwCount) {

                        // green text for information
                        SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
                        SetBkColor(hDC, RGB(0xc0, 0xc0, 0xc0));

                        ExtTextOut(hDC, 
                            lpImeL->rcCompText.left, 
                            lpImeL->rcCompText.top,
                            ETO_OPAQUE, 
                            &lpImeL->rcCompText,
                            (LPTSTR)((LPBYTE)lpRevCandList+lpRevCandList->dwOffset[0]), 
                            (int)lstrlen((LPTSTR)((LPBYTE)lpRevCandList + lpRevCandList->dwOffset[0])),
                            NULL);
                               GlobalUnlock((HGLOBAL)lpImcP->hRevCandList);
                        GlobalFree((HGLOBAL)lpImcP->hRevCandList);
                        lpImcP->hRevCandList = 0;
                        goto CrossCodeFinish;
                    }
                }
            }    
            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, 0, NULL);
CrossCodeFinish:
            ImmUnlockIMCC(lpIMC->hPrivate);
        }
#else
            ExtTextOut(hDC, lpImeL->rcCompText.left, lpImeL->rcCompText.top,
            ETO_OPAQUE, &lpImeL->rcCompText,
            (LPTSTR)NULL, 0, NULL);
#endif
    }

    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);
    return;
}

/**********************************************************************/
/* UpdateCompWindow()                                                 */
/**********************************************************************/
void PASCAL UpdateCompWindow(
    HWND hUIWnd)
{
    HWND hCompWnd;
    HDC  hDC;

    hCompWnd = GetCompWnd(hUIWnd);
    hDC = GetDC(hCompWnd);
    PaintCompWindow(hUIWnd, hCompWnd, hDC);
    ReleaseDC(hCompWnd, hDC);
}

/**********************************************************************/
/* CompWndProc()                                                      */
/**********************************************************************/
LRESULT CALLBACK CompWndProc(           // composition window proc
    HWND   hCompWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        DestroyCompWindow(hCompWnd);
        break;
    case WM_SETCURSOR:
        CompSetCursor(hCompWnd, lParam);
        break;
    case WM_MOUSEMOVE:
        if (GetWindowLong(hCompWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
            POINT ptCursor;

            DrawDragBorder(hCompWnd,
                GetWindowLong(hCompWnd, UI_MOVE_XY),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
            GetCursorPos(&ptCursor);
            SetWindowLong(hCompWnd, UI_MOVE_XY,
                MAKELONG(ptCursor.x, ptCursor.y));
            DrawDragBorder(hCompWnd, MAKELONG(ptCursor.x, ptCursor.y),
                GetWindowLong(hCompWnd, UI_MOVE_OFFSET));
        } else {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_LBUTTONUP:
        if (!CompButtonUp(hCompWnd)) {
            return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_NOTIFY:
        if (wParam != IMN_SETCOMPOSITIONWINDOW) {
        // 9.8.del
        //} else if (sImeG.IC_Trace) {
        //    SetCompWindow(hCompWnd);
        } else {
            // 9.8.add
            SetCompWindow(hCompWnd);
        }
        break;
    case WM_PAINT:
        {
            HDC         hDC;
            PAINTSTRUCT ps;

            hDC = BeginPaint(hCompWnd, &ps);
            PaintCompWindow(GetWindow(hCompWnd, GW_OWNER), hCompWnd, hDC);
            EndPaint(hCompWnd, &ps);
        }
        break;
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    default:
        return DefWindowProc(hCompWnd, uMsg, wParam, lParam);
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\mmonitor.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    mmonitor.c

    this file contains functions which support Multiple Monitors

++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

#ifdef MUL_MONITOR

/**********************************************************************/
/* ImeMonitorWorkAreaFromWindow()                                     */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromWindow( HWND hAppWnd)
{

    HMONITOR  hMonitor;

    hMonitor = MonitorFromWindow(hAppWnd, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {

        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);

        // init a default value to avoid GetMonitorInfo fails

        sMonitorInfo.rcWork = sImeG.rcWorkArea;
        GetMonitorInfo(hMonitor, &sMonitorInfo);
        return sMonitorInfo.rcWork;
    } else 
        return sImeG.rcWorkArea;
    
}

/**********************************************************************/
/* ImeMonitorWorkAreaFromPoint()                                      */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromPoint(
    POINT ptPoint)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromPoint(ptPoint, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {

        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);

        // init a default value to avoid GetMonitorInfo fails

        sMonitorInfo.rcWork = sImeG.rcWorkArea;
        GetMonitorInfo(hMonitor, &sMonitorInfo);
        return sMonitorInfo.rcWork;
    } else 
        return sImeG.rcWorkArea;
    
}


/**********************************************************************/
/* ImeMonitorWorkAreaFromRect()                                       */
/**********************************************************************/
RECT PASCAL ImeMonitorWorkAreaFromRect(
    LPRECT lprcRect)
{
    HMONITOR hMonitor;

    hMonitor = MonitorFromRect(lprcRect, MONITOR_DEFAULTTONEAREST);

    if (hMonitor) {
        MONITORINFO sMonitorInfo;

        sMonitorInfo.cbSize = sizeof(sMonitorInfo);

        // init a default value to avoid GetMonitorInfo fails

        sMonitorInfo.rcWork = sImeG.rcWorkArea;

        GetMonitorInfo(hMonitor, &sMonitorInfo);
        return sMonitorInfo.rcWork;
    } else 
        return sImeG.rcWorkArea;
    
}
#endif  // MUL_MONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\data.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    data.c

++*/


#include <windows.h>
#include <immdev.h>
#include "imedefs.h"

#pragma data_seg(".ShareDate")
IMEG      sImeG = {0};

#ifdef UNICODE
TCHAR SKLayout[NumsSK][MAXSOFTKEYS] = {
        0x3000, 0xFF10, 0xFF11, 0xFF12, 0xFF13, 0xFF14, 0xFF15, 0xFF16,
        0xFF17, 0xFF18, 0xFF19, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45,
        0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D,
        0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55,
        0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0xFF1B, 0xFF1D, 0xFF0C,
        0xFF0D, 0xFF0E, 0xFF0F, 0xFF40, 0xFF3B, 0xFF3C, 0xFF3D, 0xFF07, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x03BA, 0x03C7, 0x03C5, 0x03BC, 0x03B3,
        0x03BD, 0x03BE, 0x03BF, 0x03B8, 0x03C0, 0x03C1, 0x0020, 0x03C9,
        0x03C8, 0x03B9, 0x0020, 0x03B1, 0x03B4, 0x03BB, 0x03B5, 0x03B7,
        0x03C6, 0x03B2, 0x03C4, 0x03B6, 0x03C3, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x043B, 0x044A, 0x0448, 0x043D, 0x0432,
        0x043E, 0x043F, 0x0440, 0x0436, 0x0441, 0x0442, 0x0443, 0x044C,
        0x044B, 0x0437, 0x0438, 0x0430, 0x0433, 0x043C, 0x0434, 0x0451,
        0x0449, 0x0431, 0x0447, 0x0435, 0x0446, 0x0444, 0x0020, 0x044D,
        0x0020, 0x044E, 0x044F, 0x0020, 0x0439, 0x0020, 0x043A, 0x0445, 

        0x3000, 0x3122, 0x3105, 0x3109, 0x02C7, 0x02CB, 0x3113, 0x02CA,
        0x02D9, 0x311A, 0x311E, 0x3107, 0x3116, 0x310F, 0x310E, 0x310D,
        0x3111, 0x3115, 0x3118, 0x311B, 0x3128, 0x311C, 0x3120, 0x3129,
        0x3119, 0x311F, 0x3123, 0x3106, 0x3110, 0x310B, 0x3114, 0x3127,
        0x3112, 0x310A, 0x310C, 0x3117, 0x3108, 0x3124, 0x0020, 0x311D,
        0x3126, 0x3121, 0x3125, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0113, 0x0020, 0x01D4, 0x011B, 0x01CE,
        0x00E8, 0x0020, 0x012B, 0x01D2, 0x00ED, 0x01D0, 0x00EC, 0x01D8,
        0x01D6, 0x00F2, 0x0020, 0x0101, 0x00E0, 0x00E9, 0x0020, 0x00F3,
        0x00F9, 0x00E1, 0x00FA, 0x014D, 0x016B, 0x0020, 0x0020, 0x01DA,
        0x0020, 0x01DC, 0x00FC, 0x0020, 0x00EA, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x3043, 0x3045, 0x3047, 0x3049, 0x304B, 0x304D,
        0x304F, 0x3051, 0x3053, 0x306A, 0x3082, 0x3080, 0x306C, 0x3059,
        0x306D, 0x306E, 0x306F, 0x3064, 0x3072, 0x3075, 0x3078, 0x3085,
        0x3083, 0x3063, 0x3066, 0x3055, 0x305B, 0x306B, 0x305D, 0x3061,
        0x3081, 0x3057, 0x307F, 0x305F, 0x307E, 0x307B, 0x0020, 0x3087,
        0x3093, 0x308E, 0x3092, 0x3041, 0x3068, 0x0020, 0x3090, 0x3091, 

        0x3000, 0x30B1, 0x30A3, 0x30A5, 0x30F4, 0x30A7, 0x30A9, 0x30AB,
        0x30F5, 0x30AD, 0x30AF, 0x30CA, 0x30E2, 0x30E0, 0x30CC, 0x30B9,
        0x30CD, 0x30CE, 0x30CF, 0x30C4, 0x30D2, 0x30D5, 0x30D8, 0x30E5,
        0x30E3, 0x30C3, 0x30C6, 0x30B5, 0x30BB, 0x30CB, 0x30BD, 0x30C1,
        0x30E1, 0x30B7, 0x30DF, 0x30BF, 0x30DE, 0x30DB, 0x30B3, 0x30E7,
        0x30F6, 0x30EE, 0x30F2, 0x30A1, 0x30C8, 0x30F3, 0x30F0, 0x30F1, 

        0x3000, 0x02C9, 0xFF0C, 0x3001, 0xFF1B, 0xFF1A, 0xFF1F, 0xFF01,
        0x2026, 0x2014, 0x00B7, 0x3014, 0xFF08, 0x3010, 0x3008, 0x201C,
        0x3009, 0x300A, 0x300B, 0x2236, 0x300C, 0x300D, 0x300E, 0xFF3B,
        0xFF09, 0xFF02, 0xFF07, 0x2018, 0x201D, 0x3015, 0x3005, 0x2016,
        0x3011, 0x2019, 0x3017, 0xFF5E, 0x3016, 0x300F, 0x00A8, 0xFF3D,
        0x02C7, 0xFF5B, 0xFF5D, 0x3002, 0xFF40, 0x3003, 0xFF5C, 0xFF0E, 

        0x3000, 0x216A, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166,
        0x2167, 0x2168, 0x2169, 0x3220, 0x2478, 0x2476, 0x3222, 0x248A,
        0x3223, 0x3224, 0x3225, 0x248F, 0x3226, 0x3227, 0x3228, 0x247A,
        0x2479, 0x2490, 0x2491, 0x2488, 0x248B, 0x3221, 0x248C, 0x248E,
        0x2477, 0x2489, 0x2475, 0x248D, 0x2474, 0x3229, 0x0020, 0x247B,
        0x216B, 0x247C, 0x247D, 0x2160, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x0020, 0x2261, 0x2260, 0xFF1D, 0x2264, 0x2265, 0xFF1C,
        0xFF1E, 0x226E, 0x226F, 0x2227, 0x2299, 0x2220, 0x2211, 0xFF0D,
        0x220F, 0x222A, 0x2229, 0x222B, 0x2208, 0x0020, 0x2235, 0x223D,
        0x224C, 0x222E, 0x221D, 0x00B1, 0x00D7, 0x2228, 0x00F7, 0x0020,
        0x2312, 0xFF0B, 0x2225, 0xFF0F, 0x22A5, 0x2234, 0x0020, 0x0020,
        0x2237, 0x221A, 0x0020, 0x2248, 0x221E, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x00A4, 0x00B0, 0x2032, 0x2033, 0xFF04, 0xFFE1, 0xFFE5,
        0x2030, 0xFF05, 0x2103, 0x767E, 0x0020, 0x6BEB, 0x4E07, 0x4E8C,
        0x4EBF, 0x5146, 0x5409, 0x4E03, 0x592A, 0x62CD, 0x827E, 0x0020,
        0x0020, 0x516B, 0x4E5D, 0x25CB, 0x4E09, 0x5343, 0x56DB, 0x516D,
        0x5FAE, 0x4E00, 0x5398, 0x4E94, 0x5206, 0x0020, 0x0020, 0x0020,
        0xFFE0, 0x0020, 0x0020, 0x0020, 0x5341, 0x0020, 0x0020, 0x0020, 

        0x3000, 0x2504, 0x250D, 0x250E, 0x250F, 0x2510, 0x2511, 0x2512,
        0x2513, 0x0020, 0x2500, 0x252C, 0x2540, 0x253E, 0x252E, 0x251E,
        0x252F, 0x2530, 0x2531, 0x2523, 0x2532, 0x2533, 0x0020, 0x2542,
        0x2541, 0x0020, 0x2502, 0x251C, 0x251F, 0x252D, 0x2520, 0x2522,
        0x253F, 0x251D, 0x253D, 0x2521, 0x253C, 0x0020, 0x0020, 0x2543,
        0x2508, 0x0020, 0x0020, 0x250C, 0x2506, 0x0020, 0x250A, 0x0020, 

        0x3000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x25A0, 0xFF3E, 0xFF20, 0x25B2, 0x2606,
        0x203B, 0x2192, 0x2190, 0x25C7, 0x2191, 0x2193, 0x3013, 0xFFE3,
        0xFF3F, 0x25C6, 0x25A1, 0x00A7, 0x2605, 0x25B3, 0x25CB, 0x25CE,
        0xFF3C, 0x2116, 0xFF06, 0x25CF, 0xFF03, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 
    };
TCHAR SKLayoutS[NumsSK][MAXSOFTKEYS] = {
        0x3000, 0xFF09, 0xFF01, 0xFF20, 0xFF03, 0xFF04, 0xFF05, 0xFF3E,
        0xFF06, 0xFF0A, 0xFF08, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25,
        0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D,
        0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35,
        0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0xFF1A, 0xFF0B, 0xFF1C,
        0xFF3F, 0xFF1E, 0xFF1F, 0xFF5E, 0xFF5B, 0xFF5C, 0xFF5D, 0xFF02, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x039A, 0x03A7, 0x03A5, 0x039C, 0x0393,
        0x039D, 0x039E, 0x039F, 0x0398, 0x03A0, 0x03A1, 0x0020, 0x03A9,
        0x03A8, 0x0399, 0x0020, 0x0391, 0x0394, 0x039B, 0x0395, 0x0397,
        0x03A6, 0x0392, 0x03A4, 0x0396, 0x03A3, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x041B, 0x042A, 0x0428, 0x041D, 0x0412,
        0x041E, 0x041F, 0x0420, 0x0416, 0x0421, 0x0422, 0x0423, 0x042C,
        0x042B, 0x0417, 0x0418, 0x0410, 0x0413, 0x041C, 0x0414, 0x0401,
        0x0429, 0x0411, 0x0427, 0x0415, 0x0426, 0x0424, 0x0020, 0x042D,
        0x0020, 0x042E, 0x042F, 0x0020, 0x0419, 0x0020, 0x041A, 0x0425, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x3044, 0x3046, 0x3048, 0x304A, 0x304C, 0x304E,
        0x3050, 0x3052, 0x3054, 0x3071, 0x308D, 0x308B, 0x3077, 0x305A,
        0x307A, 0x307D, 0x3070, 0x3065, 0x3073, 0x3076, 0x3079, 0x3086,
        0x3084, 0x0020, 0x3067, 0x3056, 0x305C, 0x3074, 0x305E, 0x3062,
        0x308C, 0x3058, 0x308A, 0x3060, 0x3089, 0x307C, 0x0020, 0x3088,
        0x0020, 0x308F, 0x0020, 0x3042, 0x3069, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x30B2, 0x30A4, 0x30A6, 0x0020, 0x30A8, 0x30AA, 0x30AC,
        0x0020, 0x30AE, 0x30B0, 0x30D1, 0x30ED, 0x30EB, 0x30D7, 0x30BA,
        0x30DA, 0x30DD, 0x30D0, 0x30C5, 0x30D3, 0x30D6, 0x30D9, 0x30E6,
        0x30E4, 0x0020, 0x30C7, 0x30B6, 0x30BC, 0x30D4, 0x30BE, 0x30C2,
        0x30EC, 0x30B8, 0x30EA, 0x30C0, 0x30E9, 0x30DC, 0x30B4, 0x30E8,
        0x0020, 0x30EF, 0x0020, 0x30A2, 0x30C9, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x2460, 0x2482, 0x2480, 0x2462, 0x2494,
        0x2463, 0x2464, 0x2465, 0x2499, 0x2466, 0x2467, 0x2468, 0x2484,
        0x2483, 0x249A, 0x249B, 0x2492, 0x2495, 0x2461, 0x2496, 0x2498,
        0x2481, 0x2493, 0x247F, 0x2497, 0x247E, 0x2469, 0x0020, 0x2485,
        0x0020, 0x2486, 0x2487, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x4F70, 0x0020, 0x0020, 0x0020, 0x8D30,
        0x0020, 0x0020, 0x0020, 0x67D2, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x634C, 0x7396, 0x96F6, 0x53C1, 0x4EDF, 0x8086, 0x9646,
        0x0020, 0x58F9, 0x0020, 0x4F0D, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x62FE, 0x0020, 0x0020, 0x0020, 

        0x0020, 0x2505, 0x2515, 0x2516, 0x2517, 0x2518, 0x2519, 0x251A,
        0x251B, 0x0020, 0x2501, 0x2534, 0x2548, 0x2546, 0x2536, 0x2526,
        0x2537, 0x2538, 0x2539, 0x252B, 0x253A, 0x253B, 0x0020, 0x254A,
        0x2549, 0x0020, 0x2503, 0x2524, 0x2527, 0x2535, 0x2528, 0x252A,
        0x2547, 0x2525, 0x2545, 0x2529, 0x2544, 0x0020, 0x0020, 0x254B,
        0x2509, 0x0020, 0x0020, 0x2514, 0x2507, 0x0020, 0x250B, 0x0020, 

        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
        0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020,
    };
#else
BYTE SKLayout[NumsSK][MAXSOFTKEYS*2] = {
    "ۣܣݣ",
    "                    ʦ֦Ԧ̦æͦΦϦȦЦ  ئצ  Ħ˦ŦǦզ¦ӦƦ                      ",
    "                    ݧߧӧا٧ڧѧԧާէקҧ֧        ܧ",
    "        ڨިǨ֨ϨΨͨѨըبۨܨ٨ߨƨШ˨ԨҨ  רȨ            ",
    "                                          ",
    "  ʤ̤ͤΤϤĤҤդؤäƤˤᤷߤޤ  򤡤  ",
    "ʥ̥ͥΥϥĥҥեإåƥ˥᥷ߥޥۥ򥡥ȥ",
    "áۣݡࡨ",
    "ɢǢ碳ꢸˢʢ梵ȢƢŢ  ̢͢΢        ",
    "  ԡ٣ܡݣڡۡġѡϡƣǡȡɡҡ  ߡסաӡءš  УΣ͡    ˡ  ֡      ",
    "꣤룥  ׼̫İ    ˾šǧ΢һ            ʮ      ",
    "  Щҩ©өԩթǩ֩    éѩĩƩũ    穬        ",
    "                    ޣߡܡ                      ",
    };
BYTE SKLayoutS[NumsSK][MAXSOFTKEYS*2] = {
    "磥ޣ£ãģţƣǣȣɣʣˣ̣ͣΣϣУѣңӣԣգ֣ףأ٣ڣߣ",
    "                                                ",
    "                              ",
    "                                                                                                ",
    "                                                                                                ",
    "    ѤפڤݤܤŤӤ֤٤  ǤԤ¤줸            ",
    "      ѥץڥݥХťӥ֥٥  ǥԥ¥쥸ܥ          ",
    "                                                                                                ",
    "                      ٢ӢѢۢܢݢޢ¢ߢբԢâĢڢҢТϢ    ע          ",
    "                                                                                                ",
    "                                            ǾǪ½  Ҽ                  ʰ      ",
    "    ةکʩ۩ܩݩϩީ    ȩ˩٩̩Ωɩͩ    舘        ",
    "                                                                                                ",
    };
#endif //UNICODE

#pragma data_seg()

HDC   ST_UI_hDC;
UINT  uStartComp = 0;
UINT  uOpenCand = 0;
UINT  uCaps = 0;
DWORD SaTC_Trace;

HINSTANCE hInst;
IMEL      sImeL;
LPIMEL    lpImeL;
TCHAR      szUIClassName[CLASS_LEN];
TCHAR      szCompClassName[CLASS_LEN];
TCHAR      szCandClassName[CLASS_LEN];
TCHAR      szStatusClassName[CLASS_LEN];
TCHAR      szCMenuClassName[CLASS_LEN];            
TCHAR      szSoftkeyMenuClassName[CLASS_LEN];    
TCHAR      szHandCursor[] = TEXT("Hand");
TCHAR      szChinese[] = TEXT("Chinese");
TCHAR      szEnglish[] = TEXT("English");
#if defined(COMBO_IME)
TCHAR        pszImeName[IMEINDEXNUM][MAX_PATH];
TCHAR        *szImeName;
TCHAR        szImeRegName[MAX_PATH];
#else
#if defined(GB)
TCHAR      szImeName[] = pszImeName[0];
#else
TCHAR      szImeName[] = pszImeName[1];
#endif
#endif //COMBO_IME
TCHAR      szCode[] = TEXT("Code");
TCHAR      szEudc[] = TEXT("Eudc");
TCHAR      szFullShape[] = TEXT("FullShape");
TCHAR      szHalfShape[] = TEXT("HalfShape");
TCHAR      szSymbol[] = TEXT("Symbol");
TCHAR      szNoSymbol[] = TEXT("NoSymbol");
TCHAR      szNone[] = TEXT("None");
TCHAR      szSoftKBD[] = TEXT("SoftKBD");
TCHAR      szNoSoftKBD[] = TEXT("NoSoftKBD");
TCHAR      szDigit[] = TEXT("01234567890");

#ifdef UNICODE
TCHAR      szCandInf[] ={0x0020, 0x0020, 0x0020, 0x6570, 0x5B57, 0x952E, 0x0000};
TCHAR       szTrace[]= {0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000};
TCHAR      szRegRevKL[] = {0x7F16, 0x7801, 0x67E5, 0x8BE2, 0x0000};
TCHAR      szRegRevMaxKey[] = {0x7F16, 0x7801, 0x67E5, 0x8BE2, 0x7801, 0x957F, 0x0000};
TCHAR       szWarnTitle[] = {0x8B66, 0x544A, 0x0000};
TCHAR       szErrorTitle[] = {0x9519, 0x8BEF, 0x0000};
#else
BYTE       szCandInf[] = "   ּ";
BYTE       szTrace[]= "";
#if defined(CROSSREF)
BYTE  szRegRevKL[] = "ѯ";
BYTE  szRegRevMaxKey[] = "ѯ볤";
#endif //CROSSREF
BYTE  szWarnTitle[]="";    
BYTE  szErrorTitle[]="";
#endif //UNICODE

// convert char to upper case
BYTE bUpper[] = {
// 0x20 - 0x27
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
// 0x28 - 0x2F
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
// 0x30 - 0x37
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
// 0x38 - 0x3F
    0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
// 0x40 - 0x47
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
// 0x48 - 0x4F
    0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
// 0x50 - 0x57
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
// 0x58 - 0x5F
    0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
//   '    a    b    c    d    e    f    g 
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
//   h    i    j    k    l    m    n    o
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
//   p    q    r    s    t    u    v    w
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
//   x    y    z    {    |    }    ~
    'X', 'Y', 'Z'
};

WORD fMask[] = {         // offset of bitfield
    0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000
};

TCHAR szRegIMESetting[] = TEXT("Control Panel\\Input Method");
TCHAR szPara[] = TEXT("Parallel Distance");
TCHAR szPerp[] = TEXT("Perpendicular Distance");
TCHAR szParaTol[] = TEXT("Parallel Tolerance");
TCHAR szPerpTol[] = TEXT("Perpendicular Tolerance");
#if defined(COMBO_IME)
TCHAR szRegImeIndex[] = TEXT("IME Index");
#endif
// decide UI offset base on escapement
const NEARCARET ncUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        1,        1,      0,      0,      1},       // 0
    { 1,        0,        0,      1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,      1},       // 1800
    {-1,        0,        0,     -1,     -1,      0}        // 2700
};
// decide another UI offset base on escapement
const NEARCARET ncAltUIEsc[] = {
   // LogFontX  LogFontY  ParaX   PerpX   ParaY   PerpY
    { 0,        0,        1,      0,      0,     -1},       // 0
    { 0,        0,        0,     -1,      1,      0},       // 900
    { 0,        0,       -1,      0,      0,     -1},       // 1800
    { 0,        0,        0,      1,     -1,      0}        // 2700
};
// decide input rectangle base on escapement
const POINT ptInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,            1},                                  // 0
    {1,           -1},                                  // 900
    {1,            1},                                  // 1800
    {-1,           1}                                   // 2700
};

// decide another input rectangle base on escapement
const POINT ptAltInputEsc[] = {
    // LogFontWi   LogFontHi
    {1,           -1},                                  // 0
    {-1,          -1},                                  // 900
    {1,           -1},                                  // 1800
    {1,            1}                                   // 2700
};


BYTE VirtKey48Map[48] = {
    0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
    0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xba, 0xbb, 0xbc,
    0xbd, 0xbe, 0xbf, 0xc0, 0xdb, 0xdc, 0xdd, 0xde
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\compose.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

   compose.c

++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

void PASCAL XGBAddCodeIntoCand(LPCANDIDATELIST, WORD);
#if defined(COMBO_IME)
void PASCAL UnicodeAddCodeIntoCand(LPCANDIDATELIST, WORD);
#endif

#if defined(COMBO_IME)
/**********************************************************************/
/* UnicodeEngine()                                                         */
/* Description:                                                       */
/*      Conv GBcode                                                   */
/**********************************************************************/
WORD PASCAL UnicodeEngine(LPPRIVCONTEXT lpImcP)
{
     if (lpImcP->bSeq[3] || lpImcP->bSeq[2] == TEXT('?') || lpImcP->bSeq[2] == TEXT(' ')) {
         if (lpImcP->bSeq[2] == TEXT('?') || lpImcP->bSeq[2] == TEXT(' ')){
                lpImcP->bSeq[2] = TEXT('0');
                lpImcP->bSeq[3] = TEXT('0');
         }
         return (AsciiToGB(lpImcP));
     } else {
         return (0);
     }
}
#endif //COMBO_IME

/**********************************************************************/
/* XGBEngine()                                                         */
/* Description:                                                       */
/*      Conv GBcode                                                   */
/**********************************************************************/
WORD PASCAL XGBEngine(LPPRIVCONTEXT lpImcP)
{
    WORD wCode;

     if (lpImcP->bSeq[3] ||(lpImcP->bSeq[2] == TEXT('?'))) {
          if (lpImcP->bSeq[2] == TEXT('?')){  //add 626
                lpImcP->bSeq[2] = TEXT('4');
                lpImcP->bSeq[3] = TEXT('0');
          }
          wCode = AsciiToGB(lpImcP);
          return wCode;
     } else {
        return ((WORD)NULL);
     }
}

/**********************************************************************/
/* XGBSpcEng()                                                         */
/* Description:                                                       */
/*      Conv GBcode for Space                                         */
/**********************************************************************/
WORD PASCAL XGBSpcEng(LPPRIVCONTEXT lpImcP)
{
    WORD wCode;

    lpImcP->bSeq[2] = TEXT('4');
    lpImcP->bSeq[3] = TEXT('0');
    wCode = AsciiToGB(lpImcP);

    return wCode;
}

/**********************************************************************/
/* GBEngine()                                                         */
/* Description:                                                       */
/*      Conv GBcode                                                   */
/**********************************************************************/
WORD PASCAL GBEngine(LPPRIVCONTEXT lpImcP)
{
    WORD wCode;

     if (lpImcP->bSeq[3] ||(lpImcP->bSeq[2] == TEXT('?'))) {

        if (lpImcP->bSeq[0] >=TEXT('0') && lpImcP->bSeq[0] <=TEXT('9')) { //Area mode
             if (lpImcP->bSeq[2] == TEXT('?')){

                  lpImcP->bSeq[2] = TEXT('0');
                  lpImcP->bSeq[3] = TEXT('1');
             }
             return (AsciiToArea(lpImcP));
        }
        else if (lpImcP->bSeq[0] >=TEXT('a') && lpImcP->bSeq[0] <=TEXT('f')) { //GB mode

                 if (lpImcP->bSeq[2] == TEXT('?')){
                     lpImcP->bSeq[2] = TEXT('a');
                     lpImcP->bSeq[3] = TEXT('1');
                 }
                 wCode = AsciiToGB(lpImcP);
                 return wCode;
             } else {
                 return ((WORD)NULL);
             }
     } else
         return ((WORD)NULL);

}

/**********************************************************************/
/* GBSpcEng()                                                         */
/* Description:                                                       */
/*      Conv GBcode for Space                                         */
/**********************************************************************/
WORD PASCAL GBSpcEng(LPPRIVCONTEXT lpImcP)
{
        if (lpImcP->bSeq[0] >=TEXT('0') && lpImcP->bSeq[0] <=TEXT('9')) { //Area mode
            lpImcP->bSeq[2] = TEXT('0');
            lpImcP->bSeq[3] = TEXT('1');
            return (AsciiToArea(lpImcP));
        } else if (lpImcP->bSeq[0] >=TEXT('a') && lpImcP->bSeq[0] <=TEXT('f')) { //GB mode
            lpImcP->bSeq[2] = TEXT('a');
            lpImcP->bSeq[3] = TEXT('1');
            return (AsciiToGB(lpImcP));
        } else {
            return ((WORD)NULL);
        }
}

/**********************************************************************/
/* AsciiToGB                                                          */
/* Description:                                                       */
/**********************************************************************/
WORD PASCAL AsciiToGB(LPPRIVCONTEXT lpImcP)
{
    WORD GBCode;

    GBCode = (CharToHex(lpImcP->bSeq[2]) << 4) + CharToHex(lpImcP->bSeq[3]);
    GBCode = GBCode * 256;
    GBCode = (CharToHex(lpImcP->bSeq[0]) << 4) + CharToHex(lpImcP->bSeq[1]) + GBCode;

    return (GBCode);
}

/**********************************************************************/
/* AsciiToArea                                                        */
/* Description:                                                       */
/**********************************************************************/
WORD PASCAL AsciiToArea(LPPRIVCONTEXT lpImcP)
{
WORD AreaCode;
    AreaCode = (CharToHex(lpImcP->bSeq[2]) * 10) + CharToHex(lpImcP->bSeq[3]) + 0xa0;
    AreaCode = AreaCode * 256;
    AreaCode = (CharToHex(lpImcP->bSeq[0]) * 10) + CharToHex(lpImcP->bSeq[1]) + AreaCode + 0xa0;
        return (AreaCode);
}

WORD PASCAL CharToHex(
    TCHAR cChar)
{
    if (cChar >= TEXT('0') && cChar <= TEXT('9'))
        return((WORD)(cChar - TEXT('0')));
    else if (cChar >= TEXT('a') && cChar <= TEXT('f'))
        return((WORD)(cChar-TEXT('a')+ 0x0a));
    else
        return ((WORD)NULL);
}



/**********************************************************************/
/* Engine()                                                           */
/* Description:                                                       */
/*      search MB and fill lpCompStr and lpCandList                   */
/**********************************************************************/
int PASCAL Engine(
    LPCOMPOSITIONSTRING lpCompStr,
    LPCANDIDATELIST     lpCandList,
    LPPRIVCONTEXT       lpImcP,
    LPINPUTCONTEXT      lpIMC,
    WORD                wCharCode)
{
    if(lpCompStr->dwCursorPos < 4
      && (lpImcP->bSeq[2] != TEXT('?'))
      && (wCharCode != TEXT(' '))) {
        return (ENGINE_COMP);
    } else if((lpCompStr->dwCursorPos==4)
             ||(lpImcP->bSeq[2] == TEXT('?'))
             ||((wCharCode == TEXT(' ')) && (lpCompStr->dwCursorPos == 2))) {

        if (!lpCompStr) {
            MessageBeep((UINT)-1);
            return -1;
        }

        if (!lpImcP) {
            MessageBeep((UINT)-1);
            return -1;
        }

#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex == INDEX_GB)
        {

            // GB
            DWORD i;
            WORD wCode;
            TCHAR ResaultStr[3];

            if((lpImcP->bSeq[2] == TEXT('?'))) {
                wCode = GBEngine(lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < IME_MAXCAND; i++, wCode++) {
                     AddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else if(wCharCode == TEXT(' ')) {
                wCode = GBSpcEng(lpImcP);
                lpImcP->bSeq[2] = 0;
                lpImcP->bSeq[3] = 0;
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < IME_MAXCAND; i++, wCode++) {
                     AddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else {
                   InitCompStr(lpCompStr);

                // the result string = the selected candidate;
                wCode = GBEngine(lpImcP);
#ifdef UNICODE
                MultiByteToWideChar(NATIVE_ANSI_CP, 0, (LPCSTR)&wCode, 2, ResaultStr, sizeof(ResaultStr)/sizeof(TCHAR));
                ResaultStr[1] = TEXT('\0');
#else
                ResaultStr[0] = LOBYTE(wCode);
                ResaultStr[1] = HIBYTE(wCode);
                ResaultStr[2] = 0x00;
#endif
                lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),ResaultStr);

                // calculate result string length
                lpCompStr->dwResultStrLen = lstrlen(ResaultStr);

                return (ENGINE_RESAULT);
            }

          }else if(sImeL.dwRegImeIndex == INDEX_GBK)
        {
            // XGB
            DWORD i;
            WORD wCode;
            TCHAR ResaultStr[3];

            if((lpImcP->bSeq[2] == TEXT('?')))  {
                wCode = XGBEngine(lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else if(wCharCode == TEXT(' ')) {
                wCode = XGBSpcEng(lpImcP);
                lpImcP->bSeq[2] = 0;
                lpImcP->bSeq[3] = 0;

                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else {
                   InitCompStr(lpCompStr);

                // the result string = the selected candidate;
                wCode = XGBEngine(lpImcP);
#ifdef UNICODE
                MultiByteToWideChar(NATIVE_ANSI_CP, 0, (LPCSTR)&wCode, 2, ResaultStr, sizeof(ResaultStr)/sizeof(TCHAR));
                ResaultStr[1] = TEXT('\0');
#else
                ResaultStr[0] = LOBYTE(wCode);
                ResaultStr[1] = HIBYTE(wCode);
                ResaultStr[2] = 0x00;
#endif
                lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),ResaultStr);

                // calculate result string length
                lpCompStr->dwResultStrLen = lstrlen(ResaultStr);

                return (ENGINE_RESAULT);
            }
          }else if(sImeL.dwRegImeIndex == INDEX_UNICODE)
        {
            // UNICODE
            DWORD i;
            WORD wCode, xCode;
            TCHAR ResaultStr[3];

            memset(ResaultStr, 0, sizeof(ResaultStr));

            if((lpImcP->bSeq[2] == TEXT('?') || wCharCode == TEXT(' ')))  {
                lpImcP->bSeq[2] = TEXT('0');
                lpImcP->bSeq[3] = TEXT('0');
                lpImcP->bSeq[4] = TEXT('\0');

                wCode = UnicodeEngine(lpImcP);

                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                lpCandList->dwCount = 0;
                for (i = 0; i < IME_UNICODE_MAXCAND; i++, wCode++) {
#ifdef UNICODE
                    // add this string into candidate list
                    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                    lpCandList->dwCount]) = wCode;
#else
                    WideCharToMultiByte(NATIVE_ANSI_CP, NULL, &wCode, 1, &xCode, 2, NULL, NULL);
                    // add this string into candidate list
                    *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
                    lpCandList->dwCount]) = xCode;
#endif
                    // null terminator
                    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
                    lpCandList->dwCount] + sizeof(WORD)) = TEXT('\0');

                    lpCandList->dwOffset[lpCandList->dwCount + 1] =
                    lpCandList->dwOffset[lpCandList->dwCount] +
                    sizeof(WORD) + sizeof(TCHAR);
                    lpCandList->dwCount++;

                }
                return (ENGINE_COMP);
            } else {
                   InitCompStr(lpCompStr);

                // the result string = the selected candidate;
                wCode = UnicodeEngine(lpImcP);
                {
                    WCHAR    UniStr[2];

                    UniStr[0] = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                    UniStr[1] = 0;
                    lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),UniStr);

                    // calculate result string length
                    lpCompStr->dwResultStrLen = lstrlen(UniStr);
                }
                return (ENGINE_RESAULT);
            }
        }
#else //COMBO_IME
#ifdef GB
        {

            // GB
            DWORD i;
            WORD wCode;
            TCHAR ResaultStr[3];

            if((lpImcP->bSeq[2] == TEXT('?'))) {
                wCode = GBEngine(lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < IME_MAXCAND; i++, wCode++) {
                     AddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else if(wCharCode == TEXT(' ')) {
                wCode = GBSpcEng(lpImcP);
                lpImcP->bSeq[2] = 0;
                lpImcP->bSeq[3] = 0;
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < IME_MAXCAND; i++, wCode++) {
                     AddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else {
                   InitCompStr(lpCompStr);

                // the result string = the selected candidate;
                wCode = GBEngine(lpImcP);
#ifdef UNICODE
                // change CP_ACP to 936, so that it can work under Multilingul Env.
                MultiByteToWideChar(NATIVE_ANSI_CP, NULL, &wCode, 2, ResaultStr, sizeof(ResaultStr)/sizeof(TCHAR));
                ResaultStr[1] = TEXT('\0');
#else
                ResaultStr[0] = LOBYTE(wCode);
                ResaultStr[1] = HIBYTE(wCode);
                ResaultStr[2] = 0x00;
#endif
                lstrcpy((LPTSTR)lpCompStr + lpCompStr->dwResultStrOffset,ResaultStr);

                // calculate result string length
                lpCompStr->dwResultStrLen = lstrlen(ResaultStr);

                return (ENGINE_RESAULT);
            }

          }
#else
        {
            // XGB
            DWORD i;
            WORD wCode;
            TCHAR ResaultStr[3];

            if((lpImcP->bSeq[2] == TEXT('?')))  {
                wCode = XGBEngine(lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else if(wCharCode == TEXT(' ')) {
                wCode = XGBSpcEng(lpImcP);
                lpImcP->bSeq[2] = 0;
                lpImcP->bSeq[3] = 0;

                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                    XGBAddCodeIntoCand(lpCandList, wCode);
                }
                return (ENGINE_COMP);
            } else {
                   InitCompStr(lpCompStr);

                // the result string = the selected candidate;
                wCode = XGBEngine(lpImcP);
#ifdef UNICODE
                // change CP_ACP to 936, so that it can work under Multilingul Env.
                MultiByteToWideChar(NATIVE_ANSI_CP, NULL, &wCode, 2, ResaultStr, sizeof(ResaultStr)/sizeof(TCHAR));
                ResaultStr[1] = TEXT('\0');
#else
                ResaultStr[0] = LOBYTE(wCode);
                ResaultStr[1] = HIBYTE(wCode);
                ResaultStr[2] = 0x00;
#endif
                lstrcpy((LPTSTR)lpCompStr + lpCompStr->dwResultStrOffset,ResaultStr);

                // calculate result string length
                lpCompStr->dwResultStrLen = lstrlen(ResaultStr);

                return (ENGINE_RESAULT);
            }
        }
#endif //GB
#endif //COMBO_IME
    }
    MessageBeep((UINT)-1);
    return (ENGINE_COMP);
}

/**********************************************************************/
/* AddCodeIntoCand()                                                  */
/**********************************************************************/
void PASCAL AddCodeIntoCand(
    LPCANDIDATELIST lpCandList,
    WORD            wCode)
{
    WORD wInCode;

    if (lpCandList->dwCount >= IME_MAXCAND) {
        return;
    }

    wInCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
#ifdef UNICODE
    {
        TCHAR wUnicode;
        // change CP_ACP to 936, so that it can work under Multilingul Env.
        MultiByteToWideChar(NATIVE_ANSI_CP, 0, (LPCSTR) &wInCode, 2, &wUnicode, 1);
        *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount]) = wUnicode;
    }
#else
    // add GB string into candidate list
    *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]) = wInCode;
#endif
    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WORD)) = TEXT('\0');

    lpCandList->dwOffset[lpCandList->dwCount + 1] =
        lpCandList->dwOffset[lpCandList->dwCount] +
        sizeof(WORD) + sizeof(TCHAR);
    lpCandList->dwCount++;
    return;
}

#if defined(COMBO_IME)
/**********************************************************************/
/* UnicodeAddCodeIntoCand()                                                  */
/**********************************************************************/
void PASCAL UnicodeAddCodeIntoCand(
    LPCANDIDATELIST lpCandList,
    WORD            wCode)
{
    if (lpCandList->dwCount >= IME_UNICODE_MAXCAND) {
        return;
    }
    // add this string into candidate list
    *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]) = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

    // null terminator
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WORD)) = TEXT('\0');

    lpCandList->dwOffset[lpCandList->dwCount + 1] =
        lpCandList->dwOffset[lpCandList->dwCount] +
        sizeof(WORD) + sizeof(TCHAR);
    lpCandList->dwCount++;

    return;
}
#endif //COMBO_IME

/**********************************************************************/
/* XGBAddCodeIntoCand()                                                  */
/**********************************************************************/
void PASCAL XGBAddCodeIntoCand(
    LPCANDIDATELIST lpCandList,
    WORD            wCode)
{
    WORD wInCode;

    if (lpCandList->dwCount >= IME_XGB_MAXCAND) {
        return;
    }

    wInCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
#ifdef UNICODE
    {
        TCHAR wUnicode;

        // change CP_ACP to 936, so that it can work under Multilingul Env.
        MultiByteToWideChar(NATIVE_ANSI_CP, 0, (LPCSTR) &wInCode, 2, &wUnicode, 1);
        *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
            lpCandList->dwCount]) = wUnicode;
    }
#else
    // add GB string into candidate list
    *(LPUNAWORD)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount]) = wInCode;
#endif
    *(LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[
        lpCandList->dwCount] + sizeof(WORD)) = TEXT('\0');

    lpCandList->dwOffset[lpCandList->dwCount + 1] =
        lpCandList->dwOffset[lpCandList->dwCount] +
        sizeof(WORD) + sizeof(TCHAR);
    lpCandList->dwCount++;

    return;
}


/**********************************************************************/
/* CompEscapeKey()                                                    */
/**********************************************************************/
void PASCAL CompEscapeKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPGUIDELINE         lpGuideLine,
    LPPRIVCONTEXT       lpImcP)
{
    if (!lpGuideLine) {
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel != GL_LEVEL_NOGUIDELINE) {
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        lpGuideLine->dwStrLen = 0;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    }

    if (lpImcP->iImeState != CST_CHOOSE) {
       if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
          lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                               ~(MSG_START_COMPOSITION);
       }
    }


    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;

    if (lpCompStr) {
        InitCompStr(lpCompStr);
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = VK_ESCAPE;
        lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART);
    }

    return;
}

/**********************************************************************/
/* CompBackSpaceKey()                                                 */
/**********************************************************************/
void PASCAL CompBackSpaceKey(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP)
{

    if (lpCompStr->dwCursorPos < sizeof(BYTE)) {
        lpCompStr->dwCursorPos = sizeof(BYTE);
    }

    lpImcP->bSeq[3] = 0;

    // go back a compsoition char
    lpCompStr->dwCursorPos -= sizeof(BYTE);

    // clean the sequence code
    lpImcP->bSeq[lpCompStr->dwCursorPos] = 0;

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = TEXT('\b');
    lpImcP->fdwGcsFlag |= (GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
        GCS_DELTASTART);

    if (!lpCompStr->dwCursorPos) {
        if (lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN)) {
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

        if(lpImcP->iImeState != CST_INIT) {
            lpImcP->iImeState = CST_INIT;
            lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
                lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;
            Finalize(lpIMC, lpCompStr, lpImcP, TEXT('\b'));
            return;
        }

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            InitCompStr(lpCompStr);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_END_COMPOSITION) &
                ~(MSG_START_COMPOSITION);
            return;
        }
    }

    // reading string is composition string for some simple IMEs
    // delta start is the same as cursor position for backspace
    lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
        lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

    Finalize(lpIMC, lpCompStr, lpImcP, TEXT('\b'));

    return;
}

/**********************************************************************/
/* CompStrInfo()                                                      */
/**********************************************************************/
void PASCAL CompStrInfo(
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine,
    WORD                wCharCode)
{
    register DWORD dwCursorPos;

    //
    dwCursorPos = lpCompStr->dwCursorPos;

    // dwCrusorPos limit
    if (dwCursorPos >= lpImeL->nMaxKey) {
        // exceed the max input key limitation
        lpGuideLine->dwLevel = GL_LEVEL_ERROR;
        lpGuideLine->dwIndex = GL_ID_TOOMANYSTROKE;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
        return;
    }

    // set MSG_START_COMPOSITION
    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
              ~(MSG_END_COMPOSITION);
    }

    if (lpImcP->iImeState == CST_INIT) {
        // clean the 4 bytes in one time
        *(LPDWORD)lpImcP->bSeq = 0;
    }


    lpImcP->bSeq[dwCursorPos] = (BYTE)wCharCode;

    // composition/reading string - UsedCode(Full Shape)
    lpImcP->dwCompChar = (DWORD)wCharCode;

    // set reading string for lpCompStr
    *((LPUNAWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset +
        dwCursorPos*sizeof(TCHAR))) = (BYTE)lpImcP->dwCompChar;

    *((LPUNAWORD)((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset +
        dwCursorPos*sizeof(TCHAR))) = ((ATTR_TARGET_CONVERTED << 8)|ATTR_TARGET_CONVERTED);

    // set reading string lenght for lpCompStr
    if (lpCompStr->dwCompReadStrLen <= dwCursorPos) {
        lpCompStr->dwCompReadStrLen += sizeof(BYTE);
    }

    // composition string is reading string for some simple IMEs
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // composition/reading attribute length is equal to reading string length
    lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;

    // delta start from previous cursor position
    lpCompStr->dwDeltaStart = lpCompStr->dwCursorPos;

    // set new cursor with next to the composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;

    // set lpImcp->iImeState
    lpImcP->iImeState = CST_INPUT;

    // tell app, there is a composition char generated
    lpImcP->fdwImeMsg |= MSG_COMPOSITION;

    // set lpImeP->fdwGcsFlag
    lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|GCS_DELTASTART;

    return;
}

/**********************************************************************/
/* Finalize()                                                         */
/* Return vlaue                                                       */
/*      Engine Flag                                                   */
/* Description:                                                       */
/*      Call Engine finalize Chinese word(s) by searching table       */
/*      (Set lpCompStr and lpCandList)                                */
/*      Set lpImeP(iImeState, fdwImeMsg, fdwGcsFlag)                  */
/**********************************************************************/
UINT PASCAL Finalize(
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    WORD                wCharCode)
{
    LPCANDIDATEINFO lpCandInfo;
    LPCANDIDATELIST lpCandList;
    UINT            fEngine;

    if (!lpIMC->hCandInfo) {
        return (0);
    }

    // get lpCandInfo
    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);

    if (!lpCandInfo) {
        return (0);
    }

    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);
    lpCandList->dwCount = 0;
    lpCandList->dwSelection = 0;

    // search the IME tables
    fEngine =Engine(lpCompStr, lpCandList, lpImcP, lpIMC, wCharCode);

    if (fEngine == ENGINE_COMP) {
        lpCandInfo->dwCount  = 1;

        if (((lpCompStr->dwCursorPos < 3) && (wCharCode != TEXT(' ')))
           || ((lpCompStr->dwCursorPos == 3)
           && (wCharCode != TEXT(' ')) && (wCharCode != TEXT('?')))) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
            ImmUnlockIMCC(lpIMC->hCandInfo);
            return (fEngine);
        }

        if(lpCandList->dwCount != 0x0000) {
            // open composition candidate UI window for the string(s)
            if ((lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) ==
                (MSG_ALREADY_OPEN|MSG_CLOSE_CANDIDATE)) {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CHANGE_CANDIDATE) &
                    ~(MSG_CLOSE_CANDIDATE);
            } else if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                lpImcP->fdwImeMsg |= MSG_CHANGE_CANDIDATE;
            } else {
                lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_OPEN_CANDIDATE) &
                    ~(MSG_CLOSE_CANDIDATE);
            }

        }

        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        }
    } else if (fEngine == ENGINE_ASCII) {
    } else if (fEngine == ENGINE_RESAULT) {

        // Set lpImep!   and tell application, there is a reslut string
        lpImcP->fdwImeMsg |= MSG_COMPOSITION;
        lpImcP->dwCompChar = (DWORD)0;
        lpImcP->fdwGcsFlag |= GCS_COMPREAD|GCS_COMP|GCS_CURSORPOS|
            GCS_DELTASTART|GCS_RESULTREAD|GCS_RESULT;

        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }
        // clear  candidate now
        lpCandList->dwCount = 0;
        // set iImeState with CST_INIT
        lpImcP->iImeState = CST_INIT;
        *(LPDWORD)lpImcP->bSeq = 0;
#ifdef CROSSREF
        CrossReverseConv(lpIMC, lpCompStr, lpImcP, lpCandList);
#endif
    }

    ImmUnlockIMCC(lpIMC->hCandInfo);

    return fEngine;
}

/**********************************************************************/
/* CompWord()                                                         */
/**********************************************************************/
void PASCAL CompWord(           // compose the Chinese word(s) according to
                                // input key
    WORD                wCharCode,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPGUIDELINE         lpGuideLine)
{

    // lpComStr=NULL?
    if (!lpCompStr) {
        MessageBeep((UINT)-1);
        return;
    }

    // escape key
    if (wCharCode == VK_ESCAPE) {       // not good to use VK as char, but...
        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);
        return;
    }

    // GuideLine
    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
        lpGuideLine->dwStrLen = 0;
    } else {
        // previous input error cause us trancate some chars
        if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
            lpImcP->bSeq[lpCompStr->dwCursorPos / 2] = 0;
            lpCompStr->dwCompReadStrLen = lpCompStr->dwCompStrLen =
                lpCompStr->dwCursorPos;
            lpCompStr->dwCompReadAttrLen = lpCompStr->dwCompReadStrLen;
            lpCompStr->dwCompAttrLen = lpCompStr->dwCompStrLen;
        }
        lpGuideLine->dwLevel = GL_LEVEL_NOGUIDELINE;
        lpGuideLine->dwIndex = GL_ID_UNKNOWN;
        lpGuideLine->dwStrLen = 0;

        lpImcP->fdwImeMsg |= MSG_GUIDELINE;
    }

    // backspace key
    if (wCharCode == TEXT('\b')) {
        CompBackSpaceKey(lpIMC, lpCompStr, lpImcP);
        return;
    }


    if(wCharCode == TEXT(' ')) {
    } else {
        // build up composition string info
        CompStrInfo(lpCompStr, lpImcP, lpGuideLine, wCharCode);
    }

    Finalize(lpIMC, lpCompStr, lpImcP, wCharCode);    // compsition

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\notify.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    notify.c


++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* GenerateMessage()                                                  */
/**********************************************************************/
void PASCAL GenerateMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{

    if (!hIMC) {
        return;
    } else if (!lpIMC) {
        return;
    } else if (!lpImcP) {
        return;
    } else if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
        return;
    } else {
    }

    lpIMC->dwNumMsgBuf += TranslateImeMessage(NULL, lpIMC, lpImcP);

    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag = 0;

    ImmGenerateMessage(hIMC);
    return;
}

/**********************************************************************/
/* GenerateImeMessage()                                               */
/**********************************************************************/
void PASCAL GenerateImeMessage(
    HIMC           hIMC,
    LPINPUTCONTEXT lpIMC,
    DWORD          fdwImeMsg)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= fdwImeMsg;

    if (fdwImeMsg & MSG_CLOSE_CANDIDATE) {
        lpImcP->fdwImeMsg &= ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
    } else if (fdwImeMsg & (MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE)) {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE);
    }

    if (fdwImeMsg & MSG_END_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_START_COMPOSITION);
    } else if (fdwImeMsg & MSG_START_COMPOSITION) {
        lpImcP->fdwImeMsg &= ~(MSG_END_COMPOSITION);
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* CompCancel()                                                       */
/**********************************************************************/
void PASCAL CompCancel(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    if (!lpIMC->hPrivate) {
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwGcsFlag = (DWORD)0;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        CandEscapeKey(lpIMC, lpImcP);
    } else if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
        LPCOMPOSITIONSTRING lpCompStr;
        LPGUIDELINE         lpGuideLine;

        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
        if (!lpCompStr) {          
            ImmUnlockIMCC(lpIMC->hCompStr);
            ImmUnlockIMCC(lpIMC->hPrivate);
            return;
        }

        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
        if (!lpGuideLine) {          
            ImmUnlockIMCC(lpIMC->hGuideLine);
            ImmUnlockIMCC(lpIMC->hPrivate);
            return;
        }

        CompEscapeKey(lpIMC, lpCompStr, lpGuideLine, lpImcP);

        if (lpGuideLine) {
            ImmUnlockIMCC(lpIMC->hGuideLine);
        }
        if (lpCompStr) {
            ImmUnlockIMCC(lpIMC->hCompStr);
        }
    } else {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* SetString()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL PASCAL SetString(
    HIMC                hIMC,
    LPINPUTCONTEXT      lpIMC,
    LPCOMPOSITIONSTRING lpCompStr,
    LPPRIVCONTEXT       lpImcP,
    LPTSTR               lpszRead,
    DWORD               dwReadLen)
{
    LPCANDIDATELIST lpCandList;
    LPCANDIDATEINFO lpCandInfo;
    LPGUIDELINE lpGuideLine;
    UINT        iRet,ii;
    UINT        MAX_COMP,i;
    WORD  wCode;

    // For Windows NT Unicode,
    // dwCompReadStrLen is the number of the Unicode characters(Not in Bytes)
    // But the above the Parameter dwReadLen is in Bytes.
    // the length of the attribute information is
    // the same as the length in Unicode character counts.
    // Each attribute byte corresponds to each Unicode character of
    // the string.

    //
    // convert from byte count to the string length
    dwReadLen = dwReadLen / sizeof(TCHAR);


    lstrcpy (lpImcP->bSeq,lpszRead);

    if(lpImcP->bSeq[3] == TEXT('?')){
      MAX_COMP = 94;
    } else {
      MAX_COMP = 1;
      }

    if (dwReadLen > 4) {
        return (FALSE);
    }

    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
    if (!lpCandInfo) {
        return (-1);
    }
                                                 
    // get lpCandList and init dwCount & dwSelection
    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    InitCompStr(lpCompStr);
    ClearCand(lpIMC);

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
    if (lpGuideLine) {
        ImmUnlockIMCC(lpIMC->hGuideLine);
    }
    CopyMemory((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompReadStrOffset), lpszRead,
       dwReadLen * sizeof(TCHAR) + sizeof(TCHAR) );
    CopyMemory((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwCompStrOffset),lpszRead,
        dwReadLen * sizeof(TCHAR) + sizeof(TCHAR) );

    lpCompStr->dwCompReadAttrLen = dwReadLen;
    lpCompStr->dwCompAttrLen = lpCompStr->dwCompReadAttrLen;
    for (i = 0; i < dwReadLen; i++) {   // The IME has converted these chars
        *((LPBYTE)lpCompStr + lpCompStr->dwCompReadAttrOffset + i) =
            ATTR_TARGET_CONVERTED;

    }
    lpCompStr->dwCompReadStrLen = dwReadLen;
    lpCompStr->dwCompStrLen = lpCompStr->dwCompReadStrLen;

    // dlta start from 0;
    lpCompStr->dwDeltaStart = 0;
    // cursor is next to composition string
    lpCompStr->dwCursorPos = lpCompStr->dwCompStrLen;


    lpCompStr->dwResultReadClauseLen = 0;
    lpCompStr->dwResultReadStrLen = 0;
    lpCompStr->dwResultClauseLen = 0;
    lpCompStr->dwResultStrLen = 0;

    // set private input context
    lpImcP->iImeState = CST_INPUT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    }

    if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_START_COMPOSITION) &
            ~(MSG_END_COMPOSITION);
    }

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->fdwGcsFlag = GCS_COMPREAD|GCS_COMP|
        GCS_DELTASTART|GCS_CURSORPOS;

    lpImcP->fdwImeMsg |= MSG_GUIDELINE;

    lpCandList->dwCount = 0;

    if (dwReadLen < 4) {
        goto Finalize;
    }

      lpImcP->bSeq[0] = 0;
      lpImcP->bSeq[1] = 0;
      lpImcP->bSeq[2] = 0;
      lpImcP->bSeq[3] = 0;

#if    defined(COMBO_IME)
   if(sImeL.dwRegImeIndex == INDEX_GB){

       for (ii=0;ii<4;ii++) {
          iRet = GBProcessKey(*(LPBYTE)((LPBYTE)lpszRead+ii),lpImcP);
          if (iRet == CST_INPUT) {
             lpImcP->bSeq[ii] = *(LPBYTE)((LPBYTE)lpszRead+ii);
          } else {
          goto Finalize;

          }
       }

       wCode = GBEngine (lpImcP);
       wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
       for (i = 0; i < MAX_COMP;i++, wCode++) {
           AddCodeIntoCand(lpCandList, wCode);
       }

    }else if(sImeL.dwRegImeIndex == INDEX_GBK){
        for (ii=0;ii<4;ii++) {
           iRet = XGBProcessKey(*(LPBYTE)((LPBYTE)lpszRead+ii),lpImcP);
           if (iRet == CST_INPUT) {
              lpImcP->bSeq[ii] = *(LPBYTE)((LPBYTE)lpszRead+ii);
           } else {
           goto Finalize;

           }
        }

        wCode = XGBEngine(lpImcP);
    
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }

    }else if(sImeL.dwRegImeIndex == INDEX_UNICODE){
        for (ii=0;ii<4;ii++) {
           iRet = UnicodeProcessKey(*(LPBYTE)((LPBYTE)lpszRead+ii),lpImcP);
           if (iRet == CST_INPUT) {
              lpImcP->bSeq[ii] = *(LPBYTE)((LPBYTE)lpszRead+ii);
           } else {
               goto Finalize;
           }
        }

        wCode = UnicodeEngine(lpImcP);
        wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
    
        for (i = 0; i < (0x100); i++, wCode++) {
            UnicodeAddCodeIntoCand(lpCandList, wCode);
        }

    }
#else //COMBO_IME
#ifdef GB
   {

       for (ii=0;ii<4;ii++) {
          iRet = GBProcessKey(*(LPBYTE)((LPBYTE)lpszRead+ii),lpImcP);
          if (iRet == CST_INPUT) {
             lpImcP->bSeq[ii] = *(LPBYTE)((LPBYTE)lpszRead+ii);
          } else {
          goto Finalize;

          }
       }

       wCode = GBEngine (lpImcP);
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);
                for (i = 0; i < MAX_COMP;i++, wCode++) {
                AddCodeIntoCand(lpCandList, wCode);
            }

    } 
#else
    {
        for (ii=0;ii<4;ii++) {
           iRet = XGBProcessKey(*(LPBYTE)((LPBYTE)lpszRead+ii),lpImcP);
           if (iRet == CST_INPUT) {
              lpImcP->bSeq[ii] = *(LPBYTE)((LPBYTE)lpszRead+ii);
           } else {
           goto Finalize;

           }
        }

        wCode = XGBEngine(lpImcP);
    
                wCode = HIBYTE(wCode) | (LOBYTE(wCode) << 8);

                for (i = 0; i < (0x7e-0x40+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }
                wCode ++;
                for (i = 0; i < (0xfe-0x80+1); i++, wCode++) {
                XGBAddCodeIntoCand(lpCandList, wCode);
                }

    }
#endif //GB    
#endif //COMBO_IME

    if (lpCandList->dwCount == 1) {
                lstrcpy((LPTSTR)((LPBYTE)lpCompStr + lpCompStr->dwResultStrOffset),
                (LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]));

            // calculate result string length
                lpCompStr->dwResultStrLen =
                lstrlen((LPTSTR)((LPBYTE)lpCandList + lpCandList->dwOffset[0]));

    lpImcP->fdwImeMsg |= MSG_COMPOSITION;
    lpImcP->dwCompChar = (DWORD)0;
    lpImcP->fdwGcsFlag |= GCS_CURSORPOS|GCS_RESULTREAD|GCS_RESULT;

    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
            ~(MSG_OPEN_CANDIDATE);
    } else {
        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
    }

    lpImcP->iImeState = CST_INIT;
    *(LPDWORD)lpImcP->bSeq = 0;
    lpCandList->dwCount = 0;


    } else if(lpCandList->dwCount > 1) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg |MSG_OPEN_CANDIDATE ) &
            ~(MSG_CLOSE_CANDIDATE);

    } else if(lpCandList->dwCount == 0) {
        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg |MSG_CLOSE_CANDIDATE ) &
            ~(MSG_OPEN_CANDIDATE);

    }
 ;
 Finalize:
    GenerateMessage(hIMC, lpIMC, lpImcP);

    return (TRUE);
}

/**********************************************************************/
/* ImeSetCompositionString()                                          */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeSetCompositionString(
    HIMC   hIMC,
    DWORD  dwIndex,
    LPVOID lpComp,
    DWORD  dwCompLen,
    LPVOID lpRead,
    DWORD  dwReadLen)
{

    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    BOOL                fRet;

    if (!hIMC) {
        return (FALSE);
    }

    // composition string must  == reading string
    // reading is more important
    if (!dwReadLen) {
        dwReadLen = dwCompLen;
    }

    // composition string must  == reading string
    // reading is more important
    if (!lpRead) {
        lpRead = lpComp;
    }

    if (!dwReadLen) {
        lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
        if (!lpIMC) {
            return (FALSE);
        }

        CompCancel(hIMC, lpIMC);
        ImmUnlockIMC(hIMC);
        return (TRUE);
    } else if (!lpRead) {
        return (FALSE);
    } else if (!dwCompLen) {
    } else if (!lpComp) {
    } else if (dwReadLen != dwCompLen) {
        return (FALSE);
    } else if (lpRead == lpComp) {
    } else if (!lstrcmp(lpRead, lpComp)) {
        // composition string must  == reading string
    } else {
        // composition string != reading string
        return (FALSE);
    }

    if (dwIndex != SCS_SETSTR) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    if (!lpIMC->hCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if (!lpCompStr) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpCompStr) {
        ImmUnlockIMCC(lpIMC->hCompStr);
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    fRet = SetString(hIMC, lpIMC, lpCompStr, lpImcP, lpRead, dwReadLen);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* ToggleSoftKbd()                                                    */
/**********************************************************************/
void PASCAL ToggleSoftKbd(
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC)
{
    LPPRIVCONTEXT lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }

    lpImcP->fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);

    return;
}

/**********************************************************************/
/* NotifySelectCand()                                                 */
/**********************************************************************/
void PASCAL NotifySelectCand( // app tell IME that one candidate string is
                              // selected (by mouse or non keyboard action
                              // - for example sound)
    HIMC            hIMC,
    LPINPUTCONTEXT  lpIMC,
    LPCANDIDATEINFO lpCandInfo,
    DWORD           dwIndex,
    DWORD           dwValue)
{
    LPCANDIDATELIST     lpCandList;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;

    if (!lpCandInfo) {
        return;
    }

    if (dwIndex >= lpCandInfo->dwCount) {
        // wanted candidate list is not created yet!
        return;
    } else if (dwIndex == 0) {
        if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
            return;         // not implemented yet
        }
    }

    lpCandList = (LPCANDIDATELIST)
        ((LPBYTE)lpCandInfo + lpCandInfo->dwOffset[0]);

    // the selected value even more than the number of total candidate
    // strings, it is imposible. should be error of app
    if (dwValue >= lpCandList->dwCount) {
        return;
    }

    // app select this candidate string
    lpCandList->dwSelection = dwValue;

    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
    if(!lpCompStr){
        return;
    }
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if(!lpCompStr){
        ImmUnlockIMCC(lpIMC->hCompStr);
        return;
    }

    // translate into message buffer
    SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

    // let app generate those messages in its message loop
    GenerateMessage(hIMC, lpIMC, lpImcP);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMCC(lpIMC->hCompStr);

    return;
}

/**********************************************************************/
/* NotifyIME()                                                        */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI NotifyIME(
    HIMC        hIMC,
    DWORD       dwAction,
    DWORD       dwIndex,
    DWORD       dwValue)
{
    LPINPUTCONTEXT lpIMC;
    DWORD          fdwImeMsg;
    BOOL           fRet;

    fRet = FALSE;

    if (!hIMC) {
        return (fRet);
    }

    switch (dwAction) {
    case NI_OPENCANDIDATE:      // after a composition string is determined
                                // if an IME can open candidate, it will.
                                // if it can not, app also can not open it.
    case NI_CLOSECANDIDATE:
        return (fRet);          // not supported
    case NI_SELECTCANDIDATESTR:
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
        break;                  // need to handle it
    case NI_CHANGECANDIDATELIST:
        break;
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
        case IMC_SETOPENSTATUS:
            break;              // need to handle it
        case IMC_SETCANDIDATEPOS:
        case IMC_SETCOMPOSITIONFONT:
        case IMC_SETCOMPOSITIONWINDOW:
            return (TRUE);      // not important to the IME
        default:
            return (fRet);      // not supported
        }
        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_COMPLETE:
            break;              // need to handle it
        case CPS_CONVERT:       // all composition string can not be convert
        case CPS_REVERT:        // any more, it maybe work for some
                                // intelligent phonetic IMEs
            return (fRet);
        case CPS_CANCEL:
            break;              // need to handle it
        default:
            return (fRet);      // not supported
        }
        break;                  // need to handle it
    default:
        return (fRet);          // not supported
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (fRet);
    }

    fRet = TRUE;

    switch (dwAction) {
    case NI_CONTEXTUPDATED:
        switch (dwValue) {
        case IMC_SETCONVERSIONMODE:
            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_CHARCODE) {
                // reject CHARCODE
                lpIMC->fdwConversion &= ~IME_CMODE_CHARCODE;
                MessageBeep((UINT)-1);
                break;
            }

            fdwImeMsg = 0;

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_NOCONVERSION) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_EUDC) {
                lpIMC->fdwConversion |= IME_CMODE_NATIVE;
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_SYMBOL);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & IME_CMODE_SOFTKBD) {

                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;

            }

            if ((lpIMC->fdwConversion ^ dwIndex) == IME_CMODE_NATIVE) {
                lpIMC->fdwConversion &= ~(IME_CMODE_CHARCODE|
                    IME_CMODE_NOCONVERSION|IME_CMODE_EUDC);
                fdwImeMsg |= MSG_IMN_UPDATE_SOFTKBD;
            }

            if (fdwImeMsg) {
                GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
            }

            if ((lpIMC->fdwConversion ^ dwIndex) & ~(IME_CMODE_FULLSHAPE|
                IME_CMODE_SOFTKBD)) {
            } else {
                break;
            }

            CompCancel(hIMC, lpIMC);
            break;
        case IMC_SETOPENSTATUS:
            if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                GenerateImeMessage(hIMC, lpIMC, MSG_IMN_UPDATE_SOFTKBD);
            }
            CompCancel(hIMC, lpIMC);
            break;
        default:
            break;
        }
        break;
    case NI_SELECTCANDIDATESTR:
        if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
            if(!lpCandInfo){
                fRet = FALSE;
                break;
            }

            NotifySelectCand(hIMC, lpIMC, lpCandInfo, dwIndex, dwValue);

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_CHANGECANDIDATELIST:
        fdwImeMsg = 0;
        
        fdwImeMsg |= MSG_CHANGE_CANDIDATE;
        GenerateImeMessage(hIMC, lpIMC, fdwImeMsg);
        
        break;
    case NI_SETCANDIDATE_PAGESTART:
    case NI_SETCANDIDATE_PAGESIZE:
        if (dwIndex != 0) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->fOpen) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
            fRet = FALSE;
            break;
        } else if (lpIMC->fdwConversion & (IME_CMODE_EUDC|IME_CMODE_SYMBOL)) {
            fRet = FALSE;
            break;
        } else if (!lpIMC->hCandInfo) {
            fRet = FALSE;
            break;
        } else {
            LPCANDIDATEINFO lpCandInfo;
            LPCANDIDATELIST lpCandList;

            lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
            if (!lpCandInfo) {
                fRet = FALSE;
                break;
            }

            lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                lpCandInfo->dwOffset[0]);

            if (dwAction == NI_SETCANDIDATE_PAGESTART) {
                if (dwValue < lpCandList->dwCount) {
                    lpCandList->dwPageStart = lpCandList->dwSelection =
                        dwValue;
                }
            } else {
                if (lpCandList->dwCount) {
                    lpCandList->dwPageSize = dwValue;
                }
            }

            ImmUnlockIMCC(lpIMC->hCandInfo);
        }

        break;
    case NI_COMPOSITIONSTR:
        switch (dwIndex) {
        case CPS_CANCEL:
            CompCancel(hIMC, lpIMC);
            break;
        case CPS_COMPLETE:
            {
                LPPRIVCONTEXT lpImcP;

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    break;
                }

                if (lpImcP->iImeState == CST_INIT) {
                    CompCancel(hIMC, lpIMC);
                    // can not do any thing
                } else if (lpImcP->iImeState == CST_CHOOSE) {
                    LPCOMPOSITIONSTRING lpCompStr;
                    LPCANDIDATEINFO     lpCandInfo;

                    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                    if(!lpCompStr){
                        break;
                    }


                    lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
                    if (lpCandInfo) {
                        LPCANDIDATELIST lpCandList;

                        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                            lpCandInfo->dwOffset[0]);

                        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

                       ImmUnlockIMCC(lpIMC->hCandInfo);

                       GenerateMessage(hIMC, lpIMC, lpImcP);
                    }

                    if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
                } else if ((lpIMC->fdwConversion & (IME_CMODE_NATIVE|
                    IME_CMODE_EUDC|IME_CMODE_SYMBOL)) != IME_CMODE_NATIVE) {
                    CompCancel(hIMC, lpIMC);
                } else if (lpImcP->iImeState == CST_INPUT) {
                    LPCOMPOSITIONSTRING lpCompStr;
                    LPGUIDELINE         lpGuideLine;
                    LPCANDIDATEINFO     lpCandInfo;

                    lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                    if(!lpCompStr){
                        break;
                    }

                    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
                    if(!lpGuideLine){
                        ImmUnlockIMCC(lpIMC->hCompStr);
                        break;
                    }


                    CompWord(' ', lpIMC, lpCompStr, lpImcP, lpGuideLine);

                    if (lpImcP->iImeState == CST_INPUT) {
                        CompCancel(hIMC, lpIMC);
                    } else if (lpImcP->iImeState != CST_CHOOSE) {
                    } else if (lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(
                        lpIMC->hCandInfo)) {
                        LPCANDIDATELIST lpCandList;

                        lpCandList = (LPCANDIDATELIST)((LPBYTE)lpCandInfo +
                            lpCandInfo->dwOffset[0]);

//                        SelectOneCand(hIMC, lpIMC, lpCompStr, lpImcP, lpCandList);
                        SelectOneCand(lpIMC, lpCompStr, lpImcP, lpCandList);

                       ImmUnlockIMCC(lpIMC->hCandInfo);
                    } else {
                    }

                    if (lpCompStr) ImmUnlockIMCC(lpIMC->hCompStr);
                    if (lpGuideLine) ImmUnlockIMCC(lpIMC->hGuideLine);

                    // don't phrase predition under this case
                    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                        lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                            ~(MSG_OPEN_CANDIDATE|MSG_CHANGE_CANDIDATE);
                    } else {
                        lpImcP->fdwImeMsg &= ~(MSG_CLOSE_CANDIDATE|MSG_OPEN_CANDIDATE);
                    }

                    GenerateMessage(hIMC, lpIMC, lpImcP);
                } else {
                    CompCancel(hIMC, lpIMC);
                }

                ImmUnlockIMCC(lpIMC->hPrivate);
            }
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }

    ImmUnlockIMC(hIMC);
    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\toascii.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    toascii.c


++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* IsUsedCode()                                                       */
/* Return Value:                                                      */
/*      TURE: is UsedCode;  FALSE: is'nt UsedCode;                    */
/**********************************************************************/
BOOL IsUsedCode(
    WORD wCharCode)
{
          WORD wFlg;

          for(wFlg=0; wFlg<sImeG.wNumCodes; wFlg++)
                if (wCharCode == sImeG.UsedCodes[wFlg])
                    break;
          if(wFlg < sImeG.wNumCodes)
                return (TRUE);
      return (FALSE);
}

/**********************************************************************/
/* GBProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to (CST_      */
/**********************************************************************/
UINT PASCAL GBProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    LPPRIVCONTEXT  lpImcP)
{
    if (!lpImcP) {
        return (CST_INVALID);
    }

    // check space 
     if (wCharCode == TEXT(' ')) {
        if (lpImcP->bSeq[0] && lpImcP->bSeq[1]) {
                        return (CST_INPUT);
                } else if (!lpImcP->bSeq[0]) {
            return (CST_ALPHANUMERIC);
                } else {
            return (CST_INVALID_INPUT);
                }
         }
    // check finalize char
      if ((wCharCode >= TEXT('0') && wCharCode <= TEXT('9'))
       ||(wCharCode >= TEXT('a') && wCharCode <= TEXT('f'))
       ||(wCharCode == TEXT('?'))) {

      if (!lpImcP->bSeq[0]) {
        if (wCharCode == TEXT('?')){
            // 0x0??? - 0xF??? is OK
            return (CST_ALPHANUMERIC);
        } else {
            // there is no 0x0??? - 0x7???
                        lpImcP->bSeq[1] = TEXT('\0');
            return (CST_INPUT);
        }

      } else if (!lpImcP->bSeq[1]) {

         if (lpImcP->bSeq[0] >=TEXT('0') && lpImcP->bSeq[0] <= TEXT('9')){ //Area
           if ((lpImcP->bSeq[0] == TEXT('0') && wCharCode == TEXT('0'))
               ||(lpImcP->bSeq[0] == TEXT('9') && wCharCode >= TEXT('5'))
               ||(wCharCode >= TEXT('a') && wCharCode <= TEXT('f'))
               ||(wCharCode == TEXT('?'))) {
               // there is less than 95 area and bigger than 0 area
                  return (CST_INVALID_INPUT);
           }
           else {
                                  lpImcP->bSeq[2] = TEXT('\0');
                  return (CST_INPUT);
           }
         }

         if (lpImcP->bSeq[0] >= TEXT('a') && lpImcP->bSeq[0] <= TEXT('f')) { //GB
           if ((lpImcP->bSeq[0] == TEXT('a') && wCharCode == TEXT('0'))
               ||(lpImcP->bSeq[0] == TEXT('f') && wCharCode == TEXT('f'))
               ||(wCharCode == TEXT('?'))) {
                  // there is less than 95 area and bigger than 0 area
                  return (CST_INVALID_INPUT);
           }
           else {
                                  lpImcP->bSeq[2] = TEXT('\0');
                  return (CST_INPUT);
           }
         }

      } else if (!lpImcP->bSeq[2]) {

         if (wCharCode == TEXT('?')){
                  return (CST_INPUT);
         }
         if (lpImcP->bSeq[0] >= TEXT('0') && lpImcP->bSeq[0] <= TEXT('9')){ //Area
           if (wCharCode >= TEXT('0') && wCharCode <= TEXT('9')) {
                          lpImcP->bSeq[3] = TEXT('\0');
              return (CST_INPUT);
           } else {
              return (CST_INVALID_INPUT);
           }

         }
     
         if (lpImcP->bSeq[0] >= TEXT('a') && lpImcP->bSeq[0] <= TEXT('f')) { //GB
           if (wCharCode >= TEXT('a') && wCharCode <= TEXT('f')) {
                          lpImcP->bSeq[3] = TEXT('\0');
              return (CST_INPUT);
           } else {
              return (CST_INVALID_INPUT);
           }
         }
      } else if (!lpImcP->bSeq[3]) {

         if (lpImcP->bSeq[2] == TEXT('?')) {
           if (wCharCode == TEXT('?')) {
              return (CST_INPUT);
           }else{
              return (CST_INVALID_INPUT);
           }
         }
         if (lpImcP->bSeq[0] >= TEXT('0') && lpImcP->bSeq[0] <= TEXT('9')) { //Area
           if ((lpImcP->bSeq[2] == TEXT('0') && wCharCode == TEXT('0'))
               ||(lpImcP->bSeq[2] == TEXT('9') && wCharCode >= TEXT('5'))
               ||(wCharCode >= TEXT('a') && wCharCode <= TEXT('f'))
               ||(wCharCode == TEXT('?'))) {
                  // there is less than 95 area and bigger than 0 area
                  return (CST_INVALID_INPUT);
           }
           else {
                  return (CST_INPUT);
           }
         }
         if (lpImcP->bSeq[0] >= TEXT('a') && lpImcP->bSeq[0] <= TEXT('f')) { //GB
           if ((lpImcP->bSeq[2] == TEXT('a') && wCharCode == TEXT('0'))
               ||(lpImcP->bSeq[2] == TEXT('f') && wCharCode == TEXT('f'))
               ||(wCharCode == TEXT('?'))){
                  // there is less than 95 area and bigger than 0 area
                  return (CST_INVALID_INPUT);
           }
           else {
                  return (CST_INPUT);
           }
         }
      } else {
              return (CST_INVALID_INPUT);
          }

    } else if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
        return (CST_ALPHANUMERIC);
        } else {
                return (CST_INVALID_INPUT);
        }

        return (CST_INVALID_INPUT);
}

#if defined(COMBO_IME)
/**********************************************************************/
/* UnicodeProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to (CST_      */
/**********************************************************************/
UINT PASCAL UnicodeProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    LPPRIVCONTEXT  lpImcP)
{
    if (!lpImcP) {
        return (CST_INVALID);
    }

    if (wCharCode == TEXT(' ')) {
        if (lpImcP->bSeq[0] && lpImcP->bSeq[1]) {
                        return (CST_INPUT);
                } else if (!lpImcP->bSeq[0]) {
            return (CST_ALPHANUMERIC);
                } else {
            return (CST_INVALID_INPUT);
                }
        }

     // check finalize char
         // 0000 -- ffff

    if ((wCharCode >= TEXT('0') && wCharCode <= TEXT('9'))
       ||(wCharCode >= TEXT('a') && wCharCode <= TEXT('f'))
       ||(wCharCode == TEXT('?'))) {

         if (wCharCode == TEXT('?')){
                        if (!lpImcP->bSeq[2]) {
                  return (CST_INPUT);
                 }else
                                 return(CST_INVALID_INPUT);
                 }else{
                  return (CST_INPUT);
         }
        } else if(lpImcP->bSeq[0]){
              return (CST_INVALID_INPUT);
        } else 
                return (CST_ALPHANUMERIC);

}
#endif //COMBO_IME

/**********************************************************************/
/* XGBProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to (CST_      */
/**********************************************************************/
UINT PASCAL XGBProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    LPPRIVCONTEXT  lpImcP)
{
    if (!lpImcP) {
        return (CST_INVALID);
    }

     if (wCharCode == TEXT(' ')) {
        if (lpImcP->bSeq[0] && lpImcP->bSeq[1]) {
                        return (CST_INPUT);
                } else if (!lpImcP->bSeq[0]) {
            return (CST_ALPHANUMERIC);
                } else {
            return (CST_INVALID_INPUT);
                }
         }

     // check finalize char
     //lead  byte 81 - fe
     //trail byte 40 - 7e, 80 - fe

     if ((wCharCode >= TEXT('0') && wCharCode <= TEXT('9'))
       ||(wCharCode >= TEXT('a') && wCharCode <= TEXT('f'))
       ||(wCharCode == TEXT('?'))) {

      if (!lpImcP->bSeq[0]) {
        if (wCharCode == TEXT('?')) {
            // 0x0??? - 0xF??? is OK
            // : - @ was filted
            return (CST_ALPHANUMERIC);

        }else if (wCharCode >=TEXT('8') && wCharCode <= TEXT('f')){
            // 0x0??? - 0xF??? is OK
                        lpImcP->bSeq[1] = TEXT('\0');
            return (CST_INPUT);
            
        } else {
            // there is no 0x0??? - 0x7???
            return (CST_INVALID_INPUT);
        }

      } else if (!lpImcP->bSeq[1]) {

           if ((lpImcP->bSeq[0] == TEXT('f') && wCharCode == TEXT('f'))
             ||(lpImcP->bSeq[0] == TEXT('8') && wCharCode == TEXT('0'))
             ||(wCharCode == TEXT('?'))) {
               //XGB is 81 - fe
                  return (CST_INVALID_INPUT);
           }
           else {
                                  lpImcP->bSeq[2] = TEXT('\0');
                  return (CST_INPUT);
           }

      } else if (!lpImcP->bSeq[2]) {

         if (wCharCode == TEXT('?')){
                                lpImcP->bSeq[3] = TEXT('\0');
                return (CST_INPUT);
         }

           if (wCharCode >= TEXT('4') && wCharCode <= TEXT('f')) {
                          lpImcP->bSeq[3] = TEXT('\0');
              return (CST_INPUT);
           } else {
              return (CST_INVALID_INPUT);
           }

      } else if (!lpImcP->bSeq[3]) {

         if (lpImcP->bSeq[2] == TEXT('?')) {
           if (wCharCode == TEXT('?')) {
              return (CST_INPUT);
           }else{
              return (CST_INVALID_INPUT);
           }
         }
           if ((lpImcP->bSeq[2] == TEXT('7') && wCharCode == TEXT('f'))
             ||(lpImcP->bSeq[2] == TEXT('f') && wCharCode == TEXT('f'))
             ||(wCharCode == TEXT('?'))) {
                  //trail byte
                  //40 - 7e, 80 - fe

                  return (CST_INVALID_INPUT);
           }
           else {
                  return (CST_INPUT);
           }
      } else {
              return (CST_INVALID_INPUT);
          }

    } else if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
        return (CST_ALPHANUMERIC);
        } else {
                return (CST_INVALID_INPUT);
        }

}

/**********************************************************************/
/* ProcessKey()                                                       */
/* Return Value:                                                      */
/*      different state which input key will change IME to (CST_      */
/**********************************************************************/
UINT PASCAL ProcessKey(     // this key will cause the IME go to what state
    WORD           wCharCode,
    UINT           uVirtKey,
    UINT           uScanCode,
    LPBYTE         lpbKeyState,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{

    if (!lpIMC) {
        return (CST_INVALID);
    }

    if (!lpImcP) {
        return (CST_INVALID);
    }


    // filter system key (alt,alt+,ctrl,shift)
    // and fOpen, IME_CMODE_NOCONVERSION
    if (uVirtKey == VK_MENU) {                  // ALT key
        return (CST_INVALID);
    } else if (uScanCode & KF_ALTDOWN) {    // ALT-xx key
        return (CST_INVALID);
    } else if (uVirtKey == VK_CONTROL) {    // CTRL key
        return (CST_INVALID);
    } else if (uVirtKey == VK_SHIFT) {      // SHIFT key
        return (CST_INVALID);
    } else if (!lpIMC->fOpen) {             // don't compose in 
                                            // close status
        return (CST_INVALID);
    } else if (lpIMC->fdwConversion & IME_CMODE_NOCONVERSION) {
                // Caps on/off
                if(uVirtKey == VK_CAPITAL) {
                        return (CST_CAPITAL);
                }else           
                        return (CST_INVALID);
        
    } else if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE) {
        return (CST_INVALID);
    } else {
    }

    // Caps on/off
    if(uVirtKey == VK_CAPITAL) {
        return (CST_CAPITAL);
        }

    if ((lpIMC->fdwConversion & IME_CMODE_SOFTKBD)
       && (lpImeL->dwSKWant != 0)){
        if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
          return (CST_SOFTKB);
                } else {
          return (CST_INVALID);
                }
    }
        
    // candidate alaredy open,  <,>,pageup,pagedown,?,ECS,key
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
        if (uVirtKey == VK_PRIOR) {                     // PageUp
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_NEXT) {       // PageDown
            return (CST_CHOOSE);
        } else if (wCharCode == TEXT('-')) {
            return (CST_CHOOSE);
        } else if (wCharCode == TEXT('=')) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_HOME) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_END) {
            return (CST_CHOOSE);
        } else if (uVirtKey == VK_ESCAPE) {     // Esc
            return (CST_CHOOSE);
        } else if (wCharCode == TEXT(' ')) {
            return (CST_CHOOSE);
        } else {
        }
    }


    // candidate alaredy open, shift + num key
    if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            if ((wCharCode >= TEXT('0')) && wCharCode <= TEXT('9')) {
                return (CST_CHOOSE);
            }
    }

    // IME_CMODE_CHARCODE
    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {    //Code Input Mode
            return (CST_INVALID);
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_NATIVE)) {
        // alphanumeric mode
        if (wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
            return (CST_ALPHANUMERIC);
        } else {
            return (CST_INVALID);
        }
    } else if (wCharCode == TEXT('?')) {
    } else if (wCharCode == TEXT(' ')) {
        } else if(wCharCode >= TEXT(' ') && wCharCode <= TEXT('~')) {
                if(!IsUsedCode(wCharCode)
                && lpImcP->iImeState != CST_INIT)
            return (CST_INVALID_INPUT);
    }

    // Esc key
    if (uVirtKey == VK_ESCAPE) {
        register LPGUIDELINE lpGuideLine;
        register UINT        iImeState;

        lpGuideLine = ImmLockIMCC(lpIMC->hGuideLine);
                if(!lpGuideLine){
            return (CST_INVALID);
                }
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            iImeState = CST_INPUT;
        } else if (!lpGuideLine) {
            iImeState = CST_INVALID;
        } else if (lpGuideLine->dwLevel == GL_LEVEL_NOGUIDELINE) {
            iImeState = CST_INVALID;
        } else {
            // need this key to clean information string or guideline state
            iImeState = CST_INPUT;
        }

        ImmUnlockIMCC(lpIMC->hGuideLine);

        return (iImeState);
    } 
    
    // BackSpace Key
    else if (uVirtKey == VK_BACK) {
        if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
            return (CST_INPUT);
        } else {
            return (CST_INVALID);
        }
    }
    
    // NumPad key and Other Input vailid key
    else if (uVirtKey >= VK_NUMPAD0 && uVirtKey <= VK_DIVIDE) {
        return (CST_ALPHANUMERIC);
    } else if (wCharCode > TEXT('~')) {
        return (CST_INVALID);
    } else if (wCharCode < TEXT(' ')) {
        return (CST_INVALID);
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
    } 
    else {
    }
    if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {      

//        if (lpImcP->fdwGB & IME_SELECT_GB) {
#if defined(COMBO_IME)
                switch(sImeL.dwRegImeIndex){
                case INDEX_GB:
                        return (GBProcessKey(wCharCode,lpImcP));
                case INDEX_GBK:
                        return (XGBProcessKey (wCharCode,lpImcP));
                case INDEX_UNICODE:
                        return(UnicodeProcessKey(wCharCode, lpImcP));
                }
#else //COMBO_IME
#ifdef GB
          return (GBProcessKey(wCharCode,lpImcP));

//        } else {
#else
          return (XGBProcessKey (wCharCode,lpImcP));
//          }
#endif //GB
#endif //COMBO_IME
     }

  return (CST_INVALID);
}

/**********************************************************************/
/* ImeProcessKey()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeProcessKey(   // if this key is need by IME?
    HIMC   hIMC,
    UINT   uVirtKey,
    LPARAM lParam,
    CONST LPBYTE lpbKeyState)
{
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    BYTE           szAscii[4];
    int            nChars;
    int            iRet;
    BOOL           fRet;

    // can't compose in NULL hIMC
    if (!hIMC) {
        return (FALSE);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return (FALSE);
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        return (FALSE);
    }

    nChars = ToAscii(uVirtKey, HIWORD(lParam), lpbKeyState,
                (LPVOID)szAscii, 0);

    if (!nChars) {
        szAscii[0] = 0;
    }

    iRet = ProcessKey((WORD)szAscii[0], uVirtKey, HIWORD(lParam), lpbKeyState, lpIMC, lpImcP);
    if(iRet == CST_INVALID) {
        fRet = FALSE;
    } else if((iRet == CST_INPUT) && (uVirtKey == TEXT('\b'))
             && (lpImcP->iImeState == CST_INIT)) {
        lpImcP->fdwImeMsg = ((lpImcP->fdwImeMsg | MSG_END_COMPOSITION)
                            & ~(MSG_START_COMPOSITION)) & ~(MSG_IN_IMETOASCIIEX);

        if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            ClearCand(lpIMC);
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE);
        }

            GenerateMessage(hIMC, lpIMC, lpImcP);
        fRet = FALSE;
    } else if(uVirtKey == VK_CAPITAL) {
        DWORD fdwConversion;
#ifdef LATER
            if (lpbKeyState[VK_CAPITAL] & 0x01) {
            // change to native mode
            fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
                        uCaps = 0;
                } else {
            // change to alphanumeric mode
            fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                IME_CMODE_NATIVE | IME_CMODE_EUDC);
                        uCaps = 1;
                }
#else
                if (lpbKeyState[VK_CAPITAL] & 0x01) {
            // change to alphanumeric mode
            fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                IME_CMODE_NATIVE | IME_CMODE_EUDC);
                        uCaps = 1;
                } else {
            // change to native mode
            fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE)&
                ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC); 
                        uCaps = 0;
        }
#endif //LATER
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        fRet = FALSE;
    } else if((iRet == CST_ALPHANUMERIC)
              && !(lpIMC->fdwConversion & IME_CMODE_FULLSHAPE)
                          && (uVirtKey == VK_SPACE)) {
        fRet = FALSE;
    } else {
        fRet = TRUE;
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (fRet);
}

/**********************************************************************/
/* TranslateSymbolChar()                                              */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateSymbolChar(
    LPTRANSMSGLIST lpTransBuf,
    WORD    wSymbolCharCode,
    BOOL    SymbolMode)
{
    UINT uRet;
    LPTRANSMSG lpTransMsg;

    uRet = 0;
    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
#ifdef UNICODE
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)wSymbolCharCode;
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;
#else
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wSymbolCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
    uRet++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wSymbolCharCode);
    lpTransMsg->lParam 1UL;
    uRet++;
#endif

    if(SymbolMode) {
        lpTransMsg = lpTransBuf->TransMsg;

#ifdef UNICODE
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)wSymbolCharCode;
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;
#else
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)HIBYTE(wSymbolCharCode);
        lpTransMsg->lParam  = 1UL;
        lpTransMsg++;
        uRet++;

        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = (DWORD)LOBYTE(wSymbolCharCode);
        lpTransMsg->lParam  = 1UL;
        uRet++;
#endif
    }

    return (uRet);         // generate two messages
}

/**********************************************************************/
/* TranslateFullChar()                                                */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateFullChar(
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    // if your IME is possible to generate over ? messages,
    // you need to take care about it
    LPTRANSMSG lpTransMsg;

    wCharCode = sImeG.wFullABC[wCharCode - TEXT(' ')];

    lpTransMsg = lpTransBuf->TransMsg;

    // NT need to modify this!
#ifdef UNICODE
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)wCharCode;
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;
#else
    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)HIBYTE(wCharCode);
    lpTransMsg->lParam  = 1UL;
    lpTransMsg++;

    lpTransMsg->message = WM_CHAR;
    lpTransMsg->wParam  = (DWORD)LOBYTE(wCharCode);
    lpTransMsg->lParam  = 1UL;
#endif
    return (2);         // generate two messages
}
 
/**********************************************************************/
/* TranslateToAscii()                                                 */
/* Return Value:                                                      */
/*      the number of translated chars                                */
/**********************************************************************/
UINT PASCAL TranslateToAscii(       // translate the key to WM_CHAR
                                    // as keyboard driver
    UINT    uVirtKey,
    UINT    uScanCode,
    LPTRANSMSGLIST lpTransBuf,
    WORD    wCharCode)
{
    LPTRANSMSG lpTransMsg;

    lpTransMsg = lpTransBuf->TransMsg;

    if (wCharCode) {                    // one char code
        lpTransMsg->message = WM_CHAR;
        lpTransMsg->wParam  = wCharCode;
        lpTransMsg->lParam  = (uScanCode << 16) | 1UL;
        return (1);
    }

    // no char code case
    return (0);
}

/**********************************************************************/
/* TranslateImeMessage()                                              */
/* Return Value:                                                      */
/*      the number of translated messages                             */
/**********************************************************************/
UINT PASCAL TranslateImeMessage(
    LPTRANSMSGLIST lpTransBuf,
    LPINPUTCONTEXT lpIMC,
    LPPRIVCONTEXT  lpImcP)
{
    UINT uNumMsg;
    UINT i;
    BOOL bLockMsgBuf;
    LPTRANSMSG lpTransMsg;

    uNumMsg = 0;
    bLockMsgBuf = FALSE;

    for (i = 0; i < 2; i++) {
        if (lpImcP->fdwImeMsg & MSG_CLOSE_CANDIDATE) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_CLOSECANDIDATE;
                    lpTransMsg->lParam  = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_OPEN);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_END_COMPOSITION) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_START) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_ENDCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg &= ~(MSG_ALREADY_START);
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_START_COMPOSITION) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_STARTCOMPOSITION;
                    lpTransMsg->wParam  = 0;
                    lpTransMsg->lParam = 0;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_START;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_COMPOSITIONPOS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_SETCOMPOSITIONWINDOW;
                lpTransMsg->lParam = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_COMPOSITION) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_COMPOSITION;
                lpTransMsg->wParam  = (DWORD)lpImcP->dwCompChar;
                lpTransMsg->lParam = (DWORD)lpImcP->fdwGcsFlag;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_GUIDELINE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_GUIDELINE;
                lpTransMsg->lParam = 0;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_OPEN_CANDIDATE) {
            if (!(lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
                if (!i) {
                    uNumMsg++;
                } else {
                    lpTransMsg->message = WM_IME_NOTIFY;
                    lpTransMsg->wParam  = IMN_OPENCANDIDATE;
                    lpTransMsg->lParam = 0x0001;
                    lpTransMsg++;
                    lpImcP->fdwImeMsg |= MSG_ALREADY_OPEN;
                }
            }
        }

        if (lpImcP->fdwImeMsg & MSG_CHANGE_CANDIDATE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_CHANGECANDIDATE;
                lpTransMsg->lParam = 0x0001;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_SOFTKBD) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_UPDATE_SOFTKBD;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_UPDATE_STATUS) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_UPDATE_STATUS;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_IMN_DESTROYCAND) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_IME_NOTIFY;
                lpTransMsg->wParam  = IMN_PRIVATE;
                lpTransMsg->lParam = IMN_PRIVATE_DESTROYCANDWIN;
                lpTransMsg++;
            }
        }

        if (lpImcP->fdwImeMsg & MSG_BACKSPACE) {
            if (!i) {
                uNumMsg++;
            } else {
                lpTransMsg->message = WM_CHAR;
                lpTransMsg->wParam  = TEXT('\b');
                lpTransMsg->lParam  = 0x000e;
                lpTransMsg++;
            }
        }

        if (!i) {
            HIMCC hMem;

            if (!uNumMsg) {
                return (uNumMsg);
            }

            if (lpImcP->fdwImeMsg & MSG_IN_IMETOASCIIEX) {
                UINT uNumMsgLimit;

                uNumMsgLimit = lpTransBuf->uMsgCount;

                if (uNumMsg <= uNumMsgLimit) {
                    lpTransMsg = lpTransBuf->TransMsg;
                    continue;
                }
            }

            // we need to use message buffer
            if (!lpIMC->hMsgBuf) {
                lpIMC->hMsgBuf = ImmCreateIMCC(uNumMsg * sizeof(TRANSMSG));
                lpIMC->dwNumMsgBuf = 0;
            } else if (hMem = ImmReSizeIMCC(lpIMC->hMsgBuf,
                (lpIMC->dwNumMsgBuf + uNumMsg) * sizeof(TRANSMSG))) {
                if (hMem != lpIMC->hMsgBuf) {
                    ImmDestroyIMCC(lpIMC->hMsgBuf);
                    lpIMC->hMsgBuf = hMem;
                }
            } else {
                return (0);
            }

            lpTransMsg= (LPTRANSMSG) ImmLockIMCC(lpIMC->hMsgBuf);
            if (!lpTransMsg) {
                return (0);
            }

            lpTransMsg += lpIMC->dwNumMsgBuf;

            bLockMsgBuf = TRUE;
        } else {
            if (bLockMsgBuf) {
                ImmUnlockIMCC(lpIMC->hMsgBuf);
            }
        }
    }

    return (uNumMsg);
}

/**********************************************************************/
/* ImeToAsciiEx()                                                     */
/* Return Value:                                                      */
/*      the number of translated message                              */
/**********************************************************************/
UINT WINAPI ImeToAsciiEx(
    UINT    uVirtKey,
    UINT    uScanCode,
    CONST LPBYTE  lpbKeyState,
    LPTRANSMSGLIST lpTransBuf,
    UINT    fuState,
    HIMC    hIMC)
{
    WORD                wCharCode;
    LPINPUTCONTEXT      lpIMC;
    LPCOMPOSITIONSTRING lpCompStr;
    LPPRIVCONTEXT       lpImcP;
    UINT                uNumMsg;
    int                 iRet;

#ifdef UNICODE
    wCharCode = HIWORD(uVirtKey);
#else
    wCharCode = HIBYTE(uVirtKey);
#endif
    uVirtKey = LOBYTE(uVirtKey);

    // hIMC=NULL?
    if (!hIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    
    if (!lpIMC) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpImcP
    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
    if (!lpImcP) {
        ImmUnlockIMC(hIMC);
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
        return (uNumMsg);
    }

    // get lpCompStr and init
    if (lpImcP->fdwGcsFlag & (GCS_RESULTREAD|GCS_RESULT)) {
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);

        if (lpCompStr) {
            lpCompStr->dwResultStrLen = 0;
        }

        ImmUnlockIMCC(lpIMC->hCompStr);

        lpImcP->fdwGcsFlag = (DWORD)0;
    }

    // Now all composition realated information already pass to app
    // a brand new start

    // init lpImcP->fdwImeMsg
    lpImcP->fdwImeMsg = lpImcP->fdwImeMsg & (MSG_ALREADY_OPEN|
        MSG_ALREADY_START) | MSG_IN_IMETOASCIIEX;
    
    // Process Key(wCharCode)
    iRet = ProcessKey(wCharCode, uVirtKey, uScanCode, lpbKeyState, lpIMC,
        lpImcP);

    // iRet process
    // CST_ALPHANUMERIC
    // CST_SYMBOL

    // CST_SOFTKB
    if (iRet == CST_SOFTKB) {
            WORD wSymbolCharCode;
                WORD CHIByte, CLOByte;
                int  SKDataIndex;

                // Mapping VK
                if(uVirtKey == 0x20) {
                        SKDataIndex = 0;
                } else if(uVirtKey >= 0x30 && uVirtKey <= 0x39) {
                        SKDataIndex = uVirtKey - 0x30 + 1;
                } else if (uVirtKey >= 0x41 && uVirtKey <= 0x5a) {
                        SKDataIndex = uVirtKey - 0x41 + 0x0b;
                } else if (uVirtKey >= 0xba && uVirtKey <= 0xbf) {
                        SKDataIndex = uVirtKey - 0xba + 0x25;
                } else if (uVirtKey >= 0xdb && uVirtKey <= 0xde) {
                        SKDataIndex = uVirtKey - 0xdb + 0x2c;
                } else if (uVirtKey == 0xc0) {
                        SKDataIndex = 0x2b;
                } else {
                        SKDataIndex = 0;
                }

#ifdef UNICODE          //
                if (lpbKeyState[VK_SHIFT] & 0x80) {
                    wSymbolCharCode = SKLayoutS[lpImeL->dwSKWant][SKDataIndex];
                } else {
                    wSymbolCharCode = SKLayout[lpImeL->dwSKWant][SKDataIndex];
                }

                if(wSymbolCharCode == 0x0020) {
#else
                if (lpbKeyState[VK_SHIFT] & 0x80) {
                CHIByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
                        CLOByte = SKLayoutS[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
                } else {
                CHIByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2] & 0x00ff;
                        CLOByte = SKLayout[lpImeL->dwSKWant][SKDataIndex*2 + 1] & 0x00ff;
                }

            wSymbolCharCode = (CHIByte << 8) | CLOByte;
                if(wSymbolCharCode == 0x2020) {
#endif
                        MessageBeep((UINT) -1);
                        uNumMsg = 0;
                } else {
                uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                }
        } 

    // CST_ALPHANUMERIC
    else if (iRet == CST_ALPHANUMERIC) {
            if (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN) {
            lpImcP->fdwImeMsg = (lpImcP->fdwImeMsg | MSG_CLOSE_CANDIDATE) &
                ~(MSG_OPEN_CANDIDATE) & ~(MSG_IN_IMETOASCIIEX);
            GenerateMessage(hIMC, lpIMC, lpImcP);
                }

        if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                    WORD wSymbolCharCode;
                        if(wCharCode == TEXT('.')) {
#ifdef UNICODE
                               wSymbolCharCode = 0x3002;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT(',')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff0c;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT(';')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff1b;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT(':')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff1a;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('?')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff1f;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('!')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff01;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('(')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff08;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT(')')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xff09;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('\\')) {
#ifdef UNICODE
                                wSymbolCharCode = 0x3001;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('@')) {
#ifdef UNICODE
                                wSymbolCharCode = 0x00b7;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('&')) {
#ifdef UNICODE
                                wSymbolCharCode = 0x2014;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('$')) {
#ifdef UNICODE
                                wSymbolCharCode = 0xffe5;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('_')) {
#ifdef UNICODE
                                wSymbolCharCode = 0x2014;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, TRUE);
                        } else if(wCharCode == TEXT('^')) {
#ifdef UNICODE
                                wSymbolCharCode = 0x2026;
#else
                                wSymbolCharCode = TEXT('');
#endif
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, TRUE);
                        } else if(wCharCode == TEXT('"')) {
                                if(lpImcP->uSYHFlg) {
#ifdef UNICODE
                                        wSymbolCharCode = 0x201d;
                                } else {
                                        wSymbolCharCode = 0x201c;

#else
                                        wSymbolCharCode = TEXT('');
                                } else {
                                        wSymbolCharCode = TEXT('');
#endif
                                }
                        lpImcP->uSYHFlg ^= 0x00000001;
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('\'')) {
                                if(lpImcP->uDYHFlg) {
#ifdef UNICODE
                                        wSymbolCharCode = 0x2019;
                                } else {
                                        wSymbolCharCode = 0x2018;
#else
                                        wSymbolCharCode = TEXT('');
                                } else {
                                        wSymbolCharCode = TEXT('');
#endif
                                }
                        lpImcP->uDYHFlg ^= 0x00000001;
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('<')) {
                                if(lpImcP->uDSMHFlg) {
#ifdef UNICODE
                                        wSymbolCharCode = 0x3008;
#else
                                        wSymbolCharCode = TEXT('');
#endif
                                        lpImcP->uDSMHCount++;
                                } else {
#ifdef UNICODE
                                        wSymbolCharCode = 0x300a;
#else
                                        wSymbolCharCode = TEXT('');
#endif
                                lpImcP->uDSMHFlg = 0x00000001;
                                }
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else if(wCharCode == TEXT('>')) {
                                if((lpImcP->uDSMHFlg) && (lpImcP->uDSMHCount)) {
#ifdef UNICODE
                                        wSymbolCharCode = 0x3009;
#else
                                        wSymbolCharCode = TEXT('');
#endif
                                        lpImcP->uDSMHCount--;
                                } else {
#ifdef UNICODE
                                        wSymbolCharCode = 0x300b;
#else
                                        wSymbolCharCode = TEXT('');
#endif
                                lpImcP->uDSMHFlg = 0x00000000;
                                }
                    uNumMsg = TranslateSymbolChar(lpTransBuf, wSymbolCharCode, FALSE);
                        } else {
                        if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
                            // convert to DBCS
                            uNumMsg = TranslateFullChar(lpTransBuf, wCharCode);
                        } else {
                            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                                wCharCode);
                        }
                        }
        } else if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
            // convert to DBCS
            uNumMsg = TranslateFullChar(lpTransBuf, wCharCode);
        } else {
            uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
                wCharCode);
        }
    }
    // CST_CHOOSE
    else if (iRet == CST_CHOOSE) {
         LPCANDIDATEINFO lpCandInfo;

        lpCandInfo = (LPCANDIDATEINFO)ImmLockIMCC(lpIMC->hCandInfo);
                if(!lpCandInfo){
            return (CST_INVALID);
                }

        if (uVirtKey == VK_PRIOR) {
            wCharCode = TEXT('-');
        } else if (uVirtKey == VK_NEXT) {
            wCharCode = TEXT('=');
        } else if (uVirtKey == VK_SPACE) {
            wCharCode = TEXT('1');
        } else if (uVirtKey <= TEXT('9')) {
            // convert shift-0 ... shift-9 to 0 ... 9
            wCharCode = (WORD)uVirtKey;
        } else if (uVirtKey == VK_HOME) {
            wCharCode = 0x24;
        } else if (uVirtKey == VK_END) {
            wCharCode = 0x23;
        } else {
        }

            lpImcP->iImeState = CST_CHOOSE;
        ChooseCand(wCharCode, lpIMC, lpCandInfo, lpImcP);

        ImmUnlockIMCC(lpIMC->hCandInfo);

        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }
    // CST_INPUT(IME_CMODE_CHARCODE)
    else if (iRet == CST_INPUT &&
        lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
    }
    // CST_INPUT 
    else if (iRet == CST_INPUT) {
        LPGUIDELINE         lpGuideLine;

        // get lpCompStr & lpGuideLine
        lpCompStr = (LPCOMPOSITIONSTRING)ImmLockIMCC(lpIMC->hCompStr);
                if(!lpCompStr){
            return (CST_INVALID);
                }

        lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);
                if(!lpGuideLine){
                ImmUnlockIMCC(lpIMC->hCompStr);
            return (CST_INVALID);
                }

        // composition
        CompWord(wCharCode, lpIMC, lpCompStr, lpImcP, lpGuideLine);

        ImmUnlockIMCC(lpIMC->hGuideLine);
        ImmUnlockIMCC(lpIMC->hCompStr);
        
        // generate message
        uNumMsg = TranslateImeMessage(lpTransBuf, lpIMC, lpImcP);
    }
    // ELSE
    else if (iRet == CST_INVALID_INPUT) {
            MessageBeep((UINT) -1);
                uNumMsg = 0;
    }else {
        uNumMsg = TranslateToAscii(uVirtKey, uScanCode, lpTransBuf,
            wCharCode);
    }

    // reset lpImcP->fdwImeMsg
    lpImcP->fdwImeMsg &= (MSG_ALREADY_OPEN|MSG_ALREADY_START);
    lpImcP->fdwGcsFlag &= (GCS_RESULTREAD|GCS_RESULT);

    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return (uNumMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\regword.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    regword.c


++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>

/**********************************************************************/
/* ImeRegsisterWord                                                   */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeRegisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return (FALSE);
}


/**********************************************************************/
/* ImeUnregsisterWord                                                 */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL WINAPI ImeUnregisterWord(
    LPCTSTR lpszReading,
    DWORD   dwStyle,
    LPCTSTR lpszString)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeGetRegsisterWordStyle                                           */
/* Return Value:                                                      */
/*      number of styles copied/required                              */
/**********************************************************************/
UINT WINAPI ImeGetRegisterWordStyle(
    UINT       nItem,
    LPSTYLEBUF lpStyleBuf)
{
    return (FALSE);
}

/**********************************************************************/
/* ImeEnumRegisterWord                                                */
/* Return Value:                                                      */
/*      the last value return by the callback function                */
/**********************************************************************/
UINT WINAPI ImeEnumRegisterWord(
    REGISTERWORDENUMPROC lpfnRegisterWordEnumProc,
    LPCTSTR              lpszReading,
    DWORD                dwStyle,
    LPCTSTR              lpszString,
    LPVOID               lpData)
{
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by wingb.rc
//
#define IDC_TRACE                       1000
#define IDC_ORGNAME                     1001
#define IDD_LAYOUT_LIST                 1018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\wingb\resource.h ===
/*************************************************
 *  resource.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by wingb.rc
//
#define IDC_TRACE                       1000
#define IDC_ORGNAME                     1001
#define IDD_LAYOUT_LIST                 1018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\uisubs.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    uisubs.c


++*/


#include <windows.h>
#include <immdev.h>
#include <htmlhelp.h>
#include <imedefs.h>

/**********************************************************************/
/* DrawDragBorder()                                                   */
/**********************************************************************/
void PASCAL DrawDragBorder(
    HWND hWnd,                  // window of IME is dragged
    LONG lCursorPos,            // the cursor position
    LONG lCursorOffset)         // the offset form cursor to window org
{
    HDC  hDC;
    int  cxBorder, cyBorder;
    int  x, y;
    RECT rcWnd;

    cxBorder = GetSystemMetrics(SM_CXBORDER);   // width of border
    cyBorder = GetSystemMetrics(SM_CYBORDER);   // height of border

    // get cursor position
    x = (*(LPPOINTS)&lCursorPos).x;
    y = (*(LPPOINTS)&lCursorPos).y;

    // calculate the org by the offset
    x -= (*(LPPOINTS)&lCursorOffset).x;
    y -= (*(LPPOINTS)&lCursorOffset).y;

#ifndef MUL_MONITOR
    // check for the min boundary of the display
    if (x < sImeG.rcWorkArea.left) {
        x = sImeG.rcWorkArea.left;
    }

    if (y < sImeG.rcWorkArea.top) {
        y = sImeG.rcWorkArea.top;
    }
#endif

    // check for the max boundary of the display
    GetWindowRect(hWnd, &rcWnd);

#ifndef MUL_MONITOR

    if (x + rcWnd.right - rcWnd.left > sImeG.rcWorkArea.right) {
        x = sImeG.rcWorkArea.right - (rcWnd.right - rcWnd.left);
    }

    if (y + rcWnd.bottom - rcWnd.top > sImeG.rcWorkArea.bottom) {
        y = sImeG.rcWorkArea.bottom - (rcWnd.bottom - rcWnd.top);
    }

#endif

    // draw the moving track
    hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);

    if ( hDC )
    {
        SelectObject(hDC, GetStockObject(GRAY_BRUSH));

        // ->
        PatBlt(hDC, x, y, rcWnd.right - rcWnd.left - cxBorder, cyBorder,
            PATINVERT);
        // v
        PatBlt(hDC, x, y + cyBorder, cxBorder, rcWnd.bottom - rcWnd.top -
            cyBorder, PATINVERT);
        // _>
        PatBlt(hDC, x + cxBorder, y + rcWnd.bottom - rcWnd.top,
            rcWnd.right - rcWnd.left - cxBorder, -cyBorder, PATINVERT);
        //  v
        PatBlt(hDC, x + rcWnd.right - rcWnd.left, y,
            - cxBorder, rcWnd.bottom - rcWnd.top - cyBorder, PATINVERT);

        DeleteDC(hDC);
    }

    return;
}

/**********************************************************************/
/* DrawFrameBorder()                                                  */
/**********************************************************************/
void PASCAL DrawFrameBorder(    // border of IME
    HDC  hDC,
    HWND hWnd)                  // window of IME
{
    RECT rcWnd;
    int  xWi, yHi;

    GetWindowRect(hWnd, &rcWnd);

    xWi = rcWnd.right - rcWnd.left;
    yHi = rcWnd.bottom - rcWnd.top;

    // 1, ->
    PatBlt(hDC, 0, 0, xWi, 1, WHITENESS);

    // 1, v
    PatBlt(hDC, 0, 0, 1, yHi, WHITENESS);

    // 1, _>
    PatBlt(hDC, 0, yHi, xWi, -1, BLACKNESS);

    // 1,  v
    PatBlt(hDC, xWi, 0, -1, yHi, BLACKNESS);

    xWi -= 2;
    yHi -= 2;

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 2, ->
    PatBlt(hDC, 1, 1, xWi, 1, PATCOPY);

    // 2, v
    PatBlt(hDC, 1, 1, 1, yHi, PATCOPY);

    // 2,  v
    PatBlt(hDC, xWi + 1, 1, -1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    // 2, _>
    PatBlt(hDC, 1, yHi + 1, xWi, -1, PATCOPY);

    xWi -= 2;
    yHi -= 2;

    // 3, ->
    PatBlt(hDC, 2, 2, xWi, 1, PATCOPY);

    // 3, v
    PatBlt(hDC, 2, 2, 1, yHi, PATCOPY);

    // 3,  v
    PatBlt(hDC, xWi + 2, 3, -1, yHi - 1, WHITENESS);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 3, _>
    PatBlt(hDC, 2, yHi + 2, xWi, -1, PATCOPY);

    SelectObject(hDC, GetStockObject(GRAY_BRUSH));

    xWi -= 2;
    yHi -= 2;

    // 4, ->
    PatBlt(hDC, 3, 3, xWi, 1, PATCOPY);

    // 4, v
    PatBlt(hDC, 3, 3, 1, yHi, PATCOPY);

    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));

    // 4,  v
    PatBlt(hDC, xWi + 3, 4, -1, yHi - 1, PATCOPY);

    // 4, _>
    PatBlt(hDC, 3, yHi + 3, xWi, -1, WHITENESS);

    return;
}


/**********************************************************************/
/* ContextMenuWndProc()                                               */
/**********************************************************************/
LRESULT CALLBACK ContextMenuWndProc(
    HWND        hCMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_CMENUDESTROYED);
            }
        }
        break;
    case WM_USER_DESTROY:
        {
            SendMessage(hCMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hCMenuWnd);
        }
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDM_PROP:
            {
            HIMC            hIMC;
            LPINPUTCONTEXT  lpIMC;
            LPPRIVCONTEXT   lpImcP;
            int             UI_MODE;
            HWND            hUIWnd;
            RECT            rcWorkArea;

               hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

               if (!hUIWnd) {
                   return (0L);
               }

#ifdef MUL_MONITOR 
            rcWorkArea = ImeMonitorWorkAreaFromWindow(hCMenuWnd);
#else
            rcWorkArea = sImeG.rcWorkArea;
#endif

            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            if (!hIMC) {
                return (0L);
            }

            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {
                return (0L);
            }

            lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
            if (!lpImcP) {
                return (0L);
            }

            ImeConfigure(GetKeyboardLayout(0), lpIMC->hWnd, IME_CONFIG_GENERAL, NULL);

#ifdef CROSSREF
            {
            HWND hCompWnd;
            hCompWnd = GetCompWnd(hUIWnd);
            DestroyWindow(hCompWnd);
            }
#endif
                
            lpImcP->iImeState = CST_INIT;
            CompCancel(hIMC, lpIMC);
            
            // change compwnd size

            // init fields of hIMC
            lpIMC->fOpen = TRUE;

            if (!(lpIMC->fdwInit & INIT_CONVERSION)) {
                lpIMC->fdwConversion = IME_CMODE_NATIVE;
                lpIMC->fdwInit |= INIT_CONVERSION;
            }

            lpImcP->fdwImeMsg = lpImcP->fdwImeMsg | MSG_IMN_DESTROYCAND;
            GenerateMessage(hIMC, lpIMC, lpImcP);
            
            // set cand window data
            if(sImeG.IC_Trace) {
                UI_MODE = BOX_UI;
            } else {
                POINT ptSTFixPos;
                
                UI_MODE = LIN_UI;
                ptSTFixPos.x = 0;
                ptSTFixPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
                ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTFixPos);
            }
            InitCandUIData(
                GetSystemMetrics(SM_CXBORDER),
                GetSystemMetrics(SM_CYBORDER), UI_MODE);
            
            ImmUnlockIMCC(lpIMC->hPrivate);
            ImmUnlockIMC(hIMC);
            break;
            }
        //case IDM_HLP:
        case IDM_OPTGUD:
            {
               TCHAR szOPTGUDHlpName[MAX_PATH];

               szOPTGUDHlpName[0] = 0;
               GetWindowsDirectory((LPTSTR)szOPTGUDHlpName, MAX_PATH);
               lstrcat((LPTSTR)szOPTGUDHlpName, TEXT("\\HELP\\WINIME.CHM"));
               HtmlHelp(hCMenuWnd,szOPTGUDHlpName,HH_DISPLAY_TOPIC,0L);
            }
            break;
        case IDM_IMEGUD:
            {
              TCHAR szIMEGUDHlpName[MAX_PATH];
                    
                szIMEGUDHlpName[0] = TEXT('\0');
              GetWindowsDirectory((LPTSTR)szIMEGUDHlpName, MAX_PATH);
              lstrcat((LPTSTR)szIMEGUDHlpName, TEXT("\\HELP\\") );
#if defined(COMBO_IME)
            //COMBO_IME has only one IME help file
                lstrcat((LPTSTR)szIMEGUDHlpName, TEXT("WINGB.CHM"));
#else //COMBO_IME
#ifdef GB
                lstrcpy((LPTSTR)szIMEGUDHlpName, TEXT("WINGB.CHM"));
#else
                lstrcpy((LPTSTR)szIMEGUDHlpName, TEXT("WINNM.HLP"));
#endif
#endif //COMBO_IME
              HtmlHelp(hCMenuWnd,szIMEGUDHlpName,HH_DISPLAY_TOPIC,0L);
            }
            break;
        case IDM_VER:
            {
            HIMC           hIMC;
            LPINPUTCONTEXT lpIMC;
            HWND hUIWnd;

               hUIWnd = (HWND)GetWindowLongPtr(hCMenuWnd, CMENU_HUIWND);

               if (!hUIWnd) {
                   return (0L);
               }

            hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
            
            if (!hIMC) {          
                return (0L);
            }
            

            lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
            if (!lpIMC) {          
                return (0L);
            }

            DialogBox(hInst, TEXT("IMEVER"), (HWND)lpIMC->hWnd, (DLGPROC)ImeVerDlgProc);

            ImmUnlockIMC(hIMC);
            break;
            }

        }

        break;

    case WM_CLOSE:
        {
            HMENU hMenu;

            GetMenu(hCMenuWnd);

            hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    default:
        return DefWindowProc(hCMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/**********************************************************************/
/* SoftkeyMenuWndProc()                                               */
/**********************************************************************/
LRESULT CALLBACK SoftkeyMenuWndProc(
    HWND        hKeyMenuWnd,
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
        {
            HWND hUIWnd;

            hUIWnd = (HWND)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_HUIWND);

            if (hUIWnd) {
                SendMessage(hUIWnd, WM_IME_NOTIFY, IMN_PRIVATE,
                    IMN_PRIVATE_SOFTKEYMENUDESTROYED);
            }
        }
        break;
    case WM_USER_DESTROY:
        {
            SendMessage(hKeyMenuWnd, WM_CLOSE, 0, 0);
            DestroyWindow(hKeyMenuWnd);
        }
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDM_SKL1:
        case IDM_SKL2:
        case IDM_SKL3:
        case IDM_SKL4:
        case IDM_SKL5:
        case IDM_SKL6:
        case IDM_SKL7:
        case IDM_SKL8:
        case IDM_SKL9:
        case IDM_SKL10:
        case IDM_SKL11:
        case IDM_SKL12:
        case IDM_SKL13:
            {
                HIMC           hIMC;
                LPINPUTCONTEXT lpIMC;
                LPPRIVCONTEXT  lpImcP;
                DWORD          fdwConversion;
                HWND hUIWnd;

                hUIWnd = (HWND)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_HUIWND);

                if (!hUIWnd) {
                    return (0L);
                }

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd,IMMGWLP_IMC);
                
                if (!hIMC) {          
                    return (0L);
                }
                

                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {          
                    return (0L);
                }

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
                if (!lpImcP) {
                    return (0L);
                }

                {
                    UINT i;

                    lpImeL->dwSKWant = LOWORD(wParam) - IDM_SKL1;
                    lpImeL->dwSKState[lpImeL->dwSKWant] = 
                        lpImeL->dwSKState[lpImeL->dwSKWant]^1;
                
                    // clear other SK State
                    for(i=0; i<NumsSK; i++) {
                        if(i == lpImeL->dwSKWant) continue;
                          lpImeL->dwSKState[i] = 0;
                    }

                    if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
                        if(LOWORD(wParam) == IDM_SKL1)
                            lpImcP->iImeState = CST_INIT;
                        else
                            lpImcP->iImeState = CST_SOFTKB;
                        fdwConversion = lpIMC->fdwConversion | IME_CMODE_SOFTKBD;
                    } else {
                           lpImcP->iImeState = CST_INIT;
                        fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_SOFTKBD);
                    }
                }

                ImmSetConversionStatus(hIMC, (fdwConversion & ~(IME_CMODE_SOFTKBD)),
                    lpIMC->fdwSentence);
                ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);

                ImmUnlockIMCC(lpIMC->hPrivate);
                ImmUnlockIMC(hIMC);
                break;
            }
        }

        break;

    case WM_CLOSE:
        {
            HMENU hMenu;

            GetMenu(hKeyMenuWnd);

            hMenu = (HMENU)GetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_MENU);
            if (hMenu) {
                SetWindowLongPtr(hKeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)NULL);
                DestroyMenu(hMenu);
            }
        }
        return DefWindowProc(hKeyMenuWnd, uMsg, wParam, lParam);

    case WM_SETCURSOR:
        if (HIWORD(lParam) == WM_RBUTTONUP)
            MessageBeep(-1);
    default:
        return DefWindowProc(hKeyMenuWnd, uMsg, wParam, lParam);
    }

    return (0L);
}


/**********************************************************************/
/* ContextMenu()                                                      */
/**********************************************************************/
void PASCAL ContextMenu(
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HWND           hCMenuWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HMENU          hMenu, hCMenu;
    RECT           rcStatusWnd;
    RECT           rcWorkArea;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if(!hUIWnd){
        return;
    }
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto ContextMenuUnlockIMC;
    }

    if (!lpUIPrivate->hCMenuWnd) {
        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hCMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
            szCMenuClassName, TEXT("Context Menu"),
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, hInst, NULL);

    }

    hCMenuWnd = lpUIPrivate->hCMenuWnd;

    // Unlock before we call into TrackPopupMenu().
    GlobalUnlock(hUIPrivate);

    if (!hCMenuWnd) {
        goto ContextMenuUnlockIMC;
    }

    hMenu = LoadMenu(hInst, TEXT("PROPMENU"));
    hCMenu = GetSubMenu(hMenu, 0);

    // Disable some of menu items.

    if ( lpImeL->fWinLogon == TRUE )
    {
        // In Logon Mode, we don't want to show help and configuration dialog

        EnableMenuItem(hCMenu, 0, MF_BYPOSITION | MF_GRAYED );
        EnableMenuItem(hCMenu, IDM_PROP, MF_BYCOMMAND | MF_GRAYED); 
    }

    SetWindowLongPtr(hCMenuWnd, CMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)hMenu);

    TrackPopupMenu (hCMenu, TPM_LEFTBUTTON,
          rcStatusWnd.left, rcStatusWnd.top, 0, hCMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(hCMenuWnd, CMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(hCMenuWnd, CMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

ContextMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}
/**********************************************************************/
/* SoftkeyMenu()                                                      */
/**********************************************************************/
void PASCAL SoftkeyMenu(
    HWND        hStatusWnd,
    int         x,
    int         y)
{
    HWND           hUIWnd;
    HWND           hSoftkeyMenuWnd;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    HMENU          hMenu, hKeyMenu;
    RECT  rcStatusWnd;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    if(!hUIWnd){
        return;
    }
    GetWindowRect(hStatusWnd, &rcStatusWnd);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        goto KeyMenuUnlockIMC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        goto KeyMenuUnlockIMC;
    }

    if (!lpUIPrivate->hSoftkeyMenuWnd) {
        // this is important to assign owner window, otherwise the focus
        // will be gone

        // When UI terminate, it need to destroy this window
        lpUIPrivate->hSoftkeyMenuWnd = CreateWindowEx(CS_HREDRAW|CS_VREDRAW,
            szSoftkeyMenuClassName, TEXT("Softkey Menu"),
            WS_POPUP|WS_DISABLED, 0, 0, 0, 0,
            lpIMC->hWnd, (HMENU)NULL, hInst, NULL);

    }

    hSoftkeyMenuWnd = lpUIPrivate->hSoftkeyMenuWnd;

    // Unlock before we call into TrackPopupMenu().
    GlobalUnlock(hUIPrivate);

    if (!hSoftkeyMenuWnd) {
        goto KeyMenuUnlockIMC;
    }

    hMenu = LoadMenu(hInst, TEXT("SKMENU"));
    hKeyMenu = GetSubMenu(hMenu, 0);

    SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_HUIWND, (LONG_PTR)hUIWnd);
    SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)hMenu);


    if(lpImeL->dwSKState[lpImeL->dwSKWant]) {
        CheckMenuItem(hMenu,lpImeL->dwSKWant + IDM_SKL1, MF_CHECKED);
    }


    TrackPopupMenu (hKeyMenu, TPM_LEFTBUTTON,
          rcStatusWnd.left, rcStatusWnd.top, 0, hSoftkeyMenuWnd, NULL);

    hMenu = (HMENU)GetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU);
    if (hMenu) {
        SetWindowLongPtr(hSoftkeyMenuWnd, SOFTKEYMENU_MENU, (LONG_PTR)NULL);
        DestroyMenu(hMenu);
    }

KeyMenuUnlockIMC:
    ImmUnlockIMC(hIMC);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\winnm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by winnm.rc
//
#define IDC_TRACE                       1000
#define IDC_ORGNAME                     1001
#define IDD_LAYOUT_LIST                 1018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\statusui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    statusui.c


++*/


#include <windows.h>
#include <immdev.h>
#include <htmlhelp.h>
#include <string.h>
#include <regstr.h>
#include <imedefs.h>
#include <resource.h>
extern HWND hCrtDlg;
/**********************************************************************/
/* GetStatusWnd                                                       */
/* Return Value :                                                     */
/*      window handle of status window                                */
/**********************************************************************/
HWND PASCAL GetStatusWnd(
    HWND hUIWnd)                // UI window
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;
    HWND     hStatusWnd;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
    return (HWND)NULL;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
    return (HWND)NULL;
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);
    return (hStatusWnd);
}

/**********************************************************************/
/* AdjustStatusBoundary()                                             */
/**********************************************************************/
void PASCAL AdjustStatusBoundary(
    LPPOINTS lppt,
    HWND     hUIWnd)
{

    RECT     rcWorkArea;

#ifdef MUL_MONITOR
    {
        RECT rcStatusWnd;

        rcStatusWnd.left = lppt->x;
        rcStatusWnd.top = lppt->y;
        rcStatusWnd.right = rcStatusWnd.left + sImeG.xStatusWi;
        rcStatusWnd.bottom = rcStatusWnd.top + sImeG.yStatusHi;

        rcWorkArea = ImeMonitorWorkAreaFromRect(&rcStatusWnd);
   }
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif

    // display boundary check
    if (lppt->x < rcWorkArea.left) {
    lppt->x = (short)rcWorkArea.left;
    } else if (lppt->x + sImeG.xStatusWi > rcWorkArea.right) {
    lppt->x = (short)(rcWorkArea.right - sImeG.xStatusWi);
    }

    if (lppt->y < rcWorkArea.top) {
    lppt->y = (short)rcWorkArea.top;
    } else if (lppt->y + sImeG.yStatusHi > rcWorkArea.bottom) {
    lppt->y = (short)(rcWorkArea.bottom - sImeG.yStatusHi);
    }

    if(sImeG.IC_Trace) {
    } else {
        int             Comp_CandWndLen;

        Comp_CandWndLen = 0;
        if(uStartComp) {
                Comp_CandWndLen += lpImeL->xCompWi + UI_MARGIN;
        }
        
        if(uOpenCand) {
           Comp_CandWndLen += sImeG.xCandWi + UI_MARGIN;
        }

        if(lppt->x + sImeG.xStatusWi + Comp_CandWndLen > rcWorkArea.right) {
          lppt->x=(SHORT)(rcWorkArea.right-sImeG.xStatusWi-Comp_CandWndLen);
        }
    }
    
    return;
}

/**********************************************************************/
/* SetStatusWindowPos()                                               */
/**********************************************************************/
LRESULT PASCAL SetStatusWindowPos(
    HWND   hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    RECT           rcStatusWnd;
    POINTS         ptPos;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
       return (1L);
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {           // Oh! Oh!
       return (1L);
    }

    ptPos.x = (short)lpIMC->ptStatusWndPos.x;
    ptPos.y = (short)lpIMC->ptStatusWndPos.y;

    // display boundary adjust
    AdjustStatusBoundary(&ptPos, hUIWnd);

    SetWindowPos(hStatusWnd, NULL,
                 ptPos.x, ptPos.y,
                 0, 0, SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOSIZE|SWP_NOZORDER);

    ImmUnlockIMC(hIMC);

    return (0L);
}

/**********************************************************************/
/* ShowStatus()                                                       */
/**********************************************************************/
void PASCAL ShowStatus(         // Show the status window - shape / soft KBD
                // alphanumeric ...
    HWND hUIWnd,
    int  nShowStatusCmd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
       return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
       return;
    }

    if (!lpUIPrivate->hStatusWnd) {
    // not in show status window mode
    } else if (lpUIPrivate->nShowStatusCmd != nShowStatusCmd) {
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
        SetStatusWindowPos(lpUIPrivate->hStatusWnd);
        ShowWindow(lpUIPrivate->hStatusWnd, nShowStatusCmd);
        lpUIPrivate->nShowStatusCmd = nShowStatusCmd;
    } else {
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* OpenStatus()                                                       */
/**********************************************************************/
void PASCAL OpenStatus(         // open status window
    HWND hUIWnd)
{
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    POINT          ptPos;
    int            nShowStatusCmd;
    RECT           rcWorkArea;

    rcWorkArea = sImeG.rcWorkArea;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate)           // can not darw status window
       return;
    

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate)          // can not draw status window
       return;
    

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
       ptPos.x = rcWorkArea.left;
       ptPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
       nShowStatusCmd = SW_HIDE;
    } 
    else if (lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC)) {
           
#ifdef MUL_MONITOR
           rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);
#endif

           if (lpIMC->ptStatusWndPos.x < rcWorkArea.left) {
               lpIMC->ptStatusWndPos.x = rcWorkArea.left;
           } 
           else if (lpIMC->ptStatusWndPos.x+sImeG.xStatusWi>rcWorkArea.right) {
               lpIMC->ptStatusWndPos.x = rcWorkArea.right - sImeG.xStatusWi;
           }

           if (lpIMC->ptStatusWndPos.y < rcWorkArea.top) {
              lpIMC->ptStatusWndPos.y = rcWorkArea.top;
           } 
           else if (lpIMC->ptStatusWndPos.y+sImeG.yStatusHi>rcWorkArea.right) {
              lpIMC->ptStatusWndPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
           }
    
           if(sImeG.IC_Trace) {
              ptPos.x = lpIMC->ptStatusWndPos.x;
              ptPos.y = lpIMC->ptStatusWndPos.y;
           } else {
              ptPos.x = rcWorkArea.left;
              ptPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
           }

           ImmUnlockIMC(hIMC);
           nShowStatusCmd = SW_SHOWNOACTIVATE;
    } else {
        ptPos.x = rcWorkArea.left;
        ptPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
        nShowStatusCmd = SW_HIDE;
    }

    if (lpUIPrivate->hStatusWnd) {
        SetWindowPos(lpUIPrivate->hStatusWnd, NULL,
                     ptPos.x, ptPos.y,
                     0, 0,
                     SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
    } else {                            // create status window
       lpUIPrivate->hStatusWnd = CreateWindowEx(
                                     WS_EX_WINDOWEDGE|WS_EX_DLGMODALFRAME,
                                     szStatusClassName, NULL, 
                                     WS_POPUP|WS_DISABLED,
                                     ptPos.x, ptPos.y,
                                     sImeG.xStatusWi, sImeG.yStatusHi,
                                     hUIWnd, (HMENU)NULL, hInst, NULL);

       if ( lpUIPrivate->hStatusWnd != NULL )
       {

            SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
            SetWindowLong(lpUIPrivate->hStatusWnd, UI_MOVE_XY, 0L);
       }
    }

    lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

    if (hIMC) {
       ShowStatus( hUIWnd, SW_SHOWNOACTIVATE);
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* DestroyStatusWindow()                                              */
/**********************************************************************/
void PASCAL DestroyStatusWindow(
    HWND hStatusWnd)
{
    HWND     hUIWnd;
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
    // undo the drag border
    DrawDragBorder(hStatusWnd,
        GetWindowLong(hStatusWnd, UI_MOVE_XY),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
    }

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
    return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
    return;
    }

    lpUIPrivate->nShowStatusCmd = SW_HIDE;

    lpUIPrivate->hStatusWnd = (HWND)NULL;

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* SetStatus                                                          */
/**********************************************************************/
void PASCAL SetStatus(
    HWND    hStatusWnd,
    LPPOINT lpptCursor)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);
    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
    return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
    return;
    }

    if (!lpIMC->fOpen) {
    ImmSetOpenStatus(hIMC, TRUE);
    } else if (PtInRect(&sImeG.rcImeIcon, *lpptCursor)) {
    DWORD fdwConversion;

    if (lpIMC->fdwConversion & (IME_CMODE_CHARCODE|IME_CMODE_EUDC)) {
        // change to native mode
        fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
    } else if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
        // change to alphanumeric mode
        fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
        IME_CMODE_NATIVE | IME_CMODE_EUDC);
    } else {

    
        BYTE  lpbKeyState[256];

        GetKeyboardState(lpbKeyState);
    
        if (lpbKeyState[VK_CAPITAL] & 1)        
        {
        // Simulate a key press
        keybd_event( VK_CAPITAL,
                           0x3A,
                          KEYEVENTF_EXTENDEDKEY | 0,
                          0 );
 
        // Simulate a key release
        keybd_event( VK_CAPITAL,
                           0x3A,
                           KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP,
                           0);
        }
        fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
            // 10.11 add
            uCaps = 0;
    }

    ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    } else if (PtInRect(&sImeG.rcImeName, *lpptCursor)) {
#if defined(COMBO_IME)
    DWORD dwConvMode;
    int     cxBorder, cyBorder;
    HKEY  hKeyCurrVersion;
    HKEY  hKeyGB;
    DWORD retCode;

        //change current IME index
        dwConvMode = lpIMC->fdwConversion ^ (IME_CMODE_INDEX_FIRST << sImeL.dwRegImeIndex);
        sImeL.dwRegImeIndex = (sImeL.dwRegImeIndex+1) % IMEINDEXNUM;
        szImeName = pszImeName[sImeL.dwRegImeIndex];
        dwConvMode |= (IME_CMODE_INDEX_FIRST << sImeL.dwRegImeIndex);

        // re-caculate statusuidata
        cxBorder = GetSystemMetrics(SM_CXBORDER);
        cyBorder = GetSystemMetrics(SM_CYBORDER);
        InitStatusUIData(cxBorder, cyBorder);

        ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);

        //set IME index in registry
        retCode = OpenReg_PathSetup(&hKeyCurrVersion);
        if (retCode) {
            return;
        }
        retCode = RegCreateKeyEx(hKeyCurrVersion, szImeRegName, 0,
                    NULL, REG_OPTION_NON_VOLATILE,    KEY_ALL_ACCESS    , NULL, &hKeyGB, NULL);

        if (retCode) {
            RegCloseKey(hKeyCurrVersion);
            return;
        }
        retCode = RegSetValueEx (hKeyGB, 
                                 szRegImeIndex,
                                 (DWORD)0,
                                 REG_DWORD,
                                 (LPBYTE)&sImeL.dwRegImeIndex,
                                 sizeof(DWORD));
        if (retCode) {
            RegCloseKey(hKeyGB);
            RegCloseKey(hKeyCurrVersion);
            return;
        }
        RegCloseKey(hKeyGB);
        RegCloseKey(hKeyCurrVersion);

#endif //COMBO_IME
    } else if (PtInRect(&sImeG.rcShapeText, *lpptCursor)) {
    DWORD dwConvMode;

    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        MessageBeep((UINT)-1);
    } else if (lpIMC->fdwConversion & IME_CMODE_EUDC) {
        MessageBeep((UINT)-1);
    } else {
        dwConvMode = lpIMC->fdwConversion ^ IME_CMODE_FULLSHAPE;
        ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);
    }
    } else if (PtInRect(&sImeG.rcSymbol, *lpptCursor)) {
    DWORD fdwConversion;

    if (lpIMC->fdwConversion & IME_CMODE_CHARCODE) {
        MessageBeep((UINT)-1);
    } else {
        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SYMBOL;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
    }
    } else if (PtInRect(&sImeG.rcSKText, *lpptCursor)) {
    DWORD fdwConversion;
        LPPRIVCONTEXT  lpImcP;

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    
    if(lpImcP) {
            if(!(lpImeL->hSKMenu)) {
                lpImeL->hSKMenu = LoadMenu (hInst, TEXT("SKMENU"));
            }

        lpImeL->dwSKState[lpImeL->dwSKWant] = 
                lpImeL->dwSKState[lpImeL->dwSKWant]^1;
        fdwConversion = lpIMC->fdwConversion ^ IME_CMODE_SOFTKBD;
        ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
            ImmUnlockIMCC(lpIMC->hPrivate);
        } else {
        MessageBeep((UINT)-1);
        }
    } else {
    MessageBeep((UINT)-1);
    }

    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* StatusSetCursor()                                                  */
/**********************************************************************/
void PASCAL StatusSetCursor(
    HWND        hStatusWnd,
    LPARAM      lParam)
{
    POINT ptCursor, ptSavCursor;
    RECT  rcWnd;

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
       SetCursor(LoadCursor(NULL, IDC_SIZEALL));
       return;
    }
    
    GetCursorPos(&ptCursor);
    ptSavCursor = ptCursor;

    ScreenToClient(hStatusWnd, &ptCursor);

    if (PtInRect(&sImeG.rcStatusText, ptCursor)) {
       SetCursor(LoadCursor(hInst, szHandCursor));

       if (HIWORD(lParam) == WM_LBUTTONDOWN) {
          SetStatus(hStatusWnd, &ptCursor);
       } else if (HIWORD(lParam) == WM_RBUTTONUP) {
              if (PtInRect(&sImeG.rcSKText, ptCursor)) {
                 static BOOL fSoftkey= FALSE;
                 // prevent recursive
                 if (fSoftkey) {
                   // configuration already bring up
                   return;
                 }
                 fSoftkey = TRUE;
                 SoftkeyMenu(hStatusWnd, ptSavCursor.x, ptSavCursor.y);
                 fSoftkey = FALSE;
              }else{
                 static BOOL fCmenu=FALSE;
                 // prevent recursive
            if (fCmenu) {
                // configuration already bring up
            return;
            }
            fCmenu = TRUE;
        ContextMenu(hStatusWnd, ptSavCursor.x, ptSavCursor.y);
            fCmenu = FALSE;
            }

    }

    return;
    } else {
    SetCursor(LoadCursor(NULL, IDC_SIZEALL));

    if (HIWORD(lParam) == WM_LBUTTONDOWN) {
        // start drag
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);
    } else {
        return;
    }
    }

    SetCapture(hStatusWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_XY,
    MAKELONG(ptSavCursor.x, ptSavCursor.y));
    GetWindowRect(hStatusWnd, &rcWnd);
    SetWindowLong(hStatusWnd, UI_MOVE_OFFSET,
    MAKELONG(ptSavCursor.x - rcWnd.left, ptSavCursor.y - rcWnd.top));

    DrawDragBorder(hStatusWnd, MAKELONG(ptSavCursor.x, ptSavCursor.y),
    GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));

    return;
}


/**********************************************************************/
/* PaintStatusWindow()                                                */
/**********************************************************************/
void PASCAL PaintStatusWindow(
    HDC  hDC,
    HWND hStatusWnd)
{
    HWND           hUIWnd;
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGDIOBJ        hOldFont;
    HBITMAP        hImeIconBmp, hShapeBmp, hSymbolBmp, hSKBmp;
    HBITMAP        hOldBmp;
    HDC            hMemDC;

    hUIWnd = GetWindow(hStatusWnd, GW_OWNER);

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
       MessageBeep((UINT)-1);
       return;
    }

    if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
       MessageBeep((UINT)-1);
       return;
    }

    // get lpImcP
    if(!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        MessageBeep((UINT)-1);
        return;
    }

#if defined(COMBO_IME)
    //in case the IME index has been changed and the ImeName size is different
    {
       POINTS         ptPos;

       ptPos.x = (short)lpIMC->ptStatusWndPos.x;
       ptPos.y = (short)lpIMC->ptStatusWndPos.y;

       SetWindowPos(hStatusWnd, NULL,
                    ptPos.x, ptPos.y,
                    sImeG.xStatusWi, sImeG.yStatusHi, 
                    SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_NOZORDER);
    }
#endif //COMBO_IME

    // set font
    if (sImeG.fDiffSysCharSet) {
        LOGFONT lfFont;

        ZeroMemory(&lfFont, sizeof(lfFont));
        hOldFont = GetCurrentObject(hDC, OBJ_FONT);
        lfFont.lfHeight = -MulDiv(12, GetDeviceCaps(hDC, LOGPIXELSY), 72);
        lfFont.lfCharSet = NATIVE_CHARSET;
        lstrcpy(lfFont.lfFaceName, TEXT("Simsun"));
        SelectObject(hDC, CreateFontIndirect(&lfFont));
    }

    // draw Ime Name

    if (lpIMC->fOpen) {
       SetTextColor(hDC, RGB(0x00, 0x00, 0x00));
    } else {
       SetTextColor(hDC, RGB(0x80, 0x80, 0x80));
    }

    SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));
    DrawText(hDC, szImeName, lstrlen(szImeName),
             &sImeG.rcImeName, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    
    DrawConvexRect(hDC,
    sImeG.rcImeName.left,
    sImeG.rcImeName.top,
    sImeG.rcImeName.right - 1,
    sImeG.rcImeName.bottom - 1);

    DrawConvexRectP(hDC,
    sImeG.rcImeName.left,
    sImeG.rcImeName.top,
    sImeG.rcImeName.right,
    sImeG.rcImeName.bottom);

    // load all bitmap
    hSymbolBmp = (HBITMAP)NULL;
    hShapeBmp = (HBITMAP)NULL;
    hSKBmp = (HBITMAP)NULL;

    if (!lpIMC->fOpen) {
       hSymbolBmp = LoadBitmap(hInst, szNone);
       hShapeBmp = LoadBitmap(hInst, szNone);
       hSKBmp = LoadBitmap(hInst, szNone);
       hImeIconBmp = LoadBitmap(hInst, szChinese);
    } else if (lpIMC->fdwConversion & IME_CMODE_NATIVE) {
              hImeIconBmp = LoadBitmap(hInst, szChinese);
           } else {
              hImeIconBmp = LoadBitmap(hInst, szEnglish);
           }

           if (!hShapeBmp) {
              if (lpIMC->fdwConversion & IME_CMODE_FULLSHAPE) {
                 hShapeBmp = LoadBitmap(hInst, szFullShape);
              } else {
                 hShapeBmp = LoadBitmap(hInst, szHalfShape);
              }
           }

           if (!hSymbolBmp) {
              if (lpIMC->fdwConversion & IME_CMODE_SYMBOL) {
                 hSymbolBmp = LoadBitmap(hInst, szSymbol);
              } else {
                 hSymbolBmp = LoadBitmap(hInst, szNoSymbol);
              }
           }

           if (!hSKBmp) {
              if (lpIMC->fdwConversion & IME_CMODE_SOFTKBD) {
                 hSKBmp = LoadBitmap(hInst, szSoftKBD);
           } else {
                 hSKBmp = LoadBitmap(hInst, szNoSoftKBD);
           }
    }

    ImmUnlockIMC(hIMC);
    ImmUnlockIMCC(lpIMC->hPrivate);

    hMemDC = CreateCompatibleDC(hDC);

    hOldBmp = SelectObject(hMemDC, hImeIconBmp);

    BitBlt(hDC, sImeG.rcImeIcon.left, sImeG.rcImeIcon.top,
           sImeG.rcImeIcon.right - sImeG.rcImeIcon.left,
           STATUS_DIM_Y,
           hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hShapeBmp);

    BitBlt(hDC, sImeG.rcShapeText.left, sImeG.rcShapeText.top,
           sImeG.rcShapeText.right - sImeG.rcShapeText.left,
           STATUS_DIM_Y,
           hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hSymbolBmp);

    BitBlt(hDC, sImeG.rcSymbol.left, sImeG.rcSymbol.top,
           sImeG.rcSymbol.right - sImeG.rcSymbol.left,
           STATUS_DIM_Y,
           hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hSKBmp);

    BitBlt(hDC, sImeG.rcSKText.left, sImeG.rcSKText.top,
           sImeG.xStatusWi - sImeG.rcSKText.left,
           STATUS_DIM_Y,
           hMemDC, 0, 0, SRCCOPY);

    SelectObject(hMemDC, hOldBmp);

    DeleteDC(hMemDC);

    DeleteObject(hImeIconBmp);
    DeleteObject(hSymbolBmp);
    DeleteObject(hShapeBmp);
    DeleteObject(hSKBmp);
    if (sImeG.fDiffSysCharSet) {
        DeleteObject(SelectObject(hDC, hOldFont));
    }

    return;
}

/**********************************************************************/
/* StatusWndProc()                                                    */
/**********************************************************************/
LRESULT CALLBACK StatusWndProc(
    HWND   hStatusWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
    case WM_DESTROY:
    DestroyStatusWindow(hStatusWnd);
    break;
    case WM_SETCURSOR:
    StatusSetCursor(hStatusWnd, lParam);
    break;
    case WM_MOUSEMOVE:
    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        POINT ptCursor;

        DrawDragBorder(hStatusWnd,
        GetWindowLong(hStatusWnd, UI_MOVE_XY),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
        GetCursorPos(&ptCursor);
        SetWindowLong(hStatusWnd, UI_MOVE_XY,
        MAKELONG(ptCursor.x, ptCursor.y));
        DrawDragBorder(hStatusWnd, MAKELONG(ptCursor.x, ptCursor.y),
        GetWindowLong(hStatusWnd, UI_MOVE_OFFSET));
    } else {
        return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }
    break;
    case WM_LBUTTONUP:

    if (GetWindowLong(hStatusWnd, UI_MOVE_OFFSET) != WINDOW_NOT_DRAG) {
        LONG  lTmpCursor, lTmpOffset;

        lTmpCursor = GetWindowLong(hStatusWnd, UI_MOVE_XY);

        // calculate the org by the offset
        lTmpOffset = GetWindowLong(hStatusWnd, UI_MOVE_OFFSET);

        DrawDragBorder(hStatusWnd, lTmpCursor, lTmpOffset);

        (*(LPPOINTS)&lTmpCursor).x -= (*(LPPOINTS)&lTmpOffset).x;
        (*(LPPOINTS)&lTmpCursor).y -= (*(LPPOINTS)&lTmpOffset).y;

        SetWindowLong(hStatusWnd, UI_MOVE_OFFSET, WINDOW_NOT_DRAG);
        ReleaseCapture();

        AdjustStatusBoundary((LPPOINTS)&lTmpCursor,
                        GetWindow(hStatusWnd, GW_OWNER));

        SendMessage(GetWindow(hStatusWnd, GW_OWNER), WM_IME_CONTROL,
        IMC_SETSTATUSWINDOWPOS, lTmpCursor);
    } else {
        return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }
    break;

    case WM_IME_NOTIFY:
        // get work area for changing
        SystemParametersInfo(SPI_GETWORKAREA, 0, &sImeG.rcWorkArea, 0);

    if (wParam == IMN_SETSTATUSWINDOWPOS) {
        SetStatusWindowPos(hStatusWnd);
    }
    break;
    case WM_PAINT:
    {
        HDC         hDC;
        PAINTSTRUCT ps;

        hDC = BeginPaint(hStatusWnd, &ps);
        PaintStatusWindow(hDC, hStatusWnd);
        EndPaint(hStatusWnd, &ps);
    }
    break;
    case WM_MOUSEACTIVATE:
    return (MA_NOACTIVATE);
    default:
    return DefWindowProc(hStatusWnd, uMsg, wParam, lParam);
    }

    return (0L);
}

/**********************************************************************/
/* ImeVerDlgProc()                                                    */
/* Return Value:                                                      */
/*      TRUE - successful, FALSE - failure                            */
/**********************************************************************/
BOOL FAR PASCAL ImeVerDlgProc(  // dialog procedure of configuration
    HWND hDlg,
    UINT uMessage,
    WORD wParam,
    LONG lParam)
{
    RECT rc;
    LONG DlgWidth, DlgHeight;

    switch (uMessage) {
    case WM_INITDIALOG:
         hCrtDlg = hDlg;        
         // reset position
         GetWindowRect(hDlg, &rc);
         DlgWidth =  rc.right - rc.left;
         DlgHeight =  rc.bottom - rc.top;
    
         SetWindowPos(hDlg, HWND_TOP,
                      (int)(sImeG.rcWorkArea.right - DlgWidth)/2,
                      (int)(sImeG.rcWorkArea.bottom - DlgHeight)/2,
                      (int)0, (int)0, SWP_NOSIZE);

         return (TRUE);          // don't want to set focus to special control
    case WM_COMMAND:
    switch (wParam) {
    case IDOK:
        EndDialog(hDlg, FALSE);
        break;
    case IDCANCEL:
        EndDialog(hDlg, FALSE);
        break;
    default:
        return (FALSE);
        break;
    }
    return (TRUE);

    case WM_CLOSE:        
        EndDialog(hDlg, FALSE);
        return FALSE;

    case WM_PAINT:
        {
            RECT rc;

        GetClientRect(hDlg, &rc);
            DrawConvexRect(GetDC(hDlg),
            rc.left + 10,
            rc.top + 10,
            rc.right - 10 - 1,
            rc.bottom - 43 - 1);

            DrawConvexRectP(GetDC(hDlg),
            rc.left + 10,
            rc.top + 10,
            rc.right - 10,
            rc.bottom - 43);
        }
        
    return (FALSE);
    default:
    return (FALSE);
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgb\ui.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ui.c


++*/


#include <windows.h>
#include <immdev.h>
#include <imedefs.h>
#include <regstr.h>



/**********************************************************************/
/* CMenuDestryed()                                                    */
/**********************************************************************/
void PASCAL CMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    
        return;
    }

    lpUIPrivate->hCMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}
/**********************************************************************/
/* SoftkeyMenuDestroyed()                                                    */
/**********************************************************************/
void PASCAL SoftkeyMenuDestroyed(             // context menu window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    
        return;
    }

    lpUIPrivate->hSoftkeyMenuWnd = NULL;

    GlobalUnlock(hUIPrivate);
}

/**********************************************************************/
/* CreateUIWindow()                                                   */
/**********************************************************************/
void PASCAL CreateUIWindow(             // create composition window
    HWND hUIWnd)
{
    HGLOBAL hUIPrivate;

    // create storage for UI setting
    hUIPrivate = GlobalAlloc(GHND, sizeof(UIPRIV));
    if (!hUIPrivate) {     
        return;
    }

    SetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE, (LONG_PTR)hUIPrivate);

    // set the default position for UI window, it is hide now
    SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    ShowWindow(hUIWnd, SW_SHOWNOACTIVATE);

    return;
}

/**********************************************************************/
/* DestroyUIWindow()                                                  */
/**********************************************************************/
void PASCAL DestroyUIWindow(            // destroy composition window
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    
        return;
    }

    //destroy ContextMenuWnd
    if (lpUIPrivate->hCMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hCMenuWnd, CMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hCMenuWnd, WM_USER_DESTROY, 0, 0);
    }
    //destroy SoftkeyMenuWnd
    if (lpUIPrivate->hSoftkeyMenuWnd) {
        SetWindowLongPtr(lpUIPrivate->hSoftkeyMenuWnd, SOFTKEYMENU_HUIWND,(LONG_PTR)0);
        PostMessage(lpUIPrivate->hSoftkeyMenuWnd, WM_USER_DESTROY, 0, 0);
    }

    // composition window need to be destroyed
    if (lpUIPrivate->hCompWnd) {
        DestroyWindow(lpUIPrivate->hCompWnd);
    }

    // candidate window need to be destroyed
    if (lpUIPrivate->hCandWnd) {
        DestroyWindow(lpUIPrivate->hCandWnd);
    }

    // status window need to be destroyed
    if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    }

    // soft keyboard window need to be destroyed
    if (lpUIPrivate->hSoftKbdWnd) {
        ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
    }

    GlobalUnlock(hUIPrivate);

    // free storage for UI settings
    GlobalFree(hUIPrivate);

    return;
}

/**********************************************************************/
/* ShowSoftKbd                                                        */
/**********************************************************************/
void PASCAL ShowSoftKbd(   // Show the soft keyboard window
    HWND          hUIWnd,
    int           nShowSoftKbdCmd,
    LPPRIVCONTEXT lpImcP)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        return;
    }

    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL1, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL2, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL3, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL4, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL5, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL6, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL7, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL8, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL9, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL10, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL11, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL12, MF_UNCHECKED);
    CheckMenuItem(lpImeL->hSKMenu, IDM_SKL13, MF_UNCHECKED);

    if (!lpUIPrivate->hSoftKbdWnd) {
        // not in show status window mode
    } else if (lpUIPrivate->nShowSoftKbdCmd != nShowSoftKbdCmd) {
        ImmShowSoftKeyboard(lpUIPrivate->hSoftKbdWnd, nShowSoftKbdCmd);
        lpUIPrivate->nShowSoftKbdCmd = nShowSoftKbdCmd;
    }

    GlobalUnlock(hUIPrivate);
    return;
}

/**********************************************************************/
/* CheckSoftKbdPosition()                                             */
/**********************************************************************/
void PASCAL CheckSoftKbdPosition(
    LPUIPRIV       lpUIPrivate,
    LPINPUTCONTEXT lpIMC)
{

#ifndef MUL_MONITOR
    UINT fPortionBits = 0;
    UINT fPortionTest;
    int  xPortion, yPortion, nPortion;
    RECT rcWnd;

    // portion of dispaly
    // 0  1
    // 2  3

    if (lpUIPrivate->hCompWnd) {
        GetWindowRect(lpUIPrivate->hCompWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    if (lpUIPrivate->hStatusWnd) {
        GetWindowRect(lpUIPrivate->hStatusWnd, &rcWnd);

        if (rcWnd.left > sImeG.rcWorkArea.right / 2) {
            xPortion = 1;
        } else {
            xPortion = 0;
        }

        if (rcWnd.top > sImeG.rcWorkArea.bottom / 2) {
            yPortion = 1;
        } else {
            yPortion = 0;
        }

        fPortionBits |= 0x0001 << (yPortion * 2 + xPortion);
    }

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    // start from portion 3
    for (nPortion = 3, fPortionTest = 0x0008; fPortionTest;
        nPortion--, fPortionTest >>= 1) {
        if (fPortionTest & fPortionBits) {
            // someone here!
            continue;
        }

        if (nPortion % 2) {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.right -
                (rcWnd.right - rcWnd.left) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.x = sImeG.rcWorkArea.left;
        }

        if (nPortion / 2) {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.bottom -
                (rcWnd.bottom - rcWnd.top) - UI_MARGIN;
        } else {
            lpIMC->ptSoftKbdPos.y = sImeG.rcWorkArea.top;
        }

        lpIMC->fdwInit |= INIT_SOFTKBDPOS;

        break;
    }
#else   //MUL_MONITOR
    RECT rcWorkArea, rcWnd;

    GetWindowRect(lpUIPrivate->hSoftKbdWnd, &rcWnd);

    rcWorkArea = ImeMonitorWorkAreaFromWindow(lpIMC->hWnd);

    lpIMC->ptSoftKbdPos.x = rcWorkArea.right -
                            (rcWnd.right-rcWnd.left)-UI_MARGIN;

    lpIMC->ptSoftKbdPos.y = rcWorkArea.bottom -
                            (rcWnd.bottom-rcWnd.top)-UI_MARGIN;
#endif
    return;
}

/**********************************************************************/
/* SetSoftKbdData()                                                   */
/**********************************************************************/
void PASCAL SetSoftKbdData(
    HWND           hSoftKbdWnd,
    LPINPUTCONTEXT lpIMC)
{
    int         i;
    LPSOFTKBDDATA lpSoftKbdData;
    LPPRIVCONTEXT  lpImcP;

    HGLOBAL hsSoftKbdData;

       lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        return;
    }
    
    hsSoftKbdData = GlobalAlloc(GHND, sizeof(SOFTKBDDATA) * 2);
    if (!hsSoftKbdData) {
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData = (LPSOFTKBDDATA)GlobalLock(hsSoftKbdData);
    if (!lpSoftKbdData) {         // can not draw soft keyboard window
        ImmUnlockIMCC(lpIMC->hPrivate);
        return;
    }

    lpSoftKbdData->uCount = 2;

    for (i = 0; i < 48; i++) {
        BYTE bVirtKey;

        bVirtKey = VirtKey48Map[i];

        if (!bVirtKey) {
            continue;
        }

        {
            WORD CHIByte, CLOByte;

#ifdef UNICODE
            lpSoftKbdData->wCode[0][bVirtKey] = SKLayout[lpImeL->dwSKWant][i];
            lpSoftKbdData->wCode[1][bVirtKey] = SKLayoutS[lpImeL->dwSKWant][i];
#else
            CHIByte = SKLayout[lpImeL->dwSKWant][i*2] & 0x00ff;
            CLOByte = SKLayout[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
            lpSoftKbdData->wCode[0][bVirtKey] = (CHIByte << 8) | CLOByte;
            CHIByte = SKLayoutS[lpImeL->dwSKWant][i*2] & 0x00ff;
            CLOByte = SKLayoutS[lpImeL->dwSKWant][i*2 + 1] & 0x00ff;
            lpSoftKbdData->wCode[1][bVirtKey] = (CHIByte << 8) | CLOByte;
#endif
        }
    }

    SendMessage(hSoftKbdWnd, WM_IME_CONTROL, IMC_SETSOFTKBDDATA,
        (LPARAM)lpSoftKbdData);

    GlobalUnlock(hsSoftKbdData);

    // free storage for UI settings
    GlobalFree(hsSoftKbdData);
    ImmUnlockIMCC(lpIMC->hPrivate);
    return;
}

/**********************************************************************/
/* UpdateSoftKbd()                                                    */
/**********************************************************************/
void PASCAL UpdateSoftKbd(
    HWND   hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw soft keyboard window
        ImmUnlockIMC(hIMC);
        return;
    }

    lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
    if (!lpImcP) {
        GlobalUnlock(hUIPrivate);
        ImmUnlockIMC(hIMC);
        return;
    }

    if (!(lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (lpUIPrivate->hSoftKbdWnd) {

            ImmDestroySoftKeyboard(lpUIPrivate->hSoftKbdWnd);
            lpUIPrivate->hSoftKbdWnd = NULL;
        }

        lpUIPrivate->nShowSoftKbdCmd = SW_HIDE;
    } else if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowSoftKbdCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }
    } else {
        if (!lpUIPrivate->hSoftKbdWnd) {
            // create soft keyboard
            lpUIPrivate->hSoftKbdWnd =
                ImmCreateSoftKeyboard(SOFTKEYBOARD_TYPE_C1, hUIWnd,
                0, 0);
        }

        if (!(lpIMC->fdwInit & INIT_SOFTKBDPOS)) {
            CheckSoftKbdPosition(lpUIPrivate, lpIMC);
        }

        SetSoftKbdData(lpUIPrivate->hSoftKbdWnd, lpIMC);

        lpUIPrivate->fdwSetContext |= ISC_SHOW_SOFTKBD;

        if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            SetWindowPos(lpUIPrivate->hSoftKbdWnd, NULL,
                lpIMC->ptSoftKbdPos.x, lpIMC->ptSoftKbdPos.y,
                0, 0, SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);

            // only show, if the application want to show it
            if (lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) {
                ShowSoftKbd(hUIWnd, SW_SHOWNOACTIVATE, lpImcP);
            }
        }
    }

    ImmUnlockIMCC(lpIMC->hPrivate);
    GlobalUnlock(hUIPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* SoftKbdDestryed()                                                  */
/**********************************************************************/
void PASCAL SoftKbdDestroyed(           // soft keyboard window
                                        // already destroyed
    HWND hUIWnd)
{
    HGLOBAL  hUIPrivate;
    LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {     
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {    
        return;
    }

    lpUIPrivate->hSoftKbdWnd = NULL;

    GlobalUnlock(hUIPrivate);
}

/**********************************************************************/
/* StatusWndMsg()                                                     */
/**********************************************************************/
void PASCAL StatusWndMsg(       // set the show hide state and
    HWND        hUIWnd,
    BOOL        fOn)
{
    HGLOBAL  hUIPrivate;
    HIMC     hIMC;
    HWND     hStatusWnd;

    register LPUIPRIV lpUIPrivate;

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return;
    }

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        GlobalUnlock(hUIPrivate);
    return;
    }

    if (fOn) {
        lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;

        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(
                hUIWnd);
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~(ISC_OPEN_STATUS_WINDOW);
    }

    hStatusWnd = lpUIPrivate->hStatusWnd;

    GlobalUnlock(hUIPrivate);

    if (!hStatusWnd) {
        return;
    }

    if (!fOn) {
        register DWORD fdwSetContext;

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
                hUIWnd, SW_HIDE);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOW_SOFTKBD|ISC_HIDE_SOFTKBD);

        if (fdwSetContext == ISC_HIDE_SOFTKBD) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_SOFTKBD);
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }

        ShowStatus(
            hUIWnd, SW_HIDE);
    } else if (hIMC) {
        ShowStatus(
            hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowStatus(
            hUIWnd, SW_HIDE);
    }

    return;
}

/**********************************************************************/
/* ShowUI()                                                           */
/**********************************************************************/
void PASCAL ShowUI(             // show the sub windows
    HWND   hUIWnd,
    int    nShowCmd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    LPUIPRIV       lpUIPrivate;

    if (nShowCmd == SW_HIDE) {
    } else if (!(hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC))) {
        nShowCmd = SW_HIDE;
    } else if (!(lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate))) {
        ImmUnlockIMC(hIMC);
        nShowCmd = SW_HIDE;
    } else {
    }

    if (nShowCmd == SW_HIDE) {
        ShowStatus(hUIWnd, nShowCmd);
        ShowComp(hUIWnd, nShowCmd);
        ShowCand(hUIWnd, nShowCmd);
        ShowSoftKbd(hUIWnd, nShowCmd, NULL);
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {          // can not darw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {         // can not draw status window
        goto ShowUIUnlockIMCC;
    }

    lpUIPrivate->fdwSetContext |= ISC_SHOWUICOMPOSITIONWINDOW;

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICOMPOSITIONWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_START)) {
        if (lpUIPrivate->hCompWnd) {

            if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
                RedrawWindow(lpUIPrivate->hCompWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            if (sImeG.IC_Trace) {            // modify 95.7.17
                SendMessage(lpUIPrivate->hCompWnd, WM_IME_NOTIFY,
                    IMN_SETCOMPOSITIONWINDOW, 0);
            }

            if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
                ShowComp(hUIWnd, nShowCmd);
            }
        } else {
            StartComp(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCompCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_COMP_WINDOW;
    } else {
        ShowComp(hUIWnd, SW_HIDE);
    }

    if ((lpUIPrivate->fdwSetContext & ISC_SHOWUICANDIDATEWINDOW) &&
        (lpImcP->fdwImeMsg & MSG_ALREADY_OPEN)) {
        if (lpUIPrivate->hCandWnd) {
            if (lpUIPrivate->nShowCandCmd != SW_HIDE) {
                // some time the WM_NCPAINT is eaten by the app
                RedrawWindow(lpUIPrivate->hCandWnd, NULL, NULL,
                    RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
            }

            if (sImeG.IC_Trace) {            
                SendMessage(lpUIPrivate->hCandWnd, WM_IME_NOTIFY,
                    IMN_SETCANDIDATEPOS, 0x0001);
            }

            if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
                ShowCand(hUIWnd, nShowCmd);
            }
        } else {
            OpenCand(hUIWnd);
        }
    } else if (lpUIPrivate->nShowCandCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_CAND_WINDOW;
    } else {
        ShowCand(hUIWnd, SW_HIDE);
    }

    if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        if (!lpUIPrivate->hStatusWnd) {
            OpenStatus(hUIWnd);
        }
        if (lpUIPrivate->nShowStatusCmd != SW_HIDE) {
            // some time the WM_NCPAINT is eaten by the app
            RedrawWindow(lpUIPrivate->hStatusWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE|RDW_ERASE);
        }

        SendMessage(lpUIPrivate->hStatusWnd, WM_IME_NOTIFY,
            IMN_SETSTATUSWINDOWPOS, 0);
        if (lpUIPrivate->nShowStatusCmd == SW_HIDE) {
            ShowStatus(hUIWnd, nShowCmd);
        }
        else{
            ShowStatus(hUIWnd, nShowCmd);
        }
    } else if (lpUIPrivate->hStatusWnd) {
        DestroyWindow(lpUIPrivate->hStatusWnd);
    } 

    if (!lpIMC->fOpen) {
        if (lpUIPrivate->nShowCompCmd != SW_HIDE) {
            ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
        }
    } else if ((lpUIPrivate->fdwSetContext & ISC_SHOW_SOFTKBD) &&
        (lpIMC->fdwConversion & IME_CMODE_SOFTKBD)) {
        if (!lpUIPrivate->hSoftKbdWnd) {
            UpdateSoftKbd(hUIWnd);
        } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
            ShowSoftKbd(hUIWnd, nShowCmd, lpImcP);
        } else if (lpUIPrivate->hIMC != hIMC) {
            UpdateSoftKbd(hUIWnd);
        } else {
            RedrawWindow(lpUIPrivate->hSoftKbdWnd, NULL, NULL,
                RDW_FRAME|RDW_INVALIDATE);
        }
    } else if (lpUIPrivate->nShowSoftKbdCmd == SW_HIDE) {
    } else if (lpUIPrivate->fdwSetContext & ISC_OPEN_STATUS_WINDOW) {
        lpUIPrivate->fdwSetContext |= ISC_HIDE_SOFTKBD;
    } else {
        ShowSoftKbd(hUIWnd, SW_HIDE, NULL);
    }

    // we switch to this hIMC
    lpUIPrivate->hIMC = hIMC;

    GlobalUnlock(hUIPrivate);

ShowUIUnlockIMCC:
    ImmUnlockIMCC(lpIMC->hPrivate);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* ShowGuideLine                                                      */
/**********************************************************************/
void PASCAL ShowGuideLine(
    HWND hUIWnd)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPGUIDELINE    lpGuideLine;

    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
    if (!hIMC) {
        return;
    }

    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    lpGuideLine = (LPGUIDELINE)ImmLockIMCC(lpIMC->hGuideLine);

    if (!lpGuideLine) {
    } else if (lpGuideLine->dwLevel == GL_LEVEL_ERROR) {
        MessageBeep((UINT)-1);
        MessageBeep((UINT)-1);
    } else if (lpGuideLine->dwLevel == GL_LEVEL_WARNING) {
        MessageBeep((UINT)-1);
    } else {
    }

    ImmUnlockIMCC(lpIMC->hGuideLine);
    ImmUnlockIMC(hIMC);

    return;
}

/**********************************************************************/
/* UpdateStatusWindow()                                               */
/* Return Value:                                                      */
/*     none                                                             */
/**********************************************************************/
BOOL UpdateStatusWindow(
    HWND   hUIWnd)
{
    HWND           hStatusWnd;

    if (!(hStatusWnd = GetStatusWnd(hUIWnd))) {
        return (FALSE);
    }

    InvalidateRect(hStatusWnd, &(sImeG.rcStatusText), TRUE);
    UpdateWindow(hStatusWnd);

    return (TRUE);
}


/**********************************************************************/
/* NotifyUI()                                                         */
/**********************************************************************/
void PASCAL NotifyUI(
    HWND        hUIWnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hStatusWnd;

    switch (wParam) {
    case IMN_OPENSTATUSWINDOW:
        //PostStatus(hUIWnd, TRUE);
        StatusWndMsg(hUIWnd, TRUE);
        break;
    case IMN_CLOSESTATUSWINDOW:
        //PostStatus(hUIWnd, FALSE);
        StatusWndMsg(hUIWnd, FALSE);
        break;
    case IMN_OPENCANDIDATE:
        if (lParam & 0x00000001) {
            OpenCand(hUIWnd);
        }
        break;
    case IMN_CHANGECANDIDATE:
        if (lParam & 0x00000001) {
            HDC  hDC;
            HWND hCandWnd;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            hDC = GetDC(hCandWnd);
            PaintCandWindow(hCandWnd, hDC);
            ReleaseDC(hCandWnd, hDC);
        }
        break;
    case IMN_CLOSECANDIDATE:
        if (lParam & 0x00000001) {
            CloseCand(hUIWnd);
        }
        break;
    case IMN_SETSENTENCEMODE:
        break;
    case IMN_SETOPENSTATUS:
    case IMN_SETCONVERSIONMODE:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (!hStatusWnd) {
            return;
        }

        {
            RECT rcRect;

            rcRect = sImeG.rcStatusText;
            
            // off by 1
            rcRect.right += 1;
            rcRect.bottom += 1;

            RedrawWindow(hStatusWnd, &rcRect, NULL, RDW_INVALIDATE);
        }
        break;
    case IMN_SETCOMPOSITIONFONT:
        // we are not going to change font, but an IME can do this if it want
        break;
    case IMN_SETCOMPOSITIONWINDOW:
        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);
            if (!hCompWnd) {
                return;
            }

            PostMessage(hCompWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
    case IMN_SETCANDIDATEPOS:
        {
            HWND hCandWnd;

            hCandWnd = GetCandWnd(hUIWnd);
            if (!hCandWnd) {
                return;
            }

            PostMessage(hCandWnd, WM_IME_NOTIFY, wParam, lParam);
        }
        break;
    case IMN_SETSTATUSWINDOWPOS:
        hStatusWnd = GetStatusWnd(hUIWnd);
        if (hStatusWnd) {
            PostMessage(hStatusWnd, WM_IME_NOTIFY, wParam, lParam);
        } else {
        }
        break;
    case IMN_GUIDELINE:
        ShowGuideLine(hUIWnd);

        break;
    case IMN_PRIVATE:
        switch (lParam) {
        case IMN_PRIVATE_UPDATE_SOFTKBD:
            UpdateSoftKbd(hUIWnd);
            break;
        case IMN_PRIVATE_UPDATE_STATUS:
            UpdateStatusWindow(hUIWnd);
            break;
        case IMN_PRIVATE_DESTROYCANDWIN:
            SendMessage(GetCandWnd(hUIWnd), WM_DESTROY, (WPARAM)0, (LPARAM)0);
            break;
        case IMN_PRIVATE_CMENUDESTROYED:
            CMenuDestroyed(hUIWnd);
            break;
        case IMN_PRIVATE_SOFTKEYMENUDESTROYED:
            SoftkeyMenuDestroyed(hUIWnd);
            break;
        }
        break;
    case IMN_SOFTKBDDESTROYED:
        SoftKbdDestroyed(hUIWnd);
        break;
    default:
        break;
    }

    return;
}

/**********************************************************************/
/* SetContext()                                                       */
/**********************************************************************/
void PASCAL SetContext(         // the context activated/deactivated
    HWND   hUIWnd,
    BOOL   fOn,
    LPARAM lShowUI)
{
    HIMC           hIMC;
    LPINPUTCONTEXT lpIMC;
    LPPRIVCONTEXT  lpImcP;
    HGLOBAL        hUIPrivate;
    register LPUIPRIV lpUIPrivate;
#if defined(COMBO_IME)
    DWORD    dwRegImeIndex;
#endif
    RECT            rcWorkArea;

#ifdef MUL_MONITOR
    rcWorkArea = ImeMonitorWorkAreaFromWindow(hUIWnd);
#else
    rcWorkArea = sImeG.rcWorkArea;
#endif


    hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);

    if (!hIMC) {          
        return ;
    }

    // get lpIMC
    lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
    if (!lpIMC) {
        return;
    }

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        ImmUnlockIMC(hIMC);
        return;
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        ImmUnlockIMC(hIMC);
        return;
    }

    if (fOn) {
        register DWORD fdwSetContext;

        lpUIPrivate->fdwSetContext = lpUIPrivate->fdwSetContext &
            ~(ISC_SHOWUIALL|ISC_HIDE_SOFTKBD);

        lpUIPrivate->fdwSetContext |= (lShowUI & ISC_SHOWUIALL) |
            ISC_SHOW_SOFTKBD;

        {
        HKEY hKey;
        DWORD bcData; 
        char buf[256];
        bcData=256;
        if(RegOpenKeyEx (HKEY_CURRENT_USER,
                         TEXT("Control Panel\\Input Method"),
                         0,
                         KEY_ENUMERATE_SUB_KEYS |
                         KEY_EXECUTE |
                         KEY_QUERY_VALUE,
                         &hKey)){
            goto SetShowStatus;
        }
        if(RegQueryValueEx (hKey, TEXT("show status"),
                     NULL,
                     NULL,             //null-terminate string
                     (LPBYTE)buf,              //&bData,
                     &bcData) != ERROR_SUCCESS){
                     // Set default as ON if no entry in registry
                     lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;
                 goto SetShowStatus;
             }
        if(strcmp(buf, "1")==0)
            lpUIPrivate->fdwSetContext |= ISC_OPEN_STATUS_WINDOW;
        else
            lpUIPrivate->fdwSetContext &= ~ISC_OPEN_STATUS_WINDOW;
SetShowStatus:
        RegCloseKey(hKey);
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICOMPOSITIONWINDOW|ISC_HIDE_COMP_WINDOW);

        if (fdwSetContext == ISC_HIDE_COMP_WINDOW) {
            ShowComp(
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_COMP_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_COMP_WINDOW);
        } else {
        }

        fdwSetContext = lpUIPrivate->fdwSetContext &
            (ISC_SHOWUICANDIDATEWINDOW|ISC_HIDE_CAND_WINDOW);

        if (fdwSetContext == ISC_HIDE_CAND_WINDOW) {
            ShowCand(
                hUIWnd, SW_HIDE);
        } else if (fdwSetContext & ISC_HIDE_CAND_WINDOW) {
            lpUIPrivate->fdwSetContext &= ~(ISC_HIDE_CAND_WINDOW);
        } else {
        }

        if (lpIMC->cfCandForm[0].dwIndex != 0) {
            lpIMC->cfCandForm[0].dwStyle = CFS_DEFAULT;
        }


        lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
        if (!lpImcP) {
            GlobalUnlock(hUIPrivate);
            ImmUnlockIMC(hIMC);
            return;
        }

        // init ime properties & reset context
        {
            HKEY  hKeyCurrVersion;
            HKEY  hKeyGB;
            DWORD ValueType;
            DWORD ValueSize;
            LONG    retCode;

            retCode = OpenReg_PathSetup(&hKeyCurrVersion);
            if (retCode) {
            TCHAR    Buf[MAX_PATH];
                wsprintf (Buf, TEXT("Error: RegOpenKeyEx = %d"), retCode);
                MessageBox (lpIMC->hWnd, Buf, szWarnTitle, MB_OK | MB_ICONINFORMATION);
                return;
            }

#if defined(COMBO_IME)
            retCode = OpenReg_User (hKeyCurrVersion,
                               szImeRegName,
                               &hKeyGB);
#else
            retCode = OpenReg_User (hKeyCurrVersion,
                               szImeName,
                               &hKeyGB);
#endif //COMBO_IME
            // query  value
            ValueSize = sizeof(DWORD);
            RegQueryValueEx (hKeyGB,szTrace ,
                            (DWORD)0,
                               (LPDWORD)&ValueType,
                            (LPBYTE)&sImeG.IC_Trace,
                            (LPDWORD)&ValueSize);
#ifdef CROSSREF         
            if(RegQueryValueEx (hKeyGB, szRegRevKL,
                     NULL,
                     NULL,             //null-terminate string
                     (LPBYTE)&sImeG.hRevKL,              //&bData,
                     &ValueSize) != ERROR_SUCCESS)
            sImeG.hRevKL = NULL;
            if(RegQueryValueEx (hKeyGB, szRegRevMaxKey,
                     NULL,
                     NULL,             //null-terminate string
                     (LPBYTE)&sImeG.nRevMaxKey,              //&bData,
                     &ValueSize) != ERROR_SUCCESS)
            sImeG.hRevKL = NULL;
#endif
        

#if defined(COMBO_IME)
            // query  value
            ValueSize = sizeof(DWORD);
            RegQueryValueEx (hKeyGB, szRegImeIndex,
                            (DWORD)0,
                            (LPDWORD)&ValueType,
                            (LPBYTE)&dwRegImeIndex,
                            (LPDWORD)&ValueSize);
#endif

            RegCloseKey(hKeyGB);
            RegCloseKey(hKeyCurrVersion);

        }

#if defined(COMBO_IME)
        if(sImeL.dwRegImeIndex != dwRegImeIndex) {
        DWORD    dwConvMode;
        int        cxBorder, cyBorder;

            //change current IME index
            dwConvMode = lpIMC->fdwConversion ^ (IME_CMODE_INDEX_FIRST << sImeL.dwRegImeIndex);
            sImeL.dwRegImeIndex = dwRegImeIndex;
            szImeName = pszImeName[dwRegImeIndex];
            dwConvMode |= (IME_CMODE_INDEX_FIRST << dwRegImeIndex);
            // re-caculate statusuidata
            cxBorder = GetSystemMetrics(SM_CXBORDER);
            cyBorder = GetSystemMetrics(SM_CYBORDER);
            InitStatusUIData(cxBorder, cyBorder);

            ImmSetConversionStatus(hIMC, dwConvMode, lpIMC->fdwSentence);
        }
#endif //COMBO_IME

        if(sImeG.IC_Trace != SaTC_Trace) {
            int UI_MODE;

            lpImcP->iImeState = CST_INIT;
            CompCancel(hIMC, lpIMC);
            
            // init fields of hPrivate
            lpImcP->fdwImeMsg = (DWORD)0;
            lpImcP->dwCompChar = (DWORD)0;
            lpImcP->fdwGcsFlag = (DWORD)0;
            lpImcP->uSYHFlg = 0x00000000;
            lpImcP->uDYHFlg = 0x00000000;

            // change compwnd size

            // init fields of hIMC
            lpIMC->fOpen = TRUE;

            SendMessage(GetCandWnd(hUIWnd), WM_DESTROY, (WPARAM)0, (LPARAM)0);
            
            // set cand window data
            if(sImeG.IC_Trace) {
                UI_MODE = BOX_UI;
            } else {
                POINT ptSTFixPos;
            
    
                UI_MODE = LIN_UI;
                ptSTFixPos.x = 0;
                ptSTFixPos.y = rcWorkArea.bottom - sImeG.yStatusHi;
                ImmSetStatusWindowPos(hIMC, (LPPOINT)&ptSTFixPos);
            }
            
            InitCandUIData(
                GetSystemMetrics(SM_CXBORDER),
                GetSystemMetrics(SM_CYBORDER), UI_MODE);
        }
            
        SaTC_Trace = sImeG.IC_Trace;

        // init Caps
        {
            BYTE  lpbKeyState[256];
            DWORD fdwConversion;

            if (!GetKeyboardState(lpbKeyState))
                lpbKeyState[VK_CAPITAL] = 0;
                         
            if (lpbKeyState[VK_CAPITAL] & 0x01) {
                // 10.11 add
                uCaps = 1;
                // change to alphanumeric mode
                fdwConversion = lpIMC->fdwConversion & ~(IME_CMODE_CHARCODE |
                    IME_CMODE_NATIVE | IME_CMODE_EUDC);
            } else {
                // change to native mode
                if(uCaps == 1) {
                        fdwConversion = (lpIMC->fdwConversion | IME_CMODE_NATIVE) &
                        ~(IME_CMODE_CHARCODE | IME_CMODE_EUDC);
                } else {
                    fdwConversion = lpIMC->fdwConversion;
                }
                uCaps = 0;
            }
            ImmSetConversionStatus(hIMC, fdwConversion, lpIMC->fdwSentence);
        }

        if ((lpIMC->cfCompForm.dwStyle & CFS_FORCE_POSITION)
            && (sImeG.IC_Trace)) {
            POINT ptNew;            // new position of UI
            POINT ptSTWPos;

            ImmGetStatusWindowPos(hIMC, (LPPOINT)&ptSTWPos);

            ptNew.x = ptSTWPos.x + sImeG.xStatusWi + UI_MARGIN;
            if((ptSTWPos.x + sImeG.xStatusWi + sImeG.xCandWi + lpImeL->xCompWi + 2 * UI_MARGIN) >=
              rcWorkArea.right) { 
                ptNew.x = ptSTWPos.x - lpImeL->xCompWi - UI_MARGIN;
            }
            ptNew.x += lpImeL->cxCompBorder;
            ptNew.y = ptSTWPos.y + lpImeL->cyCompBorder;
            lpIMC->cfCompForm.ptCurrentPos = ptNew;

            ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
            lpIMC->cfCompForm.dwStyle = CFS_DEFAULT;
        }
    } else {
        lpUIPrivate->fdwSetContext &= ~ISC_SETCONTEXT_UI;
    }

    GlobalUnlock(hUIPrivate);

    UIPaint(hUIWnd);

    ImmUnlockIMC(hIMC);
    return;
}


/**********************************************************************/
/* GetCompWindow()                                                    */
/**********************************************************************/
LRESULT PASCAL GetCompWindow(
    HWND              hUIWnd,
    LPCOMPOSITIONFORM lpCompForm)
{
    HWND hCompWnd;
    RECT rcCompWnd;

    hCompWnd = GetCompWnd(hUIWnd);

    if (!hCompWnd) {
        return (1L);
    }

    if (!GetWindowRect(hCompWnd, &rcCompWnd)) {
        return (1L);
    }

    lpCompForm->dwStyle = CFS_POINT|CFS_RECT;
    lpCompForm->ptCurrentPos = *(LPPOINT)&rcCompWnd;
    lpCompForm->rcArea = rcCompWnd;

    return (0L);
}

/**********************************************************************/
/* SelectIME()                                                        */
/**********************************************************************/
void PASCAL SelectIME(          // switch IMEs
    HWND hUIWnd,
    BOOL fSelect)
{
    if (!fSelect) {
        ShowUI(hUIWnd, SW_HIDE);
    } else {

        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
          
    }

    return;
}

/**********************************************************************/
/* UIPaint()                                                          */
/**********************************************************************/
LRESULT PASCAL UIPaint(
    HWND        hUIWnd)
{
    PAINTSTRUCT ps;
    MSG         sMsg;
    HGLOBAL     hUIPrivate;
    LPUIPRIV    lpUIPrivate;

    // for safety
    BeginPaint(hUIWnd, &ps);
    EndPaint(hUIWnd, &ps);

    // some application will not remove the WM_PAINT messages
    PeekMessage(&sMsg, hUIWnd, WM_PAINT, WM_PAINT, PM_REMOVE|PM_NOYIELD);

    hUIPrivate = (HGLOBAL)GetWindowLongPtr(hUIWnd, IMMGWLP_PRIVATE);
    if (!hUIPrivate) {
        return (0L);
    }

    lpUIPrivate = (LPUIPRIV)GlobalLock(hUIPrivate);
    if (!lpUIPrivate) {
        return (0L);
    }

    if (lpUIPrivate->fdwSetContext & ISC_SETCONTEXT_UI) {
        ShowUI(hUIWnd, SW_SHOWNOACTIVATE);
    } else {
        ShowUI(hUIWnd, SW_HIDE);
    }

    GlobalUnlock(hUIPrivate);

    return (0L);
}

/**********************************************************************/
/* UIWndProc()                                                        */
/**********************************************************************/
LRESULT CALLBACK UIWndProc(
    HWND   hUIWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (uMsg) {
    case WM_CREATE:
        CreateUIWindow(hUIWnd);
        break;
    case WM_DESTROY:
        DestroyUIWindow(hUIWnd);
        break;
    case WM_IME_STARTCOMPOSITION:
        // you can create a window as the composition window here
        StartComp(hUIWnd);
        break;
    case WM_IME_COMPOSITION:
        if (!sImeG.IC_Trace) {
        } else if (lParam & GCS_RESULTSTR) {
            MoveDefaultCompPosition(hUIWnd);
        } else {
        }

        {
            HWND hCompWnd;

            hCompWnd = GetCompWnd(hUIWnd);

            if (hCompWnd) {
                RECT rcRect;

                rcRect = lpImeL->rcCompText;
                // off by 1
                rcRect.right += 1;
                rcRect.bottom += 1;

                RedrawWindow(hCompWnd, &rcRect, NULL, RDW_INVALIDATE);
            }
        }
        break;
    case WM_IME_ENDCOMPOSITION:
        // you can destroy the composition window here
        EndComp(hUIWnd);
        break;
    case WM_IME_NOTIFY:
        NotifyUI(hUIWnd, wParam, lParam);
        break;
    case WM_IME_SETCONTEXT:
        SetContext(hUIWnd, (BOOL)wParam, lParam);
        
        if (wParam && GetWindowLongPtr(hUIWnd, IMMGWLP_IMC))
            SetWindowPos(hUIWnd, NULL, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOMOVE);

        break;
    case WM_IME_CONTROL:
        switch (wParam) {
        case IMC_GETCANDIDATEPOS:
            return (1L);                    // not implemented yet
        case IMC_GETCOMPOSITIONFONT:
            return (1L);                    // not implemented yet
        case IMC_GETCOMPOSITIONWINDOW:
            return GetCompWindow(hUIWnd, (LPCOMPOSITIONFORM)lParam);
        case IMC_GETSTATUSWINDOWPOS:
            {
                HWND   hStatusWnd;
                RECT   rcStatusWnd;
                LPARAM lParam;

                hStatusWnd = GetStatusWnd(hUIWnd);
                if (!hStatusWnd) {
                    return (0L);    // fail, return (0, 0)?
                }

                if (!GetWindowRect(hStatusWnd, &rcStatusWnd)) {
                     return (0L);    // fail, return (0, 0)?
                }

                lParam = MAKELRESULT(rcStatusWnd.left, rcStatusWnd.top);

                return (lParam);
            }
            return (0L);
        case IMC_SETSTATUSWINDOWPOS:
            {
                HIMC            hIMC;
                LPINPUTCONTEXT  lpIMC;
                LPPRIVCONTEXT   lpImcP;
                //COMPOSITIONFORM CompForm;
                POINT           ptPos;
                RECT            rcWorkArea;

#ifdef MUL_MONITOR
                rcWorkArea = ImeMonitorWorkAreaFromWindow(hUIWnd);
#else
                rcWorkArea = sImeG.rcWorkArea;
#endif

                ptPos.x = ((LPPOINTS)&lParam)->x;
                ptPos.y = ((LPPOINTS)&lParam)->y;

                hIMC = (HIMC)GetWindowLongPtr(hUIWnd, IMMGWLP_IMC);
                if (!hIMC) {
                    return (1L);
                }

                if(!ImmSetStatusWindowPos(hIMC, &ptPos)) {
                    return (1L);
                }

                // set comp window position when TraceCuer
                lpIMC = (LPINPUTCONTEXT)ImmLockIMC(hIMC);
                if (!lpIMC) {
                    return (1L);
                }

                lpImcP = (LPPRIVCONTEXT)ImmLockIMCC(lpIMC->hPrivate);
                if (!lpImcP) {
                    return (1L);
                }

                if(!sImeG.IC_Trace) {
                    lpIMC->cfCompForm.dwStyle = CFS_RECT;
                    lpIMC->cfCompForm.ptCurrentPos.x = ptPos.x + sImeG.xStatusWi + UI_MARGIN;
                    lpIMC->cfCompForm.ptCurrentPos.y = ptPos.y;
                    CopyRect(&lpIMC->cfCompForm.rcArea, &rcWorkArea);

                    ScreenToClient(lpIMC->hWnd, &lpIMC->cfCompForm.ptCurrentPos);
                    // set composition window to the new poosition
                    PostMessage(GetCompWnd(hUIWnd), WM_IME_NOTIFY, IMN_SETCOMPOSITIONWINDOW, 0);

                }

                ImmUnlockIMCC(lpIMC->hPrivate);
                ImmUnlockIMC(hIMC);

                return (0L);
            }
            return (1L);
        default:
            return (1L);
        }
        break;
    case WM_IME_COMPOSITIONFULL:
        return (0L);
    case WM_IME_SELECT:
//#if  defined(LATER)
        SetContext(hUIWnd, (BOOL)wParam, 0);
//#else
//        SelectIME(hUIWnd, (BOOL)wParam);
//#endif
        return (0L);
    case WM_MOUSEACTIVATE:
        return (MA_NOACTIVATE);
    case WM_PAINT:
        return UIPaint(hUIWnd);
    default:
        return DefWindowProc(hUIWnd, uMsg, wParam, lParam);
    }
    return (0L);
}

void DrawConvexRect(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hPen, hOldPen;
    
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2);
    hPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));

    if ( hPen )
    {
        hOldPen = SelectObject (hDC, hPen);
        MoveToEx(hDC, x2-1, y2-1,NULL);
        LineTo(hDC, x2-1, y1);
        MoveToEx(hDC, x2-1, y2-1,NULL);
        LineTo(hDC, x1, y2-1);
        SelectObject(hDC, hOldPen);
        DeleteObject(hPen);          
    }
}

void DrawConvexRectP(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hPen, hOldPen;
    
    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH));
    SelectObject(hDC, GetStockObject(WHITE_PEN));
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x2 - 1, y1);
    MoveToEx(hDC, x1, y1,NULL);
    LineTo(hDC, x1, y2 - 1);
    hPen = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));

    if ( hPen )
    {
        hOldPen = SelectObject (hDC, hPen);
        MoveToEx(hDC, x2-1, y2-1,NULL);
        LineTo(hDC, x2-1, y1);
        MoveToEx(hDC, x2-1, y2-1,NULL);
        LineTo(hDC, x1, y2-1);
        SelectObject(hDC, hOldPen);
        DeleteObject(hPen);          
    }
}

void DrawConcaveRect(HDC hDC, int x1, int y1, int x2, int y2)
{
    HPEN hLtPen = CreatePen(PS_SOLID, 1, 0x00808080);

    if ( hLtPen != NULL )
    {
        HPEN OldPen = SelectObject(hDC, hLtPen);
        MoveToEx(hDC, x1, y1,NULL);
        LineTo(hDC, x2, y1);
        MoveToEx(hDC, x1, y1,NULL);
        LineTo(hDC, x1, y2);
        SelectObject(hDC, GetStockObject(WHITE_PEN));
        MoveToEx(hDC, x2  , y2,NULL);
        LineTo(hDC, x2  , y1-1);
        MoveToEx(hDC, x2  , y2,NULL);
        LineTo(hDC, x1-1, y2);
        SelectObject(hDC, OldPen);
        DeleteObject(hLtPen);     
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\dconvdlg.c ===
/*************************************************
 *  dconvdlg.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "prop.h"
#include "upimeres.h"
#include <regstr.h>

/*****************************************************************************

  FUNCTION: ConvDialogProc(HWND, UINT, WPARAM, LPARAM)

  PURPOSE:  Processes messages for "conv" property sheet.

  PARAMETERS:
    hdlg - window handle of the property sheet
    wMessage - type of message
    wparam - message-specific information
    lparam - message-specific information

  RETURN VALUE:
    TRUE - message handled
    FALSE - message not handled

  HISTORY:
    04-18-95 Yehfew Tie  Created.
 ****************************************************************************/

BOOL    CALLBACK ConvDialogProc(HWND hdlg, 
								UINT uMessage, 
								WPARAM wparam, 
								LPARAM lparam)
{
    LPNMHDR      lpnmhdr;
	static DWORD dwDesOffset,dwDesLen;
	static DWORD dwRuleOffset,dwRuleLen;
	static char  szMbName[MAX_PATH];
	static char  szSrcName[MAX_PATH];
	static char	 _szStr[MAX_PATH];
	static char  Ext[]=".mb";
    static BOOL  bModify;
	LPRULE       lpRule;
	int 		 i;
    static DESCRIPTION Descript;

    
    switch (uMessage)
    {
	    case WM_INITDIALOG:
		{	
	        LPENCODEAREA lpEncode;

			InstallConvSubClass(GetDlgItem(hdlg,IDC_LIST));
		    SendDlgItemMessage(hdlg,IDC_IMENAME,EM_LIMITTEXT,24,0L);
		    SendDlgItemMessage(hdlg,IDC_USEDCODE,EM_LIMITTEXT,MAXUSEDCODES-1,0L);
			SetConvDisable(hdlg);
			PropSheet_CancelToClose(GetParent(hdlg));
 			hRule = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
 				 sizeof(RULE)*MAXCODELEN);
            hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                 NUMENCODEAREA*sizeof(ENCODEAREA));
            if(!hRule || !hEncode) 
                 ProcessError(ERR_OUTOFMEMORY,hdlg,ERR);		
			
			lpEncode = (LPENCODEAREA) GlobalLock(hEncode);
			ConvInitEncode(lpEncode);
			GlobalUnlock(hEncode);
            break;
		}
        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;

            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                    break;
                case PSN_APPLY:
					if(bModify) {
                       LoadString(NULL, IDS_FILEMODIFY, _szStr, sizeof(_szStr));
                       wsprintf(szMbName,"뷨ҳ\n\'%s\'\n%s",szSrcName,_szStr); 
                       if(ErrMessage(hdlg,szMbName)) {
					        SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
					   }
					}
                    break;
                case PSN_RESET:
                    break;
                case PSN_QUERYCANCEL:
                    break;

                case PSN_HELP:

                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:

            switch (LOWORD(wparam))
            {
                case ID_FILEOPEN:   
					if(bModify) {
                        char errString[MAX_PATH];
                        LoadString(NULL, IDS_FILEMODIFY, _szStr, sizeof(_szStr));
                        wsprintf(errString,"\'%s\'%s",szSrcName,_szStr); 
                        if(ErrMessage(hdlg,errString)) 
					        SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
                    }
					
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
				    {	
#ifdef UNICODE					
					static TCHAR szTitle[] = {0x6253, 0x5F00, 0x0000};
#else
					TCHAR szTitle[MAX_PATH];
					strcpy(szTitle,"");
#endif

				    if(!TxtFileOpenDlg(hdlg,_szStr,szTitle)) 
				        break;
					}

					lstrcpy(szSrcName,_szStr);
                    bModify = FALSE;
                    _szStr[0] = 0;
 	                SetDlgItemText(hdlg,IDC_EDITBOX,_szStr);
 	                SendDlgItemMessage(hdlg,IDC_LIST,LB_RESETCONTENT,0,0L);
  				    {
					    LPSTR lpString;
  				        if((lpString = strrchr(szSrcName,'\\'))!=NULL)
					        SetDlgItemText(hdlg,IDC_SRCNAME, lpString+1);
					    lstrcpy(szMbName, szSrcName);
					    lstrcpy(_szStr, szSrcName);
					    if((lpString = strrchr(szMbName,'.'))!=NULL)
					        *lpString = 0;
					    lstrcat(szMbName,Ext);
					}
					
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
				    {
				        int nRetValue;
				        nRetValue = ConvGetDescript(hdlg, szSrcName, 
				            &dwDesOffset, &dwDesLen, &Descript, FALSE);
				        if(nRetValue ==(-ERR_FILENOTOPEN)) {
  					        szSrcName[0]=0;
   					        lstrcpy(szMbName, szSrcName);
 					        SetDlgItemText(hdlg,IDC_SRCNAME,szSrcName);
   					        SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
						    MessageBeep((UINT)-1);
				            break;     
 					    }
					}

                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
						break;
				    }
 				    
				    if(ConvGetRule(hdlg, szSrcName, &dwRuleOffset, &dwRuleLen, 
				       lpRule, &Descript)==(-ERR_FILENOTOPEN))
					{
						szSrcName[0]=0;
						lstrcpy(szMbName,szSrcName);
 					    SetDlgItemText(hdlg,IDC_SRCNAME,szSrcName);
 					    SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
						GlobalUnlock(hRule);
						MessageBeep((UINT)-1);
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
						break;
					}
                    SetDlgDescript(hdlg,&Descript);
					SetDlgRuleStr(hdlg,Descript.wNumRules,lpRule);
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);

					GlobalUnlock(hRule);
					SetConvEnable(hdlg);
                    
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
					SendMessage(GetDlgItem(hdlg,ID_FILEOPEN),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_CONV),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_CONV));
                    break;

                case IDC_MBNAME:
					GetDlgItemText(hdlg,IDC_MBNAME,szMbName,256);
					if(lstrlen(szMbName) == 0) {
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					    break;
					}
					else {
					    GetDlgItemText(hdlg,IDC_IMENAME,_szStr,32);
					    if(lstrlen(_szStr) != 0 && Descript.wMaxCodes != 0) 
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
						else
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					}
					
                    break;
                case IDC_IMENAME:
					GetDlgItemText(hdlg,IDC_IMENAME,_szStr,128);
					_szStr[128]=0;
					if(lstrlen(_szStr) == 0) {
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					    break;
					}
					else {
					    GetDlgItemText(hdlg,IDC_MBNAME,szMbName,256);
					    if(lstrlen(szMbName) != 0 && Descript.wMaxCodes != 0) 
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
						else
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					}
					    
					if(lstrcmpi(Descript.szName,_szStr)==0) 
					    break;
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                    break;

				case IDC_MAXCODES:
				{
					int nMaxCodes;

					nMaxCodes = GetDlgItemInt (hdlg,IDC_MAXCODES,NULL,FALSE);
                    if(nMaxCodes > MAXCODELEN) {
						 MessageBeep((UINT)-1);
						 SetDlgItemInt (hdlg,IDC_MAXCODES,MAXCODELEN,FALSE);
						 Descript.wMaxCodes = MAXCODELEN;
					}
                    if(Descript.wMaxCodes != nMaxCodes) {
                         bModify = TRUE;
                         EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
					}

					break;
				}
				case IDC_USEDCODE:
					
					GetDlgItemText(hdlg,IDC_USEDCODE,_szStr,sizeof(_szStr));
					
                    if(lstrlen(_szStr) == 0)
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					
					if(lstrcmpi(Descript.szUsedCode,_szStr)==0) 
					    break;
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                    break;

				case IDC_WILDCHAR:
					GetDlgItemText(hdlg,IDC_WILDCHAR,_szStr,sizeof(_szStr));
					if(lstrlen(_szStr)==0 ) {
					    if( Descript.cWildChar!=0) {
                             bModify = TRUE;
                             EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
						}
					    break;
					}
					if(lstrlen(_szStr)>1)  {
					    MessageBeep((UINT)-1);
						_szStr[0]=0;
						SetDlgItemText(hdlg,IDC_WILDCHAR,_szStr);
						break;
					}

					{
					    char WildChar;

					    WildChar=_szStr[0];
					    if(WildChar != Descript.cWildChar) { 
                            EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                            bModify = TRUE;
					    }
					    GetDlgItemText(hdlg,IDC_USEDCODE,_szStr,sizeof(_szStr));
					    if(strchr(_szStr,WildChar) != NULL) {
						    _szStr[0]=0;
						    SetDlgItemText(hdlg,IDC_WILDCHAR,_szStr);
				            MessageBeep((UINT)-1);
						    break;
					    }
					}
				    break;

				case IDC_SINGLEELEMENT:
				case IDC_MULTIELEMENT:
	                if(Descript.byMaxElement == (BYTE)(IsDlgButtonChecked(hdlg,IDC_MULTIELEMENT)?2:1))
                        break;
                    Descript.byMaxElement = 1 + Descript.byMaxElement%2; 
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
				    break;

				case IDC_ADD:
				{
	                FARPROC      lpProcInfo;

				    szRuleStr[0] = 0;
				    if(Descript.wNumRules >= MAXCODELEN) {
					    ProcessError(ERR_RULENUM,hdlg,WARNING);
						break;
					}

                    lpProcInfo = MakeProcInstance((FARPROC)AddRuleDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_ADDRULE),
                    		  hdlg,
                    		  (DLGPROC)AddRuleDlg);

                    FreeProcInstance(lpProcInfo);
                    bModify = TRUE;
				    break;
				}

				case IDC_MODIFY:
				{
	                FARPROC      lpProcInfo;
				    int          nSelect;

				    nSelect = SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCURSEL,0,0L);
					if(nSelect == LB_ERR) {
					    MessageBeep((UINT)-1);
						break;
					}
				    SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,nSelect,(LPARAM)szRuleStr);
                    lpProcInfo = MakeProcInstance((FARPROC)ModiRuleDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_EDITRULE),
                    		  hdlg,
                    		  (DLGPROC)ModiRuleDlg);

                    FreeProcInstance(lpProcInfo);
                    break;

				}
				case IDC_DEL:
				{
					int nSelect;

				    nSelect = SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCURSEL,0,0L);
					if(nSelect != LB_ERR) {
				        SendDlgItemMessage(hdlg,IDC_LIST,LB_DELETESTRING,nSelect,0L);
                        if(!(lpRule = GlobalLock(hRule)) )  {
                             ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
						     break;
						}

                        DelSelRule(Descript.wNumRules,(WORD)nSelect,lpRule);
						Descript.wNumRules--;
						GlobalUnlock(hRule);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);

					    SetFocus(GetDlgItem(hdlg,IDC_LIST));
					    SendDlgItemMessage(hdlg,IDC_LIST,LB_SETCURSEL,nSelect,0L);
   					    if((nSelect=SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCURSEL,0,0L))==LB_ERR) {
					        nSelect=SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
					        SendDlgItemMessage(hdlg,IDC_LIST,LB_SETCURSEL,nSelect-1,0L);
                        }
				    }
					else
					    MessageBeep((UINT)-1);
					    
				    break;
				}

				case IDC_ADDRULE:
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
				        szRuleStr[0] = 0;
						break;
				    }

                    if(RuleParse(hdlg,szRuleStr,0,lpRule,Descript.wMaxCodes)) {
						int nCnt;

	                    nCnt =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
                        if(nCnt != 0)  
	                    {    
	                        for(i=0; i<nCnt; i++) {
                                SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
						        if(_strnicoll(szRuleStr,_szStr,3) == 0)
						  	    {
					                 GlobalUnlock(hRule);
									 
      				                 ProcessError(ERR_DUPRULE,hdlg,ERR);
									 MessageBeep((UINT)-1);
									 MessageBeep((UINT)-1);
									 _szStr[0] = 0;
									 lstrcpy((LPSTR)lparam,_szStr);
									 return FALSE;
								}
							}
						}
						SendDlgItemMessage(hdlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)szRuleStr);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
					    Descript.wNumRules++;
					}
					else 
					{    
					    MessageBeep((UINT)-1);
						_szStr[0] = 0;
						lstrcpy((LPSTR)lparam,_szStr);
					}
					GlobalUnlock(hRule);
                    
				    break;

				case IDC_CHGDATA:
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
				        _szStr[0] = 0;
						lstrcpy((LPSTR)lparam,_szStr);
						break;
				    }

					{
				    int nSelect;

				    nSelect = SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCURSEL,0,0L);
                    if(RuleParse(hdlg,szRuleStr,nSelect,lpRule,Descript.wMaxCodes)) {
//					    Descript.wNumRules++;
						int nCnt;

	                    nCnt =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
                        if(nCnt != 0)  
	                    {    
	                        for(i=0; i<nCnt; i++) {
                                if(i == nSelect)
								     continue;
                                SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
						        if(_strnicoll(szRuleStr,_szStr,3) == 0)
						  	    {
					                 GlobalUnlock(hRule);
									 MessageBeep((UINT)-1);
				                     _szStr[0] = 0;
						             lstrcpy((LPSTR)lparam,_szStr);
									 return FALSE;
								}
							}
						}
						SendDlgItemMessage(hdlg,IDC_LIST,LB_DELETESTRING,nSelect,0L);
						SendDlgItemMessage(hdlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)szRuleStr);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
						
					}
					else 
				    {    
				        _szStr[0] = 0;
						lstrcpy((LPSTR)lparam,_szStr);
					    MessageBeep((UINT)-1);
					}
					GlobalUnlock(hRule);
                    
				    break;
				    }
				case IDC_GETMBFILE:
					GetDlgItemText(hdlg,IDC_MBNAME,_szStr,sizeof(_szStr));
					lstrcpy((LPSTR)lparam,_szStr);
					break;

				case IDC_GETSRCFILE:
					lstrcpy((LPSTR)lparam,szSrcName);
					break;

				case IDC_CONV:
				{
	                FARPROC      lpProcInfo;

                    if(bModify)
						 SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
                    lpProcInfo = MakeProcInstance((FARPROC)InfoDlg, hInst);
					pfnmsg=(PFNMSG)ConvProc;
					bEndProp=FALSE;
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_INFO),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
                    FreeProcInstance(lpProcInfo);
				    break;
				}
				case IDC_CRTIME:
				{ 
	                FARPROC      lpProcInfo;
                    int 		 nRetValue;
					GetDlgItemText(hdlg, IDC_MBNAME, _szStr, sizeof(_szStr));
                    nRetValue = ReadDescript(_szStr,&Descript,FILE_SHARE_READ);
                    if(nRetValue == -1){
                        char errString[MAX_PATH];
                        LoadString(NULL, IDS_FILEOPEN, errString, sizeof(errString));
						lstrcat(_szStr, errString);
                        FatalMessage(hdlg,_szStr);
						break;
					}
					else if(!nRetValue)
					{
					    ProcessError(ERR_READMAININDEX,hdlg,WARNING);
   						break;
				    }
                    lpProcInfo = MakeProcInstance((FARPROC)CrtImeDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_CRTIME),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
                    FreeProcInstance(lpProcInfo);
				    break;
				}
				
				case IDC_SAVE:
					GetDlgDescript(hdlg,&Descript);
					if(!CheckCodeCollection(hdlg,Descript.szUsedCode))
					    break;
					GetDlgRule(hdlg,lpRule,&(Descript.wNumRules),Descript.wMaxCodes);
				    if(!ConvSaveDescript(szSrcName,&Descript, dwDesOffset,dwDesLen))
				        break;
                    ConvGetDescript(hdlg,szSrcName,&dwDesOffset,&dwDesLen,&Descript,TRUE);
					
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
					    break;
					}
                    if(!ConvSaveRule(hdlg,szSrcName, dwDesLen,dwRuleLen, 
                       lpRule, Descript.wNumRules))
                        break;
 				    ConvGetRule(hdlg, szSrcName, &dwRuleOffset, &dwRuleLen, 
				        lpRule, &Descript);
					GlobalUnlock(hRule);
                    bModify = FALSE;
                    EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
					SendMessage(GetDlgItem(hdlg,IDC_SAVE),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_CONV),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_CONV));
					break;

				case IDC_HLP:
					break;
                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

VOID ConvProc(LPVOID hWnd)
{
	static char file1[MAX_PATH]="";
	static char file2[MAX_PATH]="";
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETSRCFILE,(LPARAM)file1);
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETMBFILE,(LPARAM)file2);
  	if(ConvConv(hDlgless,file1,file2))
	   bEndProp=TRUE;
	   //PropSheet_PressButton(GetParent(GetParent(hDlgless)),PSBTN_OK);
	SendMessage(hDlgless,WM_CLOSE,0,0L);
}

void SetDlgDescript(HWND hDlg,LPDESCRIPTION lpDescript)
{
	short nElement;
	char  _szStr[20];

	nElement =(lpDescript->byMaxElement==1)?IDC_SINGLEELEMENT:IDC_MULTIELEMENT;
	SetDlgItemText(hDlg,IDC_IMENAME,lpDescript->szName);
	SetDlgItemText(hDlg,IDC_USEDCODE,lpDescript->szUsedCode);
	_szStr[0]=lpDescript->cWildChar;
	_szStr[1]=0;
	SetDlgItemText(hDlg,IDC_WILDCHAR,_szStr);
	SetDlgItemInt (hDlg,IDC_MAXCODES,lpDescript->wMaxCodes,FALSE);
	CheckRadioButton(hDlg,IDC_SINGLEELEMENT,IDC_MULTIELEMENT,nElement);
}
   
void GetDlgDescript(HWND hDlg,LPDESCRIPTION lpDescript)
{

	BOOL bTrans;
	char _szStr[20];

	GetDlgItemText(hDlg,IDC_IMENAME,lpDescript->szName,NAMESIZE);
	GetDlgItemText(hDlg,IDC_USEDCODE,lpDescript->szUsedCode,MAXUSEDCODES);
	GetDlgItemText(hDlg,IDC_WILDCHAR,_szStr,sizeof(_szStr));
	DelSpace(_szStr);
	if(_szStr[0]==0) _szStr[0]='?';
	lpDescript->cWildChar=_szStr[0];
	lpDescript->wMaxCodes=(WORD)GetDlgItemInt (hDlg,IDC_MAXCODES,&bTrans,FALSE);
	lpDescript->wNumCodes=(WORD)lstrlen(lpDescript->szUsedCode);
	lpDescript->byMaxElement=(BYTE)(IsDlgButtonChecked(hDlg,IDC_MULTIELEMENT)?2:1);
	lpDescript->wNumRules=(WORD)SendDlgItemMessage(hDlg,IDC_LIST,LB_GETCOUNT,0,0L);
}


void SetDlgRuleStr(HWND hDlg,WORD NumRules,LPRULE lpRule)
{
    WORD  i;
	char _szStr[MAX_PATH];

	SendDlgItemMessage(hDlg,IDC_LIST,LB_RESETCONTENT,0,0L);
    if(NumRules==0)  return;
	for(i=0; i<NumRules; i++) {
        RuleToText(&lpRule[i], _szStr);
		_szStr[lstrlen(_szStr)-2]=0;
		SendDlgItemMessage(hDlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)_szStr);
	}
}

void GetDlgRule(HWND hdlg,LPRULE lpRule,LPWORD fwNumRules,WORD MaxCodes)
{
    int  i;
	char _szStr[128];
	WORD NumRules = 0;

	lpRule = GlobalLock(hRule);
	*fwNumRules =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
    if((*fwNumRules) == 0)  
    {
        GlobalUnlock(hRule);
        return;
	}
	for(i=0;i<(int)*fwNumRules;i++) {
        SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
        if(RuleParse(hdlg,_szStr,i,lpRule,MaxCodes))
		    NumRules++;
	}
    
    GlobalUnlock(hRule);
	*fwNumRules = NumRules;
}
			    
void DelSelRule(WORD wNumRules,WORD wSelect,LPRULE lpRule)
{
    int i;
	if(wSelect>=MAXCODELEN) return;
	for(i=wSelect;i<wNumRules;i++) 
	    lpRule[i]=lpRule[i+1];
}

void SetConvDisable(HWND hDlg)
{
	WORD wID;

	for(wID = IDC_MBNAME ;wID <= IDC_CONV ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),FALSE);
    
    EnableWindow(GetDlgItem(hDlg,IDC_CRTIME),FALSE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC5 ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),FALSE);
}

void SetConvEnable(HWND hDlg)
{
    WORD wID;

	for(wID = IDC_MBNAME ;wID <= IDC_CONV ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_CRTIME),TRUE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC5 ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),TRUE);

}

BOOL    CALLBACK  ConvEditProc(HWND   hWnd,
 				 			   UINT   wMsgID,
							   WPARAM wParam,
							   LPARAM lParam)
{
    switch(wMsgID) {
		case WM_LBUTTONDBLCLK:
			SendMessage(GetParent(hWnd),WM_COMMAND,IDC_MODIFY,0L);
		    break;

	    case WM_KEYDOWN:

		    switch(wParam) {
				case VK_DELETE:
				    SendMessage(GetParent(hWnd),WM_COMMAND,IDC_DEL,0L);
					break;
			}

		default:
		    return CallWindowProc(lpConvProc,hWnd,wMsgID,wParam,lParam);
	}
	return FALSE;
} 

void InstallConvSubClass(HWND hWnd)
{

	FARPROC lpNewProc;

    lpNewProc = MakeProcInstance(ConvEditProc,hInstance);
    lpConvProc = (FARPROC)GetWindowLongPtr(hWnd,GWL_WNDPROC);
    SetWindowLongPtr(hWnd,GWL_WNDPROC,(LONG_PTR)lpNewProc);
	FreeProcInstance(lpNewProc);
}

BOOL     CALLBACK AddRuleDlg(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
{
	LPRULE  lpRule;

    switch (message) {
        case WM_INITDIALOG:
			lpRule=GlobalLock(hRule);
			szRuleStr[0] = 0;
			SetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
				    GetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr,sizeof(szRuleStr));
					SendMessage(GetParent(hDlg),WM_COMMAND,IDC_ADDRULE,(LPARAM)szRuleStr);
					if(*szRuleStr == 0)
					{
					 	SetFocus(GetDlgItem(hDlg,IDC_EDITRULE));
					 	//SendMessage(GetParent(hDlg),WM_COMMAND,WM_SETFOCUS,IDC_
					    return (TRUE);
					}
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);

				case IDCANCEL:
				case WM_CLOSE:
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
					break;

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

BOOL  CALLBACK ModiRuleDlg(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
{
	LPRULE  lpRule;

    switch (message) {
        case WM_INITDIALOG:
			lpRule=GlobalLock(hRule);
			SetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
				    GetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr,sizeof(szRuleStr));
					SendMessage(GetParent(hDlg),WM_COMMAND,IDC_CHGDATA,(LPARAM)szRuleStr);
					if(*szRuleStr == 0)
					{ 
					 	SetFocus(GetDlgItem(hDlg,IDC_EDITRULE));
					    return (TRUE);
					}
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);

				case IDCANCEL:
				case WM_CLOSE:
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
					break;

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

//**********************************************************
//SetupIme(ImeFileName, ImeLayoutName);
//**********************************************************
/*
BOOL SetupIme(
LPTSTR ImeFileName,	 //ime file name with full path
LPTSTR MBFileName,
LPTSTR ImeLayoutName)//ime layout name(in chinese)
{
	HKEY  hKeyCurrVersion, hKey, hNewKey;
	long retCode,i;
	UCHAR Buf[256], lpszName[256],LayoutHandleName[10];
    DWORD   dwDisposition;

	memset(Buf,0,256);
	memset(lpszName,0,256);
	memset(LayoutHandleName, 0, 10);

	//create registry in keyboard layout
    retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_CURRENT_CONTROL_SET,
                            (DWORD)0,
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_EXECUTE |
                            KEY_QUERY_VALUE,
                            &hKeyCurrVersion);
     if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

    retCode = RegOpenKeyEx (hKeyCurrVersion,
                           "Keyboard Layouts",
                           0,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                           &hKey);
    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	for(i=0;;i++){
		retCode = RegEnumKey(hKey,	// handle of key to query 
    					 i,	// index of subkey to query 
    					 lpszName,	// address of buffer for subkey name  
    					 256); 	// size of subkey buffer 
		if(retCode)
			break;
		else{
			if(strcmp(Buf, lpszName)<0)
				strcpy(Buf, lpszName);
		}
	}
	if(Buf[0]=='\0')
		return FALSE;
	if(Buf[3]=='f' || Buf[3]=='F'){
		Buf[3]== '0';
		Buf[2]++;
	}else if(Buf[3]=='9')
		Buf[3]='A';
	else
		Buf[3]++;
	strcpy(LayoutHandleName,Buf);

    retCode = RegCreateKeyEx (hKey,
                           	  LayoutHandleName,
                              0,
							  0,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
                              &hNewKey,
                              &dwDisposition);

    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	GetFileTitle(ImeFileName, Buf, MAX_PATH);
    retCode = RegSetValueEx (hNewKey,
    			   "IME file", 
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	strcpy(Buf, "kbdus.kbd");
    retCode = RegSetValueEx (hNewKey,
    			   "layout file", 
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	strcpy(Buf, ImeLayoutName);
    retCode = RegSetValueEx (hNewKey,
    			   "layout text", 
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	RegCloseKey(hNewKey);
	RegCloseKey(hKey);
	RegCloseKey(hKeyCurrVersion);


	//create registry in preload
    retCode = RegOpenKeyEx (HKEY_CURRENT_USER,
                            "Keyboard Layout\\Preload",
                            0,
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_EXECUTE |
                            KEY_QUERY_VALUE,
                            &hKeyCurrVersion);
     if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	memset(Buf,0,256);
	memset(lpszName,0,256);
	for(i=0;;i++){
		retCode = RegEnumKey(hKeyCurrVersion,	// handle of key to query 
    					 i,	// index of subkey to query 
    					 lpszName,	// address of buffer for subkey name  
    					 256); 	// size of subkey buffer 
		if(retCode)
			break;
		else{
			if(strcmp(Buf, lpszName)<0)
				strcpy(Buf, lpszName);
		}
	}
	if(Buf[0]=='\0')
		return FALSE;
	i=atoi(Buf);
	i++;
	_itoa(i,Buf,10);

    retCode = RegCreateKeyEx (hKeyCurrVersion,
                           	  Buf,
                              0,
							  0,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
                              &hNewKey,
                              &dwDisposition);

    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

    retCode = RegSetValueEx (hNewKey,
    			   NULL, 
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)LayoutHandleName,
		           strlen(LayoutHandleName));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	RegCloseKey(hNewKey);
	RegCloseKey(hKey);
	RegCloseKey(hKeyCurrVersion);

	//copy files
	{
	UCHAR	DesFilePath[MAX_PATH];

	GetSystemDirectory(DesFilePath,MAX_PATH);
	strcat(DesFilePath,"\\");

	GetFileTitle(ImeFileName, Buf, MAX_PATH);
	strcat(DesFilePath,Buf);
	CopyFile(ImeFileName, DesFilePath, FALSE);

	GetSystemDirectory(DesFilePath,MAX_PATH);
	strcat(DesFilePath,"\\");

	GetFileTitle(MBFileName, Buf, MAX_PATH);
	strcat(DesFilePath,Buf);
	CopyFile(MBFileName, DesFilePath, FALSE);

	}
	return TRUE;
}
*/

BOOL  CALLBACK CrtImeDlg(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        WPARAM  lParam)
{
    static char  _szStr[MAX_PATH];
    static char  ImeTplName[MAX_PATH];
    static char  mbName[MAX_PATH];
	static char  Version[]= "뷨 汾";
	static IMERES ImeRes;
	LPTSTR       lpString;

    switch (message) {
        case WM_INITDIALOG:
			SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETMBFILE,(LPARAM)mbName);
		    SendDlgItemMessage(hDlg,IDC_VERSION,EM_LIMITTEXT,8,0L);
		    SendDlgItemMessage(hDlg,IDC_GROUP,EM_LIMITTEXT,32,0L);
			ImeRes.Value = 0x00af;
			SetValue(hDlg,ImeRes.Value);
			SendMessage(hDlg,WM_COMMAND, IDC_DEF, 0L);
			CheckRadioButton(hDlg,IDC_DEF,IDC_USERDEF,IDC_DEF);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
					{
					DESCRIPTION Descript;

					if(!GetImeRes(hDlg,&ImeRes))
					    return TRUE;
                    ReadDescript(mbName,&Descript,FILE_SHARE_READ);
					lstrcpy(_szStr, Descript.szName);
					lstrcat(_szStr, Version);
					lstrcat(_szStr, ImeRes.Version);
					lstrcpy(ImeRes.Version, _szStr);
					GetSystemDirectory(ImeTplName,sizeof(ImeTplName));
					lstrcat(ImeTplName, TplName);
					lstrcpy(_szStr,mbName);
					if((lpString=strrchr(_szStr,'.'))!=NULL)
					    *lpString=0;
					lstrcat(_szStr,ImeExt);

					DispInfo(GetWindow(hDlg, GW_OWNER),IDS_UPRES);

					CopyFile(ImeTplName, _szStr, FALSE);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
					}
				
				case IDC_BROWSE:
				    if(!RcFileOpenDlg(hDlg, _szStr,Title))
				        break;
					if(strstr(_strupr(_szStr),BmpExt) != NULL)
					    SetDlgItemText(hDlg, IDC_BMP, _szStr);
					else if(strstr(_strupr(_szStr),IconExt) != NULL)
					    SetDlgItemText(hDlg, IDC_ICO, _szStr);
					else if(strstr(_strupr(_szStr),HlpExt) != NULL)
					    SetDlgItemText(hDlg, IDC_HLPFILE, _szStr);
					break;
				case IDC_DEF:
				    EnableWindow(GetDlgItem(hDlg,IDC_BMP), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_ICO), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_HLPFILE), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE), FALSE);
					GetDlgItemText(hDlg, IDC_ICO, ImeRes.IcoName,sizeof(ImeRes.IcoName));
					GetDlgItemText(hDlg, IDC_BMP, ImeRes.BmpName,sizeof(ImeRes.BmpName));
					GetDlgItemText(hDlg, IDC_BMP, ImeRes.HlpFile,sizeof(ImeRes.HlpFile));
					_szStr[0] = 0;
					SetDlgItemText(hDlg, IDC_ICO, _szStr);
					SetDlgItemText(hDlg, IDC_BMP, _szStr);
					SetDlgItemText(hDlg, IDC_HLPFILE, _szStr);
					break;


				case IDC_USERDEF:
				    EnableWindow(GetDlgItem(hDlg,IDC_BMP), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_ICO), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_HLPFILE), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE), TRUE);
					SetDlgItemText(hDlg, IDC_ICO, ImeRes.IcoName);
					SetDlgItemText(hDlg, IDC_BMP, ImeRes.BmpName);
					SetDlgItemText(hDlg, IDC_HLPFILE, ImeRes.HlpFile);
					break;
				    
				case IDC_ZJTS:
					if(IsDlgButtonChecked(hDlg,IDC_ZJTS)) 
						EnableWindow(GetDlgItem(hDlg,IDC_WMTS),TRUE);
					else {
					    CheckDlgButton(hDlg,IDC_WMTS,0);
						EnableWindow(GetDlgItem(hDlg,IDC_WMTS),FALSE);
					}
				    break;

				case IDCANCEL:
				case WM_CLOSE:
                    EndDialog(hDlg, TRUE);
					return (TRUE);

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

void SetValue(HWND hDlg, WORD Value)
{
	
	CheckDlgButton(hDlg,IDC_CYLX,Value&0x0001);
	CheckDlgButton(hDlg,IDC_CYSR,Value&0x0002);
	CheckDlgButton(hDlg,IDC_ZJTS,Value&0x0004);
	if(Value&0x0004==0) {
	    EnableWindow(GetDlgItem(hDlg,IDC_WMTS),FALSE);
		Value &= ~ 0x0008;
	}
	CheckDlgButton(hDlg,IDC_WMTS,Value&0x0008);
	CheckDlgButton(hDlg,IDC_GBGS,Value&0x0020);
	CheckDlgButton(hDlg,IDC_SPACE,Value&0x0040);
	CheckDlgButton(hDlg,IDC_ENTER,Value&0x0080);
}

void GetValue(HWND hDlg,LPWORD Value)
{
	*Value = 0;
	*Value |= IsDlgButtonChecked(hDlg,IDC_CYLX);
	*Value |= IsDlgButtonChecked(hDlg,IDC_CYSR) << 1;
	*Value |= IsDlgButtonChecked(hDlg,IDC_ZJTS) << 2;
	*Value |= IsDlgButtonChecked(hDlg,IDC_WMTS) << 3;
	*Value |= IsDlgButtonChecked(hDlg,IDC_GBGS) << 5;
	*Value |= IsDlgButtonChecked(hDlg,IDC_SPACE) << 6;
	*Value |= IsDlgButtonChecked(hDlg,IDC_ENTER) << 7;
}

int  GetImeRes(HWND hDlg,LPIMERES lpImeRes)
{
	GetDlgItemText(hDlg, IDC_VERSION, lpImeRes->Version, sizeof(lpImeRes->Version));
	DelSpace(lpImeRes->Version);
	if(lstrlen(lpImeRes->Version) == 0)
	{
	    ProcessError(ERR_VERSION, hDlg, WARNING);
	    return FALSE;
	}
	GetDlgItemText(hDlg, IDC_GROUP,   lpImeRes->Depart, sizeof(lpImeRes->Depart));
	DelSpace(lpImeRes->Depart);
	if(lstrlen(lpImeRes->Depart) == 0)
	{
	    ProcessError(ERR_GROUP, hDlg, WARNING);
	    return FALSE;
	}
	GetDlgItemText(hDlg, IDC_BMP,     lpImeRes->BmpName, sizeof(lpImeRes->BmpName));
	GetDlgItemText(hDlg, IDC_ICO,     lpImeRes->IcoName, sizeof(lpImeRes->IcoName));
	GetValue(hDlg, &(lpImeRes->Value));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\convcomm.c ===
/*************************************************
 *  convcomm.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "conv.h"

int  CheckDescription(HANDLE hWnd, LPDESCRIPTION lpDescript)
//*** check description illegal ****
{
    TCHAR  szStr[256];

    if(lstrlen(lpDescript->szName) == 0) {
	    LoadString(NULL,IDS_IMENAMEENTRY,szStr, sizeof(szStr)/sizeof(TCHAR));
	    InfoMessage(hWnd,szStr);
		lpDescript->szName[24] = 0;
		return FALSE;
    }

    if(lpDescript->wMaxCodes == 0) {
		LoadString(NULL,IDS_MAXCODESENTRY,szStr, sizeof(szStr)/sizeof(TCHAR));
		WarnMessage(hWnd,szStr);
		return FALSE;
    }
  
    if(lpDescript->byMaxElement == 0) {
		lpDescript->byMaxElement = 1;
		LoadString(NULL,IDS_ELEMENTENTRY,szStr, sizeof(szStr)/sizeof(TCHAR));
		WarnMessage(hWnd,szStr);
		return FALSE;
    }

    if( !CheckCodeCollection(hWnd,lpDescript->szUsedCode) )
        return FALSE;

    lpDescript->wNumCodes = (WORD) lstrlen(lpDescript->szUsedCode);
	
    if(lpDescript->cWildChar == 0)
	    lpDescript->cWildChar = '?';
    if(_tcschr(lpDescript->szUsedCode,lpDescript->cWildChar) != NULL) {
        ProcessError(ERR_WILDCHAR,hWnd,ERR);
		return FALSE;
    }

    if(lpDescript->wNumRules >= 12) {
		lpDescript->wNumRules=0;
		LoadString(NULL,IDS_NUMRULESENTRY,szStr, sizeof(szStr)/sizeof(TCHAR));
		WarnMessage(szStr,hWnd);
		return FALSE;
    }

    return TRUE; 

}

int  GetDescriptEntry(LPTSTR  szSrcStr, LPDESCRIPTION lpDescript)
//*** get one description entry from source string ****
{
  TCHAR szStr[256];
  int   retValue;

  
  SetCursor (LoadCursor (NULL, IDC_WAIT));
  if( GetEntryString(szSrcStr,
             TEXT("Name"),
			 lpDescript->szName,
             lpDescript->szName,
             NAMESIZE-1)
       )
	   return TRUE;

  if( GetEntryInt(szSrcStr,
                  TEXT("MaxCodes"),
			      (int)lpDescript->wMaxCodes,
			      &retValue)
       ) 
  {	   
	   lpDescript->wMaxCodes = (WORD)retValue;
	   return TRUE;
  }

  if( GetEntryInt(szSrcStr,
             TEXT("MaxElement"),
			 (int)lpDescript->byMaxElement,
			 & retValue)
       )
  {	   
	   lpDescript->byMaxElement = (BYTE) retValue;
	   return TRUE;
  }

  retValue = GetEntryString(szSrcStr,
             TEXT("UsedCodes"),
			 lpDescript->szUsedCode,
             szStr,
             MAXUSEDCODES
            );
  if(retValue)
  {    
      DelSpace(szStr);
      lstrncpy(lpDescript->szUsedCode,MAXUSEDCODES,szStr);
	  return TRUE;
  }

  szStr[0] = lpDescript->cWildChar;
  szStr[1] = 0;

  retValue = GetEntryString(szSrcStr,
             TEXT("WildChar"),
			 szStr,
             szStr,
             sizeof(szStr)/sizeof(TCHAR));
  
  if(retValue)
  {    
      DelSpace(szStr);
      lpDescript->cWildChar = szStr[0];
	  return TRUE;
  }

  if(GetEntryInt(szSrcStr,
             TEXT("NumRules"),
			 (int)lpDescript->wNumRules,
			 &retValue )
	  )
      lpDescript->wNumRules = (WORD)retValue;
  return TRUE; 

}


int ConvGetDescript(HANDLE hWnd,
             LPCTSTR  FileName,
             LPDWORD fdwOffset,
             LPDWORD fdwLen,
             LPDESCRIPTION lpDescript,
             BOOL    bOnlyGetLength)
{
   TCHAR  szStr[1024];		 
   TCHAR  *Buffer;
   BOOL   bDescript = FALSE,bText = FALSE,bRule = FALSE;
   BOOL   bGetDes = FALSE;
   register int i,j;
   DWORD  dwFstOffset=0 , dwOffset;
   DWORD  dwReadBytes;
   HANDLE hFile;
   HLOCAL hBuffer;
   int    errno;
   
   if(!bOnlyGetLength)
   {
       memset(lpDescript->szName,0,sizeof(lpDescript->szName));
       lpDescript->wMaxCodes=0;
       lpDescript->byMaxElement=1;
       memset(lpDescript->szUsedCode,0,sizeof(lpDescript->szUsedCode));
       lpDescript->wNumRules=0;
       lpDescript->wNumCodes=0;
       lpDescript->cWildChar=0;
   }

   hFile = Create_File(hWnd,FileName,GENERIC_READ,OPEN_EXISTING);
   if (hFile == (HANDLE)-1)
		return (-ERR_FILENOTOPEN); 
   hBuffer = LocalAlloc(LMEM_ZEROINIT|LMEM_MOVEABLE, MAXREADBUFFER);
   Buffer = (TCHAR *) LocalLock(hBuffer);
   SetCursor (LoadCursor (NULL, IDC_WAIT));
   *fdwOffset = 0;
   SetFilePointer(hFile,0,0,FILE_BEGIN);
   while(ReadFile(hFile,Buffer,MAXREADBUFFER,&dwReadBytes,NULL))
   {	
	 dwReadBytes = dwReadBytes/sizeof(TCHAR);
     lstrcpy(szStr,TEXT(""));
	 j=0;
     for(i=0;i<(int)dwReadBytes;i++) {
      	if(Buffer[i] == 0x0d || Buffer[i] == 0xfeff) 
      	   continue;
      	else if(Buffer[i] == TEXT('\n')) {
    	   szStr[j]=0;
	       j=0;
           if(lstrlen(szStr) < 6) continue;
           if(lstrcmpi(szStr,TEXT(DescriptSeg))==0)  {
#ifdef UNICODE
               *fdwOffset= dwOffset - 2;	//the size of 0xfeff flag
#else
               *fdwOffset= dwOffset;
#endif
               bDescript = TRUE;
			   bGetDes = TRUE;
               lstrcpy(szStr,TEXT(""));
               continue;
       	   }
     
	       if( lstrcmpi(szStr,TEXT(TextSeg))==0) 
		   {    
		       bText =TRUE;
			   bGetDes = FALSE;
           }
           if( lstrcmpi(szStr,TEXT(RuleSeg))==0) 
		   {
		       bRule = TRUE;
			   bGetDes = FALSE;
           }
	       if( (bText||bRule)&& bDescript && !bGetDes) {
               *fdwLen = dwOffset - (*fdwOffset);
               if(!bOnlyGetLength)
                   errno = CheckDescription(hWnd, lpDescript);
			   LocalUnlock(hBuffer);
			   LocalFree(hBuffer);
			   CloseHandle(hFile);
               SetCursor (LoadCursor (NULL, IDC_ARROW));
               return errno;
		   }
           if(bGetDes && !bOnlyGetLength)
           {    
               GetDescriptEntry(szStr,lpDescript);
    	   }
           lstrcpy(szStr,TEXT(""));
           continue;
		}
		else {
		    if(j == 0)
			    dwOffset = dwFstOffset + i*sizeof(TCHAR);
			if(j<1024){
			    szStr[j]=Buffer[i];
			    j++; 
			}
		}
	 } 
	 if(dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) break;
     dwFstOffset += MAXREADBUFFER;
   };
   
   *fdwLen = dwFstOffset+dwReadBytes-(*fdwOffset);
   if(!bDescript) *fdwLen = 0;
   LocalUnlock(hBuffer);
   LocalFree(hBuffer);
   CloseHandle(hFile);
   errno = 0;

   if(!bText) {
       ProcessError(ERR_TEXTSEG,hWnd,ERR);
	   errno |= 4;
   }
   
   if(!bDescript) {
       if(bText)
           ProcessError(ERR_DESCRIPTSEG,hWnd,ERR);
	   errno |= 1;
   }
   if(!bRule){
       if(bText && bDescript)
           ProcessError(ERR_RULESEG,hWnd,WARNING);
	   errno |= 2;
   }
   SetCursor (LoadCursor (NULL, IDC_ARROW));
   if(bDescript && bRule && bText)
       return TRUE;
   else 
       return (-errno);
}


BOOL ConvSaveDescript(LPCTSTR SrcFileName,
                      LPDESCRIPTION lpDescript,
                      DWORD dwOffset,
                      DWORD dwLength)
//*** save MB description to source text file ****
{
  TCHAR szStr[256],szTemp[80],Buffer[4096];
  DWORD dwBytes,dwNewLen;
  HANDLE hSrcFile;
  BOOL  bText=TRUE;
  WORD  wFlag;

  hSrcFile = Create_File(GetFocus(),SrcFileName,GENERIC_READ|GENERIC_WRITE,OPEN_EXISTING);
  if (hSrcFile == (HANDLE)-1) 
       return FALSE;

#ifdef UNICODE
  Buffer[0] = 0xfeff;
  lstrcpy(&Buffer[1],TEXT("[Description]\r\n"));
#else
  lstrcpy(Buffer,TEXT("[Description]\r\n"));
#endif

  SetFilePointer(hSrcFile,dwOffset+dwLength,0,FILE_BEGIN);
  ReadFile(hSrcFile,szTemp,sizeof(szTemp), &dwBytes,NULL);
  if(dwBytes == 0 || szTemp[0] != TEXT('['))
        bText = FALSE;
  if(SetFilePointer(hSrcFile,dwOffset,0,FILE_BEGIN) != dwOffset) {
       CloseHandle(hSrcFile);
       return FALSE;
  }
  if(!CheckCodeCollection(GetFocus(),lpDescript->szUsedCode))
  {
       CloseHandle(hSrcFile);
       return FALSE;
  }

  SetCursor (LoadCursor (NULL, IDC_WAIT));
//write code list name to buffer ****
  wsprintf(szStr,TEXT("Name=%s\r\n"),lpDescript->szName);
  lstrcat(Buffer,szStr);

//write maximum length of codes to buffer***
  wsprintf(szStr,TEXT("MaxCodes=%d\r\n"),(int)lpDescript->wMaxCodes);
  lstrcat(Buffer,szStr);

//write maximum element to Buffer ***
  wsprintf(szStr,TEXT("MaxElement=%d\r\n"),(int)lpDescript->byMaxElement);
  lstrcat(Buffer,szStr);

//write used codes collection ***
  lstrncpy(szTemp,MAXUSEDCODES,lpDescript->szUsedCode);
  szTemp[MAXUSEDCODES]=0;
  wsprintf(szStr,TEXT("UsedCodes=%s\r\n"),lpDescript->szUsedCode);
  lstrcat(Buffer,szStr);

//write wild char ***
  if(lpDescript->cWildChar == 0)
      lpDescript->cWildChar = TEXT('?');     //**** add by yehfeh 95.10.11
  wsprintf(szStr,TEXT("WildChar=%c\r\n"),lpDescript->cWildChar);
  lstrcat(Buffer,szStr);
  
//write number of rules ***
  wsprintf(szStr,TEXT("NumRules=%d\r\n"),(int)lpDescript->wNumRules);
  lstrcat(Buffer,szStr);

  if(!bText) 
     lstrcat(Buffer,TEXT("[Text]\r\n"));
  
  dwNewLen = lstrlen(Buffer)*sizeof(TCHAR);
  if(dwNewLen > dwLength) 
     MoveFileBlock(hSrcFile,dwOffset+dwLength,dwNewLen-dwLength,1);
  else 
     MoveFileBlock(hSrcFile,dwOffset+dwLength,dwLength-dwNewLen,0);

  SetFilePointer(hSrcFile,dwOffset,0,FILE_BEGIN);
  WriteFile(hSrcFile,Buffer,dwNewLen,&dwBytes,NULL);
  CloseHandle(hSrcFile);
  SetCursor (LoadCursor (NULL, IDC_ARROW));
  return TRUE;
}


int ConvGetRule(HANDLE hWnd,LPCTSTR lpSrcFile,LPDWORD fdwOffset,
                  LPDWORD fdwRuleLen,LPRULE lpRule, LPDESCRIPTION lpDescript)
//*** read create word rule from source text file****
{
   TCHAR szStr[256],Buffer[MAXREADBUFFER];
   BOOL  bRule=FALSE;
   register int i,j;
   DWORD dwReadBytes;
   DWORD dwNumRules = 0;
   DWORD dwFstOffset = 0, dwOffset;
   HANDLE hSrcFile;
  
   
   *fdwOffset = 0;
   hSrcFile = Create_File(hWnd,lpSrcFile,GENERIC_READ,OPEN_EXISTING);
   if (hSrcFile == (HANDLE)-1)
		return (-ERR_FILENOTOPEN);
   SetCursor (LoadCursor (NULL, IDC_WAIT));
   SetFilePointer(hSrcFile,0,0,FILE_BEGIN);
   while(ReadFile(hSrcFile,Buffer,MAXREADBUFFER,&dwReadBytes,NULL))
   {	
	 dwReadBytes = dwReadBytes/sizeof(TCHAR);
     lstrcpy(szStr,TEXT(""));
	 j=0;
     for(i=0;i<(int)dwReadBytes;i++) {
      	if(Buffer[i] == 0x0d || Buffer[i] == 0xfeff) 
      	   continue;
      	else if(Buffer[i] == TEXT('\n')) {
    	   szStr[j]=0;
	       j=0;
           if(lstrlen(szStr) < 4) continue;
    	   if(lstrcmpi(szStr,TEXT(RuleSeg))==0)  {
               *fdwOffset= dwOffset;
			   bRule = TRUE;
 			   lstrcpy(szStr,TEXT(""));
    	       continue;
       	   }
     
	       if( (lstrcmpi(szStr,TEXT(TextSeg))==0
	           ||lstrcmpi(szStr,TEXT(DescriptSeg))==0)
	           && bRule) {
                 *fdwRuleLen = dwOffset - (*fdwOffset);
				 CloseHandle(hSrcFile);
                 SetCursor (LoadCursor (NULL, IDC_ARROW));
			     if(dwNumRules != lpDescript->wNumRules) {
			        ProcessError(ERR_RULENUM,hWnd,ERR);
					lpDescript->wNumRules =(WORD) dwNumRules;
			        return (-ERR_RULENUM);
			     }
		         return TRUE;
		   }
	       if(bRule) {
		      if(RuleParse(hWnd,szStr,dwNumRules,lpRule,lpDescript->wMaxCodes)) 
			        dwNumRules ++;
			  else  {
					CloseHandle(hSrcFile);
                    SetCursor (LoadCursor (NULL, IDC_ARROW));
			        return (-ERR_RULENUM);
			  }
    		  lstrcpy(szStr,TEXT(""));
			  if(dwNumRules > lpDescript->wNumRules) {
			        ProcessError(ERR_RULENUM,hWnd,ERR);
					CloseHandle(hSrcFile);
                    SetCursor (LoadCursor (NULL, IDC_ARROW));
			        return(-ERR_RULENUM);
			  }
	    	  continue;
		   }
		   else {
		     lstrcpy(szStr,TEXT(""));    
             continue;
		   }
		}
		else {
		    if(j == 0)
			    dwOffset = dwFstOffset + i*sizeof(TCHAR);
		    szStr[j]=Buffer[i];
		    j++; 
		}
	 } /*** for (i=0;...) ****/
	 if(dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) break;
     dwFstOffset += MAXREADBUFFER;
   };
   
   *fdwRuleLen = dwFstOffset+dwReadBytes-(*fdwOffset);

   if(!bRule) 
       *fdwRuleLen=0;
   CloseHandle(hSrcFile);
  
   SetCursor (LoadCursor (NULL, IDC_ARROW));
   if(bRule||lpDescript->wNumRules==0)
       return TRUE;
   else {
       ProcessError(ERR_RULESEG,hWnd,ERR);
	   lpDescript->wNumRules=0;
       return (-ERR_RULESEG);
   }
}


BOOL ConvSaveRule(HANDLE hWnd,LPCTSTR SrcFileName,DWORD dwOffset, DWORD dwLength,
                   LPRULE lpRule, DWORD dwNumRules)
//*** save create word rule to source text file****
{
  TCHAR szStr[256],Buffer[4096];
  DWORD dwBytes,dwNewLen;
  DWORD i;
  HANDLE hFile;

  hFile = Create_File(hWnd,SrcFileName,GENERIC_READ|GENERIC_WRITE,OPEN_EXISTING);
  if (hFile == (HANDLE)-1) 
       return FALSE;
  SetCursor (LoadCursor (NULL, IDC_WAIT));
  lstrcpy(Buffer,TEXT("[Rule]\r\n"));
  for(i=0; i<dwNumRules; i++) {
       RuleToText(&lpRule[i], szStr);
       lstrcat(Buffer,szStr);
  }

  dwNewLen = lstrlen(Buffer)*sizeof(TCHAR);
  if(dwNewLen > dwLength) 
      MoveFileBlock(hFile,dwOffset+dwLength,dwNewLen-dwLength,1);
  else 
      MoveFileBlock(hFile,dwOffset+dwLength,dwLength-dwNewLen,0);
  SetFilePointer(hFile,dwOffset,0,FILE_BEGIN);
  WriteFile(hFile,Buffer,dwNewLen,&dwBytes,NULL);

  CloseHandle(hFile);
  SetCursor (LoadCursor (NULL, IDC_ARROW));
  return TRUE;
}

LPTSTR ConvCreateWord(HWND hWnd,LPCTSTR MBFileName,LPTSTR szWordStr)
{
   int         nWordLen = lstrlen(szWordStr)*sizeof(TCHAR)/2;
   DWORD       i,j,k,dwCodeLen;
   TCHAR       szDBCS[3],szCode[MAXCODELEN+1];
   static      TCHAR lpCode[128];
   BOOL        bReturn=FALSE;
   HANDLE      hMBFile;
   DESCRIPTION Descript;
   HANDLE      hRule0;
   LPRULE      lpRule;
   MAININDEX   MainIndex[NUMTABLES];

   for(i=0; i< 128; i++)
        lpCode[0] = 0;
   
   if(lstrlen(MBFileName)==0 || lstrlen(szWordStr) == 0)
		return (LPTSTR)lpCode;
   hMBFile = Create_File(hWnd,MBFileName,GENERIC_READ,OPEN_EXISTING);
   if(hMBFile == (HANDLE)-1)
        return (LPTSTR)lpCode;
   if(!ConvGetMainIndex(hWnd,hMBFile,MainIndex)) {
		CloseHandle(hMBFile);
		return (LPTSTR)lpCode;
   }

   ConvReadDescript(hMBFile,&Descript, MainIndex);

   if(Descript.wNumRules == 0) {
		MessageBeep((UINT)-1);
		MessageBeep((UINT)-1);
		CloseHandle(hMBFile);
        return (LPTSTR)lpCode;
   }
   hRule0 = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(RULE)*Descript.wNumRules);
   if(!hRule0) {
        ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
		CloseHandle(hMBFile);
	    return (LPTSTR)lpCode;
   }

   if(!(lpRule = GlobalLock(hRule0)) )  {
        ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
		CloseHandle(hMBFile);
		GlobalFree(hRule0);
	    return (LPTSTR)lpCode;
   }

   ConvReadRule(hMBFile,Descript.wNumRules ,lpRule, MainIndex);

   for(i=0; i<Descript.wNumRules; i++) 
	 if( (lpRule[i].byLogicOpra == 0 && nWordLen == lpRule[i].byLength) 
	   ||(lpRule[i].byLogicOpra == 1 && nWordLen >= lpRule[i].byLength)
	   ||(lpRule[i].byLogicOpra == 2 && nWordLen <= lpRule[i].byLength) ) {

  	   int retCodeLen = 0;  
  	   for(j=0; j<lpRule[i].wNumCodeUnits; j++) {
		   k = lpRule[i].CodeUnit[j].wDBCSPosition;
		   if(k > (DWORD)nWordLen) k = (DWORD)nWordLen;   
           if(lpRule[i].CodeUnit[j].dwDirectMode == 0) 
	           lstrncpy(szDBCS,2,&szWordStr[2*(k-1)]);
		   else 
	           lstrncpy(szDBCS,2,&szWordStr[2*(nWordLen-k)]);
	 	   szDBCS[2] = 0;
		   k = EncodeToNo(szDBCS);
		   if((long)k >= 0 && k < NUM_OF_ENCODE ) 
           {
               SetFilePointer(hMBFile,MainIndex[TAG_CRTWORDCODE-1].dwOffset+Descript.wMaxCodes*k*sizeof(TCHAR),
                   0,FILE_BEGIN);
               ReadFile(hMBFile,szCode,Descript.wMaxCodes,&k,NULL);
		       szCode[Descript.wMaxCodes] = 0;
		       dwCodeLen = lstrlen(szCode);
		       k = lpRule[i].CodeUnit[j].wCodePosition;
 		       if(k == 0) 
			   {
			       if(retCodeLen + dwCodeLen > Descript.wMaxCodes)
			     	    szCode[Descript.wMaxCodes - retCodeLen] = 0;
			       lstrcat(lpCode,szCode);
			   }
 		       else
 		       {
 		           if(k > dwCodeLen) k = dwCodeLen;   
 		           lpCode[j] = (szCode[k-1] == 0)?((k > 1)? szCode[k-2]:Descript.szUsedCode[0]):szCode[k-1];
			   }
		   }
		   else 
		       lpCode[j] = (j > 0)?lpCode[j-1]:Descript.szUsedCode[0];
		   retCodeLen = lstrlen(lpCode);
	   }
	   bReturn = TRUE;
	   break;
	}

	if(!bReturn) 
	    ProcessError(ERR_NOTDEFRULE,GetFocus(),ERR);
	lpCode[Descript.wMaxCodes] = 0;
	CloseHandle(hMBFile);
	GlobalFree(hRule0);
	return (LPTSTR)lpCode;
}


INT  ReadDescript(LPCTSTR MBFileName, LPDESCRIPTION lpDescript,DWORD ShareMode)
//*** read description from .MB file ****
{
  HANDLE    hMBFile;
  DWORD     dwBytes,i;
  DWORD     dwOffset;
  MAININDEX lpMainIndex[NUMTABLES];

  hMBFile = Create_File(GetFocus(),MBFileName,GENERIC_READ,OPEN_EXISTING);
  if(hMBFile==INVALID_HANDLE_VALUE)
	  return -1;
  SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN);
  ReadFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);
  for(i=0; i<NUMTABLES; i++) {
      dwBytes = lpMainIndex[i].dwTag+
               lpMainIndex[i].dwOffset+
               lpMainIndex[i].dwLength;
      if(lpMainIndex[i].dwCheckSum != dwBytes) {
	 	  CloseHandle(hMBFile);
		  return FALSE;
	  }
  }

  dwOffset = lpMainIndex[TAG_DESCRIPTION-1].dwOffset;
  SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN);
  ReadFile(hMBFile,lpDescript,sizeof(DESCRIPTION),&dwBytes,NULL);
  CloseHandle(hMBFile);
  if(dwBytes < sizeof(DESCRIPTION) )
      return FALSE;
  else
      return TRUE;
}

BOOL ReadRule(HWND hWnd,
              LPCTSTR MBFileName, 
              int  nRuleNum,
              LPRULE lpRule)
//*** read create word rule from .MB file ****
{
  HANDLE    hMBFile;
  DWORD     dwBytes,i;
  DWORD     dwOffset;
  MAININDEX lpMainIndex[NUMTABLES];

  hMBFile = Create_File(hWnd,MBFileName,GENERIC_READ,OPEN_EXISTING);
  if(hMBFile==INVALID_HANDLE_VALUE)
	  return(0);
  SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN);
  ReadFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);
  for(i=0; i<NUMTABLES; i++) {
      dwBytes = lpMainIndex[i].dwTag+
                lpMainIndex[i].dwOffset+
                lpMainIndex[i].dwLength;
      if(lpMainIndex[i].dwCheckSum != dwBytes) {
	     //ProcessError(ERR_READMAININDEX,hWnd);
	       return FALSE;
	  }
  }

  dwOffset = lpMainIndex[TAG_RULE-1].dwOffset;
  SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN);
  ReadFile(hMBFile,lpRule,nRuleNum*sizeof(RULE),&dwBytes,NULL);
  CloseHandle(hMBFile);
  if(dwBytes < nRuleNum*sizeof(RULE) )
      return FALSE;
  else
      return TRUE;
}

BOOL RuleParse(HANDLE hWnd, LPTSTR szStr,DWORD dwRuleNum, LPRULE lpRule, WORD wMaxCodes)
{
  LPTSTR lpString;
  DWORD i,j;
  DWORD dwLen;
  BYTE  byDBCSLen, byDBCSPos, byCodePos;
  static TCHAR  subDBCS[] =TEXT("123456789abcdef");  
  static TCHAR  subCode[] =TEXT("0123456789abc");    
												  
  DelSpace(szStr);
  dwLen = lstrlen(szStr);
  if(dwLen == 0) return FALSE;
  if(_tcschr(szStr,TEXT('=')) == NULL) {
      ProcessError(ERR_RULEEQUAL,hWnd,ERR);
	  return FALSE;
  }
  if(_tcschr(TEXT("Cc"),szStr[0]) == NULL) {
      ProcessError(ERR_RULEHEADER,hWnd,ERR);
	  return FALSE;
  }
  if(_tcschr(TEXT("EeAaBb"),szStr[1]) == NULL) {
      ProcessError(ERR_RULELOGICOPRA,hWnd,ERR);
	  return FALSE;
  }
  if(_tcschr(subDBCS,szStr[2]) == NULL    
     || szStr[3] != TEXT('=')) {
	  ProcessError(ERR_RULEWORDLEN,hWnd,ERR);
	  return FALSE;
  }	   
  
  byDBCSLen = (szStr[2] > TEXT('9'))?szStr[2]-TEXT('a')+10:szStr[2]-TEXT('0');
  lpRule[dwRuleNum].wNumCodeUnits = 0;

  lpString = &szStr[4];
  for(i=0; i<dwLen-4; i+=4) {
      if(_tcschr(TEXT("PpNn"),	lpString[i]) == NULL) {
	      ProcessError(ERR_RULEDIRECTMODE,hWnd,ERR);
	      return FALSE;
	  }
	  byDBCSPos = (lpString[i+1]>TEXT('9'))?10+lpString[i+1]-TEXT('a'):lpString[i+1]-TEXT('0');
	  if(_tcschr(subDBCS, lpString[i+1]) == NULL  
	     ||byDBCSPos > byDBCSLen) {
	      ProcessError(ERR_RULEDBCSPOS,hWnd,ERR) ;
		  return FALSE;
	  }
	  byCodePos = (lpString[i+2]>TEXT('9'))?lpString[i+2]-TEXT('a')+10:lpString[i+2]-TEXT('0');
	  if(_tcschr(subCode, lpString[i+2]) == NULL  
         || (lpString[i+3] != TEXT('+') && lpString[i+3] != 0)
         || byCodePos > wMaxCodes) {
     	  ProcessError(ERR_RULECODEPOS,hWnd,ERR);
		  return FALSE;
	  }
	  j = lpRule[dwRuleNum].wNumCodeUnits;
	  lpRule[dwRuleNum].CodeUnit[j].dwDirectMode=(lpString[i]==TEXT('p'))?0:1;
	  lpRule[dwRuleNum].CodeUnit[j].wDBCSPosition=(WORD)byDBCSPos;
	  lpRule[dwRuleNum].CodeUnit[j].wCodePosition=(WORD)byCodePos;
	  lpRule[dwRuleNum].wNumCodeUnits ++;
  }
  lpRule[dwRuleNum].byLogicOpra = (szStr[1]==TEXT('e'))?0:(szStr[1]==TEXT('a'))?1:2;
  lpRule[dwRuleNum].byLength = byDBCSLen;
  return TRUE;
}

BOOL ConvGetMainID(HANDLE hMBFile,LPMAINID lpMainID)
{
  DWORD dwBytes;
  SetFilePointer(hMBFile,0,0,FILE_BEGIN);
  ReadFile(hMBFile,lpMainID,sizeof(MAINID),&dwBytes,NULL);
  if(dwBytes < sizeof(MAINID) )
       return FALSE;
  else
       return TRUE;
}

BOOL ConvWriteMainID(HANDLE hMBFile,LPMAINID lpMainID)
{
  DWORD dwBytes;
  if(SetFilePointer(hMBFile,0,0,FILE_BEGIN) != 0)
       return FALSE;
  WriteFile(hMBFile,lpMainID,sizeof(MAINID),&dwBytes,NULL);
  if(dwBytes < sizeof(MAINID) )
       return FALSE;
  else
       return TRUE;
}


BOOL ConvGetMainIndex(HANDLE hWnd, HANDLE hMBFile, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  int i;

  if(SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN) != ID_LENGTH)
      return FALSE;
  ReadFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);
  if(dwBytes < sizeof(MAININDEX)*NUMTABLES ) {
      ProcessError(ERR_READMAININDEX,hWnd,ERR);
      return FALSE;
  }
  else
      return TRUE;
  for(i=0; i<NUMTABLES; i++) {
      dwBytes = lpMainIndex[i].dwTag+
               lpMainIndex[i].dwOffset+
               lpMainIndex[i].dwLength;
      if(lpMainIndex[i].dwCheckSum != dwBytes) {
	      ProcessError(ERR_READMAININDEX,hWnd,ERR);
	  	  return FALSE;
	  }
  }
}

BOOL ConvWriteMainIndex(HANDLE hMBFile, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  if(SetFilePointer(hMBFile,ID_LENGTH,0,FILE_BEGIN) != ID_LENGTH) 
       return FALSE;
  WriteFile(hMBFile,lpMainIndex,sizeof(MAININDEX)*NUMTABLES,&dwBytes,NULL);
  if(dwBytes < sizeof(MAININDEX)*NUMTABLES )
       return FALSE;
  else
       return TRUE;
}


BOOL ConvReadDescript(HANDLE hMBFile, 
                      LPDESCRIPTION lpDescript,
                      LPMAININDEX lpMainIndex)
//*** read description from .MB file ****
{
  DWORD dwBytes;
  DWORD dwOffset = lpMainIndex[TAG_DESCRIPTION-1].dwOffset;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;
  ReadFile(hMBFile,lpDescript,sizeof(DESCRIPTION),&dwBytes,NULL);
  if(dwBytes < sizeof(DESCRIPTION) )
       return FALSE;
  else
       return TRUE;
}

BOOL ConvWriteDescript(HANDLE hMBFile, 
                       LPDESCRIPTION lpDescript, 
                       LPMAININDEX lpMainIndex)
//*** write description to .MB file ****
{
  DWORD dwBytes;
  DWORD dwOffset = lpMainIndex[TAG_DESCRIPTION-1].dwOffset;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;
  WriteFile(hMBFile,lpDescript,sizeof(DESCRIPTION),&dwBytes,NULL);
  if(dwBytes < sizeof(DESCRIPTION) )
       return FALSE;
  else
       return TRUE;
}


BOOL ConvReadRule(HANDLE hMBFile, 
                   int  nRuleNum,
                   LPRULE lpRule,
                   LPMAININDEX lpMainIndex)
//*** read create word rule from .MB file ****
{
  DWORD dwBytes;
  DWORD dwOffset = lpMainIndex[TAG_RULE-1].dwOffset;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;
  ReadFile(hMBFile,lpRule,nRuleNum*sizeof(RULE),&dwBytes,NULL);
  if(dwBytes < nRuleNum*sizeof(RULE) )
       return FALSE;
  else
       return TRUE;
}

BOOL ConvWriteRule(HANDLE hMBFile,
                    int nRuleNum,
                    LPRULE lpRule, 
                    LPMAININDEX lpMainIndex)
//*** write create word rule to .MB file ****
{
  DWORD dwBytes;
  DWORD dwOffset = lpMainIndex[TAG_RULE-1].dwOffset;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
       return FALSE;
  WriteFile(hMBFile,lpRule,nRuleNum*sizeof(RULE),&dwBytes,NULL);
  if(dwBytes < nRuleNum*sizeof(RULE) )
       return FALSE;
  else
       return TRUE;
}



BOOL ConvGetEncode(HANDLE hMBFile, 
                      LPENCODEAREA lpEncode,
                      LPDWORD fdwNumSWords,
				      LPDWORD fdwNumEncodeArea,
				      LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  DWORD dwOffset=lpMainIndex[TAG_ENCODE-1].dwOffset; 
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;

  ReadFile(hMBFile,fdwNumSWords,4,&dwBytes,NULL);
  ReadFile(hMBFile,fdwNumEncodeArea,4,&dwBytes,NULL);
  ReadFile(hMBFile,lpEncode,
            lpMainIndex[TAG_ENCODE-1].dwLength,&dwBytes,NULL);
  if(dwBytes < lpMainIndex[TAG_ENCODE-1].dwLength)
      return FALSE;
  else
      return TRUE;
}

//BOOL ConvInitEncode(LPENCODEAREA lpEncode)
BOOL ConvInitEncode(HGLOBAL hEncode)
{
  LPENCODEAREA       lpEncode;
  DWORD i;

  lpEncode = (LPENCODEAREA) GlobalLock(hEncode);

#ifdef UNICODE
  //CJK Symbols and Punctuation
  lpEncode[0].StartEncode = 0x3000;
  lpEncode[0].EndEncode   = 0x303f;
  //CJK Miscellaneous
  lpEncode[1].StartEncode = 0x3190;
  lpEncode[1].EndEncode   = 0x319f;
  //Enclosed CJK Letters
  lpEncode[2].StartEncode = 0x3200;
  lpEncode[2].EndEncode   = 0x32ff;
  //CJK Compatibility
  lpEncode[3].StartEncode = 0x3300;
  lpEncode[3].EndEncode   = 0x33ff;
  //CJK Unified Ideograph
  lpEncode[4].StartEncode = 0x4e00;
  lpEncode[4].EndEncode   = 0x9fff;
  //Private Use Area
  lpEncode[5].StartEncode = 0xe000;
  lpEncode[5].EndEncode   = 0xf8ff;
  //CJK Compatibility Ideograph
  lpEncode[6].StartEncode = 0xf900;
  lpEncode[6].EndEncode   = 0xfaff;
  //CJK Compatibility Font
  lpEncode[7].StartEncode = 0xfe30;
  lpEncode[7].EndEncode   = 0xfe4f;

  lpEncode[0].PreCount = 0;
  for(i=1; i< NUMENCODEAREA; i++) {
	  lpEncode[i].PreCount = lpEncode[i-1].PreCount + lpEncode[i-1].EndEncode
	  		 - lpEncode[i-1].StartEncode + 1;
  }
  
#else
  for(i=0; i< NUMENCODEAREA/2; i++) {
	  lpEncode[2*i].PreCount = i*190;
	  lpEncode[2*i].StartEncode = (0x81+i)*256 + 0x40;
	  lpEncode[2*i].EndEncode   = lpEncode[2*i].StartEncode + 0x3e;
	  lpEncode[2*i+1].PreCount = i*190 + 0x3f ;
	  lpEncode[2*i+1].StartEncode = (0x81+i)*256 + 0x80;
	  lpEncode[2*i+1].EndEncode   = lpEncode[2*i+1].StartEncode + 0x7e;
  }
#endif

  GlobalUnlock(hEncode);
   
  return TRUE;
}

BOOL ConvWriteEncode(HANDLE hMBFile, LPENCODEAREA lpEncode,
                        LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,i;
  DWORD dwOffset=lpMainIndex[TAG_ENCODE-1].dwOffset; 
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  i = NUM_OF_ENCODE;
  WriteFile(hMBFile,&i,4,&dwBytes,NULL);
  i = NUMENCODEAREA;
  WriteFile(hMBFile,&i,4,&dwBytes,NULL);

  WriteFile(hMBFile,lpEncode,
            lpMainIndex[TAG_ENCODE-1].dwLength,&dwBytes,NULL);
  if(dwBytes < lpMainIndex[TAG_ENCODE-1].dwLength)
      return FALSE;
  else
      return TRUE;
}


BOOL ConvGetCrtData(HANDLE hMBFile, LPCREATEWORD lpCreateWord,
                    LPMAININDEX lpMainIndex)
{
    DWORD dwBytes;
    DWORD dwOffset=lpMainIndex[TAG_CRTWORDCODE-1].dwOffset; 
    if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
        return FALSE;
    ReadFile(hMBFile,lpCreateWord,
            lpMainIndex[TAG_CRTWORDCODE-1].dwLength,&dwBytes,NULL);
    if(dwBytes < lpMainIndex[TAG_CRTWORDCODE-1].dwLength)
        return FALSE;
    else
        return TRUE;
}

BOOL ConvWriteCrtData(HANDLE hMBFile, LPCREATEWORD lpCreateWord,
                      LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  DWORD dwOffset=lpMainIndex[TAG_CRTWORDCODE-1].dwOffset; 

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  WriteFile(hMBFile,lpCreateWord,
            lpMainIndex[TAG_CRTWORDCODE-1].dwLength,&dwBytes,NULL);
  if(dwBytes < lpMainIndex[TAG_CRTWORDCODE-1].dwLength)
      return FALSE;
  else
      return TRUE;
}

BOOL ConvGetReConvIndex(HANDLE hMBFile, LPRECONVINDEX lpReConvIndex,
                        LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  DWORD dwOffset= lpMainIndex[TAG_RECONVINDEX-1].dwOffset;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  ReadFile(hMBFile,lpReConvIndex,
            lpMainIndex[TAG_RECONVINDEX-1].dwLength,&dwBytes,NULL);
  if(dwBytes < lpMainIndex[TAG_RECONVINDEX-1].dwLength)
      return FALSE;
  else
      return TRUE;
}	  

BOOL ConvWriteReConvIdx(HANDLE hMBFile, LPRECONVINDEX lpReConvIndex,
                        LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  DWORD dwOffset= lpMainIndex[TAG_RECONVINDEX-1].dwOffset;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  WriteFile(hMBFile,lpReConvIndex,
            lpMainIndex[TAG_RECONVINDEX-1].dwLength,&dwBytes,NULL);
  if(dwBytes < lpMainIndex[TAG_RECONVINDEX-1].dwLength)
      return FALSE;
  else
      return TRUE;

}

BOOL ConvGetCodeIndex(HANDLE hMBFile,LPDWORD fdwMaxXLen, 
                      LPSTR Code, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes;
  DWORD dwOffset= lpMainIndex[TAG_BASEDICINDEX-1].dwOffset;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  ReadFile(hMBFile,fdwMaxXLen,sizeof(DWORD),&dwBytes,NULL);
  ReadFile(hMBFile,Code,MAXNUMCODES,&dwBytes,NULL);
  if(dwBytes < MAXNUMCODES)
      return FALSE;
  else
      return TRUE;
}	  
  
BOOL ConvWriteCodeIndex (HANDLE hMBFile, LPDWORD fdwMaxXLen,
                         LPTSTR Code, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,i;
  DWORD dwOffset= lpMainIndex[TAG_BASEDICINDEX-1].dwOffset;
  BYTE CodeIndex[MAXNUMCODES];

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  WriteFile(hMBFile,fdwMaxXLen,sizeof(DWORD),&dwBytes,NULL);
  for(i=0;i<MAXNUMCODES;i++) 
      CodeIndex[i] = 0;
  for(i=0;i<(DWORD)lstrlen(Code);i++) 
      CodeIndex[Code[i]] =(BYTE)(i+1);  
  WriteFile(hMBFile,CodeIndex,MAXNUMCODES,&dwBytes,NULL);
  if(dwBytes < MAXNUMCODES)
      return FALSE;
  else
      return TRUE;
}
  
BOOL ConvGetDicIndex(HANDLE hMBFile, LPDICINDEX lpDicIndex , 
                     DWORD dwNumCodes, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,ReadBytes;
  DWORD dwOffset= lpMainIndex[TAG_BASEDICINDEX-1].dwOffset+
                  MAXNUMCODES+CODEMAPOFFSET;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  ReadBytes = sizeof(DWORD)*(dwNumCodes+1)*dwNumCodes;
  ReadFile(hMBFile,lpDicIndex,ReadBytes,&dwBytes,NULL);
  if(dwBytes < ReadBytes)
      return FALSE;
  else
      return TRUE;
}
  
BOOL ConvWriteDicIndex(HANDLE hMBFile, LPDICINDEX lpDicIndex , 
                     DWORD dwNumCodes, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,WriteBytes;
  DWORD dwOffset= lpMainIndex[TAG_BASEDICINDEX-1].dwOffset+
                  MAXNUMCODES+CODEMAPOFFSET;

  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  WriteBytes = sizeof(DWORD)*(dwNumCodes+1)*dwNumCodes;
  WriteFile(hMBFile,lpDicIndex,WriteBytes,&dwBytes,NULL);
  if(dwBytes < WriteBytes)
      return FALSE;
  else
      return TRUE;
}
  
BOOL ConvGetNumXYWords(HANDLE hMBFile, LPDWORD lpNumXYWords, 
                       DWORD dwNumCodes, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,ReadBytes;
  DWORD dwOffset;
  
  ReadBytes = sizeof(DWORD)*(dwNumCodes+1)*dwNumCodes;
  dwOffset=lpMainIndex[TAG_BASEDICINDEX-1].dwOffset+
           MAXNUMCODES+CODEMAPOFFSET+ReadBytes;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;
  ReadFile(hMBFile,lpNumXYWords,ReadBytes,&dwBytes,NULL);
  if(dwBytes < ReadBytes)
      return FALSE;
  else
      return TRUE;
}
  

BOOL ConvWriteNumXYWords(HANDLE hMBFile, LPDWORD lpNumXYWords, 
                         DWORD dwNumCodes, LPMAININDEX lpMainIndex)
{
  DWORD dwBytes,WriteBytes;
  DWORD dwOffset;
  
  WriteBytes = sizeof(DWORD)*(dwNumCodes+1)*dwNumCodes;
  dwOffset=lpMainIndex[TAG_BASEDICINDEX-1].dwOffset+
           MAXNUMCODES+CODEMAPOFFSET+WriteBytes;
  if(SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN) != dwOffset)
      return FALSE;

  SetFilePointer(hMBFile,lpMainIndex[TAG_BASEDICINDEX-1].dwOffset+
                 WriteBytes+MAXNUMCODES+CODEMAPOFFSET,0,FILE_BEGIN);
  WriteFile(hMBFile,lpNumXYWords,WriteBytes,&dwBytes,NULL);
  if(dwBytes < WriteBytes)
      return FALSE;
  else
     return TRUE;
}
  
int  ConvReconvIndex(HANDLE hWnd,
			         LPTSTR szDBCS,
                     LPCREATEWORD  lpCreateWords,
                     WORDINDEX     WordIndex,
                     LPDESCRIPTION lpDescript,
                     LPRECONVINDEX lpReConvIndex)
{
    int no;
    TCHAR tmpStr[256];

    if(WordIndex.wDBCSLen != 1)
   	    return FALSE;
    no =  EncodeToNo(szDBCS);
    if(no < 0 || no >= NUM_OF_ENCODE) 
	    return FALSE;
    if(lpDescript->wNumRules != 0 && lpDescript->byMaxElement == 1)
    {
        lstrncpy(tmpStr,
                lpDescript->wMaxCodes,
                lpCreateWords + no*(DWORD)lpDescript->wMaxCodes);
	    if(lstrlen(tmpStr) == 0 || 
#ifdef UNICODE
	        (!(WriteCrtFlag[(no/8)] & (1 << (7 - (no%8))) ) && _wcsicmp(WordIndex.szCode,tmpStr) < 0) )
#else
			(!(WriteCrtFlag[(no/8)] & (1 << (7 - (no%8))) ) && _strcmpi(WordIndex.szCode,tmpStr) < 0) )
#endif UNICODE
            lstrncpy(lpCreateWords + no*(DWORD)lpDescript->wMaxCodes,
                    lpDescript->wMaxCodes,
                    WordIndex.szCode);
    }
    else
	{
        lstrncpy(tmpStr,
                 lpDescript->wMaxCodes,
                 lpReConvIndex + no*(DWORD)lpDescript->wMaxCodes);
		tmpStr[lpDescript->wMaxCodes] = 0;
#ifdef UNICODE
	    if(lstrlen(tmpStr) == 0 || _wcsicmp(WordIndex.szCode,tmpStr) < 0)
#else
		if(lstrlen(tmpStr) == 0 || _strcmpi(WordIndex.szCode,tmpStr) < 0)
#endif
            lstrncpy(lpReConvIndex + no*(DWORD)lpDescript->wMaxCodes,
                     lpDescript->wMaxCodes,
	                 WordIndex.szCode);
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\conv.h ===
/*************************************************
 *  conv.h                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef __CONV_H
#define __CONV_H

#include <windows.h>
#include <windowsx.h>
#include <io.h>
#include <stdio.h>
#include <string.h>
#include "propshet.h"

//****** PlatFormID ********
#define WIN95_PRC                 0x00000001
#define WIN95_CJK                 0x00000002

//****** EncodeID **********
#define GBK_IME                   0x00000001
#define UNICODE_IME               0x00000002

//****** FileFlag **********
#define FFLG_SINGLEELEMENT                0x00000000
#define FFLG_MULTIELEMENT                 0x00000002
#define FFLG_RULE                         0x00000001
#define FFLG_NORULE                       0x00000000

//****** Number of tables ******
#define NUMTABLES                 0x00000007

//****** Version ***********
#define MBVERSION                 "1.00"

//****** Index tag *********
#define TAG_DESCRIPTION           0x00000001
#define TAG_RULE                  0x00000002
#define TAG_ENCODE                0x00000003
#define TAG_CRTWORDCODE           0x00000004
#define TAG_RECONVINDEX           0x00000005
#define TAG_BASEDICINDEX          0x00000006
#define TAG_BASEDIC               0x00000007

//****** Get code direction mode ****
#define GETCODEFORWARD            0x00000001
#define GETCODEBACKWARD                   0xffffffff

//****** define error number  *******
#define ERR_MBNAME                1001
#define ERR_FILENOTEXIST                  1002
#define ERR_FILENOTOPEN                   1003
#define ERR_OUTOFMEMORY                   1004
#define ERR_GLOBALLOCK            1005
#define ERR_IMEUSE                                1006

#define ERR_MAXCODES              1101 //error:MaxCodes over 12!
#define ERR_ELEMENT                               1102 //error:MaxElement above MaxCodes!
#define ERR_USEDCODE              1103 //error:not in {'0'~'9','a'~'z',...}
#define ERR_WILDCHAR              1104 //error:WildChar in {UsedCode} !
#define ERR_DESCRIPTSEG                   1105
#define ERR_OVERWRITE             1106
#define ERR_IMENAMEENTRY          1107
#define ERR_MAXCODESENTRY         1108
#define ERR_ELEMENTENTRY          1109
#define ERR_USEDCODEENTRY         1110
#define ERR_NUMRULEENTRY          1111

#define ERR_RULEHEADER            1201                       
#define ERR_RULELOGICOPRA         1202                       
#define ERR_RULEWORDLEN           1203                       
#define ERR_RULEEQUAL                     1204//error:not exist '='
#define ERR_RULEDBCSPOS           1205//error:DBCS position not in {'1'~'9','a'~'f'}
#define ERR_RULECODEPOS           1206
#define ERR_RULEDIRECTMODE        1207
#define ERR_NORULE                1210 
#define ERR_NOTDEFRULE                    1211//error:not defined this length word's ruler
#define ERR_RULENUM               1212
#define ERR_RULESEG               1213
#define ERR_DUPRULE               1214        //DUPLICATE RULE 

#define ERR_DBCSCODE              1301
#define ERR_CODEUNITNOTEXIST      1302
#define ERR_CREATECODE            1303
#define ERR_CREATENOTEXIST                1304//multi-elements
#define ERR_CODEEMPTY             1305//when ruler doesnot exist
#define ERR_SINGLECODEWORDDOUBLE  1306
#define ERR_SBCS_IN_DBCS          1307
#define ERR_GB2312NOTENTIRE       1308
#define ERR_USERWORDLEN           1309        
#define ERR_WORDNOTEXIST          1310
#define ERR_TEXTSEG                               1311
#define ERR_TOOMANYUSERWORD               1312

#define ERR_WRITEID               1401
#define ERR_WRITEMAININDEX        1402
#define ERR_WRITEDESCRIPT         1403
#define ERR_WRITERULE             1404
#define ERR_READID                1411
#define ERR_READMAININDEX         1412
#define ERR_READDESCRIPT          1413
#define ERR_READRULE              1414
 
#define ERR_CONVEND                               1501
#define ERR_RECONVEND                     1502
#define ERR_SORTEND                               1503

#define ERR_VERSION               1601
#define ERR_GROUP                 1602

#define ERR                                               1
#define INFO                                      2
#define WARNING                                   3
#define GB2312WORDNUM             6763
#define NUM_OF_XGB_ENCODE         23940
#define NUM_OF_CJK_ENCODE         28528

#ifdef UNICODE
#define NUM_OF_ENCODE             NUM_OF_CJK_ENCODE
#else
#define NUM_OF_ENCODE             NUM_OF_XGB_ENCODE
#endif

//CJK Unified Ideograph subset
#define NUM_OF_CJK_CHINESE        20992

#ifdef UNICODE
#define NUMENCODEAREA                 8
#else
#define NUMENCODEAREA                 252
#endif

#define MAXNUMCODES               128
#define MAXUSEDCODES              48
#define NAMESIZE                  128
#define MAXCODELEN                12
#define MAXREADBUFFER             0x4000
#define USER_WORD_SIZE            40
#define MAX_WORD_SIZE             256
//#define ID_LENGTH                                 28
#define ID_LENGTH	sizeof(MAINID)
#define CODEMAPOFFSET                     4
#define MAXUSERWORDS                      1000
#define GMEM_PAGESIZE             0x10000

#define MbName                    "IME file"
//#define CaptionName               "뷨"
#define ImeSubKey                 "System\\CurrentControlSet\\Control\\Keyboard Layouts"


#define szClassName             "IMEGEN"
#define TplName                 "\\ImeGen.tpl"
#define BmpExt                  ".BMP"
#define IconExt         ".ICO"
#define HlpExt          ".HLP"
#define ImeExt          ".IME"
#define MbExt           ".MB"
#define EmbExt          ".EMB"
#define TxtFileExt  ".TXT"
#define Slope           "\\"

#define LayoutTextKey   "layout text"
#define PreImeKey               "keyboard layout\\preload"
#define DescriptSeg             "[Description]"
#define RuleSeg                 "[Rule]"
#define TextSeg                 "[Text]"
#define TempFile                "$$$$$$$$.$$$"
#define DefVer                  "5.0"
#define DefOrgName              "Microsoft"

#define NUMPROPSHEET    5 
#define PROP_CRTIME             0
#define PROP_RECONV             1
#define PROP_SORT               2
#define PROP_CRTWORD    3
#define PROP_ABOUT              4 


typedef unsigned char UCHAR;
typedef LPTSTR  LPCREATEWORD;
typedef LPTSTR  LPRECONVINDEX;
typedef LPDWORD LPDICINDEX;
typedef LPDWORD LPNUMXYWORDS;

typedef struct tagMAINID {
    TCHAR  szVersion[4];
	DWORD dwLanguageID;
	DWORD dwEncodeID;
	DWORD dwFileFlag;
	DWORD dwNumTables;
	DWORD dwNumWords;
}  MAINID, FAR *LPMAINID;

typedef struct tagMAININDEX {
	 DWORD dwTag;
	 DWORD dwOffset;
	 DWORD dwLength;
	 DWORD dwCheckSum;   //Check if dwCheckSum=dwTag+dwOffset+dwLength
}  MAININDEX, FAR *LPMAININDEX;

typedef struct tagDESCRIPTION {
     TCHAR szName[NAMESIZE];
     WORD  wMaxCodes;
	 WORD  wNumCodes;
	 TCHAR szUsedCode[MAXUSEDCODES];
     BYTE  byMaxElement;
	 TCHAR cWildChar;
	 WORD  wNumRules;
} DESCRIPTION,FAR * LPDESCRIPTION;

typedef struct tagCREATEWORDRULE {
     BYTE byLogicOpra;
	 BYTE byLength;
	 WORD wNumCodeUnits;
	 struct CODEUNIT {
	      DWORD dwDirectMode;
		  WORD  wDBCSPosition;
		  WORD  wCodePosition;
     } CodeUnit[12];
} RULE,FAR *LPRULE;

typedef struct  tagENCODEAREA {
	 DWORD PreCount;   
     DWORD StartEncode;
	 DWORD EndEncode;
} ENCODEAREA,FAR *LPENCODEAREA;

typedef struct tagEMBHEAD {
    TCHAR W_Code[MAXCODELEN];               
    TCHAR C_Char[USER_WORD_SIZE];
} EMB_Head,FAR *LPEMB_Head;

typedef struct tagWORDINDEX {
     TCHAR szCode[MAXCODELEN+1];
	 WORD  wDBCSLen;
	 DWORD dwOffset;
}  WORDINDEX,FAR *LPWORDINDEX;


typedef struct tagImeRes{
     TCHAR  Version[NAMESIZE];
	 TCHAR  Depart[NAMESIZE/2];
	 TCHAR  BmpName[MAX_PATH];
	 TCHAR  IcoName[MAX_PATH];
	 TCHAR  HlpFile[MAX_PATH];   
	 WORD  Value;
}IMERES,FAR *LPIMERES;


extern HANDLE   hDlgless;
extern HGLOBAL  hRule;
HGLOBAL         hEncode;
HINSTANCE       hInst;
DWORD           dwLineNo;
WORD            EMB_Count;
HANDLE          HmemEMB_Table;
HANDLE hSRCFile,hMBFile; 
HANDLE hCmbFile;   
BYTE   WriteCrtFlag[(NUM_OF_ENCODE+7)/8];
BOOL InitApplication(HINSTANCE);

BOOL ConvConv           (HANDLE, LPCTSTR, LPCTSTR); 
BOOL ConvReConv         (HANDLE, LPCTSTR, LPCTSTR);
BOOL ConvGetMainID      (HANDLE, LPMAINID);
BOOL ConvWriteMainID    (HANDLE, LPMAINID);
BOOL ConvGetMainIndex   (HANDLE, HANDLE, LPMAININDEX);
BOOL ConvWriteMainIndex (HANDLE, LPMAININDEX);

BOOL ConvReadFile       (HANDLE, LPCTSTR, LPCTSTR);
BOOL WriteSortFile      (HANDLE, HANDLE, HANDLE, LPWORDINDEX, LPCREATEWORD);
BOOL ConvReadDescript   (HANDLE, LPDESCRIPTION, LPMAININDEX);
BOOL ConvWriteDescript  (HANDLE, LPDESCRIPTION, LPMAININDEX);
int  ConvGetDescript    (HANDLE, LPCTSTR, LPDWORD, LPDWORD, LPDESCRIPTION,BOOL);
BOOL ConvSaveDescript   (LPCTSTR, LPDESCRIPTION, DWORD, DWORD);

BOOL ConvReadRule       (HANDLE, int, LPRULE, LPMAININDEX);
BOOL ConvWriteRule      (HANDLE, int, LPRULE, LPMAININDEX);
int  ConvGetRule        (HANDLE, LPCTSTR, LPDWORD, LPDWORD, LPRULE, LPDESCRIPTION);
BOOL ConvSaveRule       (HANDLE, LPCTSTR, DWORD, DWORD, LPRULE, DWORD);

BOOL ConvInitEncode     (HGLOBAL hEncode);
BOOL ConvGetEncode      (HANDLE, LPENCODEAREA, LPDWORD, LPDWORD, LPMAININDEX);
BOOL ConvWriteEncode    (HANDLE, LPENCODEAREA, LPMAININDEX);

BOOL ConvGetCrtData     (HANDLE, LPCREATEWORD, LPMAININDEX);
BOOL ConvWriteCrtData   (HANDLE, LPCREATEWORD, LPMAININDEX);
BOOL ConvGetReConvIndex (HANDLE, LPRECONVINDEX, LPMAININDEX);
BOOL ConvWriteReConvIdx (HANDLE, LPRECONVINDEX, LPMAININDEX);
BOOL ConvGetCodeIndex   (HANDLE, LPDWORD, LPSTR, LPMAININDEX);
BOOL ConvWriteCodeIndex (HANDLE, LPDWORD, LPTSTR, LPMAININDEX);
BOOL ConvGetDicIndex    (HANDLE, LPDWORD, DWORD, LPMAININDEX);
BOOL ConvWriteDicIndex  (HANDLE, LPDWORD, DWORD, LPMAININDEX);
BOOL ConvGetNumXYWords  (HANDLE, LPDWORD, DWORD, LPMAININDEX);
BOOL ConvWriteNumXYWords(HANDLE, LPDWORD, DWORD, LPMAININDEX);

BOOL ConvInsNewWord     (HANDLE, HANDLE, EMB_Head);
BOOL ConvSort           (HANDLE, LPWORDINDEX, int);
BOOL ConvBatCreate      (HANDLE, DESCRIPTION, LPRULE, LPCREATEWORD, LPTSTR, LPTSTR);
LPTSTR ConvCreateWord    (HWND, LPCTSTR, LPTSTR);

void ConvInit           (LPDESCRIPTION,LPMAINID,LPMAININDEX);
BOOL ConvGetBaseWord    (HANDLE, WORDINDEX, LPTSTR);
BOOL ConvWriteBaseWord  (HANDLE, HANDLE, HANDLE, MAINID,DWORD, 
			 LPCREATEWORD, LPRECONVINDEX, DWORD);
BOOL ReadSRCFile        (HANDLE, LPINT, HANDLE, LPCREATEWORD, LPWORDINDEX, 
			 LPINT, LPDESCRIPTION,LPRECONVINDEX);
BOOL ConvCalc           (HANDLE ,HANDLE ,LPWORDINDEX ,LPMAININDEX ,LPDESCRIPTION);
//BOOL WriteMBFile        (HANDLE, HANDLE, HANDLE, LPWORDINDEX, 
//                         LPMAININDEX, LPDESCRIPTION, LPCREATEWORD, LPRECONVINDEX);
BOOL WriteMBFile        (HANDLE, HANDLE, HANDLE, LPWORDINDEX, 
			 LPMAININDEX, LPDESCRIPTION);
int  WordSplit          (HANDLE, LPINT, LPTSTR, LPCREATEWORD, LPWORDINDEX,
			 LPDESCRIPTION,LPRECONVINDEX);
int  SimpleSplit        (HANDLE, LPINT, LPTSTR, LPCREATEWORD, LPWORDINDEX, WORD);
void qSort              (LPWORDINDEX, DWORD,DWORD);
void qSortChar          (LPTSTR , DWORD ,DWORD );
HANDLE IndexReAlloc     (HANDLE, LPINT);
BOOL RuleParse          (HANDLE, LPTSTR, DWORD, LPRULE, WORD);
void RuleToText         (LPRULE, LPTSTR);
void MoveFileBlock      (HANDLE, DWORD, DWORD, DWORD);
DWORD EncodeToNo        (LPTSTR);
DWORD EncodeToGBNo      (UCHAR szDBCS[3]);
void NoToEncode         (DWORD, LPBYTE, DWORD, LPENCODEAREA);
BOOL CheckCrtData       (HANDLE, LPCREATEWORD, LPENCODEAREA, DWORD);
void DispInfo           (HANDLE, WORD);
void lstrncpy0          (LPTSTR ,int ,LPTSTR );
BOOL ReadUserWord       (HWND ,LPTSTR ,LPDWORD,WORD);
INT  ReadDescript       (LPCTSTR , LPDESCRIPTION ,DWORD);
BOOL ReadRule           (HWND, LPCTSTR , int ,LPRULE );
int  CheckUserWord      (HWND ,LPTSTR, WORD);
BOOL CheckUserDBCS      (HWND ,LPTSTR);
BOOL CheckCodeLegal     (HWND ,LPTSTR ,LPTSTR, LPTSTR, LPDESCRIPTION );
BOOL CheckCodeCollection(HWND ,LPTSTR ) ;
BOOL SaveFileAs         (HWND , LPTSTR );
BOOL CreateMbKey        (PHKEY ,LPCTSTR ,LPCTSTR);
BOOL SetRegValue        (HKEY ,LPDWORD );
BOOL GetRegValue        (HWND, HKEY ,LPDWORD );


extern void   DelSpace();
extern void   trim();
extern BOOL   ParseDBCSstr();
extern void   lstrncpy();
extern HANDLE Create_File();
extern BOOL   Copy_File();
extern void   ProcessError();
extern BOOL   QueryKey();
extern BOOL   ErrMessage();
extern VOID   WarnMessage();
extern VOID   FatalMessage();
extern VOID   InfoMessage();
extern void   ErrorOut();
extern HANDLE CreateMapFile ();
extern HANDLE CreateMap     ();
extern LPVOID MapView       ();
extern HANDLE OpenMap       ();
extern BOOL   WriteEMBToFile();
extern BOOL   ReadEMBFromFile();
extern void   DelSelCU();
extern int    AddZCItem();
extern void   fnsplit();
extern int    GetEntryInt(LPTSTR , LPTSTR, int ,LPINT);
extern int    GetEntryString();
extern void   GetEntryName();
extern int    CheckDescription();
extern int    GetDescriptEntry();
extern BOOL  searchPos(LPWORDINDEX , DWORD );  
extern DWORD bSearch(LPWORDINDEX ,  DWORD , DWORD , WORDINDEX ); 
int  ConvReconvIndex(HANDLE ,LPTSTR ,LPCREATEWORD ,WORDINDEX ,LPDESCRIPTION ,LPRECONVINDEX );
void DelIllegalCode(TCHAR *);
LPTSTR _tcschr(LPTSTR, TCHAR);
LPTSTR _tcsrchr(LPTSTR, TCHAR);
LPTSTR _tcsstr(LPTSTR, LPTSTR);
LPTSTR _tcsupr(LPTSTR);
int _taccess(LPTSTR, int);
int _ttoi(LPTSTR);
#endif //__CONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\imegen.c ===
/*************************************************
 *  imegen.c                                     *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//
//  MODULE:   winmain.c
//

#include <windows.h>            // required for all Windows applications
#include <windowsx.h>
#include "propshet.h"
#include "prop.h"

//char szAppName[9];              // The name of this application

/****************************************************************************

  FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

  PURPOSE: calls initialization function, processes message loop

  PARAMETERS:

    hInstance - The handle to the instance of this application that
          is currently being executed.

    hPrevInstance - This parameter is always NULL in Win32
          applications.

    lpCmdLine - A pointer to a null terminated string specifying the
          command line of the application.

    nCmdShow - Specifies how the main window is to be diplayed.

  RETURN VALUE:
    If the function terminates before entering the message loop,
    return FALSE.
    Otherwise, return the WPARAM value sent by the WM_QUIT message.
 ****************************************************************************/


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance, 
                     LPSTR     lpCmdLine, 
                     int       nCmdShow)
{
//    MSG msg;
//    HANDLE hAccelTable;
    if (!InitApplication(hInstance))
            return (FALSE);              
    return(DoPropertySheet(NULL));

//    LoadString(hInstance, IDS_APPNAME, szAppName, sizeof(szAppName));
//    hAccelTable = LoadAccelerators(hInstance, szAppName);
/*    hAccelTable = LoadAccelerators(hInstance, NULL);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
*/
}

/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

        COMMENTS:

                This function is called at initialization time only if no other
                instances of the application are running.  This function performs
                initialization tasks that can be done once for any number of running
                instances.

                In this case, we initialize a window class by filling out a data
                structure of type WNDCLASS and calling the Windows RegisterClass()
                function.  Since all instances of this application use the same window
                class, we only need to do this when the first instance is initialized.


****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;

        // Fill in window class structure with parameters that describe the
        // main window.

        wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
        wc.lpfnWndProc   = (WNDPROC)CopyrightProc; // Window Procedure
        wc.cbClsExtra    = 0;                      // No per-class extra data.
        wc.cbWndExtra    = 0;                      // No per-window extra data.
        wc.hInstance     = hInstance;              // Owner of this class
        wc.hIcon         = LoadIcon(hInstance,MAKEINTRESOURCE(IDI_IMEGEN));                   // Icon name from .RC
//        wc.hIcon         = NULL;                   // Icon name from .RC
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);// Cursor
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color
        wc.lpszMenuName  = NULL;                    // Menu from .RC
        wc.lpszClassName = TEXT(szClassName);       // Name to register as

        // Register the window class and return success/failure code.
        return (RegisterClass(&wc));
}


/****************************************************************************
INT_PTR APIENTRY CopyrightProc(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
****************************************************************************/
INT_PTR APIENTRY CopyrightProc(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
{
	HBRUSH      hBrush1,hBrush2;
	HPEN		hPen;
	HDC         hDC;
	PAINTSTRUCT ps;
	RECT		Rect;
    
    switch (message) {
        case WM_INITDIALOG:
            return (TRUE);

        case WM_PAINT:
		    GetClientRect(hDlg, &Rect);
			hDC = BeginPaint(hDlg, &ps);
			hBrush1 = CreateSolidBrush( GetSysColor(COLOR_BTNFACE));

            if ( hBrush1 )
            {
			    hPen = CreatePen(PS_SOLID,1, GetSysColor(COLOR_BTNFACE));

                if ( hPen )
                {
			        hPen = SelectObject(hDC, hPen);
			        hBrush2 = SelectObject(hDC, hBrush1);
			        Rectangle(hDC,Rect.left,Rect.top, Rect.right,Rect.bottom);
                    DeleteObject(SelectObject(hDC, hPen));
                }
                SelectObject(hDC, hBrush2);
			    DeleteObject(hBrush1);
            }

			EndPaint(hDlg,&ps);
			return 0; 

		case WM_KEYUP:
		    if(wParam != VK_SPACE)
			    break;
		case WM_KEYDOWN:
		     SendMessage(GetParent(hDlg),WM_COMMAND,GetWindowLong(hDlg,GWLP_ID),lParam);
			 return 0;

    }
    return DefWindowProc(hDlg, message, wParam, lParam);
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\conv.c ===
/*************************************************
 *  conv.c                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "conv.h"

DWORD       dwBaseWordNum;
HGLOBAL     hCreateWord;
HGLOBAL     hWordIndex;
HGLOBAL     hEncode;
#ifdef UNICODE
TCHAR Title[] = {0x6D4F, 0x89C8, 0x0000};
TCHAR szVer[] = {0x8F93, 0x5165, 0x6CD5, 0x0020, 0x7248, 0x672C, 0x0000};
#else
BYTE Title[] = "";
BYTE szVer[] = "뷨 汾";
#endif
		 
/*****************************************************************************

  FUNCTION: ConvConv(HANDLE hWnd,LPCSTR lpSrcFileName, LPCSTR lpszMBFileName)

  PURPOSE:  Processes MB conversion .

  PARAMETERS:
    hWnd - window handle of the parent window.
	lpSrcFileName - pointer to source text file name.
	lpszMBFileName - pointer to destinate .mb  file name.
  
  RETURN VALUE:
    TRUE - conversion completed
    FALSE - conversion not completed

  HISTORY:
    
 ****************************************************************************/

BOOL ConvConv(HANDLE hWnd,LPCTSTR lpSrcFileName, LPCTSTR lpszMBFileName)
{
  int    nTemp;
  DWORD  dwDBCS;
  DWORD  dwRuleOffset, dwRuleLen;
  DWORD  dwDesOffset, dwDesLen;
  DWORD  i;
  int    nPages;
  TCHAR  szDBCS[512];
  //dwRuleOffset: Rule segment's offset in source file


  MAINID        MainID;
  LPMAININDEX   lpMainIndex;
  LPCREATEWORD  lpCreateWords;
  DESCRIPTION   Descript;
  LPWORDINDEX   lpWordIndex;
  LPRULE        lpRule;

  HANDLE        hReConvIndex, hMainIndex;
  LPRECONVINDEX lpReConvIndex;
  LPENCODEAREA  lpEncode; 
                              
  DispInfo(hWnd,IDS_CONVERTINFO);
  nTemp = (int)ConvGetDescript(hWnd,lpSrcFileName,&dwDesOffset,
      &dwDesLen,&Descript,FALSE);
  if(nTemp == -ERR_FILENOTOPEN || nTemp < -4 ) 
      return FALSE;   
  hMainIndex = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(MAININDEX)*NUMTABLES);
  if(!(lpMainIndex = GlobalLock(hMainIndex) ) ) {
      ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
      return FALSE;
  }
  ConvInit(&Descript,&MainID,lpMainIndex);


  nPages = 1;
  dwBaseWordNum = 0;

  nTemp = sizeof(WORDINDEX)*GMEM_PAGESIZE;
  hWordIndex=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, nTemp);
  hCreateWord = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
	   (DWORD)Descript.wMaxCodes*NUM_OF_ENCODE*sizeof(TCHAR));
  if(!hMainIndex||!hCreateWord || !hWordIndex || !hRule) {
      ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
	  goto err;
  }

  if(!(lpCreateWords = GlobalLock(hCreateWord) ) 
     ||!(lpWordIndex = (LPWORDINDEX) GlobalLock(hWordIndex))
     ||!(lpRule = GlobalLock(hRule)) )  {
      ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
	  goto err;
  }


  if(ConvGetRule(hWnd,lpSrcFileName,&dwRuleOffset,&dwRuleLen,
     lpRule,&Descript)<=0)
      goto err;
 
  hSRCFile = Create_File(hWnd,lpSrcFileName,GENERIC_READ,OPEN_EXISTING);
  if (hSRCFile == (HANDLE)-1)
	  return FALSE;		 
  hMBFile = Create_File(hWnd,lpszMBFileName,GENERIC_READ|GENERIC_WRITE,
           CREATE_ALWAYS);
  if (hMBFile == (HANDLE)-1) {
      CloseHandle(hSRCFile);
      return FALSE;
  }

  if(!ConvWriteMainID(hMBFile,&MainID)) {
      ProcessError(ERR_WRITEID,hWnd,ERR);
	  goto err;
  }
  if(!ConvWriteMainIndex(hMBFile,lpMainIndex)) {
      ProcessError(ERR_WRITEMAININDEX,hWnd,ERR);
	  goto err;
  }
  if(!ConvWriteDescript(hMBFile, &Descript, lpMainIndex)) {
      ProcessError(ERR_WRITEDESCRIPT,hWnd,ERR);
	  goto err;
  }
  if(lpMainIndex[TAG_RULE-1].dwLength != 0)
      if(!ConvWriteRule( hMBFile,Descript.wNumRules,lpRule, lpMainIndex)) {
          ProcessError(ERR_WRITERULE,hWnd,ERR);
	      goto err;
      }
  hReConvIndex = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
	   (DWORD)Descript.wMaxCodes*NUM_OF_ENCODE*sizeof(TCHAR));

  if(!hReConvIndex) {
      ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);		
	  goto err;
  }

  if(!(lpReConvIndex = GlobalLock(hReConvIndex)) 
     || !(lpEncode = GlobalLock(hEncode)) )  {
      ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
	  goto err;
  }

  DispInfo(hWnd,IDS_READTEXTINFO);

  if(!ReadSRCFile(hWnd,&nPages,hSRCFile,lpCreateWords,
                  lpWordIndex,&dwDBCS,&Descript,lpReConvIndex))  {
	  goto err;
  }

  DispInfo(hWnd,IDS_WRCRTINFO);
//****** fill code mapping *****
  ConvWriteEncode(hMBFile,lpEncode,lpMainIndex);

  if(Descript.wNumRules != 0)	{
      LoadString(NULL,IDS_ISCHECKCRTWORD,szDBCS, sizeof(szDBCS)/sizeof(TCHAR));
      if(ErrMessage(hWnd, szDBCS))
	  {     
         if(!CheckCrtData(hWnd,lpCreateWords,lpEncode,Descript.wMaxCodes) ) {
             ProcessError(ERR_GB2312NOTENTIRE,hWnd,ERR);
		     goto err;
		 }
	  }
  }  //******* Debug *******

  if(lpMainIndex[TAG_CRTWORDCODE-1].dwLength != 0)
      ConvWriteCrtData(hMBFile,lpCreateWords,lpMainIndex);
  if(lpMainIndex[TAG_RECONVINDEX-1].dwLength != 0)
      ConvWriteReConvIdx(hMBFile,lpReConvIndex,lpMainIndex);
  GlobalUnlock(hEncode);

//****95.10.12 auto add code for phrases not exist code
  SetCursor (LoadCursor (NULL, IDC_WAIT));   
  if( Descript.wNumRules != 0)
  { 
     for(i=0; i<dwBaseWordNum; i++) 
     {
        if(lpWordIndex[i].wDBCSLen > 1
          && (lstrlen(lpWordIndex[i].szCode) == 0)
           ) {
           SetFilePointer(hSRCFile,lpWordIndex[i].dwOffset,0,FILE_BEGIN);
		   nTemp = 2*(DWORD)lpWordIndex[i].wDBCSLen;
		   ReadFile(hSRCFile,szDBCS,nTemp,&dwDBCS,NULL);
		   szDBCS[nTemp] = 0;
           ConvBatCreate(hWnd,Descript,lpRule,
	                 lpCreateWords,szDBCS,
                     lpWordIndex[i].szCode);
		   if(lpWordIndex[i].szCode[0] == TEXT(',') && lpWordIndex[i].szCode[1] == TEXT('z'))
		        continue;
		   if(lstrlen(lpWordIndex[i].szCode) == 0)
		   {
				goto err;
		   }

	    }
     }
  }

  SetCursor (LoadCursor (NULL, IDC_ARROW));   

  DispInfo(hWnd,IDS_SORT);

  ConvSort(hWnd,lpWordIndex,dwBaseWordNum);
  SetFilePointer(hMBFile,lpMainIndex[TAG_BASEDICINDEX-1].dwOffset,0,FILE_BEGIN);

//***** fill index area with null  *****
  nTemp = Descript.wNumCodes;
  nTemp = sizeof(DWORD)*(nTemp+1)*nTemp;
  WriteFile(hMBFile,NULL,nTemp,&nTemp,NULL);

//***** fill index area and length area *****
  ConvCalc(hWnd,hMBFile,lpWordIndex,lpMainIndex,&Descript);

//***** fill dictionary area  *****
  WriteMBFile(hWnd,hSRCFile,hMBFile,lpWordIndex,lpMainIndex,&Descript);
  MainID.dwNumWords = dwBaseWordNum;

//***** fill changed MainID  *****
  ConvWriteMainID(hMBFile,&MainID);

  GlobalUnlock(hRule);
  if(hCreateWord)
      GlobalFree(hCreateWord);
  GlobalUnlock(hReConvIndex);
  GlobalFree(hReConvIndex);

  GlobalUnlock(hWordIndex);
  GlobalFree(hWordIndex);
  CloseHandle(hMBFile);
  CloseHandle(hSRCFile);

  ProcessError(ERR_CONVEND, hWnd, INFO);
  return TRUE;

err:
  if(hSRCFile)
      CloseHandle(hSRCFile);
  if(hMBFile)
      CloseHandle(hMBFile);
  if(hMainIndex)
      GlobalFree(hMainIndex);
  if(hWordIndex)
      GlobalFree(hWordIndex);
  if(hCreateWord)
      GlobalFree(hCreateWord);
  if(hReConvIndex)
      GlobalFree(hReConvIndex);
  if(hRule)
      GlobalUnlock(hRule);
  return FALSE;

}

/*****************************************************************************

  FUNCTION: ConvReadFile(HANDLE hWnd,LPCSTR lpSrcFileName, LPCSTR lpDestFile)

  PURPOSE:  Processes source text file sorting.

  PARAMETERS:
    hWnd - window handle of the parent window.
	lpSrcFileName - pointer to source text file name.
	lpDestFile - pointer to destinate sorted text file name.
  
  RETURN VALUE:
    TRUE - sorting completed
    FALSE - sorting not completed

  HISTORY:
    
 ****************************************************************************/

BOOL ConvReadFile(HANDLE hWnd,
                  LPCTSTR lpSrcFileName,
				  LPCTSTR lpDestFile)
{
  DWORD  i,j;
  DWORD  dwRuleOffset, dwRuleLen;
  DWORD  dwDesOffset,  dwDesLen;
  DWORD  dwReadBytes;
  DWORD  dwFstOffset=0;
  DWORD  dwOffset=0;
  TCHAR  szStr[512],szDBCS[512];
  TCHAR  Buffer[MAXREADBUFFER];
  BOOL   bReadText = FALSE, bSameFile=FALSE;
  int    nRet;
  int    nPages;
  BOOL   IsGenCmb = FALSE;  

  HANDLE        hRule0;
  LPCREATEWORD  lpCreateWords;
  LPWORDINDEX   lpWordIndex;
  LPRULE        lpRule;
  DESCRIPTION   Descript;
  HANDLE 		hDlgItem;

  nRet = (int)ConvGetDescript(hWnd,lpSrcFileName,&dwDesOffset,
        &dwDesLen,&Descript,FALSE);
  if(nRet == -ERR_FILENOTOPEN)
      return FALSE; 
  if((-nRet)&7)
      bReadText = TRUE;
  if(Descript.wMaxCodes <= 0)
      Descript.wMaxCodes = MAXCODELEN;
  nPages = 1;
  dwBaseWordNum = 0;
  dwReadBytes = sizeof(WORDINDEX)*GMEM_PAGESIZE;
  hCreateWord = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
	  MAXCODELEN*NUM_OF_ENCODE*sizeof(TCHAR));
  hWordIndex=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, dwReadBytes);
  if(!hWordIndex ) {
      ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
	  goto err;
  }
  if(!hCreateWord ) {
        ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
		goto err;
  }

  if(!(lpCreateWords = GlobalLock(hCreateWord) ) 
     ||!(lpWordIndex = (LPWORDINDEX) GlobalLock(hWordIndex))
     )  {
        ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
		goto err;
  }

  hRule0= GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
          sizeof(RULE)*MAXCODELEN);
  if(!(lpRule = GlobalLock(hRule0)) )  {
        ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
		goto err;
  }

  if(ConvGetRule(hWnd,lpSrcFileName,&dwRuleOffset,&dwRuleLen,
               lpRule,&Descript) == -ERR_FILENOTOPEN)
       goto err;
  hSRCFile = Create_File(hWnd,lpSrcFileName,GENERIC_READ,OPEN_EXISTING);
  if (hSRCFile == (HANDLE)-1)
       goto err; 
  
  if(lstrcmpi(lpDestFile,lpSrcFileName)==0) {
	   bSameFile = TRUE;
       LoadString(NULL,IDS_OVERWRITE,szStr, sizeof(szStr)/sizeof(TCHAR));
       wsprintf(szDBCS,TEXT("\'%s\'\n%s"),lpSrcFileName,szStr); 
       if(!ErrMessage(hWnd, szDBCS))
	   {
           CloseHandle(hSRCFile);
           goto err; 
	   }
#ifdef UNICODE
       if(!_waccess(TEXT(TempFile),0))
#else
	   if(!_access(TEXT(TempFile),0))
#endif
           DeleteFile(TEXT(TempFile));
       hMBFile = Create_File(hWnd,TEXT(TempFile),GENERIC_WRITE|GENERIC_READ,CREATE_ALWAYS);
  }
  else 
       hMBFile = Create_File(hWnd,lpDestFile,GENERIC_WRITE|GENERIC_READ,CREATE_ALWAYS);
  if(hMBFile==(HANDLE)-1) {
       CloseHandle(hSRCFile);
       goto err; 
  }
  CloseHandle(hMBFile);

  DispInfo(hWnd,IDS_READTEXTINFO);
  SetFilePointer(hSRCFile,0,0,FILE_BEGIN);
  szStr[0] = 0;
  j = 0;

  SetCursor (LoadCursor (NULL, IDC_WAIT));


	SetDlgItemText (hWnd,TM_TOTALINFO,TEXT(""));
    LoadString(NULL,IDS_SORTWORDS,szStr,sizeof(szStr)/sizeof(TCHAR));
	SetDlgItemText (hWnd,TM_TOTAL,szStr);
	SetDlgItemInt (hWnd,TM_TOTALNUM,dwBaseWordNum,FALSE);
	hDlgItem=GetDlgItem(hWnd,TM_CONVNUM);
	InvalidateRect (hWnd,NULL,FALSE);


  while(ReadFile(hSRCFile,Buffer,MAXREADBUFFER,&dwReadBytes,NULL))
  {	
	 dwReadBytes = dwReadBytes/sizeof(TCHAR);
     for(i=0;i<(int)dwReadBytes;i++) {
      	if(Buffer[i] == 0x0d || Buffer[i] == 0xfeff) 
      	   continue;
      	if(Buffer[i] == TEXT('\n')) 
		{
		   szStr[j]=0;
		   j=0;
    	   if(lstrcmpi(szStr,TEXT(TextSeg))==0)  {
	           bReadText = TRUE;
//		       lstrcpy(szStr,"");
	           continue;
     	   }
    	   if(lstrcmpi(szStr,TEXT(RuleSeg))==0
    	      || lstrcmpi(szStr,TEXT(DescriptSeg))==0)  {
	           bReadText = FALSE;
//		  	   lstrcpy(szStr,"");
	           continue;
     	   }
     	  
		   if(bReadText) {
   	           trim(szStr);
	           if(lstrlen(szStr) != 0) {
                   nRet = SimpleSplit(hWnd,&nPages,szStr,lpCreateWords,lpWordIndex,Descript.wMaxCodes);	
                   if(nRet == 1)
                   {
                       lpWordIndex[dwBaseWordNum-1].dwOffset = dwOffset;
                       searchPos(lpWordIndex,dwBaseWordNum);  
		               

	                   if(dwBaseWordNum%100 == 0)
					   {
	                       SetDlgItemInt (hWnd,TM_TOTALNUM,dwBaseWordNum,FALSE);
			               InvalidateRect(hDlgItem,NULL,FALSE);
					   }

                   }
		  	   }
		   }
		   else
		       lstrcpy(szStr,TEXT(""));
		   continue;
		}
		else {
		   if(j == 0)
		       dwOffset = dwFstOffset + i*sizeof(TCHAR);
		   szStr[j]=Buffer[i];
		   j++; 
		}
	 } 
	 if(dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) 
	      break;
	 dwFstOffset += MAXREADBUFFER;
   };


  SetDlgItemInt (hWnd,TM_TOTALNUM,dwBaseWordNum,FALSE);
  InvalidateRect(hDlgItem,NULL,FALSE);



  if(bSameFile) {
      if(dwDesLen != 0)
          ConvSaveDescript(TEXT(TempFile),&Descript, 0,0);
      if(dwRuleLen != 0)
          ConvSaveRule(hWnd,TEXT(TempFile), dwDesLen, 0, 
              lpRule, Descript.wNumRules);
      hMBFile= Create_File(hWnd,TEXT(TempFile),GENERIC_READ|GENERIC_WRITE,OPEN_EXISTING);
  }
  else {
      if(dwDesLen != 0)
          ConvSaveDescript(lpDestFile,&Descript, 0,0);
      if(dwRuleLen != 0)
          ConvSaveRule(hWnd,lpDestFile, dwDesLen, 0, 
              lpRule, Descript.wNumRules);
      hMBFile= Create_File(hWnd,lpDestFile,GENERIC_READ|GENERIC_WRITE,OPEN_EXISTING);
  }

  SetCursor (LoadCursor (NULL, IDC_ARROW));
  if (hMBFile == (HANDLE)-1) {
      CloseHandle(hSRCFile);
      goto err; 
  }
  SetCursor (LoadCursor (NULL, IDC_WAIT));

  DispInfo(hWnd,IDS_WRITETEXTINFO);
  {
#ifdef UNICODE
      TCHAR cmbStr[] = {0x662F, 0x5426, 0x751F, 0x6210, 0x91CD, 0x7801, 0x8868, 0x0028, 0x0059, 0x002F, 0x004E, 0x0029, 0x003F, 0x0000};
#else
      BYTE cmbStr[] = "Ƿ(Y/N)?";
#endif //UNICODE
	  TCHAR cmbExt[] = TEXT(".CMB");
	  LPTSTR lpString;
	  TCHAR cmbFileName[MAX_PATH];

      IsGenCmb = ErrMessage(hWnd, cmbStr);
	  if(IsGenCmb)
      {
          lstrcpy(cmbFileName, lpSrcFileName);
		  if( (lpString = _tcsrchr(cmbFileName, TEXT('.'))) != NULL)
		      *lpString = 0;
		  lstrcat(cmbFileName, cmbExt);
          hCmbFile= Create_File(hWnd, cmbFileName, GENERIC_READ|GENERIC_WRITE, CREATE_ALWAYS);
		  if(hCmbFile == (HANDLE)-1)
		  {
               CloseHandle(hSRCFile);
               CloseHandle(hMBFile);
               goto err; 
		  }

	  }
  }

  SetCursor (LoadCursor (NULL, IDC_ARROW));

  WriteSortFile(hWnd,hSRCFile,hMBFile,lpWordIndex,lpCreateWords);

  GlobalUnlock(hCreateWord);
  GlobalFree(hCreateWord);
  GlobalFree(hWordIndex);

  SetCursor (LoadCursor (NULL, IDC_ARROW));

  if(hRule0)
      GlobalFree(hRule0);
  CloseHandle(hSRCFile);
  CloseHandle(hMBFile);
  if(hCmbFile > 0)
      CloseHandle(hCmbFile);
  if(bSameFile) {
      DeleteFile(lpSrcFileName);
      nRet = MoveFile(TEXT(TempFile),lpSrcFileName);
  }

  LoadString(NULL,IDS_SORTEND,szStr,sizeof(szStr));
#ifdef UNICODE
{
  TCHAR UniTmp[]={0x8BCD, 0x8BED, 0x6392, 0x5E8F, 0x0000};
  MessageBox(hWnd,szStr,UniTmp,MB_OK);
}
#else
  MessageBox(hWnd,szStr,"",MB_OK);
#endif
  return TRUE;

err:
  if(!_taccess(TEXT(TempFile),0))
      DeleteFile(TEXT(TempFile));
  if(hWordIndex)
      GlobalFree(hWordIndex);
  if(hCreateWord)
      GlobalFree(hCreateWord);
  if(hRule0)
      GlobalFree(hRule0);
  return FALSE;

}

/*****************************************************************************

  FUNCTION: ConvReConv(HANDLE hWnd,LPCSTR lpSrcFileName, LPCSTR lpszMBFileName)

  PURPOSE:  Processes MB reconversion .

  PARAMETERS:
    hWnd - window handle of the parent window.
	lpSrcFileName - pointer to source .mb file name.
	lpszMBFileName - pointer to destinate text  file name.
  
  RETURN VALUE:
    TRUE - reconversion completed
    FALSE - reconversion not completed

  HISTORY:
    05-21-95 Yehfew Tie  modifyed.
 ****************************************************************************/
BOOL ConvReConv(HANDLE hWnd,LPCTSTR lpSrcFileName,LPCTSTR lpMBFileName)
{
  DWORD         dwDesOffset,dwDesLen;
  HANDLE  		hRule0;

  MAINID        MainID;
  LPRULE       lpRule;
  DESCRIPTION   Descript;
  HANDLE		hReConvIndex;
  LPCREATEWORD  lpCreateWords, lpReConvIndex;
  MAININDEX     MainIndex[NUMTABLES];

  hMBFile = Create_File(hWnd,lpMBFileName,GENERIC_READ,OPEN_EXISTING);
  if (hMBFile == (HANDLE)-1) 
      return FALSE;
  DispInfo(hWnd,IDS_RECONVINFO);

  ConvGetMainID(hMBFile,&MainID);
  if(!ConvGetMainIndex(hWnd,hMBFile,MainIndex)) {
	  CloseHandle(hMBFile);
	  return FALSE;
  }

  hSRCFile = Create_File(hWnd,lpSrcFileName,
             GENERIC_READ|GENERIC_WRITE,CREATE_ALWAYS);
  if (hSRCFile == (HANDLE)-1)
	  return FALSE;		 
  CloseHandle(hSRCFile);
  ConvReadDescript(hMBFile,&Descript, MainIndex);
  ConvSaveDescript(lpSrcFileName,&Descript, 0,0);
  ConvGetDescript(hWnd,lpSrcFileName,&dwDesOffset,
           &dwDesLen,&Descript,FALSE);
  hCreateWord = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
	                 (DWORD)Descript.wMaxCodes*NUM_OF_ENCODE*sizeof(TCHAR));
  if(!hCreateWord ) {
      ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
	  return FALSE;
  }

  if(!(lpCreateWords = GlobalLock(hCreateWord)) ) {
      ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
	  return FALSE;
  }
  hReConvIndex = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                       (DWORD)Descript.wMaxCodes*NUM_OF_ENCODE*sizeof(TCHAR));
  if(!hReConvIndex ) {
      ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
	  CloseHandle(hMBFile);
	  GlobalFree(hCreateWord);
	  return FALSE;
  }

  if( !(lpReConvIndex = GlobalLock(hReConvIndex)) ) {
      ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
	  GlobalFree(hReConvIndex);
	  CloseHandle(hMBFile);
	  GlobalFree(hCreateWord);
	  return FALSE;
  }

  if(Descript.wNumRules != 0) {
      hRule0 = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                    sizeof(RULE)*Descript.wNumRules);
      if(!hRule0) {
          ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
    	  GlobalFree(hReConvIndex);
    	  CloseHandle(hMBFile);
    	  GlobalFree(hCreateWord);
    	  return FALSE;
      }
    
      if(!(lpRule = GlobalLock(hRule0)) )  {
          ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
    	  CloseHandle(hMBFile);
    	  GlobalFree(hCreateWord);
    	  GlobalFree(hRule0);
       	  GlobalFree(hReConvIndex);
    	  return FALSE;
      }
    
      ConvReadRule(hMBFile,Descript.wNumRules ,lpRule, MainIndex);
      ConvSaveRule(hWnd,lpSrcFileName, dwDesLen, 0, lpRule, Descript.wNumRules);
  }
  ConvGetCrtData(hMBFile, lpCreateWords, MainIndex);
  ConvGetReConvIndex(hMBFile, lpReConvIndex,MainIndex);

  hSRCFile = Create_File(hWnd,lpSrcFileName,
      GENERIC_READ|GENERIC_WRITE,OPEN_EXISTING);
  if (hSRCFile == (HANDLE)-1)
	  return FALSE;		 
  ConvWriteBaseWord(hWnd,hSRCFile,hMBFile,MainID,
      MainIndex[TAG_BASEDIC-1].dwOffset, lpCreateWords, lpReConvIndex,Descript.wMaxCodes);

  // DispInfo(hWnd,IDS_RECONVEND); bug#57932
  CloseHandle(hSRCFile);
  CloseHandle(hMBFile);
  GlobalFree(hCreateWord);
  GlobalFree(hReConvIndex);
  if(Descript.wNumRules != 0) 
      GlobalFree(hRule0);
  ProcessError(ERR_RECONVEND, hWnd, INFO);
  return TRUE;
}  

void ConvInit(LPDESCRIPTION lpDescript,
              LPMAINID lpMainID,
              LPMAININDEX lpMainIndex)
{ 

  DWORD dwTotal;
  int i;

//*** initializes struct MainID ***
  lstrcpy(lpMainID->szVersion,TEXT("95.01"));
  lpMainID->dwLanguageID = WIN95_PRC;
#ifdef UNICODE
  lpMainID->dwEncodeID = UNICODE_IME;
#else
  lpMainID->dwEncodeID = GBK_IME;
#endif
  lpMainID->dwNumTables = NUMTABLES;
  lpMainID->dwNumWords = dwBaseWordNum;
  lpMainID->dwFileFlag = 0;
  if(lpDescript->byMaxElement > 1 )
      lpMainID->dwFileFlag |= FFLG_MULTIELEMENT;
  if(lpDescript->wNumRules > 0)
      lpMainID->dwFileFlag |= FFLG_RULE;

//*** set tables tag ****
  lpMainIndex[TAG_DESCRIPTION-1].dwTag = TAG_DESCRIPTION;
  lpMainIndex[TAG_RULE-1].dwTag = TAG_RULE;
  lpMainIndex[TAG_ENCODE-1].dwTag = TAG_ENCODE;
  lpMainIndex[TAG_CRTWORDCODE-1].dwTag = TAG_CRTWORDCODE;
  lpMainIndex[TAG_RECONVINDEX-1].dwTag = TAG_RECONVINDEX;
  lpMainIndex[TAG_BASEDICINDEX-1].dwTag = TAG_BASEDICINDEX;
  lpMainIndex[TAG_BASEDIC-1].dwTag = TAG_BASEDIC;
  
//*** set tables length ****  
  lpMainIndex[TAG_DESCRIPTION-1].dwLength = sizeof(DESCRIPTION);
  lpMainIndex[TAG_RULE-1].dwLength= sizeof(RULE)* lpDescript->wNumRules;
  lpMainIndex[TAG_ENCODE-1].dwLength = 
         2*sizeof(DWORD) + NUMENCODEAREA*sizeof(ENCODEAREA);
  lpMainIndex[TAG_CRTWORDCODE-1].dwLength =
         (DWORD)NUM_OF_ENCODE*(DWORD)lpDescript->wMaxCodes*sizeof(TCHAR);
  lpMainIndex[TAG_RECONVINDEX-1].dwLength = 
         (DWORD)lpDescript->wMaxCodes*NUM_OF_ENCODE*sizeof(TCHAR);

  switch(lpMainID->dwFileFlag) {
      case FFLG_RULE|FFLG_SINGLEELEMENT:
               lpMainIndex[TAG_RECONVINDEX-1].dwLength = 0;
	       break;

	  case FFLG_RULE|FFLG_MULTIELEMENT:
	       break;

	  case FFLG_NORULE|FFLG_SINGLEELEMENT:
	  case FFLG_NORULE|FFLG_MULTIELEMENT:
               lpMainIndex[TAG_RULE-1].dwLength = 0;
               lpMainIndex[TAG_CRTWORDCODE-1].dwLength = 0;
		   break;

	  default:
	   	   break;
  }

  lpMainIndex[TAG_BASEDICINDEX-1].dwLength =( (DWORD)lpDescript->wNumCodes+1)*
           (DWORD)lpDescript->wNumCodes*sizeof(DWORD)*2+MAXNUMCODES+CODEMAPOFFSET;
  lpMainIndex[TAG_BASEDIC-1].dwLength = 0;

//***** set tables offset *****
  dwTotal = sizeof(MAINID) + sizeof(MAININDEX)*NUMTABLES;
  lpMainIndex[TAG_DESCRIPTION-1].dwOffset = dwTotal;

  dwTotal +=  lpMainIndex[TAG_DESCRIPTION-1].dwLength;
  lpMainIndex[TAG_RULE-1].dwOffset = dwTotal;

  dwTotal += lpMainIndex[TAG_RULE-1].dwLength;
  lpMainIndex[TAG_ENCODE-1].dwOffset = dwTotal;

  dwTotal += lpMainIndex[TAG_ENCODE-1].dwLength;
  lpMainIndex[TAG_CRTWORDCODE-1].dwOffset = dwTotal;

  dwTotal += lpMainIndex[TAG_CRTWORDCODE-1].dwLength;
  lpMainIndex[TAG_RECONVINDEX-1].dwOffset =  dwTotal;	

  dwTotal += lpMainIndex[TAG_RECONVINDEX-1].dwLength;
  lpMainIndex[TAG_BASEDICINDEX-1].dwOffset = dwTotal;

  dwTotal += lpMainIndex[TAG_BASEDICINDEX-1].dwLength;
  lpMainIndex[TAG_BASEDIC-1].dwOffset = dwTotal;

  for(i=0; i<NUMTABLES; i++)
      lpMainIndex[i].dwCheckSum = lpMainIndex[i].dwTag +
	                              lpMainIndex[i].dwLength +
								  lpMainIndex[i].dwOffset;
}	   

BOOL ReadSRCFile(HANDLE hWnd,
				 LPINT nPages,
                 HANDLE hFile,
                 LPCREATEWORD lpCreateWords,
                 LPWORDINDEX lpWordIndex,
                 LPINT dwWord, LPDESCRIPTION lpDescript,
                 LPRECONVINDEX lpReConvIndex)
{
   TCHAR szStr[256];
   TCHAR Buffer[MAXREADBUFFER];
   BOOL  bReadText=FALSE;
   register int i,j;
   int   nRet;
   DWORD dwReadBytes;
   DWORD dwFstOffset=0;
   DWORD dwOffset=0;

   SetCursor (LoadCursor (NULL, IDC_WAIT));
   SetFilePointer(hFile,0,0,FILE_BEGIN);
   szStr[0] = 0;
   j = 0;
   dwLineNo = 0;
   dwOffset = 0;
 
   memset(WriteCrtFlag, 0, (NUM_OF_ENCODE+7)/8);



   while(ReadFile(hFile,Buffer,MAXREADBUFFER,&dwReadBytes,NULL))
   {
	 dwReadBytes = dwReadBytes/sizeof(TCHAR);
     for(i=0;i<(int)dwReadBytes;i++) {
      	if(Buffer[i] == 0x0d || Buffer[i] == 0xfeff) continue;
      	if(Buffer[i] == TEXT('\n')) 
		{
		   dwLineNo ++;
		   szStr[j]=0;
		   j = 0;
    	   if(lstrcmpi(szStr,TEXT("[TEXT]"))==0)  {
	           bReadText = TRUE;
			   lstrcpy(szStr,TEXT(""));
	           continue;
     	   }
    	   if(lstrcmpi(szStr,TEXT(RuleSeg))==0
    	      || lstrcmpi(szStr,TEXT(DescriptSeg))==0)  {
	           bReadText = FALSE;
			   lstrcpy(szStr,TEXT(""));
	           continue;
     	   }
     
		   if(bReadText) {
   	           trim(szStr);
	           if(lstrlen(szStr) != 0) {
                   nRet = WordSplit(hWnd,nPages,szStr,lpCreateWords,lpWordIndex,
                             lpDescript,lpReConvIndex);	
                   if(nRet == 1)
                       lpWordIndex[dwBaseWordNum-1].dwOffset = dwOffset;
                   else if(!nRet) {
                       SetCursor (LoadCursor (NULL, IDC_ARROW));
			       return FALSE;
                   }
			   }
	  	   }
		   else
		       lstrcpy(szStr,TEXT(""));
		   continue;
		}
	  	else {
		    if(j == 0)
			    dwOffset = dwFstOffset + i*sizeof(TCHAR);
		    szStr[j]=Buffer[i];
		    j++; 
		}
	 }
	 if(dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) break;
	 dwFstOffset += MAXREADBUFFER;
   };

   SetCursor (LoadCursor (NULL, IDC_ARROW));
   if(dwBaseWordNum == 0) {
       ProcessError(ERR_TEXTSEG,hWnd,ERR);
       return FALSE;
   }
   else
       return TRUE;
}


BOOL ConvCalc(HANDLE hWnd,
			  HANDLE hMBFile,
              LPWORDINDEX lpWordIndex,
              LPMAININDEX lpMainIndex,
              LPDESCRIPTION lpDescript)
{
    DWORD        i,j,dwRecLen,dwOffset;
    BYTE         bySwap;
	TCHAR        Code[MAXNUMCODES],cc;
	DWORD        NumX,NumY,NumCodes,FstAdr,dwXStart,dwYStart,dwMaxXLen=0;
	HGLOBAL      hNumXYWords,hDicIndex;
	LPNUMXYWORDS lpNumXYWords;
	LPDICINDEX   lpDicIndex;
	BOOL		 bStart = FALSE;

	NumCodes=lpDescript->wNumCodes;
	hNumXYWords = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(DWORD)*((NumCodes+1)*NumCodes+1L));
	hDicIndex = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(DWORD)*(NumCodes+1)*NumCodes);
	if(!hNumXYWords || !hDicIndex) {
        ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
	    return FALSE;
	}

    if( !(lpNumXYWords = GlobalLock(hNumXYWords)) 
        ||!(lpDicIndex = GlobalLock(hDicIndex)) )  {
            ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
			GlobalFree(hNumXYWords);
			GlobalFree(hDicIndex);
	        return FALSE;
	}

    lstrcpy(Code,lpDescript->szUsedCode);
	FstAdr = lpMainIndex[TAG_BASEDIC-1].dwOffset;
	NumX=0;
	NumY=0;
	dwXStart=0;
	dwYStart=0;
	dwOffset=0;
    lpNumXYWords[0]=0;
    lpDicIndex[0]=0;
    for(i =0; i<dwBaseWordNum;i++) {
		bySwap =(BYTE) lstrlen(lpWordIndex[i].szCode);
		dwRecLen = (DWORD)bySwap*sizeof(TCHAR)+sizeof(TCHAR);
		bySwap =(BYTE) lpWordIndex[i].wDBCSLen;

        // if the DBCS str length is longer than 126, just get the first 126 characters.
        if ( bySwap >= 126 )
            bySwap = 126;

		dwRecLen += 2*(DWORD)bySwap+sizeof(TCHAR);
	    while( lpWordIndex[i].szCode[0] != Code[NumX] )
	    {
	    	
	    	if(!bStart && NumY == 0)
	    	{
	    	    lpNumXYWords[NumX*(NumCodes+1)+NumY+1] = i;
			    lpDicIndex[NumX*(NumCodes+1)+NumY+1] = dwOffset;
			}   

	    	while(NumY  < NumCodes-1 )
	    	{
				NumY ++;
	    	    lpNumXYWords[NumX*(NumCodes+1)+NumY+1] = i;
			    lpDicIndex[NumX*(NumCodes+1)+NumY+1] = dwOffset;
			}
	    	NumX ++;
			if(NumX >= NumCodes) break;
	    	lpNumXYWords[NumX*(NumCodes+1)] = i;
			lpDicIndex[NumX*(NumCodes+1)] = dwOffset;
	    	NumY = 0;
			bStart = FALSE;
		}
		if(NumX >= NumCodes) break;
        cc = lpWordIndex[i].szCode[1];
		if(!bStart && cc != 0 && NumY == 0)
		{
	       	lpNumXYWords[NumX*(NumCodes+1)+1] = i;
			lpDicIndex[NumX*(NumCodes+1)+1] = dwOffset;
			bStart = TRUE;
		}
		  
		while(bStart && cc != 0 && cc != Code[NumY] && NumY < NumCodes - 1 )
		{
			NumY ++;
	    	lpNumXYWords[NumX*(NumCodes+1)+NumY+1] = i;
			lpDicIndex[NumX*(NumCodes+1)+NumY+1] = dwOffset;
        }

		dwOffset += dwRecLen;
 	    if(i == dwBaseWordNum-1) {
		    j = NumX*(NumCodes+1) + NumY + 1;
	    	while(j  < (NumCodes+1)*NumCodes - 1 )
	    	{
				j ++;
	    	    lpNumXYWords[j] = i + 1;
			    lpDicIndex[j] = dwOffset;
			}
	        
	        lpNumXYWords[NumCodes*(NumCodes+1)] = i;
		}
	}

	for(i = 0; i < NumCodes	; i++)
	{    
	    for(j = 0; j < NumCodes + 1; j++)
		{
 		   if(j == 0)
 		   {
 		       lpNumXYWords[i*(NumCodes+1)] = lpNumXYWords[(i+1)*(NumCodes+1)] -
		 	       lpNumXYWords[i*(NumCodes+1)];
		   
		   }
		   else
		   {
		       lpNumXYWords[i*(NumCodes+1)+j] = lpNumXYWords[i*(NumCodes+1)+j+1] - 
				   lpNumXYWords[i*(NumCodes+1)+j];
			   lpDicIndex[i*(NumCodes+1)+j] = lpDicIndex[i*(NumCodes+1)+j] -
			       lpDicIndex[i*(NumCodes+1)];
		   }
		}
	}
	lpMainIndex[TAG_BASEDIC-1].dwLength = dwOffset;
	lpMainIndex[TAG_BASEDIC-1].dwCheckSum = TAG_BASEDIC +
	                                lpMainIndex[TAG_BASEDIC-1].dwOffset+
								    dwOffset;
	                                    
	for(i=0; i< NumCodes - 1;i++) {
	    dwRecLen = lpDicIndex[(i+1)*(NumCodes+1)]-lpDicIndex[(NumCodes+1)*i];
		dwMaxXLen = (dwRecLen>dwMaxXLen)? dwRecLen:dwMaxXLen;
	}
	
	dwRecLen =  dwOffset - lpDicIndex[(NumCodes+1)*(NumCodes-1)];
	dwMaxXLen = (dwRecLen>dwMaxXLen)? dwRecLen:dwMaxXLen;
		
	ConvWriteMainIndex(hMBFile,lpMainIndex);
    ConvWriteCodeIndex(hMBFile,&dwMaxXLen,lpDescript->szUsedCode,lpMainIndex);
	ConvWriteDicIndex(hMBFile,lpDicIndex,lpDescript->wNumCodes,lpMainIndex);
	ConvWriteNumXYWords(hMBFile,lpNumXYWords,
	                    lpDescript->wNumCodes,lpMainIndex);

	GlobalUnlock(hDicIndex);
	GlobalUnlock(hNumXYWords);
	GlobalFree(hDicIndex);
	GlobalFree(hNumXYWords);
    return TRUE;
}


BOOL WriteMBFile(HANDLE hWnd,
                 HANDLE hSRCFile,
                 HANDLE hMBFile,
                 LPWORDINDEX lpWordIndex,
                 LPMAININDEX lpMainIndex,
                 LPDESCRIPTION lpDescript)
{
    DWORD  i,dwBytes,NumCodes,FstAdr;
    WORD   bySwap;
	TCHAR  szStr[256];
	TCHAR  Code[MAXNUMCODES];
	DWORD  dwReadSum;
	HANDLE hDlgItem;

    SetCursor (LoadCursor (NULL, IDC_WAIT));   
	SetDlgItemText(hWnd,TM_TOTALINFO,TEXT(""));
    LoadString(NULL,IDS_TOTALINFO,szStr,sizeof(szStr)/sizeof(TCHAR));
	SetDlgItemText(hWnd,TM_TOTAL,szStr);
    LoadString(NULL,IDS_CONVWORDS,szStr,sizeof(szStr)/sizeof(TCHAR));
	SetDlgItemText(hWnd,TM_CONVINFO,szStr);
	SetDlgItemInt(hWnd,TM_TOTALNUM,dwBaseWordNum,FALSE);
	dwReadSum = 0;
	SetDlgItemInt(hWnd,TM_CONVNUM,dwReadSum,FALSE);
	InvalidateRect(hWnd,NULL,FALSE);

	NumCodes=lpDescript->wNumCodes;
    lstrncpy(Code,NumCodes,lpDescript->szUsedCode);
	FstAdr = lpMainIndex[TAG_BASEDIC-1].dwOffset;
	SetFilePointer(hMBFile,FstAdr,0, FILE_BEGIN);
    for(i =0; i<dwBaseWordNum;i++) {
	    SetFilePointer(hSRCFile,lpWordIndex[i].dwOffset,0,FILE_BEGIN);
		bySwap =(WORD) lpWordIndex[i].wDBCSLen;
		ReadFile(hSRCFile,szStr,2*(DWORD)bySwap,&dwBytes,NULL);
		bySwap =(WORD) lstrlen(lpWordIndex[i].szCode);
	    WriteFile(hMBFile,&bySwap,sizeof(TCHAR),&dwBytes,NULL);
	    WriteFile(hMBFile,&(lpWordIndex[i].szCode),bySwap*sizeof(TCHAR),&dwBytes,NULL);


		bySwap =(WORD) lpWordIndex[i].wDBCSLen;

        // if the DBCS str length is longer than 126, just get the first 126 characters.

        if ( bySwap >= 126 )
            bySwap = 126;

        WriteFile(hMBFile,&bySwap,sizeof(TCHAR),&dwBytes,NULL);
	    WriteFile(hMBFile,szStr,2*bySwap,&dwBytes,NULL);

		dwReadSum ++;
		if(dwReadSum%100 ==0 || dwReadSum == dwBaseWordNum) {
	         SetDlgItemInt(hWnd,TM_CONVNUM,dwReadSum,FALSE);
			 hDlgItem=GetDlgItem(hWnd,TM_CONVNUM);
			 InvalidateRect(hDlgItem,NULL,FALSE);
		}
	}

    SetCursor (LoadCursor (NULL, IDC_ARROW));   
    return TRUE;
}

BOOL WriteSortFile(HANDLE hWnd,
                   HANDLE hSRCFile,
                   HANDLE hDestFile,
                   LPWORDINDEX lpWordIndex,
				   LPCREATEWORD lpCreateWords)
{
    DWORD i, k, dwBytes;
	WORD  wRecLen;
	BYTE  bySwap;
	TCHAR szStr[512],szDBCS[512];
	TCHAR szCode[13],szCreate[13];
	BOOL  IsGenCmb = (hCmbFile)?TRUE:FALSE;  
	BOOL  bExistNext = FALSE; 
	DWORD dwReadSum;

	SetFilePointer(hDestFile,0,0, FILE_END);
	dwReadSum = 0;
    
    for(i =0; i<dwBaseWordNum;i++) {
	    SetFilePointer(hSRCFile,lpWordIndex[i].dwOffset,0,FILE_BEGIN);
		wRecLen = 2*lpWordIndex[i].wDBCSLen/sizeof(TCHAR);
		ReadFile(hSRCFile,szDBCS,wRecLen*sizeof(TCHAR),&dwBytes,NULL);
		szDBCS[wRecLen] = 0;
	    lstrcpy(szCode,lpWordIndex[i].szCode);
		bySwap =(BYTE)lstrlen(lpWordIndex[i].szCode);
		if(wRecLen == 2/sizeof(TCHAR)){
             k = EncodeToNo(szDBCS);
		   	 if((long)k>=0 && k < NUM_OF_ENCODE) {
		   	     lstrncpy(szCreate,MAXCODELEN,&lpCreateWords[k*MAXCODELEN]);
			     szCreate[MAXCODELEN]=0;
				 if(lstrlen(szCreate))
       		         wsprintf(szStr,TEXT("%s%s %s\r\n"),szDBCS,szCode,szCreate);
		         else
		             wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
			 }
		     else
		         wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
		}
		else
		     wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
	    WriteFile(hDestFile,szStr,lstrlen(szStr)*sizeof(TCHAR),&dwBytes,NULL);
		if(IsGenCmb)
		{
		    if(i != dwBaseWordNum - 1
		       && _wcsicmp(lpWordIndex[i].szCode, lpWordIndex[i+1].szCode) == 0)
			{
		        wsprintf(szStr,TEXT("%s%s\r\n"),szCode,szDBCS);
	            WriteFile(hCmbFile,szStr,lstrlen(szStr)*sizeof(TCHAR),&dwBytes,NULL);
				bExistNext = TRUE;
		        dwReadSum ++;
			}
			else
			{
			    if(bExistNext)
				{
		            wsprintf(szStr,TEXT("%s%s\r\n"),szCode,szDBCS);
	                WriteFile(hCmbFile,szStr,lstrlen(szStr)*sizeof(TCHAR),&dwBytes,NULL);
				}
				bExistNext = FALSE;
			}
		}
	}

    if(IsGenCmb)
	{
#ifdef UNICODE
	     TCHAR UniTmp[] = {0x5171, 0x8BA1, 0x91CD, 0x7801, 0x8BCD, 0x6761, 0x6570, 0x0000};
	     wsprintf(szStr,TEXT("%ws = %d\n"), UniTmp, dwReadSum);
#else
	     wsprintf(szStr," = %ld\n", dwReadSum);
#endif
	     WriteFile(hCmbFile,szStr,lstrlen(szStr)*sizeof(TCHAR),&dwBytes,NULL);
	}
	    
    return TRUE;
}


int  SimpleSplit(HANDLE hWnd,
			     LPINT nPages,
                 LPTSTR szStr,
                 LPCREATEWORD lpCreateWords,
                 LPWORDINDEX  lpWordIndex,
                 WORD  wMaxCodes)
{
   register int i=0;
   int   nDBCS=0,  nCodes=0, nCreate = 0;
   TCHAR szDBCS[512],szCode[13],szCreate[128];

   if(ParseDBCSstr(hWnd,szStr,szDBCS,szCode,szCreate,wMaxCodes) != TRUE)
   {
        if(lstrlen(szDBCS) == 0)
		{
             LoadString(NULL, IDS_NOTEXISTDBCS, szCreate, sizeof(szCreate)/sizeof(TCHAR));
             wsprintf(szDBCS,TEXT("\'%s%lu)"),szCreate,dwLineNo); 
             FatalMessage(hWnd,szDBCS);
		}
       return FALSE;
   }
   nDBCS = lstrlen(szDBCS);
   DelIllegalCode(szCode);
   nCodes = lstrlen(szCode);
   nCreate = lstrlen(szCreate);
   dwBaseWordNum ++;

   lpWordIndex[dwBaseWordNum-1].wDBCSLen =(WORD)(nDBCS*sizeof(TCHAR)/2);
   lstrcpy(lpWordIndex[dwBaseWordNum-1].szCode,szCode);
      
   if(nDBCS == 2/sizeof(TCHAR)) {
       i =  EncodeToNo(szDBCS);
	   if(i>=0 && i < NUM_OF_ENCODE) 
	   {
            if(nCreate != 0) 
                lstrncpy(lpCreateWords+i*MAXCODELEN,
                         MAXCODELEN, szCreate);
       }
   }
   return TRUE;
}

int  WordSplit(HANDLE hWnd,
			   LPINT nPages,
               LPTSTR szStr,
               LPCREATEWORD lpCreateWords,
               LPWORDINDEX  lpWordIndex,
               LPDESCRIPTION lpDescript,
               LPRECONVINDEX lpReConvIndex)
{
   int   i, nDBCS=0,  nCodes=0, nCreate = 0;
   TCHAR szTemp[512],szTmpStr[256];
   TCHAR szDBCS[512],szCode[13],szCreate[128];

   if(ParseDBCSstr(hWnd,szStr,szDBCS,szCode,szCreate,lpDescript->wMaxCodes) != TRUE)
   {
        if(lstrlen(szDBCS) == 0)
		{
             LoadString(NULL, IDS_NOTEXISTDBCS, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
             wsprintf(szTemp,TEXT("\'%s%lu)"),szTmpStr,dwLineNo); 
             FatalMessage(hWnd,szTemp);
		}
        return FALSE;
   }


   if (  lstrlen(szDBCS) > 126 ) {
       // if the string is longer than 126, the rest will be cut.
       // so show a message to end user.

       LoadString(NULL, IDS_DBCSTOOLONG, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
       {
	      TCHAR UniTmp[] = {0x0027, 0x0025, 0x0077, 0x0073, 0x0027, 0x0020, 0x0020, 
                            0x0020, 0x0028, 0x884C, 0x003A, 0x0025, 0x006C, 0x0075, 
                            0x0029, 0x0025, 0x0077, 0x0073, 0x000D, 0x000A, 0x000D,
                            0x000A, 0x9000, 0x51FA, 0x5426, 0x003F, 0x0020, 0x0000};

          wsprintf(szTemp, UniTmp, szDBCS,dwLineNo,szTmpStr); 
       }
#else
       wsprintf(szTemp,"\'%s\'%s(:%lu)\n˳? ",szDBCS,szTmpStr,dwLineNo); 
#endif 
       if (ErrMessage(hWnd,szTemp)) 
          return FALSE;
   }


   if(!CheckCodeLegal(hWnd,szDBCS,szCode,szCreate,lpDescript))
        return FALSE;
   nDBCS = lstrlen(szDBCS);
   nCodes = lstrlen(szCode);
   nCreate = lstrlen(szCreate);

   if(nDBCS == 0) 
        return -1;
     
   if(nDBCS == 2/sizeof(TCHAR))
   {
       i =  EncodeToNo(szDBCS);
       if(i < 0 || i >= NUM_OF_ENCODE) 
           return FALSE;
       if(nCodes == 0) {
           LoadString(NULL, IDS_CODEEMPTY, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
	   TCHAR UniTmp[] = {0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x0028, 0x884C, 0x003A, 0x0025, 0x006C, 0x0075, 0x0029, 0x005C, 0x006E, 0x9000, 0x51FA, 0x5426, 0x003F, 0x0020, 0x0000};
       wsprintf(szTemp, UniTmp, szDBCS,szTmpStr,dwLineNo); 
}
#else
           wsprintf(szTemp,"\'%s\'%s(:%lu)\n˳? ",szDBCS,szTmpStr,dwLineNo); 
#endif \\UNICODE
           if(ErrMessage(hWnd,szTemp)) 
              return FALSE;
	   }
       
//**** write create words
       if(lpDescript->wNumRules != 0 && nCreate != 0)
       {
           if(nCreate > lpDescript->wMaxCodes) {
                LoadString(NULL,IDS_DBCSCODE,szTmpStr,sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
		TCHAR UniTmp[] = {0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x0025, 0x0077, 0x0073, 0x005C, 0x0027, 0x0020, 0x0025, 0x0064, 0x0021, 0x0028, 0x884C, 0x003A, 0x0025, 0x006C, 0x0075, 0x0029, 0x005C, 0x006E, 0x9000, 0x51FA, 0x5426, 0x003F, 0x0000};
                wsprintf(szTemp,UniTmp, szDBCS,szTmpStr,
		                 lpDescript->byMaxElement,dwLineNo); 
}
#else
                wsprintf(szTemp,"\'%s%s\' %d!(:%lu)\n˳?", szDBCS,szTmpStr,
		                 lpDescript->byMaxElement,dwLineNo); 
#endif \\UNICODE
                if( ErrMessage(hWnd,szTemp))
                     return FALSE;
           }
           lstrncpy(szTmpStr,lpDescript->wMaxCodes,
                    lpCreateWords+i*(DWORD)lpDescript->wMaxCodes);
	 	   szTmpStr[lpDescript->wMaxCodes] = 0;
		   if(!(WriteCrtFlag[i/8] & (1 << (7 - (i%8))) ) )
                lstrncpy(lpCreateWords+i*(DWORD)lpDescript->wMaxCodes,
                         lpDescript->wMaxCodes,
                         szCreate);
		   WriteCrtFlag[i/8] |= (1 << (7 - (i%8)) );
	   }
    
   }     
   else if(nDBCS>2*sizeof(TCHAR) && nCodes==0 && lpDescript->wNumRules==0)
    {
       LoadString(NULL,IDS_CODEEMPTY,szTmpStr,sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
       TCHAR UniTmp[] = {0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x0028, 0x884C, 0x003A, 0x0025, 0x006C, 0x0064, 0x0029, 0x0000};
       wsprintf(szTemp,UniTmp, szDBCS,szTmpStr,dwLineNo); 
}
#else
       wsprintf(szTemp,"\'%s\'%s(:%ld)", szDBCS,szTmpStr,dwLineNo); 
#endif
       WarnMessage(hWnd,szTemp);
	   return FALSE;
   }
   

   dwBaseWordNum ++;
   if(dwBaseWordNum >(DWORD)(*nPages)*GMEM_PAGESIZE) {
       GlobalUnlock(hWordIndex);
       hWordIndex = IndexReAlloc(hWordIndex,nPages);
	   if(!hWordIndex) {
            ProcessError(ERR_OUTOFMEMORY,hWnd,ERR);
            return FALSE;
	   }
	   lpWordIndex = (LPWORDINDEX) GlobalLock(hWordIndex);
  	   if( !lpWordIndex )  {
            ProcessError(ERR_GLOBALLOCK,hWnd,ERR);
	        return FALSE;
	   }
   }

   lpWordIndex[dwBaseWordNum-1].wDBCSLen =(WORD)(nDBCS*sizeof(TCHAR)/2);
   lstrcpy(lpWordIndex[dwBaseWordNum-1].szCode,szCode);

   ConvReconvIndex(hWnd,szDBCS,lpCreateWords,lpWordIndex[dwBaseWordNum-1],lpDescript,lpReConvIndex); 
      
   return TRUE;
}


BOOL ConvWriteBaseWord  (HANDLE hWnd, 
                         HANDLE hSRCFile,
                         HANDLE hMBFile, 
						 MAINID MainID,
                         DWORD dwOffset, 
                         LPCREATEWORD lpCreateWords, 
						 LPRECONVINDEX lpReConvIndex,
                         DWORD MaxCodes)
{
  TCHAR  szCode[13],szCreate[13],szDBCS[512],szReCode[13];
  TCHAR  szStr[512];
  static TCHAR  ReadBuf[MAXREADBUFFER];
  static TCHAR  WriteBuf[2*MAXREADBUFFER];
  DWORD  dwReadBytes,dwRecLen,i,j,k,dwReadWords=0;
  DWORD  dwFileFlag = MainID.dwFileFlag;
  DWORD  dwNumWords = MainID.dwNumWords;
  DWORD  dwReadSum;
  HWND   hDlgItem;

  SetFilePointer(hMBFile,dwOffset,0,FILE_BEGIN);
  SetFilePointer(hSRCFile,0,0,FILE_END);

  SetDlgItemText(hWnd,TM_TOTALINFO,TEXT(""));
  LoadString(NULL,IDS_TOTALINFO,szStr,sizeof(szStr)/sizeof(TCHAR));
  SetDlgItemText(hWnd,TM_TOTAL,szStr);
  LoadString(NULL,IDS_RECONVWORDS,szStr,sizeof(szStr)/sizeof(TCHAR));
  SetDlgItemText(hWnd,TM_CONVINFO,szStr);
  SetDlgItemInt(hWnd,TM_TOTALNUM,dwNumWords,FALSE);
  dwReadSum = 0;
  SetDlgItemInt(hWnd,TM_CONVNUM,dwReadSum,FALSE);
  InvalidateRect(hWnd,NULL,FALSE);
  
  i=0;
  do {
      ReadFile(hMBFile,ReadBuf,sizeof(ReadBuf),&dwReadBytes,NULL);
	  i=0;
	  if(dwReadBytes == 0 ) break;
	  WriteBuf[0]=0;
	  dwReadBytes = dwReadBytes/sizeof(TCHAR);
	  while( i < dwReadBytes-1 ) {
	     j = (DWORD)ReadBuf[i]+1;
		 dwRecLen = j+(DWORD)ReadBuf[i+j]*2/sizeof(TCHAR)+1;
		 if( (dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) ||
		      ((i+j) < (dwReadBytes-1) && (i+dwRecLen) < (dwReadBytes-1) ) )  {
	        lstrncpy(szCode,ReadBuf[i],&ReadBuf[i+1]);
			szCode[ReadBuf[i]] = 0;
			lstrncpy(szDBCS,ReadBuf[i+j]*2/sizeof(TCHAR),&ReadBuf[i+j+1]);
			szDBCS[ReadBuf[i+j]*2/sizeof(TCHAR)] = 0;
			if(ReadBuf[i+j]==1 
			   &&(dwFileFlag&FFLG_RULE)) {
                k =  EncodeToNo(szDBCS);
				if((long)k>=0 && k < NUM_OF_ENCODE) {
			   	    lstrncpy(szCreate,MaxCodes,&lpCreateWords[k*MaxCodes]);
			   	    lstrncpy(szReCode,MaxCodes,&lpReConvIndex[k*MaxCodes]);
				    szCreate[MaxCodes]=0;
				    szReCode[MaxCodes]=0;
					if(lstrlen(szCreate) != 0 && lstrcmpi(szCreate,szCode) != 0)
       			       wsprintf(szStr,TEXT("%s%s %s\r\n"),szDBCS,szCode,szCreate);
				    else
			           wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
				}
				else
			        wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
			}
			else
			    wsprintf(szStr,TEXT("%s%s\r\n"),szDBCS,szCode);
			lstrcat(WriteBuf,szStr);
			dwReadWords ++;
			dwReadSum = dwReadWords;
			if(dwReadSum%100 ==0 || dwReadSum == dwNumWords) {
  	            SetDlgItemInt(hWnd,TM_CONVNUM,dwReadSum,FALSE);
				hDlgItem=GetDlgItem(hWnd,TM_CONVNUM);
				InvalidateRect(hDlgItem,NULL,FALSE);
			}
	        i += dwRecLen;
		}
	    else {
		    SetFilePointer(hMBFile,(i-dwReadBytes)*sizeof(TCHAR),0,FILE_CURRENT);
	       	break;
		}
	 }
	 WriteFile(hSRCFile,WriteBuf,lstrlen(WriteBuf)*sizeof(TCHAR),&k,NULL);
  }while (dwReadBytes == MAXREADBUFFER) ;
  return TRUE;
}


BOOL ConvBatCreate (HANDLE  hWnd,
                    DESCRIPTION   Descript,
                    LPRULE  lpRule,
					LPCREATEWORD lpCreateWord,
                    LPTSTR   szWordStr, 
                    LPTSTR   lpCode)
{
   int   nWordLen=lstrlen(szWordStr)*sizeof(TCHAR)/2;
   DWORD i,j,k,dwCodeLen;
   DWORD dwNumRules = Descript.wNumRules;
   WORD  wMaxCodes = Descript.wMaxCodes;
   TCHAR szDBCS[3],szCode[MAXCODELEN+1];
   BOOL  bReturn = FALSE;

   lpCode[0] = 0;
   if(dwNumRules == 0) {
       ProcessError(ERR_NORULE,hWnd,ERR);
       return FALSE;
   }
   for(i=0; i<dwNumRules; i++) 
	 if( (lpRule[i].byLogicOpra == 0 && nWordLen == lpRule[i].byLength) 
	   ||(lpRule[i].byLogicOpra == 1 && nWordLen >= lpRule[i].byLength)
	   ||(lpRule[i].byLogicOpra == 2 && nWordLen <= lpRule[i].byLength) ) {

  	   int retCodeLen = 0; 
  	   for(j=0; j<lpRule[i].wNumCodeUnits; j++) {
		   k = lpRule[i].CodeUnit[j].wDBCSPosition;
		   if(k > (DWORD)nWordLen) k = (DWORD)nWordLen;   
           if(lpRule[i].CodeUnit[j].dwDirectMode == 0) 
		       lstrncpy(szDBCS,2,&szWordStr[2*(k-1)]);
		   else 
		       lstrncpy(szDBCS,2,&szWordStr[2*(nWordLen-k)]);
	 	   szDBCS[2] = 0;
           k = EncodeToNo(szDBCS);
 		   if((long)k>=0 && k< NUM_OF_ENCODE ) 
 		   {   
 		       lstrncpy(szCode,wMaxCodes,&lpCreateWord[wMaxCodes*k]);
		       szCode[wMaxCodes] = 0;
		       dwCodeLen = lstrlen(szCode);
		       k = lpRule[i].CodeUnit[j].wCodePosition;
 		       if(k == 0) 
			   {
			       if(retCodeLen + dwCodeLen > Descript.wMaxCodes)
			     	    szCode[Descript.wMaxCodes - retCodeLen] = 0;
			       lstrcat(lpCode,szCode);
			   }
 		       else
 		       {
 		           if(k > dwCodeLen) k = dwCodeLen;   
 		           lpCode[j] = (szCode[k-1] == 0)?((k > 1)? szCode[k-2]:Descript.szUsedCode[0]):szCode[k-1];
			   }
		   }
		   else 
		       lpCode[j] = (j > 0)?lpCode[j-1]:Descript.szUsedCode[0];
		   retCodeLen = lstrlen(lpCode);
	   }
	   bReturn = TRUE;
	   break;
	}

	if(!bReturn) 
	    ProcessError(ERR_NOTDEFRULE,hWnd,ERR);
	lpCode[wMaxCodes] = 0;
	return bReturn;
}



BOOL  searchPos(LPWORDINDEX lpWordIndex, DWORD dwNumWords)
{
    DWORD i, retPos;
    WORDINDEX InsWordIndex = lpWordIndex[dwNumWords-1];
    if(dwNumWords == 1)
        return TRUE;
    retPos = bSearch(lpWordIndex, 0, dwNumWords-2, InsWordIndex);
    if(retPos == dwNumWords - 1)
	    return TRUE;
	memmove(&lpWordIndex[retPos+1], &lpWordIndex[retPos],
	     sizeof(WORDINDEX)*(dwNumWords - 1 - retPos) );
    lpWordIndex[retPos] = InsWordIndex;
    return TRUE;
}

DWORD bSearch(LPWORDINDEX lpWordIndex,  DWORD left, DWORD right, WORDINDEX InsWordIndex)
{
    WORDINDEX MidWordIndex;
    DWORD mid;

    if(left > right)
        return left;
    mid = (left + right)/2;

    MidWordIndex = lpWordIndex[mid];
    if(_wcsicmp(MidWordIndex.szCode, InsWordIndex.szCode) <= 0)
    {
        if(mid ==  right || _wcsicmp(lpWordIndex[mid+1].szCode, InsWordIndex.szCode) > 0) 
            return mid+1;
	    else
            return bSearch(lpWordIndex, mid+1, right, InsWordIndex);
    }	 
    else 
	{
        if(mid ==  left || _wcsicmp(lpWordIndex[mid-1].szCode, InsWordIndex.szCode) <= 0) 
            return mid;
	    else
//            return bSearch(lpWordIndex, left, mid, InsWordIndex);
            return bSearch(lpWordIndex, left, mid-1, InsWordIndex);
	}

    return 0;
}
//***** end 95.10.17
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\basefunc.c ===
/*************************************************
 *  basefunc.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <string.h>
#include <winbase.h>
#include <commdlg.h>
#include "conv.h"
#include "propshet.h"

#define MAX_VALUE_NAME 256
#ifdef UNICODE
TCHAR szCaption[] = {0x8F93, 0x5165, 0x6CD5, 0x751F, 0x6210, 0x5668, 0x0000};
#else
BYTE szCaption[] = "뷨"
#endif

/**** delete all spaces of string *****/
void DelSpace(LPTSTR szStr)
{
    TCHAR szStr1[512];
    int len,count=0;
    register int i=0;

    len = lstrlen(szStr);
    do  {
       if(szStr[i] == 32||szStr[i] == TEXT('\t')) continue;
           szStr1[count] = szStr[i];
           if(szStr1[count] >= TEXT('A') && szStr1[count] <= TEXT('Z'))
               szStr1[count] |= 0x20;
           count ++;
        } while(i++<len);
    szStr1[count] = 0;
    lstrcpy(szStr,szStr1);
}


//***** start 
int GetEntryString(LPTSTR szSrcStr,
                         LPTSTR szEntryName,
                         LPTSTR szDefaultStr,
             LPTSTR szGetStr,
             DWORD dwLength
            )
{
    LPTSTR lpStr;
    TCHAR  szName[256];

    GetEntryName(szSrcStr, szName);
        lpStr = _tcschr(szSrcStr,TEXT('='));

        if(lpStr == NULL)
        {
            lstrcpy(szGetStr, szDefaultStr);
                return TRUE;
    }
    else if(lstrcmpi(szEntryName, szName) != 0) 
        {    
            lstrcpy(szGetStr, szDefaultStr);
                return FALSE;
        }
        else
        {
            lstrcpy(szGetStr, lpStr+1);
                return TRUE;
        }
}

int GetEntryInt(LPTSTR szSrcStr,
                         LPTSTR szEntryName,
                         int   nDefault,
                         LPINT fnPrivateInt 
            )
{
    LPTSTR lpStr;
    TCHAR  szName[256];

    GetEntryName(szSrcStr, szName);
        lpStr = _tcschr(szSrcStr,TEXT('='));

        if(lpStr == NULL)
        {
            *fnPrivateInt = nDefault;
        return TRUE;
    }
    else if( lstrcmpi(szEntryName, szName) != 0) 
        {
            *fnPrivateInt = nDefault;
        return FALSE;
    }
        else
        {   
            lstrcpy(szName, lpStr+1);
            *fnPrivateInt = _ttoi(szName);
        return TRUE;
    }
}

void GetEntryName(LPTSTR szSrcStr, LPTSTR szEntryName)
{
    LPTSTR lpStr;

        lstrcpy(szEntryName,szSrcStr);
    if((lpStr = _tcschr(szEntryName,TEXT('='))) == NULL) 
        szEntryName[0] = 0;
        else
            *lpStr = 0;
}

//***** end 95.10.11

BOOL ParseDBCSstr(HWND hWnd,
               TCHAR *szInputStr,
               LPTSTR szDBCS, 
               LPTSTR szCodeStr, 
               LPTSTR szCreateStr,
               WORD  wMaxCodes)
{
    int   i, len, nDBCS = 0, nCodes = 0;  
        TCHAR szStr[512], szTmpStr[256];
 
#ifdef UNICODE
    len = lstrlen(szInputStr);
    for(i=0; i<len-1; i++) {
       if(szInputStr[i] > 0x100)
           nDBCS++;
           else 
               break;
    }
#else   
    len = lstrlen(szInputStr);
    for(i=0; i<len-1; i+= 2) {
       if( ((UCHAR)szInputStr[i] < 0 || (UCHAR)szInputStr[i] > (UCHAR)0x80) && 
          ((UCHAR)szInputStr[i+1] >= 0x40 && (UCHAR)szInputStr[i+1] <= (UCHAR)0xfe &&
                  (UCHAR)szInputStr[i+1] != (UCHAR)0x7f) )
           nDBCS += 2;
           else 
               break;
    }
#endif

    if(nDBCS == 0) 
        {
/*        LoadString(NULL, IDS_NOTEXISTDBCS, szTmpStr, sizeof(szTmpStr));
        wsprintf(szStr,"\'%s%lu)",szTmpStr,dwLineNo); 
        FatalMessage(hWnd,szStr);*/
        return -1;
        }
    lstrncpy(szDBCS,nDBCS,szInputStr);
        szDBCS[nDBCS] = 0;

    lstrcpy(szStr,&szInputStr[nDBCS]);
        trim(szStr);
        len = lstrlen(szStr);
    if(len > 0)
    {
        for(i = 0; i<len; i++)
            {
           if((int)szStr[i] == 32 || szStr[i] == TEXT('\t'))
                   break;
               nCodes++; 
        }
        }
        else
            nCodes = 0;
    if(nCodes > wMaxCodes)       {
                LoadString(NULL, IDS_DBCSCODELEN, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
        TCHAR UniTmp[] = {0x884C, 0x0000};
        wsprintf(szStr, TEXT("\'%ws\'%ws%d!(%ws:%lu)"), 
            szDBCS,szTmpStr,wMaxCodes,UniTmp,dwLineNo); 
}
#else
        wsprintf(szStr,"\'%s\'%s%d!(:%lu)", 
            szDBCS,szTmpStr,wMaxCodes,dwLineNo); 
#endif
        FatalMessage(hWnd,szStr);
        return FALSE;
                //szStr[wMaxCodes] = 0;
    }

    lstrncpy(szCodeStr,nCodes, szStr);
        szCodeStr[nCodes] = 0;
        DelSpace(szCodeStr);
    lstrcpy(szCreateStr,&szStr[nCodes]);
        szCreateStr[MAXCODELEN] = 0;
    DelSpace(szCreateStr);
        return TRUE;

}

/**** delete spaces of string's  head and tail  *****/
void trim(LPTSTR szStr)
{
    register int  i=0;
    UINT len ;

    while(szStr[i] == 32 || szStr[i] == TEXT('\t')) 
         i++;
    lstrcpy(szStr,&szStr[i]);
    len = lstrlen(szStr);
    if(len == 0) return;
    i = 1;
    while(szStr[len-i] == 32 
         || szStr[len-i] == TEXT('\r')
         || szStr[len-i] == TEXT('\n')
                 || szStr[len-i] == TEXT('\t')
         || szStr[len-i] == 0) 
            i++;
    szStr[len-i+1] = 0;
    len = lstrlen(szStr);
    for(i=0; i<(int)len; i++)
        {
            if(szStr[i] > 0x100)
                    continue;
            if(szStr[i] >= TEXT('A') && szStr[i] <= TEXT('Z'))
                szStr[i] |= 0x20;
        }
}

void fnsplit(LPCTSTR szFullPath, LPTSTR szFileName)
{
    LPTSTR lpString;

#ifdef UNICODE
    if((lpString=wcsrchr(szFullPath,TEXT('\\')))!=NULL)
#else
    if((lpString=strrchr(szFullPath,TEXT('\\')))!=NULL)
#endif
        lstrcpy(szFileName,lpString+1);
    else
        lstrcpy(szFileName,szFullPath);
}
   
BOOL ErrMessage(HANDLE hWnd,LPTSTR lpText)
{
   int RetValue;

   RetValue =  MessageBox(hWnd,
                          lpText,
                          szCaption,
                          MB_ICONEXCLAMATION|MB_YESNO|MB_DEFBUTTON2);
   if(RetValue == IDYES) 
         return TRUE;
   else
                 return FALSE;
}

VOID WarnMessage(HANDLE hWnd,LPTSTR lpText)
{
   MessageBox(hWnd,lpText,szCaption,MB_ICONEXCLAMATION|MB_OK);
}

VOID InfoMessage(HANDLE hWnd,LPTSTR lpText)
{
   MessageBox(hWnd,lpText,szCaption,MB_ICONINFORMATION|MB_OK);
}

VOID FatalMessage(HANDLE hWnd,LPTSTR lpText)
{
   MessageBox(hWnd,lpText,szCaption,MB_ICONSTOP|MB_OK);
}

void lstrncpy(LPTSTR lpDest,int nCount,LPTSTR lpSrc)
{
  register int i;
  BOOL bEnd = FALSE;
  
  for(i=0; i<nCount; i++) {
       if(lpSrc[i] == 0)   
            bEnd = TRUE;
           if(bEnd)
                lpDest[i] = 0;
           else
                lpDest[i] =     lpSrc[i];
  }

}
               
               
void lstrncpy0(LPTSTR lpDest,int nCount,LPTSTR lpSrc)
{
  register int i;
  BOOL bEnd = FALSE;
  
  for(i=0; i<nCount; i++) 
                lpDest[i] =     lpSrc[i];

}
               
               


/**************************************************************************
 * HANDLE CreateMapFile(HANDLE hWnd,char *MapFileName)
 *
 * Purpose: Create a Map file to map named share memory
 *
 * Inputs:  hWnd - parent window's handle
 *          *MapFileName - pointer to map file name
 *
 * Returns: MapFileHandle - a handle to the file
 *                        or NULL if failure
 *
 * Calls:   CreateFile, ErrorOut
 *
 * History:
 * 
 *
\**************************************************************************/
HANDLE CreateMapFile(HANDLE hWnd,TCHAR *MapFileName)
{
HANDLE MapFileHandle;

MapFileHandle= CreateFile(MapFileName,
                          GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL /* | STANDARD_RIGHTS_REQUIRED |
                          FILE_MAP_WRITE | FILE_MAP_READ */,
                          NULL);

if (MapFileHandle == (HANDLE)-1)
  {
  ErrorOut(hWnd,TEXT("CreateFile"));
  return(NULL);
  }
else
  return(MapFileHandle);

}

/**************************************************************************
 * HANDLE CreateMap(HANDLE hWnd,HANDLE *FileToBeMapped, char MapName[128] )
 *
 * Purpose: Create File Mapping object using the open file handle
 *
 * Inputs:  hWnd - parent window's handle
 *          *FileToBeMapped - pointer to the file handle
 *
 * Returns: MapHandle - handle to the file mapping object
 *                    or NULL if failure
 *
 * Calls:   CreateFileMapping, ErrorOut
 *
 * History:
 * 
 *
\**************************************************************************/

HANDLE CreateMap(HANDLE hWnd,HANDLE *FileToBeMapped, TCHAR MapName[128])
{
HANDLE MapHandle;

MapHandle= CreateFileMapping(*FileToBeMapped,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             4096,
                             MapName);

if (MapHandle == NULL)
  {
  ErrorOut(hWnd,TEXT("CreateFileMapping"));
  return(NULL);
  }
else
  return(MapHandle);

}


/**************************************************************************
 * LPVOID MapView(HANDLE *hMap)
 *
 * Purpose: Map the file mapping object into address space
 *
 * Inputs:  *hMap - pointer to the mapping object
 *
 * Returns: MappedPointer - pointer to the address space that the
 *                        object is mapped into
 *                        or NULL if failure
 *
 * Calls:   MapViewOfFile, ErrorOut
 *
 * History:
 * 
 *
\**************************************************************************/

LPVOID MapView(HANDLE hWnd,HANDLE *hMap)
{
LPVOID MappedPointer;

MappedPointer= MapViewOfFile(*hMap,
                             FILE_MAP_WRITE | FILE_MAP_READ,
                             0,
                             0,
                             4096);
if (MappedPointer == NULL)
  {
  ErrorOut(hWnd,TEXT("MapViewOfFile"));
  return(NULL);
  }
else
  return(MappedPointer);

}


/************************************************************************
 * void ErrorOut(HANDLE ghwndMain,char errstring[128])
 *
 * Purpose: Print out an meainful error code by means of
 *        GetLastError and printf
 *
 * Inputs:  ghwndMain - WinMain's HANDLE
 *          errstring - the action that failed, passed by the
 *                    calling proc.
 *
 * Returns: none
 *
 * Calls:   GetLastError
 *
 * History:
 * 
 *
\************************************************************************/


void ErrorOut(HANDLE ghwndMain,TCHAR errstring[128])
{
  DWORD Error;
  TCHAR  str[80];

  Error= GetLastError();
  wsprintf((LPTSTR) str, TEXT("Error on %s = %d\n"), errstring, Error);
  MessageBox(ghwndMain, (LPTSTR)str, TEXT("Error"), MB_OK);
}

/*************************************************************************
 * HANDLE OpenMap(HANDLE hWnd,char MapName[128])
 *
 * Purpose: Open the mapping object pointed to by MapName
 *
 * Inputs:  hWnd - parent window's handle
 *          * MapName - pointer to map file name 
 *
 * Returns: handle to mapped object or NULL if failure
 *
 * Calls: OpenFileMapping, ErrorOut
 *
 * History:
 * 
 *
\*************************************************************************/

HANDLE OpenMap(HANDLE hWnd,TCHAR MapName[128])
{
HANDLE hAMap;

hAMap= OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE,
                       TRUE,
                       MapName);

if (hAMap == NULL)
  {
  ErrorOut(hWnd,TEXT("OpenFileMapping"));
  return(NULL);
  }
else
  return(hAMap);

}


/*************************************************************************
 * HANDLE Create_File(HANDLE hWnd,
                   LPSTR lpFileName,
                   DWORD fdwAccess,
                   DWORD fdwCreate)
 *
 * Purpose: Open the object pointed to by lpFileName
 *
 * Inputs:  hWnd - parent window's handle
 *          lpFileName - pointer to file name 
 *                      fdwAccess - access(read-write)mode
 *                      fdwCreate - how to create
 *
 * Returns: handle to object or NULL if failure
 *
 * History:
 * 
 *
\*************************************************************************/
HANDLE Create_File(HANDLE hWnd,
                   LPTSTR lpFileName,
                   DWORD fdwAccess,
                   DWORD fdwCreate)
{
  HANDLE hFile;
  TCHAR  szStr[256],szStr1[256];
  int    RetValue;

  RetValue=CREATE_ALWAYS;
  if(fdwCreate == CREATE_ALWAYS) {
       if(_taccess(lpFileName,0)==0) {
           LoadString(NULL,IDS_OVERWRITE,szStr, sizeof(szStr)/sizeof(TCHAR));
           wsprintf(szStr1,TEXT("\'%s\' %s"),lpFileName,szStr); 
                   RetValue =  MessageBox(hWnd,
                                  szStr1,
                                  szCaption,
                                  MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2);
           if(RetValue != IDYES) 
                        //*if(!SaveFileAs(hWnd,lpFileName))
                    return (HANDLE)-1;
           }
  }    
  else if(fdwCreate == OPEN_EXISTING)
  {
       if(_taccess(lpFileName,0)) {
           /*LoadString(NULL,IDS_FILENOTEXIST,szStr, sizeof(szStr));
           wsprintf(szStr1,"\'%s\' %s",lpFileName,szStr); 
                   WarnMessage(hWnd,szStr1);*/
               return (HANDLE)-1;
           }
  }
  hFile = CreateFile(lpFileName,fdwAccess,FILE_SHARE_READ,NULL,
          fdwCreate,0,NULL);
  if (hFile == (HANDLE)-1) { 
        LoadString(NULL,IDS_FILEOPEN,szStr, sizeof(szStr)/sizeof(TCHAR));
        wsprintf(szStr1,TEXT("\'%s\' %s\n"),lpFileName,szStr); 
        FatalMessage(hWnd,szStr1);
  }
  return hFile;
}

BOOL SaveFileAs(HWND hwnd, LPTSTR szFilename) {
    OPENFILENAME ofn;
    TCHAR szFile[256], szFileTitle[256];
    static TCHAR *szFilter;

//    szFilter = "ļ(*.*)\0\0";
    szFilter = TEXT("All files (*.*)\0\0");
    lstrcpy(szFile, TEXT("*.*\0"));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 0L;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = sizeof(szFile)/sizeof(TCHAR);
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = sizeof(szFileTitle)/sizeof(TCHAR);
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = TEXT("Save file As");
    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = (LPTSTR)NULL;

    if (!GetSaveFileName(&ofn)) 
        return 0L;

        return 1L;
}



/****************************************************************************
*
*    FUNCTION: ProcessCDError(DWORD)
*
*    PURPOSE:  Processes errors from the conversion functions.
*
*    COMMENTS:
*
*        This function is  called  whenever  a conversion  function
*        fails.  The string is loaded and displayed for the user.
*
*    RETURN VALUES:
*        void.
*
*    HISTORY:
*        03-04-95 Yehfew Tie  Created.
*
****************************************************************************/
void ProcessError(DWORD dwErrorCode, HWND hWnd,DWORD ErrorLevel)
{
   WORD  wStringID;
   TCHAR  buf[256];

   switch(dwErrorCode)
      {
         case ERR_MBNAME:               wStringID=IDS_MBNAME;          break;
         case ERR_FILENOTEXIST:         wStringID=IDS_FILENOTEXIST;    break;
         case ERR_FILENOTOPEN:          wStringID=IDS_FILEOPEN;        break;
         case ERR_OUTOFMEMORY:          wStringID=IDS_MEMORY;          break;
                 case ERR_GLOBALLOCK:           wStringID=IDS_GLOBALLOCK;          break;
         case ERR_IMEUSE:               wStringID=IDS_IMEUSE;          break;

         case ERR_MAXCODES:             wStringID=IDS_MAXCODES;        break;
         case ERR_ELEMENT:              wStringID=IDS_ELEMENT;         break;
         case ERR_USEDCODE:             wStringID=IDS_USEDCODE;        break;
         case ERR_WILDCHAR:             wStringID=IDS_WILDCHAR;        break;
                 case ERR_RULEHEADER:                   wStringID=IDS_RULEHEAD;        break;
         case ERR_RULELOGICOPRA:        wStringID=IDS_RULELOGIC;       break;
         case ERR_RULEWORDLEN:          wStringID=IDS_RULEWORDLEN;     break;
         case ERR_RULEEQUAL:            wStringID=IDS_RULEEQUAL;       break;
                 case ERR_RULEDIRECTMODE:       wStringID=IDS_RULEDIRECT;      break;
         case ERR_RULEDBCSPOS:          wStringID=IDS_RULEDBCSPOS;     break;
         case ERR_RULECODEPOS:          wStringID=IDS_RULECODEPOS;     break;
         case ERR_NORULE:                               wStringID=IDS_NORULE;              break;
         case ERR_NOTDEFRULE:                   wStringID=IDS_NOTDEFRULE;          break;
         case ERR_RULENUM:              wStringID=IDS_RULENUM;             break;
         case ERR_DBCSCODE:             wStringID=IDS_DBCSCODE;        break;
         case ERR_CODEUNITNOTEXIST:     wStringID=IDS_CODEUNIT;        break;
         case ERR_CREATECODE:           wStringID=IDS_CREATECODE;      break;
         case ERR_CREATENOTEXIST:       wStringID=IDS_CRTCODEEMPTY;    break;
         case ERR_CODEEMPTY:            wStringID=IDS_CODEEMPTY;       break;
//       case ERR_SINGLECODEWORDDOUBLE: wStringID=IDS_SCODEREP;        break;
         case ERR_SBCS_IN_DBCS:         wStringID=IDS_SBCSINDBCS;      break;
         case ERR_GB2312NOTENTIRE:      wStringID=IDS_GB2312;          break;
         case ERR_USERWORDLEN:          wStringID=IDS_USERWORDLEN;     break;

         case ERR_WRITEID:              wStringID=IDS_WRID;            break;
         case ERR_WRITEMAININDEX:       wStringID=IDS_WRMAININDEX;     break;
         case ERR_WRITEDESCRIPT:        wStringID=IDS_WRDESCRIPT;      break;
         case ERR_WRITERULE:            wStringID=IDS_WRRULE;          break;
         case ERR_READID:               wStringID=IDS_READID;          break;
         case ERR_READMAININDEX:        wStringID=IDS_RDMAININDEX;     break;
         case ERR_READDESCRIPT:         wStringID=IDS_RDDESCRIPT;      break;
         case ERR_READRULE:             wStringID=IDS_RDRULE;          break;
                 case ERR_DESCRIPTSEG:              wStringID=IDS_DESCRIPTSEG;     break;
                 case ERR_RULESEG:                              wStringID=IDS_RULESEG;             break;
                 case ERR_TEXTSEG:                              wStringID=IDS_TEXTSEG;             break;
                 case ERR_TOOMANYUSERWORD:          wStringID=IDS_TOOMANYUSERWORD; break;
                 case ERR_OVERWRITE:            wStringID=IDS_OVERWRITE;           break;
         
         case ERR_IMENAMEENTRY:         wStringID=IDS_IMENAMEENTRY;        break;
         case ERR_MAXCODESENTRY:        wStringID=IDS_MAXCODESENTRY;   break;
         case ERR_ELEMENTENTRY:         wStringID=IDS_ELEMENTENTRY;        break;
         case ERR_USEDCODEENTRY:        wStringID=IDS_USEDCODEENTRY;   break;
         case ERR_NUMRULEENTRY:         wStringID=IDS_NUMRULESENTRY;   break;

         case ERR_CONVEND:              wStringID=IDS_CONVEND;         break;
         case ERR_RECONVEND:            wStringID=IDS_RECONVEND;       break;
         case ERR_SORTEND:              wStringID=IDS_SORTEND;         break;

         case ERR_VERSION:              wStringID=IDS_VERSIONEMPTY;    break;
         case ERR_GROUP:                wStringID=IDS_GROUP;           break;

         case 0:   //User may have hit CANCEL or we got a *very* random error
            return;
                                                                        
         default:
            wStringID=IDS_UNKNOWNERROR;
      }

   LoadString(NULL, wStringID, buf, sizeof(buf)/sizeof(TCHAR));
   switch(ErrorLevel) {
           case INFO:
           MessageBox(hWnd, buf, szCaption, MB_OK|MB_ICONINFORMATION);
                   break;
           case WARNING:
           MessageBox(hWnd, buf, szCaption, MB_OK|MB_ICONEXCLAMATION);
                   break;
       case ERR:
           default:
           MessageBox(hWnd, buf, szCaption, MB_OK|MB_ICONSTOP);
               break;
   }
   return;
}

HANDLE IndexReAlloc(HANDLE hMem,LPINT nPages)
{
  HANDLE hReMem;
  DWORD dwSize;

  *nPages++;
  dwSize = (DWORD)(*nPages)*GMEM_PAGESIZE*sizeof(WORDINDEX);
  GlobalUnlock(hMem);
  hReMem = GlobalReAlloc(hMem, dwSize, GMEM_MODIFY|GMEM_MOVEABLE);
  return hReMem;
}


BOOL ConvSort(HANDLE hWnd,LPWORDINDEX lpWordIndex,int nCount)
{
  int i;
  TCHAR szStr[256];
  HANDLE hDlgItem;

  SetCursor (LoadCursor (NULL, IDC_WAIT));   

  SetDlgItemText (hWnd,TM_TOTALINFO,TEXT(""));
  LoadString (NULL,IDS_TOTALINFO,szStr,sizeof(szStr)/sizeof(TCHAR));
  SetDlgItemText (hWnd,TM_TOTAL,szStr);
  LoadString(NULL,IDS_SORTWORDS,szStr,sizeof(szStr)/sizeof(TCHAR));
  SetDlgItemText (hWnd,TM_CONVINFO,szStr);
  SetDlgItemInt (hWnd,TM_TOTALNUM, nCount, FALSE);
  i = 0;
  SetDlgItemInt (hWnd,TM_CONVNUM,i,FALSE);
  InvalidateRect (hWnd,NULL,FALSE);
  hDlgItem = GetDlgItem(hWnd, TM_CONVNUM);


  for(i=1 ; i<= nCount; i++) 
  { 
      searchPos(lpWordIndex, i);  
          if(i%100 == 0 || i == nCount) 
          {
              SetDlgItemInt (hWnd,TM_CONVNUM,i,FALSE);
              InvalidateRect(hDlgItem,NULL,FALSE);
          }
  }



  SetCursor (LoadCursor (NULL, IDC_ARROW));   
  return TRUE;
}


/********  Quick sort structure function  ********/
void qSort(LPWORDINDEX item, DWORD left,DWORD right)
{
   
   int i,j,k,mid;
   WORDINDEX MidWord,SwapWord;

   if ( left > right )  return;

   i=(int)left;
   j=(int)right;
   mid = (i+j)/2;
   MidWord = item[mid];

   do {
        while( i < (int)right)
        {
           k = lstrcmpi(MidWord.szCode,item[i].szCode);

           if ( ( k > 0 ) || ( k==0  && i< mid ) )
              i++;
           else
              break;
        }

        while( j > (int)left )
        {
     
            k=lstrcmpi(MidWord.szCode,item[j].szCode);

            if ( ( k < 0 ) || (k == 0 && j >  mid) ) 
               j--;
            else
               break;
        }

        if(i <= j) {
             SwapWord = item[i];
             item[i] = item[j];
             item[j] = SwapWord;
             i++;
             j--;
        }
    } while(i <= j); 
    if((int)left < j)  qSort(item,left,j);
    if(i < (int)right) qSort(item,i,right);
}
   

/********  Quick sort char function  ********/
void qSortChar(LPTSTR item, DWORD left,DWORD right)
{
   
   int i,j,mid;
   TCHAR MidChar,SwapChar;

   if ( left > right )  return ;

   i=(int)left;
   j=(int)right;
   mid = (i+j)/2;
   MidChar = item[mid];

   do {
        while( ( MidChar > item[i] && i < (int)right)
                       ||(MidChar == item[i] && i != mid) )
             i++;
        while( (MidChar <item[j]  && j > (int)left)
                           ||(MidChar == item[j] && j!=mid) )
             j--;
                if(i <= j) {
                     
                         SwapChar = item[i];
                         item[i]  = item[j];
                         item[j]  = SwapChar;
                         i++;
                         j--;
           }
        } while(i <= j); 
        if((int)left < j) qSortChar(item,left,j);
        if(i < (int)right) qSortChar(item,i,right);
}

DWORD EncodeToNo(LPTSTR szDBCS)
{
    WORD  wCode;
    LPENCODEAREA lpEncode;

    DWORD dwNo = 0xffffffff, i;

        lpEncode = (LPENCODEAREA) GlobalLock(hEncode);

#ifdef UNICODE
    wCode = szDBCS[0];
#else
    wCode = (WORD)((UCHAR)szDBCS[0])*256 + (WORD)(UCHAR)szDBCS[1];
#endif

    for( i = NUMENCODEAREA -1; (long)i>=0; i--) {
       if(wCode >= lpEncode[i].StartEncode) {
               dwNo = lpEncode[i].PreCount;
               dwNo += wCode - lpEncode[i].StartEncode;
                   break;
           }
    }
    
    if(dwNo > NUM_OF_ENCODE)
            dwNo = 0xffffffff;
        GlobalUnlock(hEncode);

    return dwNo;
} 

DWORD EncodeToGBNo(UCHAR szDBCS[3])
{
  
    DWORD dwNo;
    if(szDBCS[0] < 0xa1 || szDBCS[1] < 0xa1 || szDBCS[1] > 0xfe)
        {
            dwNo = 0xffffffff; 
                return dwNo;
        }
    dwNo = (DWORD)(szDBCS[0]-0xa0-16) ;
    dwNo = dwNo * 94 + (DWORD)(szDBCS[1]-0xa0-1) - ((dwNo > 39)?5:0);
    return dwNo;
}

void NoToEncode(DWORD dwNo,LPBYTE szDBCS, DWORD dwNumArea,
                   LPENCODEAREA lpEncode)
{
  
  DWORD Value,i;

  for( i =dwNumArea-1; (long)i>=0; i--) {
     if(dwNo >= lpEncode[i].PreCount) {
             Value = dwNo-lpEncode[i].PreCount;
                 Value += lpEncode[i].StartEncode;
#ifdef UNICODE
                 szDBCS[0] = (UCHAR)(Value&0xff);
                 szDBCS[1] = (UCHAR)((Value>>8)&0xff);
#else
                 szDBCS[0] = (UCHAR)((Value>>8)&0xff);
                 szDBCS[1] = (UCHAR)(Value&0xff);
#endif
                 break;
         }
  }
}

void NoToGB2312Code(DWORD dwNo,LPBYTE szDBCS, DWORD dwNumArea)
{
  
    DWORD Value;
        szDBCS[0] = 0;
        szDBCS[1] = 0;

        if(dwNo > GB2312WORDNUM)
            return;
        Value = dwNo + ((dwNo >= 3755)?5:0);
        szDBCS[0] = (BYTE)(Value/94 +16 +0xa0);
        szDBCS[1] = (BYTE)(Value%94 + 0xa1);
              
}

void RuleToText(LPRULE lpRule, LPTSTR szStr)
{
  DWORD dwTemp;
  int nCount=0,i;

  szStr[0]=TEXT('c');
  dwTemp = lpRule->byLogicOpra;
  szStr[1]=(dwTemp==0)?TEXT('e'):(dwTemp==1)?TEXT('a'):TEXT('b');
  dwTemp = lpRule->byLength;
  szStr[2]=(dwTemp<10)?TEXT('0')+(TCHAR)dwTemp:TEXT('a')+(TCHAR)dwTemp-10;
  szStr[3]=TEXT('=');
  nCount = lpRule->wNumCodeUnits;
  for(i=0; i< nCount; i++) {
       dwTemp = lpRule->CodeUnit[i].dwDirectMode;
       szStr[4+i*4] = (dwTemp==0)?TEXT('p'):TEXT('n');
           dwTemp = lpRule->CodeUnit[i].wDBCSPosition;
       szStr[4+i*4+1] = (dwTemp<10)?TEXT('0')+(TCHAR)dwTemp:TEXT('a')+(TCHAR)dwTemp-10;
           dwTemp = lpRule->CodeUnit[i].wCodePosition;
       szStr[4+i*4+2] = (dwTemp<10)?TEXT('0')+(TCHAR)dwTemp:TEXT('a')+(TCHAR)dwTemp-10;
       szStr[4+i*4+3] = TEXT('+');
 }
  szStr[4+4*nCount-1] = 0;
  lstrcat(szStr,TEXT("\r\n"));
}

void MoveFileBlock(HANDLE hFile,DWORD dwOffset,DWORD dwSize, DWORD dwDirect)
//** if (dwDirect==0) move block to file begin, else move to file end 
{
  BYTE   Buffer[MAXREADBUFFER];
  static BYTE space[MAXREADBUFFER];
  DWORD  i,dwReadBytes,dwFilePtr;

  SetFilePointer(hFile,dwOffset,0,FILE_BEGIN);
  if(dwDirect == 0) {
      do { 
               ReadFile(hFile,Buffer,sizeof(Buffer),&dwReadBytes,NULL);
               SetFilePointer(hFile, (0-dwReadBytes-dwSize),0,FILE_CURRENT);
                   WriteFile(hFile,Buffer,dwReadBytes,&dwReadBytes,NULL);
               SetFilePointer(hFile, dwSize,0,FILE_CURRENT);
          }while(dwReadBytes == MAXREADBUFFER);
          SetFilePointer(hFile, 0-dwSize,0,FILE_CURRENT);
          for(i=0;i<dwSize;i++)
              //#60639 10/18/96         
              space[i] = (BYTE)0;
              WriteFile(hFile,space,dwSize,&dwReadBytes,NULL);
  }
  else {
      dwFilePtr = SetFilePointer(hFile,0,0,FILE_END);
          while(dwFilePtr > dwOffset) {
               if(dwFilePtr > dwOffset+MAXREADBUFFER) 
                           dwReadBytes = MAXREADBUFFER;
                   else 
                       dwReadBytes = dwFilePtr -  dwOffset; 
                   dwFilePtr = SetFilePointer(hFile,(0-dwReadBytes),0,FILE_CURRENT);
               ReadFile(hFile,Buffer,dwReadBytes,&dwReadBytes,NULL);
               SetFilePointer(hFile, (dwSize-dwReadBytes),0,FILE_CURRENT);
                   WriteFile(hFile,Buffer,dwReadBytes,&dwReadBytes,NULL);
               SetFilePointer(hFile, (0-dwSize-dwReadBytes),0,FILE_CURRENT);
          }

  }
 
}


BOOL Copy_File(LPCTSTR SrcFile,LPCTSTR DestFile)
{
  BYTE   Buffer[MAXREADBUFFER];
  HANDLE hSrcFile, hDestFile;
  DWORD  dwReadBytes;


  hSrcFile = Create_File(GetFocus(),(LPTSTR)SrcFile,GENERIC_READ,OPEN_EXISTING);
  hDestFile = CreateFile((LPTSTR)DestFile,GENERIC_WRITE|GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_ALWAYS,0,NULL);
  if(hSrcFile == (HANDLE)-1)
      return FALSE;
  if(hDestFile == (HANDLE)-1)
  {
      CloseHandle(hSrcFile);
          return FALSE;
  }
  SetFilePointer(hSrcFile,0,0,FILE_BEGIN);
  do {
      ReadFile(hSrcFile,Buffer,sizeof(Buffer),&dwReadBytes,NULL);
      WriteFile(hDestFile,Buffer,dwReadBytes,&dwReadBytes,NULL);
  }while(dwReadBytes == MAXREADBUFFER);
  CloseHandle(hSrcFile);
  CloseHandle(hDestFile);
  return TRUE;
}


/****************************************************************************
*
*    FUNCTION: CheckCrtData(HANDLE hWnd,
*                           LPCREATEWORD lpCreateWords,
*                           LPENCODEAREA lpEncode,
*                           DWORD dwMaxCodes)
*
*    PURPOSE:  check whether create word data is entired or not.
*
*    RETURN VALUES:
*        TRUE or FALSE.
*
*    HISTORY:
*        
*
****************************************************************************/
BOOL CheckCrtData(HANDLE hWnd,
                  LPCREATEWORD lpCreateWords,
                  LPENCODEAREA lpEncode,
                  DWORD dwMaxCodes)
{
  DWORD i;                
  TCHAR szDBCS[3],szCreate[13];
  TCHAR szTemp[128],szTmpStr[128];
  BOOL   bErr = FALSE;

#ifdef UNICODE
  //check CJK Unified Ideograph subset only
  for (i=0x250; i< 0x250+NUM_OF_CJK_CHINESE; i++) {
#else
  for (i=0; i< NUM_OF_ENCODE ; i++) {
#endif
     lstrncpy(szCreate,dwMaxCodes,&lpCreateWords[i*dwMaxCodes]);
     szCreate[dwMaxCodes] = 0;
     if(lstrlen(szCreate) == 0) {
          NoToEncode(i, (LPBYTE)szDBCS, NUMENCODEAREA, lpEncode); 
          //NoToGB2312Code(i,szDBCS,NUMENCODEAREA);
          szDBCS[1] =0;                                     //#62550
          LoadString(NULL, IDS_WORDNOTEXIST, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
          wsprintf(szTemp,TEXT("\'%s\' %s"),szDBCS,szTmpStr); 
          if(ErrMessage(hWnd,szTemp)) 
                return FALSE;
                  bErr = TRUE;
         }
  }
  return (!bErr) ;
}

void DispInfo(HANDLE hWnd,WORD wStrID)
{
  TCHAR text[80]; 
  
  LoadString(NULL,wStrID,text,sizeof(text)/sizeof(TCHAR));  
  SetDlgItemText(hWnd,TM_TOTALINFO,text);
  SetDlgItemText(hWnd,TM_TOTAL,TEXT(""));
  SetDlgItemText(hWnd,TM_TOTALNUM,TEXT(""));
  SetDlgItemText(hWnd,TM_CONVINFO,TEXT(""));
  SetDlgItemText(hWnd,TM_CONVNUM,TEXT(""));
  InvalidateRect(hWnd,NULL,FALSE);
}

BOOL WriteEMBToFile(LPCTSTR path_name,LPEMB_Head EMB_Table) {
        HANDLE          hFile;
        DWORD           byte_t_write;
        TCHAR       szStr[256],szStr1[256];
        hFile = CreateFile(path_name,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
        if(hFile==INVALID_HANDLE_VALUE) {
            LoadString(NULL,IDS_FILEOPEN,szStr, sizeof(szStr)/sizeof(TCHAR));
        wsprintf(szStr1,TEXT("\'%s\' %s\n"),path_name,szStr); 
        FatalMessage(GetFocus(),szStr1);
                return(0);
        }
        WriteFile(hFile,&EMB_Count,sizeof(EMB_Count),&byte_t_write,NULL); 
    WriteFile(hFile,EMB_Table,EMB_Count*sizeof(EMB_Head), &byte_t_write, NULL);                 
        GlobalUnlock(HmemEMB_Table);
        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return (1);
}

BOOL ReadEMBFromFile(LPCTSTR path_name, LPEMB_Head EMB_Table) {
        HANDLE          hFile;
        DWORD           byte_t_write;
        
        hFile = CreateFile(path_name,GENERIC_READ,
            FILE_SHARE_READ,NULL,OPEN_ALWAYS,0,NULL);
    if(hFile==INVALID_HANDLE_VALUE) {
            ProcessError(ERR_IMEUSE, GetFocus(), ERR);
        return FALSE;
    }
/*      if(hFile == INVALID_HANDLE_VALUE) {
            ProcessError(ERR_FILENOTOPEN,GetFocus(),ERR);
                return(0);
        }*/
        
        SetFilePointer(hFile,0,0,FILE_BEGIN);
        EMB_Count = 0;
        ReadFile(hFile,&EMB_Count,sizeof(EMB_Count),&byte_t_write,NULL); 
    if(EMB_Count > 1000) {
               CloseHandle(hFile);
                   return (0);
    }
    
    HmemEMB_Table = GlobalAlloc(GMEM_DISCARDABLE,(EMB_Count+1)*sizeof(EMB_Head));
        EMB_Table = GlobalLock(HmemEMB_Table);
        ReadFile(hFile,EMB_Table,EMB_Count*sizeof(EMB_Head), &byte_t_write, NULL);              
        GlobalUnlock(HmemEMB_Table);
        SetEndOfFile(hFile);
        CloseHandle(hFile);
        return (1);
}

int  AddZCItem(LPCTSTR path_name,LPEMB_Head EMB_Table,LPTSTR wai_code,LPTSTR cCharStr) { //string must end by '\0'
        int i;

        if(EMB_Count >= 1000)
            return FALSE;

        for(i=0; i<EMB_Count;i++) {
#ifdef UNICODE

                if(wcsncmp(wai_code,EMB_Table[i].W_Code,MAXCODELEN) == 0 &&
                   wcsncmp(cCharStr,EMB_Table[i].C_Char,USER_WORD_SIZE) == 0)
                {
                        return FALSE;
                }
                if(wcsncmp(wai_code,EMB_Table[i].W_Code,MAXCODELEN) < 0 )
                        break;


#else
                if(strncmp(wai_code,EMB_Table[i].W_Code,MAXCODELEN) == 0 &&
                   strncmp(cCharStr,EMB_Table[i].C_Char,USER_WORD_SIZE) == 0)
                {
                        return FALSE;
                }
                if(strncmp(wai_code,EMB_Table[i].W_Code,MAXCODELEN) < 0 )
                        break;
#endif
        }

        EMB_Count ++;
        memmove(&EMB_Table[i+1],&EMB_Table[i], (EMB_Count-i-1)*sizeof(EMB_Head));
        lstrncpy(EMB_Table[i].W_Code,MAXCODELEN,wai_code);
        lstrncpy(EMB_Table[i].C_Char,USER_WORD_SIZE,cCharStr); 
//      GlobalUnlock(HmemEMB_Table);

        WriteEMBToFile(path_name,EMB_Table);
        return TRUE;
}

void DelSelCU(LPCTSTR path_name,LPEMB_Head EMB_Table, int item) {
        
        memcpy(EMB_Table+item,EMB_Table+item+1,(EMB_Count-item-1)*sizeof(EMB_Head));
        EMB_Count --;
        WriteEMBToFile(path_name,EMB_Table);
}

/****************************************************************************
*
*    FUNCTION: ReadUserWord(HWND hWnd,LPSTR lpFileName,LPDWORD fdwUserWords)
*
*    PURPOSE:  read user words from file pointed by lpFileName.
*
*    INPUTS:   hWnd - parent window's handle
*              lpFileName - pointer to file name 
                           fdwUserWord - pointer to number of user words
*
*    RETURN VALUES:
*        TRUE or FALSE.
*
*    HISTORY:
*        
*
****************************************************************************/
BOOL ReadUserWord(HWND hWnd,LPTSTR lpFileName,LPDWORD fdwUserWords,WORD wMaxCodes)
{
   HANDLE hFile;
   TCHAR  Buffer[MAXREADBUFFER];
   DWORD  dwReadBytes;                                    
   TCHAR  szStr[256];
   int    nRet;
   register int i,j;

   *fdwUserWords = 0;
   hFile = Create_File(hWnd,lpFileName,GENERIC_READ,OPEN_EXISTING);
   if (hFile == (HANDLE)-1) 
        return FALSE;

   SendDlgItemMessage(hWnd,IDC_LIST,LB_RESETCONTENT,0,0L);
   SetFilePointer(hFile,0,0,FILE_BEGIN);
   SetCursor (LoadCursor (NULL, IDC_WAIT));
   dwLineNo = 0;
   while(ReadFile(hFile,Buffer,MAXREADBUFFER,&dwReadBytes,NULL))
   {    
     lstrcpy(szStr,TEXT(""));
         j=0;
         dwReadBytes = dwReadBytes/sizeof(TCHAR);
     for(i=0;i<(int)dwReadBytes;i++) {
        if(Buffer[i] == 0x0d || Buffer[i] == 0xfeff)
            continue;
        else if(Buffer[i] == TEXT('\n')) {
            dwLineNo ++;
            szStr[j]=0;
                j=0;
            if(lstrlen(szStr) == 0) continue;
                    nRet = CheckUserWord(hWnd,szStr,wMaxCodes); 
                    if(nRet == FALSE) {
                                CloseHandle(hFile);
                                SetCursor (LoadCursor (NULL, IDC_ARROW));
                                return FALSE;
                        }
                        else if(nRet == -1)
                        {
                        szStr[0]=0;
                            continue;
                    }
                SendDlgItemMessage(hWnd,IDC_LIST,LB_ADDSTRING,0,(LPARAM)szStr);
                    (*fdwUserWords)++;
                    if((*fdwUserWords) >= 1000) {
                        ProcessError(ERR_TOOMANYUSERWORD,hWnd,WARNING);
                                CloseHandle(hFile);
                                SetCursor (LoadCursor (NULL, IDC_ARROW));
                                return FALSE;
                    }
                    szStr[0]=0;
                }
                else {
                    szStr[j]=Buffer[i];
                    j++; 
                }
         } /*** for (i=0;...) ****/
         if(j) 
         SetFilePointer(hFile,0-j,0,FILE_CURRENT);
         if(dwReadBytes*sizeof(TCHAR) < MAXREADBUFFER) break;
   };
   
   CloseHandle(hFile);
   SetCursor (LoadCursor (NULL, IDC_ARROW));
   return TRUE;
}

int  CheckUserWord(HWND hWnd,LPTSTR szUserWord,WORD wMaxCodes)
{
   int   retValue;
   TCHAR szTemp[256];
   TCHAR szDBCS[256],szCode[30];

   retValue = ParseDBCSstr(hWnd,szUserWord, szDBCS,szCode,szTemp,wMaxCodes);
   if(retValue != TRUE)
       return retValue;
   if(lstrlen(szDBCS) == 0 || lstrlen(szCode) == 0)
       return -1;
   else
       return retValue;
}

BOOL CheckUserDBCS(HWND hWnd,LPTSTR szDBCS)
{
   int nDBCS=0,i;
   static TCHAR szTmpStr[256],szTemp[256];

   nDBCS=lstrlen(szDBCS);
   if(nDBCS == 0) 
       return FALSE;

#ifndef UNICODE
   if(nDBCS%2 == 1) {
           MessageBeep((UINT)-1);
           for(i=0; i <nDBCS; i += 2) {
                   if((BYTE)szDBCS[i] < 0x81)
                memcpy(&szDBCS[i],&szDBCS[i+1], nDBCS-i);
           }
       return FALSE;
   }
#endif    
   return TRUE;
}

BOOL CheckCodeLegal(HWND hWnd,LPTSTR szDBCS,LPTSTR szCode,LPTSTR szCreate, LPDESCRIPTION lpDescript)
{
  int len = lstrlen(szCode);
  int i;
  TCHAR szTemp[256],szTmpStr[256];
  
  if(len==0) return TRUE;
  if(len > lpDescript->wMaxCodes) {
      LoadString(NULL, IDS_DBCSCODELEN, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
      TCHAR UniTmp[] = {0x884C, 0x0000};
      wsprintf(szTemp,TEXT("\'%ws\'%ws %d(%ws:%ld)!"), szDBCS,szTmpStr,(int)lpDescript->wMaxCodes, UniTmp, dwLineNo); 
}
#else
      wsprintf(szTemp,"\'%s\'%s %d(:%ld)!", szDBCS,szTmpStr,(int)lpDescript->wMaxCodes, dwLineNo); 
#endif
      FatalMessage(hWnd,szTemp);
      return FALSE;
  }                 
  for(i=0; i<len; i++) {
      if(_tcschr(lpDescript->szUsedCode,szCode[i]) == NULL) {
          LoadString(NULL, IDS_DBCSCODE, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
          TCHAR UniTmp[] = {0x884C, 0x0000};
          wsprintf(szTemp,TEXT("\'%ws%ws\' %ws(%ws:%ld) "), szDBCS,szCode,szTmpStr, UniTmp, dwLineNo); 
}
#else
          wsprintf(szTemp,"\'%s%s\' %s(:%ld) ", szDBCS,szCode,szTmpStr, dwLineNo); 
#endif
          FatalMessage(hWnd,szTemp);
          return FALSE;
      }
  }
  len = lstrlen(szCreate);
  if(lpDescript->byMaxElement == 1 || len == 0)
      return TRUE;
  for(i=0; i<len; i++) {
      if(_tcschr(lpDescript->szUsedCode,szCreate[i]) == NULL) {
          LoadString(NULL, IDS_DBCSCODE, szTmpStr, sizeof(szTmpStr)/sizeof(TCHAR));
#ifdef UNICODE
{
          TCHAR UniTmp[] = {0x884C, 0x0000};
          wsprintf(szTemp, TEXT("\'%ws%ws %ws\' %ws(%ws:%ld) "), szDBCS,szCode,szCreate,szTmpStr, UniTmp, dwLineNo); 
}
#else
          wsprintf(szTemp,"\'%s%s %s\' %s(:%ld) ", szDBCS,szCode,szCreate,szTmpStr, dwLineNo); 
#endif
          FatalMessage(hWnd,szTemp);
          return FALSE;
      }
  }

  return TRUE;

}

void DelIllegalCode(TCHAR *szCode)
{
  static TCHAR collection[48]=
      TEXT("`1234567890-=\\[];',./abcdefghijklmnopqrstuvwxyz");
  int i,len = lstrlen(szCode), j;
  TCHAR szStr[512];

  if(len==0) 
      return ; 

  j = 0;
  for(i=0; i<len;i++) 
      if(_tcschr(collection,szCode[i]) != NULL) 
          {
              szStr[j] = szCode[i];
                  j ++;
          }
  szStr[j] = 0;
  lstrcpy(szCode,szStr);
  return ;
}

BOOL CheckCodeCollection(HWND hWnd,LPTSTR szUsedCode) 
{
  static TCHAR collection[48]=
      TEXT("`1234567890-=\\[];',./abcdefghijklmnopqrstuvwxyz");
  int i,len = lstrlen(szUsedCode);

  if(len==0) {
          ProcessError(ERR_USEDCODE,hWnd,ERR);
      return FALSE; 
  }
  qSortChar(szUsedCode,0,len-1);
  for(i=0; i<len-1 ;i++) 
  {    
      if(szUsedCode[i] == szUsedCode[i+1]
         || _tcschr(collection,szUsedCode[len-1])== NULL
         || _tcschr(collection,szUsedCode[i])== NULL) {
                 ProcessError(ERR_USEDCODE,hWnd,ERR);
                         return FALSE;
          }
  }
  return TRUE;
}

// QueryKey - enumerates the subkeys of a given key and the associated 
//     values and then copies the information about the keys and values 
//     into a pair of edit controls and list boxes. 
// hDlg - dialog box that contains the edit controls and list boxes 
// hKey - key whose subkeys and values are to be enumerated
//

BOOL QueryKey(HWND hDlg, HANDLE hKey)
{
    TCHAR     achKey[MAX_PATH];
    TCHAR     achClass[MAX_PATH] = TEXT("");  /* buffer for class name   */

    DWORD    cchClassName = MAX_PATH;  /* length of class string  */
    DWORD    cSubKeys;                 /* number of subkeys       */
    DWORD    cbMaxSubKey;              /* longest subkey size     */
    DWORD    cchMaxClass;              /* longest class string    */
    DWORD    cValues;              /* number of values for key    */
    DWORD    cchMaxValue;          /* longest value name          */
    DWORD    cbMaxValueData;       /* longest value data          */

    DWORD    cbSecurityDescriptor; /* size of security descriptor */
    FILETIME ftLastWriteTime;      /* last write time             */

    DWORD i, j;
    DWORD retCode;
    DWORD dwcValueName = MAX_VALUE_NAME;

    // Get the class name and the value count. 
    RegQueryInfoKey(hKey,        /* key handle                    */
        achClass,                /* buffer for class name         */

        &cchClassName,           /* length of class string        */
        NULL,                    /* reserved                      */
        &cSubKeys,               /* number of subkeys             */
        &cbMaxSubKey,            /* longest subkey size           */
        &cchMaxClass,            /* longest class string          */
        &cValues,                /* number of values for this key */
        &cchMaxValue,            /* longest value name            */

        &cbMaxValueData,         /* longest value data            */
        &cbSecurityDescriptor,   /* security descriptor           */
        &ftLastWriteTime);       /* last write time               */

    // Enumerate the child keys, looping until RegEnumKey fails. Then 

    // get the name of each child key and copy it into the list box.
    SetCursor(LoadCursor(NULL, IDC_WAIT));
    j = 0;
    for (i = 0, retCode = ERROR_SUCCESS;
        retCode == ERROR_SUCCESS; i++) {
        retCode = RegEnumKey(hKey, i, achKey, MAX_PATH);
        if (retCode == (DWORD)ERROR_SUCCESS) {

            SendMessage(GetDlgItem(hDlg, IDC_LIST),
                        LB_ADDSTRING, 0, 
                        (LPARAM)achKey);
        }
    }
    SetCursor(LoadCursor (NULL, IDC_ARROW));

    return TRUE;

}


BOOL CreateMbKey(PHKEY phKey,LPCTSTR FileName,LPCTSTR KeyName)
{
   HKEY hkResult;
   DWORD i;
   DWORD Value=1;
#ifdef UNICODE
   static TCHAR ValueName[][12]= {
                0x7801, 0x8868, 0x6587, 0x4EF6, 0x540D,0x0000,
                0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000,
                0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000,
                0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000,
                0x5916, 0x7801, 0x63D0, 0x793A, 0x0000,
                '<','S','P','A','C','E','>', 0x0000,
                '<','E','N','T','E','R','>', 0x0000,
                0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000
                }; 
#else
   static TCHAR ValueName[][12]= {
                "ļ",
                "",
                "",
                "ʾ",
                "ʾ",
                "<SPACE>",
                "<ENTER>",
                ""
                };
#endif \\UNICODE
   if(!RegOpenKey(*phKey,KeyName,&hkResult))
       return FALSE;
   if(RegCreateKey(*phKey,KeyName,&hkResult))
           return FALSE;
   RegSetValueEx(hkResult,ValueName[0],0,REG_SZ,(BYTE*)FileName,(lstrlen(FileName)+1) * sizeof(TCHAR) );
   for(i=1;i<6;i++) 
       RegSetValueEx(hkResult,ValueName[i],0,REG_DWORD,(LPSTR)&Value,sizeof(DWORD));
   RegSetValueEx(hkResult,ValueName[7],0,REG_DWORD,(LPSTR)&Value,sizeof(DWORD));
   Value = 0;
   RegSetValueEx(hkResult,ValueName[5],0,REG_DWORD,(LPSTR)&Value,sizeof(DWORD));
   RegSetValueEx(hkResult,ValueName[6],0,REG_DWORD,(LPSTR)&Value,sizeof(DWORD));

   RegCloseKey(hkResult);
   return TRUE;
}

BOOL SetRegValue(HKEY hKey,LPDWORD Value)
{
   DWORD i;
#ifdef UNICODE
   static TCHAR ValueName[][12]= {
                0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000,
                0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000,
                0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000,
                0x5916, 0x7801, 0x63D0, 0x793A, 0x0000,
                '<','S','P','A','C','E','>', 0x0000,
                '<','E','N','T','E','R','>', 0x0000,
                0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000
                }; 
#else
   static TCHAR ValueName[][12]= {
                "",
                "",
                "ʾ",
                "ʾ",
                "<SPACE>",
                "<ENTER>",
                ""
                };
#endif \\UNICODE

   for(i=0;i<7;i++)
       RegSetValueEx(hKey,ValueName[i],0,REG_DWORD,(LPSTR)&Value[i],sizeof(DWORD));
   return TRUE;
}

BOOL GetRegValue(HWND hDlg,HKEY hKey,LPDWORD Value)
{        
#ifdef UNICODE
   static TCHAR ValueName[][12]= {
                0x8BCD, 0x8BED, 0x8054, 0x60F3, 0x0000,
                0x8BCD, 0x8BED, 0x8F93, 0x5165, 0x0000,
                0x9010, 0x6E10, 0x63D0, 0x793A, 0x0000,
                0x5916, 0x7801, 0x63D0, 0x793A, 0x0000,
                '<','S','P','A','C','E','>', 0x0000,
                '<','E','N','T','E','R','>', 0x0000,
                0x5149, 0x6807, 0x8DDF, 0x968F, 0x0000
                }; 
#else
   static TCHAR ValueName[][12]= {
                "",
                "",
                "ʾ",
                "ʾ",
                "<SPACE>",
                "<ENTER>",
                ""
                };
#endif \\UNICODE
    DWORD i,j,retValue,dwcValueName;
        TCHAR Buf[80];

    SetCursor (LoadCursor (NULL, IDC_WAIT));
    for (j = 0, retValue = ERROR_SUCCESS; j < 7; j++)
    {
      dwcValueName = MAX_VALUE_NAME;
          i=sizeof(DWORD);
      retValue = RegQueryValueEx (hKey, ValueName[j],
                               NULL,
                               NULL,               //&dwType,
                               (LPSTR)&Value[j],          //&bData,
                               &i);                //&bcData);
      
      if (retValue != (DWORD)ERROR_SUCCESS &&
          retValue != ERROR_INSUFFICIENT_BUFFER)
        {
        wsprintf (Buf, TEXT("Line:%d 0 based index = %d, retValue = %d, ValueLen = %d"),
                  __LINE__, j, retValue, dwcValueName);
        MessageBox (hDlg, Buf, TEXT("Debug"), MB_OK);
        }

    }// end for(;;)

    SetCursor (LoadCursor (NULL, IDC_ARROW));
        return TRUE;
}

LPTSTR _tcschr(LPTSTR string, TCHAR c)
{
#ifdef UNICODE
        return (wcschr(string, c));
#else
        return (strchr(string, c));
#endif
}

LPTSTR _tcsrchr(LPTSTR string, TCHAR c)
{
#ifdef UNICODE
        return (wcsrchr(string, c));
#else
        return (strrchr(string, c));
#endif
}

LPTSTR _tcsstr(LPTSTR string1, LPTSTR string2)
{
#ifdef UNICODE
        return (wcsstr(string1, string2));
#else
        return (strstr(string1, string2));
#endif
}

LPTSTR _tcsupr(LPTSTR string)
{
#ifdef UNICODE
        return (_wcsupr(string));
#else
        return (_strupr(string));
#endif
}

int _ttoi(LPTSTR string)
{
#ifdef UNICODE
        return (_wtoi(string));
#else
        return (atoi(string));
#endif
}

int _taccess(LPTSTR szFileName, int mode)
{
        char szDbcsName[256];

#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, szFileName, -1, szDbcsName,
                sizeof(szDbcsName), NULL, NULL);
#else
        lstrcpy(szDbcsName, szFileName);
#endif

        return (_access(szDbcsName, mode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\makefile.inc ===
IMM.H : $(OAK_INC_PATH)\immdev.H
    COPY $(OAK_INC_PATH)\immdev.H IMM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\convdlg.c ===
/*************************************************
 *  convdlg.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <string.h>
#include "prop.h"
#include "upimeres.h"
#include <regstr.h>
#include <htmlhelp.h>

#ifdef UNICODE
extern TCHAR Title[];
extern TCHAR szVer[];
#else
extern BYTE Title[];
extern BYTE szVer[];
#endif

/*****************************************************************************

  FUNCTION: ConvDialogProc(HWND, UINT, WPARAM, LPARAM)

  PURPOSE:  Processes messages for "conv" property sheet.

  PARAMETERS:
    hdlg - window handle of the property sheet
    wMessage - type of message
    wparam - message-specific information
    lparam - message-specific information

  RETURN VALUE:
    TRUE - message handled
    FALSE - message not handled

  HISTORY:
    04-18-95 Yehfew Tie  Created.
 ****************************************************************************/

INT_PTR  CALLBACK ConvDialogProc(HWND hdlg,
                              UINT uMessage,
                              WPARAM wparam,
                              LPARAM lparam)
{
    LPNMHDR      lpnmhdr;
	static DWORD dwDesOffset,dwDesLen;
	static DWORD dwRuleOffset,dwRuleLen;
	static TCHAR szMbName[MAX_PATH];
	static TCHAR szSrcName[MAX_PATH];
	static TCHAR _szStr[MAX_PATH];
    static BOOL  bModify;
	LPRULE       lpRule;
	int 		 i;
    static DESCRIPTION Descript;


    switch (uMessage)
    {
	    case WM_INITDIALOG:
		{	

			//install conv sub class
		    lpConvProc = (FARPROC)SetWindowLongPtr(GetDlgItem(hdlg,IDC_LIST),
		    							GWLP_WNDPROC,(LONG_PTR)ConvEditProc);
		    SendDlgItemMessage(hdlg,IDC_IMENAME,EM_LIMITTEXT,24,0L);
		    SendDlgItemMessage(hdlg,IDC_USEDCODE,EM_LIMITTEXT,MAXUSEDCODES,0L);
			SetConvDisable(hdlg);
			PropSheet_CancelToClose(GetParent(hdlg));
            break;
		}
		
		
        case WM_DESTROY:
			if(hRule)
   			   GlobalFree(hRule);
			if(hEncode)
			   GlobalFree(hEncode);
			break;

		case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;

            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
 			        hRule = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
 				        sizeof(RULE)*MAXCODELEN);
                    hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                        NUMENCODEAREA*sizeof(ENCODEAREA));
                    if(!hRule || !hEncode)
                        ProcessError(ERR_OUTOFMEMORY,hdlg,ERR);		
		
                    if ( hEncode )	
			           ConvInitEncode(hEncode);
                    break;

                case PSN_APPLY:
					if(bModify) {
                       LoadString(NULL, IDS_FILEMODIFY, _szStr, sizeof(_szStr)/sizeof(TCHAR));
#ifdef UNICODE
{
		               TCHAR UniTmp[] = {0x521B, 0x5EFA, 0x8F93, 0x5165, 0x6CD5, 0x9875, 0x9762, 0x4E2D, 0x005C, 0x006E, 0x005C, 0x0027, 0x0025, 0x0077, 0x0073, 0x005C, 0x0027, 0x005C, 0x006E, 0x0025, 0x0077, 0x0073, 0x0000};		
                       wsprintf(szMbName,UniTmp,szSrcName,_szStr);
}
#else
                       wsprintf(szMbName,"뷨ҳ\n\'%s\'\n%s",szSrcName,_szStr);
#endif
                       if(ErrMessage(hdlg,szMbName)) {
					        SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
					   }
					}
                    break;
                case PSN_RESET:
                    break;
                case PSN_QUERYCANCEL:
                    break;

                case PSN_HELP:

                    break;
                case PSN_KILLACTIVE:
                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:

            switch (LOWORD(wparam))
            {
                case IDC_BROWSE:
					if(bModify) {
                        TCHAR errString[MAX_PATH];
                        LoadString(NULL, IDS_FILEMODIFY, _szStr, sizeof(_szStr)/sizeof(TCHAR));
                        wsprintf(errString,TEXT("\'%s\'%s"),szSrcName,_szStr);
                        if(ErrMessage(hdlg,errString))
					        SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
                    }
					
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
				    {	
#ifdef UNICODE					
					static TCHAR szTitle[] = {0x6253, 0x5F00, 0x0000};
#else
					TCHAR szTitle[MAX_PATH];
					strcpy(szTitle,"");
#endif

				    if(!TxtFileOpenDlg(hdlg,_szStr,szTitle))
				        break;
					}
					
					lstrcpy(szSrcName,_szStr);
                    bModify = FALSE;
                    memset(_szStr, 0, MAX_PATH);
 	                SetDlgItemText(hdlg,IDC_EDITBOX,_szStr);
 	                SendDlgItemMessage(hdlg,IDC_LIST,LB_RESETCONTENT,0,0L);
  				    {
					    LPTSTR lpString;
  				        if((lpString = _tcsrchr(szSrcName,TEXT('\\')))!=NULL)
					        SetDlgItemText(hdlg,IDC_SRCNAME, lpString+1);
					    lstrcpy(szMbName, szSrcName);
					    lstrcpy(_szStr, szSrcName);
					    if((lpString = _tcsrchr(szMbName,TEXT('.')))!=NULL)
					        *lpString = 0;
					    lstrcat(szMbName,TEXT(MbExt));
					}
					
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
				    {
				        int nRetValue;
				        nRetValue = ConvGetDescript(hdlg, szSrcName,
				            &dwDesOffset, &dwDesLen, &Descript, FALSE);
				        if(nRetValue ==(-ERR_FILENOTOPEN)) {
  					        szSrcName[0]=0;
   					        lstrcpy(szMbName, szSrcName);
 					        SetDlgItemText(hdlg,IDC_SRCNAME,szSrcName);
   					        SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
						    MessageBeep((UINT)-1);
				            break;
 					    }
					}

                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
						break;
				    }
 				
				    if(ConvGetRule(hdlg, szSrcName, &dwRuleOffset, &dwRuleLen,
				       lpRule, &Descript)==(-ERR_FILENOTOPEN))
					{
						szSrcName[0]=0;
						lstrcpy(szMbName,szSrcName);
 					    SetDlgItemText(hdlg,IDC_SRCNAME,szSrcName);
 					    SetDlgItemText(hdlg,IDC_MBNAME,szMbName);
						GlobalUnlock(hRule);
						MessageBeep((UINT)-1);
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
						break;
					}
                    SetDlgDescript(hdlg,&Descript);
					SetDlgRuleStr(hdlg,Descript.wNumRules,lpRule);
					SetDlgItemText(hdlg,IDC_MBNAME,szMbName);

					GlobalUnlock(hRule);
					SetConvEnable(hdlg);

                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
					SendMessage(GetDlgItem(hdlg,ID_FILEOPEN),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_CONV),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_CONV));
                    break;

                case IDC_MBNAME:
					GetDlgItemText(hdlg,IDC_MBNAME,szMbName,256);
					if(lstrlen(szMbName) == 0) {
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					    break;
					}
					else {
					    GetDlgItemText(hdlg,IDC_IMENAME,_szStr,32);
					    if(lstrlen(_szStr) != 0 && Descript.wMaxCodes != 0)
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
						else
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					}
					
                    break;
                case IDC_IMENAME:
					GetDlgItemText(hdlg,IDC_IMENAME,_szStr,128);
					_szStr[128]=0;
					if(lstrlen(_szStr) == 0) {
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					    break;
					}
					else {
					    GetDlgItemText(hdlg,IDC_MBNAME,szMbName,256);
					    if(lstrlen(szMbName) != 0 && Descript.wMaxCodes != 0)
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
						else
                            EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					}
					
					if(lstrcmpi(Descript.szName,_szStr)==0)
					    break;
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                    break;

				case IDC_MAXCODES:
				{
					int nMaxCodes;

					nMaxCodes = GetDlgItemInt (hdlg,IDC_MAXCODES,NULL,FALSE);
                    if(nMaxCodes > MAXCODELEN) {
						 MessageBeep((UINT)-1);
						 SetDlgItemInt (hdlg,IDC_MAXCODES,MAXCODELEN,FALSE);
						 Descript.wMaxCodes = MAXCODELEN;
					}
                    if(Descript.wMaxCodes != nMaxCodes) {
                         bModify = TRUE;
                         EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
					}

					break;
				}
				case IDC_USEDCODE:
					
					GetDlgItemText(hdlg,IDC_USEDCODE,_szStr,sizeof(_szStr)/sizeof(TCHAR));
					
                    if(lstrlen(_szStr) == 0)
                        EnableWindow(GetDlgItem(hdlg,IDC_CONV),FALSE);
					
					if(lstrcmpi(Descript.szUsedCode,_szStr)==0)
					    break;
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                    break;

				case IDC_WILDCHAR:
					GetDlgItemText(hdlg,IDC_WILDCHAR,_szStr,sizeof(_szStr)/sizeof(TCHAR));
					if(lstrlen(_szStr)==0 ) {
					    if( Descript.cWildChar!=0) {
                             bModify = TRUE;
                             EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
						}
					    break;
					}
					if(lstrlen(_szStr)>1)  {
					    MessageBeep((UINT)-1);
						_szStr[0]=0;
						SetDlgItemText(hdlg,IDC_WILDCHAR,_szStr);
						break;
					}

					{
					    TCHAR WildChar;

					    WildChar=_szStr[0];
					    if(WildChar != Descript.cWildChar) {
                            EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                            bModify = TRUE;
					    }
					    GetDlgItemText(hdlg,IDC_USEDCODE,_szStr,sizeof(_szStr)/sizeof(TCHAR));
					    if(_tcschr(_szStr,WildChar) != NULL) {
						    _szStr[0]=0;
						    SetDlgItemText(hdlg,IDC_WILDCHAR,_szStr);
				            MessageBeep((UINT)-1);
						    break;
					    }
					}
				    break;

				case IDC_SINGLEELEMENT:
				case IDC_MULTIELEMENT:
	                if(Descript.byMaxElement == (BYTE)(IsDlgButtonChecked(hdlg,IDC_MULTIELEMENT)?2:1))
                        break;
                    Descript.byMaxElement = 1 + Descript.byMaxElement%2;
                    bModify = TRUE;
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
				    break;

				case IDC_ADD:
				{
	                FARPROC      lpProcInfo;

				    szRuleStr[0] = 0;
				    if(Descript.wNumRules >= MAXCODELEN) {
					    ProcessError(ERR_RULENUM,hdlg,WARNING);
						break;
					}

                    lpProcInfo = MakeProcInstance((FARPROC)AddRuleDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_ADDRULE),
                    		  hdlg,
                    		  (DLGPROC)AddRuleDlg);

                    FreeProcInstance(lpProcInfo);
                    bModify = TRUE;
				    break;
				}

				case IDC_MODIFY:
				{
	                FARPROC      lpProcInfo;
				    int          nSelect;

				    nSelect = (INT)SendDlgItemMessage(hdlg,
                                                      IDC_LIST,
                                                      LB_GETCURSEL,
                                                      (WPARAM)0,
                                                      (LPARAM)0);
					if(nSelect == LB_ERR) {
					    MessageBeep((UINT)-1);
						break;
					}
				    SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,nSelect,(LPARAM)szRuleStr);
                    lpProcInfo = MakeProcInstance((FARPROC)ModiRuleDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_EDITRULE),
                    		  hdlg,
                    		  (DLGPROC)ModiRuleDlg);

                    FreeProcInstance(lpProcInfo);
                    break;

				}
				case IDC_DEL:
				{
					int nSelect;

				    nSelect = (INT)SendDlgItemMessage(hdlg,
                                                      IDC_LIST,
                                                      LB_GETCURSEL,
                                                      (WPARAM)0,
                                                      (LPARAM)0);
					if(nSelect != LB_ERR) {
				        SendDlgItemMessage(hdlg,IDC_LIST,LB_DELETESTRING,
                                           nSelect,(LPARAM)0);
                        if(!(lpRule = GlobalLock(hRule)) )  {
                             ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
						     break;
						}

                        DelSelRule(Descript.wNumRules,(WORD)nSelect,lpRule);
						Descript.wNumRules--;
						GlobalUnlock(hRule);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);

					    SetFocus(GetDlgItem(hdlg,IDC_LIST));
					    SendDlgItemMessage(hdlg,IDC_LIST,LB_SETCURSEL,nSelect,0L);
   					    if((nSelect=(INT)SendDlgItemMessage(hdlg,IDC_LIST,
                                         LB_GETCURSEL,0,0L))==LB_ERR) {

					        nSelect=(INT)SendDlgItemMessage(hdlg,
                                                            IDC_LIST,
                                                            LB_GETCOUNT,
                                                            (WPARAM)0,
                                                            (LPARAM)0);
					        SendDlgItemMessage(hdlg,
                                               IDC_LIST,
                                               LB_SETCURSEL,
                                               (WPARAM)(nSelect-1),
                                               (LPARAM)0);
                        }
				    }
					else
					    MessageBeep((UINT)-1);
					
				    break;
				}

				case IDC_ADDRULE:
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
				        szRuleStr[0] = 0;
						break;
				    }

                    if(RuleParse(hdlg,szRuleStr,0,lpRule,Descript.wMaxCodes)) {
						int nCnt;

	                    nCnt =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
                        if(nCnt != 0)
	                    {
	                        for(i=0; i<nCnt; i++) {
                                SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
#ifdef UNICODE
						        if(wcsncmp(szRuleStr,_szStr,3) == 0)
#else
								if(strncmp(szRuleStr,_szStr,3) == 0)
#endif //UNICODE
						  	    {
					                 GlobalUnlock(hRule);
									
      				                 ProcessError(ERR_DUPRULE,hdlg,ERR);
									 MessageBeep((UINT)-1);
									 MessageBeep((UINT)-1);
									 _szStr[0] = 0;
									 lstrcpy((LPTSTR)lparam,(LPTSTR)_szStr);
									 return FALSE;
								}
							}
						}
						SendDlgItemMessage(hdlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)szRuleStr);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
					    Descript.wNumRules++;
					}
					else
					{
					    MessageBeep((UINT)-1);
						_szStr[0] = 0;
						lstrcpy((LPTSTR)lparam,(LPTSTR)_szStr);
					}
					GlobalUnlock(hRule);

				    break;

				case IDC_CHGDATA:
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
				        _szStr[0] = 0;
						lstrcpy((LPTSTR)lparam,(LPTSTR)_szStr);
						break;
				    }

					{
				    int nSelect;

				    nSelect = (INT)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCURSEL,0,0L);
                    if(RuleParse(hdlg,szRuleStr,nSelect,lpRule,Descript.wMaxCodes)) {
//					    Descript.wNumRules++;
						int nCnt;

	                    nCnt =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
                        if(nCnt != 0)
	                    {
	                        for(i=0; i<nCnt; i++) {
                                if(i == nSelect)
								     continue;
                                SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
#ifdef UNICODE
						        if(wcsncmp(szRuleStr,_szStr,3) == 0)
#else
								if(strncmp(szRuleStr,_szStr,3) == 0)
#endif
						  	    {
					                 GlobalUnlock(hRule);
									 MessageBeep((UINT)-1);
				                     _szStr[0] = 0;
						             lstrcpy((LPTSTR)lparam,_szStr);
									 return FALSE;
								}
							}
						}
						SendDlgItemMessage(hdlg,IDC_LIST,LB_DELETESTRING,nSelect,0L);
						SendDlgItemMessage(hdlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)szRuleStr);
                        bModify = TRUE;
                        EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
						
					}
					else
				    {
				        _szStr[0] = 0;
						lstrcpy((LPTSTR)lparam,_szStr);
					    MessageBeep((UINT)-1);
					}
					GlobalUnlock(hRule);

				    break;
				    }
				case IDC_GETMBFILE:
					GetDlgItemText(hdlg,IDC_MBNAME,_szStr,sizeof(_szStr)/sizeof(TCHAR));
					lstrcpy((LPTSTR)lparam,_szStr);
					break;

				case IDC_GETSRCFILE:
					lstrcpy((LPTSTR)lparam,szSrcName);
					break;

				case IDC_CONV:
				{
	                FARPROC      lpProcInfo;

                    if(bModify)
						 SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
                    lpProcInfo = MakeProcInstance((FARPROC)InfoDlg, hInst);
					pfnmsg=(PFNMSG)ConvProc;
					bEndProp=FALSE;
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_INFO),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
                    FreeProcInstance(lpProcInfo);
				    break;
				}
				case IDC_CRTIME:
				{
	                FARPROC      lpProcInfo;
                    int 		 nRetValue;
					GetDlgItemText(hdlg, IDC_MBNAME, _szStr, sizeof(_szStr)/sizeof(TCHAR));
                    nRetValue = ReadDescript(_szStr,&Descript,FILE_SHARE_READ);
                    if(nRetValue == -1){
                        TCHAR errString[MAX_PATH];
                        LoadString(NULL, IDS_FILEOPEN, errString, sizeof(errString)/sizeof(TCHAR));
						lstrcat(_szStr, errString);
                        FatalMessage(hdlg,_szStr);
						break;
					}
					else if(!nRetValue)
					{
					    ProcessError(ERR_READMAININDEX,hdlg,WARNING);
   						break;
				    }
                    lpProcInfo = MakeProcInstance((FARPROC)CrtImeDlg, hInst);
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_CRTIME),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
                    FreeProcInstance(lpProcInfo);
				    break;
				}
				
				case IDC_SAVE:
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
				        _szStr[0] = 0;
						lstrcpy((LPTSTR)lparam,_szStr);
						break;
				    }
					GetDlgDescript(hdlg,&Descript);
					if(!CheckCodeCollection(hdlg,Descript.szUsedCode))
					    break;
					GetDlgRule(hdlg,lpRule,&(Descript.wNumRules),Descript.wMaxCodes);
				    if(!ConvSaveDescript(szSrcName,&Descript, dwDesOffset,dwDesLen))
				        break;
                    //**** modify 95.10.11
                    ConvGetDescript(hdlg,szSrcName,&dwDesOffset,&dwDesLen,&Descript,TRUE);
					//**** end modify
					
                    if(!(lpRule = GlobalLock(hRule)) )  {
                        ProcessError(ERR_GLOBALLOCK,hdlg,ERR);
					    break;
					}
                    if(!ConvSaveRule(hdlg,szSrcName, dwDesLen,dwRuleLen,
                       lpRule, Descript.wNumRules))
                        break;
 				    ConvGetRule(hdlg, szSrcName, &dwRuleOffset, &dwRuleLen,
				        lpRule, &Descript);
					GlobalUnlock(hRule);
                    bModify = FALSE;
                    EnableWindow(GetDlgItem(hdlg,IDC_CONV),TRUE);
                    EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
					SendMessage(GetDlgItem(hdlg,IDC_SAVE),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_CONV),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_CONV));
					break;

				case IDC_HLP:
				{
                    TCHAR szHlpName[MAX_PATH];

                    szHlpName[0] = 0;
                    GetWindowsDirectory((LPTSTR)szHlpName, MAX_PATH);
                    lstrcat(szHlpName, TEXT("\\HELP\\IMEGEN.CHM"));
                    HtmlHelp(hdlg,szHlpName,HH_DISPLAY_TOPIC,0L);
				}
					break;
                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

VOID ConvProc(LPVOID hWnd)
{
	static TCHAR file1[MAX_PATH]=TEXT("");
	static TCHAR file2[MAX_PATH]=TEXT("");
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETSRCFILE,(LPARAM)file1);
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETMBFILE,(LPARAM)file2);
  	if(ConvConv(hDlgless,file1,file2))
	   bEndProp=TRUE;
	SendMessage(hDlgless,WM_CLOSE,0,0L);
}

void SetDlgDescript(HWND hDlg,LPDESCRIPTION lpDescript)
{
	short nElement;
	TCHAR _szStr[20];

	nElement =(lpDescript->byMaxElement==1)?IDC_SINGLEELEMENT:IDC_MULTIELEMENT;
	SetDlgItemText(hDlg,IDC_IMENAME,lpDescript->szName);
	SetDlgItemText(hDlg,IDC_USEDCODE,lpDescript->szUsedCode);
	_szStr[0]=lpDescript->cWildChar;
	_szStr[1]=0;
	SetDlgItemText(hDlg,IDC_WILDCHAR,_szStr);
	SetDlgItemInt (hDlg,IDC_MAXCODES,lpDescript->wMaxCodes,FALSE);
	CheckRadioButton(hDlg,IDC_SINGLEELEMENT,IDC_MULTIELEMENT,nElement);
}

void GetDlgDescript(HWND hDlg,LPDESCRIPTION lpDescript)
{

	BOOL bTrans;
	TCHAR _szStr[20];

	GetDlgItemText(hDlg,IDC_IMENAME,lpDescript->szName,NAMESIZE);
	GetDlgItemText(hDlg,IDC_USEDCODE,lpDescript->szUsedCode,MAXUSEDCODES);
	GetDlgItemText(hDlg,IDC_WILDCHAR,_szStr,sizeof(_szStr)/sizeof(TCHAR));
	DelSpace(_szStr);
	if(_szStr[0]==0) _szStr[0]=TEXT('?');
	lpDescript->cWildChar=_szStr[0];
	lpDescript->wMaxCodes=(WORD)GetDlgItemInt (hDlg,IDC_MAXCODES,&bTrans,FALSE);
	lpDescript->wNumCodes=(WORD)lstrlen(lpDescript->szUsedCode);
	lpDescript->byMaxElement=(BYTE)(IsDlgButtonChecked(hDlg,IDC_MULTIELEMENT)?2:1);
	lpDescript->wNumRules=(WORD)SendDlgItemMessage(hDlg,IDC_LIST,LB_GETCOUNT,0,0L);
}


void SetDlgRuleStr(HWND hDlg,WORD NumRules,LPRULE lpRule)
{
    WORD  i;
	TCHAR _szStr[MAX_PATH];

	SendDlgItemMessage(hDlg,IDC_LIST,LB_RESETCONTENT,0,0L);
    if(NumRules==0)  return;
	for(i=0; i<NumRules; i++) {
        RuleToText(&lpRule[i], _szStr);
		_szStr[lstrlen(_szStr)-2]=0;
		SendDlgItemMessage(hDlg,IDC_LIST,LB_ADDSTRING,0,(LPARAM)_szStr);
	}
}

void GetDlgRule(HWND hdlg,LPRULE lpRule,LPWORD fwNumRules,WORD MaxCodes)
{
    int  i;
	TCHAR _szStr[128];
	WORD NumRules = 0;

	lpRule = GlobalLock(hRule);
	*fwNumRules =(WORD)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
    if((*fwNumRules) == 0)
    {
        GlobalUnlock(hRule);
        return;
	}
	for(i=0;i<(int)*fwNumRules;i++) {
        SendDlgItemMessage(hdlg,IDC_LIST,LB_GETTEXT,i,(LPARAM)_szStr);
        if(RuleParse(hdlg,_szStr,i,lpRule,MaxCodes))
		    NumRules++;
	}

    GlobalUnlock(hRule);
	*fwNumRules = NumRules;
}
			
void DelSelRule(WORD wNumRules,WORD wSelect,LPRULE lpRule)
{
    int i;
	if(wSelect>=MAXCODELEN) return;
	for(i=wSelect;i<wNumRules;i++)
	    lpRule[i]=lpRule[i+1];
}

void SetConvDisable(HWND hDlg)
{
	WORD wID;

	for(wID = IDC_MBNAME ;wID <= IDC_CONV ;wID++)
        EnableWindow(GetDlgItem(hDlg,wID),FALSE);

    EnableWindow(GetDlgItem(hDlg,IDC_CRTIME),FALSE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC5 ;wID++)
        EnableWindow(GetDlgItem(hDlg,wID),FALSE);
}

void SetConvEnable(HWND hDlg)
{
    WORD wID;

	for(wID = IDC_MBNAME ;wID <= IDC_CONV ;wID++)
        EnableWindow(GetDlgItem(hDlg,wID),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_CRTIME),TRUE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC5 ;wID++)
        EnableWindow(GetDlgItem(hDlg,wID),TRUE);

}

INT_PTR  CALLBACK  ConvEditProc(HWND   hWnd,
 				 			   UINT   wMsgID,
							   WPARAM wParam,
							   LPARAM lParam)
{
    switch(wMsgID) {
		case WM_LBUTTONDBLCLK:
			SendMessage(GetParent(hWnd),WM_COMMAND,IDC_MODIFY,0L);
		    break;

	    case WM_KEYDOWN:

		    switch(wParam) {
				case VK_DELETE:
				    SendMessage(GetParent(hWnd),WM_COMMAND,IDC_DEL,0L);
					break;
			}

		default:
		    return CallWindowProc((WNDPROC)lpConvProc,hWnd,wMsgID,wParam,lParam);
	}
	return FALSE;
}

void InstallConvSubClass(HWND hWnd)
{
    lpConvProc = (FARPROC)SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)ConvEditProc);
}


INT_PTR  CALLBACK AddRuleDlg(
        HWND   hDlg,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam)
{
	LPRULE  lpRule;

    switch (message) {
        case WM_INITDIALOG:
			lpRule=GlobalLock(hRule);
			szRuleStr[0] = 0;
			SetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
				    GetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr,sizeof(szRuleStr)/sizeof(TCHAR));
					SendMessage(GetParent(hDlg),WM_COMMAND,IDC_ADDRULE,(LPARAM)szRuleStr);
					if(*szRuleStr == 0)
					{
					 	SetFocus(GetDlgItem(hDlg,IDC_EDITRULE));
					    return (TRUE);
					}
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);

				case IDCANCEL:
				case WM_CLOSE:
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
					break;

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

INT_PTR  CALLBACK ModiRuleDlg(
        HWND   hDlg,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam)
{
	LPRULE  lpRule;

    switch (message) {
        case WM_INITDIALOG:
			lpRule=GlobalLock(hRule);
			SetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
				    GetDlgItemText(hDlg,IDC_EDITRULE,szRuleStr,sizeof(szRuleStr)/sizeof(TCHAR));
					SendMessage(GetParent(hDlg),WM_COMMAND,IDC_CHGDATA,(LPARAM)szRuleStr);
					if(*szRuleStr == 0)
					{
					 	SetFocus(GetDlgItem(hDlg,IDC_EDITRULE));
					    return (TRUE);
					}
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);

				case IDCANCEL:
				case WM_CLOSE:
					GlobalUnlock(hRule);
                    EndDialog(hDlg, TRUE);
					break;

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

//**********************************************************
//SetupIme(ImeFileName, ImeLayoutName);
//**********************************************************
/*
BOOL SetupIme(
LPTSTR ImeFileName,	 //ime file name with full path
LPTSTR MBFileName,
LPTSTR ImeLayoutName)//ime layout name(in chinese)
{
	HKEY  hKeyCurrVersion, hKey, hNewKey;
	long retCode,i;
	UCHAR Buf[256], lpszName[256],LayoutHandleName[10];
    DWORD   dwDisposition;

	memset(Buf,0,256);
	memset(lpszName,0,256);
	memset(LayoutHandleName, 0, 10);

	//create registry in keyboard layout
    retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_CURRENT_CONTROL_SET,
                            (DWORD)0,
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_EXECUTE |
                            KEY_QUERY_VALUE,
                            &hKeyCurrVersion);
     if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

    retCode = RegOpenKeyEx (hKeyCurrVersion,
                           "Keyboard Layouts",
                           0,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                           &hKey);
    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	for(i=0;;i++){
		retCode = RegEnumKey(hKey,	// handle of key to query
    					 i,	// index of subkey to query
    					 lpszName,	// address of buffer for subkey name
    					 256); 	// size of subkey buffer
		if(retCode)
			break;
		else{
			if(strcmp(Buf, lpszName)<0)
				strcpy(Buf, lpszName);
		}
	}
	if(Buf[0]=='\0')
		return FALSE;
	if(Buf[3]=='f' || Buf[3]=='F'){
		Buf[3]== '0';
		Buf[2]++;
	}else if(Buf[3]=='9')
		Buf[3]='A';
	else
		Buf[3]++;
	strcpy(LayoutHandleName,Buf);

    retCode = RegCreateKeyEx (hKey,
                           	  LayoutHandleName,
                              0,
							  0,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
                              &hNewKey,
                              &dwDisposition);

    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	GetFileTitle(ImeFileName, Buf, MAX_PATH);
    retCode = RegSetValueEx (hNewKey,
    			   "IME file",
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	strcpy(Buf, "kbdus.kbd");
    retCode = RegSetValueEx (hNewKey,
    			   "layout file",
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	strcpy(Buf, ImeLayoutName);
    retCode = RegSetValueEx (hNewKey,
    			   "layout text",
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)Buf,
		           strlen(Buf));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	RegCloseKey(hNewKey);
	RegCloseKey(hKey);
	RegCloseKey(hKeyCurrVersion);


	//create registry in preload
    retCode = RegOpenKeyEx (HKEY_CURRENT_USER,
                            "Keyboard Layout\\Preload",
                            0,
                            KEY_ENUMERATE_SUB_KEYS |
                            KEY_EXECUTE |
                            KEY_QUERY_VALUE,
                            &hKeyCurrVersion);
     if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	memset(Buf,0,256);
	memset(lpszName,0,256);
	for(i=0;;i++){
		retCode = RegEnumKey(hKeyCurrVersion,	// handle of key to query
    					 i,	// index of subkey to query
    					 lpszName,	// address of buffer for subkey name
    					 256); 	// size of subkey buffer
		if(retCode)
			break;
		else{
			if(strcmp(Buf, lpszName)<0)
				strcpy(Buf, lpszName);
		}
	}
	if(Buf[0]=='\0')
		return FALSE;
	i=_ttoi(Buf);
	i++;
	_itoa(i,Buf,10);

    retCode = RegCreateKeyEx (hKeyCurrVersion,
                           	  Buf,
                              0,
							  0,
							  REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS,
							  NULL,
                              &hNewKey,
                              &dwDisposition);

    if (retCode) {
	    wsprintf (Buf, ": RegOpenKeyEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

    retCode = RegSetValueEx (hNewKey,
    			   NULL,
		           (DWORD)NULL,
		           REG_SZ,
		           (LPBYTE)LayoutHandleName,
		           strlen(LayoutHandleName));
    if (retCode) {
	    wsprintf (Buf, ": RegSetValueEx = %d", retCode);
	    MessageBox (NULL, Buf, "", MB_OK | MB_ICONINFORMATION);
	    return FALSE;
    }

	RegCloseKey(hNewKey);
	RegCloseKey(hKey);
	RegCloseKey(hKeyCurrVersion);

	//copy files
	{
	UCHAR	DesFilePath[MAX_PATH];

	GetSystemDirectory(DesFilePath,MAX_PATH);
	strcat(DesFilePath,"\\");

	GetFileTitle(ImeFileName, Buf, MAX_PATH);
	strcat(DesFilePath,Buf);
	CopyFile(ImeFileName, DesFilePath, FALSE);

	GetSystemDirectory(DesFilePath,MAX_PATH);
	strcat(DesFilePath,"\\");

	GetFileTitle(MBFileName, Buf, MAX_PATH);
	strcat(DesFilePath,Buf);
	CopyFile(MBFileName, DesFilePath, FALSE);

	}
	return TRUE;
}
*/

//Hack for #62554 10/29/96
HWND HwndCrtImeDlg = NULL;

INT_PTR  CALLBACK CrtImeDlg(
        HWND   hDlg,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam)
{
    static TCHAR _szStr[MAX_PATH];
    static TCHAR ImeTplName[MAX_PATH];
    static TCHAR mbName[MAX_PATH];
	static IMERES ImeRes;
	LPTSTR       lpString;

	HwndCrtImeDlg = hDlg;
    switch (message) {
        case WM_INITDIALOG:
			SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETMBFILE,(LPARAM)mbName);
		    SendDlgItemMessage(hDlg,IDC_VERSION,EM_LIMITTEXT,8,0L);
		    SendDlgItemMessage(hDlg,IDC_GROUP,EM_LIMITTEXT,32,0L);
		    SetDlgItemText(hDlg, IDC_VERSION,TEXT(DefVer));
		    SetDlgItemText(hDlg, IDC_GROUP, TEXT(DefOrgName));
			ImeRes.Value = 0x00af;
			SetValue(hDlg,ImeRes.Value);
			SendMessage(hDlg,WM_COMMAND, IDC_DEF, 0L);
			CheckRadioButton(hDlg,IDC_DEF,IDC_USERDEF,IDC_DEF);
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
					{
					DESCRIPTION Descript;
                    TCHAR       tmpBuf[MAX_PATH];

					if(!GetImeRes(hDlg,&ImeRes))
					    return TRUE;
                    ReadDescript(mbName,&Descript,FILE_SHARE_READ);
					lstrcpy(_szStr, Descript.szName);
					lstrcat(_szStr, szVer);
					lstrcat(_szStr, ImeRes.Version);
					lstrcpy(ImeRes.Version, _szStr);
					GetSystemDirectory(ImeTplName,sizeof(ImeTplName)/sizeof(TCHAR));
                    lstrcpy(_szStr, ImeTplName);
					lstrcat(ImeTplName, TEXT(TplName));

                    lstrcat(_szStr, TEXT("\\"));
                    GetFileTitle(mbName, tmpBuf, MAX_PATH);
                    lstrcat(_szStr, tmpBuf);

					if((lpString=_tcsrchr(_szStr,TEXT('.')))!=NULL)
					    *lpString=0;
					lstrcat(_szStr,TEXT(ImeExt));

					
					DispInfo(GetWindow(hDlg, GW_OWNER),IDS_UPRES);
					

					CopyFile(ImeTplName, _szStr, FALSE);
					

                    if(ImeUpdateRes(_szStr, ImeRes.BmpName, ImeRes.IcoName,ImeRes.Version,
					    ImeRes.Depart, ImeRes.Value)==TRUE){
						TCHAR szDBCS[256];
						LoadString(NULL,IDS_SETUPIME,szDBCS, sizeof(szDBCS)/sizeof(TCHAR));
      					if(ErrMessage(hDlg, szDBCS))
	  					{
	  					HKL hKL;
	  					TCHAR DesFilePath[MAX_PATH],Buf[MAX_PATH];
	  					
							hKL = ImmInstallIME(_szStr,Descript.szName);
							//copy .MB & .HLP to system directory.
							if(hKL){
								GetSystemDirectory(DesFilePath,MAX_PATH);
								lstrcat(DesFilePath,TEXT("\\"));
								GetFileTitle(mbName, Buf, MAX_PATH);
								lstrcat(DesFilePath,Buf);
								CopyFile(mbName, DesFilePath, FALSE);
								if(ImeRes.HlpFile[0]){
									lstrcpy(_szStr,DesFilePath);
									if((lpString=_tcsrchr(_szStr,TEXT('.')))!=NULL)
					    			*lpString=0;
									lstrcat(_szStr,TEXT(HlpExt));
									CopyFile( ImeRes.HlpFile, _szStr, FALSE);

									if((lpString=_tcsrchr(ImeRes.HlpFile,TEXT('.')))!=NULL)
					    			*lpString=0;
									lstrcat(ImeRes.HlpFile,TEXT(".CNT"));
									lstrcpy(_szStr,DesFilePath);
									if((lpString=_tcsrchr(_szStr,TEXT('\\')))!=NULL)
					    			*(lpString+1)=0;
									GetFileTitle(ImeRes.HlpFile, Buf, MAX_PATH);
									lstrcat(_szStr,Buf);
									CopyFile( ImeRes.HlpFile, _szStr, FALSE);

									if((lpString=_tcsrchr(ImeRes.HlpFile,TEXT('.')))!=NULL)
					    			*(lpString+1)=0;
									lstrcat(ImeRes.HlpFile,TEXT(".GID"));
									lstrcpy(_szStr,DesFilePath);
									if((lpString=_tcsrchr(_szStr,TEXT('\\')))!=NULL)
					    			*lpString=0;
									GetFileTitle(ImeRes.HlpFile, Buf, MAX_PATH);
									lstrcat(_szStr,Buf);
									CopyFile( ImeRes.HlpFile, _szStr, FALSE);

								}
							}else{
								LoadString(NULL,IDS_ERR_INSTALLIME,_szStr, sizeof(_szStr)/sizeof(TCHAR));
								WarnMessage(hDlg,_szStr);
							}
						}
					}

                    EndDialog(hDlg, TRUE);
                    return (TRUE);
					}
				
				case IDC_BROWSE:
				    if(!RcFileOpenDlg(hDlg, _szStr,Title))
				        break;
					if(_tcsstr(_tcsupr(_szStr),TEXT(BmpExt)) != NULL)
					    SetDlgItemText(hDlg, IDC_BMP, _szStr);
#ifdef UNICODE
					else if(_tcsstr(_wcsupr(_szStr),TEXT(IconExt)) != NULL)
#else
					else if(_tcsstr(_strupr(_szStr),TEXT(IconExt)) != NULL)
#endif

					    SetDlgItemText(hDlg, IDC_ICO, _szStr);
#ifdef UNICODE
					else if(_tcsstr(_wcsupr(_szStr),TEXT(HlpExt)) != NULL)
#else
					else if(_tcsstr(_strupr(_szStr),TEXT(HlpExt)) != NULL)
#endif
					    SetDlgItemText(hDlg, IDC_HLPFILE, _szStr);
					break;
				case IDC_DEF:
				    EnableWindow(GetDlgItem(hDlg,IDC_BMP), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_ICO), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_HLPFILE), FALSE);
				    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE), FALSE);
					GetDlgItemText(hDlg, IDC_ICO, ImeRes.IcoName,sizeof(ImeRes.IcoName)/sizeof(TCHAR));
					GetDlgItemText(hDlg, IDC_BMP, ImeRes.BmpName,sizeof(ImeRes.BmpName)/sizeof(TCHAR) );
					GetDlgItemText(hDlg, IDC_BMP, ImeRes.HlpFile,sizeof(ImeRes.HlpFile)/sizeof(TCHAR));
					_szStr[0] = 0;
					SetDlgItemText(hDlg, IDC_ICO, _szStr);
					SetDlgItemText(hDlg, IDC_BMP, _szStr);
					SetDlgItemText(hDlg, IDC_HLPFILE, _szStr);
					break;


				case IDC_USERDEF:
				    EnableWindow(GetDlgItem(hDlg,IDC_BMP), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_ICO), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_HLPFILE), TRUE);
				    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE), TRUE);
					SetDlgItemText(hDlg, IDC_ICO, ImeRes.IcoName);
					SetDlgItemText(hDlg, IDC_BMP, ImeRes.BmpName);
					SetDlgItemText(hDlg, IDC_HLPFILE, ImeRes.HlpFile);
					break;
				
				case IDC_ZJTS:
					if(IsDlgButtonChecked(hDlg,IDC_ZJTS))
						EnableWindow(GetDlgItem(hDlg,IDC_WMTS),TRUE);
					else {
					    CheckDlgButton(hDlg,IDC_WMTS,0);
						EnableWindow(GetDlgItem(hDlg,IDC_WMTS),FALSE);
					}
				    break;

				case IDCANCEL:
				case WM_CLOSE:
                    EndDialog(hDlg, TRUE);
					return (TRUE);

				default:
				    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

void SetValue(HWND hDlg, WORD Value)
{
	
	CheckDlgButton(hDlg,IDC_CYLX,Value&0x0001);
	CheckDlgButton(hDlg,IDC_CYSR,Value&0x0002);
	CheckDlgButton(hDlg,IDC_ZJTS,Value&0x0004);
	if((Value&0x0004)==0) {
	    EnableWindow(GetDlgItem(hDlg,IDC_WMTS),FALSE);
		Value &= ~ 0x0008;
	}
	CheckDlgButton(hDlg,IDC_WMTS,Value&0x0008);
	CheckDlgButton(hDlg,IDC_GBGS,Value&0x0020);
	CheckDlgButton(hDlg,IDC_SPACE,Value&0x0040);
	CheckDlgButton(hDlg,IDC_ENTER,Value&0x0080);
}

void GetValue(HWND hDlg,LPWORD Value)
{
	*Value = 0;
	*Value |= IsDlgButtonChecked(hDlg,IDC_CYLX);
	*Value |= IsDlgButtonChecked(hDlg,IDC_CYSR) << 1;
	*Value |= IsDlgButtonChecked(hDlg,IDC_ZJTS) << 2;
	*Value |= IsDlgButtonChecked(hDlg,IDC_WMTS) << 3;
	*Value |= IsDlgButtonChecked(hDlg,IDC_GBGS) << 5;
	*Value |= IsDlgButtonChecked(hDlg,IDC_SPACE) << 6;
	*Value |= IsDlgButtonChecked(hDlg,IDC_ENTER) << 7;
}

int  GetImeRes(HWND hDlg,LPIMERES lpImeRes)
{
	GetDlgItemText(hDlg, IDC_VERSION, lpImeRes->Version, sizeof(lpImeRes->Version)/sizeof(TCHAR));
	if(lstrlen(lpImeRes->Version) == 0)
	{
	    ProcessError(ERR_VERSION, hDlg, WARNING);
	    return FALSE;
	}
	GetDlgItemText(hDlg, IDC_GROUP,   lpImeRes->Depart, sizeof(lpImeRes->Depart)/sizeof(TCHAR));
	if(lstrlen(lpImeRes->Depart) == 0)
	{
	    ProcessError(ERR_GROUP, hDlg, WARNING);
	    return FALSE;
	}
	GetDlgItemText(hDlg, IDC_BMP,     lpImeRes->BmpName, sizeof(lpImeRes->BmpName)/sizeof(TCHAR));
	GetDlgItemText(hDlg, IDC_ICO,     lpImeRes->IcoName, sizeof(lpImeRes->IcoName)/sizeof(TCHAR));
	GetValue(hDlg, &(lpImeRes->Value));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\propshet.h ===
/*************************************************
 *  propshet.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PROPSHET.RC
//
#ifndef __PROPSHET_H
#define __PROPSHET_H
#define IDS_MBNAME                      1
#define IDS_FILENOTEXIST                2
#define IDS_FILEOPEN                    3
#define IDS_MEMORY                      4
#define IDS_GLOBALLOCK                  5
#define IDS_MAXCODES                    6
#define IDS_ELEMENT                     7
#define IDS_USEDCODE                    8
#define IDS_WILDCHAR                    9
#define IDS_RULEHEAD                    10
#define IDS_RULELOGIC                   11
#define IDS_RULEWORDLEN                 12
#define IDS_RULEEQUAL                   13
#define IDS_RULEDIRECT                  14
#define IDS_RULEDBCSPOS                 15
#define IDS_RULECODEPOS                 16
#define IDS_DBCSCODE                    17
#define IDS_CODEEMPTY                   18
#define IDS_DBCSCODELEN                 19
#define IDS_CREATECODE                  20
#define IDS_CRTCODEEMPTY                21
#define IDS_NOTEXISTDBCS                22
#define IDS_SBCSINDBCS                  23
#define IDS_GB2312                      24
#define IDS_USERWORDLEN                 25
#define IDS_UNKNOWNERROR                26
#define IDS_CODEUNIT                    27
#define IDS_WRID                        28
#define IDS_WRMAININDEX                 29
#define IDS_WRDESCRIPT                  30
#define IDS_WRRULE                      31
#define IDS_READID                      32
#define IDS_RDMAININDEX                 33
#define IDS_RDRULE                      34
#define IDS_RDDESCRIPT                  35
#define IDS_WORDNOTEXIST                36
#define IDS_NORULE                      37
#define IDS_NOTDEFRULE                  38
#define IDS_CONVERTINFO                 39
#define IDS_READTEXTINFO                40
#define IDS_WRCRTINFO                   41
#define IDS_SORT                        42
#define IDS_TOTALINFO                   43
#define IDS_CONVWORDS                   44
#define IDS_RECONVINFO                  45
#define IDS_RECONVWORDS                 46
#define IDS_SORTWORDS                   47
#define IDS_CONVEND                     48
#define IDS_RECONVEND                   49
#define IDS_RULENUM                     50
#define IDS_DESCRIPTSEG                 51
#define IDS_RULESEG                     52
#define IDS_TEXTSEG                     53
#define IDS_FILEMODIFY                  54
#define IDS_DESCRIPTION                 55
#define IDS_APPNAME                     58
#define IDS_TOOMANYUSERWORD             59
#define IDS_OVERWRITE                   60
#define IDS_IMENAMEENTRY                61
#define IDS_MAXCODESENTRY               62
#define IDS_ELEMENTENTRY                63
#define IDS_USEDCODEENTRY               64
#define IDS_NUMRULESENTRY               65
#define IDS_SORTEND                     66
#define IDS_IMEUSE                      67
#define IDS_INSWORDS                    68
#define IDS_VERSIONEMPTY                69
#define IDS_GROUP                       70
#define IDS_ISCHECKCRTWORD              71
#define IDS_UPRES                       72
#define IDS_SETUPIME                    73
#define IDS_DUPRULE                     74
#define IDS_WRITETEXTINFO               75
#define IDS_ERR_INSTALLIME		76
#define IDS_DBCSTOOLONG                 80
#define IDD_CRTIME                      101
#define IDD_CONV                        102
#define IDD_RECONV                      103
#define IDD_SORT                        104
#define IDD_REGIME                      105
#define IDD_USERDIC                     106
#define IDD_INFO                        107
#define IDD_DESCRIPTION                 108
#define IDI_IMEGEN                      109
#define IDD_RULE                        110
#define IDD_EDITRULE                    110
#define IDD_IMEPROP                     111
#define IDD_ADDWORD                     112
#define IDD_MODIWORD                    113
#define IDD_COPYRIGHT                   130
#define IDD_ADDRULE                     131
#define TM_TOTAL                        1000
#define TM_CONVINFO                     1001
#define TM_TOTALNUM                     1002
#define TM_CONVNUM                      1003
#define IDC_CONVGROUP1                  1004
#define IDC_SRCNAME                     1005
#define IDC_MBNAME                      1006
#define IDC_IMENAME                     1007
#define IDC_CONVGROUP2                  1008
#define IDC_MAXELEMENT                  1009
#define IDC_SINGLEELEMENT               1010
#define IDC_MULTIELEMENT                1011
#define IDC_USEDCODE                    1012
#define IDC_USEDCODE1                   1013
#define IDC_USEDCODE2                   1014
#define IDC_WILDCHAR                    1015
#define IDC_MAXCODES                    1016
#define IDC_CONVGROUP3                  1017
#define IDC_EDITBOX                     1018
#define IDC_ADD                         1019
#define IDC_MODIFY                      1020
#define IDC_DEL                         1021
#define IDC_SAVE                        1022
#define IDC_CONV                        1023
#define IDC_RULENUM                     1024
#define IDC_RESULTNAME                  1025
#define IDC_RECONV                      1026
#define IDC_SORT                        1027
#define IDC_PROPERTIES                  1028
#define IDC_REGIMENAME                  1029
#define IDC_REMOVE                      1030
#define IDC_CRTWORD                     1031
#define IDC_MAINTAIN                    1032
#define IDC_COMBO1                      1033
#define IDC_INSUSERDIC                  1034
#define IDC_LIST                        1035
#define IDC_FULLSELECT                  1036
#define IDC_AUTOCODE                    1037
#define ID_FILEOPEN                     1038
#define IDC_STATIC1                     1039
#define IDC_STATIC2                     1040
#define IDC_STATIC3                     1041
#define IDC_STATIC4                     1042
#define IDC_STATIC5                     1043
#define IDC_STATIC6                     1044
#define IDC_STATIC7                     1045
#define IDC_STATIC8                     1046
#define IDC_INPUTWORD                   1047
#define IDC_INPUTCODE                   1048
#define IDC_EDITRULE                    1049
#define IDC_GETUSERWORD                 1050
#define IDC_ADDRULE                     1051
#define IDC_CHGDATA                     1052
#define IDC_CRTIME                      1053
#define IDC_ADDSTR                      1054
#define IDC_GETSRCFILE                  1055
#define IDC_GETMBFILE                   1056
#define IDC_VERSION                     1057
#define IDC_GROUP                       1058
#define IDC_CYLX                        1059
#define IDC_CYSR                        1060
#define IDC_ZJTS                        1061
#define IDC_WMTS                        1062
#define IDC_SPACE                       1063
#define IDC_ENTER                       1064
#define IDC_GBGS                        1065
#define IDC_BMP                         1066
#define IDC_ICO                         1067
#define IDC_BROWSE                      1068
#define IDC_DEF                         1069
#define IDC_USERDEF                     1070
#define IDC_HLPFILE                     1071
#define IDC_XSQ                         1072
#define IDC_HLP                         1073
#define TM_TOTALINFO                    65535

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1074
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
#endif //__PROPSHET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\recnvdlg.c ===
/*************************************************
 *  recnvdlg.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "prop.h"

/*****************************************************************************

  FUNCTION: ReConvDialogProc(HWND, UINT, WPARAM, LPARAM)

  PURPOSE:  Processes messages for "reconv" property sheet.

  PARAMETERS:
    hdlg - window handle of the property sheet
    wMessage - type of message
    wparam - message-specific information
    lparam - message-specific information

  RETURN VALUE:
    TRUE - message handled
    FALSE - message not handled

  HISTORY:
    04-18-95 Yehfew Tie  Created.

 ****************************************************************************/


INT_PTR  CALLBACK  ReConvDialogProc(HWND hdlg, 
						 		 UINT uMessage, 
						 		 WPARAM wparam, 
								 LPARAM lparam)
{
    LPNMHDR lpnmhdr;
	static TCHAR szMBFile[MAX_PATH];
	static TCHAR szSrcFile[MAX_PATH];
	static HANDLE hRule0;
	LPTSTR		lpString;
	TCHAR       szStr[MAX_PATH];
    MAININDEX   MainIndex[NUMTABLES];
	HANDLE      hFile;
	FARPROC     lpProcInfo;

    switch (uMessage)
    {
		case WM_INITDIALOG:
			SetReConvDisable(hdlg);
		    break;

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;

            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                    hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                        NUMENCODEAREA*sizeof(ENCODEAREA));
                    if(!hRule ) 
                        ProcessError(ERR_OUTOFMEMORY,hdlg,ERR);		
			
                    if ( hEncode )
			            ConvInitEncode(hEncode);
                    break;

                case PSN_KILLACTIVE:
					if(hEncode)
						GlobalFree(hEncode);
                    break;
                    break;
                case PSN_APPLY:
                    break;
                case PSN_RESET:
                    break;
                case PSN_QUERYCANCEL:
                    break;

                case PSN_HELP:

                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:

            switch (LOWORD(wparam))
            {
                case ID_FILEOPEN:
					{
#ifdef UNICODE
					static TCHAR szTitle[] = {0x6253, 0x5F00, 0x0000};
#else
					TCHAR szTitle[MAX_PATH];					
					strcpy(szTitle,"");
#endif
				    if(!MBFileOpenDlg(hdlg,szStr,szTitle)) 
				        break;
					}
					lstrcpy(szMBFile, szStr);
					lstrcpy(szSrcFile,szMBFile);
					SetReConvDisable(hdlg);
                    hFile = Create_File(hdlg,szMBFile,GENERIC_READ,OPEN_EXISTING);
                    if (hFile == (HANDLE)-1) {
					    szMBFile[0]=0;
					    lstrcpy(szSrcFile,szMBFile);
					    SetDlgItemText(hdlg,IDC_MBNAME,szMBFile);
					    SetDlgItemText(hdlg,IDC_SRCNAME,szSrcFile);
					    break;
					}
					if(!ConvGetMainIndex(hdlg,hFile,MainIndex)) {
					    szMBFile[0] = 0;
					    lstrcpy(szSrcFile,szMBFile);
					    CloseHandle(hFile);
					    SetDlgItemText(hdlg,IDC_SRCNAME,szSrcFile);
					    SetDlgItemText(hdlg,IDC_MBNAME,szMBFile);
					    break;
					}
					{
                	DESCRIPTION Descript; //add 95.10.26

					ConvReadDescript(hFile,&Descript, MainIndex);
                    SetReconvDlgDes(hdlg,&Descript);
					}
					fnsplit(szMBFile, szStr);
					SetDlgItemText(hdlg,IDC_MBNAME,szStr);
					if((lpString = _tcsrchr(szSrcFile,TEXT('.')))!=NULL)
					    *lpString = 0;
	                lstrcat(szSrcFile, TEXT(TxtFileExt));
					SetDlgItemText(hdlg,IDC_SRCNAME,szSrcFile);
					CloseHandle(hFile);
					SetReConvEnable(hdlg);
					SendMessage(GetDlgItem(hdlg,ID_FILEOPEN),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_RECONV),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_RECONV));
				    break;

				case IDC_SRCNAME:
					GetDlgItemText(hdlg,IDC_SRCNAME,szSrcFile,MAX_PATH);
					if(lstrlen(szSrcFile) == 0) 
                        EnableWindow(GetDlgItem(hdlg,IDC_RECONV),FALSE);
                    else
                        EnableWindow(GetDlgItem(hdlg,IDC_RECONV),TRUE);
				    break;

				case IDC_GETMBFILE:
					lstrcpy((LPTSTR)lparam,szMBFile);
					break;

				case IDC_GETSRCFILE:
					lstrcpy((LPTSTR)lparam,szSrcFile);
					break;

				case IDC_RECONV:
                    lpProcInfo = MakeProcInstance((FARPROC)InfoDlg, hInst);
					pfnmsg = (PFNMSG)ReConvProc;
					bEndProp = FALSE;
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_INFO),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
					/*if(bEndProp)
					   PropSheet_PressButton(GetParent(hdlg),PSBTN_OK);*/

                    FreeProcInstance(lpProcInfo);
				    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}


VOID ReConvProc(LPVOID hWnd)
{
	static TCHAR file1[MAX_PATH]=TEXT("");
	static TCHAR file2[MAX_PATH]=TEXT("");

  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETSRCFILE,(LPARAM)file1);
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETMBFILE,(LPARAM)file2);
  	if(ConvReConv(hDlgless,file1,file2)) 
	   bEndProp=TRUE;
	SendMessage(hDlgless,WM_CLOSE,0,0L);
}

void SetReConvDisable(HWND hDlg)
{
	WORD wID;

    EnableWindow(GetDlgItem(hDlg,IDC_RECONV),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_SRCNAME),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_MBNAME),FALSE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC8 ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),FALSE);
}
    
void SetReConvEnable(HWND hDlg)
{
	WORD wID;

    EnableWindow(GetDlgItem(hDlg,IDC_RECONV),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_SRCNAME),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_MBNAME),TRUE);
	for(wID = IDC_STATIC1 ;wID <= IDC_STATIC8 ;wID++) 
        EnableWindow(GetDlgItem(hDlg,wID),TRUE);
}

void SetReconvDlgDes(HWND hDlg,LPDESCRIPTION lpDescript)
{
	TCHAR  szStr[48];

	SetDlgItemText(hDlg,IDC_IMENAME,lpDescript->szName);
	lstrcpy(szStr,lpDescript->szUsedCode);
	szStr[30]=0;
	SetDlgItemText(hDlg,IDC_USEDCODE1,szStr);
	if(lstrlen(lpDescript->szUsedCode) > 30) 
        SetDlgItemText(hDlg,IDC_USEDCODE2,&(lpDescript->szUsedCode[30]));
	else			
        SetDlgItemText(hDlg,IDC_USEDCODE2,NULL);
	szStr[0]=lpDescript->cWildChar;
	szStr[1]=0;
	SetDlgItemText(hDlg,IDC_WILDCHAR,szStr);
	SetDlgItemInt (hDlg,IDC_MAXCODES,lpDescript->wMaxCodes,FALSE);
	SetDlgItemInt (hDlg,IDC_MAXELEMENT,lpDescript->byMaxElement,FALSE);
	SetDlgItemInt (hDlg,IDC_RULENUM,lpDescript->wNumRules,FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\userdic.c ===
/*************************************************
 *  userdic.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "prop.h"
#include <stdlib.h>

/*****************************************************************************

  FUNCTION: UserDicDialogProc(HWND, UINT, WPARAM, LPARAM)

  PURPOSE:  Processes messages for "UserDic" property sheet.

  PARAMETERS:
    hdlg - window handle of the property sheet
    wMessage - type of message
    wparam - message-specific information
    lparam - message-specific information

  RETURN VALUE:
    TRUE - message handled
    FALSE - message not handled

  HISTORY:
    04-18-95 Yehfew Tie  Created.
 ****************************************************************************/


INT_PTR  CALLBACK UserDicDialogProc(HWND hdlg, 
                                                                 UINT uMessage, 
                                                                 WPARAM wparam, 
                                                                 LPARAM lparam)
{
    LPNMHDR lpnmhdr;
    static  TCHAR       DestFile[MAX_PATH];
    static  TCHAR       SrcFile [MAX_PATH];
    static  TCHAR       SysPath [MAX_PATH];
    static  DWORD       dwUserWord;
    static  LPEMB_Head  EMB_Table;
    TCHAR               wai_code[MAXCODELEN +1],cCharStr[USER_WORD_SIZE+1];
    TCHAR               szStr[MAX_PATH],   FileName[128];
    int                 nCnt, nSel, nInsWords; 
    int                 len,i;
    int                 SelItem[1000];
    static BOOL         bModify;
    static int          OldSel;
    FARPROC             lpCrtDlg;
    LPIMEKEY            lpImeKeyData;
    static DESCRIPTION  Descript;
    HANDLE              HmemEMBTmp_Table;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            SetUDMDisable(hdlg);
            len = GetSystemDirectory(SysPath,MAX_PATH);
            lstrcat(SysPath,TEXT(Slope));
            hImeKeyData = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
            sizeof(IMEKEY)*100);
            FillObjectIme(hdlg,hImeKeyData);
            lpImeKeyData = GlobalLock(hImeKeyData);
            GetImeTxtName(lpImeKeyData[0].ImeKey, FileName);
            GlobalUnlock(hImeKeyData);

            lstrcpy(DestFile, SysPath);
            lstrcat(DestFile, FileName);
            len = lstrlen(DestFile);
            DestFile[len-4]=0;
            lstrcpy(szStr, DestFile);

            lstrcat(DestFile,TEXT(EmbExt));
            lstrcat(szStr, TEXT(MbExt));
            ReadDescript(szStr,&Descript,FILE_SHARE_READ);
                        
            if (Descript.wNumRules == 0)
               EnableWindow(GetDlgItem(hdlg,IDC_AUTOCODE),FALSE);
            else
               EnableWindow(GetDlgItem(hdlg,IDC_AUTOCODE),TRUE);

            SendDlgItemMessage(hdlg,IDC_COMBO1,CB_SETCURSEL,0,0L);
            bModify = FALSE;
            OldSel = 0;
            break;

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;

            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                    hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                        NUMENCODEAREA*sizeof(ENCODEAREA));
                    if(!hEncode) 
                        ProcessError(ERR_OUTOFMEMORY,hdlg,ERR);         
                        
                    if ( hEncode )
                        ConvInitEncode(hEncode);
                    break;
                case PSN_APPLY:
                    if(bModify) {

                       LoadString(NULL, 
                                  IDS_FILEMODIFY, 
                                  FileName, 
                                  sizeof(FileName)/sizeof(TCHAR));
#ifdef UNICODE
{
                       TCHAR UniTmp[] = {0x6279, 0x91CF, 0x9020, 0x8BCD, 
                                         0x9875, 0x9762, 0x4E2D, 0x0000};

                       wsprintf(szStr,TEXT("%ws\n\'%ws\'\n%ws"),
                                UniTmp,SrcFile,FileName); 
}
#else
                       wsprintf(szStr,"ҳ\n\'%s\'\n%s"
                                ,SrcFile,FileName); 
#endif
                       if (ErrMessage(hdlg,szStr)) 
                          SendMessage(hdlg,WM_COMMAND,IDC_SAVE,0L);
                    }
                    break;
                case PSN_RESET:
                    break;
                case PSN_QUERYCANCEL:
                    break;
                case PSN_KILLACTIVE:
                    if (hEncode)
                       GlobalFree(hEncode);
                    break;

                case PSN_HELP:

                    break;
                default:
                    break;
            }

            break;

        case WM_COMMAND:

            switch (LOWORD(wparam))
            {
               case ID_FILEOPEN:
                      {
#ifdef UNICODE
                         static TCHAR szTitle[] = {0x6253, 0x5F00,0x0000};
#else
                         TCHAR szTitle[MAX_PATH];
                         lstrcpy(szTitle,"");
#endif
                         if(!TxtFileOpenDlg(hdlg,szStr,szTitle)) 
                            break;
                      }
                      lstrcpy(SrcFile,szStr);
                      ReadUserWord(hdlg,SrcFile,&dwUserWord,Descript.wMaxCodes);
                      SetUDMEnable(hdlg);
                      EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
                      fnsplit(SrcFile, szStr);
                      SetDlgItemText(hdlg,IDC_SRCNAME,szStr);
                      break;

               case IDC_COMBO1:
                      nSel = (INT)SendDlgItemMessage(hdlg,
                                                     IDC_COMBO1,
                                                     CB_GETCURSEL,
                                                     (WPARAM)0,
                                                     (LPARAM)0);

                      if(nSel == CB_ERR || nSel == OldSel) break;
                      OldSel = nSel;
                      lpImeKeyData = GlobalLock(hImeKeyData);
                      GetImeTxtName(lpImeKeyData[nSel].ImeKey, FileName);
                      GlobalUnlock(hImeKeyData);
                      lstrcpy(DestFile,SysPath);
                      lstrcat(DestFile,FileName);
                      len = lstrlen(DestFile);
                      DestFile[len-4]=0;
                      lstrcat(DestFile,TEXT(EmbExt));
                  
                      SendMessage(hdlg,WM_COMMAND,IDC_GETMBFILE,(LPARAM)szStr);
                      if(ReadDescript(szStr,&Descript,FILE_SHARE_READ) != TRUE)
                          Descript.wNumRules = 0;
                      if(Descript.wNumRules == 0)
                          EnableWindow(GetDlgItem(hdlg,IDC_AUTOCODE),FALSE);
                      else
                          EnableWindow(GetDlgItem(hdlg,IDC_AUTOCODE),TRUE);
                      break;


               case IDC_INSUSERDIC:
                      if(lstrlen(DestFile)==0) {
                          MessageBeep((UINT)-1);
                          MessageBeep((UINT)-1);
                          break;
                      }
                      nCnt=(INT)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETSELCOUNT,0,0L);
                      if(nCnt>1000) nCnt=1000;
                      SendDlgItemMessage(hdlg,
                                         IDC_LIST,
                                         LB_GETSELITEMS,
                                         nCnt, 
                                         (LPARAM)SelItem);

                      if(nCnt == 0)  {
                         MessageBeep((UINT)-1);
                         MessageBeep((UINT)-1);
                             break;
                      }
                      SendMessage(hdlg,WM_COMMAND,IDC_GETMBFILE,(LPARAM)szStr);
                      if(ReadDescript(szStr,&Descript,FILE_SHARE_READ) != TRUE)
                         break;

                      if(!ReadEMBFromFile(DestFile,EMB_Table))
                      {     
                        GlobalUnlock(HmemEMB_Table);
                        GlobalFree(HmemEMB_Table);
                        break;
                      }

                      HmemEMBTmp_Table = GlobalReAlloc(HmemEMB_Table,
                                                       1000*sizeof(EMB_Head),
                                                       GMEM_MOVEABLE);

                      if (HmemEMBTmp_Table == NULL) 
                      {
                         GlobalFree(HmemEMB_Table);
                         break;
                      }

                      HmemEMB_Table = HmemEMBTmp_Table;

                      EMB_Table = GlobalLock(HmemEMB_Table);
                                       
                      nInsWords = 0;
                      SetCursor (LoadCursor (NULL, IDC_WAIT));
                      while((--nCnt) >= 0) {
                        len = (INT)SendDlgItemMessage(hdlg,
                                                      IDC_LIST,
                                                      LB_GETTEXT,
                                                      SelItem[nCnt],
                                                      (LPARAM)szStr);
                         szStr[len]=0;
                         dwLineNo = SelItem[nCnt] + 1;
#ifdef UNICODE
                         for(i=0;i<len;i++) 
                            if(szStr[i] < 0x100)  break;
#else
                         for(i=0;i<len;i += 2) 
                             if(szStr[i] > 0)  break;
#endif
                         lstrncpy(wai_code,MAXCODELEN,&szStr[i]);
                         szStr[i]=0;
                         lstrncpy(cCharStr,USER_WORD_SIZE,szStr);
                         if(CheckCodeLegal(hdlg,cCharStr,NULL,wai_code,&Descript))
                         {
                            if(AddZCItem(DestFile,EMB_Table,wai_code,cCharStr))
                              nInsWords ++;
                         }
                         else 
                         {
                            GlobalUnlock(HmemEMB_Table);
                            GlobalFree(HmemEMB_Table);
                            break;
                         }
                      }
                      LoadString(NULL,IDS_INSWORDS,szStr,sizeof(szStr));
#ifdef UNICODE
                      _itow(nInsWords,FileName,10);
#else
                      _itoa(nInsWords,FileName,10);
#endif
                      lstrcat(szStr,FileName); 
                      InfoMessage(hdlg,szStr);
                      GlobalUnlock(HmemEMB_Table);
                      GlobalFree(HmemEMB_Table);
                      SetCursor (LoadCursor (NULL, IDC_ARROW));
                      break;

               case IDC_FULLSELECT:
                      nCnt=(INT)SendDlgItemMessage(hdlg,
                                                   IDC_LIST,
                                                   LB_GETCOUNT,
                                                   (WPARAM)0,
                                                   (LPARAM)0);
                      SendDlgItemMessage(hdlg,
                                         IDC_LIST,
                                         LB_SELITEMRANGE,
                                         TRUE,MAKELPARAM(1,nCnt));
                      break;
                                
               case IDC_AUTOCODE:
                      nCnt = (INT)SendDlgItemMessage(hdlg,
                                                     IDC_LIST,
                                                     LB_GETSELCOUNT,
                                                     (WPARAM)0,
                                                     (LPARAM)0);

                      if(nCnt > 1000) nCnt = 1000;
                      if(nCnt == 0)  {
                          MessageBeep((UINT)-1);
                          break;
                      }

                      SendDlgItemMessage(hdlg,
                                         IDC_LIST,
                                         LB_GETSELITEMS,
                                         nCnt, 
                                         (LPARAM)SelItem);

                      SendMessage(hdlg,WM_COMMAND,IDC_GETMBFILE,(LPARAM)szStr);
                      if(ReadDescript(szStr,&Descript,FILE_SHARE_READ) != TRUE)
                            Descript.wNumRules = 0;
                      if(Descript.wNumRules == 0) {
                           ProcessError(ERR_NORULE,hdlg,ERR);
                           break;
                      }
                                    
                      SetCursor (LoadCursor (NULL, IDC_WAIT));
                      nInsWords = nCnt;
                      while((--nCnt) >= 0) 
                      {
                         len = (INT)SendDlgItemMessage(hdlg,
                                                       IDC_LIST,
                                                       LB_GETTEXT,
                                                       SelItem[nCnt],
                                                       (LPARAM)FileName);
                          FileName[len]=0;
#ifdef UNICODE
                          for(i=0;i<len;i++) 
                            if(FileName[i] < 0x100)  break;
#else
                          for(i=0;i<len;i += 2) 
                            if(FileName[i] > 0)  break;
#endif
                          lstrncpy(wai_code,MAXCODELEN,&FileName[i]);
                          FileName[i]=0;
                          lstrncpy(cCharStr,USER_WORD_SIZE,FileName);
                          lstrncpy(wai_code,
                                   MAXCODELEN,
                                   ConvCreateWord(hdlg,szStr,cCharStr));

                          lstrcat(FileName,wai_code);
                          SendDlgItemMessage(hdlg,
                                             IDC_LIST,
                                             LB_DELETESTRING,
                                             SelItem[nCnt],
                                             (LPARAM)0);

                          SendDlgItemMessage(hdlg,
                                             IDC_LIST,
                                             LB_INSERTSTRING,
                                             SelItem[nCnt],
                                             (LPARAM)FileName);
                       }
                       EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                       bModify = TRUE;
                                        
                       for(i=0; i< nInsWords; i++) 
                            SendDlgItemMessage(hdlg,
                                               IDC_LIST,
                                               LB_SETSEL,
                                               TRUE,
                                               SelItem[i]);

                       SetCursor(LoadCursor(NULL, IDC_ARROW));
                       break;

                case IDC_ADD:
                       lpCrtDlg = MakeProcInstance((FARPROC)AddWordDlg, hInst);

                       DialogBox(hInst,
                                 MAKEINTRESOURCE(IDD_ADDWORD),
                                 hdlg,
                                 (DLGPROC)lpCrtDlg);

                       FreeProcInstance(lpCrtDlg);

                       nCnt=(INT)SendDlgItemMessage(hdlg,
                                                    IDC_LIST,
                                                    LB_GETCOUNT,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                       if(nCnt != 0)
                          SetUDMEnable(hdlg);
                       break;

                case IDC_ADDSTR:
                       SendDlgItemMessage(hdlg,IDC_LIST,LB_ADDSTRING,0,lparam);
                       EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                       bModify = TRUE;
                       break;

                case IDC_GETMBFILE:
                                        
                       nSel=(INT)SendDlgItemMessage(hdlg,
                                                    IDC_COMBO1,
                                                    CB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                       if(nSel==CB_ERR) break;
                       lpImeKeyData = GlobalLock(hImeKeyData);
                       GetImeTxtName(lpImeKeyData[nSel].ImeKey, FileName);
                       GlobalUnlock(hImeKeyData);

                       lstrcpy(szStr, SysPath);
                       lstrcat(szStr, FileName);
                       len = lstrlen(szStr);
                       szStr[len-4] = 0;
                       lstrcat(szStr,TEXT(MbExt));
                       lstrcpy((LPTSTR)lparam,szStr);
                       break;

                case IDC_GETUSERWORD:
                       nCnt = (INT)SendDlgItemMessage(hdlg,
                                                      IDC_LIST,
                                                      LB_GETCURSEL,
                                                      (WPARAM)0,
                                                      (LPARAM)0);

                       len = (INT)SendDlgItemMessage(hdlg,
                                                     IDC_LIST,
                                                     LB_GETTEXT,
                                                     nCnt,
                                                     (LPARAM)szStr);
                       szStr[len] = 0;
                       lstrcpy((LPTSTR)lparam,szStr);
                       break;
                                     
                case IDC_CHGDATA:
                       nCnt=(INT)SendDlgItemMessage(hdlg,
                                                    IDC_LIST,
                                                    LB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                       SendDlgItemMessage(hdlg,
                                          IDC_LIST,
                                          LB_DELETESTRING,
                                          nCnt,
                                          (LPARAM)0);

                       SendDlgItemMessage(hdlg,
                                          IDC_LIST,
                                          LB_INSERTSTRING,
                                          nCnt,
                                          lparam);

                       EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                       bModify = TRUE;
                       break;
                                     
                case IDC_MODIFY:
                       nCnt = (INT)SendDlgItemMessage(hdlg,
                                                      IDC_LIST,
                                                      LB_GETSELCOUNT,
                                                      (WPARAM)0,
                                                      (LPARAM)0);
                       if(nCnt!=1) {
                          MessageBeep((UINT)-1);
                          break;
                       }

                       SendDlgItemMessage(hdlg,
                                          IDC_LIST,
                                          LB_GETSELITEMS,
                                          nCnt, 
                                          (LPARAM)SelItem);

                       lpCrtDlg = MakeProcInstance((FARPROC)ModiWordDlg, hInst);

                       DialogBox(hInst,
                                  MAKEINTRESOURCE(IDD_MODIWORD),
                                  hdlg,
                                  (DLGPROC)lpCrtDlg);

                       FreeProcInstance(lpCrtDlg);

                       break;

                case IDC_DEL:
                       nCnt=(INT)SendDlgItemMessage(hdlg,
                                                    IDC_LIST,
                                                    LB_GETSELCOUNT,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                                        
                       if (nCnt > 1000) nCnt = 1000;
                       if (nCnt==0)  {
                           MessageBeep((UINT)-1);
                           break;
                       }
                       SendDlgItemMessage(hdlg,
                                          IDC_LIST,
                                          LB_GETSELITEMS,
                                          nCnt, 
                                          (LPARAM)SelItem);

                       SetCursor(LoadCursor(NULL, IDC_WAIT));
                       for (i=nCnt-1; i>=0; i--) 
                          SendDlgItemMessage(hdlg,
                                             IDC_LIST,
                                             LB_DELETESTRING,
                                             SelItem[i],
                                             (LPARAM)0);
                       EnableWindow(GetDlgItem(hdlg,IDC_SAVE),TRUE);
                       SetFocus(GetDlgItem(hdlg,IDC_LIST));

                       bModify = TRUE;
                       SetCursor (LoadCursor (NULL, IDC_ARROW));
                       break;

                case IDC_SAVE:
                       nCnt=(INT)SendDlgItemMessage(hdlg,IDC_LIST,LB_GETCOUNT,0,0L);
                       if(nCnt==0)  {
                             MessageBeep((UINT)-1);
                             break;
                       }
                       if(SaveTxtFileAs(hdlg,SrcFile)) {
                             EnableWindow(GetDlgItem(hdlg,IDC_SAVE),FALSE);
                             bModify = FALSE;
                       }
                       break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

INT_PTR  CALLBACK AddWordDlg(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
{
    static TCHAR szDBCS[128];
        static TCHAR szCode[13];
        static TCHAR szStr[128];
        static TCHAR szMbName[128];

    switch (message) {
        case WM_INITDIALOG:
                        SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_LIMITTEXT,USER_WORD_SIZE,0L);
                        SendDlgItemMessage(hDlg,IDC_INPUTCODE,EM_LIMITTEXT,MAXCODELEN,0L);
            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
                                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,sizeof(szDBCS)/sizeof(TCHAR));
                                    GetDlgItemText(hDlg,IDC_INPUTCODE,szCode,sizeof(szCode)/sizeof(TCHAR));
                                        if(lstrlen(szDBCS)<2||lstrlen(szCode) == 0){
                                             MessageBeep((UINT)-1);
                                                 break;
                                        }
                                        lstrcpy(szStr,szDBCS);
                                        lstrcat(szStr,szCode);
                                        SendMessage(GetParent(hDlg),WM_COMMAND,IDC_ADDSTR,(LPARAM)szStr);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);

                                case IDC_INPUTWORD:
                                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,sizeof(szDBCS)/sizeof(TCHAR));
                                        
                                        if(SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_GETMODIFY,0,0L)) {
                                            if(!CheckUserDBCS(hDlg,szDBCS)) {
                                SetDlgItemText(hDlg,IDC_INPUTWORD, szDBCS);
                                                    SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_SETMODIFY,FALSE,0L);
                                            }
                                            if(lstrlen(szDBCS)<4/sizeof(TCHAR)) {
                                szStr[0]=0;
                                SetDlgItemText(hDlg,IDC_INPUTCODE,szStr);
                                                        break;
                                            }
                        SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETMBFILE,(LPARAM)szMbName);
                                                if(lstrlen(szMbName) != 0) {
                             lstrncpy(szStr,MAXCODELEN,ConvCreateWord(hDlg,szMbName,szDBCS));
                                                     szStr[MAXCODELEN]=0;
                                                     if(lstrlen(szStr)!=0)
                                                             lstrcpy(szCode,szStr);
                             SetDlgItemText(hDlg,IDC_INPUTCODE, szCode);
                                                }
                                            SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_SETMODIFY,FALSE,0L);
                                        }
                                        break;
                                case IDC_INPUTCODE:
                                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,sizeof(szDBCS)/sizeof(TCHAR));
                                    GetDlgItemText(hDlg,IDC_INPUTCODE,szCode,sizeof(szCode)/sizeof(TCHAR));
                    if(lstrlen(szDBCS) == 0) {
                                           MessageBeep((UINT)-1);
                                           SetFocus(GetDlgItem(hDlg,IDC_INPUTWORD));
                                       break;
                                        }
                                        break;

                                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                                        break;

                                case WM_CLOSE:
                    EndDialog(hDlg, TRUE);
                                    break;
                                default:
                                    break;
            }
            break;
    }
    return (FALSE);
        UNREFERENCED_PARAMETER(lParam);
}

INT_PTR  CALLBACK ModiWordDlg(
        HWND    hDlg,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam)
{
    static TCHAR szDBCS[128];
    static TCHAR szCode[13];
    static TCHAR szStr[128];
    static TCHAR szMbName[128];
    int    len,i;

    switch (message) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_LIMITTEXT,
                               USER_WORD_SIZE,0L);
            SendDlgItemMessage(hDlg,IDC_INPUTCODE,EM_LIMITTEXT,MAXCODELEN,0L);
            SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETUSERWORD,
                        (LPARAM)szStr);
            len=lstrlen(szStr);
            for(i=0;i<len;i++) 
                 if(szStr[i] > 0)  break;
            lstrncpy(szCode,MAXCODELEN,&szStr[i]);
            szStr[i]=0;
            lstrncpy(szDBCS,USER_WORD_SIZE,szStr);
            SetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS);
            SetDlgItemText(hDlg,IDC_INPUTCODE,szCode);

            return (TRUE);

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,
                                   sizeof(szDBCS)/sizeof(TCHAR));
                    GetDlgItemText(hDlg,IDC_INPUTCODE,szCode,
                                   sizeof(szCode)/sizeof(TCHAR));
                    if(lstrlen(szDBCS)<2||lstrlen(szCode) == 0){
                         MessageBeep((UINT)-1);
                         break;
                    }
                    lstrcpy(szStr,szDBCS);
                    lstrcat(szStr,szCode);
                    SendMessage(GetParent(hDlg),WM_COMMAND,IDC_CHGDATA,0L);
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
                case IDC_INPUTWORD:
                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,
                                   sizeof(szDBCS)/sizeof(TCHAR));
                    
                    if(SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_GETMODIFY,0,0L))
                    {
                       if(!CheckUserDBCS(hDlg,szDBCS))     {
                         SetDlgItemText(hDlg,IDC_INPUTWORD, szDBCS);
                         SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_SETMODIFY,
                                            FALSE,0L);
                       }
                       if(lstrlen(szDBCS)<4/sizeof(TCHAR)) {
                            szStr[0]=0;
                            SetDlgItemText(hDlg,IDC_INPUTCODE,szStr );
                            break;
                       }
                       SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETMBFILE,
                                   (LPARAM)szMbName);
                       lstrncpy(szStr,MAXCODELEN,
                                ConvCreateWord(hDlg,szMbName,szDBCS));
                       szStr[MAXCODELEN]=0;
                       if(lstrlen(szStr)!=0)
                            lstrcpy(szCode,szStr);
                       SetDlgItemText(hDlg,IDC_INPUTCODE, szCode);
                       SendDlgItemMessage(hDlg,IDC_INPUTWORD,EM_SETMODIFY,
                                          FALSE,0L);
                    }
                    break;
               case IDC_INPUTCODE:
                    GetDlgItemText(hDlg,IDC_INPUTWORD,szDBCS,
                                   sizeof(szDBCS)/sizeof(TCHAR));
                    GetDlgItemText(hDlg,IDC_INPUTCODE,szCode,
                                   sizeof(szCode)/sizeof(TCHAR));
                    if(lstrlen(szDBCS) == 0) {
                           MessageBeep((UINT)-1);
                           SetFocus(GetDlgItem(hDlg,IDC_INPUTWORD));
                           break;
                    }
                    break;

               case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    break;

               case WM_CLOSE:
                    EndDialog(hDlg, TRUE);
                    break;
               default:
                    break;
            }
            break;
    }
    return (FALSE);
    UNREFERENCED_PARAMETER(lParam);
}

void SetUDMDisable(HWND hDlg)
{
    EnableWindow(GetDlgItem(hDlg,IDC_INSUSERDIC),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_FULLSELECT),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_AUTOCODE),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DEL) ,FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_SAVE) ,FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_LIST) ,FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_STATIC1) ,FALSE);
}

void SetUDMEnable(HWND hDlg)
{

    EnableWindow(GetDlgItem(hDlg,IDC_INSUSERDIC),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_FULLSELECT),TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DEL) ,TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_SAVE) ,TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_LIST) ,TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_STATIC1) ,TRUE);
}

void FillObjectIme(HWND hDlg, HANDLE hImeKeyData)
{
   HKEY        hImeKey=NULL,hPreImeKey=NULL,hkResult=NULL;
   WORD        wNumIme = 0;
   TCHAR       KeyName[10], LayoutName[10];
   TCHAR       LayoutText[128], FileName[MAX_PATH],SysPath[MAX_PATH];
   int         i, len, retCode;
   DWORD       DataType;
   LPIMEKEY    ImeKeyData;
   DESCRIPTION Descript;

   DWORD       dwKeyName, dwLayoutName;

   if(RegCreateKey(HKEY_CURRENT_USER,TEXT(PreImeKey),&hPreImeKey))
           return;
   if(RegCreateKey(HKEY_LOCAL_MACHINE,TEXT(ImeSubKey),&hImeKey))
           return;
   SetCursor (LoadCursor (NULL, IDC_WAIT));
   

   ImeKeyData = GlobalLock(hImeKeyData);

   for (i = 0, retCode = ERROR_SUCCESS; retCode == ERROR_SUCCESS; i++) {

        dwKeyName = sizeof(KeyName)/sizeof(TCHAR);
        dwLayoutName = sizeof(LayoutName);
        retCode = RegEnumValue(hPreImeKey, 
                               i, 
                               KeyName, 
                               &dwKeyName,
                               NULL,&DataType,
                               (LPBYTE)LayoutName,
                               &dwLayoutName);

        if (retCode == (DWORD)ERROR_SUCCESS) {
            LayoutName[dwLayoutName] = TEXT('\0');

            if ( hkResult != NULL )
                RegCloseKey(hkResult);

            if(LayoutName[0] != TEXT('E') && LayoutName[0] != TEXT('e'))
                            continue;
            if(RegOpenKey(hImeKey,LayoutName,&hkResult))
                continue;
            len = sizeof(LayoutText);
            len = RegQueryValueEx(hkResult,
                                  TEXT(LayoutTextKey),
                                  NULL,
                                  &DataType,
                                  (LPBYTE)LayoutText,
                                  &len);
            RegCloseKey(hkResult);
            if(len != ERROR_SUCCESS)  
                continue;
            GetImeTxtName(LayoutName, FileName);
            len = lstrlen(FileName);
            FileName[len-4] = 0;
            lstrcat(FileName,TEXT(MbExt));
            GetSystemDirectory(SysPath,MAX_PATH);
            lstrcat(SysPath,TEXT(Slope));
            lstrcat(SysPath, FileName);
            if(ReadDescript(SysPath,&Descript,FILE_SHARE_READ) != TRUE)
                     continue;
            SendDlgItemMessage(hDlg,IDC_COMBO1,CB_ADDSTRING,0,(LPARAM)LayoutText);
            lstrcpy(ImeKeyData[wNumIme].ImeKey, LayoutName);
            wNumIme++;
          }
    }

   RegCloseKey(hPreImeKey);
   RegCloseKey(hImeKey);
   GlobalUnlock(hImeKeyData);
   SetCursor (LoadCursor (NULL, IDC_ARROW));
}         

void GetImeTxtName(LPCTSTR ImeKeyName, LPTSTR FileName)
{

    HKEY  hImeKey,hkResult;
        int       len;
        DWORD DataType;

    FileName[0] = 0;
    if(RegCreateKey(HKEY_LOCAL_MACHINE,TEXT(ImeSubKey),&hImeKey))
        return;
    if(RegOpenKey(hImeKey,ImeKeyName,&hkResult))
        return ;
    len = 128;
    len = RegQueryValueEx(hkResult,TEXT(MbName),NULL,&DataType,(LPBYTE)FileName,&len);
    RegCloseKey(hkResult);
    RegCloseKey(hImeKey);
}         


BOOL SaveTxtFile(HWND hWnd,LPTSTR SrcFile)
{
   HANDLE hFile;
   TCHAR  szStr[256];
   int    i,nCount;
   DWORD  dwBytes;
   
   nCount=(INT)SendDlgItemMessage(hWnd,IDC_LIST,LB_GETCOUNT,0,0L);
   if(nCount==0)  {
      MessageBeep((UINT)-1);
      return FALSE;
   }

   hFile = CreateFile(SrcFile,
                      GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      CREATE_ALWAYS,
                      0,
                      NULL);

   if (hFile == (HANDLE)-1) 
        return FALSE;

   SetCursor (LoadCursor (NULL, IDC_WAIT));

   for(i=0;i<nCount;i++) {
      SendDlgItemMessage(hWnd,IDC_LIST,LB_GETTEXT,i,(LPARAM)szStr);
      lstrcat(szStr,TEXT("\r\n"));
      WriteFile(hFile,szStr,lstrlen(szStr),&dwBytes,NULL);
   }

   SetCursor (LoadCursor (NULL, IDC_ARROW));
   CloseHandle(hFile);

   return TRUE;
}

BOOL SaveEmb(HWND hWnd,LPCTSTR SrcFile)
{
   int      i,j,len;
   WORD     nCount;
   TCHAR    szStr[256];
   HANDLE   hFile;
   DWORD    dwBytes;
   EMB_Head EmbHead;
   
   nCount=(WORD)SendDlgItemMessage(hWnd,IDC_LIST,LB_GETCOUNT,0,0L);
   if(nCount==0)  {
       MessageBeep((UINT)-1);
       return FALSE;
   }

   hFile = CreateFile(SrcFile,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL);
   if(hFile==INVALID_HANDLE_VALUE) {
       ProcessError(ERR_IMEUSE, GetFocus(), ERR);
       return FALSE;
   }
   SetCursor (LoadCursor (NULL, IDC_WAIT));
   WriteFile(hFile,&nCount,2,&dwBytes,NULL);
   for(i=0;i<nCount;i++) {
       len=(INT)SendDlgItemMessage(hWnd,IDC_LIST,LB_GETTEXT,i,(LPARAM)szStr);
       szStr[len]=0;
       for(j=0;j<len;j++) 
          if(szStr[j] > 0)  break;
       lstrncpy(EmbHead.W_Code,MAXCODELEN,&szStr[j]);
       szStr[j]=0;
       lstrncpy(EmbHead.C_Char,USER_WORD_SIZE,szStr);
       WriteFile(hFile,&EmbHead,sizeof(EMB_Head),&dwBytes,NULL);
   }
   CloseHandle(hFile);
   SetCursor (LoadCursor (NULL, IDC_ARROW));
   return TRUE;
}


BOOL CheckMbUsed(HKEY hKey,HWND hWnd,LPTSTR KeyName)
{
    int    len;
    HKEY   hkResult;
    HANDLE hFile;
    DWORD  DataType;
    TCHAR  SysPath[MAX_PATH],FileName[MAX_PATH]; 
        
    if(RegOpenKey(hKey,KeyName,&hkResult))
        return FALSE;
    len = sizeof(FileName);
    len = RegQueryValueEx(hkResult,TEXT(MbName),NULL,&DataType,(LPBYTE)FileName,&len);
    RegCloseKey(hkResult);
    if(len)  return FALSE;

    len = lstrlen(FileName);
    if(len < 5)  return FALSE;
    FileName[len-4] = 0;
    lstrcat(FileName,TEXT(MbExt));
    GetSystemDirectory(SysPath,MAX_PATH);
    lstrcat(SysPath,TEXT(Slope));
    lstrcat(SysPath,FileName);
#ifdef UNICODE
    if(_waccess(SysPath,0)==0) {
#else
    if(_access(SysPath,0)==0) {
#endif
        hFile = CreateFile(SysPath,GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL);
        if(hFile==INVALID_HANDLE_VALUE) {
                ProcessError(ERR_IMEUSE,hWnd,ERR);
                return FALSE;
        }
        else
                CloseHandle(hFile);
    }
    return TRUE;
}

   
INT_PTR   CALLBACK   UDMEditProc(HWND   hWnd,
                                                          UINT   wMsgID,
                                                          WPARAM wParam,
                                                          LPARAM lParam)
{
    switch(wMsgID) {
         case WM_LBUTTONDBLCLK:
                SendMessage(GetParent(hWnd),WM_COMMAND,IDC_MODIFY,0L);
                break;

         case WM_KEYDOWN:

                switch(wParam) {
                    case VK_DELETE:
                         SendMessage(GetParent(hWnd),WM_COMMAND,IDC_DEL,0L);
                         break;
                }

        default:
            return CallWindowProc((WNDPROC)lpUDMProc,hWnd,wMsgID,wParam,lParam);
   }
   return FALSE;
} 


void InstallUDMSubClass(HWND hWnd)
{

        FARPROC lpNewProc;

        lpNewProc = MakeProcInstance(UDMEditProc,hInstance);
        lpUDMProc = (FARPROC)GetWindowLongPtr(hWnd,GWLP_WNDPROC);
        SetWindowLongPtr(hWnd,GWLP_WNDPROC,(LONG_PTR)lpNewProc);
        FreeProcInstance(lpNewProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\sortdlg.c ===
/*************************************************
 *  sortdlg.c                                    *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "prop.h"

/*****************************************************************************

  FUNCTION: SortDialogProc(HWND, UINT, WPARAM, LPARAM)

  PURPOSE:  Processes messages for "Sort" property sheet.

  PARAMETERS:
    hdlg - window handle of the property sheet
    wMessage - type of message
    wparam - message-specific information
    lparam - message-specific information

  RETURN VALUE:
    TRUE - message handled
    FALSE - message not handled

  HISTORY:
    04-18-95 Yehfew Tie  Created.
 ****************************************************************************/


INT_PTR   CALLBACK   SortDialogProc(HWND hdlg, 
						 		 UINT uMessage, 
						 		 WPARAM wparam, 
								 LPARAM lparam)
{
	static TCHAR DestFile[MAX_PATH];
	static TCHAR SrcFile [MAX_PATH];
	static TCHAR szStr   [MAX_PATH];
	FARPROC     lpProcInfo;
	HANDLE      hSrcFile;
    LPNMHDR      lpnmhdr;

    switch (uMessage)
    {
		case WM_INITDIALOG:
            EnableWindow(GetDlgItem(hdlg,IDC_RESULTNAME),FALSE);
            EnableWindow(GetDlgItem(hdlg,IDC_SORT),FALSE);
			break;
        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;

            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                    hEncode = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
                        NUMENCODEAREA*sizeof(ENCODEAREA));
                    if(!hRule ) 
                        ProcessError(ERR_OUTOFMEMORY,hdlg,ERR);		
			
                    if ( hEncode )
			            ConvInitEncode(hEncode);
                    break;

                case PSN_KILLACTIVE:
					if(hEncode)
						GlobalFree(hEncode);
                    break;
                default:
                    break;
            }

            break;


        case WM_COMMAND:

            switch (LOWORD(wparam))
            {
			    case ID_FILEOPEN:
					{

#ifdef UNICODE
					static TCHAR szTitle[] = {0x6253, 0x5F00, 0x0000};
#else
					TCHAR szTitle[MAX_PATH];
					strcpy(szTitle,"");
#endif
				    if(!TxtFileOpenDlg(hdlg,szStr,szTitle)) 
				        break;
					}
				    lstrcpy(SrcFile, szStr);
                    hSrcFile = Create_File(hdlg,SrcFile,GENERIC_READ,OPEN_EXISTING);
                    if (hSrcFile == (HANDLE)-1) {
                         EnableWindow (GetDlgItem(hdlg,IDC_RESULTNAME), FALSE);
					     SrcFile[0]=0;
					     SetDlgItemText (hdlg,IDC_SRCNAME,SrcFile);
					     lstrcpy(DestFile,SrcFile);
					     SetDlgItemText (hdlg,IDC_RESULTNAME,DestFile);
					     break;
					}
                    
                    CloseHandle(hSrcFile);
                    EnableWindow (GetDlgItem(hdlg,IDC_RESULTNAME), TRUE);
					fnsplit(SrcFile, szStr);
					SetDlgItemText(hdlg,IDC_SRCNAME,szStr);
					lstrcpy(DestFile,SrcFile);
					SetDlgItemText(hdlg,IDC_RESULTNAME,DestFile);

					SendMessage(GetDlgItem(hdlg,ID_FILEOPEN),BM_SETSTYLE,BS_PUSHBUTTON,0L);
					SendMessage(GetDlgItem(hdlg,IDC_SORT),BM_SETSTYLE,BS_DEFPUSHBUTTON,TRUE);
					SetFocus(GetDlgItem(hdlg,IDC_SORT));
				    break;

				case IDC_RESULTNAME:
					GetDlgItemText(hdlg,IDC_RESULTNAME,DestFile,32);
					if(lstrlen(DestFile) == 0) 
 	                    EnableWindow(GetDlgItem(hdlg,IDC_SORT),FALSE);
 	                else
 	                    EnableWindow(GetDlgItem(hdlg,IDC_SORT),TRUE);
				    break;

				case IDC_GETMBFILE:
					lstrcpy((LPTSTR)lparam,DestFile);
					break;

				case IDC_GETSRCFILE:
					lstrcpy((LPTSTR)lparam,SrcFile);
					break;

				case IDC_SORT:
                    lpProcInfo = MakeProcInstance((FARPROC)InfoDlg, hInst);
					pfnmsg=(PFNMSG)SortProc;
					bEndProp=FALSE;
                   	DialogBox(hInst,
                     		  MAKEINTRESOURCE(IDD_INFO),
                    		  hdlg,
                    		  (DLGPROC)lpProcInfo);
					/*(bEndProp)
					   PropSheet_PressButton(GetParent(hdlg),PSBTN_OK);*/

                    FreeProcInstance(lpProcInfo);
				    break;

                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

VOID SortProc(LPVOID hWnd)
{
	static TCHAR file1[MAX_PATH]=TEXT("");
	static TCHAR file2[MAX_PATH]=TEXT("");
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETSRCFILE,(LPARAM)file1);
  	SendMessage(GetParent(hDlgless),WM_COMMAND,IDC_GETMBFILE,(LPARAM)file2);
  	if(ConvReadFile(hDlgless,file1,file2)) 
	   bEndProp=TRUE;
	SendMessage(hDlgless,WM_CLOSE,0,0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\prop.h ===
/*************************************************
 *  prop.h                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef PROP_H
#define PROP_H
#include <windows.h>
#include <prsht.h>
#include <commdlg.h>
#include "propshet.h"
#include "conv.h"

typedef LRESULT (*PFNMSG)(HWND,UINT,WPARAM,LPARAM);

HANDLE      hDlgless;
HANDLE      hRule, hImeKeyData;
PFNMSG      pfnmsg;
BOOL        bEndProp;
FARPROC     lpConvProc,lpUDMProc,lpRegProc;
TCHAR		szRuleStr[128];

typedef struct tagImeKeyData {
    TCHAR ImeKey[10];
} IMEKEY,FAR *LPIMEKEY;

INT_PTR  CALLBACK ConvDialogProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR  CALLBACK ReConvDialogProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR  CALLBACK SortDialogProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR  CALLBACK UserDicDialogProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR  APIENTRY About(HWND, UINT, WPARAM, LPARAM);

INT_PTR  APIENTRY CopyrightProc(HWND, UINT, WPARAM, LPARAM); 

INT_PTR  CALLBACK AddWordDlg (HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK ModiWordDlg(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK ModiRuleDlg(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK AddRuleDlg(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  APIENTRY  InfoDlg(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK DispProp(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK CrtImeDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR  CALLBACK ConvEditProc(HWND, UINT, WPARAM, LPARAM); 
INT_PTR  CALLBACK UDMEditProc(HWND, UINT, WPARAM, LPARAM); 
int DoPropertySheet(HWND);

VOID ConvProc(LPVOID);
VOID ReConvProc(LPVOID);
VOID SortProc(LPVOID);

void Init_OpenFile(HWND, LPOPENFILENAME);
BOOL TxtFileOpenDlg(HWND , LPTSTR , LPTSTR );
BOOL MBFileOpenDlg(HWND , LPTSTR , LPTSTR );
BOOL RcFileOpenDlg(HWND , LPTSTR , LPTSTR );
BOOL SaveTxtFileAs(HWND , LPTSTR );
BOOL SaveTxtFile(HWND, LPTSTR);
BOOL SaveEmb(HWND ,LPCTSTR );
int  GetImeRes(HWND ,LPIMERES);


void GetDlgDescript(HWND ,LPDESCRIPTION );
void SetDlgDescript(HWND ,LPDESCRIPTION );
void SetReconvDlgDes(HWND ,LPDESCRIPTION );
void SetDlgRuleStr(HWND ,WORD ,LPRULE );
void GetDlgRule(HWND ,LPRULE ,LPWORD ,WORD );
void DelSelRule(WORD ,WORD ,LPRULE );
void SetConvDisable(HWND );
void SetConvEnable(HWND);
void SetReConvDisable(HWND );
void SetReConvEnable(HWND);
void SetUDMDisable(HWND );
void SetUDMEnable(HWND);
void FillObjectIme(HWND ,HANDLE);
void SetValue(HWND ,WORD );
void GetValue(HWND ,LPWORD );
BOOL CheckMbUsed(HKEY, HWND, LPTSTR);
void InstallConvSubClass(HWND );
void InstallUDMSubClass(HWND );
void GetImeTxtName(LPCTSTR , LPTSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres.h ===
/*************************************************
 *  upimeres.h                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#ifndef UPIMERES_H
#define UPIMERES_H

//DATA STRUCT USED IN icon resource
#define ERR_RES_INVALID_BMP		0x01
#define ERR_RES_INVALID_ICON	0x02
#define ERR_RES_INVALID_VER		0x04
#define ERR_RES_NO_BMP			0x10
#define ERR_RES_NO_ICON			0x20
#define ERR_RES_NO_VER			0x40
#define	ERR_CANNOT_UPRES		0x100


#define BMPNAME		TEXT("CHINESE")
#define ICONNAME	TEXT("IMEICO")
#define DATANAME	TEXT("IMECHARAC")

//define in imedefs.h
//these are HACK CODES, and depends on imedefs.h
#define IDS_VER_INFO            0x0350
#define IDS_ORG_NAME            0x0351

//The block's ID is the high 12 bits of the string IDs in the block plus one
#define STR_ID			(IDS_VER_INFO >> 4) + 1

//according to the file size check if it is a 20*20 bmp
#define BMP_20_SIZE		358
	
typedef struct tagICONDIRENTRY{
	BYTE	bWidth;
	BYTE	bHeight;
	BYTE	bColorCount;
	BYTE	bReserved;
	WORD	wPlanes;
	WORD	wBitCount;
	DWORD	dwBytesInRes;
	DWORD	dwImageOffset;
}ICONDIRENTRY;
typedef struct ICONDIR{
	WORD	idReserved;
	WORD	idType;
	WORD	idCount;
	ICONDIRENTRY idEntries[1];
}ICONHEADER;


#define DEFAULT_CODEPAGE    1252
#define MAJOR_RESOURCE_VERSION  4
#define MINOR_RESOURCE_VERSION  0

#define MAXSTR      (256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef   WCHAR   *PWCHAR;

typedef struct MY_STRING {
    ULONG discriminant;       // long to make the rest of the struct aligned
    union u {
        struct {
          struct MY_STRING *pnext;
          ULONG  ulOffsetToString;
          USHORT cbD;
          USHORT cb;
          TCHAR  *sz;
        } ss;
        WORD     Ordinal;
    } uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext; // The first three fields should be the
        PSDATA Name;        // same in both res structures
        ULONG   OffsetToData;

        PSDATA  Type;
        ULONG   SectionNumber;
        struct _RESNAME *pnextRes;
        ULONG   DataSize;
        ULONG   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD    LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext; // The first three fields should be the
        PSDATA Type;        // same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG   cbStringTable;
        PSDATA  StringHead;
        PRESNAME    ResHead;
        PRESTYPE    ResTypeHeadID;
        PRESTYPE    ResTypeHeadName;
        LONG    Status;
        HANDLE  hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((DWORD)(align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG      (sizeof(LONG))
#define BUFSIZE     (4L * 1024L)

//VERSION INFO related definitions
//these are HACK CODES
#define VER_ROOT			0
#define VER_STR_INFO		1
#define VER_LANG			2
#define VER_COMP_NAME		3
#define VER_FILE_DES		4
#define VER_FILE_VER		5
#define VER_INTL_NAME		6
#define VER_LEGAL_CR		7
#define VER_ORG_FILE_NAME	8
#define VER_PRD_NAME		9
#define VER_PRD_VER			10
#define VER_VAR_FILE_INFO	11
#define VER_TRANS			12

#define VER_BLOCK_NUM		13
#define VER_HEAD_LEN		0x98
#define VER_TAIL_LEN		0x44
#define VER_STR_INFO_OFF	0x5c
#define VER_LANG_OFF		0x80
#define VER_VAR_FILE_INFO_OFF 0x2c0

typedef struct tagVERDATA{
	WORD		cbBlock;
	WORD		cbValue;
	WORD		wKeyOffset;
	WORD		wKeyNameSize;
	BOOL		fUpdate;	//need update flag		
}VERDATA;


LONG
AddResource(
    PSDATA Type,
    PSDATA Name,
    WORD Language,
    PUPDATEDATA pupd,
    PVOID lpData,
    ULONG cb
    );

PSDATA
AddStringOrID(
    LPCTSTR     lp,
    PUPDATEDATA pupd
    );
    
LONG
WriteResFile(
    HANDLE  hUpdate, 
    TCHAR    *pDstname);

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    );
BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LONG lParam
    );
BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    LONG lParam
    );
BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPTSTR lpType,
    LPTSTR lpName,
    WORD language,
    LONG lParam
    );
HANDLE BeginUpdateResourceEx(LPCTSTR,BOOL);

BOOL UpdateResourceEx(HANDLE,LPCTSTR, LPCTSTR, WORD, LPVOID, DWORD);

BOOL EndUpdateResourceEx(HANDLE, BOOL);


BOOL ImeUpdateRes(LPCTSTR,LPCTSTR,LPCTSTR,LPCTSTR,LPCTSTR ,WORD);
//  ImeFilename, BitmapFilename, IconFilename, VersionString, OrgString, RcData
//  srcname: "\\c:\windows\system\Imegen.tpl"

long MakeVerInfo(LPCTSTR,LPCTSTR,LPCTSTR,BYTE *);

#endif //UPIMERES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres.c ===
/*************************************************
 *  upimeres.c                                   *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include <windows.h>            // required for all Windows applications   
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <winnls.h>
#include <winerror.h>
#include <wchar.h>
#include   "upimeres.h"
#ifdef UNICODE
TCHAR ERR_INVALID_BMP_MSG[] = {0x975E, 0x6CD5, 0x0042, 0x0049, 0x0054, 0x004D, 0x0041, 0x0050, 0x6587, 0x4EF6, 0x002C, 0x0020, 0x9009, 0x7528, 0x7CFB, 0x7EDF, 0x0042, 0x0049, 0x0054, 0x004D, 0x0041, 0x0050, 0x3002, 0x0000};
TCHAR ERR_INVALID_ICON_MSG[] = { 0x975E, 0x6CD5, 0x0049, 0x0043, 0x004F, 0x004E, 0x6587, 0x4EF6, 0x002C, 0x0020, 0x9009, 0x7528, 0x7CFB, 0x7EDF, 0x0049, 0x0043, 0x004F, 0x004E, 0x3002, 0x0000};
TCHAR ERR_NO_BMP_MSG[] = { 0x9009, 0x7528, 0x7CFB, 0x7EDF, 0x0042, 0x0049, 0x0054, 0x004D, 0x0041, 0x0050, 0x3002, 0x0000};
TCHAR ERR_NO_ICON_MSG[] = { 0x9009, 0x7528, 0x7CFB, 0x7EDF, 0x0049, 0x0043, 0x004F, 0x004E, 0x3002, 0x0000};
TCHAR ERR_CANNOT_UPRES_MSG[] = {0x65E0, 0x6CD5, 0x751F, 0x6210, 0x8F93, 0x5165, 0x6CD5, 0xFF01, 0x0000};
TCHAR MSG_TITLE[] = {0x8B66, 0x544A, 0x0000};
#else
#define	ERR_INVALID_BMP_MSG				"ǷBITMAPļ, ѡϵͳBITMAP"
#define ERR_INVALID_ICON_MSG			"ǷICONļ, ѡϵͳICON"
#define ERR_NO_BMP_MSG					"ѡϵͳBITMAP"
#define ERR_NO_ICON_MSG					"ѡϵͳICON"
#define ERR_CANNOT_UPRES_MSG			"޷뷨"
#define MSG_TITLE	""
#endif //UNICODE
typedef TCHAR UNALIGNED FAR *LPUNATCHAR;
extern HWND HwndCrtImeDlg;
WORD GenWideName(LPCTSTR pszSBName, TCHAR *lpVerString)
{
	WORD length;

#ifdef UNICODE
	lstrcpy(lpVerString, pszSBName);
	length = (WORD)lstrlen(lpVerString);
#else
	length= (WORD)MultiByteToWideChar(CP_ACP, 0, pszSBName, lstrlen(pszSBName), lpVerString, sizeof(lpVerString)/sizeof(TCHAR));
#endif

	return length+1;        //end with zero
}

long MakeVerInfo(
LPCTSTR pszImeFileName,
LPCTSTR pszOrgName,
LPCTSTR pszImeName,
BYTE    *lpResData
)
{
BYTE    *pVerData, *pOldVerData;        
TCHAR   lpwImeFileName[128], lpwOrgName[128], lpwImeName[128];
HGLOBAL hResData;
WORD    length;
signed int      difflen,newlen,i,l;
VERDATA ImeVerData[VER_BLOCK_NUM] = {
	{0x0304, 0x0034, 0x0004, 0x0024, FALSE},
	{0x0262, 0x0000, 0x0060, 0x0020, FALSE},
	{0x023e, 0x0000, 0x0084, 0x0014, FALSE},
	{0x004c, 0x0016, 0x009c, 0x001c, TRUE},
	{0x0040, 0x000c, 0x00e8, 0x0024, TRUE},
	{0x0032, 0x0009, 0x0128, 0x001c, FALSE},
	{0x0038, 0x000c, 0x015c, 0x001c, TRUE},
	{0x0080, 0x002e, 0x0194, 0x0020, FALSE},
	{0x003e, 0x000b, 0x0214, 0x0024, TRUE},
	{0x0038, 0x000c, 0x0254, 0x001c, TRUE},
	{0x0036, 0x0009, 0x028c, 0x0020, FALSE},
	{0x0044, 0x0000, 0x02c4, 0x001c, FALSE},
	{0x0024, 0x0004, 0x02e4, 0x001c, FALSE},
};


	memset(lpwOrgName, 0, 128);
	memset(lpwImeName, 0, 128);
	memset(lpwImeFileName, 0, 128);

	//REPLACE CompanyName string
	length = GenWideName(pszOrgName, lpwOrgName);
	ImeVerData[VER_COMP_NAME].cbValue = length;
	ImeVerData[VER_COMP_NAME].cbBlock = 
			ImeVerData[VER_COMP_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace FileDescription string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_FILE_DES].cbValue = length;
	ImeVerData[VER_FILE_DES].cbBlock = 
			ImeVerData[VER_FILE_DES].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace InternalName string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_INTL_NAME].cbValue = length;
	ImeVerData[VER_INTL_NAME].cbBlock = 
			ImeVerData[VER_INTL_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace OriginalFileName string
	length = GenWideName(pszImeFileName, lpwImeFileName);
	ImeVerData[VER_ORG_FILE_NAME].cbValue = length;
	ImeVerData[VER_ORG_FILE_NAME].cbBlock = 
			ImeVerData[VER_ORG_FILE_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace ProductName string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_PRD_NAME].cbValue = length;
	ImeVerData[VER_PRD_NAME].cbBlock = 
			ImeVerData[VER_PRD_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//begin writeback all data
	//we assume the size of ver will never over 0x400
	pVerData = malloc(0x400);

    if ( pVerData == NULL )
    {
        return 0;
    }

	memset(pVerData, 0, 0x400);
    hResData = LoadResource(NULL, FindResource(NULL,TEXT("VERDATA"), RT_RCDATA));

    if ( hResData == NULL )
    {
       free(pVerData);
       return 0;
    }

	pOldVerData = LockResource(hResData);

    if ( pOldVerData == NULL )
    {
       free(pVerData);
       UnlockResource(hResData);
       return 0;
    }

	l = VER_HEAD_LEN;
	memcpy(&pVerData[0],&pOldVerData[0], VER_HEAD_LEN); 
	for( i = VER_COMP_NAME; i < VER_VAR_FILE_INFO; i++){
		memcpy(&pVerData[l], &ImeVerData[i].cbBlock, sizeof(WORD));
		l+=sizeof(WORD);
		memcpy(&pVerData[l], &ImeVerData[i].cbValue, sizeof(WORD));
		l+=sizeof(WORD);
		memcpy(&pVerData[l], &pOldVerData[(ImeVerData[i].wKeyOffset)],ImeVerData[i].wKeyNameSize);
		l+=ImeVerData[i].wKeyNameSize;
		if(ImeVerData[i].fUpdate){
			switch(i){
				case VER_FILE_DES:
				case VER_INTL_NAME:
				case VER_PRD_NAME:
					memcpy(&pVerData[l], lpwImeName, lstrlen(lpwImeName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
				case VER_COMP_NAME:
					memcpy(&pVerData[l], lpwOrgName, lstrlen(lpwOrgName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
				case VER_ORG_FILE_NAME:
					memcpy(&pVerData[l], lpwImeFileName, lstrlen(lpwImeFileName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
			}
		}else{
				memcpy(&pVerData[l],
					&pOldVerData[ImeVerData[i].wKeyOffset+ImeVerData[i].wKeyNameSize],
					ImeVerData[i].cbValue*sizeof(WCHAR));
				l+=ImeVerData[i].cbValue*sizeof(WCHAR);
		}
		difflen = REMAINDER(l, CBLONG);
		l += difflen;
	}
	newlen = l - VER_STR_INFO_OFF - difflen;
	memcpy(&pVerData[VER_STR_INFO_OFF], &newlen, sizeof(WORD));

	newlen = l - VER_LANG_OFF - difflen;
	memcpy(&pVerData[VER_LANG_OFF], &newlen, sizeof(WORD));

	memcpy(&pVerData[l],&pOldVerData[VER_VAR_FILE_INFO_OFF], VER_TAIL_LEN); 
	l+= VER_TAIL_LEN;
	memcpy(&pVerData[0], &l, sizeof(WORD));

	memcpy(lpResData, pVerData, l);

    UnlockResource(hResData);

	return ImeVerData[VER_ROOT].cbBlock;
}

BOOL UpdateImeBmp(
LPCTSTR pszImeDesName,          //destination IME file name
LPCTSTR pszImeBmpName,          //Bitmap file name
HANDLE hUpdateRes)
{
HFILE  imagefh = HFILE_ERROR;
OFSTRUCT OpenBuf;
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize;

	error = NO_ERROR;
	if(pszImeBmpName == NULL || lstrlen(pszImeBmpName) == 0){        //prepare for update bitmap
		error = ERR_RES_NO_BMP;
		goto END_ERROR;
	}else{

#ifdef UNICODE
        //
        // Because OpenFile( ) accepts only PSTR as its first parameter.
        // so we must convert this unicode string to Multi Byte String
        //

        CHAR   pszImeBmpNameA[MAX_PATH];

        WideCharToMultiByte(CP_ACP, 
                            0, 
                            pszImeBmpName, 
                            -1, 
                            pszImeBmpNameA, 
                            MAX_PATH, 
                            NULL, 
                            NULL);

        imagefh = (HFILE)OpenFile( pszImeBmpNameA, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);
        

#else
		imagefh = (HFILE)OpenFile( pszImeBmpName, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);

#endif

		if(imagefh == HFILE_ERROR){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR; //go on next resource update
		}

		ResDataSize = GetFileSize((HANDLE)ULongToPtr((DWORD)imagefh),NULL);
		
		//according to the file size check if it is a 20*20 bmp
		if(ResDataSize != BMP_20_SIZE){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR;
		}

		ResDataSize -= sizeof(BITMAPFILEHEADER);
		
		if(_llseek(imagefh, sizeof(BITMAPFILEHEADER), 0)!=sizeof(BITMAPFILEHEADER)){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR; //go on next resource update
		}
		if(_lread(imagefh, lpResData, ResDataSize)!=ResDataSize){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR; //go on next resource update
		}

		result = UpdateResource(hUpdateRes,       /* update resource handle     */
			RT_BITMAP,                   /* change bitmap resource */
			BMPNAME,                  /* bitmap name            */
			MAKELANGID(LANG_CHINESE,
		SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
		lpResData,                   /* ptr to resource info       */
		ResDataSize); /* size of resource info.     */
		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}

	}

END_ERROR:
	if(imagefh != HFILE_ERROR)
		_lclose(imagefh);
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_BMP:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_INVALID_BMP_MSG, MSG_TITLE, MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_RES_NO_BMP:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_NO_BMP_MSG, MSG_TITLE, MB_OK | MB_ICONINFORMATION);
			return TRUE;
//              case ERROR_NOT_ENOUGH_MEMORY:
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_CANNOT_UPRES_MSG, MSG_TITLE, MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}

BOOL UpdateImeIcon(
LPCTSTR pszImeDesName,          //destination IME file name
LPCTSTR pszImeIconName,         //Bitmap file name
HANDLE hUpdateRes)
{
HFILE  imagefh = HFILE_ERROR;
OFSTRUCT OpenBuf;
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize,i;
	
	//begin update ICON file
	error = NO_ERROR;
	if(pszImeIconName==NULL || lstrlen(pszImeIconName) ==0){
		error = ERR_RES_NO_ICON;
		goto END_ERROR;
	}else{
		ICONHEADER IconHeader;
		ICONDIRENTRY IconDirEntry;
#ifdef UNICODE
        //
        // Because OpenFile( ) accepts only PSTR as its first parameter.
        // so we must convert this unicode string to Multi Byte String
        //

        CHAR   pszImeIconNameA[MAX_PATH];

        WideCharToMultiByte(CP_ACP,
                            0,
                            pszImeIconName,
                            -1,
                            pszImeIconNameA,
                            MAX_PATH,
                            NULL,
                            NULL);

        imagefh = (HFILE)OpenFile( pszImeIconNameA, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);

#else
		imagefh = (HFILE)OpenFile( pszImeIconName, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);

#endif

        if(imagefh == HFILE_ERROR){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		ResDataSize =  sizeof(ICONDIRENTRY)+3*sizeof(WORD);
		if(_llseek(imagefh, 0, 0) != 0 ){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR; //go on next resource update
		}
		memset(&IconHeader, 0, ResDataSize);
		if(_lread(imagefh, &IconHeader, 3*sizeof(WORD))!=3*sizeof(WORD)){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_lread(imagefh, &IconHeader.idEntries[0], sizeof(ICONDIRENTRY))!=sizeof(ICONDIRENTRY)){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(IconHeader.idEntries[0].bWidth == 16 && IconHeader.idEntries[0].bHeight == 16){
			IconHeader.idCount = 0;
			IconDirEntry = IconHeader.idEntries[0];
		}
		for(i=1;i<IconHeader.idCount;i++){
			if(_lread(imagefh,&IconDirEntry, sizeof(ICONDIRENTRY))!=sizeof(ICONDIRENTRY)){
				error = ERR_RES_INVALID_ICON;
				goto END_ERROR;
			}
			if(IconDirEntry.bWidth == 16 && IconDirEntry.bHeight == 16){
				IconHeader.idCount = 0;
				break;
			}
		}
		if(IconHeader.idCount > 0){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_llseek(imagefh, IconDirEntry.dwImageOffset, 0)!=(LONG)(IconDirEntry.dwImageOffset) ){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_lread(imagefh, lpResData, IconDirEntry.dwBytesInRes)!=IconDirEntry.dwBytesInRes){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}

		result = UpdateResource(hUpdateRes,       /* update resource handle     */
	     RT_ICON,                   /* change dialog box resource */
	     MAKEINTRESOURCE(2),                  /* icon name , we have to use 2 instead of "IMEICO" */
	     MAKELANGID(LANG_CHINESE,
	                           SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
	     lpResData,                   /* ptr to resource info       */
	     IconDirEntry.dwBytesInRes); /* size of resource info.     */
		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	if(imagefh != HFILE_ERROR)
	{
		_lclose(imagefh);
	}
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_ICON:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_INVALID_ICON_MSG, MSG_TITLE, MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_RES_NO_ICON:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_NO_ICON_MSG, MSG_TITLE, MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_CANNOT_UPRES_MSG, MSG_TITLE, MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}               
	
BOOL UpdateImeVerInfo(
LPCTSTR pszImeDesName,
LPCTSTR pszImeVerInfo,
LPCTSTR pszImeDevCorpName,
HANDLE hUpdateRes)
{
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize;
int cch;
LPTSTR p;

	error = NO_ERROR;
	//begin update version info
	if(pszImeVerInfo ==NULL || lstrlen(pszImeVerInfo)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}
	cch = lstrlen(pszImeDesName);
	p = (LPTSTR)pszImeDesName + (INT_PTR)cch;
	while ((*(LPUNATCHAR)p) != TEXT('\\') && p >= pszImeDesName)
		p--;
	p++;
	//we assume the size of ver will never over 0x400
	ResDataSize = MakeVerInfo(p,pszImeDevCorpName,pszImeVerInfo, lpResData);
	if(error == NO_ERROR){
		result = UpdateResource(hUpdateRes,       /* update resource handle     */
	     RT_VERSION,                              /* change version resource    */
	     MAKEINTRESOURCE(VS_VERSION_INFO),        /* dialog box name            */
	     MAKELANGID(LANG_CHINESE,
		 SUBLANG_CHINESE_SIMPLIFIED),              /* neutral language ID        */
	     lpResData,                                /* ptr to resource info       */
	     ResDataSize);                             /* size of resource info.     */

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			//SHOW MSG
			return TRUE;
		case ERR_RES_NO_VER:
			//SHOW MSG
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_CANNOT_UPRES_MSG, MSG_TITLE, MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}
BOOL UpdateImeStr(
LPCTSTR pszImeDesName,
LPCTSTR pszImeVerInfo,
LPCTSTR pszImeDevCorpName,
HANDLE hUpdateRes)
{
    BOOL     result;
    WORD     error;
    TCHAR    lpwImeVerInfo[128], lpwImeDevCorpName[128], lpwImeMBName[128];
    WORD     length;
    BYTE     lpBuff[0x200];
    TCHAR    name[20],*p;
    INT_PTR  cbResSize;
    int      cch;

	error = NO_ERROR;
	//begin update version info
	if(pszImeVerInfo ==NULL || lstrlen(pszImeVerInfo)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}

	if(pszImeDevCorpName ==NULL || lstrlen(pszImeDevCorpName)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}

	if(error == NO_ERROR){
		memset(lpBuff, 0, 0x200);
		cbResSize = 0;

		//write in IDS_VER_INFO
		length = (WORD)lstrlen(pszImeVerInfo);
#ifdef UNICODE
		lstrcpy(lpwImeVerInfo, pszImeVerInfo);
#else
		length = (WORD)MultiByteToWideChar(CP_ACP, 
                                           0, 
                                           pszImeVerInfo, 
                                           lstrlen(pszImeVerInfo), 
                                           lpwImeVerInfo,
                                           length*sizeof(WCHAR));
#endif
		memcpy((BYTE *)lpBuff, &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)(lpBuff+cbResSize), 
               (BYTE *)lpwImeVerInfo, 
               length*sizeof(WCHAR));

		cbResSize += length*sizeof(WCHAR);

		//write in IDS_ORG_NAME
		length = (WORD)lstrlen(pszImeDevCorpName);
#ifdef UNICODE
		lstrcpy(lpwImeDevCorpName, pszImeDevCorpName);
#else
		length = (WORD)MultiByteToWideChar(936, 
                                           0, 
                                           pszImeDevCorpName, 
                                           lstrlen(pszImeDevCorpName),
                                           lpwImeDevCorpName, 
                                           length*sizeof(WCHAR));
#endif
		memcpy((BYTE *)(lpBuff+cbResSize), &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)(lpBuff+cbResSize), 
               (BYTE *)lpwImeDevCorpName, 
               length*sizeof(WCHAR));
		cbResSize += length*sizeof(WCHAR);

		//write in IDS_IMEMBFILENAME
		cch = lstrlen(pszImeDesName);
		p = (LPTSTR)pszImeDesName+cch;
		while (*p != TEXT('\\') && p >= pszImeDesName)
			p--;
		p++;
		lstrcpy(name, p);
		p = name;
		while(*p != TEXT('.') && *p != TEXT('\0'))
			p++;
		lstrcpy(p, TEXT(".MB"));
		length = (WORD)lstrlen(name);
#ifdef UNICODE
		lstrcpy(lpwImeMBName, name);
#else
		length = (WORD)MultiByteToWideChar(936, 
                                           0, 
                                           name, 
                                           lstrlen(name), 
                                           lpwImeMBName, 
                                           length*sizeof(WCHAR));
#endif
		memcpy((BYTE *)(lpBuff+cbResSize), &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)(lpBuff+cbResSize), 
                        (BYTE *)lpwImeMBName, 
                        length*sizeof(WCHAR));
		cbResSize += length*sizeof(WCHAR);
		memcpy((BYTE *)(lpBuff+cbResSize), &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)(lpBuff+cbResSize),
               (BYTE *)lpwImeMBName, 
               length*sizeof(WCHAR));

		cbResSize += length*sizeof(WCHAR);

		result = UpdateResource(hUpdateRes, // update resource handle  
	                            RT_STRING,  // change version resource 
	                            MAKEINTRESOURCE(STR_ID),    // dialog box name
	                            MAKELANGID(LANG_CHINESE,
		                        SUBLANG_CHINESE_SIMPLIFIED),//neutrallanguage ID
	                            (LPVOID)lpBuff, // ptr to resource info   
	                            (LONG)cbResSize);     // size of resource info.

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			return TRUE;
		case ERR_RES_NO_VER:
			return TRUE;
		case ERR_CANNOT_UPRES:
			MessageBox(HwndCrtImeDlg,
                       ERR_CANNOT_UPRES_MSG, 
                       MSG_TITLE, 
                       MB_OK|MB_ICONSTOP);

			return FALSE;
		default:
			MessageBox(HwndCrtImeDlg,
                       ERR_CANNOT_UPRES_MSG, 
                       MSG_TITLE, 
                       MB_OK|MB_ICONSTOP);

			return FALSE;
	}
}

//UPDATE ImeInitData
BOOL UpdateImeInitData(
LPCTSTR pszImeDesName,
WORD    wImeData,
HANDLE hUpdateRes)
{
BOOL result;
WORD error;

	error = NO_ERROR;

	if(error == NO_ERROR){
		result = UpdateResource(hUpdateRes,       /* update resource handle     */
	     RT_RCDATA,                   /* change version resource */
	     DATANAME,                  /* dialog box name            */
	     MAKELANGID(LANG_CHINESE,
		 SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
	     (LPVOID)&wImeData,                   /* ptr to resource info       */
	     sizeof(WORD)); /* size of resource info.     */

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			//SHOW MSG
			return TRUE;
		case ERR_RES_NO_VER:
			//SHOW MSG
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(HwndCrtImeDlg,ERR_CANNOT_UPRES_MSG, MSG_TITLE, MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}

BOOL ImeUpdateRes(
LPCTSTR pszImeDesName,          //destination IME file name
LPCTSTR pszImeBmpName,          //Bitmap file name
LPCTSTR pszImeIconName,         //Icon file name
LPCTSTR pszImeVerInfo,          //version infomation string
LPCTSTR pszImeDevCorpName,      //Ime inventer corp/person name
WORD    wImeData                        //Ime initial data
){
HANDLE hUpdateRes;  /* update resource handle            */

	if(pszImeDesName == NULL || lstrlen(pszImeDesName)==0){
		return FALSE;
	}

	hUpdateRes = BeginUpdateResource(pszImeDesName, FALSE);
	if(hUpdateRes ==NULL){
		return FALSE;
	}

	if(!UpdateImeBmp(pszImeDesName,pszImeBmpName,hUpdateRes))
		return FALSE;            
	if(!UpdateImeIcon(pszImeDesName,pszImeIconName,hUpdateRes))
		return FALSE;
	if(!UpdateImeVerInfo(pszImeDesName,pszImeVerInfo,pszImeDevCorpName,hUpdateRes))
		return FALSE;
	if(!UpdateImeStr(pszImeDesName,pszImeVerInfo,pszImeDevCorpName,hUpdateRes))
		return FALSE;
	if(!UpdateImeInitData(pszImeDesName,wImeData,hUpdateRes))
		return FALSE;
	if (!EndUpdateResource(hUpdateRes, FALSE)) {
		return FALSE;
	}
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\prop.c ===
/*************************************************
 *  prop.c                                       *
 *                                               *
 *  Copyright (C) 1995-1999 Microsoft Inc.       *
 *                                               *
 *************************************************/

#include "prop.h"
#ifdef UNICODE
TCHAR   szPropCrtIME[]={0x521B, 0x5EFA, 0x8F93, 0x5165, 0x6CD5, 0x0000};
TCHAR   szPropReconv[]={0x9006, 0x8F6C, 0x6362, 0x0000};
TCHAR   szPropSort[]={0x8BCD, 0x6761, 0x6392, 0x5E8F, 0x0000};
TCHAR   szPropCrtWord[]={0x6279, 0x91CF, 0x9020, 0x8BCD, 0x0000};
TCHAR   szPropAbout[]={0x7248, 0x672C, 0x4FE1, 0x606F, 0x0000};
#else
BYTE    szPropCrtIME[]="뷨";
BYTE    szPropReconv[]="ת";
BYTE    szPropSort[]="";
BYTE    szPropCrtWord[]="";
BYTE    szPropAbout[]="汾Ϣ";

#endif

#ifdef UNICODE
extern TCHAR szCaption[];
#else
extern BYTE szCaption[];
#endif


/****************************************************************************

  FUNCTION: DoPropertySheet(HWND)

  PURPOSE: Fills out the property sheet data structures and displays
	   the dialog with the property sheets.

  PARAMETERS:

    hwndOwner  - Parent window handle of the property sheets

  RETURN VALUE:

    Returns value from PropertySheet()

  History:
    04-17-95 Yehfew Tie (л) Created.
  COMMENTS:
 ****************************************************************************/

int DoPropertySheet(HWND hwndOwner)
{
    PROPSHEETPAGE psp[NUMPROPSHEET];
    PROPSHEETHEADER psh;

    //Fill out the PROPSHEETPAGE data structure for the MB Conv Sheet

    psp[PROP_CRTIME].dwSize = sizeof(PROPSHEETPAGE);
    psp[PROP_CRTIME].dwFlags = PSP_USETITLE;
    psp[PROP_CRTIME].hInstance = hInst;
    psp[PROP_CRTIME].pszTemplate = MAKEINTRESOURCE(IDD_CONV);
    psp[PROP_CRTIME].pszIcon = NULL;
    psp[PROP_CRTIME].pfnDlgProc = ConvDialogProc;
    psp[PROP_CRTIME].pszTitle = szPropCrtIME;
    psp[PROP_CRTIME].lParam = 0;

    //Fill out the PROPSHEETPAGE data structure for the MB ReConv Sheet

    psp[PROP_RECONV].dwSize = sizeof(PROPSHEETPAGE);
    psp[PROP_RECONV].dwFlags = PSP_USETITLE;
    psp[PROP_RECONV].hInstance = hInst;
    psp[PROP_RECONV].pszTemplate = MAKEINTRESOURCE(IDD_RECONV);
    psp[PROP_RECONV].pszIcon = NULL;
    psp[PROP_RECONV].pfnDlgProc = ReConvDialogProc;
    psp[PROP_RECONV].pszTitle = szPropReconv;
    psp[PROP_RECONV].lParam = 0;

    //Fill out the PROPSHEETPAGE data structure for the MB Sort Sheet

    psp[PROP_SORT].dwSize = sizeof(PROPSHEETPAGE);
    psp[PROP_SORT].dwFlags = PSP_USETITLE;
    psp[PROP_SORT].hInstance = hInst;
    psp[PROP_SORT].pszTemplate = MAKEINTRESOURCE(IDD_SORT);
    psp[PROP_SORT].pszIcon = NULL;
    psp[PROP_SORT].pfnDlgProc = SortDialogProc;
    psp[PROP_SORT].pszTitle = szPropSort;
    psp[PROP_SORT].lParam = 0;

    //Fill out the PROPSHEETPAGE data structure for the MB CrtWord Sheet

    psp[PROP_CRTWORD].dwSize = sizeof(PROPSHEETPAGE);
    psp[PROP_CRTWORD].dwFlags = PSP_USETITLE;
    psp[PROP_CRTWORD].hInstance = hInst;
    psp[PROP_CRTWORD].pszTemplate = MAKEINTRESOURCE(IDD_USERDIC);
    psp[PROP_CRTWORD].pszIcon = NULL;
    psp[PROP_CRTWORD].pfnDlgProc = UserDicDialogProc;
    psp[PROP_CRTWORD].pszTitle = szPropCrtWord;
    psp[PROP_CRTWORD].lParam = 0;

    //Fill out the PROPSHEETPAGE data structure for the MB Register Sheet

    psp[PROP_ABOUT].dwSize = sizeof(PROPSHEETPAGE);
    psp[PROP_ABOUT].dwFlags = PSP_USEICONID | PSP_USETITLE;
    psp[PROP_ABOUT].hInstance = hInst;
    psp[PROP_ABOUT].pszTemplate = MAKEINTRESOURCE(IDD_COPYRIGHT);
    psp[PROP_ABOUT].pszIcon = MAKEINTRESOURCE(IDI_IMEGEN);
    psp[PROP_ABOUT].pfnDlgProc = About;
    psp[PROP_ABOUT].pszTitle = szPropAbout;
    psp[PROP_ABOUT].lParam = 0;

    //Fill out the PROPSHEETHEADER

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID|PSH_PROPTITLE| PSH_PROPSHEETPAGE ;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hInst;
    psh.pszIcon = MAKEINTRESOURCE(IDI_IMEGEN);
    psh.pszCaption = szCaption;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) psp;

    //And finally display the dialog with the two property sheets.

   return (PropertySheet (&psh) != -1);
}

/****************************************************************************

    FUNCTION: About(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for "About" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

****************************************************************************/

INT_PTR APIENTRY About(
	HWND   hDlg,
	UINT   message,
	WPARAM wParam,
	LPARAM lParam)
{
    switch (message) {
	case WM_INITDIALOG:
	    return (TRUE);

	case WM_COMMAND:
	    if (LOWORD(wParam) == IDOK) {
		EndDialog(hDlg, TRUE);
		return (TRUE);
	    }
	    break;
    }
    return (FALSE);
	UNREFERENCED_PARAMETER(lParam);
}

/****************************************************************************

    FUNCTION: Info_box(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for "InfoDlg" dialog box

    MESSAGES:

	WM_INITDIALOG - initialize dialog box
	WM_COMMAND    - Input received

****************************************************************************/

INT_PTR APIENTRY InfoDlg(
	HWND   hDlg,
	UINT   message,
	WPARAM wParam,
	LPARAM lParam)
{
	static HANDLE hThread;
    DWORD dwThreadId;
    HWND  HwndThrdParam;
#ifdef UNICODE
	static TCHAR UniTmp[] = {0x662F, 0x5426, 0x53D6, 0x6D88, 0xFF1F, 0x0000};
#endif
	
    switch (message) {
	case WM_INITDIALOG:
		    hDlgless=hDlg;
			HwndThrdParam=hDlg;
			hThread = CreateThread(NULL,
				  0,
				  (LPTHREAD_START_ROUTINE)pfnmsg,
				  &HwndThrdParam,
				  0,
				  &dwThreadId);
			if(hThread == NULL)
			     EndDialog(hDlg,TRUE);
	    break;

	case WM_COMMAND:
	    switch(LOWORD(wParam)) {
	       case IDCANCEL:
				   SuspendThread(hThread);
#ifdef UNICODE
				   if(MessageBox(hDlg,
				  UniTmp,
				  szCaption,
				  MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2) != IDYES){
#else
				   if(MessageBox(hDlg,
				  "Ƿȡ",
				  szCaption,
				  MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2) != IDYES){
#endif
						ResumeThread(hThread);
						break;
					}
				{BY_HANDLE_FILE_INFORMATION FileInfo;
					if(hMBFile){
						GetFileInformationByHandle(hMBFile, &FileInfo);
						CloseHandle(hMBFile);
//to be done                                            DeleteFile(FileInfo);
					}
					if(hSRCFile){
						GetFileInformationByHandle(hSRCFile, &FileInfo);
						CloseHandle(hSRCFile);
//to be done                                            DeleteFile(FileInfo);
					}
					if(hCmbFile){
						GetFileInformationByHandle(hCmbFile, &FileInfo);
						CloseHandle(hCmbFile);
//to be done                                            DeleteFile(FileInfo);
					}
				}
			       TerminateThread(hThread,0);
			       CloseHandle(hThread);
			       EndDialog(hDlg,TRUE);
			       hDlgless=0;
				   bEndProp=TRUE;
		   return 0;
	    }    
			   
	    break;
		case WM_CLOSE:
			CloseHandle(hThread);
			EndDialog(hDlg,TRUE);
			hDlgless=0;
	    return 0;
    }
    return (FALSE);
	UNREFERENCED_PARAMETER(lParam);
}

/*
INT_PTR  CALLBACK DispProp(
	HWND    hDlg,
	UINT    message,
	WPARAM  wParam,
	LPARAM  lParam)
{
#ifdef UNICODE
	static TCHAR MbName[]={0x7801, 0x8868, 0x6587, 0x4EF6, 0x540D, 0x0000};
	static TCHAR Slope[]=TEXT("\\");
	static TCHAR SubKey[]={0x0053, 0x006F, 0x0066, 0x0074, 0x0057, 0x0061, 0x0072, 0x0065, 0x005C, 0x004D, 0x0069, 0x0063, 0x0072, 0x006F, 0x0073, 0x006F, 0x0066, 0x0074, 0x005C, 0x0057, 0x0069, 0x006E, 0x0064, 0x006F, 0x0077, 0x0073, 0x005C, 0x0043, 0x0075, 0x0072, 0x0072, 0x0065, 0x006E, 0x0074, 0x0056, 0x0065, 0x0072, 0x0073, 0x0069, 0x006F, 0x006E, 0x005C, 0x901A, 0x7528, 0x7801, 0x8868, 0x8F93, 0x5165, 0x6CD5, 0x0000};
#else    
	static TCHAR MbName[]=TEXT("ļ");
	static TCHAR Slope[]=TEXT("\\");
	static TCHAR SubKey[]=TEXT("SoftWare\\Microsoft\\Windows\\CurrentVersion\\ͨ뷨");
#endif
	char        szStr[MAX_PATH],SysPath[MAX_PATH];
	DESCRIPTION Descript;
	HKEY        hKey,hSubKey;
	LPRULE     lpRule;
	HANDLE      hRule0;
	int         nSelect;

    switch (message) {
	case WM_INITDIALOG:
			SendMessage(GetParent(hDlg),WM_COMMAND,IDC_GETMBFILE,(LPARAM)szStr);
	    if(RegOpenKey(HKEY_CURRENT_USER,SubKey,&hKey))
				  break;
			RegOpenKey(hKey,szStr,&hSubKey);
			QueryKey(hDlg,hSubKey);
	    nSelect=sizeof(szStr);
	    if(RegQueryValueEx(hSubKey,TEXT(MbName),NULL,NULL,szStr,&nSelect))
				  break;
	    RegCloseKey(hSubKey);
			GetSystemDirectory(SysPath,MAX_PATH);
			lstrcat(SysPath,TEXT(Slope));
			lstrcat(SysPath,szStr);
	    if(ReadDescript(SysPath,&Descript,FILE_SHARE_READ)!=TRUE) {
				  ProcessError(ERR_IMEUSE,hDlg,ERR);
		  SendMessage(hDlg,WM_COMMAND,WM_CLOSE,0L);
				  break;
			}
	    SetReconvDlgDes(hDlg,&Descript);
			hRule0= GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,
				sizeof(RULE)*12);
	    if(!(lpRule = GlobalLock(hRule0)) )  {
		  ProcessError(ERR_GLOBALLOCK,hDlg,ERR);
				  if(!hRule0)
				      GlobalFree(hRule0);
				  break;
			}
			if(ReadRule(hDlg,SysPath,Descript.wNumRules,lpRule))
			{
			      SetDlgRuleStr(hDlg,Descript.wNumRules,lpRule);
			      GlobalFree(hRule0);
				  break;
			}
			GlobalFree(hRule0);
	    break;

	case WM_COMMAND:
	    switch(LOWORD(wParam)) {

		case IDOK:
		    EndDialog(hDlg, TRUE);
		    return (TRUE);

				case IDCANCEL:
				case WM_CLOSE:
		    EndDialog(hDlg, TRUE);
					return (TRUE);

				default:
				    break;
	    }
	    break;
    }
    return (FALSE);
	UNREFERENCED_PARAMETER(lParam);
}*/

void Init_OpenFile(HWND hWnd,LPOPENFILENAME ofn)
{

   ofn->hwndOwner = hWnd;
   ofn->lStructSize = sizeof(OPENFILENAME);
   ofn->lpstrCustomFilter = NULL;
   ofn->nMaxCustFilter = 0;
   ofn->nFilterIndex = 1;
   ofn->nMaxFile = 256;
   ofn->nMaxFileTitle = 256;
   ofn->lpstrInitialDir = NULL;
   ofn->lpstrTitle = NULL;
   ofn->Flags = OFN_ALLOWMULTISELECT;//PATHMUSTEXIST;
   ofn->nFileOffset = 0;
   ofn->nFileExtension = 0;
   ofn->lCustData = 0L;
   ofn->lpfnHook = NULL;
   ofn->lpTemplateName = NULL;
}

BOOL TxtFileOpenDlg(HWND hWnd, LPTSTR lpFileName, LPTSTR lpTitleName) 
{

   OPENFILENAME    ofn;
#ifdef UNICODE
   static TCHAR  szFilter[]={
0x7801, 0x8868, 0x539F, 0x6587, 0x4EF6, 0x005B, 0x002A, 0x002E, 0x0074, 0x0078, 0x0074, 0x005D, 0x0000, 0x002A, 0x002E, 0x0074, 0x0078, 0x0074, 0x0000, 0x6240, 0x6709, 0x6587, 0x4EF6, 0x005B, 0x002A, 0x002E, 0x002A, 0x005D, 0x0000, 0x002A, 0x002E, 0x002A, 0x0000, 0x0000};
#else
   static TCHAR  szFilter[]="ԭļ[*.txt]\0*.txt\0ļ[*.*]\0*.*\0\0";
#endif
   Init_OpenFile(hWnd,&ofn);
   lstrcpy(lpFileName,TEXT("*.txt"));
   ofn.lpstrInitialDir   = NULL;
   ofn.lpstrFile =lpFileName;
   ofn.lpstrFileTitle = NULL;//lpTitleName;
   ofn.lpstrTitle = lpTitleName;
   ofn.lpstrCustomFilter = NULL;
   ofn.lpstrFilter = szFilter;           
   ofn.lpstrDefExt = TEXT("txt");
   ofn.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
   ofn.nFilterIndex   = 1;
   ofn.lpTemplateName = NULL;
   ofn.lpfnHook       = NULL;

   
   if (!GetOpenFileName(&ofn))
       return 0L;
   return TRUE;
}
   
BOOL MBFileOpenDlg(HWND hWnd, LPTSTR lpFileName, LPTSTR lpTitleName) 
{
   OPENFILENAME    ofn;
#ifdef UNICODE
   static TCHAR  szFilter[] = {
0x7801, 0x8868, 0x6587, 0x4EF6, 0x005B, 0x002A, 0x002E, 0x006D, 0x0062, 0x005D, 0x0000, 0x002A, 0x002E, 0x006D, 0x0062, 0x0000, 0x6240, 0x6709, 0x6587, 0x4EF6, 0x005B, 0x002A, 0x002E, 0x002A, 0x005D, 0x0000, 0x002A, 0x002E, 0x002A, 0x0000, 0x0000};
#else
   static BYTE szFilter[]="ļ[*.mb]\0*.mb\0ļ[*.*]\0*.*\0\0";
#endif
   Init_OpenFile(hWnd,&ofn);
   lstrcpy(lpFileName,TEXT("*.mb"));
   ofn.lpstrFile = lpFileName;
   ofn.lpstrFileTitle = NULL;
   ofn.lpstrFilter = szFilter;           
   ofn.lpstrDefExt = TEXT("mb");
   ofn.lpstrTitle = NULL;//lpTitleName;
   ofn.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
   ofn.nFilterIndex   = 1;
   ofn.lpTemplateName = NULL;
   ofn.lpfnHook       = NULL;

   if (!GetOpenFileName(&ofn))
       return 0L;
   return TRUE;
}
   
BOOL RcFileOpenDlg(HWND hWnd, LPTSTR lpFileName, LPTSTR lpTitleName) 
{
   OPENFILENAME    ofn;
#ifdef UNICODE
   static TCHAR szFilter[]={
0x8D44, 0x6E90, 0x6587, 0x4EF6, 0x005B, 0x002A, 0x002E, 0x0069, 0x0063, 0x006F, 0x002C, 0x002A, 0x002E, 0x0062, 0x006D, 0x0070, 0x003B, 0x002A, 0x002E, 0x0068, 0x006C, 0x0070, 0x005D, 0x0000, 0x002A, 0x002E, 0x0062, 0x006D, 0x0070, 0x003B, 0x002A, 0x002E, 0x0069, 0x0063, 0x006F, 0x003B, 0x002A, 0x002E, 0x0068, 0x006C, 0x0070, 0x0000, 0x0000};
#else   
   static BYTE szFilter[]="Դļ[*.ico,*.bmp;*.hlp]\0*.bmp;*.ico;*.hlp\0\0";
#endif
   Init_OpenFile(hWnd,&ofn);
   lstrcpy(lpFileName,TEXT("*.ico;*.bmp;*.hlp"));
   ofn.lpstrFile = lpFileName;
   ofn.lpstrFileTitle = NULL;//lpTitleName;
   ofn.lpstrFilter = szFilter;           
   ofn.lpstrDefExt = TEXT("ico");
   ofn.lpstrTitle = lpTitleName;
   ofn.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
   ofn.nFilterIndex   = 1;
   ofn.lpTemplateName = NULL;
   ofn.lpfnHook       = NULL;

   if (!GetOpenFileName(&ofn))
       return 0L;
   return TRUE;
}
   

BOOL SaveTxtFileAs(HWND hwnd, LPTSTR szFilename) {
    OPENFILENAME ofn;
    TCHAR szFile[256], szFileTitle[256];
#ifdef UNICODE
    static TCHAR szFilter[] = {
0x7801, 0x8868, 0x539F, 0x6587, 0x4EF6, 0x0028, 0x002A, 0x002E, 0x0074, 0x0078, 0x0074, 0x0029, 0x0000, 0x002A, 0x002E, 0x0074, 0x0078, 0x0074, 0x0000, 0x0000};
    TCHAR UniTmp[] = {0x53E6, 0x5B58, 0x4E3A, 0x0000};
#else
    static BYTE szFilter[] = TEXT("ԭļ(*.txt)\0*.txt\0\0");
#endif
    lstrcpy(szFile, TEXT("*.txt\0"));
    Init_OpenFile(hwnd,&ofn);

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFilename;
    ofn.lpstrFileTitle = szFileTitle;
#ifdef UNICODE
    ofn.lpstrTitle = UniTmp;
#else
    ofn.lpstrTitle = "Ϊ";
#endif
    ofn.lpstrDefExt = NULL;
    if (!GetSaveFileName(&ofn)) 
	return 0L;

	return (SaveTxtFile(hwnd,szFilename));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres\useres.c ===
#include <windows.h>            // required for all Windows applications   
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <winnls.h>
#include "upimeres.h"
void main()
{
//	if(ImeUpdateRes("C:\\WINPY.IME", "", "", "ҵǿ뷨 汾1.0000", "Ц÷", 0x0f))
	if(ImeUpdateRes("C:\\WINPY.dll", "C:\\NEW.BMP", "C:\\NEW.ICO", "ҵǿ뷨 汾1.0000", "Ц÷", 0x0f))
//	if(ImeUpdateRes("C:\\WINPPY.IME", "C:\\NEW.BMP", "C:\\NEW.ICO", "뷨ģ 汾2.0", "Microsoft Corporation", 0))
		exit(0);
	else
		exit(-1);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by new.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres\upimeres.c ===
#include <windows.h>            // required for all Windows applications   
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <winnls.h>
#include <winerror.h>
#include   "upimeres.h"

WORD GenWideName(
LPCTSTR pszSBName,
WCHAR *lpVerString
)
{
WORD length;

length=strlen(pszSBName);
length= MultiByteToWideChar(936, 0, pszSBName, strlen(pszSBName), lpVerString, length*sizeof(WCHAR));

return length+1;	//end with zero

}
long MakeVerInfo(
LPCTSTR	pszImeFileName,
LPCTSTR pszOrgName,
LPCTSTR pszImeName,
BYTE 	*lpResData
)
{
BYTE	*pVerData, *pOldVerData;	
WCHAR 	lpwImeFileName[128], lpwOrgName[128], lpwImeName[128];
HGLOBAL hResData;
WORD	length;
signed int	difflen,newlen,i,l;
VERDATA	ImeVerData[VER_BLOCK_NUM] = {
	{0x0304, 0x0034, 0x0004, 0x0024, FALSE},
	{0x0262, 0x0000, 0x0060, 0x0020, FALSE},
	{0x023e, 0x0000, 0x0084, 0x0014, FALSE},
	{0x004c, 0x0016, 0x009c, 0x001c, TRUE},
	{0x0040, 0x000c, 0x00e8, 0x0024, TRUE},
	{0x0032, 0x0009, 0x0128, 0x001c, FALSE},
	{0x0038, 0x000c, 0x015c, 0x001c, TRUE},
	{0x0080, 0x002e, 0x0194, 0x0020, FALSE},
	{0x003e, 0x000b, 0x0214, 0x0024, TRUE},
	{0x0038, 0x000c, 0x0254, 0x001c, TRUE},
	{0x0036, 0x0009, 0x028c, 0x0020, FALSE},
	{0x0044, 0x0000, 0x02c4, 0x001c, FALSE},
	{0x0024, 0x0004, 0x02e4, 0x001c, FALSE},
};


	memset(lpwOrgName, 0, 128);
	memset(lpwImeName, 0, 128);
	memset(lpwImeFileName, 0, 128);

	//REPLACE CompanyName string
	length = GenWideName(pszOrgName, lpwOrgName);
	ImeVerData[VER_COMP_NAME].cbValue = length;
	ImeVerData[VER_COMP_NAME].cbBlock = 
			ImeVerData[VER_COMP_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace FileDescription string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_FILE_DES].cbValue = length;
	ImeVerData[VER_FILE_DES].cbBlock = 
			ImeVerData[VER_FILE_DES].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace InternalName string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_INTL_NAME].cbValue = length;
	ImeVerData[VER_INTL_NAME].cbBlock = 
			ImeVerData[VER_INTL_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace OriginalFileName string
	length = GenWideName(pszImeFileName, lpwImeFileName);
	ImeVerData[VER_ORG_FILE_NAME].cbValue = length;
	ImeVerData[VER_ORG_FILE_NAME].cbBlock = 
			ImeVerData[VER_ORG_FILE_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//replace ProductName string
	length = GenWideName(pszImeName, lpwImeName);
	ImeVerData[VER_PRD_NAME].cbValue = length;
	ImeVerData[VER_PRD_NAME].cbBlock = 
			ImeVerData[VER_PRD_NAME].wKeyNameSize +
			length*sizeof(WCHAR) + 2*sizeof(WORD);

	//begin writeback all data
	//we assume the size of ver will never over 0x400
	pVerData = malloc(0x400);
	memset(pVerData, 0, 0x400);
    hResData = LoadResource(NULL, FindResource(NULL,"VERDATA", RT_RCDATA));
	pOldVerData = LockResource(hResData);
	l = VER_HEAD_LEN;
	memcpy(&pVerData[0],&pOldVerData[0], VER_HEAD_LEN); 
	for( i = VER_COMP_NAME; i < VER_VAR_FILE_INFO; i++){
		memcpy(&pVerData[l], &ImeVerData[i].cbBlock, sizeof(WORD));
		l+=sizeof(WORD);
		memcpy(&pVerData[l], &ImeVerData[i].cbValue, sizeof(WORD));
		l+=sizeof(WORD);
		memcpy(&pVerData[l], &pOldVerData[(ImeVerData[i].wKeyOffset)],ImeVerData[i].wKeyNameSize);
		l+=ImeVerData[i].wKeyNameSize;
		if(ImeVerData[i].fUpdate){
			switch(i){
				case VER_FILE_DES:
				case VER_INTL_NAME:
				case VER_PRD_NAME:
					memcpy(&pVerData[l], lpwImeName, wcslen(lpwImeName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
				case VER_COMP_NAME:
					memcpy(&pVerData[l], lpwOrgName, wcslen(lpwOrgName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
				case VER_ORG_FILE_NAME:
					memcpy(&pVerData[l], lpwImeFileName, wcslen(lpwImeFileName)*sizeof(WCHAR));
					l+=ImeVerData[i].cbValue*sizeof(WCHAR);
					break;
			}
		}else{
				memcpy(&pVerData[l],
					&pOldVerData[ImeVerData[i].wKeyOffset+ImeVerData[i].wKeyNameSize],
					ImeVerData[i].cbValue*sizeof(WCHAR));
				l+=ImeVerData[i].cbValue*sizeof(WCHAR);
		}
		difflen = REMAINDER(l, CBLONG);
		l += difflen;
	}
	newlen = l - VER_STR_INFO_OFF - difflen;
	memcpy(&pVerData[VER_STR_INFO_OFF], &newlen, sizeof(WORD));

	newlen = l - VER_LANG_OFF - difflen;
	memcpy(&pVerData[VER_LANG_OFF], &newlen, sizeof(WORD));

	memcpy(&pVerData[l],&pOldVerData[VER_VAR_FILE_INFO_OFF], VER_TAIL_LEN); 
	l+= VER_TAIL_LEN;
	memcpy(&pVerData[0], &l, sizeof(WORD));

	memcpy(lpResData, pVerData, l);

    UnlockResource(hResData);

	return ImeVerData[VER_ROOT].cbBlock;
}

BOOL UpdateImeBmp(
LPCTSTR	pszImeDesName,		//destination IME file name
LPCTSTR	pszImeBmpName,		//Bitmap file name
HANDLE hUpdateRes)
{
HFILE  imagefh;
OFSTRUCT OpenBuf;
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize;

	error = NO_ERROR;
	if(pszImeBmpName == NULL || strlen(pszImeBmpName) == 0){	//prepare for update bitmap
		error = ERR_RES_NO_BMP;
		goto END_ERROR;
	}else{
		imagefh = (HFILE)OpenFile( pszImeBmpName, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);
		if(imagefh == -1){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR;	//go on next resource update
		}

		ResDataSize = GetFileSize((HANDLE)imagefh,NULL);
		
		//according to the file size check if it is a 20*20 bmp
		if(ResDataSize != BMP_20_SIZE){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR;
		}

		ResDataSize -= sizeof(BITMAPFILEHEADER);
		
		if(_llseek(imagefh, sizeof(BITMAPFILEHEADER), 0)!=sizeof(BITMAPFILEHEADER)){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR;	//go on next resource update
		}
		if(_lread(imagefh, lpResData, ResDataSize)!=ResDataSize){
			error = ERR_RES_INVALID_BMP;
			goto END_ERROR;	//go on next resource update
		}

		result = UpdateResourceEx(hUpdateRes,       /* update resource handle     */
        	   	RT_BITMAP,                   /* change bitmap resource */
           		BMPNAME,                  /* bitmap name            */
           		MAKELANGID(LANG_CHINESE,
                SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
            	lpResData,                   /* ptr to resource info       */
             	ResDataSize); /* size of resource info.     */
		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}

	}

END_ERROR:
	if(imagefh>0)
		_lclose(imagefh);
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_BMP:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_INVALID_BMP_MSG), TEXT(MSG_TITLE), MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_RES_NO_BMP:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_NO_BMP_MSG), TEXT(MSG_TITLE), MB_OK | MB_ICONINFORMATION);
			return TRUE;
//		case ERROR_NOT_ENOUGH_MEMORY:
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_CANNOT_UPRES_MSG), TEXT(MSG_TITLE), MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}

BOOL UpdateImeIcon(
LPCTSTR	pszImeDesName,		//destination IME file name
LPCTSTR	pszImeIconName,		//Bitmap file name
HANDLE hUpdateRes)
{
HFILE  imagefh;
OFSTRUCT OpenBuf;
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize,i;
	
	//begin update ICON file
	error = NO_ERROR;
	if(pszImeIconName==NULL || strlen(pszImeIconName) ==0){
		error = ERR_RES_NO_ICON;
		goto END_ERROR;
	}else{
		ICONHEADER IconHeader;
		ICONDIRENTRY IconDirEntry;

		imagefh = (HFILE)OpenFile( pszImeIconName, &OpenBuf, OF_READ | OF_SHARE_EXCLUSIVE);
		if(imagefh == -1){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		ResDataSize =  sizeof(ICONDIRENTRY)+3*sizeof(WORD);
		if(_llseek(imagefh, 0, 0) != 0 ){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;	//go on next resource update
		}
		memset(&IconHeader, 0, ResDataSize);
		if(_lread(imagefh, &IconHeader, 3*sizeof(WORD))!=3*sizeof(WORD)){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_lread(imagefh, &IconHeader.idEntries[0], sizeof(ICONDIRENTRY))!=sizeof(ICONDIRENTRY)){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(IconHeader.idEntries[0].bWidth == 16 && IconHeader.idEntries[0].bHeight == 16){
			IconHeader.idCount = 0;
			IconDirEntry = IconHeader.idEntries[0];
		}
		for(i=1;i<IconHeader.idCount;i++){
			if(_lread(imagefh,&IconDirEntry, sizeof(ICONDIRENTRY))!=sizeof(ICONDIRENTRY)){
				error = ERR_RES_INVALID_ICON;
				goto END_ERROR;
			}
			if(IconDirEntry.bWidth == 16 && IconDirEntry.bHeight == 16){
				IconHeader.idCount = 0;
				break;
			}
		}
		if(IconHeader.idCount > 0){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_llseek(imagefh, IconDirEntry.dwImageOffset, 0)!=IconDirEntry.dwImageOffset){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}
		if(_lread(imagefh, lpResData, IconDirEntry.dwBytesInRes)!=IconDirEntry.dwBytesInRes){
			error = ERR_RES_INVALID_ICON;
			goto END_ERROR;
		}

		result = UpdateResourceEx(hUpdateRes,       /* update resource handle     */
             RT_ICON,                   /* change dialog box resource */
             MAKEINTRESOURCE(2),                  /* icon name , we have to use 2 instead of "IMEICO" */
             MAKELANGID(LANG_CHINESE,
                 SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
             lpResData,                   /* ptr to resource info       */
             IconDirEntry.dwBytesInRes); /* size of resource info.     */
		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	if(imagefh>0)
		_lclose(imagefh);
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_ICON:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_INVALID_ICON_MSG), TEXT(MSG_TITLE), MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_RES_NO_ICON:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_NO_ICON_MSG), TEXT(MSG_TITLE), MB_OK | MB_ICONINFORMATION);
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_CANNOT_UPRES_MSG), TEXT(MSG_TITLE), MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}		
	
BOOL UpdateImeVerInfo(
LPCTSTR	pszImeDesName,
LPCTSTR	pszImeVerInfo,
LPCTSTR	pszImeDevCorpName,
HANDLE hUpdateRes)
{
BOOL result;
WORD error;
BYTE lpResData[0x2000];
ULONG ResDataSize;
int cch;
LPTSTR p;

	error = NO_ERROR;
	//begin update version info
	if(pszImeVerInfo ==NULL || strlen(pszImeVerInfo)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}
	cch = strlen(pszImeDesName);
	p = (LPBYTE)pszImeDesName + cch;
	while (*p != '\\' && p >= pszImeDesName)
	   	p--;
	p++;
	//we assume the size of ver will never over 0x400
	ResDataSize = MakeVerInfo(p,pszImeDevCorpName,pszImeVerInfo, lpResData);
	if(error == NO_ERROR){
		result = UpdateResourceEx(hUpdateRes,       /* update resource handle     */
             RT_VERSION,                   /* change version resource */
             MAKEINTRESOURCE(VS_VERSION_INFO),                  /* dialog box name            */
             MAKELANGID(LANG_CHINESE,
                 SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
             lpResData,                   /* ptr to resource info       */
             ResDataSize); /* size of resource info.     */

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			//SHOW MSG
			return TRUE;
		case ERR_RES_NO_VER:
			//SHOW MSG
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_CANNOT_UPRES_MSG), TEXT(MSG_TITLE), MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}
BOOL UpdateImeStr(
LPCTSTR	pszImeDesName,
LPCTSTR	pszImeVerInfo,
LPCTSTR	pszImeDevCorpName,
HANDLE hUpdateRes)
{
BOOL result;
WORD error;
WCHAR 	lpwImeVerInfo[128], lpwImeDevCorpName[128], lpwImeMBName[128];
WORD length;
BYTE lpBuff[0x200],*p;
char name[20];
LONG cbResSize;
int cch;

	error = NO_ERROR;
	//begin update version info
	if(pszImeVerInfo ==NULL || strlen(pszImeVerInfo)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}

 	if(pszImeDevCorpName ==NULL || strlen(pszImeDevCorpName)==0){
		error = ERR_RES_NO_VER;
		goto END_ERROR;
	}

	if(error == NO_ERROR){
		memset(lpBuff, 0, 0x200);
		cbResSize = 0;

		//write in IDS_VER_INFO
		length = strlen(pszImeVerInfo);
		length = MultiByteToWideChar(936, 0, pszImeVerInfo, strlen(pszImeVerInfo), lpwImeVerInfo, length*sizeof(WCHAR));
		memcpy((BYTE *)lpBuff, &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)((LONG)lpBuff+cbResSize), (BYTE *)lpwImeVerInfo, length*sizeof(WCHAR));
		cbResSize += length*sizeof(WCHAR);

		//write in IDS_ORG_NAME
		length = strlen(pszImeDevCorpName);
		length = MultiByteToWideChar(936, 0, pszImeDevCorpName, strlen(pszImeDevCorpName), lpwImeDevCorpName, length*sizeof(WCHAR));
		memcpy((BYTE *)((LONG)lpBuff+cbResSize), &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)((LONG)lpBuff+cbResSize), (BYTE *)lpwImeDevCorpName, length*sizeof(WCHAR));
		cbResSize += length*sizeof(WCHAR);

		//write in IDS_IMEMBFILENAME
		cch = strlen(pszImeDesName);
		p = (LPBYTE)pszImeDesName+cch;
		while (*p != '\\' && p >= pszImeDesName)
	   		p--;
		p++;
		strcpy(name, p);
		p = name;
		while(*p != '.' && *p != '\0')
			p++;
		strcpy(p, ".MB");
		length = strlen(name);
		length = MultiByteToWideChar(936, 0, name, strlen(name), lpwImeMBName, length*sizeof(WCHAR));
		memcpy((BYTE *)((LONG)lpBuff+cbResSize), &length, sizeof(WORD));
		cbResSize += sizeof(WORD);
		memcpy((BYTE *)((LONG)lpBuff+cbResSize), (BYTE *)lpwImeMBName, length*sizeof(WCHAR));
		cbResSize += length*sizeof(WCHAR);

		result = UpdateResourceEx(hUpdateRes,       /* update resource handle     */
             RT_STRING,                   /* change version resource */
             MAKEINTRESOURCE(STR_ID),                  /* dialog box name            */
             MAKELANGID(LANG_CHINESE,
                 SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
             (LPVOID)lpBuff,                   /* ptr to resource info       */
             cbResSize); /* size of resource info.     */

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			//SHOW MSG
			return TRUE;
		case ERR_RES_NO_VER:
			//SHOW MSG
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_CANNOT_UPRES_MSG), TEXT(MSG_TITLE), MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}

//UPDATE ImeInitData
BOOL UpdateImeInitData(
LPCTSTR	pszImeDesName,
WORD	wImeData,
HANDLE hUpdateRes)
{
BOOL result;
WORD error;

	error = NO_ERROR;

	if(error == NO_ERROR){
		result = UpdateResourceEx(hUpdateRes,       /* update resource handle     */
             RT_RCDATA,                   /* change version resource */
             DATANAME,                  /* dialog box name            */
             MAKELANGID(LANG_CHINESE,
                 SUBLANG_CHINESE_SIMPLIFIED),        /* neutral language ID        */
             (LPVOID)&wImeData,                   /* ptr to resource info       */
             sizeof(WORD)); /* size of resource info.     */

		if(!result){
			error = ERR_CANNOT_UPRES;
			goto END_ERROR;
		}
	}
		
END_ERROR:
	switch(error){
		case NO_ERROR:
			return TRUE;
		case ERR_RES_INVALID_VER:
			//SHOW MSG
			return TRUE;
		case ERR_RES_NO_VER:
			//SHOW MSG
			return TRUE;
		case ERR_CANNOT_UPRES:
		default:
			//SHOW MSG
			MessageBox(NULL,TEXT(ERR_CANNOT_UPRES_MSG), TEXT(MSG_TITLE), MB_OK|MB_ICONSTOP);
			return FALSE;
	}
}

BOOL ImeUpdateRes(
LPCTSTR	pszImeDesName,		//destination IME file name
LPCTSTR	pszImeBmpName,		//Bitmap file name
LPCTSTR	pszImeIconName,		//Icon file name
LPCTSTR	pszImeVerInfo,		//version infomation string
LPCTSTR pszImeDevCorpName,	//Ime inventer corp/person name
WORD	wImeData			//Ime initial data
){
HANDLE hUpdateRes;  /* update resource handle            */

	if(pszImeDesName == NULL || strlen(pszImeDesName)==0){
		return FALSE;
	}

	hUpdateRes = BeginUpdateResourceEx(pszImeDesName, FALSE);
	if(hUpdateRes ==NULL){
		return FALSE;
	}

	if(!UpdateImeBmp(pszImeDesName,pszImeBmpName,hUpdateRes))
		return FALSE;            
	if(!UpdateImeIcon(pszImeDesName,pszImeIconName,hUpdateRes))
		return FALSE;
	if(!UpdateImeVerInfo(pszImeDesName,pszImeVerInfo,pszImeDevCorpName,hUpdateRes))
		return FALSE;
	if(!UpdateImeStr(pszImeDesName,pszImeVerInfo,pszImeDevCorpName,hUpdateRes))
		return FALSE;
	if(!UpdateImeInitData(pszImeDesName,wImeData,hUpdateRes))
		return FALSE;
	if (!EndUpdateResourceEx(hUpdateRes, FALSE)) {
		return FALSE;
	}
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\feime\chs\ntgen\upimeres\updr16.c ===
/****************************************************************************

    PROGRAM: updr16.cpp

    PURPOSE: Contains API Entry points and routines for updating resource
	sections in exe/dll
					   
    FUNCTIONS:

    EndUpdateResource(HANDLE, BOOL)     - end update, write changes
    UpdateResource(HANDLE, LPSTR, LPSTR, WORD, PVOID)
			- update individual resource
    BeginUpdateResource(LPSTR)      - begin update

    16 Bit version to update win32 binaries [alessanm] - 26/07/1993

	Changed Rtl* fns to use combination of far & huge heap. 
	Added mem-use reporting fns; grep MEM_STATISTICS. [MikeCo] - 8/17/1994
	
	Port to 32-bit and used for Win95 IME Generator, ouput as an .OBJ -
	v-guanx 8/15/1995
		delete HUGE & far
		HPUCHAR ==> BYTE *
*******************************************************************************/

//#include <afxwin.h>
#include <windows.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <stdio.h>
//#include "iodll.h"
#include "upimeres.h"
//#include "..\nls\nls16.h" V-GUANX 95/8/15

long error;
#define cbPadMax    16L
 static char     *pchPad = "PADDINGXXPADDING";
 static char     *pchZero = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";

#ifndef _X86_
#define HEAP_ZERO_MEMORY 0
#endif

DWORD   gdwLastError = 0L;  // we will have a global variable to remember the last error
//extern UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength);
//extern UINT _WCSTOMBS( CHAR * pszOut, WCHAR * pwszIn, UINT nOutLength, UINT nInLength = -1);
//v-guanx static UINT CopyFile( char * pszfilein, char * pszfileout );

//#define MEM_STATISTICS
#ifdef MEM_STATISTICS
static void RtlRecordAlloc(DWORD cb);
static void RtlRecordFree();
static void RtlInitStatistics();
static void RtlReportStatistics();
#endif

static BOOL gbReportDupRes;	   // whether to report duplicate resources


/****************************************************************************
**
** API entry points
**
****************************************************************************/


/****************************************************************************
    BeginUpdateResourceW:

    This is a reduced version of the original NT API.

    We accept only a call with the parameter bDeleteExistingResource==TRUE.
    We force this parameter to be TRUE so we haven't to call the LoadLibrary
    API. We don't want call this API to alowed the succesfull update of loaded
    modules 

****************************************************************************/
HANDLE BeginUpdateResourceEx(
    LPCTSTR pwch,
    BOOL bDeleteExistingResources
    )
{
    PUPDATEDATA pUpdate;
    HANDLE  hUpdate;
    LPTSTR  pFileName;
	HMODULE	hModule;
#ifdef MEM_STATISTICS
	RtlInitStatistics();
#endif

	gbReportDupRes = TRUE;

    SetLastError(0);
    hUpdate = GlobalAlloc(GHND, sizeof(UPDATEDATA));
   	if (hUpdate == NULL) {
   		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
   	}
   	pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
   	if (pUpdate == NULL) {
   		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
   	}

    pUpdate->hFileName = GlobalAlloc(GHND, strlen(pwch)+1);
    if (pUpdate->hFileName == NULL) {
		GlobalUnlock(hUpdate);
    	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
    }
    pFileName = (LPTSTR)GlobalLock(pUpdate->hFileName);
    if (pFileName == NULL) {
		GlobalUnlock(hUpdate);
    	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return NULL;
    }
    strcpy(pFileName, pwch);
    GlobalUnlock(pUpdate->hFileName);

    if (bDeleteExistingResources)
		pUpdate->Status = NO_ERROR;
    else {
	    if (pwch != NULL)
			hModule = LoadLibrary(pwch);
    	else
			hModule = NULL;
		error = GetLastError();
    	if (pwch != NULL && hModule == NULL) {
			GlobalUnlock(hUpdate);
			GlobalFree(hUpdate);
			return NULL;
    	}
    	else
			EnumResourceTypes(hModule, (ENUMRESTYPEPROC)EnumTypesFunc, (LONG)pUpdate);
    	FreeLibrary(hModule);
//v-guanx	pUpdate->Status = ERROR_NOT_IMPLEMENTED;
    }
    
    if (pUpdate->Status != NO_ERROR) {
    	GlobalUnlock(hUpdate);
    	GlobalFree(hUpdate);
		return NULL;
    }

    GlobalUnlock(hUpdate);
    return hUpdate;
}

BOOL UpdateResourceEx(
    HANDLE  hUpdate,
    LPCTSTR      lpType,
    LPCTSTR      lpName,
    WORD    language,
    LPVOID  lpData,
    ULONG   cb
    )
{
    PUPDATEDATA pUpdate;
    PSDATA  Type;
    PSDATA  Name;
    PVOID   lpCopy;
    LONG    fRet;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    Name = AddStringOrID(lpName, pUpdate);
    if (Name == NULL) {
		pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
		GlobalUnlock(hUpdate);
    	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
    }
    Type = AddStringOrID(lpType, pUpdate);
    if (Type == NULL) {
		pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
		GlobalUnlock(hUpdate);
    	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
    }
    
//v-guanx    lpCopy = RtlAllocateHeap(RtlProcessHeap(), 0, cb);
	lpCopy = malloc(cb);
    if (lpCopy == NULL) {
		pUpdate->Status = ERROR_NOT_ENOUGH_MEMORY;
		GlobalUnlock(hUpdate);
    	SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    	return FALSE;
    }
	memset(lpCopy, 0, cb);
    memcpy(lpCopy, lpData, cb);
     fRet = AddResource(Type, Name, language, pUpdate, lpCopy, cb);
    GlobalUnlock(hUpdate);
    if (fRet == NO_ERROR)
    return TRUE;
    else {
    	SetLastError(fRet);
//v-guanx    	RtlFreeHeap(RtlProcessHeap(), 0, lpData);
		if(lpCopy!=NULL)
			free(lpCopy);
    	return FALSE;
    }
}

BOOL EndUpdateResourceEx(
    HANDLE  hUpdate,
    BOOL    fDiscard
    )
{
    LPTSTR  pFileName;
    PUPDATEDATA pUpdate;
    static char     pTempFileName[_MAX_PATH];
    int     cch;
    LPSTR   p;
    LONG    rc;

    SetLastError(0);
    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    if (fDiscard) {
		rc = NO_ERROR;
    }
    else {
		pFileName = (LPTSTR)GlobalLock(pUpdate->hFileName);
		// convert back to ANSI
		strcpy(pTempFileName, pFileName);
//v-guanx change back to wcscpy		_WCSTOMBS( pTempFileName, pFileName, wcslen(pFileName)+1);
		cch = strlen(pTempFileName);
		p = pTempFileName + cch;
//v-guanx		while (*p != L'\\' && p >= pTempFileName)
		while (*p != '\\' && p >= pTempFileName)
	    	p--;
		*(p+1) = 0;
		rc = GetTempFileName( pTempFileName, "RCX", 0, pTempFileName);
    	if (rc == 0) {
			rc = GetLastError();
	    }
    	else {
			rc = WriteResFile(hUpdate, pTempFileName);
			if (rc == NO_ERROR) {
				DeleteFile(pFileName);
				if(!MoveFile(pTempFileName, pFileName)){
					SetLastError(ERROR_FILE_NOT_FOUND);
				}
			}
			else {
				SetLastError(rc);
				DeleteFile(pTempFileName);
			}
    	}
		GlobalUnlock(pUpdate->hFileName);
		GlobalFree(pUpdate->hFileName);
    }

#ifdef MEM_STATISTICS
	RtlReportStatistics();
#endif

    FreeData(pUpdate);
    GlobalUnlock(hUpdate);
    GlobalFree(hUpdate);
    return rc?FALSE:TRUE;

}

/* v-guanx
extern "C"
void
APIENTRY
SetLastError(
    DWORD fdwError 
    )
{
    gdwLastError = fdwError;
}

extern "C"
DWORD
APIENTRY
GetLastError(
    void
    )
{
    return gdwLastError;
}
*/
/****************************************************************************
**
** Helper functions
**
****************************************************************************/



//-------------------------------------------------------------
// Helper for ReportDuplicateResource().
//-------------------------------------------------------------
/*LPSTR PrintablePSDATA(PSDATA x)
{
	char work[70];
	int i;
	if (x->discriminant == IS_ID)
	{
		// Format as hex
		sprintf(work, "0x%x", x->uu.Ordinal);
		for (i=2; work[i] != 0; i++)
		{
			work[i] = toupper(work[i]);
		}	
		return (LPSTR) work;
	}
	else
	{
		work[0] = '"';
		strcpy(&work[1],x->szStr);
		strcat(work, "\"");
		return (LPSTR)work;
	}
}
*/
//-------------------------------------------------------------
// Alerts user that a duplicate Type,Name pair was given to
// AddResource().
//-------------------------------------------------------------
//v-guanx rewrite this function as a C and use Windows API
/*void ReportDuplicateResource(PSDATA Type, PSDATA Name)
{
	if (gbReportDupRes)
	{
		char work[200];
		int	uiStatus;
		sprintf(work, "WARNING: Duplicate resource id.\n\nType=%s; Name=%s.\n\n"
			"Report all problems of this kind?",
			(LPSTR)PrintablePSDATA(Type),
			(LPSTR)PrintablePSDATA(Name));
//V-GUANX		UINT uiStatus = AfxMessageBox(work, MB_ICONEXCLAMATION | MB_YESNO);
		uiStatus = MessageBox(NULL,work, "Warning", MB_YESNO);
		if (uiStatus == IDNO)
		{
			gbReportDupRes = FALSE;
		}
	}
}
*/	 

LONG
AddResource(
    PSDATA Type,
    PSDATA Name,
    WORD Language,
    PUPDATEDATA pupd,
    PVOID lpData,
    ULONG cb
    )
{
    PRESTYPE  pType;
    PPRESTYPE ppType;
    PRESNAME  pName;
    PRESNAME  pNameT;
    PRESNAME  pNameM;
    PPRESNAME ppName = NULL;
    BOOL fTypeID=(Type->discriminant == IS_ID);
    BOOL fNameID=(Name->discriminant == IS_ID);
    BOOL fSame=FALSE;

    //
    // figure out which list to store it in
    //

    ppType = fTypeID ? &pupd->ResTypeHeadID : &pupd->ResTypeHeadName;

    //
    // Try to find the Type in the list
    //
    // We only have new types
    
    while ((pType=*ppType) != NULL) {
		if (pType->Type->uu.Ordinal == Type->uu.Ordinal) {
		    ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
	    	break;
		}
		if (fTypeID) {
	    	if (Type->uu.Ordinal < pType->Type->uu.Ordinal)
				break;
		}
    	else {
	    	if (memcmp(Type->szStr, pType->Type->szStr, Type->cbsz*sizeof(WCHAR)) < 0)
				break;
		}
		ppType = &(pType->pnext);
    }
    
    //
    // Create a new type if needed
    //

    if (ppName == NULL) {
		pType = malloc(sizeof(RESTYPE));
    	if (pType == NULL)
			return ERROR_NOT_ENOUGH_MEMORY;
    	memset((PVOID)pType,0, sizeof(RESTYPE));
		pType->pnext = *ppType;
		*ppType = pType;
		pType->Type = Type;
		ppName = fNameID ? &pType->NameHeadID : &pType->NameHeadName;
    }

    //
    // Find proper place for name
    //
    // We only have new resources
    
    while ( (pName = *ppName) != NULL) {
		if (fNameID) {
			if (Name->uu.Ordinal == pName->Name->uu.Ordinal) {
				fSame = TRUE;
				break;
			}
	    	if (Name->uu.Ordinal < pName->Name->uu.Ordinal)
				break;
		}
    	else {
	    	if (memcmp(Name->szStr, pName->Name->szStr, Name->cbsz*sizeof(WCHAR)) == 0) {
				fSame = TRUE;
				break;
			}
	    	if (memcmp(Name->szStr, pName->Name->szStr, Name->cbsz*sizeof(WCHAR)) < 0)
				break;
		}
		ppName = &(pName->pnext);
    }
    
    //
    // check for delete/modify
    //

    if (fSame) {        /* same name, new language */
		ppName = &pName->pnextRes;

//		ReportDuplicateResource(Type, Name);

		if (pName->pnextRes == NULL) {  /* only one language currently ? */
//	    	if (Language == pName->LanguageId) {    /* REPLACE */
				pName->DataSize = cb;
				if (cb == 0) {
		    		return ERROR_BAD_FORMAT;
				}
				pName->OffsetToDataEntry = (ULONG)lpData;
				return NO_ERROR;
//	    	}
		}
		else {              /* many languages currently */
			pNameT = NULL;
			pNameM = pName;
			while ( (pName = *ppName) != NULL) {
	    		if (Language >= pName->LanguageId)
					break;
	    		pNameT = pName;
	    		ppName = &(pName->pnext);
			}
	    	if (lpData == NULL) {   /* delete language */
				if (Language != pName->LanguageId)
					return ERROR_INVALID_PARAMETER;

				pName->NumberOfLanguages--;
				free((PVOID)pName->OffsetToDataEntry);
				if (pNameT == NULL) {   /* first? */
	    			pNameT = pName->pnext;
	    			if (pNameT == NULL) {   /* nothing left? */
						if (fNameID) {
		    				pType->NameHeadID = NULL;
		    				pType->NumberOfNamesID = 0;
						}
						else {
		    				pType->NameHeadName = NULL;
		    				pType->NumberOfNamesName = 0;
						}
	    			}
	    			else {      /* set new head of list */
						pNameT->NumberOfLanguages = pName->NumberOfLanguages-1;
						if (fNameID) {
		    				pType->NameHeadID = pNameT;
		    				pType->NumberOfNamesID -= 1;
						}
						else {
		    				pType->NameHeadName = pNameT;
		    				pType->NumberOfNamesName -= 1;
						}
	    			}
				}
				else {
	    			pNameT->pnext = pName->pnext;
				}

				free(pName);
				return NO_ERROR;
			}
			else {          /* add new language */
	    		pNameM->NumberOfLanguages++;
			}
    	}
    }
    else {              /* unique name */
    	if (lpData == NULL) {       /* can't delete new name */
			return ERROR_INVALID_PARAMETER;
    	}
    }

    //
    // add new name/language
    //

    if (!fSame) {
		if (fNameID)
	    	pType->NumberOfNamesID++;
		else
	    	pType->NumberOfNamesName++;
    }

    pName = (PRESNAME)malloc(sizeof(RESNAME));
    if (pName == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

    memset((PVOID)pName,0, sizeof(RESNAME));
    pName->pnext = *ppName;
    *ppName = pName;
    pName->Name = Name;
    pName->Type = Type;
    pName->NumberOfLanguages = 1;
    pName->LanguageId = Language;
    pName->DataSize = cb;
    pName->OffsetToDataEntry = (ULONG)lpData;  

    return NO_ERROR;
}    

/****************************************************************************
**
** Memory Helper functions
**
****************************************************************************/

size_t wcslen( WCHAR const * lpwszIn )
{
    UINT n = 0;
    
    while( *(lpwszIn+n)!=0x0000 )
    {
	n++;
    }
    return( n );
}                                                                 

WCHAR*
wcsncpy( WCHAR* lpwszOut, WCHAR const * lpwszIn, size_t n )
{
    return (WCHAR*)memcpy( lpwszOut, lpwszIn, n*sizeof(WORD) );
}

WCHAR*
wcscpy( WCHAR* lpwszOut, WCHAR const * lpwszIn )
{
    UINT n = wcslen( lpwszIn )+1;
    return (WCHAR*)memcpy( lpwszOut, lpwszIn, n*sizeof(WORD) );
}

int 
wcsncmp( WCHAR const * lpszw1, WCHAR const * lpszw2, size_t cb)
{
    return memcmp( lpszw1, lpszw2, cb*sizeof(WORD));
}

//
//  Resources are DWORD aligned and may be in any order.
//

#define TABLE_ALIGN  4
#define DATA_ALIGN  4L



PSDATA
AddStringOrID(
    LPCTSTR     lp,
    PUPDATEDATA pupd
)
{
    USHORT cb;
    PSDATA pstring;
    PPSDATA ppstring;

    if (((ULONG)lp & 0xFFFF0000) == 0) {
	//
	// an ID
	//
		pstring = malloc(sizeof(SDATA));
    	if (pstring == NULL)
			return NULL;
    	memset((PVOID)pstring,0, sizeof(SDATA));
    	pstring->discriminant = IS_ID;

		pstring->uu.Ordinal = (WORD)((ULONG)lp & 0x0000ffff);
    }
    else {
	//
	// a string
	//
		LPWSTR	wlp;
		int	i;

		cb = strlen(lp)+1;
		wlp = malloc(cb*sizeof(WCHAR));
		memset(wlp, 0, sizeof(wlp));
		for(i=0;i<cb;i++)
			wlp[i]=lp[i];

		ppstring = &pupd->StringHead;

		while ((pstring = *ppstring) != NULL) {
	    	if (!memcmp(pstring->szStr, wlp, cb*sizeof(WCHAR)))
				break;
	    	ppstring = &(pstring->uu.ss.pnext);
		}

		if (!pstring) {

	    //
	    // allocate a new one
	    //

			pstring = malloc(sizeof(SDATA));
			if (pstring == NULL)
	    		return NULL;
			memset((PVOID)pstring,0, sizeof(SDATA));

			pstring->szStr = (WCHAR*)malloc(cb*sizeof(WCHAR));
	    	if (pstring->szStr == NULL) {
				free(pstring);
				return NULL;
			}
			pstring->discriminant = IS_STRING;
	    	pstring->OffsetToString = pupd->cbStringTable;

	    	pstring->cbData = sizeof(pstring->cbsz) + cb*sizeof(WCHAR);
	    	pstring->cbsz = (cb - 1); /* don't include zero terminator */
	    	memcpy(pstring->szStr, (char *)wlp, cb*sizeof(WCHAR));

	    	pupd->cbStringTable += pstring->cbData;

	    	pstring->uu.ss.pnext=NULL;
	    	*ppstring=pstring;
		}
    }

    return(pstring);
}

// Fake the Rtl function
//LPHVOID
//RtlCopyMemory( LPHVOID lpTgt, LPHVOID lpSrc, DWORD cb)
//{
//	hmemcpy(lpTargt, lpSrc, cb);
//    return lpTgt;
//}


//v-guanx
//LPHVOID
//RtlAllocateHeap( DWORD dwUnused, int c, DWORD dwcbRequested )
//{
//	LPHVOID lphAllocated;
//	lphAllocated = malloc(dwcbRequested);
//if (lphAllocated != NULL)
//	{
//		return memset(lphAllocated, c, dwcbRequested);
//	}
//	return lphAllocated;
//}



//void
//RtlFreeHeap( DWORD dwUnused, int c, LPHVOID lpData)
//{
//	free(lpData);
//}

//DWORD
//RtlProcessHeap( void )
//{
//    return 0L;
//} 


VOID
FreeOne(
    PRESNAME pRes
    )
{
//    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes->OffsetToDataEntry);
//    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pRes);
    free((PVOID)pRes->OffsetToDataEntry);
    free((PVOID)pRes);
}

VOID
FreeData(
    PUPDATEDATA pUpd
	)
{
    PRESTYPE    pType;
    PRESNAME    pRes;
    PSDATA      pstring, pStringTmp;

    for (pType=pUpd->ResTypeHeadID ; pUpd->ResTypeHeadID ; pType=pUpd->ResTypeHeadID) {
		pUpd->ResTypeHeadID = pUpd->ResTypeHeadID->pnext;

		for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
	    	pType->NameHeadID = pType->NameHeadID->pnext;
	    	FreeOne(pRes);
		}

		for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
	    	pType->NameHeadName = pType->NameHeadName->pnext;
	    	FreeOne(pRes);
		}

//		RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)pType);
		free((PVOID)pType);
    }

    for (pType=pUpd->ResTypeHeadName ; pUpd->ResTypeHeadName ; pType=pUpd->ResTypeHeadName) {
		pUpd->ResTypeHeadName = pUpd->ResTypeHeadName->pnext;

		for (pRes=pType->NameHeadID ; pType->NameHeadID ; pRes=pType->NameHeadID ) {
	    	pType->NameHeadID = pType->NameHeadID->pnext;
	    	FreeOne(pRes);
		}

		for (pRes=pType->NameHeadName ; pType->NameHeadName ; pRes=pType->NameHeadName ) {
	    	pType->NameHeadName = pType->NameHeadName->pnext;
	    	FreeOne(pRes);
		}

    }

    pstring = pUpd->StringHead;
    while (pstring != NULL) {
		pStringTmp = pstring->uu.ss.pnext;
	   	if (pstring->discriminant == IS_STRING)
			free((PVOID)pstring->szStr);
   		free((PVOID)pstring);
		pstring = pStringTmp;
    }	
	return;
}	

/*
void
DeleteFile( LPTSTR pFileName)
{
    OFSTRUCT of;
    OpenFile( pFileName, &of, OF_DELETE);
}

BOOL
MoveFile( char * pTempFileName, LPTSTR pFileName)
{
    
    // 
    // BUG: 409
    // We will rename if on the same drive. Otherwise copy it
    // 
    BOOL rc = FALSE;
    if (strncmp( pTempFileName, pFileName, 1 )) {
//		TRACE2("\t\tCopyFile:\tpTempFileName: %s\tpName: %s\n", pTempFileName, pFileName );
		rc = CopyFile( pTempFileName, pFileName, TRUE );
//		TRACE1("\t\tCopyFile: %ld\n", rc);
		// Delete the temporary file name
		DeleteFile( pTempFileName );
    } else {
//		TRACE2("\t\tMoveFile:\tpTempFileName: %s\tpName: %s\n", pTempFileName, pFileName );
		if(rename( pTempFileName, pFileName )==0)
			rc=TRUE;
//		TRACE1("\t\tMoveFile: %ld", rc);
    }   
    return rc;
}
*/
/*
 * Utility routines
 */


ULONG
FilePos(int fh)
{

    return _llseek(fh, 0L, SEEK_CUR);
}



ULONG
MoveFilePos( INT fh, ULONG pos )
{
    return _llseek( fh, pos, SEEK_SET );
}



ULONG
MyWrite( INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _hwrite(fh, (LPCSTR)p, n)) != n) {
    return n1;
    }
    else
	return 0;
}



ULONG
MyRead(INT fh, UCHAR*p, ULONG n )
{
    ULONG   n1;

    if ((n1 = _hread( fh, p, n )) != n) {
	return n1;
    }
    else
	return 0;
}



BOOL
MyCopy( INT srcfh, INT dstfh, ULONG nbytes )
{
    ULONG   n;
    ULONG   cb=0L;
    PUCHAR  pb;

    pb = (PUCHAR)malloc(BUFSIZE);
    if (pb == NULL)
		return 0;
	memset(pb, 0, BUFSIZE);
    while (nbytes) {
		if (nbytes <= BUFSIZE)
		    n = nbytes;
		else
	    	n = BUFSIZE;
		nbytes -= n;

		if (!MyRead( srcfh, pb, n )) {
			cb += n;
	    	MyWrite( dstfh, pb, n );
    	}
		else {
			free(pb);
			return (BOOL)cb;
    	}
    }
    free(pb);
    return (BOOL)cb;
}



VOID
SetResdata(
    PIMAGE_RESOURCE_DATA_ENTRY  pResData,
    ULONG           offset,
    ULONG           size)
{
    pResData->OffsetToData = offset;
    pResData->Size = size;
    pResData->CodePage = DEFAULT_CODEPAGE;
    pResData->Reserved = 0L;
}


VOID
SetRestab(
    PIMAGE_RESOURCE_DIRECTORY   pRestab,
    LONG            time,
    WORD            cNamed,
    WORD            cId)
{
    pRestab->Characteristics = 0L;
    pRestab->TimeDateStamp = time;
    pRestab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pRestab->MinorVersion = MINOR_RESOURCE_VERSION;
    pRestab->NumberOfNamedEntries = cNamed;
    pRestab->NumberOfIdEntries = cId;
}


PIMAGE_SECTION_HEADER
FindSection(
    PIMAGE_SECTION_HEADER   pObjBottom,
    PIMAGE_SECTION_HEADER   pObjTop,
    LPSTR pName
    )
{

    while (pObjBottom < pObjTop) {
	    if (strcmp((char*)pObjBottom->Name, pName) == 0)
			return pObjBottom;
    	pObjBottom++;
    }

    return NULL;
}


ULONG
AssignResourceToSection(
    PRESNAME    *ppRes,     /* resource to assign */
    ULONG   ExtraSectionOffset, /* offset between .rsrc and .rsrc1 */
    ULONG   Offset,     /* next available offset in section */
    LONG    Size,       /* Maximum size of .rsrc */
    PLONG   pSizeRsrc1
    )
{
    ULONG   cb;

    /* Assign this res to this section */
    cb = ROUNDUP((*ppRes)->DataSize, CBLONG);
    if (Offset < ExtraSectionOffset && Offset + cb > (ULONG)Size) {
    	*pSizeRsrc1 = Offset;
    	Offset = ExtraSectionOffset;
    //DPrintf((DebugBuf, "<<< Secondary resource section @%#08lx >>>\n", Offset));
    }
    (*ppRes)->OffsetToData = Offset;
    *ppRes = (*ppRes)->pnext;
    //DPrintf((DebugBuf, "    --> %#08lx bytes at %#08lx\n", cb, Offset));
    return Offset + cb;
}


//
// adjust debug directory table
//

/*  */
LONG
PatchDebug(int  inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER pDebugOld,
      PIMAGE_SECTION_HEADER pDebugNew,
      PIMAGE_SECTION_HEADER pDebugDirOld,
      PIMAGE_SECTION_HEADER pDebugDirNew,
      PIMAGE_NT_HEADERS pOld,
      PIMAGE_NT_HEADERS pNew,
	  ULONG ibMaxDbgOffsetOld,
      PULONG pPointerToRawData)
{
    PIMAGE_DEBUG_DIRECTORY pDbgLast;
    PIMAGE_DEBUG_DIRECTORY pDbgSave;
    PIMAGE_DEBUG_DIRECTORY pDbg;
    ULONG   ib;
    ULONG   adjust;
    ULONG   ibNew;

    if (pDebugDirOld == NULL)
    return NO_ERROR;

    pDbgSave = pDbg = (PIMAGE_DEBUG_DIRECTORY)malloc(pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    if (pDbg == NULL)
    	return ERROR_NOT_ENOUGH_MEMORY;
	memset(pDbgSave, 0, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);	

    if (pDebugOld) {
    //DPrintf((DebugBuf, "patching dbg directory: @%#08lx ==> @%#08lx\n",
    //     pDebugOld->PointerToRawData, pDebugNew->PointerToRawData));
    }
    else
		adjust = *pPointerToRawData;    /* passed in EOF of new file */

    ib = pOld->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress - pDebugDirOld->VirtualAddress;
    MoveFilePos(inpfh, pDebugDirOld->PointerToRawData+ib);
    pDbgLast = pDbg + (pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size)/sizeof(IMAGE_DEBUG_DIRECTORY);
    MyRead(inpfh, (PUCHAR)pDbg, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

    if (pDebugOld == NULL) {
    /* find 1st entry - use for offset */
	//DPrintf((DebugBuf, "adjust: %#08lx\n",adjust));
	    for (ibNew=0xffffffff ; pDbg<pDbgLast ; pDbg++)
		    if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld &&
				pDbg->PointerToRawData < ibNew
	       	)
				ibNew = pDbg->PointerToRawData;
    
	    *pPointerToRawData = ibNew; /* return old */
    	for (pDbg=pDbgSave ; pDbg<pDbgLast ; pDbg++) {
	//DPrintf((DebugBuf, "old debug file offset: %#08lx\n",
	//     pDbg->PointerToRawData));
		    if (pDbg->PointerToRawData >= ibMaxDbgOffsetOld)
				pDbg->PointerToRawData += adjust - ibNew;
	//DPrintf((DebugBuf, "new debug file offset: %#08lx\n",
	//     pDbg->PointerToRawData));
    	}
    }
    else {
    	for ( ; pDbg<pDbgLast ; pDbg++) {
	//DPrintf((DebugBuf, "old debug addr: %#08lx, file offset: %#08lx\n",
	//     pDbg->AddressOfRawData,
	//     pDbg->PointerToRawData));
			pDbg->AddressOfRawData += pDebugNew->VirtualAddress -
				pDebugOld->VirtualAddress;
			pDbg->PointerToRawData += pDebugNew->PointerToRawData -
				pDebugOld->PointerToRawData;
	//DPrintf((DebugBuf, "new debug addr: %#08lx, file offset: %#08lx\n",
	//     pDbg->AddressOfRawData,
	//     pDbg->PointerToRawData));
    	}
    }

    MoveFilePos(outfh, pDebugDirNew->PointerToRawData+ib);
    MyWrite(outfh, (PUCHAR)pDbgSave, pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);
    free(pDbgSave);

    return NO_ERROR;
}

//
// This routine patches various RVAs in the file to compensate
// for extra section table entries.
//


LONG
PatchRVAs(int   inpfh,
      int   outfh,
      PIMAGE_SECTION_HEADER po32,
      ULONG pagedelta,
      PIMAGE_NT_HEADERS pNew,
      ULONG OldSize)
{
    ULONG hdrdelta;
    ULONG offset, rvaiat, offiat, iat;
    IMAGE_EXPORT_DIRECTORY Exp;
    IMAGE_IMPORT_DESCRIPTOR Imp;
    ULONG i, cmod, cimp;

    hdrdelta = pNew->OptionalHeader.SizeOfHeaders - OldSize;
    if (hdrdelta == 0) {
    	return NO_ERROR;
    }

    //
    // Patch export section RVAs
    //

    //DPrintf((DebugBuf, "Export offset=%08lx, hdrsize=%08lx\n",
    //     pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress,
    //     pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) == 0)
    {
    //DPrintf((DebugBuf, "No exports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    //DPrintf((DebugBuf, "No exports in header to patch\n"));
    }
    else
    {
    	MoveFilePos(inpfh, offset - hdrdelta);
    	MyRead(inpfh, (PUCHAR) &Exp, sizeof(Exp));
    	Exp.Name += hdrdelta;
    	Exp.AddressOfFunctions += (ULONG)hdrdelta;
    	Exp.AddressOfNames += (ULONG)hdrdelta;
    	Exp.AddressOfNameOrdinals += (ULONG)hdrdelta;
    	MoveFilePos(outfh, offset);
    	MyWrite(outfh, (PUCHAR) &Exp, sizeof(Exp));
    }

    //
    // Patch import section RVAs
    //

    //DPrintf((DebugBuf, "Import offset=%08lx, hdrsize=%08lx\n",
    //     pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress,
    //     pNew->OptionalHeader.SizeOfHeaders));
    if ((offset = pNew->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress) == 0)
    {
    //DPrintf((DebugBuf, "No imports to patch\n"));
    }
    else if (offset >= pNew->OptionalHeader.SizeOfHeaders)
    {
    //DPrintf((DebugBuf, "No imports in header to patch\n"));
    }
    else
    {
    	for (cimp = cmod = 0; ; cmod++)
    	{
			MoveFilePos(inpfh, offset + cmod * sizeof(Imp) - hdrdelta);
			MyRead(inpfh, (PUCHAR) &Imp, sizeof(Imp));
			if (Imp.FirstThunk == 0)
			{
				break;
			}
			Imp.Name += hdrdelta;
			MoveFilePos(outfh, offset + cmod * sizeof(Imp));
			MyWrite(outfh, (PUCHAR) &Imp, sizeof(Imp));
	
			rvaiat = (ULONG)Imp.FirstThunk;
			//DPrintf((DebugBuf, "rvaiat = %#08lx\n", (ULONG)rvaiat));
			for (i = 0; i < pNew->FileHeader.NumberOfSections; i++) {
				if (rvaiat >= po32[i].VirtualAddress &&
	    		rvaiat < po32[i].VirtualAddress + po32[i].SizeOfRawData) {

	    			offiat = rvaiat - po32[i].VirtualAddress + po32[i].PointerToRawData;
	    			goto found;
				}
			}
			//DPrintf((DebugBuf, "IAT not found\n"));
			return ERROR_INVALID_DATA;
found:
	//DPrintf((DebugBuf, "IAT offset: @%#08lx ==> @%#08lx\n",
	//     offiat - pagedelta,
	//     offiat));
			MoveFilePos(inpfh, offiat - pagedelta);
			MoveFilePos(outfh, offiat);
			for (;;) {
				MyRead(inpfh, (PUCHAR) &iat, sizeof(iat));
				if (iat == 0) {
	    			break;
				}
				if ((iat & IMAGE_ORDINAL_FLAG) == 0) {  // if import by name
	    //DPrintf((DebugBuf, "patching IAT: %08lx + %04lx ==> %08lx\n",
	    //     iat,
	    //     hdrdelta,
	    //     iat + hdrdelta));
	    			iat += hdrdelta;
	    			cimp++;
				}
				MyWrite(outfh, (PUCHAR) &iat, sizeof(iat)); // Avoids seeking
			}
    	}
    //DPrintf((DebugBuf, "%u import module name RVAs patched\n", cmod));
    //DPrintf((DebugBuf, "%u IAT name RVAs patched\n", cimp));
    	if (cmod == 0)
    	{
	//DPrintf((DebugBuf, "No import modules to patch\n"));
    	}
    	if (cimp == 0)
    	{
	//DPrintf((DebugBuf, "No import name RVAs to patch\n"));
    	}
    }

    return NO_ERROR;

}


/***************************** Main Worker Function ***************************
* LONG PEWriteResFile
*
* This function writes the resources to the named executable file.
* It assumes that resources have no fixups (even any existing resources
* that it removes from the executable.)  It places all the resources into
* one or two sections. The resources are packed tightly into the section,
* being aligned on dword boundaries.  Each section is padded to a file
* sector size (no invalid or zero-filled pages), and each
* resource is padded to the afore-mentioned dword boundary.  This
* function uses the capabilities of the NT system to enable it to easily
* manipulate the data:  to wit, it assumes that the system can allocate
* any sized piece of data, in particular the section and resource tables.
* If it did not, it might have to deal with temporary files (the system
* may have to grow the swap file, but that's what the system is for.)
*
* Return values are:
*     TRUE  - file was written succesfully.
*     FALSE - file was not written succesfully.
*
* Effects:
*
* History:
* Thur Apr 27, 1989        by     Floyd Rogers      [floydr]
*   Created.
* 12/8/89   sanfords    Added multiple section support.
* 12/11/90  floydr  Modified for new (NT) Linear Exe format
* 1/18/92   vich    Modified for new (NT) Portable Exe format
* 5/8/92    bryant    General cleanup so resonexe can work with unicode
* 6/9/92    floydr    incorporate bryan's changes
* 6/15/92   floydr    debug section separate from debug table
* 9/25/92   floydr    account for .rsrc not being last-1
* 9/28/92   floydr    account for adding lots of resources by adding
*             a second .rsrc section.
* 7/27/93   alessanm  ported to win16 for Chicago
\****************************************************************************/

/*  */

/*  This is a BIG function - disable warning about 'can't optimize'     */
/*  MHotchin Apr 1994                                                   */
#pragma warning (disable : 4703)

LONG
PEWriteResFile(
    INT     inpfh,
    INT     outfh,
    ULONG   cbOldexe,
    PUPDATEDATA pUpdate
    )
{
    IMAGE_NT_HEADERS Old;   /* original header              */
    IMAGE_NT_HEADERS New;   /* working header       */
    PRESNAME    pRes;
    PRESNAME    pResSave;
    PRESTYPE    pType;
    ULONG   clock = GetTickCount(); /* current time */
    ULONG   cbName=0;   /* count of bytes in name strings */
    ULONG   cbType=0;   /* count of bytes in type strings */
    ULONG   cTypeStr=0; /* count of strings */
    ULONG   cNameStr=0; /* count of strings */
    LONG    cb;     /* temp byte count and file index */
    ULONG   cTypes = 0L;    /* count of resource types      */
    ULONG   cNames = 0L;    /* Count of names for multiple languages/name */
    ULONG   cRes = 0L;  /* count of resources      */
    ULONG   cbRestab;   /* count of resources      */
    LONG    cbNew = 0L; /* general count */
    ULONG   ibObjTab;
    ULONG   ibObjTabEnd;
    ULONG   ibSave;
    //ULONG   adjust=0;
    LONG   adjust=0;
    PIMAGE_SECTION_HEADER   pObjtblOld,
	pObjtblNew,
	pObjDebug,
	pObjResourceOld,
	pObjResourceNew,
	pObjResourceOldX,
	pObjDebugDirOld,
	pObjDebugDirNew,
	pObjNew,
	pObjOld,
	pObjLast;
    BYTE *p;
    PIMAGE_RESOURCE_DIRECTORY   pResTab;
    PIMAGE_RESOURCE_DIRECTORY   pResTabN;
    PIMAGE_RESOURCE_DIRECTORY   pResTabL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirL;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirN;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirT;
    PIMAGE_RESOURCE_DATA_ENTRY  pResData;
    PUSHORT pResStr;
    PUSHORT pResStrEnd;
    PSDATA  pPreviousName;
    LONG    nObjResource=-1;
    LONG    nObjResourceX=-1;
    ULONG   cbResource;
    ULONG   cbMustPad = 0;
    ULONG   cbMustPadX = 0;
    ULONG       ibMaxDbgOffsetOld;

    MoveFilePos(inpfh, cbOldexe);
    MyRead(inpfh, (PUCHAR)&Old, sizeof(IMAGE_NT_HEADERS));
    ibObjTab = FilePos(inpfh);
    ibObjTabEnd = ibObjTab + Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);

    if (*(PUSHORT)&Old.Signature != IMAGE_NT_SIGNATURE)
    	return ERROR_INVALID_EXE_SIGNATURE;

    if ((Old.FileHeader.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
    	return ERROR_EXE_MARKED_INVALID;
    }
    
    //TRACE(("\n"));

    /* New header is like old one.                  */
    memcpy(&New, &Old, sizeof(IMAGE_NT_HEADERS));

    /* Read section table */
    pObjtblOld = (PIMAGE_SECTION_HEADER)malloc(Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    if (pObjtblOld == NULL) {
    	cb = ERROR_NOT_ENOUGH_MEMORY;
    	goto AbortExit;
    }
    memset((PVOID)pObjtblOld, 0, Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER));
    /*
    TRACE2("old section table: %#08lx bytes at %#08lx(mem)\n",
      Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
      DPrintfpObjtblOld);
    */
    MyRead(inpfh, (PUCHAR)pObjtblOld,
	Old.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));
    pObjLast = pObjtblOld + Old.FileHeader.NumberOfSections;
    ibMaxDbgOffsetOld = 0;
    for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
		if (pObjOld->PointerToRawData > ibMaxDbgOffsetOld) {
		    ibMaxDbgOffsetOld = pObjOld->PointerToRawData + pObjOld->SizeOfRawData;
		}
    }
    //DPrintf((DebugBuf, "Maximum debug offset in old file: %08x\n", ibMaxDbgOffsetOld ));

    /*
     * First, count up the resources.  We need this information
     * to discover how much room for header information to allocate
     * in the resource section.  cRes tells us how
     * many language directory entries/tables.  cNames and cTypes
     * is used for the respective tables and/or entries.  cbName totals
     * the bytes required to store the alpha names (including the leading
     * length word).  cNameStr counts these strings.
     */
    //DPrintf((DebugBuf, "beginning loop to count resources\n"));

    /* first, count those in the named type list */
    cbResource = 0;
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType != NULL) {
    	if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
	//DPrintf((DebugBuf, "resource type "));
	//DPrintfu((pType->Type->szStr));
	//DPrintfn((DebugBuf, "\n"));
			cTypes++;
			cTypeStr++;
			cbType += (pType->Type->cbsz + 1) * sizeof(WORD);

	    //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
	    	pPreviousName = NULL;
			pRes = pType->NameHeadName;
			while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));
				cRes++;
				cbName += (pRes->Name->cbsz + 1) * sizeof(WCHAR);
				cNameStr++;
				if (pPreviousName == NULL ||
		    	memcmp(pPreviousName->szStr,
			    pRes->Name->szStr,
			    pRes->Name->cbsz*sizeof(WCHAR)) != 0)
		    		cNames++;
				cbResource += ROUNDUP(pRes->DataSize, CBLONG);
				pPreviousName = pRes->Name;
				pRes = pRes->pnext;
			}

	    //DPrintf((DebugBuf, "Walk name: ID list\n"));
	    	pPreviousName = NULL;
			pRes = pType->NameHeadID;
			while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));
				cRes++;
				if (pPreviousName == NULL ||
		    	pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
		    		cNames++;
				}
				cbResource += ROUNDUP(pRes->DataSize, CBLONG);
				pPreviousName = pRes->Name;
				pRes = pRes->pnext;
			}
		}
		pType = pType->pnext;
    }

    /* second, count those in the ID type list */
    //DPrintf((DebugBuf, "Walk type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType != NULL) {
    	if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
	//DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));
			cTypes++;
	    //DPrintf((DebugBuf, "Walk name: Alpha list\n"));
	    	pPreviousName = NULL;
			pRes = pType->NameHeadName;
			while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));
				cRes++;
				cbName += (pRes->Name->cbsz + 1) * sizeof(WORD);
				cNameStr++;
				if (pPreviousName == NULL ||
		    	memcmp(pPreviousName->szStr,
			    pRes->Name->szStr,
			    pRes->Name->cbsz*sizeof(WCHAR)) != 0)
		    		cNames++;
				cbResource += ROUNDUP(pRes->DataSize, CBLONG);
				pPreviousName = pRes->Name;
				pRes = pRes->pnext;
			}

	    //DPrintf((DebugBuf, "Walk name: ID list\n"));
	    	pPreviousName = NULL;
			pRes = pType->NameHeadID;
			while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));
				cRes++;
				if (pPreviousName == NULL ||
		    	pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
		    		cNames++;
				}
				cbResource += ROUNDUP(pRes->DataSize, CBLONG);
				pPreviousName = pRes->Name;
				pRes = pRes->pnext;
			}
    	}
		pType = pType->pnext;
    }
    cb = REMAINDER(cbName + cbType, CBLONG);

    /* Add up the number of bytes needed to store the directory.  There is
     * one type table with cTypes entries.  They point to cTypes name tables
     * that have a total of cNames entries.  Each of them points to a language
     * table and there are a total of cRes entries in all the language tables.
     * Finally, we have the space needed for the Directory string entries,
     * some extra padding to attain the desired alignment, and the space for
     * cRes data entry headers.
     */
    cbRestab =   sizeof(IMAGE_RESOURCE_DIRECTORY) + /* root dir (types) */
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir2 (names) */
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) +
    cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) + /* subdir3 (langs) */
    cRes   * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY)  +
    (cbName + cbType) +             /* name/type strings */
    cb +                        /* padding */
    cRes   * sizeof(IMAGE_RESOURCE_DATA_ENTRY); /* data entries */

    cbResource += cbRestab;     /* add in the resource table */

    // Find any current resource sections

    pObjResourceOld = FindSection(pObjtblOld, pObjLast, ".rsrc");
    pObjResourceOldX = FindSection(pObjtblOld, pObjLast, ".rsrc1");
    if (pObjResourceOld == NULL) {
    	cb = 0x7fffffff;        /* can fill forever */
    }
    else if (pObjResourceOld + 1 == pObjResourceOldX) {
    	nObjResource = pObjResourceOld - pObjtblOld;
    //DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    //DPrintf((DebugBuf,"Merging old Resource extra section #%lu\n", nObjResource+2));
    	cb = 0x7fffffff;        /* merge resource sections */
    }
    else {
    	nObjResource = pObjResourceOld - pObjtblOld;
    //DPrintf((DebugBuf,"Old Resource section #%lu\n", nObjResource+1));
    	cb = (pObjResourceOld+1)->VirtualAddress -
	    pObjResourceOld->VirtualAddress;
    	if (cbRestab > (ULONG)cb) {
	//DPrintf((DebugBuf, "Resource Table Too Large\n"));
			return ERROR_INVALID_DATA;
    	}
    }

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
    pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

    if (pObjResourceOld != NULL && cbResource > (ULONG)cb) {
    	if (pObjResourceOld != NULL && pObjOld == pObjResourceOld + 1) {
	//DPrintf((DebugBuf, "Large resource section  pushes .reloc\n"));
			cb = 0x7fffffff;        /* can fill forever */
    	}
    	else if (pObjResourceOldX == NULL) {
	//DPrintf((DebugBuf, "Too much resource data for old .rsrc section\n"));
			nObjResourceX = pObjOld - pObjtblOld;
			adjust = pObjOld->VirtualAddress - pObjResourceOld->VirtualAddress;
    	}
    	else {      /* have already merged .rsrc & .rsrc1, if possible */
	/*
	 *   We are fine we have to calculate the place in which the old
	 *   .rsrc1 was.
	 *   Later we have to check if the .rsrc1 that we had was big enough or
	 *   if we have to move the .reloc section.
	 *   We will keep the .rsrc1 section in the position it is.
	 *   There is no need to push it forward to the .reloc section
	 */
			nObjResourceX = pObjResourceOldX - pObjtblOld;
			adjust = pObjResourceOldX->VirtualAddress -
	     	pObjResourceOld ->VirtualAddress;
	/*
	adjust = pObjOld->VirtualAddress -
	     pObjResourceOld ->VirtualAddress;
	*/
    	}
   	}

    /*
     * Walk the type lists and figure out where the Data entry header will
     * go.  Keep a running total of the size for each data element so we
     * can store this in the section header.
     */
    //DPrintf((DebugBuf, "beginning loop to assign resources to addresses\n"));

    /* first, those in the named type list */

   	cbResource = cbRestab;  /* assign resource table to 1st rsrc section */
		/* adjust == offset to .rsrc1 */
		/* cb == size availble in .rsrc */
   	cbNew = 0;          /* count of bytes in second .rsrc */
    //DPrintf((DebugBuf, "Walk type: NAME list\n"));
   	pType = pUpdate->ResTypeHeadName;
   	while (pType != NULL) {
   		if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
	//DPrintf((DebugBuf, "resource type "));
	//DPrintfu((pType->Type->szStr));
	//DPrintfn((DebugBuf, "\n"));
			pRes = pType->NameHeadName;
			while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));
				cbResource = AssignResourceToSection(&pRes,
    			adjust, cbResource, cb, &cbNew);
			}
			pRes = pType->NameHeadID;
			while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));
				cbResource = AssignResourceToSection(&pRes,
    			adjust, cbResource, cb, &cbNew);
			}
   		}
		pType = pType->pnext;
   	}

    /* then, count those in the ID type list */

    //DPrintf((DebugBuf, "Walk type: ID list\n"));
   	pType = pUpdate->ResTypeHeadID;
   	while (pType != NULL) {
   		if (pType->NameHeadName != NULL || pType->NameHeadID != NULL) {
	//DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));
			pRes = pType->NameHeadName;
			while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));
				cbResource = AssignResourceToSection(&pRes,
    			adjust, cbResource, cb, &cbNew);
			}
			pRes = pType->NameHeadID;
			while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));
				cbResource = AssignResourceToSection(&pRes,
    			adjust, cbResource, cb, &cbNew);
			}
   		}
		pType = pType->pnext;
   	}
    /*
     * At this point:
     * cbResource has offset of first byte past the last resource.
     * cbNew has the count of bytes in the first resource section,
     * if there are two sections.
     */
   	if (cbNew == 0)
		cbNew = cbResource;
    /*
     * Discover where the Debug info is (if any)?
     */
   	pObjDebug = FindSection(pObjtblOld, pObjLast, ".debug");
   	if (pObjDebug != NULL) {
   		if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress  == 0) {
	//DPrintf((DebugBuf, ".debug section but no debug directory\n"));
			return ERROR_INVALID_DATA;
   		}
   		if (pObjDebug != pObjLast-1) {
	//DPrintf((DebugBuf, "debug section not last section in file\n"));
			return ERROR_INVALID_DATA;
   		}
    //DPrintf((DebugBuf, "Debug section: %#08lx bytes @%#08lx\n",
    //   pObjDebug->SizeOfRawData,
    //   pObjDebug->PointerToRawData));
   	}
   	pObjDebugDirOld = NULL;
   	for (pObjOld=pObjtblOld ; pObjOld<pObjLast ; pObjOld++) {
   		if (Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress >= pObjOld->VirtualAddress &&
		Old.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress < pObjOld->VirtualAddress+pObjOld->SizeOfRawData) {
			pObjDebugDirOld = pObjOld;
			break;
   		}
   	}

    /*
     * Discover where the first discardable section is.  This is where
     * we will stick any new resource section.
     *
     * Note that we are ignoring discardable sections such as .CRT -
     * this is so that we don't cause any relocation problems.
     * Let's hope that .reloc is the one we want!!!
     */
   	pObjOld = FindSection(pObjtblOld, pObjLast, ".reloc");

   	if (nObjResource == -1) {       /* no old resource section */
   		if (pObjOld != NULL)
			nObjResource = pObjOld - pObjtblOld;
   		else if (pObjDebug != NULL)
			nObjResource = pObjDebug - pObjtblOld;
		else
			nObjResource = New.FileHeader.NumberOfSections;
   		New.FileHeader.NumberOfSections++;
  	}
    //DPrintf((DebugBuf, "resources assigned to section #%lu\n", nObjResource+1));
   	if (nObjResourceX != -1) {      /* we have already a .rsrc1 section */
   		if (pObjResourceOldX != NULL) {
			nObjResourceX = pObjResourceOldX - pObjtblOld;
			New.FileHeader.NumberOfSections--;
   		}
   		else if (pObjOld != NULL)
			nObjResourceX = pObjOld - pObjtblOld;
		else if (pObjDebug != NULL)
			nObjResourceX = pObjDebug - pObjtblOld;
		else
			nObjResourceX = New.FileHeader.NumberOfSections;
   		New.FileHeader.NumberOfSections++;
    //DPrintf((DebugBuf, "Extra resources assigned to section #%lu\n",
    //  nObjResourceX+1));
   	} else if(pObjResourceOldX != NULL)    // Check if we are reducing the number of section because removing the .rsrc1
		New.FileHeader.NumberOfSections--;
    

    /*
     * If we had to add anything to the header (section table),
     * then we have to update the header size and rva's in the header.
     */
   	adjust = (New.FileHeader.NumberOfSections -
  	Old.FileHeader.NumberOfSections) * sizeof(IMAGE_SECTION_HEADER);
   	cb = Old.OptionalHeader.SizeOfHeaders -
   	(Old.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER) +
    	sizeof(IMAGE_NT_HEADERS) + cbOldexe );
   	if (adjust > cb) {
   		int i;

   		adjust -= cb;
    //DPrintf((DebugBuf, "adjusting header RVAs by %#08lx\n", adjust));
   		for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES ; i++) {
			if (New.OptionalHeader.DataDirectory[i].VirtualAddress &&
			New.OptionalHeader.DataDirectory[i].VirtualAddress < New.OptionalHeader.SizeOfHeaders) {
	//DPrintf((DebugBuf, "adjusting unit[%s] RVA from %#08lx to %#08lx\n",
	//   apszUnit[i],
	//   New.OptionalHeader.DataDirectory[i].VirtualAddress,
	//   New.OptionalHeader.DataDirectory[i].VirtualAddress + adjust));
				New.OptionalHeader.DataDirectory[i].VirtualAddress += adjust;
			}
   		}
   		New.OptionalHeader.SizeOfHeaders += adjust;
   	}

    /* Allocate storage for new section table                */
   	cb = New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
   	pObjtblNew = (PIMAGE_SECTION_HEADER)malloc((short)cb);
   	if (pObjtblNew == NULL) {
   		cb = ERROR_NOT_ENOUGH_MEMORY;
   		goto AbortExit;
   	}
   	memset((PVOID)pObjtblNew,0, cb);
    //DPrintf((DebugBuf, "new section table: %#08lx bytes at %#08lx\n", cb, pObjtblNew));
   	pObjResourceNew = pObjtblNew + nObjResource;

    /*
     * copy old section table to new
     */
   	adjust = 0;         /* adjustment to virtual address */
   	for (pObjOld=pObjtblOld,pObjNew=pObjtblNew ; pObjOld<pObjLast ; pObjOld++) {
   		if (pObjOld == pObjResourceOldX) {
			continue;
   		}
   		else if (pObjNew == pObjResourceNew) {
	//DPrintf((DebugBuf, "Resource Section %i\n", nObjResource+1));
			cb = ROUNDUP(cbNew, New.OptionalHeader.FileAlignment);
			if (pObjResourceOld == NULL) {
				adjust = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
//v-guanx	RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
				memset(pObjNew,0, sizeof(IMAGE_SECTION_HEADER));
				strcpy((char*)pObjNew->Name, ".rsrc");
				pObjNew->VirtualAddress = pObjOld->VirtualAddress;
				pObjNew->PointerToRawData = pObjOld->PointerToRawData;
				pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
    			IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
				pObjNew->SizeOfRawData = cb;
				pObjNew->Misc.VirtualSize = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
			}
			else {
				*pObjNew = *pObjOld;    /* copy obj table entry */
				pObjNew->SizeOfRawData = cb;
				pObjNew->Misc.VirtualSize = ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment);
				if (pObjNew->SizeOfRawData == pObjOld->SizeOfRawData) {
    				adjust = 0;
				}
				else if (pObjNew->SizeOfRawData > pObjOld->SizeOfRawData) {
    				adjust +=
    				ROUNDUP(cbNew, New.OptionalHeader.SectionAlignment) -
    				((pObjOld+1)->VirtualAddress-pObjOld->VirtualAddress);
				}
				else {      /* is smaller, but pad so will be valid */
    				adjust = 0;
    				pObjNew->SizeOfRawData = pObjResourceOld->SizeOfRawData;
					pObjNew->Misc.VirtualSize = pObjResourceOld->Misc.VirtualSize;
    				cbMustPad = pObjResourceOld->SizeOfRawData;
				}
			}
			pObjNew++;
			if (pObjResourceOld == NULL)
				goto rest_of_table;
   		}
   		else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {
	//DPrintf((DebugBuf, "Additional Resource Section %i\n",
	//nObjResourceX+1));
//v-guanx	RtlZeroMemory(pObjNew, sizeof(IMAGE_SECTION_HEADER));
			memset(pObjNew,0, sizeof(IMAGE_SECTION_HEADER));
			strcpy((char*)pObjNew->Name, ".rsrc1");
	/* 
	 * Before we copy the virtual address we have to move back the .reloc 
	 * virtual address. Otherwise we will keep moving the reloc VirtualAddress
	 * forward.         
	 * We will have to move back the address of .rsrc1
	 */ 
			if (pObjResourceOldX == NULL) {
	    // This is the first time we have a .rsrc1
    			pObjNew->VirtualAddress = pObjOld->VirtualAddress;
    			pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
				IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
    			adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
				pObjResourceNew->VirtualAddress -
				pObjNew->VirtualAddress;
//    			TRACE2("Added .rsrc1. VirtualAddress %lu\t adjust: %lu\n", pObjNew->VirtualAddress,
//				adjust );
			} else {
	    // we already have an .rsrc1 use the position of that and 
	    // calculate the new adjust
    			pObjNew->VirtualAddress = pObjResourceOldX->VirtualAddress;
    			pObjNew->Characteristics = IMAGE_SCN_MEM_READ |
				IMAGE_SCN_MEM_WRITE | IMAGE_SCN_CNT_INITIALIZED_DATA;
	
//    			TRACE1(".rsrc1 Keep old position.\t\tVirtualAddress %lu\t", pObjNew->VirtualAddress );
        // Check if we have enough room in the old .rsrc1
	    // Include the full size of the section, data + roundup
	   			if (cbResource - 
				(pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress) <=
				pObjOld->VirtualAddress - pObjNew->VirtualAddress ) {
		// we have to move back all the other section.
		// the .rsrc1 is bigger than what we need
		// adjust must be a negative number
		// calc new adjust size
					adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
	    			pObjResourceNew->VirtualAddress -
	    			pObjOld->VirtualAddress;
		// subtract old size
		//adjust -= pObjOld->VirtualAddress - pObjNew->VirtualAddress;
//					TRACE3("adjust: %ld\tsmall: New %lu\tOld %lu\n", adjust,
//	    			cbResource - 
//	    			(pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
//	    			pObjOld->VirtualAddress - pObjNew->VirtualAddress);
    			} else {  
		// we have to move the section again. the .rsrc1 is too small
		
					adjust = ROUNDUP(cbResource, New.OptionalHeader.SectionAlignment) +
	    			pObjResourceNew->VirtualAddress -
	    			pObjOld->VirtualAddress;
//					TRACE3("adjust: %lu\tsmall: New %lu\tOld %lu\n", adjust,
//	    			cbResource - 
//	    			(pObjResourceOldX->VirtualAddress - pObjResourceOld->VirtualAddress),
//	    			pObjOld->VirtualAddress - pObjNew->VirtualAddress);
	   			}
			}
			pObjNew++;
			goto rest_of_table;
    	}
    	else if (pObjNew < pObjResourceNew) {                     
	/* 
	 * There is no need for us to do anything. We have just to copy the 
	 * old section. There is no adjust we need to do
	 */
	//DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
	//     pObjOld - pObjtblOld + 1, pObjNew));
			*pObjNew++ = *pObjOld;      /* copy obj table entry */
//			TRACE3("Before .reloc, Just copy.\t\t %s\tVA: %lu\t adj: %ld\n",
//	   		(pObjNew-1)->Name,
//	   		(pObjNew-1)->VirtualAddress,
//	   		adjust);
    	}
    	else {
rest_of_table:
	//DPrintf((DebugBuf, "copying section table entry %i@%#08lx\n",
	//     pObjOld - pObjtblOld + 1, pObjNew));
	//DPrintf((DebugBuf, "adjusting VirtualAddress by %#08lx\n", adjust));
			*pObjNew++ = *pObjOld;
			(pObjNew-1)->VirtualAddress += adjust;
//			TRACE3("After .reloc, might get moved.\t\t%s\tVA: %lu\t adj: %ld\n",
//	   		(pObjNew-1)->Name,
//	   		(pObjNew-1)->VirtualAddress,
//	   		adjust);
    	}
    }

//    TRACE1("Number of section: %u\n", New.FileHeader.NumberOfSections);
    pObjNew = pObjtblNew + New.FileHeader.NumberOfSections - 1;
    New.OptionalHeader.SizeOfImage = ROUNDUP(pObjNew->VirtualAddress +
	pObjNew->SizeOfRawData,
	New.OptionalHeader.SectionAlignment);

    /* allocate room to build the resource directory/tables in */
	pResTab = (PIMAGE_RESOURCE_DIRECTORY)malloc(cbRestab);
    if (pResTab == NULL) {
    	cb = ERROR_NOT_ENOUGH_MEMORY;
    	goto AbortExit;
    }

    /* First, setup the "root" type directory table.  It will be followed by */
    /* Types directory entries.                          */

//v-guanx    RtlZeroMemory((PVOID)pResTab, cbRestab);
    memset((PVOID)pResTab,0, cbRestab);
    //DPrintf((DebugBuf, "resource directory tables: %#08lx bytes at %#08lx(mem)\n", cbRestab, pResTab));
    p = (PUCHAR)pResTab;
    pResTab->Characteristics = 0L;
    pResTab->TimeDateStamp = clock;
    pResTab->MajorVersion = MAJOR_RESOURCE_VERSION;
    pResTab->MinorVersion = MINOR_RESOURCE_VERSION;
    pResTab->NumberOfNamedEntries = (USHORT)cTypeStr;
    pResTab->NumberOfIdEntries = (USHORT)(cTypes - cTypeStr);

    /* Calculate the start of the various parts of the resource table.  */
    /* We need the start of the Type/Name/Language directories as well  */
    /* as the start of the UNICODE strings and the actual data nodes.   */

    pResDirT = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTab + 1);

    pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirT) +
	cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

	pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(((PUCHAR)pResDirN) +
	cTypes * sizeof(IMAGE_RESOURCE_DIRECTORY) +
	cNames * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

    pResData = (PIMAGE_RESOURCE_DATA_ENTRY)(((PUCHAR)pResDirL) +
	cNames * sizeof(IMAGE_RESOURCE_DIRECTORY) +
	cRes * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

	pResStr  = (PUSHORT)(((PUCHAR)pResData) +
	cRes * sizeof(IMAGE_RESOURCE_DATA_ENTRY));

    pResStrEnd = (PUSHORT)(((PUCHAR)pResStr) + cbName + cbType);

    /*
     * Loop over type table, building the PE resource table.
     */

    /*
     * *****************************************************************
     * This code doesn't sort the table - the TYPEINFO and RESINFO    **
     * insertion code in rcp.c (AddResType and SaveResFile) do the    **
     * insertion by ordinal type and name, so we don't have to sort   **
     * it at this point.                                              **
     * *****************************************************************
     */
    //DPrintf((DebugBuf, "building resource directory\n"));

    // First, add all the entries in the Types: Alpha list.

    //DPrintf((DebugBuf, "Walk the type: Alpha list\n"));
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
    //DPrintf((DebugBuf, "resource type "));
    //DPrintfu((pType->Type->szStr));
    //DPrintfn((DebugBuf, "\n"));

    	pResDirT->Name = (ULONG)((((BYTE *)pResStr) - p) |
	   	IMAGE_RESOURCE_NAME_IS_STRING);
    	pResDirT->OffsetToData = (ULONG)((((BYTE *)pResDirN) - p) |
	   	IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    	pResDirT++;

    	*pResStr = pType->Type->cbsz;
    	memcpy((WCHAR*)(pResStr+1), pType->Type->szStr, pType->Type->cbsz*sizeof(WCHAR));
    	pResStr += pType->Type->cbsz + 1;

	    pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    	SetRestab(pResTabN, clock,
		(USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    	pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

		pPreviousName = NULL;

    	pRes = pType->NameHeadName;
    	while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));

	   		if (pPreviousName == NULL ||
			memcmp(pPreviousName->szStr,
		   	pRes->Name->szStr,
		   	pRes->Name->cbsz*sizeof(WCHAR)) != 0) {
		// Setup a new name directory

	   			pResDirN->Name = (ULONG)((((BYTE *)pResStr)-p) |
	   			IMAGE_RESOURCE_NAME_IS_STRING);
				pResDirN->OffsetToData = (ULONG)((((BYTE *)pResDirL)-p) |
	   			IMAGE_RESOURCE_DATA_IS_DIRECTORY);
	   			pResDirN++;

	    // Copy the alpha name to a string entry

	   			*pResStr = pRes->Name->cbsz;
	   			memcpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz*sizeof(WCHAR));
	   			pResStr += pRes->Name->cbsz + 1;

				pPreviousName = pRes->Name;

		// Setup the Language table

				pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
				SetRestab(pResTabL, clock,
	   			(USHORT)0, (USHORT)pRes->NumberOfLanguages);
				pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
	   		}

	    // Setup a new Language directory

	   		pResDirL->Name = pRes->LanguageId;
	   		pResDirL->OffsetToData = (ULONG)(((BYTE *)pResData) - p);
	   		pResDirL++;

	    // Setup a new resource data entry

			SetResdata(pResData,
			pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
			pRes->DataSize);
			pResData++;

			pRes = pRes->pnext;
    	}

		pPreviousName = NULL;

    	pRes = pType->NameHeadID;
    	while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

	   		if (pPreviousName == NULL ||
			pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
		// Setup the name directory to point to the next language
		// table

	   			pResDirN->Name = pRes->Name->uu.Ordinal;
	   			pResDirN->OffsetToData = (ULONG)((((BYTE *)pResDirL)-p) |
	   			IMAGE_RESOURCE_DATA_IS_DIRECTORY);
	   			pResDirN++;

				pPreviousName = pRes->Name;

		// Init a new Language table

				pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
				SetRestab(pResTabL, clock,
	   			(USHORT)0, (USHORT)pRes->NumberOfLanguages);
				pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
	   		}

	    // Setup a new language directory entry to point to the next
	    // resource
	   		pResDirL->Name = pRes->LanguageId;
	   		pResDirL->OffsetToData = (ULONG)(((BYTE *)pResData) - p);
	   		pResDirL++;

	    // Setup a new resource data entry

			SetResdata(pResData,
			pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
			pRes->DataSize);
			pResData++;

			pRes = pRes->pnext;
    	}

    	pType = pType->pnext;
    }

    //  Do the same thing, but this time, use the Types: ID list.

    //DPrintf((DebugBuf, "Walk the type: ID list\n"));
    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    //DPrintf((DebugBuf, "resource type %hu\n", pType->Type->uu.Ordinal));

    	pResDirT->Name = (ULONG)pType->Type->uu.Ordinal;
    	pResDirT->OffsetToData = (ULONG)((((BYTE *)pResDirN) - p) |
	   	IMAGE_RESOURCE_DATA_IS_DIRECTORY);
    	pResDirT++;

    	pResTabN = (PIMAGE_RESOURCE_DIRECTORY)pResDirN;
    	SetRestab(pResTabN, clock,
		(USHORT)pType->NumberOfNamesName, (USHORT)pType->NumberOfNamesID);
    	pResDirN = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabN + 1);

		pPreviousName = NULL;

    	pRes = pType->NameHeadName;
    	while (pRes) {
	//DPrintf((DebugBuf, "resource "));
	//DPrintfu((pRes->Name->szStr));
	//DPrintfn((DebugBuf, "\n"));

	   		if (pPreviousName == NULL ||
			memcmp(pPreviousName->szStr,
		   	pRes->Name->szStr,
		   	pRes->Name->cbsz*sizeof(WCHAR)) != 0) {
		// Setup a new name directory

	   			pResDirN->Name = (ULONG)((((BYTE *)pResStr)-p) |
	   			IMAGE_RESOURCE_NAME_IS_STRING);
				pResDirN->OffsetToData = (ULONG)((((BYTE *)pResDirL)-p) |
				IMAGE_RESOURCE_DATA_IS_DIRECTORY);
				pResDirN++;

		// Copy the alpha name to a string entry.

	   			*pResStr = pRes->Name->cbsz;
	   			memcpy((WCHAR*)(pResStr+1),pRes->Name->szStr,pRes->Name->cbsz*sizeof(WCHAR));
	   			pResStr += pRes->Name->cbsz + 1;

				pPreviousName = pRes->Name;

		// Setup the Language table

				pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
				SetRestab(pResTabL, clock,
	   			(USHORT)0, (USHORT)pRes->NumberOfLanguages);
				pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
	   		}

	    // Setup a new Language directory

	   		pResDirL->Name = pRes->LanguageId;
	   		pResDirL->OffsetToData = (ULONG)(((BYTE *)pResData) - p);
	   		pResDirL++;

	    // Setup a new resource data entry

			SetResdata(pResData,
			pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
			pRes->DataSize);
			pResData++;

			pRes = pRes->pnext;
    	}

		pPreviousName = NULL;

    	pRes = pType->NameHeadID;
    	while (pRes) {
	//DPrintf((DebugBuf, "resource %hu\n", pRes->Name->uu.Ordinal));

	   		if (pPreviousName == NULL ||
			pPreviousName->uu.Ordinal != pRes->Name->uu.Ordinal) {
		// Setup the name directory to point to the next language
		// table

	   			pResDirN->Name = pRes->Name->uu.Ordinal;
				pResDirN->OffsetToData = (ULONG)((((BYTE *)pResDirL)-p) |
				IMAGE_RESOURCE_DATA_IS_DIRECTORY);
	   			pResDirN++;

				pPreviousName = pRes->Name;

		// Init a new Language table

				pResTabL = (PIMAGE_RESOURCE_DIRECTORY)pResDirL;
				SetRestab(pResTabL, clock,
	   			(USHORT)0, (USHORT)pRes->NumberOfLanguages);
				pResDirL = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pResTabL + 1);
	   		}

	    // Setup a new language directory entry to point to the next
	    // resource

	   		pResDirL->Name = pRes->LanguageId;
	   		pResDirL->OffsetToData = (ULONG)(((BYTE *)pResData) - p);
	  		pResDirL++;

	    // Setup a new resource data entry


			SetResdata(pResData,
			pRes->OffsetToData+pObjtblNew[nObjResource].VirtualAddress,
			pRes->DataSize);
			pResData++;

			pRes = pRes->pnext;
    	}

    	pType = pType->pnext;
    }
    //DPrintf((DebugBuf, "Zeroing %u bytes after strings at %#08lx(mem)\n",
    //     (pResStrEnd - pResStr) * sizeof(*pResStr), pResStr));
    while (pResStr < pResStrEnd) {
    	*pResStr++ = 0;
    }

#if DBG
    {
    USHORT  j = 0;
    PUSHORT pus = (PUSHORT)pResTab;

    while (pus < (PUSHORT)pResData) {
	//DPrintf((DebugBuf, "%04x\t%04x %04x %04x %04x %04x %04x %04x %04x\n",
	//     j,
	//   *pus,
	//     *(pus + 1),
	//     *(pus + 2),
	//     *(pus + 3),
	//     *(pus + 4),
	//     *(pus + 5),
	//     *(pus + 6),
	//     *(pus + 7)));
	pus += 8;
	j += 16;
    }
    }
#endif /* DBG */

    /*
     * copy the Old exe header and stub, and allocate room for the PE header.
     */
    //DPrintf((DebugBuf, "copying through PE header: %#08lx bytes @0x0\n",
    //     cbOldexe + sizeof(IMAGE_NT_HEADERS)));
    MoveFilePos(inpfh, 0L);
    MyCopy(inpfh, outfh, cbOldexe + sizeof(IMAGE_NT_HEADERS));

    /*
     * Copy rest of file header
     */
    //DPrintf((DebugBuf, "skipping section table: %#08lx bytes @%#08lx\n",
    //     New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
    //     FilePos(outfh)));
    //DPrintf((DebugBuf, "copying hdr data: %#08lx bytes @%#08lx ==> @%#08lx\n",
    //     Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd,
    //     ibObjTabEnd,
    //     ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
    //      Old.OptionalHeader.SizeOfHeaders));

    MoveFilePos(outfh, ibObjTabEnd + New.OptionalHeader.SizeOfHeaders -
	   	Old.OptionalHeader.SizeOfHeaders);
    MoveFilePos(inpfh, ibObjTabEnd);
    MyCopy(inpfh, outfh, Old.OptionalHeader.SizeOfHeaders - ibObjTabEnd);

    /*
     * copy existing image sections
     */

    /* Align data sections on sector boundary           */
    cb = REMAINDER(New.OptionalHeader.SizeOfHeaders, New.OptionalHeader.FileAlignment);
    New.OptionalHeader.SizeOfHeaders += cb;
    //DPrintf((DebugBuf, "padding header with %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
    while (cb >= cbPadMax) {
    	MyWrite(outfh, (PUCHAR)pchZero, cbPadMax);
    	cb -= cbPadMax;
    }
    MyWrite(outfh, (PUCHAR)pchZero, cb);

    cb = ROUNDUP(Old.OptionalHeader.SizeOfHeaders, Old.OptionalHeader.FileAlignment);
    MoveFilePos(inpfh, cb);

    /* copy one section at a time */
    New.OptionalHeader.SizeOfInitializedData = 0;
    for (pObjOld = pObjtblOld , pObjNew = pObjtblNew ;
	pObjOld < pObjLast ;
	pObjNew++) {
    	if (pObjOld == pObjResourceOldX)
			pObjOld++;
    	if (pObjNew == pObjResourceNew) {

	/* Write new resource section */
	//DPrintf((DebugBuf, "Primary resource section %i to %#08lx\n",
	//  nObjResource+1, FilePos(outfh)));

			pObjNew->PointerToRawData = FilePos(outfh);
			New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = pObjResourceNew->VirtualAddress;
	   		New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = cbResource;
			ibSave = FilePos(outfh);
	//DPrintf((DebugBuf,
	//  "writing resource header data: %#08lx bytes @%#08lx\n",
	//   cbRestab, ibSave));
			MyWrite(outfh, (PUCHAR)pResTab, cbRestab);

			pResSave = WriteResSection(pUpdate, outfh,
	    		New.OptionalHeader.FileAlignment,
	    		pObjResourceNew->SizeOfRawData-cbRestab,
	    		NULL);
			cb = FilePos(outfh);
	//DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
	//  cb - ibSave - cbRestab, ibSave + cbRestab));
			if (cbMustPad != 0) {
				cbMustPad -= cb - ibSave;
	//DPrintf((DebugBuf, "writing MUNGE pad: %#04lx bytes @%#08lx\n",
	//   cbMustPad, cb));
	/* assumes that cbMustPad % cbpadMax == 0 */
				while (cbMustPad > 0) {
	   				MyWrite(outfh, (PUCHAR)pchPad, cbPadMax);
	   				cbMustPad -= cbPadMax;
				}
				cb = FilePos(outfh);
			}
			if (nObjResourceX == -1) {
				MoveFilePos(outfh, ibSave);
	//DPrintf((DebugBuf,
	//  "re-writing resource directory: %#08x bytes @%#08lx\n",
	//  cbRestab, ibSave));
				MyWrite(outfh, (PUCHAR)pResTab, cbRestab);
				MoveFilePos(outfh, cb);
				cb = FilePos(inpfh);
				MoveFilePos(inpfh, cb+pObjOld->SizeOfRawData);
			}
			New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
			if (pObjResourceOld == NULL) {
				pObjNew++;
				goto next_section;
			}
			else
				pObjOld++;
    	}
    	else if (nObjResourceX != -1 && pObjNew == pObjtblNew + nObjResourceX) {

	/* Write new resource section */
	//DPrintf((DebugBuf, "Secondary resource section %i @%#08lx\n",
	//  nObjResourceX+1, FilePos(outfh)));

			pObjNew->PointerToRawData = FilePos(outfh);
			(void)WriteResSection(pUpdate, outfh,
	   		New.OptionalHeader.FileAlignment, 0xffffffff, pResSave);
			cb = FilePos(outfh);
			pObjNew->SizeOfRawData = cb - pObjNew->PointerToRawData;
	//DPrintf((DebugBuf, "wrote resource data: %#08lx bytes @%#08lx\n",
	//     pObjNew->SizeOfRawData, pObjNew->PointerToRawData));
			MoveFilePos(outfh, ibSave);
	//DPrintf((DebugBuf,
	//   "re-writing resource directory: %#08x bytes @%#08lx\n",
	//    cbRestab, ibSave));
			MyWrite(outfh, (PUCHAR)pResTab, cbRestab);
			MoveFilePos(outfh, cb);
			New.OptionalHeader.SizeOfInitializedData += pObjNew->SizeOfRawData;
			pObjNew++;
			goto next_section;
   		}
   		else {
			if (pObjNew < pObjResourceNew &&
			pObjOld->PointerToRawData != 0 &&
			pObjOld->PointerToRawData != FilePos(outfh)) {
				MoveFilePos(outfh, pObjOld->PointerToRawData);
 			}
next_section:
		    if ((Old.OptionalHeader.BaseOfCode == 0x400) &&
			(Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R3000 ||
	 		Old.FileHeader.Machine == IMAGE_FILE_MACHINE_R4000
			) &&
			(pObjOld->PointerToRawData != 0) &&
			(pObjOld->VirtualAddress != New.OptionalHeader.BaseOfCode) &&
			((pObjOld->Characteristics&IMAGE_SCN_CNT_CODE) != 0)
       		) {
				cb = FilePos(outfh) & 0xFFF;
				if (cb != 0) {
	    			cb = (cb ^ 0xFFF) + 1;
		    //DPrintf((DebugBuf, "padding driver code section %#08lx bytes @%#08lx\n", cb, FilePos(outfh)));
	    			while (cb >= cbPadMax) {
						MyWrite(outfh, (PUCHAR)pchZero, cbPadMax);
						cb -= cbPadMax;
	    			}
	    			MyWrite(outfh, (PUCHAR)pchZero, cb);
				}
    		}

	//DPrintf((DebugBuf, "copying section %i @%#08lx\n",
	//  pObjNew-pObjtblNew+1, FilePos(outfh)));
			if (pObjOld->PointerToRawData != 0) {
				pObjNew->PointerToRawData = FilePos(outfh);
				MoveFilePos(inpfh, pObjOld->PointerToRawData);
				MyCopy(inpfh, outfh, pObjOld->SizeOfRawData);
			}
			if (pObjOld == pObjDebugDirOld) {
				pObjDebugDirNew = pObjNew;
			}
    		if ((pObjNew->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) != 0)
				New.OptionalHeader.SizeOfInitializedData +=
				pObjNew->SizeOfRawData;
			pObjOld++;
   		}
   	}
   	if (pObjResourceOldX != NULL)
   		New.OptionalHeader.SizeOfInitializedData -=
    	pObjResourceOldX->SizeOfRawData;


    /* Update the address of the relocation table */
    pObjNew = FindSection(pObjtblNew,
    pObjtblNew+New.FileHeader.NumberOfSections,
    ".reloc");
   	if (pObjNew != NULL) {
   		New.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = pObjNew->VirtualAddress;
   	}

    /*
     * Write new section table out.
     */
    //DPrintf((DebugBuf, "writing new section table: %#08x bytes @%#08lx\n",
    //     New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER),
    //     ibObjTab));
   	MoveFilePos(outfh, ibObjTab);
   	MyWrite(outfh, (PUCHAR)pObjtblNew, New.FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    /*
     * Write updated PE header
     */
    //DPrintf((DebugBuf, "writing updated file header: %#08x bytes @%#08lx\n",
    //     sizeof(IMAGE_NT_HEADERS),
    //    cbOldexe));
   	MoveFilePos(outfh, (long)cbOldexe);
   	MyWrite(outfh, (PUCHAR)&New, sizeof(IMAGE_NT_HEADERS));

    /* Seek to end of output file and issue truncating write */
   	adjust = _llseek(outfh, 0L, SEEK_END);
   	MyWrite(outfh, NULL, 0);
    //DPrintf((DebugBuf, "file size is: %#08lx\n", adjust));

    /* If a debug section, fix up the debug table */
   	pObjNew = FindSection(pObjtblNew,
    pObjtblNew+New.FileHeader.NumberOfSections,
    ".debug");
   	cb = PatchDebug(inpfh, outfh,
	pObjDebug, pObjNew,
	pObjDebugDirOld, pObjDebugDirNew,
	&Old, &New, ibMaxDbgOffsetOld, (ULONG*)&adjust);

   	if (cb == NO_ERROR) {
   		if (pObjResourceOld == NULL) {
			cb = (LONG)pObjResourceNew->SizeOfRawData;
   		}
   		else {
			cb = (LONG)pObjResourceOld->SizeOfRawData -
 			(LONG)pObjResourceNew->SizeOfRawData;
   		}
   		cb = PatchRVAs(inpfh, outfh, pObjtblNew, cb,
		&New, Old.OptionalHeader.SizeOfHeaders);
   	}

    /* copy NOTMAPPED debug info */
   	if (pObjDebugDirOld != NULL && pObjDebug == NULL) {
   		ibSave = _llseek(inpfh, 0L, SEEK_END);  /* copy debug data */
   		_llseek(outfh, 0L, SEEK_END);       /* to EOF */
   		MoveFilePos(inpfh, adjust); /* returned by PatchDebug */
    //DPrintf((DebugBuf, "Copying NOTMAPPED Debug Information, %#08lx bytes\n", ibSave-adjust));
   		MyCopy(inpfh, outfh, ibSave-adjust);
   	}

   	_lclose(outfh);
    //DPrintf((DebugBuf, "files closed\n"));

    /* free up allocated memory */

    //DPrintf((DebugBuf, "freeing old section table: %#08lx(mem)\n", pObjtblOld));
   	free(pObjtblOld);
   //DPrintf((DebugBuf, "freeing resource directory: %#08lx(mem)\n", pResTab));
   	free(pResTab);

AbortExit:
    //DPrintf((DebugBuf, "freeing new section table: %#08lx(mem)\n", pObjtblNew));
   	free(pObjtblNew);
    return cb;
}

/***************************************************************************
 * WriteResSection
 *
 * This routine writes out the resources asked for into the current section.
 * It pads resources to dword (4-byte) boundaries.
 **************************************************************************/

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME    pResSave
    )
{
    ULONG   cbB=0;            /* bytes in current section    */
    ULONG   cbT;            /* bytes in current section    */
    ULONG   size;
    PRESNAME    pRes;
    PRESTYPE    pType;
    BOOL    fName;
    PVOID   lpData;

    /* Output contents associated with each resource */
    pType = pUpdate->ResTypeHeadName;
    while (pType) {
	    pRes = pType->NameHeadName;
    	fName = TRUE;
loop1:
    	for ( ; pRes ; pRes = pRes->pnext) {
			if (pResSave != NULL && pRes != pResSave)
			continue;
			pResSave = NULL;
#if DBG
	if (pType->Type->discriminant == IS_STRING) {
	    //DPrintf((DebugBuf, "    "));
	    //DPrintfu((pType->Type->szStr));
	    //DPrintfn((DebugBuf, "."));
	}
	else {
	    //DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
	}
	if (pRes->Name->discriminant == IS_STRING) {
	    //DPrintfu((pRes->Name->szStr));
	}
	else {
	    //DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
	}
#endif
			lpData = (PVOID)pRes->OffsetToDataEntry;
	//DPrintfn((DebugBuf, "\n"));

	/* if there is room in the current section, write it there */
			size = pRes->DataSize;
			if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
	//DPrintf((DebugBuf,
	//  "writing resource: %#04lx bytes @%#08lx\n",
	//  size, FilePos(outfh)));
				MyWrite(outfh, (PUCHAR)lpData, size);
	/* pad resource     */
				cbT = REMAINDER(size, CBLONG);
#ifdef DBG
	if (cbT != 0)
	    //DPrintf((DebugBuf,
	    //    "writing small pad: %#04lx bytes @%#08lx\n",
	    //    cbT, FilePos(outfh)));
#endif
				MyWrite(outfh, (PUCHAR)pchPad, cbT);    /* dword    */
				cbB += size + cbT;
				cbLeft -= size + cbT;       /* less left    */
				continue;       /* next resource    */
			}
			else {          /* will fill up section    */
	//DPrintf((DebugBuf, "Done with .rsrc section\n"));
				goto write_pad;
			}
    	}
    	if (fName) {
			fName = FALSE;
			pRes = pType->NameHeadID;
			goto loop1;
    	}
    	pType = pType->pnext;
    }

    pType = pUpdate->ResTypeHeadID;
    while (pType) {
    	pRes = pType->NameHeadName;
    	fName = TRUE;
loop2:
    	for ( ; pRes ; pRes = pRes->pnext) {
			if (pResSave != NULL && pRes != pResSave)
			continue;
			pResSave = NULL;
#if DBG
	if (pType->Type->discriminant == IS_STRING) {
	    //DPrintf((DebugBuf, "    "));
	    //DPrintfu((pType->Type->szStr));
	    //DPrintfn((DebugBuf, "."));
	}
	else {
	    //DPrintf(( DebugBuf, "    %d.", pType->Type->uu.Ordinal ));
	}
	if (pRes->Name->discriminant == IS_STRING) {
	    //DPrintfu((pRes->Name->szStr));
	}
	else {
	    //DPrintfn(( DebugBuf, "%d", pRes->Name->uu.Ordinal ));
	}
#endif
			lpData = (PVOID)pRes->OffsetToDataEntry;
	//DPrintfn((DebugBuf, "\n"));

	/* if there is room in the current section, write it there */
			size = pRes->DataSize;
			if (cbLeft != 0 && cbLeft >= size) {   /* resource fits?   */
	//DPrintf((DebugBuf,
	//  "writing resource: %#04lx bytes @%#08lx\n",
	//  size, FilePos(outfh)));
				MyWrite(outfh, (PUCHAR)lpData, size);
	/* pad resource     */
				cbT = REMAINDER(size, CBLONG);
#ifdef DBG
	if (cbT != 0)
	    //DPrintf((DebugBuf,
	    //    "writing small pad: %#04lx bytes @%#08lx\n",
	    //    cbT, FilePos(outfh)));
#endif
				MyWrite(outfh, (PUCHAR)pchPad, cbT);    /* dword    */
				cbB += size + cbT;
				cbLeft -= size + cbT;       /* less left    */
				continue;       /* next resource    */
			}
			else {          /* will fill up section    */
	//DPrintf((DebugBuf, "Done with .rsrc section\n"));
				goto write_pad;
			}
    	}
    	if (fName) {
			fName = FALSE;
			pRes = pType->NameHeadID;
			goto loop2;
    	}
    	pType = pType->pnext;
    }
    pRes = NULL;

write_pad:
    /* pad to alignment boundary */
    cbB = FilePos(outfh);
    cbT = ROUNDUP(cbB, align);
    cbLeft = cbT - cbB;
    //DPrintf((DebugBuf, "writing file sector pad: %#04lx bytes @%#08lx\n",
    //     cbLeft, FilePos(outfh)));
    if (cbLeft != 0) {
    	while (cbLeft >= cbPadMax) {
			MyWrite(outfh, (PUCHAR)pchPad, cbPadMax);
			cbLeft -= cbPadMax;
    	}
    	MyWrite(outfh, (PUCHAR)pchPad, cbLeft);
    }
    return pRes;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteResFile() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/


LONG
WriteResFile(
    HANDLE  hUpdate, 
    char    *pDstname)
{
    INT     inpfh;
    INT     outfh;
    ULONG   onewexe;
    IMAGE_DOS_HEADER    oldexe;
    PUPDATEDATA pUpdate;
    LONG        rc;
    LPTSTR	pFilename;
    static char     pSrcname[_MAX_PATH];
    OFSTRUCT OpenBuf;

    pUpdate = (PUPDATEDATA)GlobalLock(hUpdate);
    pFilename = (LPTSTR)GlobalLock(pUpdate->hFileName);
    memcpy(pSrcname, pFilename, strlen(pFilename));

    /* open the original exe file */
    
    //inpfh = (INT)CreateFileW(pFilename, GENERIC_READ,
    //      0 /*exclusive access*/, NULL /* security attr */,
    //      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
