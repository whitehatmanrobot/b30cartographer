Signers; i++)
        {
            MemFree(&ppv[i].blob.pBlobData);
        }
        MemFree(ppv);
    }

    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageBody::_FindAttribute
//
// Utility function designed to find attributes in an attribute set
// --------------------------------------------------------------------------------

PCRYPT_ATTRIBUTE CMessageBody::_FindAttribute(PCRYPT_ATTRIBUTES pattrs,
                                              LPCSTR pszObjId, DWORD iInstance)
{
    DWORD               i;

    if (pattrs == NULL)
        return NULL;

    for (i=0; i<pattrs->cAttr; i++)
    {
        if (lstrcmp(pattrs->rgAttr[i].pszObjId, pszObjId) == 0)
        {
            if (iInstance == 0)
            {
                return &pattrs->rgAttr[i];
            }
            else
            {
                iInstance -= 1;
            }
        }
    }

    return NULL;
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrSetAttribute
//
// Utility function designed to set attributes.  Called from set property as well
//      as public interface set attribute function
// --------------------------------------------------------------------------------

HRESULT CMessageBody::_HrSetAttribute(DWORD dwFlags, PCRYPT_ATTRIBUTES * ppattrs,
                                      LPCSTR pszObjId, DWORD cbNew, const BYTE * pbNew)
{
    DWORD               cAttr =0;
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    PCRYPT_ATTRIBUTES   pattrs = *ppattrs;
    PCRYPT_ATTRIBUTES   pattrs2 = NULL;
    LPBYTE              pb;
    CRYPT_ATTR_BLOB UNALIGNED *pVal = NULL;

    //
    //  We have a special case of pszObjId == NULL, in this case the entire
    //  encoded item is passed in
    //

    if (pszObjId == NULL)
    {
        hr = HrDecodeObject(pbNew, cbNew, szOID_Microsoft_Attribute_Sequence, 0,
                            &cb, (LPVOID *) &pattrs2);
        if (SUCCEEDED(hr))
        {
#ifdef _WIN64
        *ppattrs = (PCRYPT_ATTRIBUTES) MyPbAlignPb(*ppattrs);
#endif //_WIN64
            MemFree(*ppattrs);
            *ppattrs = NULL;
            *ppattrs = pattrs2;
            pattrs2 = NULL;
        }
        goto exit;
    }

    //
    //  Compute size of buffer we are going to need to hold the result
    //

    if (pattrs == NULL)
    {
        cb = sizeof(CRYPT_ATTRIBUTES);
    }
    else
    {
        cb = sizeof(CRYPT_ATTRIBUTES);

        for (i=0; i<pattrs->cAttr; i++)
        {
            Assert(pattrs->rgAttr[i].cValue == 1);

            //
            // If we are going to replace something, then set it's oid to NULL
            //

            if ((lstrcmp(pattrs->rgAttr[i].pszObjId, pszObjId) == 0) &&
                !(dwFlags & SMIME_ATTR_ADD_TO_EXISTING))
            {
                if (dwFlags & SMIME_ATTR_ADD_IF_NOT_EXISTS)
                {
                    return S_OK;
                }

                pattrs->rgAttr[i].pszObjId = NULL;
                continue;
            }

            pVal = &(pattrs->rgAttr[i].rgValue[0]);

            cb += ((DWORD) (sizeof(CRYPT_ATTRIBUTE) + sizeof(CRYPT_ATTR_BLOB) +
                strlen(pattrs->rgAttr[i].pszObjId) + 1 +
                pVal->cbData));
#ifdef _WIN64
            cb = LcbAlignLcb(cb);
#endif // _WIN64
            cAttr += 1;
        }
    }

    //
    // Add room for the one we are about to include
    //
#ifdef _WIN64
    cb = LcbAlignLcb(cb);
#endif // _WIN64

    cb += (DWORD)(sizeof(CRYPT_ATTRIBUTE) + sizeof(CRYPT_ATTR_BLOB) +
#ifdef _WIN64
        LcbAlignLcb(strlen(pszObjId) + 1) + cbNew);
#else
        strlen(pszObjId) + 1 + cbNew);
#endif // _WIN64
    cAttr += 1;

    //
    // Allocate Memory to hold the result
    //

    pattrs2 = (PCRYPT_ATTRIBUTES) g_pMalloc->Alloc(cb);
    if (pattrs2 == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    //
    //  Now copy over the items appending our item at the end
    //

    pattrs2->rgAttr = (PCRYPT_ATTRIBUTE) &pattrs2[1];
    pb = (LPBYTE) &pattrs2->rgAttr[cAttr];

    cAttr = 0;
    if (pattrs != NULL)
    {
        for (i=0; i<pattrs->cAttr; i++)
        {
            if (pattrs->rgAttr[i].pszObjId == NULL) continue;

            pattrs2->rgAttr[cAttr].pszObjId = (LPSTR) pb;
#ifdef _WIN64
            cb = LcbAlignLcb(strlen(pattrs->rgAttr[i].pszObjId) + 1);
#else
            cb = strlen(pattrs->rgAttr[i].pszObjId) + 1;
#endif // _WIN64
            memcpy(pb, pattrs->rgAttr[i].pszObjId, cb);
            pb += cb;

            pattrs2->rgAttr[cAttr].cValue = 1;
            pattrs2->rgAttr[cAttr].rgValue = (PCRYPT_ATTR_BLOB) pb;
#ifdef _WIN64
            pb += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB));
#else
            pb += sizeof(CRYPT_ATTR_BLOB);
#endif
            pVal = &(pattrs->rgAttr[i].rgValue[0]);

            cb = ((DWORD) (pVal->cbData));

#ifdef _WIN64
//             cb = LcbAlignLcb(cb);
#endif // _WIN64

            pVal = &(pattrs2->rgAttr[cAttr].rgValue[0]);

            pVal->pbData = pb;
            pVal->cbData = cb;

            pVal = &(pattrs->rgAttr[i].rgValue[0]);
            memcpy(pb, pVal->pbData, cb);

#ifdef _WIN64
            pb += LcbAlignLcb(cb);
#else
            pb += cb;
#endif
            cAttr += 1;
        }
    }

    //
    // Append the new one
    //

#ifdef _WIN64
    cb = LcbAlignLcb(strlen(pszObjId) + 1);
#else
    cb = strlen(pszObjId) + 1;
#endif // _WIN64
    pattrs2->rgAttr[cAttr].pszObjId = (LPSTR) pb;
    memcpy(pb, pszObjId, cb);
    pb += cb;

    pattrs2->rgAttr[cAttr].cValue = (DWORD) 1;
    pattrs2->rgAttr[cAttr].rgValue = (PCRYPT_ATTR_BLOB) pb;
#ifdef _WIN64
    pb += LcbAlignLcb(sizeof(CRYPT_ATTR_BLOB));
#else
    pb += sizeof(CRYPT_ATTR_BLOB);
#endif

    pVal = &(pattrs2->rgAttr[cAttr].rgValue[0]);

    pVal->cbData = (DWORD) cbNew;
    pVal->pbData = pb;
    memcpy(pb, pbNew, cbNew);
#ifdef _WIN64
    pb += LcbAlignLcb(cbNew);
#else
    pb += cbNew;
#endif

    pattrs2->cAttr = cAttr + 1;


    MemFree(*ppattrs);                  
    *ppattrs = NULL;
    *ppattrs = pattrs2;                 
    pattrs2 = NULL;

    hr = S_OK;
exit:
    if (pattrs2 != NULL)                MemFree(pattrs2);
    return hr;
}


#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bookbody.h ===
// --------------------------------------------------------------------------------
// BookBody.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BOOKBODY_H
#define __BOOKBODY_H

// --------------------------------------------------------------------------------
// IID_CMessageBody - {CDBC9B51-A489-11d0-85C4-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CMessageBody, 0xcdbc9b51, 0xa489, 0x11d0, 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "containx.h"
#include "privunk.h"

// --------------------------------------------------------------------------------
// Forward Refs
// --------------------------------------------------------------------------------
class CMessageBody;
class CBodyLockBytes;
typedef struct _CERT_CONTEXT CERT_CONTEXT;
typedef const CERT_CONTEXT *PCCERT_CONTEXT;
typedef void *HCERTSTORE;
typedef ULONG_PTR HCRYPTPROV;
typedef struct tagTREENODEINFO *LPTREENODEINFO;

#ifdef _WIN64
// --------------------------------------------------------------------------------
// CERTARRAY
// --------------------------------------------------------------------------------
struct tagCERTARRAY
{
    DWORD           cCerts;
    PCCERT_CONTEXT *rgpCerts;
};
typedef struct tagCERTARRAY CERTARRAY;
#endif // _WIN64

// --------------------------------------------------------------------------------
// STOREARRAY
// --------------------------------------------------------------------------------
struct tagSTOREARRAY
{
    DWORD           cStores;
    HCERTSTORE     *rgStores;
};
typedef struct tagSTOREARRAY STOREARRAY;

// --------------------------------------------------------------------------------
// BODYOPTIONS
// --------------------------------------------------------------------------------
typedef struct tagBODYOPTIONS {
    ENCODINGTYPE            ietTransmit;                // User specified transmission encoding...
    ULONG                   cbMaxLine;                  // Max Line length
    BOOL                    fWrapText;                  // Wrap the text in this body
    BOOL                    fRemoveNBSP;                // Remove NBSP on GetData
    BOOL                    fDBCSEscape8;               // Treat Escape (0x1b) characters in a dbcs encoding as 8bit
    BOOL                    fHideTNEF;                  // Hide TNEF Attachments
    // Security Options
    ULONG                   ulSecurityType;             // OID_SECURITY_TYPE
    BLOB *                  rgblobHash;                 // OID_SECURITY_ALG_HASH and OID_SECURITY_ALG_HASH_RG
    BLOB                    blobBulk;                   // OID_SECURITY_ALG_BULK
    PCCERT_CONTEXT *        rgpcCertSigning;            // OID_SECURITY_CERT_SIGNING and OID_SECURITY_CERT_SIGNING_RG
    PCCERT_CONTEXT          pcCertDecryption;           // OID_SECURITY_CERT_DECRYPTION
#ifdef _WIN65
    CERTARRAY               caEncrypt;                  // OID_SECURITY_RG_CERT_ENCRYPT
#endif // _WIN65
    HCERTSTORE              hCertStore;                 // OID_SECURITY_HCERTSTORE
    STOREARRAY              saSearchStore;              // OID_SECURITY_SEARCHSTORES
    DWORD                   cIASN;
    ULONG                  *rgIASN;                     // OID_SECURITY_RG_IASN
#ifdef SMIME_V3
    PCRYPT_ATTRIBUTES *     rgrgpattrs[3];              // OID_SECURITY_AUTHATTR_RG
#else // !SMIME_V3
    BLOB *                  rgblobSymCaps;              // OID_SECURITY_SYMCAPS and OID_SECURITY_SYMCAPS_RG
    BLOB *                  rgblobAuthAttr;             // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    BLOB *                  rgblobUnauthAttr;           // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    FILETIME *              rgftSigning;                // OID_SECURITY_SIGNTIME and OID_SECURITY_SIGNTIME_RG
#endif // SMIME_V3
    ULONG *                 rgulUserDef;                // OID_SECURITY_USER_VALIDITY and OID_SECURITY_USER_VALIDITY_RG
    ULONG *                 rgulROValid;                // OID_SECURITY_RO_MSG_VALIDITY and OID_SECURITY_RO_MSG_VALIDITY_RG
    HCRYPTPROV              hCryptProv;                 // OID_SECURITY_HCRYPTPROV
    ULONG                   ulEncodeFlags;              // OID_SECURITY_ENCODE_FLAGS
    BOOL                    fCertWithMsg;               // OID_SECURITY_CERT_INCLUDED
    HWND                    hwndOwner;                  // OID_SECURITY_HWND_OWNER
    ENCODINGTYPE            ietRequested;               // OID_SECURITY_REQUESTED_CTE
#ifdef SMIME_V3
    BLOB *                  rgblobReceipt;              // OID_SECURITY_RECEIPT_RG
    BLOB *                  rgblobMsgHash;              // OID_SECURITY_MESSAGE_HASH_RG
    LPWSTR                  pwszKeyPrompt;              // OID_SECURITY_KEY_PROMPT
#endif // SMIME_V3
    BOOL                    fShowMacBin;                // OID_SHOW_MACBINARY
    BOOL                    fExternalBody;              // OID_SUPPORT_EXTERNAL_BODY
    ULONG                   cSigners;                   // OID_SECURITY_SIGNATURE_COUNT // How many signers?
    BOOL                    fNoSecurityOnSave;          // OID_NOSECURITY_ON_SAVE
#ifdef SMIME_V3
    DWORD                   cRecipients;                // Actual Recipients
    DWORD                   cRecipsAllocated;           // Allocated Recipients
    PCMS_RECIPIENT_INFO     rgRecipients;               // Recipient Information
    HCERTSTORE              hstoreEncrypt;              // OID_SECURITY_ENCRYPT_CERT_BAG
#endif // SMIME_V3
} BODYOPTIONS, *LPBODYOPTIONS;

// --------------------------------------------------------------------------------
// BODYSTORAGE
// --------------------------------------------------------------------------------
typedef struct tagBODYSTORAGE {
    IID                     riid;           // Type of data source
    IUnknown               *pUnkRelease;    // Release this to free this object
    union {
        ILockBytes         *pLockBytes;     // IID_ILockBytes
        IMimeWebDocument   *pWebDocument;   // IID_IMimeWebDocument
    };
} BODYSTORAGE, *LPBODYSTORAGE;

// --------------------------------------------------------------------------------
// FCANSETDATAIID - IIDs that can be passed into IMimeBody::SetData
// --------------------------------------------------------------------------------
#define FBODYSETDATAIID(_iid) \
    (IID_IStream          == riid || \
     IID_ILockBytes       == riid || \
     IID_IMimeBody        == riid || \
     IID_IMimeMessage     == riid || \
     IID_IMimeWebDocument == riid)

// --------------------------------------------------------------------------------
// BODYSTATE
// --------------------------------------------------------------------------------
#define BODYSTATE_DIRTY       FLAG01        // The body is dirty
#define BODYSTATE_CSETTAGGED  FLAG02        // The body is tagged with a character set
#define BODYSTATE_SECURE      FLAG03        // The body is secure
#define BODYSTATE_EXTERNAL    FLAG04        // The body was content-Type: message/external-body
#define BODYSTATE_SKIPCSET    FLAG05        // The body character set has been set explicitly

#ifdef SMIME_V3
// --------------------------------------------------------------------------------
// ReceiptNames
// --------------------------------------------------------------------------------
typedef struct {
    DWORD               cNames;
    CERT_NAME_BLOB *    rgNames;
} ReceiptNames;
#endif // SMIME_V3


// --------------------------------------------------------------------------------
// Definition of IMimeBody
// --------------------------------------------------------------------------------
class CMessageBody : public CPrivateUnknown, public IMimeBodyW
#ifdef SMIME_V3 
                , public IMimeSecurity2
#endif // SMIME_V3
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMessageBody(LPTREENODEINFO pNode, IUnknown *pUnkOuter=NULL);
    ~CMessageBody(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) {
        return CPrivateUnknown::Release(); };

    // ---------------------------------------------------------------------------
    // IPersistStreamInit members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);

    // ---------------------------------------------------------------------------
    // IMimePropertySet members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP DeleteExcept(ULONG cNames, LPCSTR *prgszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam);
    STDMETHODIMP IsContentType(LPCSTR pszCntType, LPCSTR pszSubType);
    STDMETHODIMP Clone(IMimePropertySet **ppPropertySet);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo);
    STDMETHODIMP SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo);
    STDMETHODIMP EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum);

    // ---------------------------------------------------------------------------
    // IMimeBody members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetEstimatedSize(ENCODINGTYPE ietEncoding, ULONG *pcbSize);
    STDMETHODIMP GetDataHere(ENCODINGTYPE ietEncoding, IStream *pStream);
    STDMETHODIMP GetData(ENCODINGTYPE ietEncoding, IStream **ppStream);
    STDMETHODIMP SetData(ENCODINGTYPE ietEncoding, LPCSTR pszPriType, LPCSTR pszSubType, REFIID riid, LPVOID pvObject);
    STDMETHODIMP CopyTo(IMimeBody *pBody);
    STDMETHODIMP GetCurrentEncoding(ENCODINGTYPE *pietEncoding);
    STDMETHODIMP SetCurrentEncoding(ENCODINGTYPE ietEncoding);
    STDMETHODIMP GetHandle(LPHBODY phBody);
    STDMETHODIMP GetTransmitInfo(LPTRANSMITINFO pTransmit);
    STDMETHODIMP GetOffsets(LPBODYOFFSETS pOffsets);
    STDMETHODIMP SetDisplayName(LPCSTR pszDisplay);
    STDMETHODIMP GetDisplayName(LPSTR *ppszDisplay);
    STDMETHODIMP IsType(IMSGBODYTYPE type);
    STDMETHODIMP SaveToFile(ENCODINGTYPE ietEncoding, LPCSTR pszFilePath);
    STDMETHODIMP EmptyData(void);

    // ---------------------------------------------------------------------------
    // IMimeBodyW members
    // ---------------------------------------------------------------------------
    STDMETHODIMP SetDisplayNameW(LPCWSTR pwszDisplay);
    STDMETHODIMP GetDisplayNameW(LPWSTR *ppwszDisplay);
    STDMETHODIMP SetDataW(ENCODINGTYPE ietEncoding, LPCWSTR pwszPriType, LPCWSTR pwszSubType, REFIID riid, LPVOID pvObject);
    STDMETHODIMP SaveToFileW(ENCODINGTYPE ietEncoding, LPCWSTR pwszFilePath);

#ifdef SMIME_V3
    // ---------------------------------------------------------------------------
    // IMimeSecurity2 members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Encode(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback);
    STDMETHODIMP GetRecipientCount(DWORD dwFlags, DWORD *pdwRecipCount);
    STDMETHODIMP AddRecipient(DWORD dwFlags, DWORD cRecipData, PCMS_RECIPIENT_INFO recipData);
    STDMETHODIMP GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData);
    STDMETHODIMP DeleteRecipient(DWORD dwFlags, DWORD iRecipent, DWORD cRecipients);
    STDMETHODIMP GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              DWORD iInstance, LPCSTR pszObjId,
                              CRYPT_ATTRIBUTE ** ppattr);
    STDMETHODIMP SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              const CRYPT_ATTRIBUTE * pattr);
    STDMETHODIMP DeleteAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                                 DWORD iInstance, LPCSTR pszObjid);
    STDMETHODIMP CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                               const BYTE * pbFromNames, DWORD cSignerCertificates,
                               PCCERT_CONTEXT * rgSignerCertificates,
                               IMimeMessage ** ppMimeMessageReceipt);
    STDMETHODIMP GetReceiptSendersList(DWORD dwFlags, DWORD * pcSendersList,
                                       CERT_NAME_BLOB ** rgSendersList);
    STDMETHODIMP VerifyReceipt(DWORD dwFlags, IMimeMessage * pMimeMessageReceipt);
    STDMETHODIMP CapabilitiesSupported(DWORD * pdwFeatures);
#endif // SMIME_V3

    // ---------------------------------------------------------------------------
    // CMessageBody members
    // ---------------------------------------------------------------------------
    BOOL    FExtractRfc822Subject(LPWSTR *ppwszVal);
    void    ClearDirty(void);
    void    SetState(DWORD dwState);
    void    ClearState(DWORD dwState);
    HRESULT Load(CInternetStream *pInternet);
    HRESULT HrGetLockBytes(ILockBytes **ppLockBytes);
    HRESULT HrBindToTree(CStreamLockBytes *pStmLock, LPTREENODEINFO pNode);
    DWORD   DwGetFlags(BOOL fHideTnef);
    void    SwitchContainers(CMessageBody *pBody);
    void    CopyOptionsTo(CMessageBody *pBody, BOOL fNewOnwer=FALSE);
    HRESULT InternalSetOption(const TYPEDID oid, LPCPROPVARIANT pValue, BOOL fInternal, BOOL fNoDirty);

    // ---------------------------------------------------------------------------
    // Inlines
    // ---------------------------------------------------------------------------
    LPINETCSETINFO PGetTaggedCset(void) {
        EnterCriticalSection(&m_cs);
        LPINETCSETINFO p = m_pCsetTagged;
        LeaveCriticalSection(&m_cs);
        return p;
    }
    HRESULT GetPreviousEncoding(ENCODINGTYPE * pietEncoding) {
        if (ISFLAGSET(m_dwState, BODYSTATE_DIRTY)) {
            *pietEncoding = m_ietPrevious = IET_UNKNOWN;
        }
        else {
            *pietEncoding = m_ietPrevious;
        }
        return S_OK;
    }
    HRESULT SetPreviousEncoding(ENCODINGTYPE ietEncoding) {
        m_ietPrevious = ietEncoding;
        return S_OK;
    }

    // ---------------------------------------------------------------------------
    // CMessageBody Accessor Functions
    // ---------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    void RevokeTreeNode(void);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    DWORD _GetSecureTypeFlags();
    HRESULT _HrCopyDataStream(IStream *pstmSource, IStream *pstmDest);
    void _FreeOptions();
    void _BindToExternalBody(void);
#ifdef SMIME_V3
    static HRESULT _HrGetAttrs(DWORD cAttrs, PCRYPT_ATTRIBUTES * rgpattrs, LPCSTR pszOid, PROPVARIANT FAR * pvOut);
    static PCRYPT_ATTRIBUTE _FindAttribute(PCRYPT_ATTRIBUTES pattrs, LPCSTR pszObjId, DWORD iInstance);
    static HRESULT _HrSetAttribute(DWORD dwFlags, PCRYPT_ATTRIBUTES * ppattrs, LPCSTR pszObjectId, DWORD cb, const BYTE * pb);
#endif // SMIME_V3
#ifdef _WIN64
    static HRESULT _CAULToCERTARRAY(const CAUL caul, CERTARRAY *pca);
    static HRESULT _CERTARRAYToCAUL(const CERTARRAY ca, CAUL *pcaul);
    static HRESULT _CAUHToCERTARRAY(const CAUH cauh, CERTARRAY *pca);
    static HRESULT _CERTARRAYToCAUH(const CERTARRAY ca, CAUH *pcauh);
#endif // _WIN64
    static HRESULT _CAULToCertStore(const CAUL caul, HCERTSTORE * phcertstore);
    static HRESULT _CertStoreToCAUL(const HCERTSTORE hcertstore, CAUL *pcaul);
    static HRESULT _CAULToSTOREARRAY(const CAUL caul, STOREARRAY *psa);
    static HRESULT _STOREARRAYToCAUL(const STOREARRAY sa, CAUL *pcaul);
    static HRESULT _CAUHToCertStore(const CAUH cauh, HCERTSTORE * phcertstore);
    static HRESULT _CertStoreToCAUH(const HCERTSTORE hcertstore, CAUH *pcauh);
    static HRESULT _CAUHToSTOREARRAY(const CAUH cauh, STOREARRAY *psa);
    static HRESULT _STOREARRAYToCAUH(const STOREARRAY sa, CAUH *pcauh);

    HRESULT _HrEnsureBodyOptionLayers(LPCPROPVARIANT ppv);
    HRESULT _HrEnsureBodyOptionLayers(ULONG ulLayers);
    void _FreeLayerArrays(void);
    HRESULT _CompareCopyBlobArray(const PROPVARIANT FAR * pvSource, BLOB FAR * FAR * prgblDestination, BOOL fNoDirty);
#ifdef SMIME_V3
    HRESULT     _HrSizeOfRecipInfos(DWORD cItems, const CMS_RECIPIENT_INFO *);
    HRESULT     _HrCopyRecipInfos(DWORD cItems, const CMS_RECIPIENT_INFO * precipSrc,
                                  PCMS_RECIPIENT_INFO precipDst);
    HRESULT     _HrMapPublicKeyAlg(CERT_PUBLIC_KEY_INFO *, DWORD *,
                                   CRYPT_ALGORITHM_IDENTIFIER **);
    HRESULT     _SetNames(ReceiptNames * pnames, DWORD cNames, 
                          CERT_NAME_BLOB * rgNames);
    HRESULT     _MergeNames(ReceiptNames * pnames, DWORD cNames, 
                            CERT_NAME_BLOB * rgNames);
    STDMETHODIMP _GetReceiptRequest(DWORD dwFlags, 
                                    PSMIME_RECEIPT_REQUEST *ppreq,
                                    ReceiptNames *pReceiptsTo,
                                    DWORD *pcbReceipt,
                                    LPBYTE *ppbReceipt,
                                    DWORD *pcbMsgHash,
                                    LPBYTE *ppbMsgHash);
#endif // SMIME_V3


private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Counting
    DWORD               m_dwState;      // State of this body
    DWORD               m_cbExternal;   // Size of external body if m_dwState, BODYSTATE_EXTERNAL
    LPWSTR              m_pszDisplay;   // Display Name
    BODYOPTIONS         m_rOptions;     // Body Options
    BODYSTORAGE         m_rStorage;     // Body Data Source/Storage
    ENCODINGTYPE        m_ietEncoding;  // Internal Body Format
    LPINETCSETINFO      m_pCharset;     // Character set to be sent with
    LPINETCSETINFO      m_pCsetTagged;  // Original Character Set
    LPCONTAINER         m_pContainer;   // Property Container
    LPTREENODEINFO      m_pNode;        // Tree NodeInfo
    CRITICAL_SECTION    m_cs;           // Thread Safety
    ENCODINGTYPE        m_ietPrevious;  // Previous CTE 
};

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
typedef CMessageBody *LPMESSAGEBODY;

#endif // __BOOKBODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\booktree.h ===
// --------------------------------------------------------------------------------
// BookTree.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BOOKTREE_H
#define __BOOKTREE_H

// --------------------------------------------------------------------------------
// Depends On
// --------------------------------------------------------------------------------
#include "mimeole.h"
#include "privunk.h"
#include "variantx.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CBindStream;
class CMessageBody;
class CMessageWebPage;
typedef struct tagTEMPFILEINFO *LPTEMPFILEINFO;
typedef CMessageBody *LPMESSAGEBODY;
class CStreamLockBytes;
class CInternetStream;
class CMimePropertySet;
class CMessageTree;
class CBodyLockBytes;
class CActiveUrl;
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagRESOLVEURLINFO *LPRESOLVEURLINFO;
typedef class CActiveUrlRequest *LPURLREQUEST;

#define AthFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags) \
        CchFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags, \
        GetDateFormatWrapW, GetTimeFormatWrapW, GetLocaleInfoWrapW)


// --------------------------------------------------------------------------------
// For the Product Version
// --------------------------------------------------------------------------------
#include <ntverp.h>

// --------------------------------------------------------------------------------
// GUIDs
// --------------------------------------------------------------------------------
// {FD853CD8-7F86-11d0-8252-00C04FD85AB4}
DEFINE_GUID(IID_CMessageTree, 0xfd853cd8, 0x7f86, 0x11d0, 0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define VER_BODYTREEV2          0x00000001  // Version of the persisted body tree format
#define CCHMAX_BOUNDARY         45
#define STR_MIMEOLE_VERSION     "Produced By Microsoft MimeOLE V" VER_PRODUCTVERSION_STR
#define TREE_MIMEVERSION        1
#define CFORMATS_IDATAOBJECT    5          // Max number of formats in IDataObject impl

// --------------------------------------------------------------------------------
// Cache Node Signing
// --------------------------------------------------------------------------------
#define DwSignNode(_info, _index)           (DWORD)MAKELONG(_info.wSignature, _index)
#define FVerifySignedNode(_info, _snode)    (BOOL)(LOWORD(_snode) == _info.wSignature && HIWORD(_snode) < _info.cNodes)
#define PNodeFromSignedNode(_snode)         (m_rTree.prgpNode[HIWORD(_snode)])

// --------------------------------------------------------------------------------
// HBODY Macros
// --------------------------------------------------------------------------------
#define HBODYMAKE(_index)          (HBODY)MAKELPARAM(m_wTag, _index)
#define HBODYINDEX(_hbody)         (ULONG)HIWORD(_hbody)
#define HBODYTAG(_hbody)           (WORD)LOWORD(_hbody)

// --------------------------------------------------------------------------------
// TEXTTYPEINFO
// --------------------------------------------------------------------------------
typedef struct tagTEXTTYPEINFO {
    DWORD               dwTxtType;      // Text Type Flag
    LPCSTR              pszSubType;     // Text Subtype (plain)
    DWORD               dwWeight;       // Text Alternative Weight
} TEXTTYPEINFO, *LPTEXTTYPEINFO;

// --------------------------------------------------------------------------------
// CACHEINFOV2
// --------------------------------------------------------------------------------
typedef struct tagCACHEINFOV2 {
    WORD                wVersion;           // Version of the BIDXTABLE
    WORD                wSignature;         // Used to sign the nodes
    DWORD               dwReserved;         // Reserved
    DWORD               cbMessage;          // Size of the message this index was created for
    DWORD               iRoot;              // Zero-Based index of root node
    DWORD               cNodes;             // Number of nodes in the tree
    DWORD               rgReserved[6];      // Reserve 6 DWORDS for future use
} CACHEINFOV2, *LPCACHEINFOV2;

// --------------------------------------------------------------------------------
// CACHENODEV2
// --------------------------------------------------------------------------------
typedef struct tagCACHENODEV2 {
    DWORD               dwType;             // Flags for this node    
    DWORD               cChildren;          // Number of children
    DWORD               iParent;            // Index of parent of this node
    DWORD               iPrev;              // Index of next sibling to this node
    DWORD               iNext;              // Index of next sibling to this node
    DWORD               iChildHead;         // Index of first child
    DWORD               iChildTail;         // Tail Child
    DWORD               cbBodyStart;        // Byte offset to body start
    DWORD               cbBodyEnd;          // Byte offset to body end
    DWORD               cbHeaderStart;      // Byte offset to start of header
    DWORD               dwReserved;         // Not Used
    DWORD               dwBoundary;         // Boundary Type for this body
    DWORD               cbBoundaryStart;    // Byte offset to starting boundary
    DWORD               rgReserved[10];     // Reserve 6 DWORDS for future use
} CACHENODEV2, *LPCACHENODEV2;

// --------------------------------------------------------------------------------
// BINDNODESTATE
// --------------------------------------------------------------------------------
typedef enum tagBINDNODESTATE {
    BINDSTATE_COMPLETE=0,                   // The bind is complete
    BINDSTATE_PARSING_HEADER,               // Parsing a header
    BINDSTATE_FINDING_MIMEFIRST,            // Finding mime start boundary
    BINDSTATE_FINDING_MIMENEXT,             // Reading body to end mime boundary
    BINDSTATE_FINDING_UUBEGIN,              // begin uuencode
    BINDSTATE_FINDING_UUEND,                // End uuencode
    BINDSTATE_PARSING_RFC1154,              // Parsing an RFC1154 message
    BINDSTATE_LAST                          // Don't Use
} BINDNODESTATE;

// --------------------------------------------------------------------------------
// BOUNDARYTYPE
// --------------------------------------------------------------------------------
typedef enum tagBOUNDARYTYPE {
    BOUNDARY_NONE       = 0,                // No Boundary  
    BOUNDARY_ROOT       = 1,                // This is the root boundary (0)
    BOUNDARY_MIMEEND    = 3,                // Terminating mime boundary
    BOUNDARY_MIMENEXT   = 4,                // Mime Boundary non-terminating
    BOUNDARY_UUBEGIN    = 5,                // UUENCODE begining boundary
    BOUNDARY_UUEND      = 6,                // UUENCODE ending boundary
    BOUNDARY_LAST       = 7                 // Don't use
} BOUNDARYTYPE;

// --------------------------------------------------------------------------------
// PFNBINDPARSER
// --------------------------------------------------------------------------------
typedef HRESULT (CMessageTree::*PFNBINDPARSER)(THIS_);

// --------------------------------------------------------------------------------
// Node Flags
// --------------------------------------------------------------------------------
#define NODETYPE_INCOMPLETE         FLAG01  // The body's boundries do not match
#define NODETYPE_FAKEMULTIPART      FLAG02  // The body is a fake multipart    
#define NODETYPE_RFC1154_ROOT       FLAG03  // The body is the root of an RFC1154
#define NODETYPE_RFC1154_BINHEX     FLAG04  // The body is BINHEX from RFC1154

// --------------------------------------------------------------------------------
// Node State
// --------------------------------------------------------------------------------
#define NODESTATE_MESSAGE           FLAG01  // We are parsing a message/rfc822 body
#define NODESTATE_VERIFYTNEF        FLAG02  // Verify tnef signature after HrBindToTree
#define NODESTATE_BOUNDNOFREE       FLAG03  // Don't free BINDPARSEINFO::rBoundary (it is a copy)
#define NODESTATE_BOUNDTOTREE       FLAG04  // IMimeBody::HrBindToTree(pNode) has been called
#define NODESTATE_ONWEBPAGE         FLAG05  // CMessageWebPage has renedered the start body from this multipart/related body
#define NODESTATE_INSLIDESHOW       FLAG06  // CMessageWebPage will render this body in a slide show
#define WEBPAGE_NODESTATE_BITS      (NODESTATE_ONWEBPAGE | NODESTATE_INSLIDESHOW)
#define NODESTATE_AUTOATTACH        FLAG07  // Marked as an attachment in _HandleCanInlineTextOption

// --------------------------------------------------------------------------------
// TREENODEINFO
// --------------------------------------------------------------------------------
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef struct tagTREENODEINFO {
    HBODY               hBody;              // Index of this body in BODYTABLE::prgpBody
    DWORD               dwType;             // NODETYPE_xxx Flags
    DWORD               dwState;            // NODESTATE_xxx Flags
    HRESULT             hrBind;             // Bind Result
    ULONG               cChildren;          // Number of chilren if cnttype == CNT_MULTIPART
    DWORD               iCacheNode;         // Used for saving
    BINDNODESTATE       bindstate;          // Current parsing state
    PROPSTRINGA         rBoundary;          // Boundary
    BOUNDARYTYPE        boundary;           // Boundary Type for this body
    DWORD               cbBoundaryStart;    // Byte offset to starting boundary
    DWORD               cbHeaderStart;      // Byte offset to start of header
    DWORD               cbBodyStart;        // Byte offset to body start
    DWORD               cbBodyEnd;          // Byte offset to body end
    LPURLREQUEST        pResolved;          // Head Binding Requests
    LPTREENODEINFO      pBindParent;        // BindStackPrevious Node
    LPTREENODEINFO      pParent;            // Parent body
    LPTREENODEINFO      pNext;              // Next Sibling
    LPTREENODEINFO      pPrev;              // Previous Sibling
    LPTREENODEINFO      pChildHead;         // Handle to first child (if multipart)
    LPTREENODEINFO      pChildTail;         // Handle to first child (if multipart)
    LPCONTAINER         pContainer;         // The parsed header
    CBodyLockBytes     *pLockBytes;         // The binded tree data
    LPMESSAGEBODY       pBody;              // The body object for this tree node
} TREENODEINFO;                              

// --------------------------------------------------------------------------------
// TREENODETABLE
// --------------------------------------------------------------------------------
typedef struct tagTREENODETABLE {
    ULONG               cNodes;             // Number of valid elements in prgpBody
    ULONG               cEmpty;             // Number of empty cells in prgpBody
    ULONG               cAlloc;             // Number of elements allocated in prgpBody
    LPTREENODEINFO     *prgpNode;           // Array of pointers to bindinfo structs
} TREENODETABLE, *LPTREENODETABLE;

// --------------------------------------------------------------------------------
// Tree State
// --------------------------------------------------------------------------------
#define TREESTATE_DIRTY            FLAG01   // The tree is dirty
//#define TREESTATE_BOUND            FLAG02   // Load & LoadOffsetTable has bound success
#define TREESTATE_LOADED           FLAG03   // LoadOffsetTable has success
#define TREESTATE_HANDSONSTORAGE   FLAG04   // I have AddRef'ed somebodies storage
#define TREESTATE_SAVENEWS         FLAG05   // We are saving a news message    
#define TREESTATE_REUSESIGNBOUND   FLAG06   // Saving multipart/signed reuse boundary
#define TREESTATE_BINDDONE         FLAG07   // The bind operation is complete    
#define TREESTATE_BINDUSEFILE      FLAG08   // Hands off storage OnStopBinding
#define TREESTATE_LOADEDBYMONIKER  FLAG09   // IPersistMoniker::Load was called to load this
#define TREESTATE_RESYNCHRONIZE    FLAG10

// --------------------------------------------------------------------------------
// More Save Body Flags
// --------------------------------------------------------------------------------
#define SAVEBODY_UPDATENODES       FLAG32   // Update the node offsets to point to the new stream
#define SAVEBODY_SMIMECTE          FLAG31   // Change CTE rules for S/MIME bodies
#define SAVEBODY_REUSECTE          FLAG30   // Force CTE to be re-used

// --------------------------------------------------------------------------------
// Tree Options
// if you add anything to this struct, you *must* update g_rDefTreeOptions
// in imsgtree.cpp
// --------------------------------------------------------------------------------
typedef struct tagTREEOPTIONS {
    BYTE                fCleanupTree;       // Cleanup Tree On Save ?
    BYTE                fHideTnef;          // HIDE TNEF attachments?
    BYTE                fAllow8bitHeader;   // Allow 8bit in header
    BYTE                fGenMessageId;      // Should I generate the message id ?
    BYTE                fWrapBodyText;      // Wrap Body Text
    ULONG               cchMaxHeaderLine;   // Max header line length
    ULONG               cchMaxBodyLine;     // Max body line length
    MIMESAVETYPE        savetype;           // Commit type
    LPINETCSETINFO      pCharset;           // Current Character Set
    CSETAPPLYTYPE       csetapply;          // Method in which to use m_hCharset
    ENCODINGTYPE        ietTextXmit;        // Text transfer encoding
    ENCODINGTYPE        ietPlainXmit;       // Transmit Text Format
    ENCODINGTYPE        ietHtmlXmit;        // Transmit Text Format
    ULONG               ulSecIgnoreMask;    // Mask of ignorable errors
    RELOADTYPE          ReloadType;         // How the the root header be treated on a reload
    BOOL                fCanInlineText;     // Can the client inline multiple text bodies
    BOOL                fShowMacBin;        // Can the client handle macbinary??
    BOOL                fKeepBoundary;      // OID_SAVEBODY_KEEPBOUNDARY
    BOOL                fBindUseFile;       // If TRUE, I duplicate the stream on load
    BOOL                fHandsOffOnSave;    // Don't Hold onto pStream after IMimeMessage::Save
    BOOL                fExternalBody;      // Handle message/external-body
    BOOL                fDecodeRfc1154;     // Decode using RFC1154 (aka Encoding: header)
    // if you add anything to this struct, you *must* update g_rDefTreeOptions
    // in imsgtree.cpp
} TREEOPTIONS, *LPTREEOPTIONS;

// --------------------------------------------------------------------------------
// BOOKTREERESET - Used with _ResetObject
// --------------------------------------------------------------------------------
typedef enum tagBOOKTREERESET {
    BOOKTREE_RESET_DECONSTRUCT,
    BOOKTREE_RESET_LOADINITNEW,
    BOOKTREE_RESET_INITNEW
} BOOKTREERESET;

// --------------------------------------------------------------------------------
// BOOKTREE1154 - Used for RFC1154 Handling
// --------------------------------------------------------------------------------
typedef enum tagBT1154ENCODING {    // Body encoding type
    BT1154ENC_MINIMUM=0,
    BT1154ENC_TEXT=0,                   // text body
    BT1154ENC_UUENCODE=1,               // uuencoded body
    BT1154ENC_BINHEX=2,                 // binhex body
    BT1154ENC_MAXIMUM=2
} BT1154ENCODING;

typedef struct tagBT1154BODY {      // Info about one body
    BT1154ENCODING  encEncoding;        // Body encoding type
    ULONG           cLines;             // Number of lines in the body
} BT1154BODY;

typedef struct tagBOOKTREE1154 {    // Info about the state of RFC1154 handling
    ULONG       cBodies;                // Count of the number of bodies
    ULONG       cCurrentBody;           // The index of the current body (zero-based)
    ULONG       cCurrentLine;           // The current line number in the current body
    HRESULT     hrLoadResult;           // The result of the load.
    BT1154BODY  aBody[1];               // The bodies
} BOOKTREE1154, *LPBOOKTREE1154;

// --------------------------------------------------------------------------------
// CMessageTree Definition
// --------------------------------------------------------------------------------
class CMessageTree : public CPrivateUnknown,
                     public IMimeMessageW, 
                     public IDataObject,
                     public IPersistFile,
                     public IPersistMoniker,
                     public IServiceProvider,
#ifdef SMIME_V3
                     public IMimeSecurity2, 
#endif // SMIME_V3
                     public IBindStatusCallback
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMessageTree(IUnknown *pUnkOuter=NULL);
    virtual ~CMessageTree(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // ---------------------------------------------------------------------------
    // IDataObject members
    // ---------------------------------------------------------------------------
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFormatIn, FORMATETC *pFormatOut);
    STDMETHODIMP GetData(FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP GetDataHere(FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP QueryGetData(FORMATETC *pFormat);
    STDMETHODIMP SetData(FORMATETC *pFormat, STGMEDIUM *pMedium, BOOL fRelease) { 
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP DAdvise(FORMATETC *pFormat, DWORD, IAdviseSink *pAdvise, DWORD *pdwConn) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP DUnadvise(DWORD dwConn) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppEnum) {
        return TrapError(OLE_E_ADVISENOTSUPPORTED); }

    // ---------------------------------------------------------------------------
    // IPersist Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);

    // ---------------------------------------------------------------------------
    // IPersistMoniker Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    STDMETHODIMP GetCurMoniker(IMoniker **ppMoniker);
    STDMETHODIMP Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx) {
        return TrapError(E_NOTIMPL); }

    // ---------------------------------------------------------------------------
    // IPersistStreamInit Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);

    // ---------------------------------------------------------------------------
    // IPersistFile Members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);

    // ----------------------------------------------------------------------------
    // IServiceProvider methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void **ppvObj); /* IServiceProvider */

    // ---------------------------------------------------------------------------
    // IBindStatusCallback
    // ---------------------------------------------------------------------------
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding *pBinding);
    STDMETHODIMP GetPriority(LONG *plPriority);
    STDMETHODIMP OnLowResource(DWORD reserved);
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText);
    STDMETHODIMP OnStopBinding(HRESULT hrResult, LPCWSTR pszError);
    STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pBindInfo);
    STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFormat, STGMEDIUM *pMedium);
    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *pUnknown) { return TrapError(E_NOTIMPL); }

    // ---------------------------------------------------------------------------
    // IMimeMessageTree members
    // ---------------------------------------------------------------------------
    STDMETHODIMP LoadOffsetTable(IStream *pStream);
    STDMETHODIMP SaveOffsetTable(IStream *pStream, DWORD dwFlags);
    STDMETHODIMP GetMessageSize(ULONG *pcbSize, DWORD dwFlags);
    STDMETHODIMP Commit(DWORD dwFlags);
    STDMETHODIMP HandsOffStorage(void);
    STDMETHODIMP IsBodyType(HBODY hBody, IMSGBODYTYPE bodytype);
    STDMETHODIMP SaveBody(HBODY hBody, DWORD dwFlags, IStream *pStream);
    STDMETHODIMP BindToObject(const HBODY hBody, REFIID riid, void **ppvObject);
    STDMETHODIMP InsertBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody);
    STDMETHODIMP GetBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody);
    STDMETHODIMP DeleteBody(HBODY hBody, DWORD dwFlags);
    STDMETHODIMP MoveBody(HBODY hBody, BODYLOCATION location);
    STDMETHODIMP CountBodies(HBODY hParent, boolean fRecurse, ULONG *pcBodies);
    STDMETHODIMP FindFirst(LPFINDBODY pFindBody, LPHBODY phBody);
    STDMETHODIMP FindNext(LPFINDBODY pFindBody, LPHBODY phBody);
    STDMETHODIMP GetMessageSource(IStream **ppStream, DWORD dwFlags);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP ToMultipart(HBODY hBody, LPCSTR pszSubType, LPHBODY phMultipart);
    STDMETHODIMP GetBodyOffsets(HBODY hBody, LPBODYOFFSETS pOffsets);
    STDMETHODIMP IsContentType(HBODY hBody, LPCSTR pszCntType, LPCSTR pszSubType);
    STDMETHODIMP QueryBodyProp(HBODY hBody, LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeleteBodyProp(HBODY hBody, LPCSTR pszName);
    STDMETHODIMP GetFlags(DWORD *pdwFlags);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP ResolveURL(HBODY hRelated, LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, LPHBODY phBody);

    // ---------------------------------------------------------------------------
    // IMimeMessage members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetRootMoniker(LPMONIKER *ppmk); /* will die soon */
    STDMETHODIMP CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, IMimeMessageCallback *pCallback, IMoniker **ppMoniker);
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, IStream **ppStream, LPHBODY phBody);
    STDMETHODIMP SetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, HBODY hAlternative, IStream *pStream, LPHBODY phBody);
    STDMETHODIMP AttachObject(REFIID riid, void *pvObject, LPHBODY phBody);
    STDMETHODIMP AttachFile(LPCSTR pszFilePath, IStream *pstmFile, LPHBODY phBody);
    STDMETHODIMP GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach);
    STDMETHODIMP AttachURL(LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, IStream *pstmURL, LPSTR *ppszCID, LPHBODY phBody);
    STDMETHODIMP SplitMessage(ULONG cbMaxPart, IMimeMessageParts **ppParts);
    STDMETHODIMP GetAddressTable(IMimeAddressTable **ppTable);
    STDMETHODIMP GetSender(LPADDRESSPROPS pAddress);
    STDMETHODIMP GetAddressTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList);
    STDMETHODIMP GetAddressFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat);
    STDMETHODIMP EnumAddressTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum);

    // ---------------------------------------------------------------------------
    // IMimeMessageW members
    // ---------------------------------------------------------------------------
    STDMETHODIMP AttachFileW(LPCWSTR pszFilePath, IStream *pstmFile, LPHBODY phBody);
    STDMETHODIMP GetAddressFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppszFormat);
    STDMETHODIMP GetPropW(LPCWSTR pwszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP SetPropW(LPCWSTR pwszName, DWORD dwFlags, LPCPROPVARIANT pValue);
    STDMETHODIMP DeletePropW(LPCWSTR pwszName);
    STDMETHODIMP QueryPropW(LPCWSTR pwszName, LPCWSTR pwszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP AttachURLW(LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, IStream *pstmURL, LPWSTR *ppwszCID, LPHBODY phBody);
    STDMETHODIMP ResolveURLW(HBODY hRelated, LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, LPHBODY phBody);


#ifdef SMIME_V3
    // ---------------------------------------------------------------------------
    // IMimeSecurity2 members
    // ---------------------------------------------------------------------------

    STDMETHODIMP Encode(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pfn);
    STDMETHODIMP GetRecipientCount(DWORD dwFlags, DWORD *pdwRecipCount);
    STDMETHODIMP AddRecipient(DWORD dwFlags, DWORD cRecipData, PCMS_RECIPIENT_INFO recipData);
    STDMETHODIMP GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData);
    STDMETHODIMP DeleteRecipient(DWORD dwFlgas, DWORD iRecipient, DWORD cRecipients);
    STDMETHODIMP GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              DWORD iInstance, LPCSTR pszObjId,
                              CRYPT_ATTRIBUTE ** ppattr);
    STDMETHODIMP SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                              const CRYPT_ATTRIBUTE * pattr);
    STDMETHODIMP DeleteAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttributeSet,
                                 DWORD iInstance, LPCSTR pszObjid);
    STDMETHODIMP CreateReceipt(DWORD dwFlags, DWORD cbFromNames, const BYTE * pbFromNames, DWORD cSignerCertificates, PCCERT_CONTEXT * rgSignerCertificates, IMimeMessage ** ppMimeMessageRecipient);
    STDMETHODIMP GetReceiptSendersList(DWORD dwFlags, DWORD * pcSendersList, CERT_NAME_BLOB ** rgSendersList);
    STDMETHODIMP VerifyReceipt(DWORD dwFlags, IMimeMessage * pMimeMesageReceipt);
    STDMETHODIMP CapabilitiesSupported(DWORD * pdwFeatures);
#endif // SMIME_V3

    // ---------------------------------------------------------------------------
    // CMessageTree members
    // ---------------------------------------------------------------------------
    HRESULT IsState(DWORD dwState);
    DWORD   DwGetFlags(void);
    void    ClearDirty(void);
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    void SetState(DWORD dwState) {
        EnterCriticalSection(&m_cs);
        FLAGSET(m_dwState, dwState);
        LeaveCriticalSection(&m_cs);
    }

    // ---------------------------------------------------------------------------
    // Active Url Caching Methods
    // ---------------------------------------------------------------------------
    HRESULT HrActiveUrlRequest(LPURLREQUEST pRequest);
    HRESULT CompareRootUrl(LPCSTR pszUrl);
    HRESULT SetActiveUrl(CActiveUrl *pActiveUrl);

    // ---------------------------------------------------------------------------
    // CMessageTree members
    // ---------------------------------------------------------------------------
#ifdef DEBUG
    void DebugDumpTree(LPSTR pszfunc, BOOL fWrite);
    void DebugDumpTree(LPTREENODEINFO pParent, ULONG ulLevel, BOOL fVerbose);
    void DebugAssertNotLinked(LPTREENODEINFO pBody);
    void DebugWriteXClient();
#endif

private:
    // ----------------------------------------------------------------------------
    // Save Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrApplySaveSecurity(void);
    HRESULT _HrWriteMessage(IStream *pStream, BOOL fClearDirty, BOOL fHandsOffOnSave,
                            BOOL fSMimeCTE);
    HRESULT _HrCleanupMessageTree(LPTREENODEINFO pParent);
    HRESULT _HrSetMessageId(LPTREENODEINFO pNode);
    HRESULT _HrWriteUUFileName(IStream *pStream, LPTREENODEINFO pNode);
    HRESULT _HrWriteHeader(BOOL fClearDirty, IStream *pStream, LPTREENODEINFO pNode);
    HRESULT _HrWriteBoundary(LPSTREAM pStream, LPSTR pszBoundary, BOUNDARYTYPE boundary, LPDWORD pcboffStart, LPDWORD pcboffEnd);
    HRESULT _HrBodyInheritOptions(LPTREENODEINFO pNode);
    HRESULT _HrSaveBody(BOOL fClearDirty, DWORD dwFlags, IStream *pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrSaveMultiPart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrSaveSinglePart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, LPTREENODEINFO pNode, ULONG ulLevel);
    HRESULT _HrComputeBoundary(LPTREENODEINFO pNode, ULONG ulLevel, LPSTR pszBoundary, LONG cchMax);
    void    _GenerateBoundary(LPSTR pszBoundary, ULONG ulLevel);
    void    _HandleCanInlineTextOption(void);
    HRESULT _GetContentTransferEncoding(LPTREENODEINFO pNode, BOOL fText, BOOL fPlain, BOOL fMessage, BOOL fAttachment, DWORD dwFlags, ENCODINGTYPE *pietEncoding);

    // ----------------------------------------------------------------------------
    // BindToOffsetTable Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrBindOffsetTable(IStream *pStream, CStreamLockBytes **ppStmLock);
    HRESULT _HrFastParseBody(CInternetStream *pInternet, LPTREENODEINFO pNode);
    HRESULT _HrValidateOffsets(LPTREENODEINFO pNode);
    HRESULT _HrValidateStartBoundary(CInternetStream *pInternet, LPTREENODEINFO pNode, LPSTR *ppszFileName);
    HRESULT _HrComputeDefaultContent(LPTREENODEINFO pNode, LPCSTR pszFileName);

    // ----------------------------------------------------------------------------
    // Allocators / De-Allocator Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrCreateTreeNode(LPTREENODEINFO *ppNode);
    HRESULT _HrAllocateTreeNode(ULONG ulIndex);
    void    _PostCreateTreeNode(HRESULT hrResult, LPTREENODEINFO pNode);
    void    _FreeNodeTableElements(void);
    void    _UnlinkTreeNode(LPTREENODEINFO pNode);
    void    _FreeTreeNodeInfo(LPTREENODEINFO pNode, BOOL fFull=TRUE);

    // ----------------------------------------------------------------------------
    // International Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrSetCharsetTree(LPTREENODEINFO pNode, HCHARSET hCharset, CSETAPPLYTYPE applytype);
    HRESULT _HrGetCharsetTree(LPTREENODEINFO pNode, LPHCHARSET phCharset);

    // ----------------------------------------------------------------------------
    // Boundary Methods
    // ----------------------------------------------------------------------------
    BOOL    _FIsUuencodeBegin(LPPROPSTRINGA pLine, LPSTR *ppszFileName);
    BOUNDARYTYPE _GetMimeBoundaryType(LPPROPSTRINGA pLine, LPPROPSTRINGA pBoundary);

    // ----------------------------------------------------------------------------
    // Interface Recursion and Helper Methods
    // ----------------------------------------------------------------------------
    void    _DeleteChildren(LPTREENODEINFO pParent);
    void    _CountChildrenInt(LPTREENODEINFO pParent, BOOL fRecurse, ULONG *pcChildren);
    void    _InitNewWithoutRoot(void);
    void    _ApplyOptionToAllBodies(const TYPEDID oid, LPCPROPVARIANT pValue);
    void    _FuzzyPartialRecognition(BOOL fIsMime);
    void    _ResetObject(BOOKTREERESET ResetType);    
    void    _RecursiveGetFlags(LPTREENODEINFO pNode, LPDWORD pdwFlags, BOOL fInRelated);
    BOOL    _FIsValidHandle(HBODY hBody);
    HRESULT _HrLoadInitNew(void);
    HRESULT _HrDeletePromoteChildren(LPTREENODEINFO pNode);
    HRESULT _HrNodeFromHandle(HBODY hBody, LPTREENODEINFO *ppNode);
    HRESULT _HrRecurseResolveURL(LPTREENODEINFO pRelated, LPRESOLVEURLINFO pInfo, LPHBODY phBody);
    HRESULT _HrEnumeratAttachments(HBODY hBody, ULONG *pcBodies, LPHBODY prghBody);
    HRESULT _HrDataObjectGetHeaderA(LPSTREAM pStream);
    HRESULT _HrDataObjectGetHeaderW(LPSTREAM pStream);
    HRESULT _HrDataObjectWriteHeaderA(LPSTREAM pStream, UINT idsHeader, LPSTR pszData);
    HRESULT _HrDataObjectWriteHeaderW(LPSTREAM pStream, UINT idsHeader, LPWSTR pwszData);
    HRESULT _HrDataObjectGetSource(CLIPFORMAT cfFormat, LPSTREAM pstmData);
    HRESULT _HrGetTextTypeInfo(DWORD dwTxtType, LPTEXTTYPEINFO *ppTextInfo);
    HRESULT _FindDisplayableTextBody(LPCSTR pszSubType, LPTREENODEINFO pNode, LPHBODY phBody);
    LPTREENODEINFO _PNodeFromHBody(HBODY hBody);

    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    void    _LinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead);
    void    _ReleaseUrlRequestList(LPURLREQUEST *ppHead);
    void    _UnlinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead);
    void    _RelinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppSource, LPURLREQUEST *ppDest);
    HRESULT _HrBindNodeComplete(LPTREENODEINFO pNode, HRESULT hrResult);
    HRESULT _HrOnFoundMultipartEnd(void);
    HRESULT _HrOnFoundNodeEnd(DWORD cbBoundaryStart, HRESULT hrBind=S_OK);
    HRESULT _HrProcessPendingUrlRequests(void);
    HRESULT _HrResolveUrlRequest(LPURLREQUEST pRequest, BOOL *pfResolved);
    HRESULT _HrMultipartMimeNext(DWORD cboffBoundary);
    HRESULT _HrInitializeStorage(IStream *pStream);
    HRESULT _HrBindTreeNode(LPTREENODEINFO pNode);
    HRESULT _HrSychronizeWebPage(LPTREENODEINFO pNode);
    void    _DecodeRfc1154();

    // ----------------------------------------------------------------------------
    // Bind State Handlers
    // ----------------------------------------------------------------------------
    HRESULT _HrBindParsingHeader(void);
    HRESULT _HrBindFindingMimeFirst(void);
    HRESULT _HrBindFindingMimeNext(void);
    HRESULT _HrBindFindingUuencodeBegin(void);
    HRESULT _HrBindFindingUuencodeEnd(void);
    HRESULT _HrBindRfc1154(void);

    // ----------------------------------------------------------------------------
    // Static Array of Function Pointers
    // ----------------------------------------------------------------------------
    static const PFNBINDPARSER m_rgBindStates[BINDSTATE_LAST];

    // ----------------------------------------------------------------------------
    // CMessageWebPage is a good friend
    // ----------------------------------------------------------------------------
    friend CMessageWebPage;

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    TREEOPTIONS             m_rOptions;         // Save options
    LPWSTR                  m_pwszFilePath;     // File Used in IPersistFile
    WORD                    m_wTag;             // HBODY Tag
    DWORD                   m_cbMessage;        // Sizeof message
    DWORD                   m_dwState;          // State of the tree TS_xxx
    LPTREENODEINFO          m_pRootNode;        // Root Body Object
    CStreamLockBytes       *m_pStmLock;         // Protective Wrapper for m_pStream
    IMoniker               *m_pMoniker;         // Current moniker
    IBinding               *m_pBinding;         // Used in async binding operation
    CInternetStream        *m_pInternet;        // Text Stream that wraps m_pStmLock
    CBindStream            *m_pStmBind;         // Used for tempfile binding
    IStream                *m_pRootStm;         // Root document stream
    HRESULT                 m_hrBind;           // Current Bind Result
    LPTREENODEINFO          m_pBindNode;        // Current Node being parsed
    LPURLREQUEST            m_pPending;         // Head Un-resolved bind request
    LPURLREQUEST            m_pComplete;        // Head Un-resolved bind request
    TREENODETABLE           m_rTree;            // Body Table
    PROPSTRINGA             m_rRootUrl;         // Moniker Base Url
    CActiveUrl             *m_pActiveUrl;       // Active Url
    CMessageWebPage        *m_pWebPage;         // CreateWebPage Results
    WEBPAGEOPTIONS          m_rWebPageOpt;      // Web Page Options
    IMimeMessageCallback   *m_pCallback;      // WebPage Callback
    BOOL                    m_fApplySaveSecurity;// Used to prevent re-entrancy into _HrWriteMessage
    CRITICAL_SECTION        m_cs;               // Thread Safety
    LPBC                    m_pBC;              // bindcontext for moniker
    BOOKTREE1154           *m_pBT1154;          // State of RFC1154 handling
};

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
typedef CMessageTree *LPMESSAGETREE;

#endif // __BOOKTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bytebuff.cpp ===
// --------------------------------------------------------------------------------
// ByteBuff.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bytebuff.h"

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
CByteBuffer::CByteBuffer(LPBYTE pb /* =NULL */, ULONG cbAlloc /* =0 */, ULONG cb /* =0 */, ULONG i /* =0 */)
{
    m_cRef = 1;
    m_dwState = 0;
    m_cbGrow = BYTEBUFF_GROW;
    m_buffer.pb = pb;
    m_buffer.pbStatic = pb;
    m_buffer.cbAlloc = cbAlloc;
    m_buffer.cb = cb;
    m_buffer.i = i;
}

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
void CByteBuffer::Init(LPBYTE pb, ULONG cbAlloc, ULONG cb, ULONG i)
{
    m_buffer.pb = pb;
    m_buffer.cb = cb;
    m_buffer.i = i;
    m_buffer.cbAlloc = cbAlloc;
    m_buffer.pbStatic = pb;
}

// --------------------------------------------------------------------------------
// CByteBuffer::CByteBuffer
// --------------------------------------------------------------------------------
CByteBuffer::~CByteBuffer(void)
{
    // Free memory if not equal to static
    if (m_buffer.pb != m_buffer.pbStatic)
        g_pMalloc->Free(m_buffer.pb);
}

// --------------------------------------------------------------------------------
// CByteBuffer::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteBuffer::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CByteBuffer::_HrRealloc
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::_HrRealloc(DWORD cbAlloc)
{
    // Locals
    HRESULT     hr=S_OK;
    LPBYTE      pbAlloc=NULL;

    // This should have been checked
    Assert(cbAlloc > m_buffer.cbAlloc);

    // Currently using static ?
    if (m_buffer.pb == m_buffer.pbStatic)
    {
        // Allocate
        CHECKALLOC(pbAlloc = (LPBYTE)g_pMalloc->Alloc(cbAlloc));

        // Copy Data into pbAlloc
        CopyMemory(pbAlloc, m_buffer.pb, m_buffer.cb);
    }

    // Otherwise, realloc
    else
    {
        // Reallocate
        CHECKALLOC(pbAlloc = (LPBYTE)g_pMalloc->Realloc(m_buffer.pb, cbAlloc));
    }

    // Save pbAlloc
    m_buffer.pb = pbAlloc;

    // Save cbAlloc
    m_buffer.cbAlloc = cbAlloc;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteBuffer::Append
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::Append(LPBYTE pbData, ULONG cbData)
{
    // Locals
    HRESULT hr=S_OK;

    // Get Bigger and need to allocate
    if (m_buffer.cb + cbData > m_buffer.cbAlloc)
    {
        // Realloc
        CHECKHR(hr = _HrRealloc(m_buffer.cb + cbData + m_cbGrow));
    }

    // Append the data
    CopyMemory(m_buffer.pb + m_buffer.cb, pbData, cbData);

    // Save Size
    m_buffer.cb += cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteBuffer::SetSize
// --------------------------------------------------------------------------------
HRESULT CByteBuffer::SetSize(DWORD cb)
{
    // Locals
    HRESULT hr=S_OK;

    // Get Bigger and need to allocate
    if (cb > m_buffer.cb && cb > m_buffer.cbAlloc)
    {
        // Realloc
        CHECKHR(hr = _HrRealloc(cb + m_cbGrow));
    }

    // Save Size
    m_buffer.cb = cb;

    // Adjust Index
    if (m_buffer.i > cb)
        m_buffer.i = cb;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\booktree.cpp ===
// --------------------------------------------------------------------------------
// BookTree.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <stddef.h>
#include "dllmain.h"
#include "booktree.h"
#include "stmlock.h"
#include "ibdylock.h"
#include "resource.h"
#include "vstream.h"
#include "ixputil.h"
#include "olealloc.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "icoint.h"
#include "ibdystm.h"
#include "symcache.h"
#include "urlmon.h"
#include "mhtmlurl.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "inetstm.h"
#include "imnxport.h"
#include "msgmon.h"
#include "bookbody.h"
#include "mimeapi.h"
#include "strconst.h"
#include "bindstm.h"
#include "enriched.h"
#include "webpage.h"
#include "demand.h"

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// _IsMultiPart
// --------------------------------------------------------------------------------
inline BOOL _IsMultiPart(LPTREENODEINFO pNode)
{ 
    return pNode->pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK; 
}

// --------------------------------------------------------------------------------
// BINDASSERTARGS
// --------------------------------------------------------------------------------
#define BINDASSERTARGS(_bindstate, _fBoundary) \
    Assert(m_pBindNode && m_pBindNode->pBody && m_pBindNode->pContainer && _bindstate == m_pBindNode->bindstate && (FALSE == _fBoundary || ISVALIDSTRINGA(&m_pBindNode->rBoundary)))

// --------------------------------------------------------------------------------
// Array of Bind Parsing States to Functions
// --------------------------------------------------------------------------------
const PFNBINDPARSER CMessageTree::m_rgBindStates[BINDSTATE_LAST] = {
    NULL,                                                              // BINDSTATE_COMPLETE
    (PFNBINDPARSER)CMessageTree::_HrBindParsingHeader,          // BINDSTATE_PARSING_HEADER
    (PFNBINDPARSER)CMessageTree::_HrBindFindingMimeFirst,       // BINDSTATE_FINDING_MIMEFIRST
    (PFNBINDPARSER)CMessageTree::_HrBindFindingMimeNext,        // BINDSTATE_FINDING_MIMENEXT
    (PFNBINDPARSER)CMessageTree::_HrBindFindingUuencodeBegin,   // BINDSTATE_FINDING_UUBEGIN
    (PFNBINDPARSER)CMessageTree::_HrBindFindingUuencodeEnd,     // BINDSTATE_FINDING_UUEND
    (PFNBINDPARSER)CMessageTree::_HrBindRfc1154,                // BINDSTATE_PARSING_RFC1154
};

// --------------------------------------------------------------------------------
// Used in IMimeMessageTree::ToMultipart
// --------------------------------------------------------------------------------
static LPCSTR g_rgszToMultipart[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

// --------------------------------------------------------------------------------
// Used in IMimeMessage::AttachObject IID_IMimeBody
// --------------------------------------------------------------------------------
static LPCSTR g_rgszAttachBody[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

static const WEBPAGEOPTIONS g_rDefWebPageOpt = {
    sizeof(WEBPAGEOPTIONS),                        // cbsize
    WPF_NOMETACHARSET | WPF_HTML | WPF_AUTOINLINE, // dwFlags
    3000,                                          // dwDelay
    NULL                                           // wchQuote
};

// --------------------------------------------------------------------------------
// Default Tree Options
// --------------------------------------------------------------------------------
static const TREEOPTIONS g_rDefTreeOptions = {
    DEF_CLEANUP_TREE_ON_SAVE,       // OID_CLEANUP_TREE_ON_SAVE
    DEF_HIDE_TNEF_ATTACHMENTS,      // OID_HIDE_TNEF_ATTACHMENTS
    DEF_ALLOW_8BIT_HEADER,          // OID_ALLOW_8BIT_HEADER
    DEF_GENERATE_MESSAGE_ID,        // OID_GENERATE_MESSAGE_ID
    DEF_WRAP_BODY_TEXT,             // OID_WRAP_BODY_TEXT
    DEF_CBMAX_HEADER_LINE,          // OID_CBMAX_HEADER_LINE
    DEF_CBMAX_BODY_LINE,            // OID_CBMAX_BODY_LINE
    SAVE_RFC1521,                   // OID_SAVE_FORMAT
    NULL,                           // hCharset
    CSET_APPLY_UNTAGGED,            // csetapply
    DEF_TRANSMIT_TEXT_ENCODING,     // OID_TRANSMIT_TEXT_ENCODING
    DEF_XMIT_PLAIN_TEXT_ENCODING,   // OID_XMIT_PLAIN_TEXT_ENCODING
    DEF_XMIT_HTML_TEXT_ENCODING,    // OID_XMIT_HTML_TEXT_ENCODING
    0,                              // OID_SECURITY_ENCODE_FLAGS
    DEF_HEADER_RELOAD_TYPE_TREE,    // OID_HEADER_REALOD_TYPE
    DEF_CAN_INLINE_TEXT_BODIES,     // OID_CAN_INLINE_TEXT_BODIES
    DEF_SHOW_MACBINARY,             // OID_SHOW_MACBINARY
    DEF_SAVEBODY_KEEPBOUNDARY,      // OID_SAVEBODY_KEEPBOUNDARY
    FALSE,                          // OID_LOAD_USE_BIND_FILE
    DEF_HANDSOFF_ONSAVE,            // OID_HANDSOFF_ONSAVE
    DEF_SUPPORT_EXTERNAL_BODY,      // OID_SUPPORT_EXTERNAL_BODY
    DEF_DECODE_RFC1154              // OID_DECODE_RFC1154
};

extern BOOL FIsMsasn1Loaded();

#ifdef DEBUG
// --------------------------------------------------------------------------------
// These booleans determine if the tree is dumped to the output window
// --------------------------------------------------------------------------------
static BOOL s_fWriteMessageDump     = 0;
static BOOL s_fKeepBoundary         = 0;
static BOOL s_fDumpMessage          = 0;
static BOOL s_fWriteXClient         = 0;

// --------------------------------------------------------------------------------
// This writes the message X-Mailer or X-Newsreader
// --------------------------------------------------------------------------------
void CMessageTree::DebugWriteXClient()
{
    if (s_fWriteXClient)
    {
        LPSTR pszX;
        if (SUCCEEDED(m_pRootNode->pContainer->GetProp(SYM_HDR_XMAILER, &pszX)) && pszX)
        {
            DebugTrace("X-Mailer: %s\n", pszX);
            MemFree(pszX);
        }
        else if (SUCCEEDED(m_pRootNode->pContainer->GetProp(SYM_HDR_XNEWSRDR, &pszX)) && pszX)
        {
            DebugTrace("X-Newsreader: %s\n", pszX);
            MemFree(pszX);
        }
    }
}

// --------------------------------------------------------------------------------
// This dumps the current tree to debug output window
// --------------------------------------------------------------------------------
void CMessageTree::DebugDumpTree(LPSTR pszfunc, BOOL fWrite)
{
    if (TRUE == fWrite)
    {
        DebugTrace("---------------------------------------------------------------------------\n");
        DebugTrace("CMessageTree::%s\n", pszfunc);
    }
    DebugDumpTree(m_pRootNode, 0, fWrite);
}

// --------------------------------------------------------------------------------
// This macros writes _pstm to a file
// --------------------------------------------------------------------------------
#define DEBUGMESSAGEOUT "c:\\lastmsg.txt"
void DebugWriteMsg(LPSTREAM pstm)
{
    if (TRUE == s_fDumpMessage)
    {
        LPSTREAM pstmFile;
        if (SUCCEEDED(OpenFileStream(DEBUGMESSAGEOUT, CREATE_ALWAYS, GENERIC_WRITE, &pstmFile)))
        {
            HrRewindStream(pstm);
            HrCopyStream(pstm, pstmFile, NULL);
            pstmFile->Commit(STGC_DEFAULT);
            pstmFile->Release();
        }
    }
}

#else // DEBUG

#define DebugDumpTree           1 ? (void)0 : (void)
#define DebugWriteMsg           1 ? (void)0 : (void)
#define DebugAssertNotLinked    1 ? (void)0 : (void)
#define DebugIsRootContainer    1 ? (void)0 : (void)

#endif // DEBUG

// --------------------------------------------------------------------------------
// WebBookContentTree_CreateInstance
// --------------------------------------------------------------------------------
HRESULT WebBookContentTree_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageTree *pNew = new CMessageTree(pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// Text Type Information Array
// --------------------------------------------------------------------------------
static const TEXTTYPEINFO g_rgTextInfo[] = {
    { TXT_PLAIN,    STR_SUB_PLAIN,      0 },
    { TXT_HTML,     STR_SUB_HTML,       5 }
};

// --------------------------------------------------------------------------------
// CMessageTree::CMessageTree
// --------------------------------------------------------------------------------
CMessageTree::CMessageTree(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_dwState = 0;
    m_pCallback = NULL;
    m_pBindNode = NULL;
    m_pRootStm = NULL;
    m_pInternet = NULL;
    m_pStmBind = NULL;
    m_pBinding = NULL;
    m_pMoniker = NULL;
    m_pBC = NULL;
    m_cbMessage = 0;
    m_pStmLock = NULL;
    m_pRootNode = NULL;
    m_pwszFilePath = NULL;
    m_hrBind = S_OK;
    m_pPending = NULL;
    m_pComplete = NULL;
    m_wTag = LOWORD(GetTickCount());
    m_pActiveUrl = NULL;
    m_pWebPage = NULL;
    m_fApplySaveSecurity = FALSE;
    m_pBT1154 = NULL;
    while(m_wTag == 0 || m_wTag == 0xffff) m_wTag++;
    ZeroMemory(&m_rRootUrl, sizeof(PROPSTRINGA));
    ZeroMemory(&m_rTree, sizeof(TREENODETABLE));
    CopyMemory(&m_rWebPageOpt, &g_rDefWebPageOpt, sizeof(WEBPAGEOPTIONS));
    CopyMemory(&m_rOptions, &g_rDefTreeOptions, sizeof(TREEOPTIONS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageTree::~CMessageTree
// --------------------------------------------------------------------------------
CMessageTree::~CMessageTree(void)
{
    if(m_pActiveUrl && g_pUrlCache)
    {
        //Bug #101348 - free CActiveUrl leaked to the CMimeActiveUrlCache
        g_pUrlCache->RemoveUrl(m_pActiveUrl);
        m_pActiveUrl = NULL;
    }
	
    // Reset the Object
    _ResetObject(BOOKTREE_RESET_DECONSTRUCT);


    // Kill the Critical Section
    DeleteCriticalSection(&m_cs);

    // Releaes the Dll
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMessageTree::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CMessageTree::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Interface Map
    if (IID_IPersist == riid)
        *ppv = (IPersist *)(IPersistStreamInit *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_IMimeMessage == riid)
        *ppv = (IMimeMessage *)this;
    else if (IID_IMimeMessageW == riid)
        *ppv = (IMimeMessageW *)this;
    else if (IID_IMimeMessageTree == riid)
        *ppv = (IMimeMessageTree *)this;
    else if (IID_IDataObject == riid)
        *ppv = (IDataObject *)this;
    else if (IID_IPersistFile == riid)
        *ppv = (IPersistFile *)this;
    else if (IID_IBindStatusCallback == riid)
        *ppv = (IBindStatusCallback *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_CMessageTree == riid)
        *ppv = (CMessageTree *)this;
    else if (IID_IPersistMoniker == riid)
        *ppv = (IPersistMoniker *)this;
#ifdef SMIME_V3
    else if (IID_IMimeSecurity2 == riid)
        *ppv = (IMimeSecurity2 *) this;
#endif // SMIME_V3   

    // E_NOINTERFACE
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// CMessageTree::DebugDumpTree
// --------------------------------------------------------------------------------
void CMessageTree::DebugDumpTree(LPTREENODEINFO pParent, ULONG ulLevel, BOOL fVerbose)
{
    // Locals
    LPSTR           pszPriType=NULL,
                    pszEncoding=NULL,
                    pszFileName=NULL;
    LPTREENODEINFO  pChild,
                    pPrev,
                    pNext;
    ULONG           cChildren;
    LONG            lRendered=-1;
    PROPVARIANT     rVariant;

    // Get Content Type
    if (fVerbose)
    {
        Assert(pParent->pContainer->GetProp(SYM_HDR_CNTTYPE, &pszPriType) == S_OK);
        Assert(pParent->pContainer->GetProp(SYM_HDR_CNTXFER,  &pszEncoding) == S_OK);
        Assert(pParent->pContainer->GetProp(SYM_ATT_GENFNAME,  &pszFileName) == S_OK);

        rVariant.vt = VT_UI4;
        if (SUCCEEDED(pParent->pContainer->GetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)))
            lRendered = (LONG)rVariant.ulVal;

        for (ULONG i=0; i<ulLevel; i++)
            DebugTrace("     ");
        DebugTrace("%0x == > %s (%s - %s) Rendered: %ld\n", pParent->hBody, pszPriType, pszFileName, pszEncoding, lRendered);
    }
 
    // IsMultiPart
    if (_IsMultiPart(pParent))
    {
        // Count Children
        cChildren = 0;
        pPrev = NULL;

        // Increment the level
        ulLevel++;

        // Loop Chilren
        for (pChild=pParent->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Verify Handle
            Assert(_FIsValidHandle(pChild->hBody));

            // Check Parent
            AssertSz(pChild->pParent == pParent, "Parent is wrong");

            // Check pParent Child Head
            if (NULL == pChild->pPrev)
                Assert(pParent->pChildHead == pChild);

            // Check pParent Child Tail
            if (NULL == pChild->pNext)
                Assert(pParent->pChildTail == pChild);

            // Valid Prev
            Assert(pChild->pPrev == pPrev);

            // Dump This Child
            DebugDumpTree(pChild, ulLevel, fVerbose);

            // Count Children
            cChildren++;

            // Set Previous
            pPrev = pChild;
        }

        // Verify Children
        Assert(pParent->cChildren == cChildren);
    }

    // Cleanup
    SafeMemFree(pszPriType);
    SafeMemFree(pszEncoding);
    SafeMemFree(pszFileName);
}

// --------------------------------------------------------------------------------
// CMessageTree::DebugAssertNotLinked
// This insures that pNode is not referenced by the tree
// --------------------------------------------------------------------------------
void CMessageTree::DebugAssertNotLinked(LPTREENODEINFO pNode)
{
    // Better not be the root
    Assert(m_pRootNode != pNode);

    // Loop through bodies
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        if (NULL == m_rTree.prgpNode[i])
            continue;
        
        // Check if linked to pBody
        Assert(m_rTree.prgpNode[i]->pParent != pNode);
        Assert(m_rTree.prgpNode[i]->pChildHead != pNode);
        Assert(m_rTree.prgpNode[i]->pChildTail != pNode);
        Assert(m_rTree.prgpNode[i]->pNext != pNode);
        Assert(m_rTree.prgpNode[i]->pPrev != pNode);
    }
}

#endif // DEBUG

// --------------------------------------------------------------------------------
// CMessageTree::IsState
// --------------------------------------------------------------------------------
HRESULT CMessageTree::IsState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, dwState)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetRootMoniker (This Function will die soon)
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetRootMoniker(LPMONIKER *ppmk)
{
    return HrCreateMsgMoniker(IID_IMimeMessage, (LPUNKNOWN)(IMimeMessage *)this, ppmk);
}

// --------------------------------------------------------------------------------
// CMessageTree::CreateWebPage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, 
    IMimeMessageCallback *pCallback, IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pwszRootUrl=NULL;

    // Invalid Arg
    if (NULL == ppMoniker)
        return TrapError(E_INVALIDARG);

    // If an options structure was passed in, is it the right size ?
    if (pOptions && sizeof(WEBPAGEOPTIONS) != pOptions->cbSize)
        return TrapError(E_INVALIDARG);

    // Init
    *ppMoniker = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release Current BindRoot Stream
    SafeRelease(m_pRootStm);
    SafeRelease(m_pWebPage);

    // Null pStream is allowed
    if (pStmRoot)
    {
        // Save Root Stream
        m_pRootStm = pStmRoot;
        m_pRootStm->AddRef();
    }

    // Otherwise, we can inline text bodies...
    else
    {
        // Change Option
        m_rOptions.fCanInlineText = TRUE;
    }

    // Release current webpage callback
    SafeRelease(m_pCallback);

    // Setup the new webpage callback
    if (pCallback)
    {
        m_pCallback = pCallback;
        m_pCallback->AddRef();
    }

    // Save WebPageOptions
    if (pOptions)
        CopyMemory(&m_rWebPageOpt, pOptions, sizeof(WEBPAGEOPTIONS));
    else
        CopyMemory(&m_rWebPageOpt, &g_rDefWebPageOpt, sizeof(WEBPAGEOPTIONS));

    // Already have a Base Url from IMimeMessageTree::IPersitMoniker::Load
    if (NULL == m_rRootUrl.pszVal)
    {
        // Locals
        CHAR szRootUrl[CCHMAX_MID + 8];

        // Build MessageID
        m_rRootUrl.cchVal = wsprintf(szRootUrl, "mhtml:mid://%08d/", DwCounterNext());

        // Allocate
        CHECKALLOC(m_rRootUrl.pszVal = (LPSTR)g_pMalloc->Alloc(m_rRootUrl.cchVal + 1));

        // Copy memory
        CopyMemory((LPBYTE)m_rRootUrl.pszVal, (LPBYTE)szRootUrl, m_rRootUrl.cchVal + 1);

        // Register this object in the list of active objects
        Assert(g_pUrlCache);
        CHECKHR(hr = g_pUrlCache->RegisterActiveObject(m_rRootUrl.pszVal, this));

        // We shuould have a m_pActiveUrl now
        Assert(m_pActiveUrl != NULL);

        // Set some flags on the activeurl
        m_pActiveUrl->SetFlag(ACTIVEURL_ISFAKEURL);

        // Is valid
        Assert(ISVALIDSTRINGA(&m_rRootUrl));
    }

    // Convert Url to Wide
    CHECKALLOC(pwszRootUrl = PszToUnicode(CP_ACP, m_rRootUrl.pszVal));

    // Create a dummy moniker
    CHECKHR(hr = CreateURLMoniker(NULL, pwszRootUrl, ppMoniker));

exit:
    // Cleanup
    SafeMemFree(pwszRootUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::SetActiveUrl
// ---------------------------------------------------------------------------
HRESULT CMessageTree::SetActiveUrl(CActiveUrl *pActiveUrl)  
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // NULL ?
    if (NULL == pActiveUrl)
    {
        Assert(m_pActiveUrl);
        SafeRelease(m_pActiveUrl);
    }
    else
    {
        Assert(NULL == m_pActiveUrl);
        m_pActiveUrl = pActiveUrl;
        m_pActiveUrl->AddRef();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::CompareRootUrl
// --------------------------------------------------------------------------------
HRESULT CMessageTree::CompareRootUrl(LPCSTR pszUrl) 
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid ARg
    Assert(pszUrl);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Root Url
    if (NULL == m_rRootUrl.pszVal)
    {
        Assert(FALSE);
        hr = S_FALSE;
        goto exit;
    }

    // This url must start with mhtml:
    Assert(StrCmpNI(m_rRootUrl.pszVal, "mhtml:", 6) == 0);

    // Compare
    hr = MimeOleCompareUrl(m_rRootUrl.pszVal + 6, FALSE, pszUrl, FALSE);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Load
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pStream=NULL;
    ULONG           cb;
    LPOLESTR        pwszUrl=NULL;
    LPSTR           pszUrl=NULL;
    ULONG           cchUrl;
    BOOL            fReSynchronize;

    // Invalid Arg
    if (NULL == pMoniker)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Remember if TREESTATE_RESYNCHRONIZE is set...
    fReSynchronize = ISFLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE);

    // InitNew
    CHECKHR(hr = _HrLoadInitNew());

    // Reset pragma no cache
    if (fReSynchronize)
    {
        // Reset 
        FLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE);
    }

    // We better have a tree
    Assert(NULL == m_pMoniker);

    // Assume the Moniker
    m_pMoniker = pMoniker;
    m_pMoniker->AddRef();

    // No Bind Context was given ?
    if (NULL == pBindCtx)
    {
        // Create me a BindContext
        CHECKHR(hr = CreateBindCtx(0, &pBindCtx));
    }

    // Otherwise, assume the Bind Context Passed Into me
    else
        pBindCtx->AddRef();

    Assert (m_pBC==NULL);
    m_pBC = pBindCtx;   // released in OnStopBinding
    
    // Get the Url from this dude
    CHECKHR(hr = m_pMoniker->GetDisplayName(NULL, NULL, &pwszUrl));

    // Save as Root Url
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Raid-2508: Comment tag ( <! comment> ) doesn't work in mhtml
    ReplaceChars(pszUrl, '!', '_');

    // Better not have mhtml: on it
    Assert(StrCmpNI(pszUrl, "mhtml:", 6) != 0);

    // Get the length of pszUrl
    cchUrl = lstrlen(pszUrl);

    // Create "mhtml://" + pszUrl + '/' + '\0'
    CHECKALLOC(m_rRootUrl.pszVal = (LPSTR)g_pMalloc->Alloc(10 + cchUrl));

    // Format the string
    SideAssert(wsprintf(m_rRootUrl.pszVal, "%s%s", c_szMHTMLColon, pszUrl) <= (LONG)(10 + cchUrl));

    // Register my bind status callback in the bind context
    CHECKHR(hr = RegisterBindStatusCallback(pBindCtx, (IBindStatusCallback *)this, NULL, 0));

    // Assume the Bind has Finished
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // I only support share deny none
    FLAGSET(m_dwState, TREESTATE_BINDUSEFILE);

    // I was loaded by a moniker
    FLAGSET(m_dwState, TREESTATE_LOADEDBYMONIKER);

    // This better be synchronous
    hr = m_pMoniker->BindToStorage(pBindCtx, NULL, IID_IStream, (LPVOID *)&pStream);
    if (FAILED(hr) || MK_S_ASYNCHRONOUS == hr)
    {
        TrapError(hr);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pwszUrl);
    SafeMemFree(pszUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetCurMoniker
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCurMoniker(IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppMoniker)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pMoniker)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Return It
    *ppMoniker = m_pMoniker;
    (*ppMoniker)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetCurFile
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCurFile(LPOLESTR *ppszFileName)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Return File Name
    if (NULL == m_pwszFilePath)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Dup and return
    CHECKALLOC(*ppszFileName = PszDupW(m_pwszFilePath));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Load
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmFile=NULL;
    DWORD       dwAccess=GENERIC_READ;
    DWORD       dwShare=FILE_SHARE_READ|FILE_SHARE_WRITE;
    BOOL        fBindUseFile;

    // Invalid Arg
    if (NULL == pszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Determine Access
    if (ISFLAGSET(dwMode, STGM_WRITE))
        FLAGSET(dwAccess, GENERIC_WRITE);
    if (ISFLAGSET(dwMode, STGM_READWRITE))
        FLAGSET(dwAccess, GENERIC_READ | GENERIC_WRITE);

    // Determine Share Mode
    dwMode &= 0x00000070; //  the STGM_SHARE_* flags are not individual bits
    if (STGM_SHARE_DENY_NONE == dwMode)
        dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
    else if (STGM_SHARE_DENY_READ == dwMode)
        dwShare = FILE_SHARE_WRITE;
    else if (STGM_SHARE_DENY_WRITE == dwMode)
        dwShare = FILE_SHARE_READ;
    else if (STGM_SHARE_EXCLUSIVE == dwMode)
        dwShare = 0;

    // Save Option
    fBindUseFile = m_rOptions.fBindUseFile;

    // If the user wants file sharing on this file, then I need to put this into my own file
    if (ISFLAGSET(dwShare, FILE_SHARE_WRITE))
        m_rOptions.fBindUseFile = TRUE;

    // Open File Stream
    CHECKHR(hr = OpenFileStreamShareW((LPWSTR)pszFileName, OPEN_EXISTING, dwAccess, dwShare, &pstmFile));

    // Bind the message
    CHECKHR(hr = Load(pstmFile));

    // Reset Option
    m_rOptions.fBindUseFile = fBindUseFile;

    // Free Current File
    SafeMemFree(m_pwszFilePath);

    // Assume new file
    CHECKALLOC(m_pwszFilePath = PszDupW(pszFileName));

exit:
    // Cleanup
    SafeRelease(pstmFile);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::Save
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmFile=NULL,
               *pstmSource=NULL;

    // Invalid Arg
    if (NULL == pszFileName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Open File Stream
    CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFileName, CREATE_ALWAYS, GENERIC_READ | GENERIC_WRITE, &pstmFile));
   
    // If Remember
    if (fRemember)
    {
        // Bind the message
        CHECKHR(hr = Save(pstmFile, TRUE));
    }

    // Otherwise, get message source, and copy...
    else
    {
        // Get Message Source
        CHECKHR(hr = GetMessageSource(&pstmSource, COMMIT_ONLYIFDIRTY));

        // Copy...
        CHECKHR(hr = HrCopyStream(pstmSource, pstmFile, NULL));
    }

    // Commit
    CHECKHR(hr = pstmFile->Commit(STGC_DEFAULT));

    // If Remember
    if (fRemember)
    {
        // Free Current File
        SafeMemFree(m_pwszFilePath);

        // Assume new file
        CHECKALLOC(m_pwszFilePath = PszDupW(pszFileName));
    }

exit:
    // Cleanup
    SafeRelease(pstmFile);
    SafeRelease(pstmSource);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::SaveCompleted
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetClassID
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetClassID(CLSID *pClassID)
{
    // Invalid Arg
    if (NULL == pClassID)
        return TrapError(E_INVALIDARG);

    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimeMessageTree, sizeof(CLSID));

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetSizeMax
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cbSize;

    // Invalid Arg
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);

    // INit
    pcbSize->QuadPart = 0;

    // Get Message Size
    CHECKHR(hr = GetMessageSize(&cbSize, COMMIT_ONLYIFDIRTY));

    // Set Size
    pcbSize->QuadPart = cbSize;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageTree::_FIsValidHandle
// ----------------------------------------------------------------------------
BOOL CMessageTree::_FIsValidHandle(HBODY hBody)
{
    // Its Valid
    if ((WORD)HBODYTAG(hBody) == m_wTag && 
        HBODYINDEX(hBody) < m_rTree.cNodes && 
        m_rTree.prgpNode[HBODYINDEX(hBody)] && 
        m_rTree.prgpNode[HBODYINDEX(hBody)]->hBody == hBody)
        return TRUE;

    // Not Valid
    return FALSE;
}

// ----------------------------------------------------------------------------
// CMessageTree::_PNodeFromHBody
// ----------------------------------------------------------------------------
LPTREENODEINFO CMessageTree::_PNodeFromHBody(HBODY hBody)
{
    Assert(_FIsValidHandle(hBody));
    return m_rTree.prgpNode[HBODYINDEX(hBody)];
}

// --------------------------------------------------------------------------------
// CMessageTree::GetMessageSize
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetMessageSize(ULONG *pcbSize, DWORD dwFlags)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmSource=NULL;

    // Invalid Arg
    if (pcbSize == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *pcbSize = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the message source
    CHECKHR(hr = GetMessageSource(&pstmSource, dwFlags));

    // Get the stream Size
    CHECKHR(hr = HrGetStreamSize(pstmSource, pcbSize));

    // If you hit this assert, please let me know. t-erikne
    // I'm trying to see if we have to call HrGetStreamSize here.
    Assert(m_cbMessage == *pcbSize);

exit:
    // Cleanup
    SafeRelease(pstmSource);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::_ApplyOptionToAllBodies
// ---------------------------------------------------------------------------
void CMessageTree::_ApplyOptionToAllBodies(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // Loop through bodies and set on each body
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Check if deleted
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Dirty Header...
        m_rTree.prgpNode[i]->pBody->SetOption(oid, pValue);
    }
}

// ---------------------------------------------------------------------------
// CMessageTree::SetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetOption(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_HANDSOFF_ONSAVE:
        m_rOptions.fHandsOffOnSave = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_SUPPORT_EXTERNAL_BODY:
        _ApplyOptionToAllBodies(oid, pValue);
        break;

    case OID_SHOW_MACBINARY:
        if (m_rOptions.fShowMacBin != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fShowMacBin = pValue->boolVal ? TRUE : FALSE;
            _ApplyOptionToAllBodies(oid, pValue);
        }
        break;

    case OID_HEADER_RELOAD_TYPE:
        if (pValue->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pValue->ulVal;
        }
        break;

    case OID_LOAD_USE_BIND_FILE:
        m_rOptions.fBindUseFile = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_CLEANUP_TREE_ON_SAVE:
        m_rOptions.fCleanupTree = pValue->boolVal ? TRUE : FALSE;
        break;

    case OID_SAVEBODY_KEEPBOUNDARY:
        if (m_rOptions.fKeepBoundary != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fKeepBoundary = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CAN_INLINE_TEXT_BODIES:
        if (m_rOptions.fCanInlineText != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fCanInlineText = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        if (m_rOptions.fHideTnef != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fHideTnef = pValue->boolVal ? TRUE : FALSE;
            _ApplyOptionToAllBodies(oid, pValue);
        }
        break;

    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bitHeader != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fAllow8bitHeader = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CBMAX_HEADER_LINE:
        if (pValue->ulVal < MIN_CBMAX_HEADER_LINE || pValue->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cchMaxHeaderLine != pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.cchMaxHeaderLine = pValue->ulVal;
        }
        break;

    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pValue->ulVal && SAVE_RFC1521 != pValue->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pValue->ulVal;
        }
        break;

    case OID_TRANSMIT_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietTextXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietTextXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_XMIT_PLAIN_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietPlainXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietPlainXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_XMIT_HTML_TEXT_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietHtmlXmit != (ENCODINGTYPE)pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.ietHtmlXmit = (ENCODINGTYPE)pValue->ulVal;
        }
        break;

    case OID_WRAP_BODY_TEXT:
        if (m_rOptions.fWrapBodyText != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fWrapBodyText = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_CBMAX_BODY_LINE:
        if (pValue->ulVal < MIN_CBMAX_BODY_LINE || pValue->ulVal > MAX_CBMAX_BODY_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cchMaxBodyLine != pValue->ulVal)
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.cchMaxBodyLine = pValue->ulVal;
        }
        break;

    case OID_GENERATE_MESSAGE_ID:
        if (m_rOptions.fGenMessageId != (pValue->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, TREESTATE_DIRTY);
            m_rOptions.fGenMessageId = pValue->boolVal ? TRUE : FALSE;
        }
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        m_rOptions.ulSecIgnoreMask = pValue->ulVal;
        break;

    case OID_DECODE_RFC1154:
        m_rOptions.fDecodeRfc1154 = pValue->boolVal ? TRUE : FALSE;
        break;

    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageTree::GetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetOption(const TYPEDID oid, LPPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    pValue->vt = TYPEDID_TYPE(oid);

    // Handle Optid
    switch(oid)
    {
    case OID_HANDSOFF_ONSAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHandsOffOnSave;
        break;

    case OID_LOAD_USE_BIND_FILE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fBindUseFile;
        break;

    case OID_SHOW_MACBINARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fShowMacBin;
        break;

    case OID_HEADER_RELOAD_TYPE:
        pValue->ulVal = m_rOptions.ReloadType;
        break;

    case OID_CAN_INLINE_TEXT_BODIES:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCanInlineText;
        break;

    case OID_CLEANUP_TREE_ON_SAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCleanupTree;
        break;

    case OID_SAVEBODY_KEEPBOUNDARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fKeepBoundary;
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHideTnef;
        break;

    case OID_ALLOW_8BIT_HEADER:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fAllow8bitHeader;
        break;

    case OID_WRAP_BODY_TEXT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fWrapBodyText;
        break;

    case OID_CBMAX_HEADER_LINE:
        pValue->ulVal = m_rOptions.cchMaxHeaderLine;
        break;

    case OID_SAVE_FORMAT:
        pValue->ulVal = (ULONG)m_rOptions.savetype;
        break;    

    case OID_TRANSMIT_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietTextXmit;
        break;

    case OID_XMIT_PLAIN_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietPlainXmit;
        break;

    case OID_XMIT_HTML_TEXT_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietHtmlXmit;
        break;

    case OID_CBMAX_BODY_LINE:
        pValue->ulVal = m_rOptions.cchMaxBodyLine;
        break;

    case OID_GENERATE_MESSAGE_ID:
        pValue->boolVal = m_rOptions.fGenMessageId;
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        pValue->ulVal = m_rOptions.ulSecIgnoreMask;
        break;

    case OID_DECODE_RFC1154:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fDecodeRfc1154;
        break;

    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_ResetObject
// --------------------------------------------------------------------------------
void CMessageTree::_ResetObject(BOOKTREERESET ResetType)
{
    // Load InitNew
    if (BOOKTREE_RESET_LOADINITNEW == ResetType)
    {
        // There has to be a root (look at impl of ::_HrLoadInitNew)
        Assert(m_pRootNode);

        // Don't Crash
        if (m_pRootNode)
        {
            // Delete all bodies, except for the root, if there is one...
            if (m_pRootNode->pBody->IsType(IBT_EMPTY) == S_FALSE || m_pRootNode->pContainer->CountProps() > 0)
            {
                // Delete the root body, this simply removed properties and empties the body, but leave the root body
                DeleteBody(m_pRootNode->hBody, 0);
            }

            // Lighweight FreeTree Node Info
            _FreeTreeNodeInfo(m_pRootNode, FALSE);

            // Validate
            Assert(m_pRootNode->cChildren == 0);
            Assert(m_pRootNode->pParent == NULL);
            Assert(m_pRootNode->pNext == NULL);
            Assert(m_pRootNode->pPrev == NULL);
            Assert(m_pRootNode->pChildHead == NULL);
            Assert(m_pRootNode->pChildTail == NULL);
            Assert(m_pRootNode->pBody);
            Assert(m_pRootNode->pContainer);

            // Quick Reset
            TREENODEINFO rTemp;
            CopyMemory(&rTemp, m_pRootNode, sizeof(TREENODEINFO));
            ZeroMemory(m_pRootNode, sizeof(TREENODEINFO));
            m_pRootNode->pBody = rTemp.pBody;
            m_pRootNode->pContainer = rTemp.pContainer;
            m_pRootNode->hBody = rTemp.hBody;

            // Set OID_RELOAD_HEADER_TYPE
            PROPVARIANT rOption;
            rOption.vt = VT_UI4;
            rOption.ulVal = (ULONG)m_rOptions.ReloadType;
            m_pRootNode->pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption);
        }
    }

    // Free All Elements
    else
        _FreeNodeTableElements();

    // Free Bind Request Table
    _ReleaseUrlRequestList(&m_pPending);
    _ReleaseUrlRequestList(&m_pComplete);

    // Free and Release Objects
    SafeRelease(m_pCallback);
    SafeRelease(m_pWebPage);
    SafeMemFree(m_pwszFilePath);
    SafeRelease(m_pBinding);
    SafeRelease(m_pMoniker);
    SafeRelease(m_pBC);
    SafeRelease(m_pInternet);
    SafeRelease(m_pStmBind);
    SafeRelease(m_pRootStm);
    SafeMemFree(m_rRootUrl.pszVal);
    SafeMemFree(m_pBT1154);

    // Clear Current BindNode
    m_pBindNode = NULL;

    // Orphan CStreamLockBytes
    if (m_pStmLock)
    {
        m_pStmLock->HrHandsOffStorage();
        m_pStmLock->Release();
        m_pStmLock = NULL;
    }

    // If Deconstructing
    if (BOOKTREE_RESET_DECONSTRUCT == ResetType)
    {
        // Release the body table array
        SafeMemFree(m_rTree.prgpNode);

        // If I'm registered as a Url
        if (m_pActiveUrl)
            m_pActiveUrl->RevokeWebBook(this);

        // Better not have an active Url
        Assert(NULL == m_pActiveUrl);
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrLoadInitNew
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrLoadInitNew(void)
{
    // Locals
    HRESULT hr=S_OK;

    // If there is not root body, normal InitNew
    if (NULL == m_pRootNode || RELOAD_HEADER_RESET == m_rOptions.ReloadType)
    {
        // InitNew
        CHECKHR(hr = InitNew());
    }

    // Otherwise, smart init new, allowing root header merge
    else
    {
        // Reset the Object
        _ResetObject(BOOKTREE_RESET_LOADINITNEW);

        // Reset Vars
        m_cbMessage = 0;
        m_dwState = 0;

        // Assume the Bind has Finished
        FLAGSET(m_dwState, TREESTATE_BINDDONE);

        // Reset charset to system charset
        m_rOptions.pCharset = CIntlGlobals::GetDefBodyCset();
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_InitNewWithoutRoot
// --------------------------------------------------------------------------------
void CMessageTree::_InitNewWithoutRoot(void)
{
    // Reset the Object
    _ResetObject(BOOKTREE_RESET_INITNEW);

    // Reset Vars
    m_cbMessage = 0;
    m_dwState = 0;
    m_wTag++;

    // Invalid Tag Numbers
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // Assume the Bind has Finished
    FLAGSET(m_dwState, TREESTATE_BINDDONE);

    // Reset charset to system charset
    m_rOptions.pCharset = CIntlGlobals::GetDefBodyCset();
}

// --------------------------------------------------------------------------------
// CMessageTree::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::InitNew(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // _InitNewWithoutRoot
    _InitNewWithoutRoot();

    // Init the Root Body...
    CHECKHR(hr = InsertBody(IBL_ROOT, NULL, NULL));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::IsDirty(void)
{
    // Locals
    HRESULT     hr=S_FALSE;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty...
    if (ISFLAGSET(m_dwState, TREESTATE_DIRTY))
    {
        hr = S_OK;
        goto exit;
    }

    // Loop through bodies and ask IMimeHeader's and IMimeBody's
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Better have it
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Dirty Header...
        if (m_rTree.prgpNode[i]->pBody->IsDirty() == S_OK)
        {
            hr = S_OK;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_RecursiveGetFlags
// --------------------------------------------------------------------------------
void CMessageTree::_RecursiveGetFlags(LPTREENODEINFO pNode, LPDWORD pdwFlags, BOOL fInRelated)
{
    // Locals
    DWORD           dw;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode && pdwFlags);

    // $$WARNING$$ Don't use pNode->pContainer here, that will circumvent CMimeBody's chance to set some flags
    dw = pNode->pBody->DwGetFlags(m_rOptions.fHideTnef);

    // If in related, clear IMF_ATTACHMENTS
    if (fInRelated)
        FLAGCLEAR(dw, IMF_ATTACHMENTS);

    // Raid-44446: not getting paperclip icon in listview on pegasus messages w/ text attach
    // If dw has text and no attachments and pdwFlags has text and no attachments, add attachments
    //
    // Raid-11617: OE: GetAttachmentCount should not include vcards
    if (ISFLAGSET(dw, IMF_TEXT) && !ISFLAGSET(dw, IMF_HASVCARD) && ISFLAGSET(*pdwFlags, IMF_TEXT) && !ISFLAGSET(dw, IMF_ATTACHMENTS) && !ISFLAGSET(*pdwFlags, IMF_ATTACHMENTS))
    {
        // As long as pNode is not in an alternative section
        if (NULL == pNode->pParent || pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_FALSE)
        {
            // This message must have text attachments
            FLAGSET(*pdwFlags, IMF_ATTACHMENTS);
        }
    }

    // Add in Flags
    FLAGSET(*pdwFlags, dw);

    // Partial...
    if (ISFLAGSET(pNode->dwType, NODETYPE_INCOMPLETE))
        FLAGSET(*pdwFlags, IMF_PARTIAL);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Sub-multipart
        FLAGSET(*pdwFlags, IMF_SUBMULTIPART);

        // If fInRelated == FALSE...
        if (FALSE == fInRelated)
            fInRelated = (S_OK == pNode->pContainer->IsContentType(NULL, STR_SUB_RELATED) ? TRUE : FALSE);

        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Get the flags for this child node
            _RecursiveGetFlags(pChild, pdwFlags, fInRelated);
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::DwGetFlags
// --------------------------------------------------------------------------------
DWORD CMessageTree::DwGetFlags(void)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Recurse the tree
    if (m_pRootNode && m_pRootNode->pBody->IsType(IBT_EMPTY) == S_FALSE)
        _RecursiveGetFlags(m_pRootNode, &dwFlags, (S_OK == m_pRootNode->pContainer->IsContentType(NULL, STR_SUB_RELATED) ? TRUE : FALSE));

    if (m_pRootNode && ISFLAGSET(m_pRootNode->dwType, NODETYPE_RFC1154_ROOT))
        FLAGSET(dwFlags, IMF_RFC1154);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// ----------------------------------------------------------------------------
// CMessageTree::GetFlags
// ----------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetFlags(DWORD *pdwFlags)
{
    // Invalid Arg
    if (NULL == pdwFlags)
        return TrapError(E_INVALIDARG);

    // dwgetflags has a critsec
    *pdwFlags = DwGetFlags();

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMessageTree::_FreeTreeNodeInfo
// ----------------------------------------------------------------------------
void CMessageTree::_FreeTreeNodeInfo(LPTREENODEINFO pNode, BOOL fFull /* TRUE */)
{
    // Invalid
    Assert(pNode);

    // Free Boundary info
    if (!ISFLAGSET(pNode->dwState, NODESTATE_BOUNDNOFREE))
        SafeMemFree(pNode->rBoundary.pszVal);

    // Full Free
    if (TRUE == fFull)
    {
        // Release the Container
        SafeRelease(pNode->pContainer);

        // Revoke the TreeNode from the body
        if (pNode->pBody)
        {
            // Revoke pNode
            pNode->pBody->RevokeTreeNode();

            // Release the body object
            pNode->pBody->Release();

            // Null It
            pNode->pBody = NULL;
        }
    }

    // Orphan the lockbytes
    if (pNode->pLockBytes)
    {
        // Orhpan It
        pNode->pLockBytes->HrHandsOffStorage();

        // Release Body Lock Bytes
        pNode->pLockBytes->Release();
    }

    // Free Bind Request List
    if (pNode->pResolved)
        _ReleaseUrlRequestList(&pNode->pResolved);

    // Free the node
    if (fFull)
        g_pMalloc->Free(pNode);
}

// ----------------------------------------------------------------------------
// CMessageTree::_FreeNodeTableElements
// ----------------------------------------------------------------------------
void CMessageTree::_FreeNodeTableElements(void)
{
    // Release all of the headers
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Better have a bindinfo
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Free the node info
        _FreeTreeNodeInfo(m_rTree.prgpNode[i]);
    }

    // Zero
    m_rTree.cNodes = 0;
    m_rTree.cEmpty = 0;

    // No Root Body...
    m_pRootNode = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrAllocateTreeNode
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrAllocateTreeNode(ULONG ulIndex)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // Check Params
    Assert(ulIndex < m_rTree.cAlloc);

    // Allocate a TREENODEINFO Object
    CHECKALLOC(pNode = (LPTREENODEINFO)g_pMalloc->Alloc(sizeof(TREENODEINFO)));

    // ZeroInit
    ZeroMemory(pNode, sizeof(TREENODEINFO));

    // Allocate the body
    CHECKALLOC(pNode->pBody = new CMessageBody(pNode));

    // InitNew
    CHECKHR(hr = pNode->pBody->InitNew());

    // Pass Down Some Inherited Options
    if (m_rOptions.fExternalBody != DEF_SUPPORT_EXTERNAL_BODY)
    {
        // Locals
        PROPVARIANT Variant;

        // Initialize the Variant
        Variant.vt = VT_BOOL;
        Variant.boolVal = (VARIANT_BOOL) !!m_rOptions.fExternalBody;

        // Set the Option
        SideAssert(SUCCEEDED(pNode->pBody->SetOption(OID_SUPPORT_EXTERNAL_BODY, &Variant)));
    }

    // Get the Container
    SideAssert(SUCCEEDED(pNode->pBody->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pNode->pContainer)));

    // Create hBody
    pNode->hBody = HBODYMAKE(ulIndex);

    // Readability
    m_rTree.prgpNode[ulIndex] = pNode;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::LoadOffsetTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::LoadOffsetTable(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    CACHEINFOV2     rInfo;
    LPCACHENODEV2   prgNode=NULL;
    ULONG           cbNodes,
                    i;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init New
    _InitNewWithoutRoot();

    // Free the root
    Assert(NULL == m_pRootNode && 0 == m_rTree.cNodes);

    // Read Header...
    CHECKHR(hr = pStream->Read(&rInfo, sizeof(CACHEINFOV2), NULL));

    // Current Version...
    if (VER_BODYTREEV2 == rInfo.wVersion)
    {
        // Save Message Size
        m_cbMessage = rInfo.cbMessage;

        // Are there bodies...
        Assert(rInfo.cNodes >= 1);

        // Better have a root
        if (FVerifySignedNode(rInfo, rInfo.iRoot) == FALSE)
        {
            hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
            goto exit;
        }

        // Compute sizeof Nodes
        cbNodes = sizeof(CACHENODEV2) * rInfo.cNodes;
        Assert(cbNodes % 4 == 0);

        // Allocate prgNode array
        CHECKHR(hr = HrAlloc((LPVOID *)&prgNode, cbNodes));
    
        // Read Nodes...
        CHECKHR(hr = pStream->Read(prgNode, cbNodes, NULL));

        // Set body count
        m_rTree.cNodes = rInfo.cNodes;
        m_rTree.cAlloc = m_rTree.cNodes + 5;

        // Build Body Table
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTree.prgpNode, sizeof(LPTREENODEINFO) * m_rTree.cAlloc));

        // Zero Init
        ZeroMemory(m_rTree.prgpNode, sizeof(LPTREENODEINFO) * m_rTree.cAlloc);

        // Build bodies
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Allocate LPBINDINFO
            CHECKHR(hr = _HrAllocateTreeNode(i));
        }

        // Link Body Table
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability
            pNode = m_rTree.prgpNode[i];
            Assert(pNode);

            // Flags
            pNode->dwType = prgNode[i].dwType;

            // Number of Children
            pNode->cChildren = prgNode[i].cChildren;

            // Valid Boundary
            if (prgNode[i].dwBoundary >= BOUNDARY_LAST || 2 == prgNode[i].dwBoundary)
                pNode->boundary = BOUNDARY_NONE;
            else
                pNode->boundary = (BOUNDARYTYPE)prgNode[i].dwBoundary;

            // Offset
            pNode->cbBoundaryStart = prgNode[i].cbBoundaryStart;
            pNode->cbHeaderStart = prgNode[i].cbHeaderStart;
            pNode->cbBodyStart = prgNode[i].cbBodyStart;
            pNode->cbBodyEnd = prgNode[i].cbBodyEnd;

            // Parent
            if (prgNode[i].iParent)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iParent) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the parent
                pNode->pParent = PNodeFromSignedNode(prgNode[i].iParent);
            }

            // Next
            if (prgNode[i].iNext)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iNext) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the Next
                pNode->pNext = PNodeFromSignedNode(prgNode[i].iNext);
            }

            // Prev
            if (prgNode[i].iPrev)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iPrev) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the Prev
                pNode->pPrev = PNodeFromSignedNode(prgNode[i].iPrev);
            }

            // First Child
            if (prgNode[i].iChildHead)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iChildHead) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the first child
                pNode->pChildHead = PNodeFromSignedNode(prgNode[i].iChildHead);
            }

            // Tail
            if (prgNode[i].iChildTail)
            {
                // Validate the handle with the signature
                if (FVerifySignedNode(rInfo, prgNode[i].iChildTail) == FALSE)
                {
                    AssertSz(FALSE, "MIME_E_CORRUPT_CACHE_TREE");
                    hr = TrapError(MIME_E_CORRUPT_CACHE_TREE);
                    goto exit;
                }

                // Get the last child
                pNode->pChildTail = PNodeFromSignedNode(prgNode[i].iChildTail);
            }
        }

        // Save Root Handle
        Assert(NULL == m_pRootNode);
        m_pRootNode = PNodeFromSignedNode(rInfo.iRoot);
    }

    // Otherwise, bad version...
    else
    {
        hr = TrapError(MIME_E_UNKNOWN_BODYTREE_VERSION);
        goto exit;
    }

    // Tree Loaded
    FLAGSET(m_dwState, TREESTATE_LOADED);

exit:
    // Cleanup
    SafeMemFree(prgNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SaveOffsetTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveOffsetTable(LPSTREAM pStream, DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i,
                    cbNodes=0,
                    iNode;
    LPTREENODEINFO  pNode;
    CACHEINFOV2     rInfo;
    LPCACHENODEV2   prgNode=NULL;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We better have some bodies (we always have a root)
    Assert(m_rTree.cNodes >= 1);

    // If Dirty, SaveMessage needs to be called first...
    if (ISFLAGSET(dwFlags, COMMIT_ONLYIFDIRTY) && IsDirty() == S_OK)
    {
        // Commit it
        CHECKHR(hr = Commit(dwFlags));
    }

    // I removed this check because of the addition of OID_HANDSOFF_ONSAVE option
    // I need to be able to save the offsettable even if i don't have m_pStmLock
    Assert(NULL == m_pStmLock ? S_FALSE == IsDirty() : TRUE);
#if 0 
    if (NULL == m_pStmLock)
    {
        hr = TrapError(MIME_E_NOTHING_TO_SAVE);
        goto exit;
    }
#endif

    // Init rHeader
    ZeroMemory(&rInfo, sizeof(CACHEINFOV2));

    // Loop bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        if (m_rTree.prgpNode[i])
            m_rTree.prgpNode[i]->iCacheNode = rInfo.cNodes++;
    }

    // Version
    rInfo.wVersion = VER_BODYTREEV2;
    rInfo.wSignature = m_wTag;
    rInfo.cbMessage = m_cbMessage;

    // Better have a root
    Assert(m_pRootNode);

    // Compute sizeof Nodes
    cbNodes = sizeof(CACHENODEV2) * rInfo.cNodes;
    Assert(cbNodes % 4 == 0);

    // Allocate prgNode array
    CHECKHR(hr = HrAlloc((LPVOID *)&prgNode, cbNodes));

    // Zero the array
    ZeroMemory(prgNode, cbNodes);

    // Loop bodies
    for (i=0, iNode=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];
        if (NULL == pNode)
            continue;

        // Validate this node
        Assert(pNode->hBody == HBODYMAKE(i));
        Assert(pNode->iCacheNode == iNode);

        // Is this the root
        if (pNode == m_pRootNode)
        {
            Assert(0 == rInfo.iRoot);
            rInfo.iRoot = DwSignNode(rInfo, pNode->iCacheNode);
            Assert(FVerifySignedNode(rInfo, rInfo.iRoot));
        }

        // Copy Offset Information
        prgNode[iNode].dwBoundary = pNode->boundary;
        prgNode[iNode].cbBoundaryStart = pNode->cbBoundaryStart;
        prgNode[iNode].cbHeaderStart = pNode->cbHeaderStart;
        prgNode[iNode].cbBodyStart = pNode->cbBodyStart;
        prgNode[iNode].cbBodyEnd = pNode->cbBodyEnd;

        // Bitmask of NODETYPE_xxx describing this body
        prgNode[iNode].dwType = pNode->dwType;

        // Number of children
        prgNode[iNode].cChildren = pNode->cChildren;

        // Parent
        if (pNode->pParent)
        {
            prgNode[iNode].iParent = DwSignNode(rInfo, pNode->pParent->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iParent));
        }

        // ChildHead
        if (pNode->pChildHead)
        {
            prgNode[iNode].iChildHead = DwSignNode(rInfo, pNode->pChildHead->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iChildHead));
        }

        // ChildTail
        if (pNode->pChildTail)
        {
            prgNode[iNode].iChildTail = DwSignNode(rInfo, pNode->pChildTail->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iChildTail));
        }

        // Next
        if (pNode->pNext)
        {
            prgNode[iNode].iNext = DwSignNode(rInfo, pNode->pNext->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iNext));
        }

        // Prev
        if (pNode->pPrev)
        {
            prgNode[iNode].iPrev = DwSignNode(rInfo, pNode->pPrev->iCacheNode);
            Assert(FVerifySignedNode(rInfo, prgNode[iNode].iPrev));
        }

        // Increment iNode
        iNode++;
    }

    // Write the header...
    Assert(sizeof(CACHEINFOV2) % 4 == 0 && rInfo.iRoot);
    CHECKHR(hr = pStream->Write(&rInfo, sizeof(CACHEINFOV2), NULL));

    // Write the nodes
    CHECKHR(hr = pStream->Write(prgNode, cbNodes, NULL));

exit:
    // Cleanup
    SafeMemFree(prgNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Commit
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Commit(DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pStream=NULL;
    ULARGE_INTEGER  uli;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not Dirty and it has been saved into m_pStmLock
    if (IsDirty() == S_FALSE && m_pStmLock)
        goto exit;

    // Reuse Storage
    if (ISFLAGSET(dwFlags, COMMIT_REUSESTORAGE) && ISFLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE) && m_pStmLock)
    {
        // Get the current stream from m_pStmLock
        m_pStmLock->GetCurrentStream(&pStream);

        // Hands off of current storage
        CHECKHR(hr = HandsOffStorage());

        // Rewind the stream
        CHECKHR(hr = HrRewindStream(pStream));

        // SetSize to Zero
        INT64SET(&uli, 0);
        pStream->SetSize(uli);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, TRUE, FALSE, FALSE));
    }

    // Otherwise, I'll create my own storage
    else
    {
        // Create a new stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, TRUE, FALSE,
                                     !!(dwFlags & COMMIT_SMIMETRANSFERENCODE)));

        // Hands are off..
        FLAGCLEAR(m_dwState, TREESTATE_HANDSONSTORAGE);
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Save(IStream *pStream, BOOL fClearDirty)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;

    // check params
    if (pStream == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not dirty, and we have a stream $$$INFO$$ should be using m_pLockBytes here if we have one
    if (IsDirty() == S_FALSE && m_pStmLock)
    {
        // Copy Lock Bytes to Stream
        CHECKHR(hr = HrCopyLockBytesToStream(m_pStmLock, pStream, NULL));

        // Commit
        CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

        // Raid-33985: MIMEOLE: CMessageTree:Save does not respect fHandsOffOnSave == FALSE if the message is not dirty
        if (FALSE == m_rOptions.fHandsOffOnSave)
        {
            // Replace internal stream
            m_pStmLock->ReplaceInternalStream(pStream);

            // Hands are on..
            FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);
        }

        // Were Done
        goto exit;
    }

    // Write the message
    CHECKHR(hr = _HrWriteMessage(pStream, fClearDirty, m_rOptions.fHandsOffOnSave, FALSE));

    // Return Warnings
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteMessage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteMessage(IStream *pStream, BOOL fClearDirty, BOOL fHandsOffOnSave, BOOL fSMimeCTE)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    MIMEPROPINFO    rPropInfo;
    DWORD           dwSaveFlags;
    INETCSETINFO    rCharset;
    LPINETCSETINFO  pOriginal=NULL;

    // This Function is re-entrant when saving a message that is signed and/or encrypted
    if (FALSE == m_fApplySaveSecurity)
    {
        // Character Set Fixup
        if (m_rOptions.pCharset)
        {
            // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect Internet Encoded and Windows Encoding are CPI_AUTODETECT 
            if (CP_JAUTODETECT == m_rOptions.pCharset->cpiInternet)
            {
                // Save Current Charset
                pOriginal = m_rOptions.pCharset;

                // Find ISO-2022-JP
                SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(c_szISO2022JP, &m_rOptions.pCharset)));
            }

            // Raid-8436: OE: non standard MIME header is composed when send from Send as Unicode dialog, if UTF-7 or UTF-8, and not saving as mime...
            else if (SAVE_RFC822 == m_rOptions.savetype && (CP_UTF7 == m_rOptions.pCharset->cpiInternet || CP_UTF8 == m_rOptions.pCharset->cpiInternet))
            {
                // Save Current Charset
                pOriginal = m_rOptions.pCharset;

                // Get the default body charset
                if (FAILED(g_pInternat->HrOpenCharset(GetACP(), CHARSET_BODY, &m_rOptions.pCharset)))
                    m_rOptions.pCharset = NULL;
            }
        }

        // State
        m_fApplySaveSecurity = TRUE;

        // Do Message Save Security
        hr = _HrApplySaveSecurity();

        // Not in Apply Save security
        m_fApplySaveSecurity = FALSE;

        // Failure
        if (FAILED(hr))
            goto exit;
    }

    // Cleanup the message (i.e. remove empty multiparts, multiparts that have a single child that is a multipart, TNEF)
    if (TRUE == m_rOptions.fCleanupTree)
    {
        // Call Espiranza and have her do the cleaning
        CHECKHR(hr = _HrCleanupMessageTree(m_pRootNode));
    }

    // Generate Message Id...
    if (m_rOptions.fGenMessageId)
    {
        // Set the message Id
        _HrSetMessageId(m_pRootNode);
    }

    // Determine if we are saving a News Message
    rPropInfo.dwMask = 0;
    if (SUCCEEDED(m_pRootNode->pContainer->GetPropInfo(PIDTOSTR(PID_HDR_XNEWSRDR), &rPropInfo)) ||
        SUCCEEDED(m_pRootNode->pContainer->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &rPropInfo)))
        FLAGSET(m_dwState, TREESTATE_SAVENEWS);

    // Set MIME Version
    CHECKHR(hr = m_pRootNode->pContainer->SetProp(PIDTOSTR(PID_HDR_MIMEVER), c_szMimeVersion));

    // X-MimeOLE Version
    CHECKHR(hr = m_pRootNode->pContainer->SetProp(STR_HDR_XMIMEOLE, STR_MIMEOLE_VERSION));

    // Remove Types...
    m_pRootNode->pContainer->DeleteProp(STR_HDR_ENCODING);

    // Root
    m_pRootNode->boundary = BOUNDARY_ROOT;
    m_pRootNode->cbBoundaryStart = 0;

    // Set SaveBody Flags
    dwSaveFlags = SAVEBODY_UPDATENODES;
    if (m_rOptions.fKeepBoundary)
        FLAGSET(dwSaveFlags, SAVEBODY_KEEPBOUNDARY);

    if (fSMimeCTE)
        FLAGSET(dwSaveFlags, SAVEBODY_SMIMECTE);

    // Save Root body
    CHECKHR(hr = _HrSaveBody(fClearDirty, dwSaveFlags, pStream, m_pRootNode, 0));
    if ( S_OK != hr )
        hrWarnings = TrapError(hr);

    // Commit
    CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

    // Hands Off On Save ?
    if (FALSE == fHandsOffOnSave)
    {
        // Reset message size
        CHECKHR(hr = HrSafeGetStreamSize(pStream, &m_cbMessage));

        // Save this new stream
        SafeRelease(m_pStmLock);

        // Create a new Stream Lock Bytes Wrapper
        CHECKALLOC(m_pStmLock = new CStreamLockBytes(pStream));

        // Hands are on the storage
        FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);
    }

    // Debug to temp file...
    DebugWriteMsg(pStream);

    // Clear Dirty
    if (fClearDirty)
        ClearDirty();

exit:
    // Reset Original Charset
    if (pOriginal)
        m_rOptions.pCharset = pOriginal;

    // Remove state flag the tells us to reuse multipart/signed boundaries
    FLAGCLEAR(m_dwState, TREESTATE_REUSESIGNBOUND);

    // Reset
    FLAGCLEAR(m_dwState, TREESTATE_SAVENEWS);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrApplySaveSecurity
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrApplySaveSecurity(void)
{
    // Locals
    HRESULT            hr=S_OK;
    PROPVARIANT        var;
    CSMime            *pSMime=NULL;

    // Invalid Arg
    Assert(m_pRootNode);

    m_pRootNode->pBody->GetOption(OID_NOSECURITY_ONSAVE, &var);
    if (var.boolVal) goto exit;

    // Query the root body for secure status
    m_pRootNode->pBody->GetOption(OID_SECURITY_TYPE, &var);
    if (MST_NONE != var.ulVal)
    {
        // Create the object
        CHECKALLOC(pSMime = new CSMime);

        // Initialize the object
        CHECKHR(hr = pSMime->InitNew());

        // Set state flag the tells us to reuse multipart/signed boundaries
        FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);

        // Encode the message
        CHECKHR(hr = pSMime->EncodeMessage(this, m_rOptions.ulSecIgnoreMask));
    }

exit:
    ReleaseObj(pSMime);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrCleanupMessageTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrCleanupMessageTree(LPTREENODEINFO pParent)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;
    ULONG           i;
    BOOL            fKeepOnTruckin=TRUE;

    // check params
    Assert(pParent);

    // This could require multiple passes
    while(fKeepOnTruckin)
    {
        // Assume we will not have to do another pass
        fKeepOnTruckin = FALSE;

        // Loop through bodies
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability
            pNode = m_rTree.prgpNode[i];
            if (NULL == pNode)
                continue;

            // Hiding TNEF Attachments ?
            if (TRUE == m_rOptions.fHideTnef && pNode->pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_MSTNEF) == S_OK)
            {
                // Remove this TNEF attachment
                CHECKHR(hr = DeleteBody(pNode->hBody, 0));

                // Lets Stop right here, and start another pass
                fKeepOnTruckin = TRUE;

                // Done
                break;
            }

            // Empty multipart... and not the root... ?
            else if (_IsMultiPart(pNode))
            {
                // No Children ?
                if (0 == pNode->cChildren)
                {
                    // If this is the root...simply change the content type
                    if (m_pRootNode == pNode)
                    {
                        // Make the body empty
                        pNode->pBody->EmptyData();

                        // text/plain
                        pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);
                    }

                    // Otherwise, delete the body
                    else
                    {
                        // Delete delete the body
                        CHECKHR(hr = DeleteBody(pNode->hBody, 0));

                        // Lets Stop right here, and start another pass
                        fKeepOnTruckin = TRUE;

                        // Done
                        break;
                    }
                }

                // Otherwise, Multipart with a single child...
                else if (pNode->cChildren == 1)
                {
                    // Do a ReplaceBody
                    CHECKHR(hr = DeleteBody(pNode->hBody, DELETE_PROMOTE_CHILDREN));

                    // Lets Stop right here, and start another pass
                    fKeepOnTruckin = TRUE;

                    // Done
                    break;
                }
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SaveBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SaveBody(HBODY hBody, DWORD dwFlags, IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pNode;

    // Invalid ARg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Save From This Body On Down
    CHECKHR(hr = _HrSaveBody(TRUE, dwFlags, pStream, pNode, 0));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveBody(BOOL fClearDirty, DWORD dwFlags, IStream *pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    TREENODEINFO    rOriginal;
    BOOL            fWeSetSaveBoundary=FALSE;

    // Parameters
    Assert(pStream && pNode);

    if (ISFLAGSET(dwFlags, SAVEBODY_KEEPBOUNDARY))
        {
        if (!ISFLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND))
            {
            fWeSetSaveBoundary = TRUE;
            FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);
            }
        }

    // Save the Current Node
    if (!ISFLAGSET(dwFlags, SAVEBODY_UPDATENODES))
        CopyMemory(&rOriginal, pNode, sizeof(TREENODEINFO));

    // Override Options
    _HrBodyInheritOptions(pNode);

    // Starting Boundary pNode->boundary and pNode->cbBoundaryStart are expected to be set on entry
    pNode->cbHeaderStart = 0;
    pNode->cbBodyStart = 0;
    pNode->cbBodyEnd = 0;

    // If this is a multipart content item, lets read its child
    if (_IsMultiPart(pNode))
    {
        // Save Multipart Children
        CHECKHR(hr = _HrSaveMultiPart(fClearDirty, dwFlags, pStream, pNode, ulLevel));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);
    }

#ifdef SMIME_V3
    //  OID content types are saved by just copying the body into the save
    //  location.
    else if (pNode->pContainer->IsContentType("OID", NULL) == S_OK) 
    {
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_BINARY, pStream));
        if (hr != S_OK) 
        {
            hrWarnings = TrapError(hr);
        }
    }
#endif // SMIME_V3

    // Otherwise, parse single part
    else
    {
        // Save SinglePart Children
        CHECKHR(hr = _HrSaveSinglePart(fClearDirty, dwFlags, pStream, pNode, ulLevel));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);
    }

    // Reset the Node
    if (!ISFLAGSET(dwFlags, SAVEBODY_UPDATENODES))
        CopyMemory(pNode, &rOriginal, sizeof(TREENODEINFO));

exit:
    if (fWeSetSaveBoundary)
        FLAGCLEAR(m_dwState, TREESTATE_REUSESIGNBOUND);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSetMessageId
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSetMessageId(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT     hr= S_OK;
    CHAR        szMessageId[CCHMAX_MID];
    FILETIME    ft;
    SYSTEMTIME  st;

    // Invalid Arg
    Assert(pNode);

    // Get Current Time
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    CHECKHR(hr = MimeOleGenerateMID(szMessageId, sizeof(szMessageId), FALSE));

    // Write the message Id
    CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_MESSAGEID, szMessageId));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GenerateBoundary
// --------------------------------------------------------------------------------
void CMessageTree::_GenerateBoundary(LPSTR pszBoundary, ULONG ulLevel)
{
    // Locals
    SYSTEMTIME  stNow;
    FILETIME    ftNow;
    WORD        wCounter;

    // Get Local Time
    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    // Format the string
    wsprintf(pszBoundary, "----=_NextPart_%03d_%04X_%08.8lX.%08.8lX", ulLevel, DwCounterNext(), ftNow.dwHighDateTime, ftNow.dwLowDateTime);
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteBoundary(LPSTREAM pStream, LPSTR pszBoundary, BOUNDARYTYPE boundary, 
    LPDWORD pcboffStart, LPDWORD pcboffEnd)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;

    // Invalid Arg
    Assert(pStream && pszBoundary);

    // Header body CRLF
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // Starting Boundary Start
    if (pcboffStart)
        CHECKHR(hr = HrGetStreamPos(pStream, pcboffStart));

    // --
    CHECKHR(hr = pStream->Write(c_szDoubleDash, lstrlen(c_szDoubleDash), NULL));

    // Write the boundary
    CHECKHR(hr = pStream->Write(pszBoundary, lstrlen(pszBoundary), NULL));

    // If end
    if (BOUNDARY_MIMEEND == boundary)
    {
        // Write ending double dash
        CHECKHR(hr = pStream->Write(c_szDoubleDash, lstrlen(c_szDoubleDash), NULL));
    }

    // Otherwise, set pNode->cbBoundaryStart
    else
        Assert(BOUNDARY_MIMENEXT == boundary);

    // Emit Line Break;
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // BUG 38411: to be complient with RFC 1847 we have to include
    // the last CRLF in the hash of a signed message.  The S/MIME
    // code relies on cbBodyEnd, so place this after the CRLF emit.

    // Ending offset
    if (pcboffEnd)
        CHECKHR(hr = HrGetStreamPos(pStream, pcboffEnd));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrComputeBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrComputeBoundary(LPTREENODEINFO pNode, ULONG ulLevel, LPSTR pszBoundary, LONG cchMax)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fGenerate=TRUE;
    LPSTR           pszCurrent=NULL;

    // If reusing tree boundaries...
    if (ISFLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND))
    {
        // (this is required for multipart/signed -- t-erikne)
        if (SUCCEEDED(pNode->pContainer->GetProp(SYM_PAR_BOUNDARY, &pszCurrent)))
        {
            // Better fit into cchMax
            if (lstrlen(pszCurrent) <= cchMax - 1)
            {
                // Copy it to the out param
                lstrcpy(pszBoundary, pszCurrent);

                // Don't generate
                fGenerate = FALSE;
            }
        }
    }

    // Generate a boundary ?
    if (TRUE == fGenerate)
    {
        // Generate boundary
        _GenerateBoundary(pszBoundary, ulLevel);

        // Set the boundary property...
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_PAR_BOUNDARY, pszBoundary));
    }


exit:
    // Cleanup
    SafeMemFree(pszCurrent);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveMultiPart
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveMultiPart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    CHAR            szRes[100];
    CHAR            szBoundary[CCHMAX_BOUNDARY];
    LPTREENODEINFO  pChild;
    LPSTR           pszBoundary=NULL;

    // Invalid Arg
    Assert(pStream && pNode);

    // MIME
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Remove Fake Multipart flag, its a real multipart now...
        FLAGCLEAR(pNode->dwType, NODETYPE_FAKEMULTIPART);
        FLAGCLEAR(pNode->dwType, NODETYPE_RFC1154_ROOT);
        FLAGCLEAR(pNode->dwType, NODETYPE_RFC1154_BINHEX);

        // HrComputeBoundary
        CHECKHR(hr = _HrComputeBoundary(pNode, ulLevel, szBoundary, ARRAYSIZE(szBoundary)));

        // Delete any charset information (doesn't make sense on a multipart)
        pNode->pContainer->DeleteProp(SYM_PAR_CHARSET);

        // Write the header
        CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));

        // Remove SMIME_CTE for Multipart/signed 
        if ((pNode->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) == S_OK) &&
            (pNode->cChildren == 2))
        {
            FLAGCLEAR(dwFlags, SAVEBODY_SMIMECTE);
            FLAGSET(dwFlags, SAVEBODY_REUSECTE);
        }

        // Multipart-Preamble
        if (0 == ulLevel)
        {
            LoadString(g_hLocRes, IDS_MULTIPARTPROLOG, szRes, ARRAYSIZE(szRes));
            CHECKHR(hr = pStream->Write(szRes, lstrlen(szRes), NULL));
        }

        // Increment Level
        ulLevel++;

        // Loop Chilren
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Set Boundary
            pChild->boundary = BOUNDARY_MIMENEXT;

            // Write Boundary
            CHECKHR(hr = _HrWriteBoundary(pStream, szBoundary, BOUNDARY_MIMENEXT, &pChild->cbBoundaryStart, NULL));

            // Bind the body table for this dude
            CHECKHR(hr = _HrSaveBody(fClearDirty, dwFlags, pStream, pChild, ulLevel));
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Write Ending Boundary
        CHECKHR(hr = _HrWriteBoundary(pStream, szBoundary, BOUNDARY_MIMEEND, NULL, &pNode->cbBodyEnd));
    }

    // Otherwise, SAVE_RFC822
    else
    {
        // Only write UUENCODED root header...
        if (0 == ulLevel)
        {
            // Write the header
            CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));
        }

        // Increment Level
        ulLevel++;

        // Now its a fakemultipart...
        FLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART);
        
        // Loop Chilren
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrSaveBody(fClearDirty, dwFlags, pStream, pChild, ulLevel));
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Body Start...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteHeader
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteHeader(BOOL fClearDirty, IStream *pStream, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pStream && pNode);

    // Better be the root
    Assert(pNode->boundary == BOUNDARY_ROOT || pNode->boundary == BOUNDARY_MIMENEXT ||
           pNode->boundary == BOUNDARY_NONE);

    // Get current stream position
    CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbHeaderStart));

    // Write the header...
    CHECKHR(hr = pNode->pContainer->Save(pStream, fClearDirty));

    // Header body CRLF
    CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

    // Get Header End
    CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GetContentTransferEncoding
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_GetContentTransferEncoding(LPTREENODEINFO pNode, BOOL fText, 
    BOOL fPlain, BOOL fMessage, BOOL fAttachment, DWORD dwFlags,
    ENCODINGTYPE *pietEncoding)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    TRANSMITINFO    rXmitInfo;
    PROPVARIANT     rOption;

    *pietEncoding=IET_UNKNOWN;

    if (ISFLAGSET(dwFlags, SAVEBODY_REUSECTE))
    {
        pNode->pBody->GetPreviousEncoding(pietEncoding);
        if (*pietEncoding != IET_UNKNOWN)
            goto exit;
    }


    // If mesage/*, always use 7bit
    if (fMessage)
    {
        // Don't Wrap It
        rOption.vt = VT_BOOL;
        rOption.boolVal = FALSE;
        pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rOption);

        // Set Encoding
        *pietEncoding = (SAVE_RFC1521 == m_rOptions.savetype) ? IET_7BIT : IET_UUENCODE;

        // Done
        goto smimeExit;
    }

    // Use Option for text transmit format
    if (fText && !fAttachment)
    {
        // Default to plain text encoding first
        if (IET_UNKNOWN != m_rOptions.ietTextXmit)
            *pietEncoding = m_rOptions.ietTextXmit;

        // Plain
        if (IET_UNKNOWN != m_rOptions.ietPlainXmit && pNode->pContainer->IsContentType(NULL, STR_SUB_PLAIN) == S_OK)
            *pietEncoding = m_rOptions.ietPlainXmit;

        // Html
        else if (IET_UNKNOWN != m_rOptions.ietHtmlXmit && pNode->pContainer->IsContentType(NULL, STR_SUB_HTML) == S_OK)
            *pietEncoding = m_rOptions.ietHtmlXmit;
    }

    // Not known yet, using body option...
    if (IET_UNKNOWN == *pietEncoding)
    {
        // Try to get the body option
        if (SUCCEEDED(pNode->pBody->GetOption(OID_TRANSMIT_BODY_ENCODING, &rOption)) && IET_UNKNOWN != rOption.ulVal)
            *pietEncoding = (ENCODINGTYPE)rOption.ulVal;
    }

    // Save as MIME
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Get the current encoding of the body..
        if (IET_UNKNOWN == *pietEncoding)
            pNode->pBody->GetCurrentEncoding(pietEncoding);

        // If CTE is IET_QP or IET_BASE64 or IET_UUENCODE, were done
        if (IET_QP == *pietEncoding || IET_BASE64 == *pietEncoding || IET_UUENCODE == *pietEncoding)
            goto exit;

        // Ask the pody to suggest an ietEncoding
        hr = pNode->pBody->GetTransmitInfo(&rXmitInfo);
        if (SUCCEEDED(hr) )
        {
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);

            // Must not need wrapping
            if (IET_7BIT == rXmitInfo.ietXmitMime)
            {
                rOption.vt = VT_BOOL;
                rOption.boolVal = FALSE;
                pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rOption);
            }

            // If IET_7BIT and there are 8bit chars, bump upto 8bit
            if (IET_7BIT == *pietEncoding || IET_8BIT == *pietEncoding)
            {
                // 8bit
                *pietEncoding = (rXmitInfo.cExtended > 0) ? IET_8BIT : IET_7BIT;
            }

            // Just use the suggested mime cte from GetTransmitInfo
            else
                *pietEncoding = rXmitInfo.ietXmitMime;
        }

        // Transmit ietEncoding still unknown
        else
            *pietEncoding = (IET_UNKNOWN == *pietEncoding) ? (fText ? IET_QP : IET_BASE64) : *pietEncoding;
    }

    // Save a non-MIME
    else
    {
        // If I already know this body is TREENODE_INCOMPLETE, it will be 7bit...
        if (ISFLAGSET(pNode->dwType, NODETYPE_INCOMPLETE))
        {
            // No Encoding
            *pietEncoding = IET_7BIT;

            // Tell the body that its 7bit
            pNode->pBody->SetCurrentEncoding(IET_7BIT);
        }

        // Raid 41599 - lost/munged attachments on forward/uuencode - Text attachments were not 
        // getting encoded when: *pietEncoding = (fText && fPlain) ? IET_7BIT : IET_UUENCODE;
        else
            *pietEncoding = (fText && fPlain && !fAttachment) ? IET_7BIT : IET_UUENCODE;
    }

    //  If we are doing S/MIME at this point, we need to make sure that the
    //  content encoding rules for S/MIME are followed.  Specifically we
    //  want to make sure that binary and 8bit are not allowed.
smimeExit:
    if (ISFLAGSET(dwFlags, SAVEBODY_SMIMECTE))
    {
        if (*pietEncoding == IET_8BIT)
            *pietEncoding = IET_QP;
        if (*pietEncoding == IET_BINARY)
            *pietEncoding = IET_BASE64;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrWriteUUFileName
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrWriteUUFileName(IStream *pStream, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rFileName;

    // Init rFileName
    ZeroMemory(&rFileName, sizeof(PROPVARIANT));
    rFileName.vt = VT_LPSTR;

    // RAID-22479: FE-J:Athena:SJIS is used on file name on the message source with Uuencode/JIS.
    if (FAILED(pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_GENFNAME), PDF_ENCODED, &rFileName)))
    {
        // Write the filename
        CHECKHR(hr = pStream->Write(c_szUUENCODE_DAT, lstrlen(c_szUUENCODE_DAT), NULL));

        // Done
        goto exit;
    }

    // Write the filename
    CHECKHR(hr = pStream->Write(rFileName.pszVal, lstrlen(rFileName.pszVal), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSaveSinglePart
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSaveSinglePart(BOOL fClearDirty, DWORD dwFlags, LPSTREAM pStream, 
    LPTREENODEINFO pNode, ULONG ulLevel)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    LPSTR           pszFileName=NULL;
    BOOL            fText=FALSE;
    BOOL            fMessage=FALSE;
    BOOL            fAttachment=FALSE;
    ENCODINGTYPE    ietEncoding;
    BOOL            fPlain=FALSE;
    PROPVARIANT     val;
    LPINETCSETINFO  pTaggedCset=NULL;

    // Invalid Arg
    Assert(pStream && pNode);

    // Text/Plain
    if (pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) == S_OK)
        fText = fPlain = TRUE;

    // Text Body
    else if (pNode->pContainer->IsContentType(STR_CNT_TEXT, NULL) == S_OK)
        fText = TRUE;

    // Message/*
    else if (pNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
    {
        // We have a message
        fMessage = TRUE;
        fAttachment = TRUE;
    }

    // fAttachment has not been set yet
    if (!fAttachment)
    {
        fAttachment = (pNode->pContainer->QueryProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT, FALSE, FALSE) == S_OK ||
                       pNode->pContainer->IsPropSet(PIDTOSTR(PID_PAR_FILENAME)) == S_OK ||
                       pNode->pContainer->IsPropSet(PIDTOSTR(PID_PAR_NAME)) == S_OK);
    }

    // Get Content Transfer Encoding
    hr = _GetContentTransferEncoding(pNode, fText, fPlain, fMessage, fAttachment,
                                     dwFlags, &ietEncoding);
    if ( S_OK != hr )
        hrWarnings = TrapError(hr);

    // Sanity Check
    Assert(ietEncoding != IET_UNKNOWN && (SAVE_RFC1521 == m_rOptions.savetype || SAVE_RFC822 == m_rOptions.savetype));

    // Set Content-Transfer-Encoding...
    CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, g_rgEncodingMap[ietEncoding].pszName));
    pNode->pBody->SetPreviousEncoding(ietEncoding);

    // Compute Character Set for the message...
    if (m_rOptions.pCharset && TRUE == fText && (FALSE == fAttachment || S_OK == pNode->pBody->IsType(IBT_CSETTAGGED)))
    {


#if 0 // Raid-69667: OE5: Kor: Only the charset, euc-kr, is used for news message
        // ISO-2022-KR -> EUC-KR for News text/plain
        if (ISFLAGSET(m_dwState, TREESTATE_SAVENEWS) && 949 == m_rOptions.pCharset->cpiWindows && pNode->pContainer->IsContentType(NULL, STR_SUB_PLAIN) == S_OK)
        {
            // Locals
            LPINETCSETINFO pEUCKR;

            // Find EUC-KR
            if (SUCCEEDED(g_pInternat->HrOpenCharset("EUC-KR", &pEUCKR)))
                pNode->pBody->SetCharset(pEUCKR->hCharset, CSET_APPLY_UNTAGGED);
        }

        // Otherwise, use current charset
        else
#endif // Raid-69667: OE5: Kor: Only the charset, euc-kr, is used for news message

        // Store the Character set
        pNode->pBody->SetCharset(m_rOptions.pCharset->hCharset, m_rOptions.csetapply);

        // Get original charset
        if (fAttachment && S_OK == pNode->pBody->IsType(IBT_CSETTAGGED))
        {
            // Get the tagged charset
            pTaggedCset = pNode->pBody->PGetTaggedCset();

            // Set the charset property
            pNode->pContainer->SetProp(PIDTOSTR(PID_PAR_CHARSET), pTaggedCset->szName);

            // Remove the CSETTAGGED state, and then reset it after we write the body
            // This will keep the body from being character set converted
            pNode->pBody->ClearState(BODYSTATE_CSETTAGGED);
        }
    }

    // Otherwise, remove the charset parameter, we don't encode attachments in a character set
    else
    {
        // Remove the CharacterSet parameter from the body
        pNode->pContainer->DeleteProp(SYM_PAR_CHARSET);
    }

    // Write the header...
    if (SAVE_RFC1521 == m_rOptions.savetype || 0 == ulLevel)
    {
        // Write the header
        CHECKHR(hr = _HrWriteHeader(fClearDirty, pStream, pNode));
    }

    // Determine the send ietEncoding
    if (SAVE_RFC1521 == m_rOptions.savetype)
    {
        // Write body data into the stream
        CHECKHR(hr = pNode->pBody->GetDataHere(ietEncoding, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

    // Otherwise, SAVE_RFC822
    else if (SAVE_RFC822 == m_rOptions.savetype && IET_UUENCODE == ietEncoding)
    {
        // Starting boundary/header
        if (ulLevel > 0)
            pNode->boundary = BOUNDARY_UUBEGIN;

        // Start new line
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Get Boundary Start
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBoundaryStart));

        // Header Start and boundary start are the same
        if (ulLevel > 0)
            pNode->cbHeaderStart = pNode->cbBoundaryStart;

        // Write begin
        CHECKHR(hr = pStream->Write(c_szUUENCODE_BEGIN, lstrlen(c_szUUENCODE_BEGIN), NULL));

        // Write the file permission
        CHECKHR(hr = pStream->Write(c_szUUENCODE_666, lstrlen(c_szUUENCODE_666), NULL));

        // Write UU File Name
        CHECKHR(hr = _HrWriteUUFileName(pStream, pNode));

        // Start new line
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Get Header End
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

        // Write the data
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_UUENCODE, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));

        // Write end
        CHECKHR(hr = pStream->Write(c_szUUENCODE_END, lstrlen(c_szUUENCODE_END), NULL));
    }

    // Otherwise, SAVE_RFC822 and IET_7BIT
    else if (SAVE_RFC822 == m_rOptions.savetype && IET_7BIT == ietEncoding)
    {
        // Get Boundary Start....
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyStart));

        // Starting boundary/header
        if (ulLevel > 0)
        {
            // No Boundary
            pNode->boundary = BOUNDARY_NONE;

            // Boundoff
            pNode->cbBoundaryStart = pNode->cbBodyStart;

            // Same as header start
            pNode->cbHeaderStart = pNode->cbBoundaryStart;
        }

        // Write the data
        CHECKHR(hr = pNode->pBody->GetDataHere(IET_7BIT, pStream));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write final crlf
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Body End...
        CHECKHR(hr = HrGetStreamPos(pStream, &pNode->cbBodyEnd));
    }

    // Otherwise...
    else
        AssertSz(FALSE, "A body is about to be lost. Contact sbailey at x32553 NOW!!!");

exit:
    // Try to fixup the body
    if (pTaggedCset)
    {
        pNode->pBody->SetCharset(pTaggedCset->hCharset, CSET_APPLY_UNTAGGED);
        pNode->pBody->SetState(BODYSTATE_CSETTAGGED);
    }

    // Free BodyInfo
    SafeMemFree(pszFileName);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBodyInheritOptions
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBodyInheritOptions(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT     hr=S_OK;
    PROPVARIANT rValue;

    // Invalid ARg
    Assert(pNode);

    // Allow 8bit in header
    rValue.boolVal = m_rOptions.fAllow8bitHeader;
    CHECKHR(hr = pNode->pBody->SetOption(OID_ALLOW_8BIT_HEADER, &rValue));

    // Wrap Body Text
    rValue.boolVal = m_rOptions.fWrapBodyText;
    CHECKHR(hr = pNode->pBody->SetOption(OID_WRAP_BODY_TEXT, &rValue));

    // Max Header Line
    rValue.ulVal = m_rOptions.cchMaxHeaderLine;
    CHECKHR(hr = pNode->pBody->SetOption(OID_CBMAX_HEADER_LINE, &rValue));

    // Persist Type
    rValue.ulVal = (ULONG)m_rOptions.savetype;
    CHECKHR(hr = pNode->pBody->SetOption(OID_SAVE_FORMAT, &rValue));

    // Max Body Line
    rValue.ulVal = m_rOptions.cchMaxBodyLine;
    CHECKHR(hr = pNode->pBody->SetOption(OID_CBMAX_BODY_LINE, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::Load(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    ULONG               i;
    HCHARSET            hCharset;
    PROPVARIANT         rVersion;
    STGMEDIUM           rMedium;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Assume the Bind has Finished
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // Release m_pStmLock
    SafeRelease(m_pStmLock);

    // Do I have a tree already...
    if (!ISFLAGSET(m_dwState, TREESTATE_LOADED) || FAILED(_HrBindOffsetTable(pStream, &m_pStmLock)))
    {
        // InitNew
        CHECKHR(hr = _HrLoadInitNew());

        // Use file
        if (m_rOptions.fBindUseFile)
            FLAGSET(m_dwState, TREESTATE_BINDUSEFILE);

        // If this fails, I assume the clients stream is already rewound and they don't support this
        HrRewindStream(pStream);

        // Fake OnStartBinding
        OnStartBinding(0, NULL);

        // Setup the Storage Medium
        ZeroMemory(&rMedium, sizeof(STGMEDIUM));
        rMedium.tymed = TYMED_ISTREAM;
        rMedium.pstm = pStream;

        // Fake OnDataAvailable
        OnDataAvailable(BSCF_LASTDATANOTIFICATION, 0, NULL, &rMedium);

        // Fake OnStartBinding
        OnStopBinding(S_OK, NULL);

        // If bind failed, return warnings
        if (FAILED(m_hrBind))
            hrWarnings = MIME_S_INVALID_MESSAGE;
    }

    // Otherwise, we are finished binding
    else
    {
        // HandleCanInlineTextOption
        _HandleCanInlineTextOption();

        // Bind Finished
        FLAGSET(m_dwState, TREESTATE_BINDDONE);

        // DispatchBindRequest
        _HrProcessPendingUrlRequests();
    }

    // Assume the stream
    Assert(m_pStmLock);

    // Allow for zero-byte stream to be Loaded
    if (m_cbMessage)
    {
        // Is MIME ?
        rVersion.vt = VT_UI4;
        if (SUCCEEDED(m_pRootNode->pContainer->GetProp(PIDTOSTR(PID_HDR_MIMEVER), 0, &rVersion)))
        {
            // Its a Mime Message
            m_rOptions.savetype = SAVE_RFC1521;

            // Invalid Version
            if (rVersion.ulVal != TREE_MIMEVERSION)
                hrWarnings = MIME_S_MIME_VERSION;
        }

        // Otherwise, savetype should default to rfc822
        else
            m_rOptions.savetype = SAVE_RFC822;

        // Detect Partials and Set FileName/Encoding Correctly
        _FuzzyPartialRecognition(m_rOptions.savetype == SAVE_RFC822 ? FALSE : TRUE);

        // Bind All Bodies to the Tree
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Readability - Should not have any deleted bodies yet
            if (m_rTree.prgpNode[i] && !ISFLAGSET(m_rTree.prgpNode[i]->dwState, NODESTATE_BOUNDTOTREE))
            {
                // BindState is done
                m_rTree.prgpNode[i]->bindstate = BINDSTATE_COMPLETE;

                // Bind to the tree
                CHECKHR(hr = m_rTree.prgpNode[i]->pBody->HrBindToTree(m_pStmLock, m_rTree.prgpNode[i]));
            }
        }

        // Determine the dominent charcter set of the message
        if (SUCCEEDED(_HrGetCharsetTree(m_pRootNode, &hCharset)) && hCharset)
        {
            // Apply Charset to Untagged bodies
            SetCharset(hCharset, CSET_APPLY_UNTAGGED);
        }
    }

#ifdef DEBUG
    // Write X-Mailer or X-NewsReader
    DebugWriteXClient();
#endif

    // My hands are on the storage
    FLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE);

    // Dirty
    ClearDirty();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HandleCanInlineTextOption
// --------------------------------------------------------------------------------
void CMessageTree::_HandleCanInlineTextOption(void)
{
    // Locals
    FINDBODY        rFind;
    HBODY           hMixed;
    LPTREENODEINFO  pNode;
    LPTREENODEINFO  pChild;
    LPTREENODEINFO  pText=NULL;

    // Only do this if the client doesn't support inlining multiple text bodies, such as Outlook Express
    if (TRUE == m_rOptions.fCanInlineText)
        return;

    // Raid 53456: mail: We should be displaying the plain text portion and making enriched text an attachment for attached msg
    // Raid 53470: mail:  We are not forwarding the attachment in the attached message
    // I am going to find the first multipart/mixed section, then find the first text/plain body, and then 
    // mark all of the text/*, non-attachment bodies after that as attachments
    ZeroMemory(&rFind, sizeof(FINDBODY));
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_MIXED;

    // Find First
    if (FAILED(FindFirst(&rFind, &hMixed)))
        goto exit;

    // Get node for hMixed
    pNode = _PNodeFromHBody(hMixed);

    // Loop
    for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
    {
        // Not an attachment
        if (S_FALSE == pChild->pBody->IsType(IBT_ATTACHMENT))
        {
            // Is text/plain
            if (S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) ||
                S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
            {
                pText = pChild;
                break;
            }
        }
    }

    // If we found a text body
    if (NULL == pText)
        goto exit;

    // Loop through the children again
    for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
    {
        // Is text/*
        if (pChild != pText && S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, NULL) && S_FALSE == pChild->pBody->IsType(IBT_ATTACHMENT))
        {
            // Mark as attachment
            pChild->pContainer->SetProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT);

            // Set a special flag to denote it was converted to an attachment
            FLAGSET(pChild->dwState, NODESTATE_AUTOATTACH);
        }
    }

exit:
    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindOffsetTable
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindOffsetTable(IStream *pStream, CStreamLockBytes **ppStmLock)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cb;
    CInternetStream cInternet;

    // Init
    *ppStmLock = NULL;

    // Get Sizeof Stream
    CHECKHR(hr = HrSafeGetStreamSize(pStream, &cb));

    // Otherwise bind the body table
    if (cb != m_cbMessage)
    {
        hr = TrapError(MIME_E_MSG_SIZE_DIFF);
        goto exit;
    }

    // Init the Internet Stream
    CHECKHR(hr = cInternet.HrInitNew(pStream));

    // Fast Parse Body
    CHECKHR(hr = _HrFastParseBody(&cInternet, m_pRootNode));

    // Success, get the lockbytes from the internet stream
    cInternet.GetLockBytes(ppStmLock);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBodyOffsets
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBodyOffsets(HBODY hBody, LPBODYOFFSETS pOffsets)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // Invalid Arg
    if (NULL == hBody || NULL == pOffsets)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // No Data ?
    CHECKHR(hr = pNode->pBody->GetOffsets(pOffsets));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::ClearDirty
// --------------------------------------------------------------------------------
void CMessageTree::ClearDirty(void)
{
    // If Dirty...
    FLAGCLEAR(m_dwState, TREESTATE_DIRTY);

    // Loop through bodies and ask IMimeHeader's and IMimeBody's
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // If NULL...
        if (NULL == m_rTree.prgpNode[i])
            continue;
        
        // Dirty Header...
        m_rTree.prgpNode[i]->pBody->ClearDirty();
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::GetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCharset(LPHCHARSET phCharset)
{
    // Locals
    HRESULT     hr=S_OK;
    HCHARSET    hCharset;

    // Check Params
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phCharset = NULL;

    // Recurse the current tree
    if (NULL == m_rOptions.pCharset && m_pRootNode)
    {
        // Get charset
        if (SUCCEEDED(_HrGetCharsetTree(m_pRootNode, &hCharset)))
        {
            // Get Pointer to Charset
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_rOptions.pCharset)));
        }
    }

    // No Charset
    if (NULL == m_rOptions.pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Set Return
    *phCharset = m_rOptions.pCharset->hCharset;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrGetCharsetTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrGetCharsetTree(LPTREENODEINFO pNode, LPHCHARSET phCharset)
{
    // Locals
    LPTREENODEINFO pChild;

    // Invalid Arg
    Assert(pNode && phCharset && m_rOptions.pCharset);

    // Init
    *phCharset = NULL;

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            if (SUCCEEDED(_HrGetCharsetTree(pChild, phCharset)) && *phCharset)
                break;
        }
    }

    // If the Header was tagged with a charset, use that charset
    else if (pNode->pContainer->IsState(COSTATE_CSETTAGGED) == S_OK)
    {     
        // Get Internal Character Set
        if (SUCCEEDED(pNode->pContainer->GetCharset(phCharset)) && *phCharset)
            goto exit;
    }

exit:
    // Done
    return (*phCharset) ? S_OK : E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Lookiup Charset Info
    if (FALSE == g_pInternat->FIsValidHandle(hCharset))
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Save the charset
    SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_rOptions.pCharset)));

    // Save apply type
    m_rOptions.csetapply = applytype;

    // If we have a root body
    if (m_pRootNode)
    {
        // Recurse all bodies and set the charset
        CHECKHR(hr = _HrSetCharsetTree(m_pRootNode, m_rOptions.pCharset->hCharset, m_rOptions.csetapply));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSetCharsetTree
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSetCharsetTree(LPTREENODEINFO pNode, HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode);

    // Raid-22662: OExpress: if content-type on fileattach does not have charset should apply same as message body
    pNode->pBody->SetCharset(hCharset, applytype);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrSetCharsetTree(pChild, hCharset, applytype));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrValidateOffsets
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrValidateOffsets(LPTREENODEINFO pNode)
{
    // Invalid Arg
    Assert(pNode);

    // Validate the offsets
    if (pNode->cbBodyStart > m_cbMessage || pNode->cbBodyEnd > m_cbMessage ||
        pNode->cbHeaderStart > m_cbMessage || pNode->cbBoundaryStart > m_cbMessage)
    {
        Assert(FALSE);
        return TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
    }

    // Validate the offsets
    if (pNode->cbBodyStart > pNode->cbBodyEnd || pNode->cbBoundaryStart > pNode->cbHeaderStart ||
        pNode->cbHeaderStart > pNode->cbBodyStart || pNode->cbBoundaryStart > pNode->cbBodyEnd)
    {
        Assert(FALSE);
        return TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrValidateStartBoundary
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrValidateStartBoundary(CInternetStream *pInternet, LPTREENODEINFO pNode, 
    LPSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;

    // Is there a boundary to read...
    if (BOUNDARY_MIMENEXT == pNode->boundary)
    {
        // Seek to the boundary start..
        pInternet->Seek(pNode->cbBoundaryStart);

        // Readline and verify the header
        CHECKHR(hr = pInternet->HrReadLine(&rLine));

        // Read and verify the boundary...
        if (!ISVALIDSTRINGA(&pNode->rBoundary) || BOUNDARY_MIMENEXT != _GetMimeBoundaryType(&rLine, &pNode->rBoundary))
        {
            AssertSz(FALSE, "MIME_E_BODYTREE_OUT_OF_SYNC");
            hr = TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
            goto exit;
        }
    }

    // Otherwise, verify UU boundary
    else if (BOUNDARY_UUBEGIN == pNode->boundary)
    {
        // Seek to the boundary start..
        pInternet->Seek(pNode->cbBoundaryStart);

        // Readline and verify the header
        CHECKHR(hr = pInternet->HrReadLine(&rLine));

        // Read and verify the boundary...
        if (FALSE == _FIsUuencodeBegin(&rLine, ppszFileName))
        {
            AssertSz(FALSE, "MIME_E_BODYTREE_OUT_OF_SYNC");
            hr = TrapError(MIME_E_BODYTREE_OUT_OF_SYNC);
            goto exit;
        }

        // FileName..
        AssertSz(!ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART), "pszFileName is not going to get set.");
    }

    // Otherwise, header start should be same as boundary start
    else 
        Assert(BOUNDARY_ROOT == pNode->boundary ? TRUE : pNode->cbBoundaryStart == pNode->cbHeaderStart);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrFastParseBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrFastParseBody(CInternetStream *pInternet, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rVariant;
    LPSTR           pszFileName=NULL;
    LPTREENODEINFO  pChild, 
                    pTemp;

    // check params
    Assert(pInternet && pNode);

    // Validate Offset
    CHECKHR(hr = _HrValidateOffsets(pNode));

    // Validate Start Boundary
    CHECKHR(hr = _HrValidateStartBoundary(pInternet, pNode, &pszFileName));

    // Is there a header to read...
    if (BOUNDARY_MIMENEXT == pNode->boundary || BOUNDARY_ROOT == pNode->boundary)
    {
        // Load the header
        Assert(pNode->boundary == BOUNDARY_ROOT ? m_pRootNode == pNode : TRUE);

        // Seek to the boundary start..
        pInternet->Seek(pNode->cbHeaderStart);

        // Load the Header
        CHECKHR(hr = pNode->pContainer->Load(pInternet));

        // Raid-38646: Mimeole:  Multipart/Digest not being parsed correctly initially, but save fine
        // Message In a Message
        if (pNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
        {
            // We are parsing a message attachment
            FLAGSET(pNode->dwState, NODESTATE_MESSAGE);
        }

        // Otherwise, if parent and parent is a multipart/digest
        else if (pNode->pParent && pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK &&
                 pNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTTYPE)) == S_FALSE)
        {
            // Change the Content Type
            pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822);

            // This is a message
            FLAGSET(pNode->dwState, NODESTATE_MESSAGE);
        }
    }

    // Encoding
    else if (!ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART))
    {
        // ComputeDefaultContent
        CHECKHR(hr = _HrComputeDefaultContent(pNode, pszFileName));
    }

    // Fake Multipart...
    if (ISFLAGSET(pNode->dwType, NODETYPE_FAKEMULTIPART))
    {
        // Application/octet-stream
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

        // Loop children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check pChild
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrFastParseBody(pInternet, pChild));
        }
    }

    // If Multipart...cruise through the children
    else if (_IsMultiPart(pNode))
    {
        // Get the boundary from the header
        rVariant.type = MVT_STRINGA;
        if (FAILED(pNode->pContainer->GetProp(SYM_PAR_BOUNDARY, 0, &rVariant)))
        {
            hr = TrapError(MIME_E_NO_MULTIPART_BOUNDARY);
            goto exit;
        }

        // But the Boundary into pNode->rBoundary
        pNode->rBoundary.pszVal = rVariant.rStringA.pszVal;
        pNode->rBoundary.cchVal = rVariant.rStringA.cchVal;

        // Free this boundary later
        FLAGCLEAR(pNode->dwState, NODESTATE_BOUNDNOFREE);

        // Loop children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check pChild
            Assert(pChild->pParent == pNode);

            // Put the Boundary into pChild
            pChild->rBoundary.pszVal = rVariant.rStringA.pszVal;
            pChild->rBoundary.cchVal = rVariant.rStringA.cchVal;

            // Done free the boundary
            FLAGSET(pChild->dwState, NODESTATE_BOUNDNOFREE);

            // Bind the body table for this dude
            CHECKHR(hr = _HrFastParseBody(pInternet, pChild));
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FuzzyPartialRecognition
// --------------------------------------------------------------------------------
void CMessageTree::_FuzzyPartialRecognition(BOOL fIsMime)
{
    // Locals
    CHAR            szFile[MAX_PATH];
    ULONG           ulTotal;
    ULONG           ulPart;
    BOOL            fCntTypeSet=FALSE;
    LPSTR           pszContentType=NULL;
    CHAR            szExt[_MAX_EXT];

    // Better have a Root
    Assert(m_pRootNode);

    // Only if this is the 
    if (fIsMime || m_pRootNode->cChildren || m_pRootNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN) == S_FALSE)
        goto exit;

    // Extract FileName and part/total from the subject
    if (FAILED(MimeOleGetSubjectFileName(m_pRootNode->pBody, &ulPart, &ulTotal, szFile, MAX_PATH)))
        goto exit;

    // Mark as Partial
    FLAGSET(m_pRootNode->dwType, NODETYPE_INCOMPLETE);

    // A Little Debugging
    DebugTrace("FuzzyPartialRecognition - FileName = '%s', Part = %d, Total = %d\n", szFile, ulPart, ulTotal);

    // Store the FileName
    if (FAILED(m_pRootNode->pContainer->SetProp(SYM_ATT_FILENAME, szFile)))
        goto exit;

    // Get File Extesion
    if (SUCCEEDED(MimeOleGetFileExtension(szFile, szExt, sizeof(szExt))))
    {
        // GetExtContentType
        if (SUCCEEDED(MimeOleGetExtContentType(szExt, &pszContentType)))
        {
            // Set Content Type
            m_pRootNode->pContainer->SetProp(SYM_HDR_CNTTYPE, pszContentType);

            // We Set the content type
            fCntTypeSet = TRUE;
        }
    }

    // Default to Application/octet-stream
    if (FALSE == fCntTypeSet)
        m_pRootNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM);

    // Set Encoding
    m_pRootNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT);

    // I Should Actualy do some detection...
    if (FALSE == fIsMime)
        m_pRootNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_UUENCODE);

exit:
    // Cleanup
    SafeMemFree(pszContentType);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrComputeDefaultContent
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrComputeDefaultContent(LPTREENODEINFO pNode, LPCSTR pszFileName)
{
    // Locals
    HRESULT          hr=S_OK;
    CHAR             szExt[256];
    LPSTR            pszContentType=NULL;
    LPSTR            pszDecoded=NULL;

    // Invalid Arg
    Assert(pNode);

    // Otherwise, lets get the content type
    if (pszFileName)
    {
        // Set File Name
        PROPVARIANT rVariant;
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)pszFileName;

        // Set the file name
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_FILENAME), PDF_ENCODED, &rVariant));

        // Get the filename back out so that its decoded...
        CHECKHR(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), &pszDecoded));

        // Test for winmail.dat
        if (lstrcmpi(pszDecoded, c_szWinmailDotDat) == 0)
        {
            // Make sure the stream is really TNEF
            FLAGSET(pNode->dwState, NODESTATE_VERIFYTNEF);
        }

        // Get File Extesion
        if (SUCCEEDED(MimeOleGetFileExtension(pszDecoded, szExt, sizeof(szExt))))
        {
            // GetExtContentType
            if (SUCCEEDED(MimeOleGetExtContentType(szExt, &pszContentType)))
            {
                // Set Content Type
                CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, pszContentType));
            }
            else
            {
                // Set Content Type
                CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM));
            }
        }

        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
    }

    // Otherwise
    else
    {
        // Default to text/plain
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));
    }

    // Boundary Was UUencode
    if (BOUNDARY_UUBEGIN == pNode->boundary)
    {
        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_UUENCODE));
    }

    else if (ISFLAGSET(pNode->dwType,NODETYPE_RFC1154_BINHEX))
    {
        // This is BINHEX from RFC1154
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), STR_CNT_APPLICATION));
        CHECKHR(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), STR_SUB_BINHEX));
    }

    // Otherwise
    else
    {
        // Set Encoding
        CHECKHR(hr = pNode->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));
    }

exit:
    // Cleanup
    SafeMemFree(pszContentType);
    SafeMemFree(pszDecoded);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::HandsOffStorage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::HandsOffStorage(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmNew=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Internal Stream...
    if (NULL == m_pStmLock)
        goto exit;

    // I own the stream
    if (!ISFLAGSET(m_dwState, TREESTATE_HANDSONSTORAGE))
        goto exit;

    // Copy m_pStmLock to a local place...
    CHECKALLOC(pstmNew = new CVirtualStream);

    // Go through m_pLockBytes to continue to provide thread safety to m_pStmLock
    CHECKHR(hr = HrCopyLockBytesToStream(m_pStmLock, pstmNew, NULL));

    // Rewind and commit
    CHECKHR(hr = pstmNew->Commit(STGC_DEFAULT));

    // Replace internal stream
    m_pStmLock->ReplaceInternalStream(pstmNew);

    // Hands are off..
    FLAGCLEAR(m_dwState, TREESTATE_HANDSONSTORAGE);

exit:
    // Cleanup
    SafeRelease(pstmNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetMessageSource
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetMessageSource(IStream **ppStream, DWORD dwFlags)
{
    // Locals
    HRESULT          hr=S_OK;
    IStream         *pStream=NULL;

    // Invalid Arg
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Init
    *ppStream = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty
    if (ISFLAGSET(dwFlags, COMMIT_ONLYIFDIRTY) && IsDirty() == S_OK && FALSE == m_rOptions.fHandsOffOnSave)
    {
        // Commit
        CHECKHR(hr = Commit(dwFlags));
    }

    // Raid-19644: MIMEOLE: GetMessageSource fails with MIME_E_NO_DATA (because of OID_HANDSOFF_ONSAVE = TRUE)
    if (NULL == m_pStmLock || TRUE == m_rOptions.fHandsOffOnSave)
    {
        // Create a new stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Call Save Message
        CHECKHR(hr = _HrWriteMessage(pStream, FALSE, m_rOptions.fHandsOffOnSave, FALSE));

        // All good
        *ppStream = pStream;

        // Null pStream
        pStream = NULL;
    }

    // Otherwise, just wrap m_pStmLock
    else if (m_pStmLock)
    {
        // Locked Stream
        CHECKALLOC(*ppStream = (IStream *)new CLockedStream(m_pStmLock, m_cbMessage));
    }

    // Otherwise, failure
    else
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeRelease(pStream);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryService
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryService(REFGUID rsid, REFIID riid, void **ppvObject) /* IServiceProvider */
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IID_IBindMessageStream
    if (IID_IBindMessageStream == riid)
    {
        // We should not have a lock bytes yet
        Assert(NULL == m_pStmLock);

        // Create a Virtual Stream
        CHECKHR(hr = MimeOleCreateVirtualStream((IStream **)ppvObject));
    }

    // IID_IBinding
    else if (IID_IBinding == riid)
    {
        // No Bind Context Yet
        if (NULL == m_pBinding)
        {
            hr = TrapError(E_UNEXPECTED);
            goto exit;
        }

        // Return It
        (*ppvObject) = m_pBinding;
        ((IUnknown *)*ppvObject)->AddRef();
    }

    // IID_IMoniker
    else if (IID_IMoniker == riid)
    {
        // No Bind Context Yet
        if (NULL == m_pMoniker)
        {
            hr = TrapError(E_UNEXPECTED);
            goto exit;
        }

        // Return It
        (*ppvObject) = m_pMoniker;
        ((IUnknown *)*ppvObject)->AddRef();
    }

    // Otherwise, no object
    else
    {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::BinToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::BindToObject(const HBODY hBody, REFIID riid, void **ppvObject)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == ppvObject)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // BindToObject on the body
    CHECKHR(hr = pNode->pBody->BindToObject(riid, ppvObject));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr; 
}

// --------------------------------------------------------------------------------
// CMessageTree::_PoseCreateTreeNode
// --------------------------------------------------------------------------------
void CMessageTree::_PostCreateTreeNode(HRESULT hrResult, LPTREENODEINFO pNode)
{
    // Failure...
    if (FAILED(hrResult) && pNode)
    {
        // Set Index
        ULONG ulIndex = HBODYINDEX(pNode->hBody);

        // This body better be here
        Assert(m_rTree.prgpNode[ulIndex] == pNode);

        // Lets make sure nobody else is referencing this node...
#ifdef DEBUG
        for (ULONG i=0; i<m_rTree.cNodes; i++)
        {
            if (m_rTree.prgpNode[i])
            {
                AssertSz(m_rTree.prgpNode[i]->pPrev != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pNext != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pParent != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pChildHead != pNode, "Killing a linked node is not good");
                AssertSz(m_rTree.prgpNode[i]->pChildTail != pNode, "Killing a linked node is not good");
            }
        }
#endif

        // This node should not have been linked yet...
        AssertSz(pNode->pPrev == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pNext == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pParent == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pChildHead == NULL, "Killing a linked node is not good");
        AssertSz(pNode->pChildTail == NULL, "Killing a linked node is not good");
        AssertSz(pNode->cChildren == 0, "Deleting a node with children");

        // Free It
        _FreeTreeNodeInfo(pNode);

        // Reset entry in table
        m_rTree.prgpNode[ulIndex] = NULL;

        // If Index is last item
        if (ulIndex + 1 == m_rTree.cNodes)
            m_rTree.cNodes--;

        // Otherwise, Increment Empty Count...
        else
            m_rTree.cEmpty++;
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrCreateTreeNode
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrCreateTreeNode(LPTREENODEINFO *ppNode)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i=0;
    BOOL        fUsingEmpty=FALSE;

    // Invalid Arg
    Assert(ppNode);

    // Use Empty Cell
    if (m_rTree.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rTree.cNodes; i++)
        {
            // Empty ?
            if (NULL == m_rTree.prgpNode[i])
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rTree.cNodes + 1 > m_rTree.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rTree.prgpNode, sizeof(LPTREENODEINFO) * (m_rTree.cAlloc + 10)));

            // Increment alloc size
            m_rTree.cAlloc += 10;
        }

        // Index to use
        i = m_rTree.cNodes;
    }

    // Set to empty
    m_rTree.prgpNode[i] = NULL;

    // Allocate this node...
    CHECKHR(hr = _HrAllocateTreeNode(i));

    // Return It
    *ppNode = m_rTree.prgpNode[i];

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rTree.cNodes++;

    // Otherwise, decrement number of empty cells
    else
        m_rTree.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::InsertBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::InsertBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode=NULL; 
    LPTREENODEINFO  pPivot=NULL;
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // Invalid Arg
    if (IBL_PARENT == location)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Handle Body Type
    if (IBL_ROOT == location)
    {
        // Currently No root
        if (NULL == m_pRootNode)
        {
            // Create Object
            CHECKHR(hr = _HrCreateTreeNode(&pNode));

            // Better not be any bodies
            Assert(m_rTree.cNodes == 1);

            // Set as root
            m_pRootNode = pNode;
        }

        // Otherwise, re-use the root
        else
        {
            hr = TrapError(MIME_E_CANT_RESET_ROOT);
            goto exit;
        }
    }

    // All non-root inserts
    else
    {
        // Get Pivot
        if (_FIsValidHandle(hPivot) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast it..
        pPivot = _PNodeFromHBody(hPivot);

        // Create Object
        CHECKHR(hr = _HrCreateTreeNode(&pNode));

        // First or Last Child
        if (IBL_LAST == location || IBL_FIRST == location)
        {
            // Better be a multipart
            if (!_IsMultiPart(pPivot))
            {
                hr = TrapError(MIME_E_NOT_MULTIPART);
                goto exit;
            }

            // DON'T FAIL FROM HERE TO END OF FUNCTION
            // No Children on pPivot
            if (NULL == pPivot->pChildHead)
            {
                Assert(pPivot->pChildTail == NULL);
                pPivot->pChildHead = pNode;
                pPivot->pChildTail = pNode;
                pNode->pParent = pPivot;
            }

            // IBL_LAST
            else if (IBL_LAST == location)
            {
                pPrev = pPivot->pChildTail;
                pNode->pPrev = pPrev;
                pPrev->pNext = pNode;
                pPivot->pChildTail = pNode;
                pNode->pParent = pPivot;
            }

            // IBL_FIRST
            else if (IBL_FIRST == location)
            {
                pNext = pPivot->pChildHead;
                pNode->pNext = pNext;
                pNext->pPrev = pNode;
                pPivot->pChildHead = pNode;
                pNode->pParent = pPivot;
            }

            // Increment Count
            pPivot->cChildren++;
        }

        // Otherwise
        else if (IBL_NEXT == location || IBL_PREVIOUS == location)
        {
            // Need a parent
            pParent = pPivot->pParent;

            // No Parent
            if (NULL == pParent)
            {
                hr = TrapError(MIME_E_NOT_MULTIPART);
                goto exit;
            }

            // DON'T FAIL FROM HERE TO END OF FUNCTION
            // Parent Better be a multipart
            Assert(_IsMultiPart(pParent));

            // Set Parent
            pNode->pParent = pParent;

            // IBL_NEXT
            if (IBL_NEXT == location)
            {
                // Set Previous
                pPrev = pPivot;

                // Append to the end
                if (NULL == pPrev->pNext)
                {
                    pPrev->pNext = pNode;
                    pNode->pPrev = pPrev;
                    pParent->pChildTail = pNode;
                }

                // Otherwise, inserting between two nodes
                else
                {
                    pNext = pPrev->pNext;
                    pNode->pPrev = pPrev;
                    pNode->pNext = pNext;
                    pPrev->pNext = pNode;
                    pNext->pPrev = pNode;
                }
            }

            // IBL_PREVIOUS
            else if (IBL_PREVIOUS == location)
            {
                // Set Previous
                pNext = pPivot;

                // Append to the end
                if (NULL == pNext->pPrev)
                {
                    pNext->pPrev = pNode;
                    pNode->pNext = pNext;
                    pParent->pChildHead = pNode;
                }

                // Otherwise, inserting between two nodes
                else
                {
                    pPrev = pNext->pPrev;
                    pNode->pNext = pNext;
                    pNode->pPrev = pPrev;
                    pPrev->pNext = pNode;
                    pNext->pPrev = pNode;
                }
            }

            // Increment Count
            pParent->cChildren++;
        }

        // Otherwise bad body location
        else
        {
            hr = TrapError(MIME_E_BAD_BODY_LOCATION);
            goto exit;
        }
    }

    // Set Return
    if (phBody)
        *phBody = pNode->hBody;

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Failure
    _PostCreateTreeNode(hr, pNode);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBody(BODYLOCATION location, HBODY hPivot, LPHBODY phBody)
{
    // Locals
    HRESULT     hr=S_OK;
    LPTREENODEINFO  pPivot, pCurr;

    // check params
    if (NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Handle Root Case
    if (IBL_ROOT == location)
    {
        if (m_pRootNode)
            *phBody = m_pRootNode->hBody;
        else
            hr = MIME_E_NOT_FOUND;
    }

    // Otherwise
    else
    {
        // Validate handle
        if (_FIsValidHandle(hPivot) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast It
        pPivot = _PNodeFromHBody(hPivot);

        // Handle Get Type
        switch(location)
        {
        // ----------------------------------------------
        case IBL_PARENT:
            if (pPivot->pParent)
                *phBody = pPivot->pParent->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_FIRST:
            if (pPivot->pChildHead)
                *phBody = pPivot->pChildHead->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_LAST:
            if (pPivot->pChildTail)
                *phBody = pPivot->pChildTail->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_NEXT:
            if (pPivot->pNext)
                *phBody = pPivot->pNext->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        case IBL_PREVIOUS:
            if (pPivot->pPrev)
                *phBody = pPivot->pPrev->hBody;
            else
                hr = MIME_E_NOT_FOUND;
            break;

        // ----------------------------------------------
        default:
            hr = TrapError(MIME_E_BAD_BODY_LOCATION);
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteBody(HBODY hBody, DWORD dwFlags)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;
    BOOL            fMultipart;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate handle
    if (_FIsValidHandle(hBody) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Cast
    pNode = _PNodeFromHBody(hBody);

    // Free Children...
    fMultipart = (_IsMultiPart(pNode)) ? TRUE :FALSE;

    // Promote Children ?
    if (TRUE == fMultipart && ISFLAGSET(dwFlags, DELETE_PROMOTE_CHILDREN) && pNode->cChildren > 0)
    {
        // Call Helper
        CHECKHR(hr = _HrDeletePromoteChildren(pNode));
    }

    // Otherwise
    else
    {
        // If multipart, delete children
        if (fMultipart && pNode->cChildren > 0)
        {
            // Remove the children
            _DeleteChildren(pNode);
        }

        // If Not Children Only
        if (!ISFLAGSET(dwFlags, DELETE_CHILDREN_ONLY))
        {
            // Was this the root
            if (pNode == m_pRootNode)
            {
                // Delete the content type
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTBASE);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTLOC);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTID);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTTYPE);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTXFER);
                m_pRootNode->pContainer->DeleteProp(SYM_HDR_CNTDISP);

                // Empty the body
                m_pRootNode->pBody->EmptyData();
            }

            // Otherwise, not deleting the root
            else
            {
                // Unlink the node
                _UnlinkTreeNode(pNode);

                // Fix up the table
                m_rTree.prgpNode[HBODYINDEX(hBody)] = NULL;

                // Increment Empty Count
                m_rTree.cEmpty++;

                // Free this node
                _FreeTreeNodeInfo(pNode);
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDeletePromoteChildren
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDeletePromoteChildren(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO    pParent, pChild, pNext, pPrev;

    // Get Parent
    pParent = pNode->pParent;

    // Single Child...
    if (1 == pNode->cChildren)
    {
        // Promote the child up one level...
        Assert(pNode->pChildHead && pNode->pChildHead && pNode->pChildHead == pNode->pChildTail);

        // Get Child
        pChild = pNode->pChildHead;
        Assert(pChild->pNext == NULL && pChild->pPrev == NULL && pChild->pParent == pNode);

        // Replace pBody with pChild
        pChild->pParent = pNode->pParent;
        pChild->pNext = pNode->pNext;
        pChild->pPrev = pNode->pPrev;

        // Is there a parent ?
        if (pParent)
        {
            // Fixup pChildHead and pChildTail
            if (pParent->pChildHead == pNode)
                pParent->pChildHead = pChild;
            if (pParent->pChildTail == pNode)
                pParent->pChildTail = pChild;
        }

        // pNode's next and Previous
        LPTREENODEINFO pNext = pNode->pNext;
        LPTREENODEINFO pPrev = pNode->pPrev;

        // Fixup Next and Previuos
        if (pNext)
            pNext->pPrev = pChild;
        if (pPrev)
            pPrev->pNext = pChild;

        // pNode Basically does not have any children now
        Assert(pNode->cChildren == 1);
        pNode->cChildren = 0;

        // Was this the root ?
        if (m_pRootNode == pNode)
        {
            // OE5 Raid: 51543
            if(S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN))
            {
                pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);
            }

            // Raid 41595 - Athena: Reply to a message includes the body of the message being replied to as an attachment
            CHECKHR(hr = pChild->pContainer->MoveProps(0, NULL, m_pRootNode->pBody));

            // Reset Header on pChild
            pChild->pBody->SwitchContainers(m_pRootNode->pBody);

            // Copy Options from p and tell m_pRootNode->pBody
            m_pRootNode->pBody->CopyOptionsTo(pChild->pBody, TRUE);

            // New root
            m_pRootNode = pChild;
        }

        // We have now totally unlinked pNode
        DebugAssertNotLinked(pNode);

        // Fix up the table
        m_rTree.prgpNode[HBODYINDEX(pNode->hBody)] = NULL;

        // Increment Empty Count
        m_rTree.cEmpty++;

        // Free this node
        _FreeTreeNodeInfo(pNode);
    }

    // Or parent is a multipart
    else
    {
        // No parent or not multipart
        if (NULL == pParent || FALSE == _IsMultiPart(pParent))
        {
            hr = TrapError(MIME_E_INVALID_DELETE_TYPE);
            goto exit;
        }

        // Set Previous
        pPrev = pParent->pChildTail;

        // Walk children of pBody and append as children of pParent
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // pPrev
            pChild->pPrev = pPrev;

            // pNext
            pChild->pNext = NULL;
            
            // pPrev->pNext
            if (pPrev)
                pPrev->pNext = pChild;

            // pChildTail
            pParent->pChildTail = pChild;

            // Set Parent
            pChild->pParent = pParent;

            // Increment pParent child count
            pParent->cChildren++;

            // Save pPrev
            pPrev = pChild;
        }

        // Unlink the node
        _UnlinkTreeNode(pNode);

        // Fix up the table
        m_rTree.prgpNode[HBODYINDEX(pNode->hBody)] = NULL;

        // Increment Empty Count
        m_rTree.cEmpty++;

        // Free this node
        _FreeTreeNodeInfo(pNode);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_DeleteChildren
// --------------------------------------------------------------------------------
void CMessageTree::_DeleteChildren(LPTREENODEINFO pParent)
{
    // Locals
    ULONG           i;
    LPTREENODEINFO  pNode;

    // check params
    Assert(pParent);

    // Loop through bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];

        // Could be null if I already deleted it
        if (NULL == pNode)
            continue;

        // pBody is Parent...
        if (pParent == pNode->pParent)
        {
            // Free Children...
            if (_IsMultiPart(pNode))
            {
                // Delete Children
                _DeleteChildren(pNode);
            }

            // Unlink the node
            _UnlinkTreeNode(pNode);

            // Free this node
            _FreeTreeNodeInfo(pNode);

            // Fix up the table
            m_rTree.prgpNode[i] = NULL;

            // Increment Empty Count
            m_rTree.cEmpty++;
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::MoveBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::MoveBody(HBODY hBody, BODYLOCATION location)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode; 
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate handle
    if (_FIsValidHandle(hBody) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Cast
    pNode = _PNodeFromHBody(hBody);

    // Handle Location Type
    switch(location)
    {
    // ------------------------------------------------------------------------------------
    case IBL_PARENT:
        // Root already
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pParent || NULL == pNode->pParent->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Parent better be a multipart
        Assert(_IsMultiPart(pParent) && _IsMultiPart(pNode->pParent));

        // Unlink from tree
        _UnlinkTreeNode(pNode);

        // Get the current first child
        pPrev = pParent->pChildTail;

        // Fixup pCurrent
        pNode->pPrev = pPrev;

        // Fixup pPrev
        pPrev->pNext = pNode;

        // Fixup Tail
        pParent->pChildTail = pNode;

        // Increment child count
        pParent->cChildren++;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    // This is a swap of two nodes in a doubly-linked list
    case IBL_NEXT:
        // No Next ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pNext)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Setup for move
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // Set pNext up...
        Assert(pNext->pPrev == pNode);
        pNext->pPrev = pPrev;

        // Setup pPrev
        if (pPrev)
        {
            Assert(pPrev->pNext == pNode);
            pPrev->pNext = pNext;
        }

        // Setup pNode->pNext
        pNode->pNext = pNext->pNext;
        if (pNode->pNext)
        {
            Assert(pNode->pNext->pPrev == pNext);
            pNode->pNext->pPrev = pNode;
        }
        pNext->pNext = pNode;

        // Setup pNode->pPrev
        pNode->pPrev = pNext;    

        // Get Parent
        pParent = pNode->pParent;

        // Adjust Child and Tail...
        if (pNode == pParent->pChildHead)
            pParent->pChildHead = pNext;
        if (pNext == pParent->pChildTail)
            pParent->pChildTail = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    // This is a swap of two nodes in a doubly-linked list (reverse of IBL_NEXT)
    case IBL_PREVIOUS:
        // No pPrev ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pPrev)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Setup for move
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // Set pNext
        Assert(pPrev->pNext == pNode);
        pPrev->pNext = pNext;

        // Setup pPrev
        pPrev->pPrev = pNode;

        // Fixup Net
        if (pNext)
        {
            Assert(pNext->pPrev == pNode);
            pNext->pPrev = pPrev;
        }

        // Setup pNode->pNext
        pNode->pNext = pPrev;

        // Setup pNode->pPrev
        pNode->pPrev = pPrev->pPrev;

        // Setup two(prev)->next
        if (pNode->pPrev)
        {
            Assert(pNode->pPrev->pNext == pPrev);
            pNode->pPrev->pNext = pNode;
        }

        // Get Parent
        pParent = pNode->pParent;

        // Adjust Child and Tail...
        if (pNode == pParent->pChildTail)
            pParent->pChildTail = pPrev;
        if (pPrev == pParent->pChildHead)
            pParent->pChildHead = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_FIRST:
        // No Parent ?
        if (NULL == pNode->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Better be first child
        if (NULL == pNode->pPrev)
        {
            Assert(pNode == pParent->pChildHead);
            goto exit;
        }

        // Unlink this body
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // If pPrev
        pPrev->pNext = pNext;

        // If pNext or pChildTail
        if (pNext)
        {
            Assert(pNext->pPrev == pNode);
            pNext->pPrev = pPrev;
        }
        else if (pParent)
        {
            Assert(pParent->pChildTail == pNode);
            pParent->pChildTail = pPrev;
        }

        // Setup pNode
        pNode->pNext = pParent->pChildHead;
        pParent->pChildHead->pPrev = pNode;
        pNode->pPrev = NULL; 
        pParent->pChildHead = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_LAST:
        // No Parent ?
        AssertSz(FALSE, "UNTESTED - PLEASE CALL SBAILEY AT X32553");
        if (NULL == pNode->pParent)
        {
            hr = TrapError(MIME_E_CANT_MOVE_BODY);
            goto exit;
        }

        // Set Parent
        pParent = pNode->pParent;

        // Better be first child
        if (NULL == pNode->pNext)
        {
            Assert(pNode == pParent->pChildTail);
            goto exit;
        }

        // Unlink this body
        pPrev = pNode->pPrev;
        pNext = pNode->pNext;

        // If pPrev
        pNext->pPrev = pPrev;

        // If pNext or pChildTail
        if (pPrev)
        {
            Assert(pPrev->pNext == pNode);
            pPrev->pNext = pNext;
        }
        else if (pParent)
        {
            Assert(pParent->pChildHead == pNode);
            pParent->pChildHead = pNext;
        }

        // Setup pNode
        pNode->pPrev = pParent->pChildTail;
        pNode->pNext = NULL; 
        pParent->pChildTail = pNode;

        // Done
        break;

    // ------------------------------------------------------------------------------------
    case IBL_ROOT:
        hr = TrapError(MIME_E_CANT_MOVE_BODY);
        goto exit;

    // ------------------------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_BAD_BODY_LOCATION);
        goto exit;
    }

    // Dirty
    FLAGSET(m_dwState, TREESTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#ifndef WIN16

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkTreeNode
// --------------------------------------------------------------------------------
void CMessageTree::_UnlinkTreeNode(LPTREENODEINFO pNode)
{
    // Locals
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // Check Params
    Assert(pNode);

    // Set Next and Previous
    pParent = pNode->pParent;
    pPrev = pNode->pPrev;
    pNext = pNode->pNext;

    // If pPrev
    if (pPrev)
        pPrev->pNext = pNext;
    else if (pParent)
        pParent->pChildHead = pNext;

    // If pNext
    if (pNext)
        pNext->pPrev = pPrev;
    else if (pParent)
        pParent->pChildTail = pPrev;

    // Delete Children on Parent
    if (pParent)
        pParent->cChildren--;

    // Cleanup pNode
    pNode->pParent = NULL;
    pNode->pNext = NULL;
    pNode->pPrev = NULL;
    pNode->pChildHead = NULL;
    pNode->pChildTail = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::CountBodies
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::CountBodies(HBODY hParent, boolean fRecurse, ULONG *pcBodies)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pcBodies)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcBodies = 0;

    // No Parent ?
    if (NULL == hParent || HBODY_ROOT == hParent)
    {
        // Is there a root..
        if (NULL == m_pRootNode)
            goto exit;

        // Use Root
        pNode = m_pRootNode;
    }

    // Otherwise, get parent...
    else
    {
        // Validate handle
        if (_FIsValidHandle(hParent) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast
        pNode = _PNodeFromHBody(hParent);
    }

    // Include the root
    (*pcBodies)++;

    // Count the children...
    _CountChildrenInt(pNode, fRecurse, pcBodies);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_CountChildrenInt
// --------------------------------------------------------------------------------
void CMessageTree::_CountChildrenInt(LPTREENODEINFO pParent, BOOL fRecurse, ULONG *pcChildren)
{
    // Locals
    LPTREENODEINFO pNode;

    // check params
    Assert(pParent && pcChildren);

    // Loop through bodies
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];

        // Empty..
        if (NULL == pNode)
            continue;

        // pNode is Parent...
        if (pParent == pNode->pParent)
        {
            // Increment Count
            (*pcChildren)++;

            // Free Children...
            if (fRecurse && _IsMultiPart(pNode))
                _CountChildrenInt(pNode, fRecurse, pcChildren);
        }
    }
}

// --------------------------------------------------------------------------------
// CMessageTree::FindFirst
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::FindFirst(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Invalid Arg
    if (NULL == pFindBody)
        return TrapError(E_INVALIDARG);

    // Init Find
    pFindBody->dwReserved = 0;

    // Find Next
    return FindNext(pFindBody, phBody);
}

// --------------------------------------------------------------------------------
// CMessageTree::FindNext
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::FindNext(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pFindBody || NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Loop
    for (i=pFindBody->dwReserved; i<m_rTree.cNodes; i++)
    {
        // If delete
        pNode = m_rTree.prgpNode[i];

        // Empty
        if (NULL == pNode)
            continue;

        // Compare content type
        if (pNode->pContainer->IsContentType(pFindBody->pszPriType, pFindBody->pszSubType) == S_OK)
        {
            // Save Index of next item to search
            pFindBody->dwReserved = i + 1;
            *phBody = pNode->hBody;
            goto exit;
        }
    }

    // Error
    pFindBody->dwReserved = m_rTree.cNodes; 
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::ToMultipart
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::ToMultipart(HBODY hBody, LPCSTR pszSubType, LPHBODY phMultipart)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pNode;
    LPTREENODEINFO      pNew=NULL;
    LPTREENODEINFO      pParent;
    LPTREENODEINFO      pNext; 
    LPTREENODEINFO      pPrev;

    // check params
    if (NULL == hBody || NULL == pszSubType)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phMultipart)
        *phMultipart = NULL;

    // Get the body from hBody
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // We better have a root
    Assert(m_pRootNode);

    // If pNode does not have a parent...
    if (NULL == pNode->pParent)
    {
        // pNode must be the root ?
        Assert(m_pRootNode == pNode);

        // Create Object
        //N duplicated
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // Set pNode First and Last...
        pNew->pChildHead = m_pRootNode;
        pNew->pChildTail = m_pRootNode;
        m_pRootNode->pParent = pNew;

        // Set Children Count
        pNew->cChildren = 1;

        // Set new root
        m_pRootNode = pNew;

        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Swap Property Sets...
        Assert(m_pRootNode != pNode);
        m_pRootNode->pBody->SwitchContainers(pNode->pBody);

        // Copy Some Props Across
        CHECKHR(hr = m_pRootNode->pBody->MoveProps(ARRAYSIZE(g_rgszToMultipart), g_rgszToMultipart, pNode->pBody));
    }

    // Otherwise, create a body that takes the place of pNode
    else
    {
        // Create a body object
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // DON'T FAIL FROM HERE TO END OF FUNCTION
        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Assume the position of pNode
        pNew->pParent = pNode->pParent;
        pNew->pPrev = pNode->pPrev;
        pNew->pNext = pNode->pNext;
        pNew->pChildHead = pNode;
        pNew->pChildTail = pNode;
        pNew->cChildren = 1;

        // Set pParnet
        pParent = pNode->pParent;

        // Fix up parent head and child
        if (pParent->pChildHead == pNode)
            pParent->pChildHead = pNew;
        if (pParent->pChildTail == pNode)
            pParent->pChildTail = pNew;

        // Set pNode Parent
        pNode->pParent = pNew;

        // Fixup pNext and pPrev
        pNext = pNode->pNext;
        pPrev = pNode->pPrev;
        if (pNext)
            pNext->pPrev = pNew;
        if (pPrev)
            pPrev->pNext = pNew;

        // Clear pNext and pPrev
        pNode->pNext = NULL;
        pNode->pPrev = NULL;
    }

    // Change this nodes content type
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_PRITYPE, STR_CNT_MULTIPART));
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

    pNode->pBody->CopyOptionsTo(pNew->pBody);

exit:
    // Create Worked
    _PostCreateTreeNode(hr, pNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrNodeFromHandle
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrNodeFromHandle(HBODY hBody, LPTREENODEINFO *ppBody)
{
    // Invalid Arg
    Assert(hBody && ppBody);

    // Root ?
    if ((HBODY)HBODY_ROOT == hBody)
    {
        // No Root
        if (NULL == m_pRootNode)
            return MIME_E_NO_DATA;

        // Otherwise, use root
        *ppBody = m_pRootNode;
    }

    // Otherwise
    else
    {
        // Validate handle
        if (_FIsValidHandle(hBody) == FALSE)
            return TrapError(MIME_E_INVALID_HANDLE);

        // Get Node
        *ppBody = _PNodeFromHBody(hBody);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsBodyType
// --------------------------------------------------------------------------------
HRESULT CMessageTree::IsBodyType(HBODY hBody, IMSGBODYTYPE bodytype)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pBody->IsType(bodytype);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::IsContentType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::IsContentType(HBODY hBody, LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->IsContentType(pszPriType, pszSubType);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryBodyProp(HBODY hBody, LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->GetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->SetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteBodyProp(HBODY hBody, LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->DeleteProp(pszName);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FIsUuencodeBegin
// --------------------------------------------------------------------------------
BOOL CMessageTree::_FIsUuencodeBegin(LPPROPSTRINGA pLine, LPSTR *ppszFileName)
{
    // Locals
    ULONG i;

    // check params
    Assert(ISVALIDSTRINGA(pLine));

    // Length must be at least 11 to accomodate "begin 666 " and the first character of a filename.
    if (pLine->cchVal < 11)
        return FALSE;
    
    // First 6 characters must be "begin ", or we're not a valid line.
    if (StrCmpN(pLine->pszVal, "begin ", 6) != 0)
        return FALSE;
    
    // Check characters 6-8 for valid Unix filemode. They must all be digits between 0 and 7.
    for (i=6; i<pLine->cchVal; i++)
    {
        if (pLine->pszVal[i] < '0' || pLine->pszVal[i] > '7')
            break;
    }
    
    // Not a begin line
    if (pLine->pszVal[i] != ' ')
        return FALSE;

    // Get File Name
    if (ppszFileName)
    {
        *ppszFileName = PszDupA(pLine->pszVal + i + 1);
        ULONG cbLine = lstrlen (*ppszFileName);
        StripCRLF(*ppszFileName, &cbLine);
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMessageTree::_GetMimeBoundaryType
// --------------------------------------------------------------------------------
BOUNDARYTYPE CMessageTree::_GetMimeBoundaryType(LPPROPSTRINGA pLine, LPPROPSTRINGA pBoundary)
{
    // Locals
    BOUNDARYTYPE boundary=BOUNDARY_NONE;
    CHAR         ch;
    ULONG        cchLine=pLine->cchVal;
    LPSTR        psz1, psz2;

    // Check Params
    Assert(ISVALIDSTRINGA(pBoundary) && ISVALIDSTRINGA(pLine));

    // Check First two chars of the line
    if ('-' != pLine->pszVal[0] || '-' != pLine->pszVal[1])
        goto exit;

    // Removes trailing white spaces
    while(pLine->cchVal > 0)
    {
        // Get the last character
        ch = *(pLine->pszVal + (pLine->cchVal - 1));

        // No LWSP or CRLF
        if (' ' != ch && '\t' != ch && chCR != ch && chLF != ch)
            break;

        // Decrement Length
        pLine->cchVal--;
    }

    // Decrement two for --
    pLine->cchVal -= 2;

    // Checks line length against boundary length
    if (pLine->cchVal != pBoundary->cchVal && pLine->cchVal != pBoundary->cchVal + 2)
        goto exit;

    // Compare the line with the boundary
    if (StrCmpN(pLine->pszVal + 2, pBoundary->pszVal, (size_t)pBoundary->cchVal) == 0)
    {
        // BOUNDARY_MIMEEND
        if ((pLine->cchVal > pBoundary->cchVal) && (pLine->pszVal[pBoundary->cchVal+2] == '-') && (pLine->pszVal[pBoundary->cchVal+3] == '-'))
            boundary = BOUNDARY_MIMEEND;

        // BOUNDARY_MIMENEXT
        else if (pLine->cchVal == pBoundary->cchVal)
            boundary = BOUNDARY_MIMENEXT;
    }

exit:
    // Relace the Length
    pLine->cchVal = cchLine;

    // Done
    return boundary;
}

// --------------------------------------------------------------------------------
// CMessageTree::ResolveURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::ResolveURL(HBODY hRelated, LPCSTR pszBase, LPCSTR pszURL, 
    DWORD dwFlags, LPHBODY phBody)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pSearchRoot;
    RESOLVEURLINFO      rInfo;
    HBODY               hBody=NULL;
    PROPSTRINGA         rBaseUrl;
    LPSTR               pszFree=NULL;
    LPSTR               pszFree2=NULL;
    BOOL                fMultipartBase=FALSE;

    // InvalidArg
    if (NULL == pszURL)
        return TrapError(E_INVALIDARG);

    // Init
    if (phBody)
        *phBody = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If hRelated is NULL, find the first multipart/related
    if (NULL == hRelated)
    {
        // Find the Related
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
        {
            // Use Root
            hRelated = m_pRootNode->hBody;
        }
    }

    // Get Default Base
    if (NULL == pszBase && FALSE == ISFLAGSET(dwFlags, URL_RESULVE_NO_BASE))
    {
        // Compute the content-base
        if (SUCCEEDED(MimeOleComputeContentBase(this, hRelated, &pszFree, &fMultipartBase)))
            pszBase = pszFree;
    }

    // Setup Resolve URL Info
    ZeroMemory(&rInfo, sizeof(RESOLVEURLINFO));

    // This is the base that we will use to absolutify URLs that are in the text/html body
    rInfo.pszBase = pszBase;

    // Set the url that we are looking for, could be combined with rInfo.pszBase
    rInfo.pszURL = pszURL;

    // Are we searching for a CID type URL.
    if (StrCmpNI(pszURL, c_szCID, lstrlen(c_szCID)) == 0)
    {
        rInfo.fIsCID = TRUE;
        rInfo.pszURL += 4;
    }
    else
        rInfo.fIsCID = FALSE;

    // Raid-62579: Athena: Need to support MHTML content-base inheritance
    if (hRelated)
    {
        // Did pszBase come from the multipart/related section ?
        if (fMultipartBase)
            rInfo.pszInheritBase = pszBase;

        // Otherwise, lookup the multipart/related base header
        else
            rInfo.pszInheritBase = pszFree2 = MimeOleContentBaseFromBody(this, hRelated);
    }

    // Get a Body from the Handle
    CHECKHR(hr = _HrNodeFromHandle(rInfo.fIsCID ? HBODY_ROOT : hRelated, &pSearchRoot));

    // Recurse the Tree
    CHECKHR(hr = _HrRecurseResolveURL(pSearchRoot, &rInfo, &hBody));

    // Not found
    if (NULL == hBody)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Return It ?
    if (phBody)
        *phBody = hBody;

    // Mark as Resolved ?
    if (ISFLAGSET(dwFlags, URL_RESOLVE_RENDERED))
    {
        // Defref the body
        LPTREENODEINFO pNode = _PNodeFromHBody(hBody);

        // Set Rendered
        PROPVARIANT rVariant;
        rVariant.vt = VT_UI4;
        rVariant.ulVal = TRUE;

        // Set the Property
        SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszFree2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrRecurseResolveURL
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrRecurseResolveURL(LPTREENODEINFO pNode, LPRESOLVEURLINFO pInfo, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pChild;

    // Invalid Arg
    Assert(pNode && pInfo && phBody);

    // We must have not found the body yet ?
    Assert(NULL == *phBody);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrRecurseResolveURL(pChild, pInfo, phBody));

            // Done
            if (NULL != *phBody)
                break;
        }
    }

    // Get Character Set Information
    else 
    {
        // Ask the container to do the resolution
        if (SUCCEEDED(pNode->pContainer->HrResolveURL(pInfo)))
        {
            // Cool we found the body, we resolved the URL
            *phBody = pNode->hBody;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::GetPropW(LPCWSTR pwszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::SetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->SetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::SetPropW(LPCWSTR pwszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::DeleteProp(LPCSTR pszName)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->DeleteProp(pszName);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::DeletePropW(LPCWSTR pwszName)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);
    LeaveCriticalSection(&m_cs);
    return hr;
}

STDMETHODIMP CMessageTree::QueryPropW(LPCWSTR pwszName, LPCWSTR pwszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressTable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressTable(IMimeAddressTable **ppTable)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->BindToObject(IID_IMimeAddressTable, (LPVOID *)ppTable);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetSender
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetSender(LPADDRESSPROPS pAddress)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetSender(pAddress);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetTypes(dwAdrTypes, dwProps, pList);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressFormat
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetFormat(dwAdrType, format, ppszFormat);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAddressFormatW
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAddressFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppszFormat)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetFormatW(dwAdrType, format, ppszFormat);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::EnumAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::EnumAddressTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->EnumTypes(dwAdrTypes, dwProps, ppEnum);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrGetTextTypeInfo
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrGetTextTypeInfo(DWORD dwTxtType, LPTEXTTYPEINFO *ppTextInfo)
{
    // Invalid Arg
    Assert(ppTextInfo);

    // Init
    *ppTextInfo = NULL;

    // Locate the text type
    for (ULONG i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
    {
        // Desired Text Type
        if (g_rgTextInfo[i].dwTxtType == dwTxtType)
        {
            // Found It
            *ppTextInfo = (LPTEXTTYPEINFO)&g_rgTextInfo[i];
            return S_OK;
        }
    }

    // Un-identified text type
    if (NULL == *ppTextInfo)
        return TrapError(MIME_E_INVALID_TEXT_TYPE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_FindDisplayableTextBody
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_FindDisplayableTextBody(LPCSTR pszSubType, 
    LPTREENODEINFO pNode, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cBodies;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(pNode && phBody && pszSubType && NULL == *phBody);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            hr = _FindDisplayableTextBody(pszSubType, pChild, phBody);

            // Done ?
            if (SUCCEEDED(hr))
            {
                Assert(*phBody);
                goto exit;
            }
        }
    }

    // Otherwise...
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, pszSubType))
    {
        // If not an attachment...
        if (S_FALSE == IsBodyType(pNode->hBody, IBT_ATTACHMENT))
        {
            *phBody = pNode->hBody;
            goto exit;
        }

        // Otherwise...Raid 43444: Inbox Direct messages showing as attachments
        else
        {
            // Count Bodies
            CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

            // Only one body...
            if (cBodies == 1)
            {
                // Inline or Disposition is not set
                if (m_pRootNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_INLINE, FALSE, FALSE) == S_OK || 
                    m_pRootNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTDISP)) == S_FALSE)
                {
                    *phBody = pNode->hBody;
                    goto exit;
                }
            }
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageTree::GetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    IStream **ppStream, LPHBODY phBody)
{
    // Locals
    HRESULT              hr=S_OK;
    HRESULT              hrFind;
    LPTEXTTYPEINFO       pTextInfo=NULL;
    FINDBODY             rFind;
    IMimeBody           *pBody=NULL;
    PROPVARIANT          rStart;
    PROPVARIANT          rVariant;
    HBODY                hAlternativeParent;
    HBODY                hFirst=NULL;
    HBODY                hChild;
    HBODY                hBody=NULL;
    HBODY                hRelated;
    LPSTR                pszStartCID=NULL;
    BOOL                 fMarkRendered=TRUE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;
    if (ppStream)
        *ppStream = NULL;

    // Init
    MimeOleVariantInit(&rStart);

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // MimeHTML
    if (SUCCEEDED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
    {
        // Get start= parameter
        if (SUCCEEDED(GetBodyProp(hRelated, STR_PAR_START, 0, &rStart)))
        {
            // Raid 63823: Mail : Content-Location Href's inside the message do not work if there is a Start Parameter in headers
            //             The start parameter can only specify a CID.     

            // I need to prefix cid: onto the front of rStart
            CHECKALLOC(pszStartCID = PszAllocA(lstrlen(rStart.pszVal) + lstrlen(c_szCID) + 1));

            // Format the CID
            wsprintf(pszStartCID, "%s%s", c_szCID, rStart.pszVal);

            // Resolve this URL
            ResolveURL(hRelated, NULL, pszStartCID, URL_RESULVE_NO_BASE, &hBody);
        }
    }

    // Still haven't found a text body ?
    if (NULL == hBody)
    {
        // FindTextBody
        hr = _FindDisplayableTextBody(pTextInfo->pszSubType, m_pRootNode, &hBody);

        // If that failed and we were looking for html, try to get enriched text...
        if (FAILED(hr) && ISFLAGSET(dwTxtType, TXT_HTML))
        {
            // Looking for text/html, lets try to find text/enriched
            hr = _FindDisplayableTextBody(STR_SUB_ENRICHED, m_pRootNode, &hBody);
        }

        // Not Found
        if (FAILED(hr))
        {
            hr = TrapError(MIME_E_NOT_FOUND);
            goto exit;
        }

        // Reset hr
        hr = S_OK;
    }

    // Get the stream...
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If Empty...
    if (pBody->IsType(IBT_EMPTY) == S_OK)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // User Wants the Data
    if (ppStream)
    {
        // If content-type is text/enriched, convert to html
        if (pBody->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED) == S_OK)
        {
            // Better be asking for html
            Assert(ISFLAGSET(dwTxtType, TXT_HTML));

            // Do the Conversion
            CHECKHR(hr = MimeOleConvertEnrichedToHTMLEx(pBody, ietEncoding, ppStream));
        }

        // Otherwise, non-text enriched case
        else
        {
            // Get Data
            CHECKHR(hr = pBody->GetData(ietEncoding, ppStream));
        }
    }

    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_OE5))
    {
        // If there is no stream requested, then don't mark rendered
        if (NULL == ppStream)
        {
            // Don't Mark Rendered
            fMarkRendered = FALSE;
        }
    }

    // Mark Rendered
    if (fMarkRendered)
    {
        // Rendered
        rVariant.vt = VT_UI4;
        rVariant.ulVal = TRUE;

        // Lets set the resourl flag
        SideAssert(SUCCEEDED(pBody->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

        // Raid-45116: new text attachment contains message body on Communicator inline image message
        if (FAILED(GetBody(IBL_PARENT, hBody, &hAlternativeParent)))
            hAlternativeParent = NULL;

        // Try to find an alternative parent...
        while(hAlternativeParent)
        {
            // If multipart/alternative, were done
            if (IsContentType(hAlternativeParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
                break;

            // Get Next Parent
            if (FAILED(GetBody(IBL_PARENT, hAlternativeParent, &hAlternativeParent)))
                hAlternativeParent = NULL;
        }

        // Get Parent
        if (hAlternativeParent)
        {
            // Resolve all first level children
            hrFind = GetBody(IBL_FIRST, hAlternativeParent, &hChild);
            while(SUCCEEDED(hrFind) && hChild)
            {
                // Set Resolve Property
                SideAssert(SUCCEEDED(SetBodyProp(hChild, PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

                // Find Next
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }
        }
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody); 
    SafeMemFree(pszStartCID);
    MimeOleVariantFree(&rStart);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    HBODY hAlternative, IStream *pStream, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    HBODY           hRoot,
                    hBody,
                    hTextBody=NULL,
                    hSection,
                    hParent,
                    hPrevious, 
                    hInsertAfter;
    LPTEXTTYPEINFO  pTextInfo=NULL;
    BOOL            fFound,
                    fFoundInsertLocation;
    DWORD           dwWeightBody;
    ULONG           i;
    IMimeBody      *pBody=NULL;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Debug Dump
    // DebugDumpTree("SetTextBody", TRUE);

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // Raid-45369: message from Eudora Pro comes in .txt attachment which is lost when forwarded.
    // If hAlternative is NULL, then this means that the client wants to replace all text bodies
    // with this new text body. If hAlternative is not NULL, then the client has already inserted
    // a text body and created a alternative section, no more deleting.
    if (NULL == hAlternative)
    {
        // Loop through the text type
        for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
        {
            // Get the Current Text Body Associated with this type
            if (SUCCEEDED(GetTextBody(g_rgTextInfo[i].dwTxtType, IET_BINARY, NULL, &hBody)))
            {
                // If the parent of hBody is an alternative section, delete the alternative
                if (SUCCEEDED(GetBody(IBL_PARENT, hBody, &hParent)) && IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
                {
                    // Delete multipart/alternative
                    hBody = hParent;
                }

                // Not if hBody is equal to hAlternative
                if (hBody != hAlternative)
                {
                    // Locals
                    HRESULT     hrFind;
                    HBODY       hFind;

                    // Raid-54277: Mail : Inline replying losses inline images sent from Nav4 using Plain text & HTML format
                    hrFind = GetBody(IBL_FIRST, hBody, &hFind);
                    while(SUCCEEDED(hrFind) && hFind)
                    {
                        // If not a multipart/related, delete it
                        if (S_FALSE == IsContentType(hFind, STR_CNT_MULTIPART, STR_SUB_RELATED))
                        {
                            // Delete this body
                            CHECKHR(hr = DeleteBody(hFind, 0));

                            // Use the hPrevious
                            hrFind = GetBody(IBL_FIRST, hBody, &hFind);
                        }

                        // Get Next
                        else
                        {
                            // Find Next
                            hrFind = GetBody(IBL_NEXT, hFind, &hFind);
                        }
                    }

                    // Delete the multipart/alternative section, promoting any multipart/related section
                    CHECKHR(hr = DeleteBody(hBody, DELETE_PROMOTE_CHILDREN));

                    // Done
                    break;
                }
            }
        }
    }

    // Get Root
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // If only one body..
    if (IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Just use the root
        hTextBody = hRoot;
    }

    // Otherwise, if not inserting an alternative body, we must need a multipart/mixed or multipart/related section
    else if (NULL == hAlternative)
    {
        // Better not be an alternative section
        Assert(FAILED(MimeOleGetAlternativeSection(this, &hSection, NULL)));

        // If there is a related section use it
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hSection, NULL)))
        {
            // Find or Create a multipart/mixed section
            CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
        }

        // Insert an element at the head of this section...
        CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
    }

    // Otherwise, if inserting an alternative body
    else if (hAlternative != NULL)
    {
        // Verify pBody is STR_CNT_TEXT
        Assert(IsContentType(hAlternative, STR_CNT_TEXT, NULL) == S_OK);

        // Get hAlternative's parent
        if (FAILED(GetBody(IBL_PARENT, hAlternative, &hParent)))
            hParent = NULL;

        // If hAlternative is the root
        if (hRoot == hAlternative || NULL == hParent || IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_FALSE)
        {
            // Convert this body to a multipart/alternative
            CHECKHR(hr = ToMultipart(hAlternative, STR_SUB_ALTERNATIVE, &hSection));
        }

        // Otherwise, hSection is equal to hParent
        else
            hSection = hParent;

        // We better have an alternative section now...
        Assert(IsContentType(hSection, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK);

        // Init Search
        hPrevious = NULL;
        fFound = FALSE;
        fFoundInsertLocation = FALSE;
        dwWeightBody = 0;
        hInsertAfter = NULL;

        // Lets enum the children of rLayout.hAlternative and verify that hAlternative is still a child...and decide what alternative body to insert after
        hrFind = GetBody(IBL_FIRST, hSection, &hBody);
        while(SUCCEEDED(hrFind) && hBody)
        {
            // Default dwWeightBody
            dwWeightBody = 0xffffffff;

            // Get Weight of hBody
            for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
            {
                // Compare Content Type
                if (IsContentType(hBody, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                {
                    dwWeightBody = g_rgTextInfo[i].dwWeight;
                    break;
                }
            }

            // Get Alternative Weight of the body we are inserting
            if (pTextInfo->dwWeight <= dwWeightBody && FALSE == fFoundInsertLocation)
            {
                fFoundInsertLocation = TRUE;
                hInsertAfter = hPrevious;
            }

            // Is this the alternative brother...
            if (hAlternative == hBody)
                fFound = TRUE;

            // Set hPrev
            hPrevious = hBody;

            // Find Next
            hrFind = GetBody(IBL_NEXT, hBody, &hBody);
        }

        // If we didn't find hAlternative, we're hosed
        if (FALSE == fFound)
        {
            Assert(FALSE);
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // If no after was found... insert first..
        if (NULL == hInsertAfter)
        {
            // BODY_LAST_CHILD
            if (pTextInfo->dwWeight > dwWeightBody)
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hTextBody));
            }

            // BODY_FIRST_CHILD
            else
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
            }
        }

        // Otherwise insert after hInsertAfter
        else
        {
            // Insert a new body...
            CHECKHR(hr = InsertBody(IBL_NEXT, hInsertAfter, &hTextBody));
        }
    }

    // Open the object
    Assert(hTextBody);
    CHECKHR(hr = BindToObject(hTextBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set the root...
    CHECKHR(hr = pBody->SetData(ietEncoding, STR_CNT_TEXT, pTextInfo->pszSubType, IID_IStream, (LPVOID)pStream));

    // Release This
    SafeRelease(pBody);

    // Set multipart/related; type=...
    if (SUCCEEDED(GetBody(IBL_PARENT, hTextBody, &hParent)))
    {
        // If parent is multipart/related, set type
        if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
        {
            // Get Parent
            CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

            // type = text/plain
            if (ISFLAGSET(dwTxtType, TXT_PLAIN))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }

            // type = text/plain
            else if (ISFLAGSET(dwTxtType, TXT_HTML))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_HTML;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }
            else
                AssertSz(FALSE, "UnKnown dwTxtType passed to IMimeMessage::SetTextBody");
        }

        // Otherwise, if hParent is multipart/alternative
        else if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Set multipart/related; type=...
            if (SUCCEEDED(GetBody(IBL_PARENT, hParent, &hParent)))
            {
                // If parent is multipart/related, set type
                if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
                {
                    // Get Parent
                    CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

                    // Setup Variant
                    rVariant.vt = VT_LPSTR;
                    rVariant.pszVal = (LPSTR)STR_MIME_MPART_ALT;

                    // Set the Properyt
                    CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
                }
            }
        }
    }

    // Set body handle
    if (phBody)
        *phBody = hTextBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AttachObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachObject(REFIID riid, void *pvObject, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody,
                    hMixed;
    IMimeBody      *pBody=NULL;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pvObject || FALSE == FBODYSETDATAIID(riid))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Get Mixed Section
    CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hMixed, NULL));

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hMixed, &hBody));

    // Bind to the Body Object
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set Data Object
    CHECKHR(hr = pBody->SetData(IET_INETCSET, NULL, NULL, riid, pvObject));

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)STR_DIS_ATTACHMENT;

    // Mark as Attachment
    CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTDISP), 0, &rVariant));

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AttachFile
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachFile(LPCSTR pszFilePath, IStream *pstmFile, LPHBODY phBody)
{
    LPWSTR  pwszFilePath;
    HRESULT hr = S_OK;

    IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, pszFilePath));

    IF_FAILEXIT(hr = AttachFileW(pwszFilePath, pstmFile, phBody));

exit:
    MemFree(pwszFilePath);

    return hr;
}

STDMETHODIMP CMessageTree::AttachFileW(LPCWSTR pszFilePath, IStream *pstmFile, LPHBODY phBody)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmTemp=NULL;
    LPWSTR      pszCntType=NULL,
                pszSubType=NULL,
                pszFName=NULL;
    HBODY       hBody;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Did the user give me a file stream
    if (NULL == pstmFile)
    {
        // Get File Stream
        CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFilePath, OPEN_EXISTING, GENERIC_READ, &pstmTemp));

        // Set The File Stream
        pstmFile = pstmTemp;
    }

    // Attach as object
    CHECKHR(hr = AttachObject(IID_IStream, (LPVOID)pstmFile, &hBody));

    // Get mime file info
    hr = MimeOleGetFileInfoW((LPWSTR)pszFilePath, &pszCntType, &pszSubType, NULL, &pszFName, NULL);

    // Failure
    if (FAILED(hr) && NULL == pszFName)
    {
        Assert(FALSE);
        hr = TrapError(hr);
        goto exit;
    }

    // Success
    hr = S_OK;

    // Attachment FileName
    if (pszFName)
    {
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszFName;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_FILENAME), 0, &rVariant));
    }

    // ContentType
    if (pszCntType && pszSubType)
    {
        // PriType
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszCntType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_PRITYPE), 0, &rVariant));

        // SubType
        rVariant.vt = VT_LPWSTR;
        rVariant.pwszVal = pszSubType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_SUBTYPE), 0, &rVariant));
    }

    // Otherwise, default content type
    else
    {
        // Default to text/plain
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    ReleaseObj(pstmTemp);
    MemFree(pszCntType);
    MemFree(pszSubType);
    MemFree(pszFName);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    LPHBODY     prghBody=NULL;
    ULONG       cAlloc=0;
    ULONG       cCount=0;
    ULONG       i;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Setup Variant
    rVariant.vt = VT_UI4;

    // Walk through the tree and look for unrendered bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Better have it
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Not a multipart
        if (_IsMultiPart(m_rTree.prgpNode[i]))
            continue;

        // Raid-44193: reply to multipart/digest message yields  text attachment
        if (m_rTree.prgpNode[i]->pBody->IsType(IBT_EMPTY) == S_OK)
            continue;

        // Raid-56665: We are showing tnef attachments again
        if (TRUE == m_rOptions.fHideTnef && S_OK == m_rTree.prgpNode[i]->pBody->IsContentType(STR_CNT_APPLICATION, STR_SUB_MSTNEF))
            continue;

        // an attachment shows up in the attachment well if it has NOT been rendered yet, OR it has been renderd but was auto inlined
        // eg: if (!r || a) (as a implies r)

        if ( (!(m_rTree.prgpNode[i]->pContainer->GetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant) == S_OK && TRUE == rVariant.ulVal)) ||
             (m_rTree.prgpNode[i]->pContainer->GetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)==S_OK && TRUE == rVariant.ulVal))
        {
            // Realloc
            if (cCount + 1 > cAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&prghBody, sizeof(HBODY) * (cAlloc + 10)));

                // Increment cAlloc
                cAlloc += 10;
            }

            // Insert the hBody
            prghBody[cCount] = m_rTree.prgpNode[i]->hBody;

            // Increment Count
            cCount++;
        }
    }

    // Done
    *pcAttach = cCount;

    // Return hBody Array
    if (pprghAttach)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }


exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#if 0
// --------------------------------------------------------------------------------
// CMessageTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cBodies;
    LPHBODY     prghBody=NULL;
    HBODY       hRoot;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Count the number of items in the tree
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // No Data
    if (0 == cBodies)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // Get the root body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // Allocate an array that can old the handle to all text items
    CHECKALLOC(prghBody = (LPHBODY)g_pMalloc->Alloc(sizeof(HBODY) * cBodies));

    // Zero Init
    ZeroMemory(prghBody, sizeof(HBODY) * cBodies);

    // Get Content
    CHECKHR(hr = _HrEnumeratAttachments(hRoot, pcAttach, prghBody));

    // Return this array
    if (pprghAttach && *pcAttach > 0)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }

exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrEnumeratAttachments
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrEnumeratAttachments(HBODY hBody, ULONG *pcBodies, LPHBODY prghBody)
{
    // Locals
    HRESULT     hr=S_OK,
                hrFind;
    HBODY       hChild;
    ULONG       i;

    // multipart/alternative
    if (IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Is Alternative
        if (IsContentType(hBody, NULL, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Get First Child
            hrFind = GetBody(IBL_FIRST, hBody, &hChild);
            while(SUCCEEDED(hrFind) && NULL != hChild)
            {
                // If this text type is support by the client, then 
                for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
                {
                    // text/XXXX
                    if (IsContentType(hChild, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                        goto exit;
                }

                // Next Child
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }
        }

        // Get First Child
        hrFind = GetBody(IBL_FIRST, hBody, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Bind the body table for this dude
            CHECKHR(hr = _HrEnumeratAttachments(hChild, pcBodies, prghBody));

            // Next Child
            hrFind = GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Otherwise, is it an attachment
    else if (IsBodyType(hBody, IBT_ATTACHMENT) == S_OK)
    {
        // Insert as an attachment
        prghBody[(*pcBodies)] = hBody;
        (*pcBodies)++;
    }

exit:
    // Done
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// CMessageTree::AttachURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::AttachURL(LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, 
    IStream *pstmURL, LPSTR *ppszCIDURL, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    HBODY             hRoot,
                      hBody=NULL,
                      hSection;
    CHAR              szCID[CCHMAX_CID];
    LPSTR             pszFree=NULL;
    LPSTR             pszBaseFree=NULL;
    IMimeBody        *pBody=NULL;
    LPWSTR            pwszUrl=NULL;
    IMimeWebDocument *pWebDocument=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the Root Body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // multipart/mixed
    if (ISFLAGSET(dwFlags, URL_ATTACH_INTO_MIXED))
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
    }

    // multipart/related
    else
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetRelatedSection(this, TRUE, &hSection, NULL));
    }

    // Get Default Base
    if (NULL == pszBase && SUCCEEDED(MimeOleComputeContentBase(this, hSection, &pszBaseFree, NULL)))
        pszBase = pszBaseFree;

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hBody));

    // Bind to IMimeBody
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If I have a stream
    if (pstmURL)
    {
        // Set the data
        CHECKHR(hr = pBody->SetData(IET_INETCSET, NULL, NULL, IID_IStream, (LPVOID)pstmURL));
    }

    // Otherwise, Set the content type
    else
    {
        // Create a WebDocument
        CHECKHR(hr = MimeOleCreateWebDocument(pszBase, pszURL, &pWebDocument));

        // Set Web Document on the body object
        CHECKHR(hr = pBody->SetData(IET_BINARY, NULL, NULL, IID_IMimeWebDocument, (LPVOID)pWebDocument));
    }

    // URL_ATTACH_SET_CNTTYPE
    if (ISFLAGSET(dwFlags, URL_ATTACH_SET_CNTTYPE))
    {
        // Locals
        LPSTR pszCntType=(LPSTR)STR_MIME_APPL_STREAM;
        PROPVARIANT rVariant;

        // Get the Content Type from the Url
        if (SUCCEEDED(MimeOleContentTypeFromUrl(pszBase, pszURL, &pszFree)))
            pszCntType = pszFree;

        // Setup the Variant
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszCntType;

        // Set the Content Type
        CHECKHR(hr = pBody->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Set Content-Base
    if (pszBase && pszBase != pszBaseFree)
    {
        // Set Base
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTBASE), 0, pszBase));
    }

    // User Wants a CID: URL Back
    if (ISFLAGSET(dwFlags, URL_ATTACH_GENERATE_CID))
    {
        // Generate CID
        CHECKHR(hr = MimeOleGenerateCID(szCID, CCHMAX_CID, FALSE));

        // Set the Body Property
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTID), 0, szCID));

        // User Wants CID Back...
        if (ppszCIDURL)
            {
            CHECKALLOC(MemAlloc((LPVOID *)ppszCIDURL, lstrlen(szCID) + 5));
            lstrcpy(*ppszCIDURL, "cid:");
            lstrcat(*ppszCIDURL, szCID);
            }
    }
    else
    {
        if (pszURL)
            // Setup Content-Location
            CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTLOC), 0, pszURL));
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszBaseFree);
    SafeMemFree(pwszUrl);
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CMessageTree::AttachURLW(LPCWSTR pwszBase, LPCWSTR pwszURL, DWORD dwFlags, 
    IStream *pstmURL, LPWSTR *ppwszCIDURL, LPHBODY phBody)
{
    return TraceResult(E_NOTIMPL);
}

STDMETHODIMP CMessageTree::ResolveURLW(HBODY hRelated, LPCWSTR pwszBase, LPCWSTR pwszURL, 
                                       DWORD dwFlags, LPHBODY phBody)
{
    return TraceResult(E_NOTIMPL);
}



// --------------------------------------------------------------------------------
// CMessageTree::SplitMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::SplitMessage(ULONG cbMaxPart, IMimeMessageParts **ppParts)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = MimeOleSplitMessage(this, cbMaxPart, ppParts);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::EnumFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFormat=0;
    DATAOBJINFO     rgFormat[CFORMATS_IDATAOBJECT];
    ULONG           cBodies;
    IEnumFORMATETC *pEnum=NULL;
    DWORD           dwFlags;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);
    if (DATADIR_SET == dwDirection)
        return TrapError(E_NOTIMPL);
    else if (DATADIR_GET != dwDirection)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // No Data...
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // If there are bodies...
    if (cBodies)
    {
        // I can always give CF_INETMSG now...
        SETDefFormatEtc(rgFormat[cFormat].fe, CF_INETMSG, TYMED_ISTREAM |  TYMED_HGLOBAL);
        cFormat++;

        // Get Some Flags
        dwFlags = DwGetFlags();

        // Get the HTML body stream
        if (ISFLAGSET(dwFlags, IMF_HTML))
        {
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_HTML, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }

        // Get the TEXT body stream
        if (ISFLAGSET(dwFlags, IMF_PLAIN))
        {
            // Unicode Text
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_UNICODETEXT, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;

            // Plain Text
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_TEXT, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }
    }

    // Create the enumerator
    CHECKHR(hr = CreateEnumFormatEtc(GetInner(), cFormat, rgFormat, NULL, &pEnum));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();
    
exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetCanonicalFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetCanonicalFormatEtc(FORMATETC *pFormatIn, FORMATETC *pFormatOut)
{
    // E_INVALIDARG
    if (NULL == pFormatOut)
        return E_INVALIDARG;

    // Target device independent
    pFormatOut->ptd = NULL;

    // Done
    return DATA_S_SAMEFORMATETC;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetData(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    BOOL            fFreeGlobal=FALSE;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // Use a fast IStream
        if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;
        pMedium->pstm = pstmData;
        pstmData->AddRef();
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        fFreeGlobal = TRUE;

        // don't have the stream release the global
        if (FAILED(CreateStreamOnHGlobal(NULL, FALSE, &pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }
        
        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Create HGLOBAL from stream
        if (FAILED(GetHGlobalFromStream(pstmData, &pMedium->hGlobal)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;
        // Release the strema
        pstmData->Release();
        pstmData = NULL;
        fFreeGlobal = FALSE;
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    if (pstmData)
    {
        if (fFreeGlobal)
        {
            // we may fail had have to free the hglobal
            HGLOBAL hGlobal;

            // Free the underlying HGLOBAL
            if (SUCCEEDED(GetHGlobalFromStream(pstmData, &hGlobal)))
                GlobalFree(hGlobal);
        }

        // Release the Stream
        pstmData->Release();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetDataHere
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetDataHere(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    ULONG           cb;
    LPVOID          pv=NULL;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // No dest stream...
        if (NULL == pMedium->pstm)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;

        // Get the data
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pMedium->pstm));
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        // No dest stream...
        if (NULL == pMedium->hGlobal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;

        // Create a place to store the data
        if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData));

        // Get Size
        CHECKHR(hr = HrGetStreamSize(pstmData, &cb));

        // Is it big enought ?
        if (cb > GlobalSize(pMedium->hGlobal))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Lock the hglobal
        pv = GlobalLock(pMedium->hGlobal);
        if (NULL == pv)
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Copy the Data
        CHECKHR(hr = HrCopyStreamToByte(pstmData, (LPBYTE)pv, NULL));

        // Unlock it
        GlobalUnlock(pMedium->hGlobal);
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pstmData);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectWriteHeaderA
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectWriteHeaderA(LPSTREAM pStream, UINT idsHeader, LPSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_STRINGRES];

    // Invalid Arg
    Assert(idsHeader && pStream && pszData);

    // Load Localized Header Name
    LoadString(g_hLocRes, idsHeader, szRes, ARRAYSIZE(szRes));

    // Write Header Name
    CHECKHR(hr = pStream->Write(szRes, lstrlen(szRes), NULL));

    // Write space
    CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pszData, lstrlen(pszData), NULL));

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetHeaderA
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetHeaderA(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;

    // Init
    MimeOleVariantInit(&rVariant);

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_FROM, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_TO), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_TO, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CC), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_CC, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_SUBJECT, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_FILETIME;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
    {
        // Locals
        CHAR szDate[CCHMAX_STRINGRES];

        // Convert to user friendly date format
        CchFileTimeToDateTimeSz(&rVariant.filetime, szDate, ARRAYSIZE(szDate), DTM_NOSECONDS | DTM_LONGDATE);

        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderA(pStream, IDS_DATE, szDate));
    }

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectWriteHeaderW
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectWriteHeaderW(LPSTREAM pStream, UINT idsHeader, LPWSTR pwszData)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[CCHMAX_STRINGRES];
    LPWSTR          pwszRes=NULL;

    // Invalid Arg
    Assert(idsHeader && pStream && pwszData);

    // Load Localized Header Name
    LoadString(g_hLocRes, idsHeader, szRes, ARRAYSIZE(szRes));

    // Convert to Unicode
    IF_NULLEXIT(pwszRes = PszToUnicode(CP_ACP, szRes));

    // Write Header Name
    CHECKHR(hr = pStream->Write(pwszRes, (lstrlenW(pwszRes) * sizeof(WCHAR)), NULL));

    // Write space
    CHECKHR(hr = pStream->Write(L": ", (lstrlenW(L": ") * sizeof(WCHAR)), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pwszData, (lstrlenW(pwszData) * sizeof(WCHAR)), NULL));

    // Final CRLF
    CHECKHR(hr = pStream->Write(L"\r\n", (lstrlenW(L"\r\n") * sizeof(WCHAR)), NULL));

exit:
    // Cleanup
    SafeMemFree(pwszRes);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetHeaderW
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetHeaderW(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszDate=NULL;
    PROPVARIANT     rVariant;

    // Init
    MimeOleVariantInit(&rVariant);

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_FROM, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_TO), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_TO, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CC), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_CC, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPWSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_SUBJECT, rVariant.pwszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_FILETIME;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
    {
        // Locals
        WCHAR  wszDate[CCHMAX_STRINGRES];

        // Convert to user friendly date format
        AthFileTimeToDateTimeW(&rVariant.filetime, wszDate, ARRAYSIZE(wszDate), DTM_NOSECONDS | DTM_LONGDATE);

        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeaderW(pStream, IDS_DATE, wszDate));
    }

    // Final CRLF
    CHECKHR(hr = pStream->Write(L"\r\n", (lstrlenW(L"\r\n") * sizeof(WCHAR)), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrDataObjectGetSource
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrDataObjectGetSource(CLIPFORMAT cfFormat, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmSrc=NULL;

    // Invalid Arg
    Assert(pStream);

    // text body
    if (CF_TEXT == cfFormat || CF_UNICODETEXT == cfFormat)
    {
        // Get Plain Text Source
        CHECKHR(hr = GetTextBody(TXT_PLAIN, (cfFormat == CF_UNICODETEXT) ? IET_UNICODE : IET_BINARY, &pstmSrc, NULL));
    }

    // HTML Body
    else if (CF_HTML == cfFormat)
    {
        // Get HTML Text Source
        CHECKHR(hr = GetTextBody(TXT_HTML, IET_INETCSET, &pstmSrc, NULL));
    }

    // Raw Message Stream
    else if (CF_INETMSG == cfFormat)
    {
        // Get source
        CHECKHR(hr = GetMessageSource(&pstmSrc, COMMIT_ONLYIFDIRTY));
    }

    // Format not handled
    else
    {
        hr = DV_E_FORMATETC;
        goto exit;
    }

    // No Data
    if (NULL == pstmSrc)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Rewind Source
    CHECKHR(hr = HrRewindStream(pstmSrc));

    // If TEXT, put in friendly header
    if (CF_TEXT == cfFormat)
    {
        CHECKHR(hr = _HrDataObjectGetHeaderA(pStream));
    }

    // Otherwise, unicode
    else if (CF_UNICODETEXT == cfFormat)
    {
        CHECKHR(hr = _HrDataObjectGetHeaderW(pStream));
    }

    // Copy Source to destination
    CHECKHR(hr = HrCopyStream(pstmSrc, pStream, NULL));

    // Write a NULL
    if (CF_TEXT == cfFormat)
    {
        CHECKHR(hr = pStream->Write(c_szEmpty, 1, NULL));
    }

    // Otherwise, unicode
    else if (CF_UNICODETEXT == cfFormat)
    {
        CHECKHR(hr = pStream->Write(L"", 2, NULL));
    }

    // Commit
    CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

    // Rewind it
    CHECKHR(hr = HrRewindStream(pStream));

exit:
    // Cleanup
    SafeRelease(pstmSrc);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::QueryGetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::QueryGetData(FORMATETC *pFormat)
{
    // Invalid Arg
    if (NULL == pFormat)
        return TrapError(E_INVALIDARG);

    // Bad Medium
    if (!(TYMED_ISTREAM & pFormat->tymed) && !(TYMED_HGLOBAL & pFormat->tymed))
        return DV_E_TYMED;

    // Bad format
    if (CF_TEXT != pFormat->cfFormat && CF_HTML != pFormat->cfFormat &&
        CF_UNICODETEXT  != pFormat->cfFormat && CF_INETMSG != pFormat->cfFormat)
        return DV_E_FORMATETC;

    // Success
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnStartBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnStartBinding(DWORD dwReserved, IBinding *pBinding)
{
    // Locals
    HBODY hBody;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // I Should not have a current binding
    Assert(NULL == m_pBinding);

    // Remove Bind Finished Flag
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // Assume the Binding
    if (pBinding)
    {
        // Assume It
        m_pBinding = pBinding;
        m_pBinding->AddRef();
    }

    // Get the Root Body
    Assert(m_pRootNode);

    // Current Bind Result
    m_hrBind = S_OK;

    // Bind to that object
    m_pBindNode = m_pRootNode;

    // Set Bound Start
    m_pBindNode->boundary = BOUNDARY_ROOT;

    // Set Node Bind State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetPriority
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetPriority(LONG *plPriority)
{
    // Normal Priority
    *plPriority = THREAD_PRIORITY_NORMAL;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnLowResource
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnLowResource(DWORD reserved)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a binding operation, try to abort it
    if (m_pBinding)
        m_pBinding->Abort();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText)
{
    // Debuging
    //DebugTrace("CMessageTree::OnProgress - %d of %d Bytes\n", ulProgress, ulProgressMax);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnStopBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnStopBinding(HRESULT hrResult, LPCWSTR pszError)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release the Binding Object
    SafeRelease(m_pBinding);

    // Bind Finished
    FLAGSET(m_dwState, TREESTATE_BINDDONE);

    // Nuke the no cache flag....
    FLAGCLEAR(m_dwState, TREESTATE_RESYNCHRONIZE);

    // No m_pInternet Object ?
    if (NULL == m_pInternet)
    {
        m_hrBind = TrapError(E_FAIL);
        goto exit;
    }

    // It must be fully available
    m_pInternet->SetFullyAvailable(TRUE);

    // Make sure we have read all the way to the end of the stream
    m_pInternet->HrReadToEnd();

    // Keep Saving Total
    m_cbMessage = m_pInternet->DwGetOffset();

#ifdef DEBUG
    STATSTG rStat;
    SideAssert(SUCCEEDED(m_pStmLock->Stat(&rStat, STATFLAG_NONAME)));
    if (rStat.cbSize.QuadPart != m_cbMessage)
        DebugTrace("CMessageTree Size Difference m_pStmLock::Stat = %d, m_cbMessage = %d\n", rStat.cbSize.QuadPart, m_cbMessage);
#endif

    // Terminate current parsing state
    if (m_pBindNode)
    {
        // Set Error
        if (SUCCEEDED(m_hrBind))
            m_hrBind = TrapError(E_FAIL);

        // Mark remaining bodies as incomplete
        while(m_pBindNode)
        {
            // Must not be complete
            FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

            // Must not have found the end
            Assert(0 == m_pBindNode->cbBodyEnd);

            // cbBodyEnd
            m_pBindNode->cbBodyEnd = m_cbMessage;

            // Pop the stack
            m_pBindNode = m_pBindNode->pBindParent;
        }
    }

    // Check hrResult
    if (FAILED(hrResult) && SUCCEEDED(m_hrBind))
        m_hrBind = hrResult;

    // DispatchBindRequest
    _HrProcessPendingUrlRequests();

    // Tell the webpage that we are done
    if (m_pWebPage)
    {
        m_pWebPage->OnBindComplete(this);
        m_pWebPage->Release();
        m_pWebPage = NULL;
    }

    // Bind Node Better be Null
    m_pBindNode = NULL;

    // Release the Internet Stream Object
    SafeRelease(m_pInternet);

    // If we have a bind stream...
    if (m_pStmBind)
    {
#ifdef DEBUG
        // m_pStmBind->DebugDumpDestStream("d:\\binddst.txt");
#endif
        // Get hands off source
        m_pStmBind->HandsOffSource();

        // Release, m_pStmLock should still have this object
        SideAssert(m_pStmBind->Release() > 0);

        // Don't release it again
        m_pStmBind = NULL;
    }

    // HandleCanInlineTextOption
    _HandleCanInlineTextOption();

exit:
    if (m_pBC)
        {
        // we only regiser our own bscb is m_pbc is set
        RevokeBindStatusCallback(m_pBC, (IBindStatusCallback *)this);
        SafeRelease(m_pBC);
        }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return m_hrBind;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetBindInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::GetBindInfo(DWORD *grfBINDF, BINDINFO *pBindInfo)
{
    // Setup the BindInfo
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;

    // No CACHE?
    if (ISFLAGSET(m_dwState, TREESTATE_RESYNCHRONIZE))
    {
        // Don't load from cache
        FLAGSET(*grfBINDF, BINDF_RESYNCHRONIZE);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrInitializeStorage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrInitializeStorage(IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwOffset;

    // Invalid Arg
    Assert(pStream && NULL == m_pInternet && NULL == m_pStmLock && NULL == m_pStmBind);

    // TREESTATE_BINDUSEFILE
    if (ISFLAGSET(m_dwState, TREESTATE_BINDUSEFILE))
    {
        // Create a Binding Stream
        CHECKALLOC(m_pStmBind = new CBindStream(pStream));

        // Set pStmSource
        pStream = (IStream *)m_pStmBind;
    }

    // $$BUGBUG$$ Urlmon fails on getting the current position of a stream
    if (FAILED(HrGetStreamPos(pStream, &dwOffset)))
        dwOffset = 0;

    // Create a ILockBytes
    CHECKALLOC(m_pStmLock = new CStreamLockBytes(pStream));

    // Create a Text Stream
    CHECKALLOC(m_pInternet = new CInternetStream);

    // Initialize the TextStream
    m_pInternet->InitNew(dwOffset, m_pStmLock);

exit:
    // Failure
    if (FAILED(hr))
    {
        SafeRelease(m_pStmLock);
        SafeRelease(m_pInternet);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::OnDataAvailable
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageTree::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;

    // No Storage Medium
    if (NULL == pMedium || TYMED_ISTREAM != pMedium->tymed || NULL == pMedium->pstm)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Trace
    // DebugTrace("CMessageTree::OnDataAvailable - Nodes=%d, m_pBindNode=%0x, dwSize = %d\n", m_rTree.cNodes, m_pBindNode, dwSize);

    // Do I have an internal lock bytes yet ?
    if (NULL == m_pStmLock)
    {
        // InitializeStorage
        CHECKHR(hr = _HrInitializeStorage(pMedium->pstm));

        // Assume not fully available
        if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
            m_pInternet->SetFullyAvailable(TRUE);
        else
            m_pInternet->SetFullyAvailable(FALSE);
    }

    // Done downloading the data
    else if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
        m_pInternet->SetFullyAvailable(TRUE);

    // If we are in a failed read state
    if (SUCCEEDED(m_hrBind))
    {
        // State Pumper
        while(m_pBindNode)
        {
            // Execute current - could return E_PENDING
            hr = ((this->*m_rgBindStates[m_pBindNode->bindstate])());

            // Failure
            if (FAILED(hr))
            {
                // E_PENDING
                if (E_PENDING == hr)
                    goto exit;

                // Otherwise, set m_hrBind
                m_hrBind = hr;

                // Done
                break;
            }
        }
    }

    // If m_hrBind has failed, read until endof stream
    if (FAILED(m_hrBind))
    {
        // Read to the end of the internet stream
        CHECKHR(hr = m_pInternet->HrReadToEnd());
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindParsingHeader
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindParsingHeader(void)
{
    // Locals
    HRESULT     hr=S_OK;
    MIMEVARIANT rVariant;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_PARSING_HEADER, FALSE);

    // Load the Current Body with the header
    CHECKHR(hr = m_pBindNode->pContainer->Load(m_pInternet));

    // End of the Header
    m_pBindNode->cbBodyStart = m_pInternet->DwGetOffset();

    // Multipart ?
    if (_IsMultiPart(m_pBindNode))
    {
        // Setup the variant
        rVariant.type = MVT_STRINGA;

        // Get the boundary String
        hr = m_pBindNode->pContainer->GetProp(SYM_PAR_BOUNDARY, 0, &rVariant);

        // Raid-63150: Athena version 1 MSN issue:  unable to download messages from SCSPromo
        if (FAILED(hr))
        {
            // Incomplete Body
            FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

            // Convert to a text part only if we read more than two bytes from body start
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);

            // Boundary Mismatch
            hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

            // Done
            goto exit;
        }

        // Set PropStringA
        m_pBindNode->rBoundary.pszVal = rVariant.rStringA.pszVal;
        m_pBindNode->rBoundary.cchVal = rVariant.rStringA.cchVal;

        // Free this boundary later
        FLAGCLEAR(m_pBindNode->dwState, NODESTATE_BOUNDNOFREE);

        // Modify Bind Parser State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }

    // Otherwise
    else
    {
        // Message In a Message
        if (m_pBindNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
        {
            // We are parsing a message attachment
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // Otherwise, if parent and parent is a multipart/digest
        else if (m_pBindNode->pParent && m_pBindNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK &&
                 m_pBindNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTTYPE)) == S_FALSE)
        {
            // Change the Content Type
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822);

            // This is a message
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // If parsing a body inside of a parent multipart section
        if (m_pBindNode->pParent && !ISFLAGSET(m_pBindNode->pParent->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Find Next Mime Part
            m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;
        }

        // Otherwise, Reading Body and Looking for a uuencode begin boundary
        else
        {
            // Parse the RFC1154 header
            _DecodeRfc1154();

            if (m_pBT1154)
            {
                HBODY hBody;

                // This is an RFC1154 message.  We convert the root node
                // to a multi-part, and create a new node for the first
                // of the body parts.
                Assert(m_pBindNode == m_pRootNode);
                m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
                m_pBindNode->cbBodyEnd = m_pBindNode->cbBodyStart;
                FLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART);
                FLAGSET(m_pBindNode->dwType, NODETYPE_RFC1154_ROOT);
                CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));
                CHECKHR(hr = InsertBody(IBL_LAST,m_pBindNode->hBody,&hBody));
                m_pBindNode = _PNodeFromHBody(hBody);
                m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
            }
            else
            {
                // Search for nested uuencoded block of data
                m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrOnFoundNodeEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrOnFoundNodeEnd(DWORD cbBoundaryStart, HRESULT hrBind /* =S_OK */)
{
    // Locals
    HRESULT hr =S_OK;

    // Compute the real body end
    if (cbBoundaryStart < 2 || cbBoundaryStart == m_pBindNode->cbBodyStart)
        m_pBindNode->cbBodyEnd = m_pBindNode->cbBodyStart;
    else
        m_pBindNode->cbBodyEnd = cbBoundaryStart - 2;

    // This node is finished binding
    CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, hrBind));

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrOnFoundMultipartEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrOnFoundMultipartEnd(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Set m_pBindNode which is a multipart, end
    m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

    // This node is finished binding
    CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

    // Finished with the multipart, pop it off the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // If I still have a bind node, it should now be looking for a mime first boundary
    if (m_pBindNode)
    {
        // New Bind State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingMimeFirst
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingMimeFirst(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMEFIRST, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Is MimeBoundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // BOUNDARY_MIMENEXT
    if (BOUNDARY_MIMENEXT == boundary)
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

    // RAID-38241: Mail:  some attached files not getting parsed from Communicator to OE
    // RAID-31255: multipart/mixed with single child which is multipart/alternative
    else if (BOUNDARY_MIMEEND == boundary)
    {
        // Finished with a multipart
        if (_IsMultiPart(m_pBindNode))
        {
            // Done
            CHECKHR(hr = _HrOnFoundMultipartEnd());
        }

        // Found end of current node
        else
        {
            // Done
            CHECKHR(hr = _HrOnFoundNodeEnd(cbBoundaryStart));
        }
    }

    else
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Get Offset
        DWORD dwOffset = m_pInternet->DwGetOffset();

        // Convert to a text part only if we read more than two bytes from body start
        if (dwOffset > m_pBindNode->cbBodyStart && dwOffset - m_pBindNode->cbBodyStart > 2)
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _HrOnFoundNodeEnd(dwOffset, hr);

        // Done
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrMultipartMimeNext
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrMultipartMimeNext(DWORD cbBoundaryStart)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody;
    LPTREENODEINFO  pChild;

    // Get the Root Body
    CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

    // Bind to that object
    pChild = _PNodeFromHBody(hBody);

    // Align the stack correctly
    pChild->pBindParent = m_pBindNode;

    // Setup Offset Information
    pChild->boundary = BOUNDARY_MIMENEXT;
    pChild->cbBoundaryStart = cbBoundaryStart;
    pChild->cbHeaderStart = m_pInternet->DwGetOffset();

    // Assume the Boundary
    pChild->rBoundary.pszVal = m_pBindNode->rBoundary.pszVal;
    pChild->rBoundary.cchVal = m_pBindNode->rBoundary.cchVal;

    // Don't Free this string...
    FLAGSET(pChild->dwState, NODESTATE_BOUNDNOFREE);

    // New State for parent
    m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;

    // Set New Current Node
    m_pBindNode = pChild;

    // Change State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingMimeNext
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingMimeNext(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMENEXT, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Next or Ending Mime Boundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // Not found
    if (BOUNDARY_NONE == boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _HrOnFoundNodeEnd(m_pInternet->DwGetOffset(), hr);

        // Done
        goto exit;
    }

    // Compute Ending Offset
    CHECKHR(hr = _HrOnFoundNodeEnd(cbBoundaryStart));
   
    // If BOUNDARY_MIMEEND
    if (BOUNDARY_MIMEEND == boundary)
    {
        // OnFoundMultipartEnd
        CHECKHR(hr = _HrOnFoundMultipartEnd());
    }

    // BOUNDARY_MIMENEXT
    else
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// _FIsUuencodeEnd
// --------------------------------------------------------------------------------
BOOL _FIsUuencodeEnd(LPCSTR pszVal)
{

    // UU Encode End
    if (StrCmpN(pszVal, "end", 3) == 0)
    {

        // Skip the first three chars
        pszVal += 3;

        // Make sure there is only space after the word end
        while (*pszVal)
        {
            // LWSP or CRLF
            if (' ' != *pszVal && '\t' != *pszVal && chCR != *pszVal && chLF != *pszVal)
            {
                // Oops, this isn't the end
                return (FALSE);

                // Done
                break;
            }

            // Next Char
            pszVal++;
        }
        return (TRUE);
    }
    return (FALSE);
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindRfc1154
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindRfc1154(void)
{
    static CHAR szBINHEXSTART[] = "(This file must be converted with BinHex";
    HRESULT         hr=S_OK;
    ULONG           cbThisLine;
    PROPSTRINGA     rLine;
    BT1154BODY     *pCurrBody;
    ULONG           cbLastLine=0;

    BINDASSERTARGS(BINDSTATE_PARSING_RFC1154, FALSE);
    Assert(m_pBT1154 != NULL);
    Assert(m_pBT1154->cBodies > m_pBT1154->cCurrentBody);

    pCurrBody = &m_pBT1154->aBody[m_pBT1154->cCurrentBody];
    Assert((BT1154ENC_MINIMUM <= pCurrBody->encEncoding) &&
           (BT1154ENC_MAXIMUM >= pCurrBody->encEncoding));

    // Sit and Spin
    while (1)
    {
        // Get the current offset, and read a line
        cbThisLine = m_pInternet->DwGetOffset();
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        if (0 == m_pBT1154->cCurrentLine)
        {
            // This is the first line in the body.
            m_pBindNode->cbBoundaryStart = cbThisLine;
            m_pBindNode->cbHeaderStart = cbThisLine;
            switch (pCurrBody->encEncoding)
            {
                case BT1154ENC_TEXT:
                    // For a TEXT body, the "body start" and the "boundary start"
                    // are the same thing.
                    m_pBindNode->cbBodyStart = cbThisLine;
                    m_pBindNode->boundary = BOUNDARY_NONE;
                    _HrComputeDefaultContent(m_pBindNode,NULL);
                    break;

                case BT1154ENC_UUENCODE:
                    // This is UUENCODE - we won't know the "content type" until we
                    // see the filename.
                    m_pBindNode->boundary = BOUNDARY_UUBEGIN;
                    break;

                case BT1154ENC_BINHEX:
                    // For a BINHEX body, we set the "body start" and "boundary start"
                    // to the same thing - the "body start" will be set forward later
                    // if we see the BINHEX start line.  We set the "content disposition"
                    // to "attachment", the "content type" to be "application/mac-binhex40",
                    // and HrBindNodeComplete will end up setting the "content transfer
                    // encoding" to "mac-binhex40".
                    m_pBindNode->cbBodyStart = cbThisLine;
                    m_pBindNode->boundary = BOUNDARY_NONE;
                    FLAGSET(m_pBindNode->dwType,NODETYPE_RFC1154_BINHEX);
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTDISP, STR_DIS_ATTACHMENT));
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), STR_CNT_APPLICATION));
                    CHECKHR(hr = m_pBindNode->pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), STR_SUB_BINHEX));
                    break;

                default:
                    AssertSz(FALSE,"Unknown encoding type.");
                    break;
            }
        }

        if (0 == rLine.cchVal)
        {
            // Zero bytes read, we're done
            if ((pCurrBody->cLines != 0xffffffff) &&
                (m_pBT1154->cCurrentLine+1 <= pCurrBody->cLines))
            {
                // We weren't in the special "read as many lines as
                // we can" state, and we haven't consumed all of
                // the lines yet for this body part.  So, we need to
                // go into the "There were parsing errors" state.
                m_pBT1154->hrLoadResult = MIME_E_NO_DATA;
            }
            break;
        }

        if (m_pBT1154->cCurrentLine == pCurrBody->cLines)
        {
            // We have just read the line past the end
            // of the body.  Let's remember this spot...
            cbLastLine = cbThisLine;
        }

        m_pBT1154->cCurrentLine++;

        if (m_pBT1154->cCurrentLine > pCurrBody->cLines)
        {
            // We are reading lines past the end of a body part.

            if ((rLine.cchVal != 2) || (rLine.pszVal[0] != '\r') || (rLine.pszVal[1] != '\n'))
            {
                // All of the lines past the end of a body part (i.e. lines that are
                // either between body parts, or at the end of the message) should be
                // blank - and this one isn't.  Since it isn't, we go into the "There
                // were parsing errors" state.
                m_pBT1154->hrLoadResult = MIME_E_NO_MULTIPART_BOUNDARY;
            }

            if (m_pBT1154->cCurrentBody+1 < m_pBT1154->cBodies)
            {
                // We are *between* body parts, which means we just
                // consumed the single (blank) line which is between
                // them.  So we break out so we can add this body part
                // and move on to the next one.
                break;
            }

            // If we get to this point, it means that we are consuming the
            // (blank) lines which are beyond the end of the last body
            // part.  We continue consuming all of those lines until they
            // are gone.  If any of them were non-blank, then we will have
            // set the m_pBT1154->hrLoadResult member to MIME_E_NO_MULTIPART_BOUNDARY
            // (above).
            Assert(m_pBT1154->cCurrentBody+1 == m_pBT1154->cBodies);
        }
        else if (BT1154ENC_UUENCODE == pCurrBody->encEncoding)
        {
            // This is an else-if clause because we never look for the UUENCODE
            // begin and end keywords past the end of the body part.
            LPSTR pszFileName = NULL;

            // We are dealing with UUENCODE.
            if ((0 == m_pBindNode->cbBodyStart) && _FIsUuencodeBegin(&rLine, &pszFileName))
            {
                // We are looking for the start of UUENCODE - and this is it!  We set
                // the boundary start to be at the begin marker, and the body start to be
                // *after* the begin marker.
                m_pBindNode->cbBoundaryStart = cbThisLine;
                m_pBindNode->cbHeaderStart = cbThisLine;
                m_pBindNode->cbBodyStart = m_pInternet->DwGetOffset();
                _HrComputeDefaultContent(m_pBindNode, pszFileName);
                SafeMemFree(pszFileName);
            }
            else if ((0 != m_pBindNode->cbBodyStart) &&
                     (0 == m_pBindNode->cbBodyEnd) &&
                     _FIsUuencodeEnd(rLine.pszVal))
            {
                // We are looking for the end of UUENCODE - and this is it!  We set
                // the body end to be *before* the end marker.
                m_pBindNode->cbBodyEnd = cbThisLine;

                // We *don't* break out - we keep reading until we've consumed all
                // of the lines for this body.
            }
        }
        else if (BT1154ENC_BINHEX == pCurrBody->encEncoding)
        {
            // This is an else-if clause because we never look for the BINHEX
            // start line past the end of the body part.
            if (m_pBindNode->cbBodyStart == m_pBindNode->cbBoundaryStart)
            {
                // We haven't found the BINHEX start line yet.
                if (StrCmpNI(szBINHEXSTART,rLine.pszVal,sizeof(szBINHEXSTART)-1) == 0)
                {
                    // And this is it!  So set the body start to this line.
                    m_pBindNode->cbBodyStart = cbThisLine;
                }
            }
        }
    }

    // We only get to this point when we are at the end of a body - either
    // by having consumed the correct number of lines (plus the blank line
    // between bodies), or by having run off the end of the message.
    Assert((0 == rLine.cchVal) || (m_pBT1154->cCurrentLine == pCurrBody->cLines+1));

    // The only way we should have set the body end is if we are UUENCODE.
    Assert((BT1154ENC_UUENCODE == pCurrBody->encEncoding) || (0 == m_pBindNode->cbBodyEnd));

    if (0 == m_pBindNode->cbBodyEnd)
    {
        // We are either a TEXT or BINHEX body, or we are a UUENCODE and we
        // didn't find the end.

        if (BT1154ENC_UUENCODE == pCurrBody->encEncoding)
        {
            // We are doing UUENCODE, and we haven't seen the end keyword (and
            // maybe not even the begin keyword).  So we go into the "There
            // were parsing errors" state.
            if (0 == m_pBindNode->cbBodyStart)
            {
                // We haven't seen the begin keyword - so set the
                // body start to be the same as the boundary start.
                m_pBindNode->cbBodyStart = m_pBindNode->cbBoundaryStart;
            }
            m_pBT1154->hrLoadResult = MIME_E_BOUNDARY_MISMATCH;
        }

        // We need to set the body end...
        if (0 != cbLastLine)
        {
            // We found the "last line" above, so we set the
            // body end to that line.
            m_pBindNode->cbBodyEnd = cbLastLine;
        }
        else
        {
            // Since we didn't find the "last line" above, we set the
            // body end to this line.
            m_pBindNode->cbBodyEnd = cbThisLine;
        }
    }

    // We're done with this body part, so bind it.
    _HrBindNodeComplete(m_pBindNode, m_pBT1154->hrLoadResult);

    if (0 == rLine.cchVal)
    {
        // We have consumed the entire message - so clean everything up.

        // ****************************************************
        // NOTE - We set hr to the return value for the binding
        // operation.  Don't change hr between this point and
        // where we return.
        // ****************************************************

        m_pRootNode->cbBodyEnd = m_pInternet->DwGetOffset();
        _HrBindNodeComplete(m_pRootNode,S_OK);

        hr = m_pBT1154->hrLoadResult;

        SafeMemFree(m_pBT1154);
        m_pBindNode = NULL;
    }
    else
    {
        HBODY           hBody;

        // When we are processing the last body part, we consume all
        // of the lines after the last body part.  So, if we haven't
        // consumed the entire message, that means that we must have
        // some bodies left to process...
        Assert(m_pBT1154->cBodies > m_pBT1154->cCurrentBody+1);

        m_pBT1154->cCurrentBody++;
        m_pBT1154->cCurrentLine = 0;
        Assert(m_pBindNode != m_pRootNode);
        m_pBindNode = NULL;  // set this to NULL in case we get an error from InsertBody
        CHECKHR(hr = InsertBody(IBL_LAST, m_pRootNode->hBody, &hBody));
        m_pBindNode = _PNodeFromHBody(hBody);
        m_pBindNode->bindstate = BINDSTATE_PARSING_RFC1154;
    }

    // *********************************************************
    // NOTE - Don't change hr below this point.  See NOTE above.
    // *********************************************************

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingUuencodeBegin
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingUuencodeBegin(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;
    LPTREENODEINFO  pChild;
    LPSTR           pszFileName=NULL;
    HBODY           hBody;
    BOOL            fAddTextBody=FALSE;
    ULONG           cbTextBodyStart=0;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUBEGIN, FALSE);

    // Sit and Spin
    while(1)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // If not parsing a message
        if (!ISFLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE))
        {
            // Is uuencode begine line
            if (_FIsUuencodeBegin(&rLine, &pszFileName) == TRUE)
            {
                boundary = BOUNDARY_UUBEGIN;
                break;
            }
        }
    }

    // No Boundary
    if (BOUNDARY_NONE == boundary)
    {
        // Stuff after the last UUENCODED body must be appended as a text body
        if (m_pBindNode->pChildTail)
        {
            // De-ref Last Child
            pChild = m_pBindNode->pChildTail;

            // Artificial text body start
            cbTextBodyStart = pChild->cbBodyEnd;

            // AddTextBody ? lstrlen(end\r\n) = 5
            if (BOUNDARY_UUBEGIN == pChild->boundary && !ISFLAGSET(pChild->dwType, NODETYPE_INCOMPLETE))
                cbTextBodyStart += 5;

            // Space between last body end and boundary start is greater than sizeof(crlf)
            if (cbBoundaryStart > cbTextBodyStart && cbBoundaryStart - cbTextBodyStart > 2)
            {
                // Create Root Body Node
                CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

                // Bind to that object
                pChild = _PNodeFromHBody(hBody);

                // Fixup the STack
                pChild->pBindParent = m_pBindNode;

                // This body should assume the new text offsets
                CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));

                // Set Encoding
                CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

                // Set Offsets
                pChild->boundary = BOUNDARY_NONE;
                pChild->cbBoundaryStart = cbTextBodyStart;
                pChild->cbHeaderStart = cbTextBodyStart;
                pChild->cbBodyStart = cbTextBodyStart;
                pChild->cbBodyEnd = cbBoundaryStart;

                // This node is finished binding
                CHECKHR(hr = _HrBindNodeComplete(pChild, S_OK));
            }
        }

        // Body Offset Information
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

        // Pop the parsing Stack
        m_pBindNode = m_pBindNode->pBindParent;
    }

    // Otherwise, if we hit a uuencode boundary
    else
    {
        // If not a fake multipart yet...
        if (!ISFLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Its a faked multipart
            FLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART);

            // Free current content type
            CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));

            // Modify this dudes bound start
            Assert(m_pBindNode->boundary == BOUNDARY_ROOT);

            // Set the parse state
            m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
        }

        // ------------------------------------------------------------------------------------
        // \/ \/ \/ Raid 41599 - lost/munged attachments on forward/uuencode \/ \/ \/

        // If root node and body size is greater than sizeof(crlf)
        if (NULL == m_pBindNode->pChildTail && cbBoundaryStart - m_pBindNode->cbBodyStart > 2)
        {
            // Validate bind node
            Assert(m_pRootNode == m_pBindNode && m_pBindNode->cChildren == 0);

            // Set artificial text body start
            cbTextBodyStart = m_pBindNode->cbBodyStart;

            // Yes, add artificial text body
            fAddTextBody = TRUE;
        }

        // Otherwise, if last child parsed had an ending boundary of UUEND, and body size is greater than sizeof(crlf)
        else if (m_pBindNode->pChildTail)
        {
            // De-ref Last Child
            pChild = m_pBindNode->pChildTail;

            // Artificial text body start
            cbTextBodyStart = pChild->cbBodyEnd;

            // AddTextBody ? lstrlen(end\r\n) = 5
            if (BOUNDARY_UUBEGIN == pChild->boundary && !ISFLAGSET(pChild->dwType, NODETYPE_INCOMPLETE))
                cbTextBodyStart += 5;

            // Otherwise, what was the ending boundary
            else
                AssertSz(FALSE, "I should have only seen and uuencoded ending boundary.");

            // Space between last body end and boundary start is greater than sizeof(crlf)
            if (cbBoundaryStart > cbTextBodyStart && cbBoundaryStart - cbTextBodyStart > 2)
                fAddTextBody = TRUE;
        }

        // /\ /\ /\ Raid 41599 - lost/munged attachments on forward/uuencode /\ /\ /\
        // ------------------------------------------------------------------------------------

        // Create Root Body Node
        CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

        // Bind to that object
        pChild = _PNodeFromHBody(hBody);

        // Fixup the STack
        pChild->pBindParent = m_pBindNode;

        // Enough text to create a text/plain body ?
        if (fAddTextBody)
        {
            // This body should assume the new text offsets
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));

            // Set Encoding
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

            // Set Offsets
            pChild->boundary = BOUNDARY_NONE;
            pChild->cbBoundaryStart = cbTextBodyStart;
            pChild->cbHeaderStart = cbTextBodyStart;
            pChild->cbBodyStart = cbTextBodyStart;
            pChild->cbBodyEnd = cbBoundaryStart;

            // This node is finished binding
            CHECKHR(hr = _HrBindNodeComplete(pChild, S_OK));

            // Create Root Body Node
            CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

            // Bind to that object
            pChild = _PNodeFromHBody(hBody);

            // Fixup the STack
            pChild->pBindParent = m_pBindNode;
        }

        // Set Offsets
        pChild->boundary = BOUNDARY_UUBEGIN;
        pChild->cbBoundaryStart = cbBoundaryStart;
        pChild->cbHeaderStart = cbBoundaryStart;
        pChild->cbBodyStart = m_pInternet->DwGetOffset();

        // Update m_pBindNode
        Assert(m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN);
        m_pBindNode = pChild;

        // Default Node Content Type
        _HrComputeDefaultContent(m_pBindNode, pszFileName);

        // New Node BindState
        m_pBindNode->bindstate = BINDSTATE_FINDING_UUEND;
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindFindingUuencodeEnd
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindFindingUuencodeEnd(void)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;
    DWORD           cbBoundaryStart;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUEND, FALSE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // UU Encode End
        if (_FIsUuencodeEnd(rLine.pszVal))
        {
            boundary = BOUNDARY_UUEND;
        }
    }

    // Incomplete
    if (BOUNDARY_UUEND != boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Adjust body start to boundary start
        m_pBindNode->cbBodyStart = m_pBindNode->cbBoundaryStart;

        // Body End
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        CHECKHR(hr = _HrBindNodeComplete(m_pBindNode, S_OK));

        // Pop the tree
        m_pBindNode = m_pBindNode->pBindParent;

        // Done
        goto exit;
    }

    // Get the offset
    m_pBindNode->cbBodyEnd = cbBoundaryStart;

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // Should now be looking for next uubegin
    Assert(m_pBindNode ? m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN : TRUE);
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrBindNodeComplete
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrBindNodeComplete(LPTREENODEINFO pNode, HRESULT hrResult)
{
    // Locals
    HRESULT         hr=S_OK;
    LPURLREQUEST    pRequest;
    LPURLREQUEST    pNext;

    // The bind for this node is complete
    pNode->bindstate = BINDSTATE_COMPLETE;

    // Save the bind result
    pNode->hrBind = hrResult;

    // If pNode has not been bound yet, lets do it
    if (!ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Bind it to the tree
        hr = pNode->pBody->HrBindToTree(m_pStmLock, pNode);

        // If HrBindToTree failed
        if (SUCCEEDED(pNode->hrBind) && FAILED(hr))
            pNode->hrBind = hr;

        // Process the bind Request Table
        CHECKHR(hr = _HrProcessPendingUrlRequests());

        // If there is a WebPage being built, lets add this body
        if (m_pWebPage)
        {
            // Add the Body
            m_pWebPage->OnBodyBoundToTree(this, pNode);
        }
    }

    // Init the Loop
    pRequest = pNode->pResolved;

    // Loop
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &pNode->pResolved, &m_pComplete);

        // OnComplete
        pRequest->OnBindingComplete(pNode->hrBind);

        // Set pRequest
        pRequest = pNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::HrRegisterRequest
// --------------------------------------------------------------------------------
HRESULT CMessageTree::HrActiveUrlRequest(LPURLREQUEST pRequest)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == pRequest)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(m_rRootUrl.pszVal);

    // AddRef the Request
    pRequest->GetInner()->AddRef();

    // Put the Request into the pending list
    _LinkUrlRequest(pRequest, &m_pPending);

    // Process Pending Url Requests
    CHECKHR(hr = _HrProcessPendingUrlRequests());

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrProcessPendingUrlRequests
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrProcessPendingUrlRequests(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPURLREQUEST    pRequest=m_pPending;
    LPURLREQUEST    pNext;
    HBODY           hBody;
    BOOL            fResolved;

    // Loop the request
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // Try to resolve the request
        CHECKHR(hr = _HrResolveUrlRequest(pRequest, &fResolved));
        
        // Resolved
        if (FALSE == fResolved && ISFLAGSET(m_dwState, TREESTATE_BINDDONE))
        {
            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Not found, use default protocol
            pRequest->OnBindingComplete(E_FAIL);
        }

        // Next
        pRequest = pNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrResolveUrlRequest
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrResolveUrlRequest(LPURLREQUEST pRequest, BOOL *pfResolved)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody=NULL;
    LPTREENODEINFO  pNode;
    LPWSTR          pwszCntType=NULL;
    IStream        *pStream=NULL;

    // Invalid Arg
    Assert(pfResolved);

    // Initialize
    *pfResolved = FALSE;

    // Is this the root request ?
    if (NULL == pRequest->m_pszBodyUrl)
    {
        // Do I have a user supplied root data stream...I assume its html
        if (m_pRootStm)
        {
            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Use client driven root html stream
            pRequest->OnFullyAvailable(STR_TEXTHTML, m_pRootStm, this, NULL);

            // Resolved
            *pfResolved = TRUE;

            // Done
            goto exit;
        }

        // Otherwise, try to resolve the text/html body
        else
        {
            // We should not have a webpage object yet...
            Assert(NULL == m_pWebPage);

            // Create a CMessageWebPage Object
            CHECKALLOC(m_pWebPage = new CMessageWebPage(pRequest));

            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Feed the current amount of data read into the binder
            pRequest->OnStartBinding(STR_TEXTHTML, (IStream *)m_pWebPage, this, HBODY_ROOT);

            // Initialize
            CHECKHR(hr = m_pWebPage->Initialize(m_pCallback, this, &m_rWebPageOpt));

            // I need to feed all bound nodes to the web page for generation...
            CHECKHR(hr = _HrSychronizeWebPage(m_pRootNode));

            // If the entire tree bind is complete, then tell the webpage we are complete
            if (ISFLAGSET(m_dwState, TREESTATE_BINDDONE))
            {
                // Tell the webpage that we are done
                m_pWebPage->OnBindComplete(this);
                m_pWebPage->Release();
                m_pWebPage = NULL;
            }

            // Resolved
            *pfResolved = TRUE;

            // Done
            goto exit;
        }
    }

    // Otherwise, look for the Url
    else if (FAILED(ResolveURL(NULL, NULL, pRequest->m_pszBodyUrl, URL_RESOLVE_RENDERED, &hBody)))
        goto exit;

    // We better have a body handle by now
    Assert(_FIsValidHandle(hBody) && pRequest);

    // Dereference the body
    pNode = _PNodeFromHBody(hBody);

    // Get the Content Type
    MimeOleGetPropW(pNode->pBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &pwszCntType);

    // Get the BodyStream
    if (FAILED(pNode->pBody->GetData(IET_INETCSET, &pStream)))
        goto exit;

    // Complete
    if (BINDSTATE_COMPLETE == pNode->bindstate)
    {
        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

        // OnComplete
        pRequest->OnFullyAvailable(pwszCntType, pStream, this, pNode->hBody);

        // Resolved
        *pfResolved = TRUE;

        // Done
        goto exit;
    }

    // Otherwise, start binding
    else if (ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Should have pNode->pLockBytes
        Assert(pNode->pLockBytes);

        // Relink Request into the Node
        _RelinkUrlRequest(pRequest, &m_pPending, &pNode->pResolved);

        // Feed the current amount of data read into the binder
        pRequest->OnStartBinding(pwszCntType, pStream, this, pNode->hBody);

        // Resolved
        *pfResolved = TRUE;

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pwszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_HrSychronizeWebPage
// --------------------------------------------------------------------------------
HRESULT CMessageTree::_HrSychronizeWebPage(LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pChild;

    // Invalid Arg
    Assert(m_pWebPage && pNode);

    // Clear the "OnWebPage" Flag, we are re-generating the webpage
    FLAGCLEAR(pNode->dwState, WEBPAGE_NODESTATE_BITS);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Get the flags for this child node
            CHECKHR(hr = _HrSychronizeWebPage(pChild));
        }

        // Bind the multipart to the webpage
        m_pWebPage->OnBodyBoundToTree(this, pNode);
    }

    // Otherwise, if the node is bound and gagged...
    else if (BINDSTATE_COMPLETE == pNode->bindstate)
    {
        // Append to the WebPage
        m_pWebPage->OnBodyBoundToTree(this, pNode);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_RelinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppSource, 
    LPURLREQUEST *ppDest)
{
    // Unlink this pending request
    _UnlinkUrlRequest(pRequest, ppSource);

    // Link the bind request into pNode
    _LinkUrlRequest(pRequest, ppDest);
}

// --------------------------------------------------------------------------------
// CMessageTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_UnlinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Debug make sure pRequest is part of *ppHead chain
#ifdef DEBUG
    for(LPURLREQUEST pCurr=*ppHead; pCurr!=NULL; pCurr=pCurr->m_pNext)
        if (pCurr == pRequest)
            break;
    AssertSz(pCurr, "pRequest is not part of *ppHead linked list");
#endif

    // Fixup Previous and Next
    LPURLREQUEST pNext = pRequest->m_pNext;
    LPURLREQUEST pPrev = pRequest->m_pPrev;

    // Fixup Links
    if (pNext)
        pNext->m_pPrev = pPrev;
    if (pPrev)
        pPrev->m_pNext = pNext;

    // Fixup ppHead
    if (pRequest == *ppHead)
    {
        Assert(pPrev == NULL);
        *ppHead = pNext;
    }

    // Set Next and Prev
    pRequest->m_pNext = NULL;
    pRequest->m_pPrev = NULL;
}

// --------------------------------------------------------------------------------
// CMessageTree::_LinkUrlRequest
// --------------------------------------------------------------------------------
void CMessageTree::_LinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Is the head set
    if (NULL != *ppHead)
    {
        // Set Next
        pRequest->m_pNext = *ppHead;

        // Set Previous
        (*ppHead)->m_pPrev = pRequest;
    }

    // Set the head
    (*ppHead) = pRequest;
}

// --------------------------------------------------------------------------------
// CMessageTree::_ReleaseUrlRequestList
// --------------------------------------------------------------------------------
void CMessageTree::_ReleaseUrlRequestList(LPURLREQUEST *ppHead)
{
    // Locals
    LPURLREQUEST pCurr;
    LPURLREQUEST pNext;

    // Invalid Arg
    Assert(ppHead);

    // Init
    pCurr = *ppHead;

    // Loop the Elements
    while(pCurr)
    {
        // Set Next
        pNext = pCurr->m_pNext;

        // Free pCurr
        pCurr->GetInner()->Release();

        // Next
        pCurr = pNext;
    }

    // Done
    *ppHead = NULL;
}

// --------------------------------------------------------------------------------
// IsRfc1154Token
//
// --------------------------------------------------------------------------------
inline BOOL IsRfc1154Token(LPSTR pszDesired, LPSTR pszEndPtr, ULONG cchLen)
{

    if (StrCmpNI(pszDesired,pszEndPtr,cchLen) != 0)
    {
        return (FALSE);
    }
    if ((pszEndPtr[cchLen] != '\0') &&
        (pszEndPtr[cchLen] != ' ') &&
        (pszEndPtr[cchLen] != '\t') &&
        (pszEndPtr[cchLen] != ','))
    {
        return (FALSE);
    }
    return (TRUE);
}

// --------------------------------------------------------------------------------
// CMessageTree::_DecodeRfc1154
// --------------------------------------------------------------------------------
void CMessageTree::_DecodeRfc1154() {
    BOOL bRes = FALSE;
    HRESULT hr;
    LPSTR pszEncoding = NULL;
    LPSTR pszEndPtr;
    ULONG cAlloc = 0;

    if (!m_rOptions.fDecodeRfc1154)
    {
        goto exit;
    }
    hr = m_pBindNode->pContainer->GetProp(SYM_HDR_ENCODING, &pszEncoding);
    if (!SUCCEEDED(hr))
    {
        goto exit;
    }
    pszEndPtr = pszEncoding;
    // Each time we enter this loop, pszEndPtr points to the start of the
    // next subfield.  Each subfield is something like "103 TEXT".  The
    // number is always decimal, and the number is optional in the last
    // subfield.
    while (1)
    {
        LPSTR pszTmp;
        ULONG cLines;
        BOOL bNumberFound;
        BT1154ENCODING encEncoding;

        // ------------------------------------
        // "  103  TEXT  , ..."
        //  ^
        //  |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //  ^
        //  |-- pszEndPtr
        // ------------------------------------

        bNumberFound = FALSE;

        // Skip past any leading whitespace.
        while ((*pszEndPtr==' ')||(*pszEndPtr=='\t'))
        {
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //    ^
        //    |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        pszTmp = pszEndPtr;

        // We use strtoul to convert a decimal number.
        // pszEndPtr will be left pointing at the
        // character which terminated the number.
        cLines = strtoul(pszTmp, &pszEndPtr, 10);

        if (0xffffffff == cLines)
        {
            // We don't allow this - we use cLines == 0xffffffff to signal
            // the case where the body part didn't include a line count and
            // thus should consume all remaining lines.  So we'll (silently)
            // convert this to 0xfffffffe...
            cLines = 0xfffffffe;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //       ^
        //       |-- pszEndPtr
        //
        // or (if there isn't a number)
        //
        // "       TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        if (cLines && !((*pszEndPtr==' ')||(*pszEndPtr=='\t')))
        {
            // Malformed - if the subfield specifies a number, then
            // the number *must* be followed by whitespace.
            goto exit;
        }
        // Now we skip past any whitespace...
        while ((*pszEndPtr==' ') || (*pszEndPtr=='\t'))
        {
            bNumberFound = TRUE;
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //         ^
        //         |-- pszEndPtr
        // ------------------------------------

        // We should now be pointing at the body type.
        if (IsRfc1154Token("text",pszEndPtr,4))
        {
            encEncoding = BT1154ENC_TEXT;
            pszEndPtr += 4;
        }
        else if (IsRfc1154Token("uuencode",pszEndPtr,8))
        {
            encEncoding = BT1154ENC_UUENCODE;
            pszEndPtr += 8;
        }
        else if (IsRfc1154Token("x-binhex",pszEndPtr,8))
        {
            encEncoding = BT1154ENC_BINHEX;
            pszEndPtr += 8;
        }
        else
        {
            // Malformed - we don't really support anything except
            // TEXT, UUENCODE, and X-BINHEX.  But, instead of
            // falling back to "fake multipart" handling, we'll just
            // pretend that this body part is TEXT...
            encEncoding = BT1154ENC_TEXT;
            // We need to consume the body part from the Encoding: string - that means
            // that we advance until we see a NULL, a space, a tab, or a comma.
            while ((*pszEndPtr != '\0') &&
                   (*pszEndPtr != ' ') &&
                   (*pszEndPtr != '\t') &&
                   (*pszEndPtr != ','))
            {
                pszEndPtr++;
            }
            // TBD - We could add the body type as a property on the
            // body part.  To do that, we would need to save it in the
            // m_pBT1154 structure.  We'd also have to figure out which
            // property to set it as.
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //             ^
        //             |-- pszEndPtr
        // ------------------------------------

        // Now we skip past any whitespace...
        while ((*pszEndPtr==' ') || (*pszEndPtr=='\t'))
        {
            pszEndPtr++;
        }

        // ------------------------------------
        // "  103  TEXT  , ..."
        //               ^
        //               |-- pszEndPtr
        // ------------------------------------

        if ((*pszEndPtr!='\0') && (*pszEndPtr!=','))
        {
            // Malformed - a subfield is terminated either by a comma,
            // or by a NULL.
            goto exit;
        }
        if (*pszEndPtr != '\0' && !bNumberFound)
        {
            // Malformed - only the *last* subfield can get away with
            // not specifying a line count.
            goto exit;
        }
        if (*pszEndPtr == '\0' && !bNumberFound)
        {
            // This is the last subfield, and there wasn't
            // a line count specified.  This means that the
            // last body part should consume all of the remaining
            // lines - so we'll set the line count really high...
            cLines = 0xffffffff;
        }
        if (!m_pBT1154 || (m_pBT1154->cBodies == cAlloc))
        {
            ULONG cbCurrSize = offsetof(BOOKTREE1154, aBody) + (sizeof(BT1154BODY) * cAlloc);
            ULONG cbAllocSize = cbCurrSize + sizeof(BT1154BODY) * 4;
            LPBOOKTREE1154 pTmp;

            CHECKALLOC(pTmp = (LPBOOKTREE1154)g_pMalloc->Alloc(cbAllocSize));
            if (!m_pBT1154)
            {
                ZeroMemory(pTmp, cbAllocSize);
            }
            else
            {
                CopyMemory(pTmp, m_pBT1154, cbCurrSize);
                ZeroMemory(((LPBYTE) pTmp) + cbCurrSize, cbAllocSize - cbCurrSize);
            }
            SafeMemFree(m_pBT1154);
            m_pBT1154 = pTmp;
            cAlloc += 4;
        }
        Assert(0 == m_pBT1154->aBody[m_pBT1154->cBodies].encEncoding);
        Assert(0 == m_pBT1154->aBody[m_pBT1154->cBodies].cLines);
        m_pBT1154->aBody[m_pBT1154->cBodies].encEncoding = encEncoding;
        m_pBT1154->aBody[m_pBT1154->cBodies].cLines = cLines;
        m_pBT1154->cBodies++;
        if (*pszEndPtr == '\0')
        {
            // The end of the line...
            break;
        }
        // Skip past the comma.
        Assert(*pszEndPtr==',');
        Assert(bNumberFound);
        pszEndPtr++;

        // ------------------------------------
        // "         ... , 975 UUENCODE"
        //                ^
        //                |-- pszEndPtr
        // ------------------------------------

    }
    Assert(m_pBT1154);
    Assert(m_pBT1154->cBodies);
    Assert(!m_pBT1154->cCurrentBody);
    Assert(!m_pBT1154->cCurrentLine);
    Assert(S_OK == m_pBT1154->hrLoadResult);

    bRes = TRUE;

exit:
    SafeMemFree(pszEncoding);
    if (!bRes)
    {
        SafeMemFree(m_pBT1154);
    }
}

#endif // !WIN16

#ifdef SMIME_V3
// --------------------------------------------------------------------------------
// CMessageTree::Encode
// --------------------------------------------------------------------------------

HRESULT CMessageTree::Encode(HWND hwnd, DWORD dwFlags)
{
    HRESULT            hr;
    CSMime *           pSMime = NULL;

    //  Create the object
    CHECKALLOC(pSMime = new CSMime);

    //  Initialize the object
    CHECKHR(hr = pSMime->InitNew());

    //  Set the state flag to tell us about re-use of boundaries
    FLAGSET(m_dwState, TREESTATE_REUSESIGNBOUND);

    //  Encode the message
    CHECKHR(hr = pSMime->EncodeMessage2(this, m_rOptions.ulSecIgnoreMask |
                                        dwFlags, hwnd));

exit:
    ReleaseObj(pSMime);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::Decode
// --------------------------------------------------------------------------------

HRESULT CMessageTree::Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback)
{
    HRESULT             hr;
    CSMime *            pSMime = NULL;

    //  Create the object
    CHECKALLOC(pSMime = new CSMime);

    //  Initialize the object
    CHECKHR(hr = pSMime->InitNew());

    //  Encode the message
    CHECKHR(hr = pSMime->DecodeMessage2(this, m_rOptions.ulSecIgnoreMask |
                                        dwFlags, hwnd, pCallback));

exit:
    ReleaseObj(pSMime);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetRecipientCount
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetRecipientCount(DWORD dwFlags, DWORD * pdwRecipCount)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetRecipientCount(dwFlags, pdwRecipCount));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::AddRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageTree::AddRecipient(DWORD dwFlags, DWORD cRecipData,
                                   PCMS_RECIPIENT_INFO precipData)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->AddRecipient(dwFlags, cRecipData, precipData));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}


// ------------------------------------------------------------------------------
// CMessageTree::GetRecipient
// ------------------------------------------------------------------------------

HRESULT CMessageTree::GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetRecipient(dwFlags, iRecipient, cRecipients, pRecipData));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::DeleteRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageTree::DeleteRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->DeleteRecipient(dwFlags, iRecipient, cRecipients));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   DWORD iInstance, LPCSTR pszObjId,
                                   CRYPT_ATTRIBUTE ** ppattr)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->GetAttribute(dwFlags, iSigner, iAttribSet, iInstance,
                                    pszObjId, ppattr));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::SetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   const CRYPT_ATTRIBUTE * ppattr)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->SetAttribute(dwFlags, iSigner, iAttribSet, ppattr));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageTree::DeleteAttribute(DWORD dwFlags, DWORD iSigner,
                                      DWORD iAttributeSet, DWORD iInstance,
                                      LPCSTR pszObjId)
{
    HRESULT             hr;
    IMimeSecurity2 *    pms2 = NULL;

    CHECKHR(hr = BindToObject(HBODY_ROOT, IID_IMimeSecurity2, (LPVOID *) &pms2));

    CHECKHR(hr = pms2->DeleteAttribute(dwFlags, iSigner, iAttributeSet,
                                       iInstance, pszObjId));

exit:
    if (pms2 != NULL)   pms2->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageTree::CreateReceipt
// --------------------------------------------------------------------------------

HRESULT CMessageTree::CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                                    const BYTE *pbFromNames, DWORD cSignerCertificates,
                                    PCCERT_CONTEXT *rgSignerCertificates,
                                    IMimeMessage ** ppMimeMessageReceipt)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::GetReceiptSendersList
// --------------------------------------------------------------------------------

HRESULT CMessageTree::GetReceiptSendersList(DWORD dwFlags, DWORD *pcSendersList,
                                            CERT_NAME_BLOB  * *rgSendersList)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::VerifyReceipt
// --------------------------------------------------------------------------------

HRESULT CMessageTree::VerifyReceipt(DWORD dwFlags,
                                    IMimeMessage * pMimeMessageReceipt)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageTree::CapabilitiesSupported
// --------------------------------------------------------------------------------

HRESULT CMessageTree::CapabilitiesSupported(DWORD * pdwFlags)
{
    //  Assume no capabilities
    *pdwFlags = 0;
    
    //  If we have msasn1.dll on the system, then we can support labels
    if (FIsMsasn1Loaded())  *pdwFlags |= SMIME_SUPPORT_LABELS;

    //  If we have a correct crypt32, then we can support receipts & key agreement
    DemandLoadCrypt32();
    if (g_FSupportV3 && FIsMsasn1Loaded())
        *pdwFlags |= SMIME_SUPPORT_RECEIPTS;

    if (g_FSupportV3)
        *pdwFlags |= SMIME_SUPPORT_KEY_AGREE;

    //  If we have a correct advapi32, then we can support maillist keys
    DemandLoadAdvApi32();
    if (VAR_CryptContextAddRef != MY_CryptContextAddRef)
        *pdwFlags |= SMIME_SUPPORT_MAILLIST;
    
    return S_OK;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bytebuff.h ===
// --------------------------------------------------------------------------------
// ByteBuff.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef _BYTEBUFF_H
#define _BYTEBUFF_H

// --------------------------------------------------------------------------------
// Default Grow Amount
// --------------------------------------------------------------------------------
#define BYTEBUFF_GROW        256

// --------------------------------------------------------------------------------
// WBS_xxx - WebBuffer State
// --------------------------------------------------------------------------------
#define BBS_LAST     0x00000001      // Last Buffer     

// --------------------------------------------------------------------------------
// BUFFERINFO
// --------------------------------------------------------------------------------
typedef struct tagBUFFERINFO {       
    LPBYTE          pb;              // Current buffer
    DWORD           cb;              // Current Byte Count
    DWORD           i;               // Current Index
    DWORD           cbAlloc;         // Sizeof(m_pb)
    LPBYTE          pbStatic;        // Passed in, dont free
} BUFFERINFO, *LPBUFFERINFO;

// --------------------------------------------------------------------------------
// CByteBuffer
// --------------------------------------------------------------------------------
class CByteBuffer : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CByteBuffer(LPBYTE pb=NULL, ULONG cbAlloc=0, ULONG cb=0, ULONG i=0);
    ~CByteBuffer(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void) { return ++m_cRef; }
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CByteBuffer Methods
    // ----------------------------------------------------------------------------
    void Init(LPBYTE pb=NULL, ULONG cbAlloc=0, ULONG cb=0, ULONG i=0);
    void SetGrowBy(DWORD cbGrow) { m_cbGrow = cbGrow; }
    const LPBYTE PbData(void) { return ((0 == m_buffer.cb) ? NULL : (const LPBYTE)(m_buffer.pb)); }
    const DWORD CbData(void) { return m_buffer.cb; }
    void SetIndex(DWORD i) { m_buffer.i = i; }
    HRESULT SetSize(DWORD cb);
    HRESULT Append(LPBYTE pbData, ULONG cbData); 

private:
    // ----------------------------------------------------------------------------
    // Private Members
    // ----------------------------------------------------------------------------
    HRESULT _HrRealloc(DWORD cbAlloc);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference count
    DWORD           m_dwState;          // State
    DWORD           m_cbGrow;           // Grow Amount
    BUFFERINFO      m_buffer;           // Buffer
};

#endif // _BYTEBUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\capitype.h ===
#ifndef __CAPITYPE_H
#define __CAPITYPE_H

#ifndef __WINCRYPT_H__
#include "wincrypt.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN ADVAPI Functions

typedef
WINADVAPI
BOOL
WINAPI
CRYPTGETPROVPARAM(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTACQUIRECONTEXTA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
typedef
WINADVAPI
BOOL
WINAPI
CRYPTACQUIRECONTEXTW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#error this won't work
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTW
#else
#define CRYPTACQUIRECONTEXT  CRYPTACQUIRECONTEXTA
#endif // !UNICODE


typedef
WINADVAPI
BOOL
WINAPI
CRYPTRELEASECONTEXT(
    HCRYPTPROV hProv,
    DWORD dwFlags);


typedef
WINADVAPI
BOOL
WINAPI
CRYPTGENKEY(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTDESTROYKEY(
    HCRYPTKEY hKey);

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Hash Functions

typedef
WINADVAPI
BOOL
WINAPI
CRYPTCREATEHASH(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTHASHDATA(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTDESTROYHASH(
    HCRYPTHASH hHash);

typedef
WINADVAPI
BOOL
WINAPI
CRYPTSIGNHASHA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Cryptograpic Functions

typedef
WINCRYPT32API
int
WINAPI
CRYPTSIGNMESSAGE(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTENCRYPTMESSAGE(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTSIGNANDENCRYPTMESSAGE(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeSignedAndEncrypted,
    IN DWORD cbToBeSignedAndEncrypted,
    OUT BYTE *pbSignedAndEncryptedBlob,
    IN OUT DWORD *pcbSignedAndEncryptedBlob
    );


typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTDECRYPTMESSAGE(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Store Functions

typedef
WINCRYPT32API HCERTSTORE WINAPI CERTOPENSYSTEMSTOREA(
    HCRYPTPROV      hProv,
    LPCSTR		szSubsystemProtocol
    );

typedef
WINCRYPT32API
HCERTSTORE
WINAPI
CERTOPENSTORE(
    IN LPCTSTR dwStoreProvType,
    IN DWORD dwCertEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN void const *pvPara
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTCLOSESTORE(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTENUMCERTIFICATESINSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTFINDCERTIFICATEINSTORE(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTADDCERTIFICATECONTEXTTOSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Certificate Functions

typedef
WINCRYPT32API
BOOL
WINAPI
CERTGETINTENDEDKEYUSAGE(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertInfo,
    OUT BYTE *pbKeyUsage,
    IN DWORD cbKeyUsage
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTGETCERTIFICATECONTEXTPROPERTY(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTGETSUBJECTCERTIFICATEFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTGETISSUERCERTIFICATEFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTFREECERTIFICATECONTEXT(
    IN PCCERT_CONTEXT pCertContext
    );

typedef
WINCRYPT32API
PCCERT_CONTEXT
WINAPI
CERTDUPLICATECERTIFICATECONTEXT(
    IN PCCERT_CONTEXT pCertContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN CRL Functions

typedef
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CERTGETCRLFROMSTORE(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL PCCERT_CONTEXT pIssuerContext,
    IN PCCRL_CONTEXT pPrevCrlContext,
    IN OUT DWORD *pdwFlags
    );

typedef
WINCRYPT32API
PCCRL_CONTEXT
WINAPI
CERTDUPLICATECRLCONTEXT(
    IN PCCRL_CONTEXT pCrlContext
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTFREECRLCONTEXT(
    IN PCCRL_CONTEXT pCrlContext
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Message Functions

typedef
WINCRYPT32API
HCRYPTMSG
WINAPI
CRYPTMSGOPENTODECODE(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGCLOSE(
    IN HCRYPTMSG hCryptMsg
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGUPDATE(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGCONTROL(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTMSGGETPARAM(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Debug Functions

typedef
WINCRYPT32API
BOOL
WINAPI
CRYPTDECODEOBJECT(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

typedef
WINCRYPT32API
BOOL
WINAPI
CERTSETCERTIFICATECONTEXTPROPERTY(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    );

//////////////////////////////////////////////////////////////////////////////
/////////////  BEGIN Helper Functions

typedef
WINCRYPT32API
LPCSTR
WINAPI
CERTALGIDTOOID(
    IN DWORD dwAlgId
    );


typedef
WINCRYPT32API
DWORD
WINAPI
CERTOIDTOALGID(
    IN LPCSTR pszObjId
    );

typedef
WINCRYPT32API
DWORD
WINAPI
CERTNAMETOSTRA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    );

typedef
WINCRYPT32API
LONG
WINAPI
CERTVERIFYTIMEVALIDITY(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    );

typedef
WINCRYPT32API
PCERT_RDN_ATTR
WINAPI
CERTFINDRDNATTR(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    );

#ifdef __cplusplus
}
#endif // extern "C"

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\capistm.cpp ===
/*
**  capistm.cpp
**
**  Purpose:
**      Implementation of a class to wrap around CAPI functionality
**
**  History
**      1/26/98; (brucek) triple wrap support
**      2/07/97: (t-erikne) multipart/signed
**      1/06/97: (t-erikne) Moved into MimeOLE
**     11/14/96: (t-erikne) CAPI Post-SDR work
**      8/27/96: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1996-1998.
*/

///////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include <wincrypt.h>
#include "olealloc.h"
#include "containx.h"
#include "smime.h"
#include "capistm.h"
#include "mimeapi.h"
#include "inetconv.h"
#include <capiutil.h>
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include <demand.h>
#include "strconst.h"

#include "smimepol.h"
BOOL    FHideMsgWithDifferentLabels(); 
enum ECertErrorProcessLabel {
    CertErrorProcessLabelAnyway = 0,
    CertErrorProcessLabelGrant = 1,
    CertErrorProcessLabelDeny = 2
};
DWORD   DwProcessLabelWithCertError(); 
HRESULT HrCheckLabelAccess(const DWORD dwFlags, const HWND hwnd, 
           PSMIME_SECURITY_LABEL plabel, const PCCERT_CONTEXT pccertDecrypt,
           const PCCERT_CONTEXT pccertSigner, const HCERTSTORE    hcertstor);

#ifdef MAC
#undef CertOpenStore
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore
#endif  // MAC

// from dllmain.h
extern DWORD g_dwSysPageSize;
extern CMimeAllocator * g_pMoleAlloc;
extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

extern void DebugDumpStreamToFile(LPSTREAM pstm, LPSTR lpszFile);

// From smime.cpp
extern HRESULT HrGetLastError(void);
extern BOOL FIsMsasn1Loaded();

#ifdef WIN16
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextA
#else
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextW
#endif

///////////////////////////////////////////////////////////////////////////
//
// defines
//

#define THIS_AS_UNK ((IUnknown *)(IStream *)this)

#define CS_E_CANT_DECRYPT   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x2414)
#define CS_E_MSG_INVALID    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x2415)

const int CbCacheBufferSize = 4 * 1024;

///////////////////////////////////////////////////////////////////////////
//
// inlines
//

static INLINE void ReleaseCert(PCCERT_CONTEXT pc)
    { if (pc) CertFreeCertificateContext(pc); }

// Streaming state diagram
//
//            SF                GT                    SD-FW-TN-SO-SF
//             |                 |                   /[encryption]
//            SO                QT-------------------
//  [op encode] \              / [opaque decode]     \[signed]
//               ------NB------                       (FW-TN)-SO-SF
// [det encode] /              \ [detached decode]
//            DO                DO
//             |                 \
//            SF                  DF
//                                 |
//                                SO
//                                 |
//                                SF
//
//
//  New state diagram:
//                                                               encrypt
//                                                            SD--SO
//        opaque encode              opaque decode           /
//               SO            QT--------------------[QTF]---
//                 \          /                              \
//                  ---NB-----                                SO    signed
//                 /          \
//          SO---DO            DO ------------------ SO
//      detach encode               detach decode
//
//

#ifndef WIN16
enum CSstate {
    STREAM_NOT_BEGUN,
    STREAM_QUESTION_TIME,
    STREAM_QUESTION_TIME_FINAL,
    STREAM_SETUP_DECRYPT,
    STREAM_DETACHED_OCCURING,
    STREAM_OCCURING, // must be +1 of DF
    STREAM_ERROR,
    STREAM_GOTTYPE,

    CSTM_FIRST_WRITE = 32,
    CSTM_TEST_NESTING,
    CSTM_STREAMING,
    CSTM_STREAMING_DONE,
    CSTM_GOTTYPE,
    };
#endif // !WIN16

// low word is public.  see .h file.
#define CSTM_DECODE             0x00010000
#define CSTM_DONTRELEASEPROV    0x00020000
#define CSTM_RECURSED           0x00040000
#define CSTM_HAVECR             0x10000000
#define CSTM_HAVEEOL            0x20000000

static const char s_cszMy[]             = "My";
static const char s_cszWABCertStore[]   = "AddressBook";
static const char s_cszCA[]             = "CA";

static const char s_cszMimeHeader[]     = "Content-Type: application/x-pkcs7-mime"
                "; name=smime.p7m; smime-type=";
static const char s_cszMimeHeader2[]     = "Content-Disposition: attachment; "
                "filename=smime.p7m";

static const char s_cszOIDMimeHeader1[]   = "Content-Type: oid/";
static const char s_cszOIDMimeHeader2[]   = "\nContent-Transfer-Encoding: binary\n\n";



///////////////////////////////////////////////////////////////////////////
//
// static prototypes
//

#if 0
#define IV_LENGTH 8
static BOOL _GetIV(BYTE rgbIV[IV_LENGTH]);

static PBYTE _PVEncodeObject(
    LPCSTR lpszStructType,
    const void *pvStructInfo,
    DWORD *pcbEncoded);
#endif

static HRESULT _InitEncodedCert(IN HCERTSTORE hcertstor,
                                OUT PCERT_BLOB * rgblobCert, OUT DWORD * pcCerts,
                                OUT PCRL_BLOB * rgblobCRL, OUT DWORD * pcCrl);

static HRESULT _InitEncodedCertIncludingSigners(IN HCERTSTORE hcertstor,
                                DWORD cSigners, SignerData rgSigners[],
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl);

static void _SMimeCapsFromHMsg(HCRYPTMSG, DWORD id, LPBYTE * ppb, DWORD * pcb);

// ---------------------------- UTILITY FUNCTIONS --------------------------


HRESULT GetParameters(PCCERT_CONTEXT pccert, HCERTSTORE hstoreMsg, 
                      HCERTSTORE hstoreAll)
{
    CRYPT_DATA_BLOB     blob;
    DWORD               dw;
    HRESULT             hr = CRYPT_E_MISSING_PUBKEY_PARA;
    PCCERT_CONTEXT      pccertX;

    //  
    //  Start by looking for the issuer certificate on your own.  All that
    //  matters is that we find a certificate which claims to be the issuer
    //  and has parameters -- they will need to verify the parameters are
    //  correct at a later date.
    //

    pccertX = NULL;
    while (hstoreMsg != NULL) {
        //
        //  Find certificates by matching issuers -- ok for now as PKIX requires
        //  all issuers to have DNs
        //

        dw = CERT_STORE_SIGNATURE_FLAG;
        pccertX = CertGetIssuerCertificateFromStore(hstoreMsg, pccert, pccertX,
                                                    &dw);
        if (pccertX == NULL) {
            if (::GetLastError() == CRYPT_E_SELF_SIGNED) {
                return S_OK;
            }
            break;
        }

        //
        //  Only accept the item if we manage a signature validation on it.
        //

        if ((dw & CERT_STORE_SIGNATURE_FLAG)) {
            //
            //  We can't verify the signature, so get the issuers paramters and try again
            //

            hr = GetParameters(pccertX, hstoreMsg, hstoreAll);
            if (FAILED(hr)) {
                continue;
            }

            //
            //  The issuing cert has parameters, try the signature check again againist it.
            //
            
            dw = CERT_STORE_SIGNATURE_FLAG;
            if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                break;
            }
            hr = CRYPT_E_MISSING_PUBKEY_PARA;
        }
        else {
            if (pccertX->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData != 0) {
                hr = 0;
                break;
            }

            //
            //  If we found one but it does not have the parameters, it must be
            //  inheriting from it's issuer as well.
            //

            dw = CERT_STORE_SIGNATURE_FLAG;
            if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                hr = 0;
                break;
            }
        }
    }

    //
    //  If we still do not have a certificate, then search all of the system stores
    //  for an isuer.
    //

    if (pccertX == NULL) {
        while (hstoreAll != NULL) {
            //
            //  Find certificates by matching issuers -- ok for now as PKIX requires
            //  all issuers to have DNs
            //

            dw = CERT_STORE_SIGNATURE_FLAG;
            pccertX = CertGetIssuerCertificateFromStore(hstoreAll, pccert, pccertX,
                                                        &dw);

            if (pccertX == NULL) {
                if (::GetLastError() == CRYPT_E_SELF_SIGNED) {
                    return S_OK;
                }
                break;
            }

            //
            //  Only accept the item if we manage a signature validation on it.
            //

            if ((dw & CERT_STORE_SIGNATURE_FLAG)) {
                //
                //  We can't verify the signature, so get the issuers paramters and try again
                //

                hr = GetParameters(pccertX, hstoreMsg, hstoreAll);
                if (FAILED(hr)) {
                    continue;
                }

                //
                //  The issuing cert has parameters, try the signature check again againist it.
                //
            
                dw = CERT_STORE_SIGNATURE_FLAG;
                if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                    break;
                }
                hr = CRYPT_E_MISSING_PUBKEY_PARA;
            }
            else {
                if (pccertX->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData != 0) {
                    hr = 0;
                    break;
                }

                //
                //  If we found one but it does not have the parameters, it must be inheriting
                //  from it's issuer as well.
                //

                dw = CERT_STORE_SIGNATURE_FLAG;
                if (CertVerifySubjectCertificateContext(pccert, pccertX, &dw) && (dw == 0)) {
                    hr = 0;
                    break;
                }
            }
        }
    }

#if 0
    //
    //  We found a certificate, set the parameters onto the context so that we
    //  can successfully manage to validate the signature
    //

    if (pccertX != NULL) {
        CRYPT_DATA_BLOB *       pdata = NULL;
        
        hr = HrGetCertificateParam(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, (LPVOID *) &pdata, NULL);
        if (FAILED(hr)) {
            CertFreeCertificateContext(pccertX);
            return hr;
        }
        
        CertSetCertificateContextProperty(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, 0, pdata);
        
        ReleaseMem(pdata);
        CertFreeCertificateContext(pccertX);
        return S_OK;
    }
    
    //
    //  if we still have not found anything, then let the caller have a chance
    //  to tell us what the parameters ought to be.
    //
                    
    if (m_pSmimeCallback != NULL) {
        hr = m_pSmimeCallback->GetParameters(pSignerCert, NULL,
                                             &blob.cbData, &blob.pbData);
        if (SUCCEEDED(hr)) {
            if (!CertSetCertificateContextProperty(pccert, CERT_PUBKEY_ALG_PARA_PROP_ID, 0, &blob) {
                hr = HrGetLastError();
            }
        }
        if (pb != NULL) {
            LocalFree(blob.pbData);
        }
        if (SUCCEEDED(hr)) {
            goto retry;
        }
    }
#endif // 0

    return hr;
}

//*************************************************************************
//                      CCAPIStm
//*************************************************************************


///////////////////////////////////////////////////////////////////////////
//
// ctor/dtor
//


/***************************************************************************

    Name      : constructor

    Purpose   :

    Parameters: lpstmOut -> Output stream or NULL
                psld -> SECURITY_LAYER_DATA or NULL.  If NULL, one will be
                  created.

    Returns   : void

    Comment   :

***************************************************************************/
CCAPIStm::CCAPIStm(LPSTREAM lpstmOut) :
    m_pstmOut(lpstmOut), m_cRef(1)
{
    DOUT("CCAPIStm::constructor() %#x -> %d", this, m_cRef);
    if (m_pstmOut)
        m_pstmOut->AddRef();

    m_hProv = NULL;
    m_hMsg = NULL;
    //    m_buffer = NULL;
    m_csStatus = STREAM_NOT_BEGUN;
    m_csStream = CSTM_FIRST_WRITE;
    m_rgStores = NULL;
    m_cStores = 0;
    m_pUserCertDecrypt = NULL;
    m_pCapiInner = NULL;
    m_pConverter = NULL;
    m_psldData = NULL;    
    m_pattrAuth = NULL;

#if defined(DEBUG) && !defined(MAC)
    {
        char szFileName[MAX_PATH + 1];

        m_pstmDebugFile = NULL;
        // Create a debug output file name based on the CAPIStm pointer
        wsprintf(szFileName, "c:\\capidump%08x.txt", this);
        OpenFileStream(szFileName, CREATE_ALWAYS, GENERIC_WRITE, &m_pstmDebugFile);
    }
#endif

    m_hwnd = NULL;
    m_pSmimeCallback = NULL;
    m_dwFlagsSEF = 0;
    m_pwszKeyPrompt = NULL;

    m_pbBuffer = NULL;
    m_cbBuffer = 0;

    // m_dwFlags set in HrInitialize
    // m_cbBeginWrite initialized before use
    // m_cbBufUsed handled in the Begin* functions
    // m_cbBufAlloc handled in the Begin* functions
}

CCAPIStm::~CCAPIStm()
{
    DOUT("CCAPIStm::destructor() %#x -> %d", this, m_cRef);
    if (m_hMsg) {
        CryptMsgClose(m_hMsg);
    }

    if (m_hProv) 
    {
        CryptReleaseContext(m_hProv, 0); 
    }

    m_hProv = NULL;
    ReleaseObj(m_pCapiInner);
    ReleaseObj(m_pstmOut);
    ReleaseObj(m_pConverter);
    if (m_pattrAuth)  {
        MemFree(m_pattrAuth);
    }
    if (m_pUserCertDecrypt) {
        CertFreeCertificateContext(m_pUserCertDecrypt);
    }
    if (m_cStores) {
        Assert(m_rgStores);
        for (DWORD i=0; i<m_cStores; i++) {
            CertCloseStore(m_rgStores[i], 0);
        }
        MemFree(m_rgStores);
    }

	// Fix: Releasing hProv is caller responcibility
    //if (m_hProv && !(m_dwFlagsStm & CSTM_DONTRELEASEPROV)) {
    //    CryptReleaseContext(m_hProv, 0);
    //}

#if defined(DEBUG) && !defined(MAC)
    SafeRelease(m_pstmDebugFile);
#endif

    if (m_psldData) {
        m_psldData->Release();
    }

    if (m_pbBuffer != NULL) {
        MemFree(m_pbBuffer);
    }
    
    SafeMemFree(m_pwszKeyPrompt);

    ReleaseObj(m_pSmimeCallback);
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CCAPIStm::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv) {
        return TrapError(E_INVALIDARG);
    }

    // Find IID
    if (IID_IUnknown == riid) {
        *ppv = THIS_AS_UNK;
    }
    else if (IID_IStream == riid) {
        *ppv = (IStream *)this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCAPIStm::AddRef(void)
{
    DOUT("CCAPIStm::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CCAPIStm::Release(void)
{
    DOUT("CCAPIStm::Release() %#x -> %d", this, m_cRef-1);
    if (0 == InterlockedDecrement((LPLONG)&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// IStream methods
//

STDMETHODIMP CCAPIStm::Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *plibNewPosition)
{
    if (!plibNewPosition) {
        return E_POINTER;
    }
    else {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = 0;
    }

    return S_OK;
}

////    CCAPIStm::Write
//
//  Description:
//      This function is called with the original message as the buffer
//      being written into this stream object.  We then make the appropriate
//      calls into the NT Crypto system in order to encrypt/decrypt the message.
//
//      Part of what this function needs to do is to interact with the
//      Crypto system in order to cause decryption of message to occur.

#ifndef WIN16
STDMETHODIMP CCAPIStm::Write(const void *pv, ULONG cb, ULONG *pcbActual)
#else
STDMETHODIMP CCAPIStm::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbActual)
#endif // !WIN16
{
    HRESULT hr;

    //
    //  Reset the return arg just incase
    //
    
    if (pcbActual != NULL) {
        *pcbActual = 0;
    }

    //
    //  If the CMS object is not still open, then we are dead and need to return an error.
    //
    
    if (!m_hMsg) {
        hr = CAPISTM_E_MSG_CLOSED;
        goto exit;
    }

    //
    //  Are we in the correct state to take anything.
    //
    
    switch (m_csStatus) {
        case STREAM_NOT_BEGUN:
            Assert(FALSE);              // Should never get here
            hr = CAPISTM_E_NOT_BEGUN;
            goto exit;
        case STREAM_DETACHED_OCCURING:
        case STREAM_QUESTION_TIME:
        case STREAM_SETUP_DECRYPT:
        case STREAM_OCCURING:
            break;
        case STREAM_ERROR:
            Assert(FALSE);              // Should never get here
            hr = CAPISTM_E_OVERDONE;
            goto exit;
        case STREAM_GOTTYPE:
            hr = CAPISTM_E_GOTTYPE;
            goto exit;

            //  We should go from QT to QTF in this function, and never come back
            //  until we have changed the state again.
        default:
            Assert(FALSE);
        case STREAM_QUESTION_TIME_FINAL:
            hr = E_UNEXPECTED;
            goto exit;
    }

#if defined(DEBUG) && !defined(MAC)
    //
    //  Flush the input buffer to disk so that we can debug it later if necessary
    //

    if (!m_pCapiInner && m_pstmDebugFile) {
        m_pstmDebugFile->Write((BYTE *)pv, cb, NULL);
    }
#endif

    //
    //  We need to start buffering data to make our messages shorter.  The output
    //  from the save code comes in one and two byte chucks often, we need to put
    //  the data out in larger blocks
    //

    if (m_pbBuffer != NULL) {
        //
        //  If we would overflow the buffer, then dump the cached buffer out
        //
        
        if (m_cbBuffer + cb > CbCacheBufferSize) {
            if (!CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, FALSE)) {
                // CryptMsgUpdate failed

                Assert(S_OK != HrGetLastError());
                hr = HrGetLastError();
                if (FAILED(hr)) {
                    m_csStatus = STREAM_ERROR;
                }
                goto exit;
            }
            m_cbBuffer = 0;
        }

        //
        //  If this buffer will over flow, then dump out just that item. Otherwise 
        //      we are just going to cache the buffer.
        //

        if (cb >= CbCacheBufferSize) {
            if (!CryptMsgUpdate(m_hMsg, (BYTE *) pv, cb, FALSE)) {
                // CryptMsgUpdate failed

                Assert(S_OK != HrGetLastError());
                hr = HrGetLastError();
                if (FAILED(hr)) {
                    m_csStatus = STREAM_ERROR;
                }
                goto exit;
            }
        }
        else {
            memcpy(m_pbBuffer + m_cbBuffer, pv, cb);
            m_cbBuffer += cb;
        }

        if (pcbActual != NULL) {
            *pcbActual = cb;
        }

        //
        //  The only time we should be here is when we are creating a new CMS object
        //      and thus all of the code below this is not relavent as we don't ever
        //      need to ask questions about what type of this message.
        //
        
        hr = S_OK;
        goto exit;
    }
    else {
        //
        //  Push the input buffer into the Crypto system.  On failures from the
        //  system we need to propigate the correct error state into our structure
        //  and into the return value.
        //

        if (!CryptMsgUpdate(m_hMsg, (BYTE *)pv, cb, FALSE)) {
            // CryptMsgUpdate failed

            Assert(S_OK != HrGetLastError());
            hr = HrGetLastError();
            if (FAILED(hr)) {
                m_csStatus = STREAM_ERROR;
            }
            goto exit;
        }
    }

    //
    // Since the CryptMsgUpdate call succeeded, return
    // a nice out param (specifically that we have consumed all of the passed
    // in bytes)
    //

    if (pcbActual) {
        *pcbActual = cb;
    }
    hr = S_OK;

    //
    // If we are in a state where we need to ask questions about the message,
    //  then proceed to do so.
    //

    if ((STREAM_QUESTION_TIME == m_csStatus) ||
        (STREAM_QUESTION_TIME_FINAL == m_csStatus)) {
        
        DWORD cbDWORD, dwMsgType;

        //  We should never be asking questions if encoding.
        Assert(m_dwFlagsStm & CSTM_DECODE);

        //
        //  Find out what security services have been placed onto this
        //      message object (if any).  If not enough bytes have been processed
        //      to find out what the encoding of the message is, then return
        //      success so we can get more bytes and get the question answered
        //      at a later date.
        //

        cbDWORD = sizeof(DWORD);
        if (!CryptMsgGetParam(m_hMsg, CMSG_TYPE_PARAM, 0, &dwMsgType, &cbDWORD)) {
            hr = HrGetLastError();
            Assert (S_OK != hr);
            if (CRYPT_E_STREAM_MSG_NOT_READY == hr) {
                hr = S_OK;
            }
            goto exit;
        }

        //  Since we are here, we must have a V1 type S/MIME message
        Assert(m_psldData);
        m_psldData->m_dwMsgEnhancement = MST_CLASS_SMIME_V1;
        hr = S_OK;

        //
        //  Set the correct flags based on the message type of the object we are
        //      decoding.
        //

        switch (dwMsgType) {
        case CMSG_ENVELOPED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_ENCRYPT;
            break;
        case CMSG_SIGNED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_BLOBSIGN;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            m_psldData->m_dwMsgEnhancement |= MST_THIS_BLOBSIGN | MST_THIS_ENCRYPT;
            break;

        default:
            // K this is a little rude.  not my iface error.
            hr = MIME_E_SECURITY_BADSECURETYPE;

            // just return the CAPI type if we don't recognize
            m_psldData->m_dwMsgEnhancement = dwMsgType;
            break;
        }

        //
        //  If all we are asking for is a type and we don't have any other errors,
        //      mark the fact that we got the type and return that fact as the
        //      error (to prevent futher buffers being written into us.)
        //

        if (CSTM_TYPE_ONLY & m_dwFlagsStm) {
            CSSDOUT("Got Type on typeonly call.");
            CSSDOUT("You will now see 80041417 failures; they're okay.");
            m_csStatus = STREAM_GOTTYPE;
            if (SUCCEEDED(hr)) {
                hr = CAPISTM_E_GOTTYPE;
            }
            goto exit;
        }

        //
        //  Change the object state based on the message type.  If we need to
        //      setup a decryption, then we need to mark the state for that.
        //      If we are just signing, then we can just let the rest of the
        //      streaming occur.
        //

        if (CMSG_ENVELOPED == dwMsgType) {
            m_csStatus = STREAM_SETUP_DECRYPT;
        }
        else {
            m_csStatus = STREAM_OCCURING;
        }
    }

    //
    //  If we need to set-up the message for decryption, then do so at this
    //  point.
    //

    Assert(SUCCEEDED(hr));
    if (STREAM_SETUP_DECRYPT == m_csStatus) {
        //  Can't decrypt detached messages
        Assert(!(m_dwFlagsStm & CSTM_DETACHED));

        //  We are now streaming the data out, on the assumption that the
        //      decryption stats.
        m_csStatus = STREAM_OCCURING;
        hr = HandleEnveloped();

        //  If we failed to decrypt, then re-map some errors and change the
        //      state back in the event that not all of the lock boxes have
        //      been seen yet.
        if (FAILED(hr)) {
            if (CRYPT_E_STREAM_MSG_NOT_READY == hr) {
                m_csStatus = STREAM_SETUP_DECRYPT;
                hr = S_OK;
            }
            else if (CS_E_CANT_DECRYPT == hr) {
                hr = MIME_E_SECURITY_CANTDECRYPT;
                // m_csStatus = STREAM_FINAL; // M00QUEST
            }
            else {
                if (CS_E_MSG_INVALID == hr) {
                    hr = MIME_E_SECURITY_CANTDECRYPT;
                }
                m_csStatus = STREAM_ERROR;
            }
            goto exit;
        }
    }

    hr = S_OK;

exit:
#ifdef DEBUG
    if (CAPISTM_E_GOTTYPE != hr) {
        return TrapError(hr);
    }
    else {
        return hr;  // don't spew this
    }
#else
    return hr;
#endif
}

///////////////////////////////////////////////////////////////////////////
//
// CCAPIStm public methods
//




/*  HrInnerInitialize:
**
**  Purpose:
**      the standard "my constructor can't return errors" function
**  Takes:
**      dwFlagsSEF  - Control Flags 
**      hwndParent  - modal UI parents to this
**      dwFlagsStm  - see capistm.h
**  Returns:
**      OLE_E_INVALIDHWND if you give me a bad window
**      MIME_E_SECURITY_NOOP if MST_NONE is the current psi type
**  Notes:
**      dwFlags is currently 0 for encode.  do it this way.
*/
HRESULT CCAPIStm::HrInnerInitialize(DWORD dwFlagsSEF, const HWND hwndParent,
                               DWORD dwFlagsStm, IMimeSecurityCallback * pCallback,
                               PSECURITY_LAYER_DATA psld)
{
    HRESULT hr = S_OK;

    //
    // Save the security layer data
    //

    if (psld)
    {
        psld->AddRef();
        m_psldData = psld;
    }
    else
    {
        IF_NULLEXIT(m_psldData = new(SECURITY_LAYER_DATA));
    }

    //
    // Save the flags
    //

    m_dwFlagsSEF = dwFlagsSEF;
    m_dwFlagsStm = dwFlagsStm;

    if (pCallback != NULL)
    {
        m_pSmimeCallback = pCallback;
        pCallback->AddRef();
    }

    //
    //  Make sure that if we have a window, it is a real window.
    //
    
    IF_TRUEEXIT((hwndParent && !IsWindow(hwndParent)), OLE_E_INVALIDHWND);

    //
    //  Shove the hwnd into any crypto provider we openned up.
    //
    
    CryptSetProvParam(NULL, PP_CLIENT_HWND, (BYTE *)&hwndParent, 0);
    m_hwnd = hwndParent;

exit:
    return hr;
    
}

/*  HrInitialize:
**
**  Purpose:
**      the standard "my constructor can't return errors" function
**  Takes:
**      dwFlagsSEF  - Control Flags 
**      hwndParent  - modal UI parents to this
**      fEncode     - trivial
**      psi         - message state information.  see smime.h
**      dwFlagsStm  - see capistm.h
**  Returns:
**      OLE_E_INVALIDHWND if you give me a bad window
**      MIME_E_SECURITY_NOOP if MST_NONE is the current psi type
**  Notes:
**      dwFlags is currently 0 for encode.  do it this way.
*/
HRESULT CCAPIStm::HrInitialize(DWORD dwFlagsSEF, const HWND hwndParent,
                               const BOOL fEncode, SMIMEINFO *const psi,
                               DWORD dwFlagsStm, IMimeSecurityCallback * pCallback,
                               PSECURITY_LAYER_DATA psld)
{
    HRESULT hr;


    // do the initialization common to all capi stream objects.
    CHECKHR(hr = HrInnerInitialize(dwFlagsSEF, hwndParent, dwFlagsStm, pCallback, psld));


    if (fEncode) {
        hr = BeginEncodeStreaming(psi);
    }
    else {
        hr = BeginDecodeStreaming(psi);
    }

exit:
    return TrapError(hr);
}



/*  EndStreaming:
**
**  Purpose:
**      Push CAPI's message state forward a notch
**  Returns:
**      HRESULT
*/
HRESULT CCAPIStm::EndStreaming()
{
    DWORD       dwMsgEnhancement = m_psldData->m_dwMsgEnhancement;
    HRESULT     hr = S_OK;
    PCMSG_ATTR  pUnprotectedAttrs = NULL;

    Assert(m_hMsg);


    //  If we are crurent in an error state then return
    if ((STREAM_ERROR == m_csStatus) || STREAM_GOTTYPE == m_csStatus) {
        goto exit;
    }

    //
    //  If we are decoding -- and we are doing a detached message we need
    //  to jump from the sign object to the real body here.
    //

    if ((CSTM_DECODE & m_dwFlagsStm) && (STREAM_DETACHED_OCCURING == m_csStatus)) {
        Assert(m_csStream == CSTM_STREAMING_DONE);

        // client has finished giving us the signature block
        m_csStatus = STREAM_OCCURING;
        m_csStream = CSTM_STREAMING;

        m_psldData->m_dwMsgEnhancement = MST_THIS_SIGN;

        CSSDOUT("Signature streaming finished.");
        if (! CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, TRUE)) {
            if ((hr = HrGetLastError()) == 0x80070000) {   // CAPI sometimes doesn't SetLastError
                hr = 0x80070000 | ERROR_ACCESS_DENIED;
            }
        }
        m_cbBuffer = 0;
        goto exit;
    }

    if (! CryptMsgUpdate(m_hMsg, m_pbBuffer, m_cbBuffer, TRUE)) {
        if ((hr = HrGetLastError()) == 0x80070000) {   // CAPI sometimes doesn't SetLastError
            hr = 0x80070000 | ERROR_ACCESS_DENIED;
        }
        goto exit;
    }
    m_cbBuffer = 0;

    if (m_dwFlagsStm & CSTM_DETACHED) {
        m_csStatus = STREAM_OCCURING;
    }

    //
    // do final streaming and verification
    //

    if (CSTM_DECODE & m_dwFlagsStm) {
        if (MST_THIS_SIGN & dwMsgEnhancement) {
            hr = VerifySignedMessage();
            if (FAILED(hr)) {
                goto exit;
            }
        } else {
            Assert(STREAM_OCCURING == m_csStatus);
            Assert(CSTM_STREAMING_DONE == m_csStream);
            if (g_FSupportV3 &&  (MST_THIS_ENCRYPT & dwMsgEnhancement)) {
                BOOL                f;
                DWORD               cbData = 0;
                LPBYTE              pb = NULL;
                
                f = CryptMsgGetParam(m_hMsg, CMSG_UNPROTECTED_ATTR_PARAM, 0, NULL, &cbData);
                if (!f) {
                    // Probably, message doesn't have a CMSG_UNPROTECTED_ATTR_PARAM
                    hr = HrGetLastError();
                    if(hr != CRYPT_E_ATTRIBUTES_MISSING)
                        goto exit;
                    else
                    {
                        hr = S_OK;
                        cbData = 0;
                    }
                }
                if (cbData != 0) {
                    if (!MemAlloc((LPVOID *) &pUnprotectedAttrs, cbData)) {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    f = CryptMsgGetParam(m_hMsg, CMSG_UNPROTECTED_ATTR_PARAM, 0, pUnprotectedAttrs, &cbData);
                    Assert(f);
                    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                             pUnprotectedAttrs, CRYPT_ENCODE_ALLOC_FLAG,
                                             &CryptEncodeAlloc, &pb, &cbData)) {
                        hr = HrGetLastError();
                        goto exit;
                    }
                    m_psldData->m_blobUnprotectAttrs.cbData = cbData;
                    m_psldData->m_blobUnprotectAttrs.pbData = pb;
                }
            }
        }
    }

    //
    // fill in some more of the data structure
    //

    if ((CSTM_DECODE & m_dwFlagsStm) &&
        (dwMsgEnhancement & MST_THIS_ENCRYPT)) {
        _SMimeCapsFromHMsg(m_hMsg, CMSG_ENVELOPE_ALGORITHM_PARAM,
                           &m_psldData->m_blobDecAlg.pBlobData,
                           &m_psldData->m_blobDecAlg.cbSize);
    }

    if (m_pCapiInner) {
        hr = m_pCapiInner->EndStreaming();
    }
exit:
    SafeMemFree(pUnprotectedAttrs);
    if (hr == ERROR_ACCESS_DENIED) {
        hr = E_ACCESSDENIED;    // convert CAPI error to OLE HRESULT
    }
    return(hr);
}

PSECURITY_LAYER_DATA CCAPIStm::GetSecurityLayerData() const
{
    if (m_psldData) {
        m_psldData->AddRef();
    }
    return(m_psldData);
}



///////////////////////////////////////////////////////////////////////////
//
// Implementation methods
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//
// Encode / Decode
//


HRESULT CCAPIStm::BeginEncodeStreaming(SMIMEINFO *const psi)
{
    DWORD                   cb;
    DWORD                   cbData;
    DWORD                   cCrls = 0;
    DWORD                   cCerts = 0;
    DWORD                   cSigners = 0;
    HRESULT                 hr;
    DWORD                   i;
    DWORD                   dwMsgType;
    DWORD                   dwFlags = 0;
    PCRYPT_KEY_PROV_INFO    pKPI;
    CMSG_STREAM_INFO        cmsi;
    DWORD                   dwPsiType;
    DWORD                   iSigner;
    PCRYPT_ATTRIBUTES       pattrsUnprot = NULL;
    PCRYPT_ATTRIBUTES *     rgpattrAuth = NULL;
    PCRYPT_ATTRIBUTES *     rgpattrUnauth = NULL;
#ifndef SMIME_V3
    PCRYPT_SMIME_CAPABILITIES pcaps = NULL;
#endif // SMIME_V3
    CMSG_RC2_AUX_INFO       rc2Aux;
    CRL_BLOB*               rgCrlBlob;
    PCRYPT_SMIME_CAPABILITIES * rgpcaps = NULL;
    CMSG_SIGNER_ENCODE_INFO *   rgSigner;
// #ifndef _WIN64
    union {
        struct {
// #endif
            // anything that comes first must be common (in size)
            // to both structures
            CERT_INFO**                 rgpCertInfo;
            CMSG_ENVELOPED_ENCODE_INFO  ceei;
// #ifndef _WIN64
        };
        struct {
// #endif
            CERT_BLOB*                  rgCertBlob;
            CMSG_SIGNED_ENCODE_INFO     csei;
// #ifndef _WIN64
        };
    };
// #endif

    ////////////
    // can only return from here down

    m_csStatus = STREAM_ERROR;
    rgSigner = NULL;

    if (!psi) {
        return E_POINTER;
    }

    //
    // Get the security operations to be performed on this body layer.
    //          we only care about the current body properties so mask out
    //          other layers.
    //  If we don't have any security to perform, then get out of here
    //
    
    dwPsiType = m_psldData->m_dwMsgEnhancement & MST_THIS_MASK;

    if (MST_NONE == dwPsiType) {
        AssertSz(dwPsiType != MST_NONE, "Why are we here if we have no security to apply?");
        return TrapError(MIME_E_SECURITY_NOOP);
    }

    //
    // detached is the only allowed user settable flag
    //
    
    if ((m_dwFlagsStm & CSTM_ALLFLAGS) & ~CSTM_DETACHED) {
        return TrapError(E_INVALIDARG);
    }

    rgCertBlob = NULL;
    rgCrlBlob = NULL;
    pKPI = NULL;

    ////////////
    // can goto end from here down

    //
    //  We should never be in a situation where we are going to both encrypt and sign
    //  a message.
    //
    
    AssertSz((!!(dwPsiType & MST_THIS_SIGN) +
              !!(dwPsiType & MST_THIS_ENCRYPT)) == 1,
             "Encrypt and Sign Same Layer is not legal");

    if (dwPsiType & MST_THIS_SIGN) {
        dwMsgType = CMSG_SIGNED;

        if (!(m_psldData->m_dwMsgEnhancement & MST_BLOB_FLAG)) {
            dwFlags |= CMSG_DETACHED_FLAG;
        }

        cSigners = m_psldData->m_cSigners;

        if (m_psldData->m_hcertstor != NULL) {
            hr = _InitEncodedCertIncludingSigners(m_psldData->m_hcertstor,
                                  cSigners, m_psldData->m_rgSigners,
                                  &rgCertBlob, &cCerts,
                                  &rgCrlBlob, &cCrls);
            if (FAILED(hr)) {
                goto exit;
            }
        }

        cb = sizeof(CMSG_SIGNER_ENCODE_INFO) * cSigners;
        if (!MemAlloc((LPVOID *) &rgSigner, cb)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgSigner, 0, cb);

        cb = sizeof(PCRYPT_SMIME_CAPABILITIES) * cSigners;
        if (!MemAlloc((LPVOID *) &rgpcaps, cb)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpcaps, 0, cb);

        if (!MemAlloc((LPVOID *) &rgpattrAuth, cSigners*sizeof(PCRYPT_ATTRIBUTES))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpattrAuth, 0, cSigners*sizeof(PCRYPT_ATTRIBUTES));

        if (!MemAlloc((LPVOID *) &rgpattrUnauth, cSigners*sizeof(PCRYPT_ATTRIBUTES))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset(rgpattrUnauth, 0, cSigners*sizeof(PCRYPT_ATTRIBUTES));

        for (iSigner=0; iSigner<cSigners; iSigner++) {
            rgSigner[iSigner].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
            rgSigner[iSigner].pvHashAuxInfo = NULL;

            //  We need to pull apart the algorithm used to sign the message so
            //     we can pass it down to the crypt32 code

            hr = HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobHashAlg.pBlobData,
                                m_psldData->m_rgSigners[iSigner].blobHashAlg.cbSize,
                                PKCS_SMIME_CAPABILITIES, 0, &cbData,
                                (LPVOID *)&rgpcaps[iSigner]);
            if (FAILED(hr)) {
                goto exit;
            }

            // MOOBUG -- MEMORY LEAK ON PCAPS!!!!

            Assert(rgpcaps[iSigner] != NULL);
            Assert(rgpcaps[iSigner]->cCapability == 1);
            rgSigner[iSigner].HashAlgorithm.pszObjId = rgpcaps[iSigner]->rgCapability[0].pszObjId;
            rgSigner[iSigner].HashAlgorithm.Parameters.cbData = rgpcaps[iSigner]->rgCapability[0].Parameters.cbData;
            rgSigner[iSigner].HashAlgorithm.Parameters.pbData = rgpcaps[iSigner]->rgCapability[0].Parameters.pbData;

            //
            //  Need to setup the attributes to attach to the signed message
            //

            if (m_psldData->m_rgSigners[iSigner].blobAuth.cbSize != 0) {
                cbData = 0;
                hr = HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobAuth.pBlobData,
                                    m_psldData->m_rgSigners[iSigner].blobAuth.cbSize,
                                    szOID_Microsoft_Attribute_Sequence, 0,
                                    &cbData, (LPVOID *)&rgpattrAuth[iSigner]);
                if (FAILED(hr)) {
                    goto exit;
                }

                if (rgpattrAuth[iSigner] != NULL) {
                    rgSigner[iSigner].cAuthAttr = rgpattrAuth[iSigner]->cAttr;
                    rgSigner[iSigner].rgAuthAttr = rgpattrAuth[iSigner]->rgAttr;
                    Assert(m_pattrAuth == NULL);
                    if (!g_FSupportV3) {
                        //  This code exists for old versions of crypt32.  Prior to
                        //  the NT5 re-write the capi code did not copy the attributes
                        //  but assumed that we must have done so.
                        m_pattrAuth = rgpattrAuth[iSigner];
                        rgpattrAuth[iSigner] = NULL;
                    }
                } else {
                    Assert(rgSigner[iSigner].cAuthAttr == 0);
                    Assert(rgSigner[iSigner].rgAuthAttr == NULL);
                }
            }

            if (m_psldData->m_rgSigners[iSigner].blobUnauth.cbSize != 0) {
                cbData = 0;
                HrDecodeObject(m_psldData->m_rgSigners[iSigner].blobUnauth.pBlobData,
                               m_psldData->m_rgSigners[iSigner].blobUnauth.cbSize,
                               szOID_Microsoft_Attribute_Sequence, 0,
                               &cbData, (LPVOID *)&rgpattrUnauth[iSigner]);
                if (FAILED(hr)) {
                    goto exit;
                }

                if (rgpattrUnauth[iSigner] != NULL) {
                    rgSigner[iSigner].cUnauthAttr = rgpattrUnauth[iSigner]->cAttr;
                    rgSigner[iSigner].rgUnauthAttr = rgpattrUnauth[iSigner]->rgAttr;
                } else {
                    Assert(rgSigner[iSigner].cUnauthAttr == 0);
                    Assert(rgSigner[iSigner].rgUnauthAttr == NULL);
                }
            }

            // load the provider information from the signing cert and then
            // acquire that provider with the appropriate key container

            hr = HrGetCertificateParam(m_psldData->m_rgSigners[iSigner].pccert,
                                       CERT_KEY_PROV_INFO_PROP_ID,
                                       (LPVOID *) &pKPI, NULL);
            if (FAILED(hr)) {
                goto gle;
            }

            if (!m_hProv && ! CRYPT_ACQUIRE_CONTEXT(&m_hProv, pKPI->pwszContainerName,
                                        pKPI->pwszProvName, pKPI->dwProvType,
                                        pKPI->dwFlags)) {
                goto gle;
            }
            Assert(0 == pKPI->cProvParam);

#ifdef SMIME_V3
            if (psi->pwszKeyPrompt != NULL) {
                CryptSetProvParam(m_hProv, PP_UI_PROMPT, (LPBYTE) psi->pwszKeyPrompt, 0);
            }
#endif // SMIME_V3

            rgSigner[iSigner].pCertInfo = m_psldData->m_rgSigners[iSigner].pccert->pCertInfo;
            rgSigner[iSigner].hCryptProv = m_hProv;
            rgSigner[iSigner].dwKeySpec = pKPI->dwKeySpec;

            //
            //  Need to change dsa to dsa-with-sha1
            //

            if (strcmp(rgSigner[iSigner].pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId, szOID_OIWSEC_dsa) == 0) {
                rgSigner[iSigner].HashEncryptionAlgorithm.pszObjId = szOID_OIWSEC_dsaSHA1;
            }
        }

        csei.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        csei.cSigners = m_psldData->m_cSigners;
        csei.rgSigners = rgSigner;
        csei.cCertEncoded = cCerts;
        csei.rgCertEncoded = rgCertBlob;
        csei.cCrlEncoded = cCrls;
        csei.rgCrlEncoded = rgCrlBlob;
    }
    
    //
    //  If it is not signed, then it must be encrypted.  Setup the calls for
    //  performing an encryption operation.
    //
    else {
        Assert((dwPsiType & MST_THIS_ENCRYPT) != 0);
        
        dwMsgType = CMSG_ENVELOPED;

        //
        //  If we are given a CSP, then we are going to pass it on to the Crypt32 code,
        //      However it turns out that we are the ones who release the CSP so store it
        //      locally into the class object.
        //

        Assert(m_hProv == NULL);
        m_hProv = psi->hProv;
        psi->hProv = NULL;

        //
        //  Extract out the bulk encryption algorithm we are going to apply to
        //      the body of the message.  This algorithm is the same across all
        //      the different key transfer algorthms.
        //

        //
        //  Setup the structure containing all of the encryption parameters for the 
        //      Message Encode function.  This structure gets setup differently
        //      depending on the version of Crypt32 which we are running on.
        //
        
        memset(&ceei, 0, sizeof(ceei));
        ceei.cbSize = sizeof(CMSG_ENVELOPED_ENCODE_INFO);
        ceei.hCryptProv = m_hProv;
        ceei.ContentEncryptionAlgorithm = m_psldData->m_ContentEncryptAlgorithm;
        ceei.pvEncryptionAuxInfo = m_psldData->m_pvEncryptAuxInfo;

        if (g_FSupportV3) {
            ceei.cRecipients = m_psldData->m_cEncryptItems;
            ceei.rgCmsRecipients = m_psldData->m_rgRecipientInfo;

            if (m_psldData->m_blobUnprotectAttrs.cbData > 0) {
                CHECKHR(hr = HrDecodeObject(m_psldData->m_blobUnprotectAttrs.pbData,
                                            m_psldData->m_blobUnprotectAttrs.cbData,
                                            szOID_Microsoft_Attribute_Sequence, 0,
                                            &cbData, (LPVOID *) &pattrsUnprot));
                ceei.cUnprotectedAttr = pattrsUnprot->cAttr;
                ceei.rgUnprotectedAttr = pattrsUnprot->rgAttr;
            }

            //
            //  Allow for certificates to be carried on the encryption package now
            //  need this for Fortezza static-static implementation.
            //
            
            if (m_psldData->m_hstoreEncrypt != NULL) {
                hr = _InitEncodedCert(m_psldData->m_hstoreEncrypt, &rgCertBlob, &cCerts,
                                      &rgCrlBlob, &cCrls);
                if (FAILED(hr)) {
                    goto exit;
                }

                ceei.cCertEncoded = cCerts;
                ceei.rgCertEncoded = rgCertBlob;
                ceei.cCrlEncoded = cCrls;
                ceei.rgCrlEncoded = rgCrlBlob;
            }
        }
        else {
            PCERT_INFO        pinfo;
            
            if (!MemAlloc((LPVOID *) &ceei.rgpRecipients,
                          (sizeof(CERT_INFO) + sizeof(PCERT_INFO)) * m_psldData->m_cEncryptItems)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(ceei.rgpRecipients, 0,
                   (sizeof(CERT_INFO) + sizeof(PCERT_INFO)) * m_psldData->m_cEncryptItems);
            ceei.cRecipients = m_psldData->m_cEncryptItems;
            pinfo = (PCERT_INFO) ((ceei.cRecipients * sizeof(PCERT_INFO)) +
                                  (LPBYTE) ceei.rgpRecipients);

            for (i=0; i<ceei.cRecipients; i++, pinfo++) {
                ceei.rgpRecipients[i] = pinfo;
                
                Assert(m_psldData->m_rgRecipientInfo[i].dwRecipientChoice == CMSG_KEY_TRANS_RECIPIENT);

                pinfo->SubjectPublicKeyInfo.Algorithm = m_psldData->m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm;
                pinfo->SubjectPublicKeyInfo.PublicKey = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey;

                
                Assert(m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_ISSUER_SERIAL_NUMBER);
                pinfo->Issuer = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer;
                pinfo->SerialNumber = m_psldData->m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber;
            }
        }
    }

    // Do we need to recurse and wrap ourselves in an Outer Layer?
    if (m_psldData->m_psldOuter) {
        CSSDOUT("Streaming wrapped message (type: %x)", m_psldData->m_psldOuter->m_dwMsgEnhancement);

        hr = InitInner(psi, NULL, m_psldData->m_psldOuter);
        if (FAILED(hr)) {
            goto exit;
        }

        // This will write the header to the new inner CAPI stream
        if (m_pstmOut) {
            CONVINITINFO ci = {0};

            // Create a conversion stream
            ci.ietEncoding = IET_BASE64;
            ci.fEncoder = TRUE;
            TrapError(HrCreateInternetConverter(&ci, &m_pConverter));

            m_pstmOut->Write(s_cszMimeHeader, sizeof(s_cszMimeHeader)-1, NULL);
            if (m_psldData->m_dwMsgEnhancement & MST_THIS_ENCRYPT) {
                m_pstmOut->Write(STR_SMT_ENVELOPEDDATA,
                                 lstrlen(STR_SMT_ENVELOPEDDATA), NULL);
            }
            else {
                if ((psi->pszInnerContent != NULL) &&
                    (strcmp(psi->pszInnerContent,
                            szOID_SMIME_ContentType_Receipt) == 0)) {
                    m_pstmOut->Write(STR_SMT_SIGNEDRECEIPT,
                                     lstrlen(STR_SMT_SIGNEDRECEIPT), NULL);
                }
                else {
                    m_pstmOut->Write(STR_SMT_SIGNEDDATA,
                                     lstrlen(STR_SMT_SIGNEDDATA), NULL);
                }
            }

            m_pstmOut->Write(c_szCRLF,          lstrlen(c_szCRLF), NULL);
            m_pstmOut->Write(STR_HDR_CNTXFER,   lstrlen(STR_HDR_CNTXFER), NULL);
            m_pstmOut->Write(c_szColonSpace,    lstrlen(c_szColonSpace), NULL);
            if (m_pConverter) {
                m_pstmOut->Write(STR_ENC_BASE64,    lstrlen(STR_ENC_BASE64), NULL);
            } else {
                // Failed to create the conversion stream.  Try sending binary anyway.
                // (Netscape can't read it, but most others can.)
                m_pstmOut->Write(STR_ENC_BINARY,    lstrlen(STR_ENC_BINARY), NULL);
            }
            m_pstmOut->Write(c_szCRLF,          lstrlen(c_szCRLF), NULL);
            m_pstmOut->Write(s_cszMimeHeader2,  sizeof(s_cszMimeHeader2)-1, NULL);
            m_pstmOut->Write(c_szCRLFCRLF,      lstrlen(c_szCRLFCRLF), NULL);
        }
    }

    //
    //  Since the write code is so bad for buffering, lets do the buffering here.
    //  Ignore all errors on return, if the buffer is not allocated then we just
    //  get the same poor performance as before.
    //

    MemAlloc((LPVOID *) &m_pbBuffer, CbCacheBufferSize);

    //
    //

    if (psi->pszInnerContent != NULL) {
        cmsi.cbContent = psi->cbInnerContent;
    }
    else {
        cmsi.cbContent = (DWORD) -1;    // indefinite-lenght BER encoding
    }
    cmsi.pfnStreamOutput = CBStreamOutput;
    cmsi.pvArg = (void *)this;

    m_hMsg = CryptMsgOpenToEncode(
                                  CRYPT_ASN_ENCODING|PKCS_7_ASN_ENCODING,
                                  CMSG_CMS_ENCAPSULATED_CONTENT_FLAG | dwFlags,
                                  dwMsgType,                                
//                                  (dwMsgType == CMSG_SIGNED) ? ((void *) &csei) : ((void *) &ceei),      // really depends on the union
                                  &ceei, 
                                  psi->pszInnerContent,
                                  &cmsi);
    if (! m_hMsg) {
        goto gle;
    }

    //
    //  Put the top level into either DETACHED or STREAM based on if we are
    //  doing detached signing or blob signing/encryption.
    //
    //  Put the low level stream into the write through state so it moves all
    //  data out to the output stream. (If no output stream then mark as no
    //  output streaming.)
    //

    m_csStatus = (m_dwFlagsStm & CSTM_DETACHED) ? STREAM_DETACHED_OCCURING : STREAM_OCCURING;
    m_csStream = m_pstmOut ? CSTM_STREAMING : CSTM_GOTTYPE;
    hr = S_OK;

exit:
    if (!g_FSupportV3 && (dwPsiType & MST_THIS_ENCRYPT)) {
        MemFree(ceei.rgpRecipients);
    }
    
    ReleaseMem(pKPI);
    if (rgCertBlob)  {
        g_pMoleAlloc->Free(rgCertBlob);  //also rgpCertInfo
    }
    if (rgCrlBlob)  {
        g_pMoleAlloc->Free(rgCrlBlob);
    }
    if (rgpcaps != NULL) {
        for (iSigner=0; iSigner<cSigners; iSigner++) {
            MemFree(rgpcaps[iSigner]);
        }
        MemFree(rgpcaps);
    }
    SafeMemFree(rgSigner);
    SafeMemFree(pattrsUnprot);
    for (iSigner=0; iSigner<cSigners; iSigner++) {
        SafeMemFree(rgpattrAuth[iSigner]);
        SafeMemFree(rgpattrUnauth[iSigner]);
    }
    SafeMemFree(rgpattrAuth);
    SafeMemFree(rgpattrUnauth);

    Assert(m_hMsg || S_OK != hr);
    return TrapError(hr);
gle:
    hr = HrGetLastError();
    goto exit;
}

HRESULT CCAPIStm::BeginDecodeStreaming(
    SMIMEINFO *const  psi)
{
    CMSG_STREAM_INFO    cmsi;

    if (CSTM_TYPE_ONLY & m_dwFlagsStm) {
        if (CSTM_DETACHED & m_dwFlagsStm) {
            return E_INVALIDARG;
        }
    }

    m_dwFlagsStm |= CSTM_DECODE;

    if (psi) {
        // SMIME3: if there is a cert in the associated layer data, duplicate it up here.
        // BUGBUG: NYI

        m_hProv = psi->hProv;
        psi->hProv = NULL;

        // Copy the array of cert stores up here
        if (psi->cStores) {
            m_rgStores = (HCERTSTORE*)g_pMalloc->Alloc(psi->cStores * sizeof(HCERTSTORE));
            if (! m_rgStores) {
                return(E_OUTOFMEMORY);
            }

            for (DWORD i = 0; i < psi->cStores; i++) {
                m_rgStores[i] = CertDuplicateStore(psi->rgStores[i]);
            }
            m_cStores = psi->cStores;
        }
// HACK!!! HACK!!!! for WIN64
#ifndef _WIN64
#ifdef SMIME_V3
        UNALIGNED WCHAR *wsz = psi->pwszKeyPrompt;
        if (wsz != NULL) {
            m_pwszKeyPrompt = PszDupW((LPCWSTR) wsz);
            if (m_pwszKeyPrompt == NULL) {
                return(E_OUTOFMEMORY);
            }
        }
#endif // SMIME_V3
#endif //_WIN64
    }


    cmsi.cbContent = (DWORD)-1;  // indefinite-length BER encoding
    cmsi.pfnStreamOutput = CBStreamOutput;
    cmsi.pvArg = (void *)this;

    m_hMsg = CryptMsgOpenToDecode(
      CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
      (m_dwFlagsStm & CSTM_DETACHED) ? CMSG_DETACHED_FLAG : 0,
      0,          // don't know the type
      m_hProv,    // needed for verify, but not decrypt
      NULL,       // pRecipientInfo
      &cmsi);

    if (m_hMsg) {
        m_csStatus = (m_dwFlagsStm & CSTM_DETACHED) ? STREAM_DETACHED_OCCURING : STREAM_QUESTION_TIME;
    } else {
        m_csStatus = STREAM_ERROR;
    }

    Assert(m_hMsg || S_OK != HrGetLastError());
    return m_hMsg ? S_OK : HrGetLastError();
}


///////////////////////////////////////////////////////////////////////////
//
// Callback and helpers/crackers
//


BOOL WINAPI CCAPIStm::CBStreamOutput(
    const void *pvArg,
    BYTE *pbData,
    DWORD cbData,
    BOOL fFinal)
{
    Assert(pvArg);
    return((CCAPIStm*)pvArg)->StreamOutput(pbData, cbData, fFinal);
}


BOOL CCAPIStm::StreamOutput(
    BYTE *  pbData,
    DWORD   cbData,
    BOOL    fFinal)
{
    HRESULT             hr = S_OK;
    int                 iEOH;
#ifdef SMIME_V3
    LPSTR               szContentType = NULL;
#endif // SMIME_V3

    // m_csStream should be one of the CSTM states at this point, if not then
    //          we are in error.

    Assert((m_csStream == CSTM_GOTTYPE) || (m_csStream == CSTM_FIRST_WRITE) ||
           (m_csStream == CSTM_TEST_NESTING) || (m_csStream == CSTM_STREAMING));

    //  If all we are doing is looking for the type, then we know that
    //  we already have one at this point.  There is no need to put the
    //  output of the Crypto code anyplace as it is not part of what we
    //  are looking for.

    if (CSTM_GOTTYPE == m_csStream) {
        return TRUE;
    }

    //  If we have no output stream, then all we need to do is the state
    //  transistion on fFinal being true.
    if (m_pstmOut == NULL) {
        if (fFinal) {
            m_csStream = CSTM_STREAMING_DONE;
        }
        return TRUE;
    }

    //
    // Test for an enclosed opaque S/MIME message
    // the client doesn't care about this level of goo, so hide it and
    // stream this data into a new CAPIStm, letting it stream out the
    // real stuff.
    //

    if (CSTM_FIRST_WRITE == m_csStream) {
        // this is the position of the beginning of any
        // possible MIME header
        if (FAILED(HrGetStreamPos(m_pstmOut, &m_cbBeginWrite)) ||
            FAILED(HrGetStreamSize(m_pstmOut, &m_cbBeginSize))) {
            m_cbBeginWrite = 0;
            m_cbBeginSize = 0;
        } else {
            // reset position
            HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
        }

        m_csStream = CSTM_TEST_NESTING;
#ifdef SMIME_V3
        if (szContentType = (LPSTR)PVGetMsgParam(m_hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, NULL, NULL)) {
            if (lstrcmp(szOID_PKCS_7_DATA, szContentType)) {
                hr = m_pstmOut->Write(s_cszOIDMimeHeader1, strlen(s_cszOIDMimeHeader1), NULL);
                if (SUCCEEDED(hr)) {
                    hr = m_pstmOut->Write(szContentType, strlen(szContentType), NULL);
                }                    
                if (SUCCEEDED(hr)) {
                    hr = m_pstmOut->Write(s_cszOIDMimeHeader2, strlen(s_cszOIDMimeHeader2), NULL);
                }          
                if (FAILED(hr)) {
                    return FALSE;
                }
                m_csStream = CSTM_STREAMING;
            }
        }
#endif // SMIME_V3
        
    }

    if (CSTM_TEST_NESTING == m_csStream &&
        (-1 != (iEOH = SniffForEndOfHeader(pbData, cbData)))) {
        CMimePropertyContainer *pContHeader;

        // get the position of the first char of the body
        iEOH = cbData - iEOH + 1;

        pContHeader = new CMimePropertyContainer;
        if (pContHeader) {
            hr = pContHeader->InitNew();
            if (SUCCEEDED(hr)) {
                ULONG posCurrent;

                // write out the last bit of the header data
                // then move back to the header's start after
                // saving our current position
                hr = m_pstmOut->Write(pbData, iEOH, NULL);
                if (SUCCEEDED(hr)) {
                    // fixup the amount of data in pbData so
                    // only body stuff gets written to the stream
                    // . . . we've already written the header
                    pbData += iEOH;
                    cbData -= iEOH;

                    HrGetStreamPos(m_pstmOut, &posCurrent);
                    HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
                    hr = pContHeader->Load(m_pstmOut);
#ifdef DEBUG
                    BYTE *pbHeader;
                    DWORD cbHeader;
                    HrStreamToByte(m_pstmOut, &pbHeader, &cbHeader);
                    SafeMemFree(pbHeader);
#endif
                    // if we don't have an inner message, need to reset
                    // the stream back to where we were
                    HrStreamSeekSet(m_pstmOut, posCurrent);
                }
            }
            if (SUCCEEDED(hr)) {
                CSSDOUT("Loaded an inner header.");
                if (IsOpaqueSecureContentType(pContHeader)) {
                    CSSDOUT("Sniffed an inner PKCS#7.");

                    // the HandleNesting call will reset m_pstmOut
                    TrapError(HandleNesting(pContHeader));
                }

                m_csStream = CSTM_STREAMING;
            }
#ifdef DEBUG
            else {
                CSSDOUT("Load of inner header failed.");
            }
#endif
            pContHeader->Release();
        }
    }

    if (fFinal) {
        m_csStream = CSTM_STREAMING_DONE;
    }

    if (m_pConverter) {
        BLOB blob;

        blob.pBlobData = pbData;
        blob.cbSize = cbData;

        hr = m_pConverter->HrFillAppend(&blob);
        if (SUCCEEDED(hr)) {
            if (m_dwFlagsStm & CSTM_DECODE) {
                hr = m_pConverter->HrInternetDecode(fFinal);
            }
            else {
                hr = m_pConverter->HrInternetEncode(fFinal);
            }
        }
        if (SUCCEEDED(hr)) {
            hr = m_pConverter->HrWriteConverted(m_pstmOut);
        }
        else {
            hr = m_pstmOut->Write(pbData, cbData, NULL);
        }
    }
    else {
        hr = m_pstmOut->Write(pbData, cbData, NULL);
    }

#ifdef SMIME_V3
    MemFree(szContentType);
#endif // SMIME_V3
    return SUCCEEDED(hr) ? TRUE : FALSE;
}


/*  SniffForEndOfHeader:
**
**  Purpose:
**      see if we have accumulated two blank lines in a row
**  Takes:
**      a buffer to scan and size of the buffer
**  Returns:
**      number of characters from the end of the second \n
*/
int CCAPIStm::SniffForEndOfHeader(
    BYTE *  pbData,
    DWORD   cbData)
{
    BOOL fCR, fEOL;

    // state is saved b/c the double blank could cross
    // a buffer chunk's boundary

    // restore old state and also reset
    fCR = m_dwFlagsStm & CSTM_HAVECR;
    fEOL = m_dwFlagsStm & CSTM_HAVEEOL;
    if (fCR || fEOL) {
        m_dwFlagsStm &= ~(CSTM_HAVECR | CSTM_HAVEEOL);
    }

    while (cbData) {
        if (chCR == *pbData) {
            fCR = TRUE;
        }
        else if (fCR && (chLF == *pbData)) {
            if (fEOL) {
                // double blank line
                return cbData;
            }
            fCR = FALSE;
            fEOL = TRUE;
        }
        else {
            fCR = FALSE;
            fEOL = FALSE;
        }
        pbData++;
        cbData--;
    }

    // state was reset above.  persist if we need to.
    if (fCR || fEOL) {
        m_dwFlagsStm |= (fCR ? CSTM_HAVECR : 0) | (fEOL ? CSTM_HAVEEOL : 0);
    }
    return -1;
}

HRESULT CCAPIStm::HandleNesting(CMimePropertyContainer *pContHeader)
{
    ENCODINGTYPE    iet;

    iet = pContHeader->GetEncodingType();
    if (!(IET_BINARY == iet || IET_7BIT == iet || IET_8BIT == iet)) {
        CONVINITINFO    ciiDecode;

        // we actually need to decode

        ciiDecode.dwFlags = 0;
        ciiDecode.ietEncoding = iet;
        ciiDecode.fEncoder = FALSE;

        TrapError(HrCreateInternetConverter(&ciiDecode, &m_pConverter));
    }
    return InitInner();
}

HRESULT CCAPIStm::InitInner()
{
    SMIMEINFO       siBuilt;
    ULARGE_INTEGER  liSize;

    // Init siBuilt
    memset(&siBuilt, 0, sizeof(siBuilt));

    // now also fixup the stream back to a near original
    // state.  if for some reason the data written after
    // now is smaller than the header is, this
    // work will make sure we don't keep bits of the header
    HrStreamSeekSet(m_pstmOut, m_cbBeginWrite);
    liSize.LowPart = m_cbBeginSize;
    liSize.HighPart = m_cbBeginWrite;
    m_pstmOut->SetSize(liSize);

    siBuilt.hProv = m_hProv;

#ifdef OLD_STUFF
    // BUGBUG: Is something like this needed?
    siBuilt.ssEncrypt.pcDecryptionCert = m_pUserCertDecrypt;
#endif // OLD_STUFF

    siBuilt.cStores = m_cStores;
    siBuilt.rgStores = m_rgStores;
    return InitInner(&siBuilt);
}


HRESULT CCAPIStm::InitInner(
    SMIMEINFO *const    psi,
    CCAPIStm *          pOuter,
    PSECURITY_LAYER_DATA psldOuter)
{
    HRESULT     hr;

    if (! pOuter) {
        m_pCapiInner = new CCAPIStm(m_pstmOut);

        CHECKHR(hr = m_pCapiInner-> HrInnerInitialize(m_dwFlagsSEF, m_hwnd, m_dwFlagsStm, m_pSmimeCallback, psldOuter));

        if (!psldOuter) {
            // Hook up the chain of Security Layer Data objects.
            Assert(! m_psldData->m_psldInner);
            m_pCapiInner->m_psldData->AddRef();
            m_psldData->m_psldInner = m_pCapiInner->m_psldData;
            if (m_pCapiInner->m_psldData) {
                // Init the Up pointer of the new layer data
                m_pCapiInner->m_psldData->m_psldOuter = m_psldData;
            }
        }

        // recurse
        return m_pCapiInner->InitInner(psi, this, psldOuter);
    }

    Assert(!m_pCapiInner);
    Assert(pOuter);
    Assert(psi);

    m_dwFlagsStm = pOuter->m_dwFlagsStm & CSTM_ALLFLAGS;


    // This will get me involved
    ReleaseObj(pOuter->m_pstmOut);
    pOuter->m_pstmOut = (IStream*)this;
    AddRef();   // outer is holding 1

    m_dwFlagsStm |= CSTM_RECURSED;
    if (pOuter->m_dwFlagsStm & CSTM_DECODE) {
        hr = BeginDecodeStreaming(psi);
    }
    else {
        // don't support detached inner CRYPTMSGs
        m_dwFlagsStm &= ~CSTM_DETACHED;

        hr = BeginEncodeStreaming(psi);
    }
    m_dwFlagsStm &= ~CSTM_RECURSED;

exit:
    return hr;
}


//
// Gets the immediate outermost decryption cert (if any).
//
PCCERT_CONTEXT CCAPIStm::GetOuterDecryptCert()
{
    PCCERT_CONTEXT       pccertDecrypt = NULL;
    PSECURITY_LAYER_DATA psldOuter = NULL;

    Assert(NULL != m_psldData);
    if (NULL != m_psldData) {
        psldOuter = m_psldData->m_psldOuter;    
    }
    
    while (NULL != psldOuter) {
        if (NULL != psldOuter->m_pccertDecrypt) {
            Assert( MST_ENCRYPT_MASK & (psldOuter->m_dwMsgEnhancement) );
            pccertDecrypt = psldOuter->m_pccertDecrypt;
            break;
        }
        psldOuter = psldOuter->m_psldOuter;
    }
    
    return pccertDecrypt;
}

HCERTSTORE
OpenAllStore(
    IN DWORD cStores,
    IN HCERTSTORE rgStores[],
    IN OUT HCERTSTORE *phCertStoreAddr,
    IN OUT HCERTSTORE *phCertStoreCA,
    IN OUT HCERTSTORE *phCertStoreMy,
    IN OUT HCERTSTORE *phCertStoreRoot
    )
{
    HCERTSTORE hstoreAll;
    DWORD i;

    hstoreAll = CertOpenStore(CERT_STORE_PROV_COLLECTION, X509_ASN_ENCODING,
                              NULL, 0, NULL);
    if (hstoreAll == NULL) {
        return NULL;
    }


    for (i=0; i<cStores; i++) {
        CertAddStoreToCollection(hstoreAll, rgStores[i], 0, 0);
    }

    //  Open the standard system stores

    *phCertStoreAddr = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING,
                                   NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                   s_cszWABCertStore);
    if (*phCertStoreAddr != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreAddr, 0, 0);
    }

    *phCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, s_cszMy);
    if (*phCertStoreMy != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreMy, 0, 0);
    }
    
    *phCertStoreCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, s_cszCA);
    if (*phCertStoreCA != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreCA, 0, 0);
    }

    *phCertStoreRoot = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, X509_ASN_ENCODING, NULL,
                                 CERT_SYSTEM_STORE_CURRENT_USER, "Root");
    if (*phCertStoreRoot != NULL) {
        CertAddStoreToCollection(hstoreAll, *phCertStoreRoot, 0, 0);
    }

    return hstoreAll;
}

///////////////////////////////////////////////////////////////////////////
//
// The enveloped and signed message parsers
//


/*  VerifySignedMessage:
**
**  Purpose:
**      Using CAPI, this loads the certs from the message and tests to find
**      the one hopefully used to sign the message.  CAPI builds a new hash
**      using this cert and compares it with the hash from the SignerInfo.
**  Takes:
**      IN hMsg     - built CAPI message containing cyphertext
**      OUT psi     - certificate used for signing, and if it was part of hMsg
**      OUT OPTIONAL pPlain  - blob containing cleartext
**  Returns:
**      MIME_E_SECURITY_MULTSIGNERS if cSigners > 1.  We can't deal.
**      MIME_E_SECURITY_BADCONTENT if I don't understand the message type of the
**          inner data
**      else S_OK or E_FAIL
*/
HRESULT CCAPIStm::VerifySignedMessage()
{
    CRYPT_SMIME_CAPABILITIES cap;
    DWORD               cbData = 0;
    DWORD               cCerts;
    DWORD               cSigners = 0;
    DWORD               dexStore;
    BOOL                f;
#ifdef SMIME_V3    
    BOOL                fLookForReceiptRequest = TRUE;
#endif // SMIME_V3    
    HCERTSTORE          hCertStoreAddr = NULL;
    HCERTSTORE          hCertStoreCA = NULL;
    HCERTSTORE          hCertStoreMy = NULL;
    HCERTSTORE          hCertStoreRoot = NULL;
    HCERTSTORE          hMsgCertStore = NULL;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               iSigner;
#ifdef SMIME_V3
    DWORD               iSignData;
    CRYPT_ATTR_BLOB     attrReceiptReq = {0};
    CRYPT_ATTR_BLOB     attrSecLabel = {0};
    DWORD               cblabel;
    CMSG_CMS_SIGNER_INFO                cmsSignerInfo;
    DWORD                               dwCtrl;
    HCERTSTORE                          hstoreAll = NULL;
    PSMIME_RECEIPT_REQUEST preq = NULL;
    PSMIME_SECURITY_LABEL  plabel = NULL;
    CMSG_CMS_SIGNER_INFO *              pCmsSignerInfo = NULL;
    LPVOID                              pv;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA  verifySignature;
#endif // SMIME_V3    
    PCCERT_CONTEXT      pccertSigner = NULL;
    SignerData *        pSignerData = NULL;
    PCMSG_SIGNER_INFO   pSignerInfo = NULL;
    CERT_INFO           SignerId;
    LPSTR               szContentType = NULL;

    Assert(m_hMsg);
    Assert(m_psldData->m_fCertInLayer == FALSE);

    // Get the number of signers
    cbData = sizeof(cSigners);
    f = CryptMsgGetParam(m_hMsg, CMSG_SIGNER_COUNT_PARAM, 0, &cSigners, &cbData);
    if (!f) {
        goto CryptoError;
    }
    if (cSigners == 0) {
        hr = MIME_E_NO_SIGNER;
        goto ErrorReturn;
    }

    // Allocate space to hold the signer information

    if (!MemAlloc((LPVOID *) &pSignerData, cSigners * sizeof(SignerData))) {
        hr = E_OUTOFMEMORY;
        goto ErrorReturn;
    }
    m_psldData->m_rgSigners = pSignerData;
    m_psldData->m_cSigners = cSigners;

    //  Initialized to a known state
    memset(pSignerData, 0, cSigners * sizeof(SignerData));
    for (i=0; i<cSigners; i++) {
        pSignerData[i].ulValidity = MSV_UNVERIFIABLE;
    }

    // If there are certificates in the message, get a store provider which
    //  maps to the certificates in the message for later lookup.

    Assert(sizeof(cCerts) == cbData);
    f = CryptMsgGetParam(m_hMsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbData);
    Assert(f);

    if (f && cCerts) {
        // since there are certs included, let's try them first when matching
        // certs with signers.

        // get the store set
        // make sure we keep hold of our provider
        hMsgCertStore = CertOpenStore(CERT_STORE_PROV_MSG, X509_ASN_ENCODING,
                                      m_hProv, 0, m_hMsg);
        if (hMsgCertStore) {
            m_dwFlagsStm |= CSTM_DONTRELEASEPROV;  // given unto the store
        }

        // if it failed, we just don't have a store then
        Assert(hMsgCertStore != NULL);
        m_psldData->m_hcertstor = CertDuplicateStore(hMsgCertStore);
    }

    //
    //  Walk through each and every signature attempting to verify each signature
    //

    for (iSigner=0; iSigner<cSigners; iSigner++, pSignerData++) {
        //  Preconditions
        Assert(pccertSigner == NULL);

        // release the signer info from the previous iteration.
        SafeMemFree(pSignerInfo);
        if (pCmsSignerInfo != &cmsSignerInfo) {
            SafeMemFree(pCmsSignerInfo);
        }

        // get the issuer and serial number from the ith SignerInfo
        if (g_FSupportV3) {
            hr = HrGetMsgParam(m_hMsg, CMSG_CMS_SIGNER_INFO_PARAM, iSigner,
                               (LPVOID *) &pCmsSignerInfo, NULL);
            if (FAILED(hr)) {
                goto ErrorReturn;
            }
        }
        else {
            hr = HrGetMsgParam(m_hMsg, CMSG_SIGNER_INFO_PARAM, iSigner,
                               (LPVOID *) &pSignerInfo, NULL);
            if (FAILED(hr)) 
            {
                goto ErrorReturn;
            }
            cmsSignerInfo.dwVersion = pSignerInfo->dwVersion;
            cmsSignerInfo.SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            cmsSignerInfo.SignerId.IssuerSerialNumber.Issuer = pSignerInfo->Issuer;
            cmsSignerInfo.SignerId.IssuerSerialNumber.SerialNumber = pSignerInfo->SerialNumber;
            cmsSignerInfo.HashAlgorithm = pSignerInfo->HashAlgorithm;
            cmsSignerInfo.HashEncryptionAlgorithm = pSignerInfo->HashEncryptionAlgorithm;
            cmsSignerInfo.EncryptedHash = pSignerInfo->EncryptedHash;
            cmsSignerInfo.AuthAttrs = pSignerInfo->AuthAttrs;
            cmsSignerInfo.UnauthAttrs = pSignerInfo->UnauthAttrs;

            pCmsSignerInfo = &cmsSignerInfo;

            // (post-SDR)
            // Build up IASN

            SignerId.Issuer = pSignerInfo->Issuer;
            SignerId.SerialNumber = pSignerInfo->SerialNumber;
        }

        // Our best bet to easily find a certificate is in the message provided
        //      list of certificates.

        if (hMsgCertStore) {
            if (g_FSupportV3) {
                pccertSigner = CertFindCertificateInStore(hMsgCertStore, X509_ASN_ENCODING, 0,
                                                         CERT_FIND_CERT_ID, 
                                                         &pCmsSignerInfo->SignerId, NULL);
            }
            else {
                pccertSigner = CertGetSubjectCertificateFromStore(hMsgCertStore,
                                                         X509_ASN_ENCODING, &SignerId);
            }
            if (pccertSigner != NULL) {
                m_psldData->m_fCertInLayer = TRUE;
            }
        }

        if (pccertSigner == NULL) {
            if (g_FSupportV3) {
                hstoreAll = OpenAllStore(
                    m_cStores,
                    m_rgStores,
                    &hCertStoreAddr,
                    &hCertStoreCA,
                    &hCertStoreMy,
                    &hCertStoreRoot
                    );
                if (hstoreAll == NULL)
                    goto CryptoError;
                                       
                pccertSigner = CertFindCertificateInStore(hstoreAll, X509_ASN_ENCODING, 0,
                                                         CERT_FIND_CERT_ID, 
                                                         &pCmsSignerInfo->SignerId, NULL);
            }
            else {
                Assert(!g_FSupportV3);
                CSSDOUT("Couldn't find cert in message store");
                // Look in the caller specified cert store before the hard coded stores.
                for (dexStore=0; dexStore<m_cStores; dexStore++) {
                    if (m_rgStores[dexStore]) {
                        if (pccertSigner = CertGetSubjectCertificateFromStore(
                                  m_rgStores[dexStore], X509_ASN_ENCODING, &SignerId)) {
                            break;
                        }
                    }
                }

                if (!pccertSigner) {
                    // Look in the "Address Book" store
                    if (hCertStoreAddr == NULL) {
                        hCertStoreAddr = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                 X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                                       s_cszWABCertStore);
                    }
                    if (hCertStoreAddr != NULL) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                           hCertStoreAddr, X509_ASN_ENCODING, &SignerId);
                    }
                }

                if (!pccertSigner) {
                    // Look in the "My" store
                    if (hCertStoreMy == NULL) {
                        hCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                                     X509_ASN_ENCODING, NULL,
                                                     CERT_SYSTEM_STORE_CURRENT_USER,
                                                     s_cszMy);
                    }
                    if (hCertStoreMy != NULL) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                             hCertStoreMy, X509_ASN_ENCODING, &SignerId);
                    }
                }

                if (!pccertSigner) {
                    // Look in the "CA" store
                    if (hCertStoreCA == NULL) {
                        hCertStoreCA = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                                                     X509_ASN_ENCODING, NULL, 
                                               CERT_SYSTEM_STORE_CURRENT_USER, s_cszCA);
                    }

                    if (hCertStoreCA) {
                        pccertSigner = CertGetSubjectCertificateFromStore(
                                             hCertStoreCA, X509_ASN_ENCODING, &SignerId);
                    }
                }
            }
        }

        //
        //  By now we should have a certificate to verify with, if we don't then
        //      we need to say we can't do anything with it.
        //

        if (!pccertSigner) {
            // we still can't find the cert.  Therefore, cannot verify signer
            CSSDOUT("Cannot verify signer");
            pSignerData->ulValidity = MSV_UNVERIFIABLE;
        } else {
            pSignerData->pccert = CertDuplicateCertificateContext(pccertSigner);

            if (g_FSupportV3) {
                dwCtrl = CMSG_CTRL_VERIFY_SIGNATURE_EX;
                pv = &verifySignature;

                verifySignature.cbSize = sizeof(verifySignature);
                verifySignature.hCryptProv = NULL;
                verifySignature.dwSignerIndex = iSigner;
                verifySignature.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
                verifySignature.pvSigner = (LPVOID) pccertSigner;
            }
            else {
                dwCtrl = CMSG_CTRL_VERIFY_SIGNATURE;
                pv = pccertSigner->pCertInfo;
            }

        retry:
            if (!CryptMsgControl(m_hMsg, 0, dwCtrl, pv)) {
                HRESULT hr2 = HrGetLastError();
                CSSDOUT("Failed signer verify --> %lx", hr2);

                if (hr2 == CRYPT_E_MISSING_PUBKEY_PARA) {
                    if (NULL == hstoreAll && g_FSupportV3) {
                        hstoreAll = OpenAllStore(
                            m_cStores,
                            m_rgStores,
                            &hCertStoreAddr,
                            &hCertStoreCA,
                            &hCertStoreMy,
                            &hCertStoreRoot
                            );
                        if (NULL == hstoreAll)
                            goto CryptoError;
                    }
                    hr2 = GetParameters(pccertSigner, hMsgCertStore, hstoreAll);
                    if (hr2 == S_OK) {
                        goto retry;
                    }
                    pSignerData->ulValidity = MSV_UNVERIFIABLE;
                }
                else if (NTE_BAD_SIGNATURE == hr2 || CRYPT_E_HASH_VALUE == hr2) {
                    pSignerData->ulValidity = MSV_BADSIGNATURE;
                } else if (NTE_BAD_ALGID == hr2) {
                    pSignerData->ulValidity = MSV_UNKHASH;
                } else if (CRYPT_E_SIGNER_NOT_FOUND == hr2) {
                    pSignerData->ulValidity = MSV_UNVERIFIABLE;
                } else if (NTE_FAIL == hr2) {
                    // RSABASE returns errors.  This might
                    // be a failure or the hash might be changed.
                    // Have to be cautious -> make it bad.
                    pSignerData->ulValidity = MSV_BADSIGNATURE;
                } else {
                    pSignerData->ulValidity = MSV_MALFORMEDSIG;
                }
            } else {
                CSSDOUT("Verify of signature succeeded.");
                pSignerData->ulValidity &=
                    ~(MSV_SIGNATURE_MASK|MSV_SIGNING_MASK);
            }

            // Determine if certificate is expired
            if (0 != CertVerifyTimeValidityWithDelta(NULL, pccertSigner->pCertInfo, TIME_DELTA_SECONDS)) {
                pSignerData->ulValidity |= MSV_EXPIRED_SIGNINGCERT;
            }
        }


        if (szContentType = (LPSTR)PVGetMsgParam(m_hMsg, CMSG_INNER_CONTENT_TYPE_PARAM, NULL, NULL)) {
            if (lstrcmp(szOID_PKCS_7_DATA, szContentType)) {
                CSSDOUT("Guess what, we have nested PKCS7 data types (maybe).");
            }
        } else {
            // CAPI failed... we are in trouble...
            pSignerData->ulValidity |= MSV_INVALID;

            hr = MIME_E_SECURITY_BADCONTENT;
            goto ErrorReturn;
        }

        //  Grab the hashing alg
        cap.cCapability = 1;
        cap.rgCapability = (CRYPT_SMIME_CAPABILITY *) &pCmsSignerInfo->HashAlgorithm;
        if (!CryptEncodeObjectEx(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                                 &cap, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                 &pSignerData->blobHashAlg.pBlobData,
                                 &pSignerData->blobHashAlg.cbSize)) {
            Assert(FALSE);
        }

        //
        //  Get the attributes, authenicated and unauthenicated, and put into the
        //          structure so we can push them back to the user later
        if (pCmsSignerInfo->AuthAttrs.cAttr != 0) {
#ifdef SMIME_V3
            for (i=0; i<pCmsSignerInfo->AuthAttrs.cAttr; i++) {
                // If we have a security label in this message, then we need to
                //      perform access validation.
                if (g_FSupportV3 && FIsMsasn1Loaded()) {
                    if (strcmp(pCmsSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                               szOID_SMIME_Security_Label) == 0) {

                        if ((pSignerData->ulValidity & MSV_SIGNATURE_MASK) != MSV_OK) {
                            DWORD dw = DwProcessLabelWithCertError();
                            if (CertErrorProcessLabelGrant == dw) {
                                hr = S_OK;
                                continue;
                            }
                            else if (CertErrorProcessLabelDeny == dw) {
                                hr = MIME_E_SECURITY_LABELACCESSDENIED;
                                goto ErrorReturn;
                            }
                            // else continue processing the label.
                        }
                        
                        if (pCmsSignerInfo->AuthAttrs.rgAttr[i].cValue != 1) {
                            hr = MIME_E_SECURITY_LABELCORRUPT;
                            goto ErrorReturn;
                        }

                        // Have we already seen a label?
                        if (attrSecLabel.pbData != NULL) {
                            // Check that the one we saw matches this one
                            if ((attrSecLabel.cbData != 
                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData) ||
                                memcmp(attrSecLabel.pbData,
                                       pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                       attrSecLabel.cbData)) {
                                if (FHideMsgWithDifferentLabels()) {
                                    hr = MIME_E_SECURITY_LABELCORRUPT;
                                    goto ErrorReturn;
                                }
                                else {
                                    continue;
                                }
                            }
                            else {
                                continue;
                            }
                        }
                        else {
                            // Save label.
                            attrSecLabel.cbData = pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData;
                            if (!MemAlloc((LPVOID*) (& attrSecLabel.pbData), attrSecLabel.cbData)) {
                                hr = MIME_E_SECURITY_LABELCORRUPT;
                                goto ErrorReturn; 
                            }
                            memcpy(attrSecLabel.pbData, pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                   attrSecLabel.cbData);
                        }
                        
                        // Clean-up from last loop
                        if (plabel != NULL)         CryptDecodeAlloc.pfnFree(plabel);
                                            
                        // Crack the contents of the label
                        if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_Security_Label,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
                                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                                 &plabel, &cblabel)) {
                            goto CryptoError;
                        }

                        // Query the policy.
                        hr = HrCheckLabelAccess((m_dwFlagsSEF & SEF_NOUI) ? 
                                                SMIME_POLICY_MODULE_NOUI: 0,
                                                m_hwnd, plabel, GetOuterDecryptCert(), 
                                                pccertSigner, hMsgCertStore);
                    

                        // If security policy returned an error, then abort.
                        if (FAILED(hr)) {
                            goto ErrorReturn;
                        }
                    }
                }

                if (g_FSupportV3 && FIsMsasn1Loaded() && (fLookForReceiptRequest) &&
                    ((pSignerData->ulValidity & (MSV_SIGNATURE_MASK | MSV_SIGNING_MASK)) == MSV_OK)) {
                    //  If we have a receipt request in this message than we need to build
                    //      the receipt body now while we have a chance.
    
                    if (strcmp(pCmsSignerInfo->AuthAttrs.rgAttr[i].pszObjId,
                               szOID_SMIME_Receipt_Request) == 0) {
                        if (pCmsSignerInfo->AuthAttrs.rgAttr[i].cValue != 1) {
                            if (attrReceiptReq.pbData != NULL) {
                   StopSendOfReceipt:
                                for (iSignData=0; iSignData < iSigner; iSignData++) {
                                    SafeMemFree(m_psldData->m_rgSigners[iSignData].blobReceipt.pBlobData);
                                    SafeMemFree(m_psldData->m_rgSigners[iSignData].blobHash.pBlobData);
                                    m_psldData->m_rgSigners[iSignData].blobReceipt.cbSize = 0;
                                    m_psldData->m_rgSigners[iSignData].blobHash.cbSize = 0;
                                    }
                            }
                            fLookForReceiptRequest = FALSE;
                            continue;
                        }

                        DWORD                       cb;
                        DWORD                       cbReceipt;
                        DWORD                       cbHash = 0;
                        LPBYTE                      pbReceipt = NULL;
                        LPBYTE                      pbHash = NULL;
                        SMIME_RECEIPT               receipt = {0};

                        // Clean-up from last loop
                        if (preq != NULL)         free(preq);
                        
                        // Have we already seen a receipt?
                        if (attrReceiptReq.pbData != NULL) {
                            // Check that the one we saw matches this one
                            if ((attrReceiptReq.cbData != 
                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData) ||
                               memcmp(attrReceiptReq.pbData,
                                      pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                      attrReceiptReq.cbData)) {
                                goto StopSendOfReceipt;
                            }
                        }
                        else {
                            // Save receipt request
                            attrReceiptReq.cbData = pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData;
                            if (!MemAlloc((LPVOID*) (& attrReceiptReq.pbData), attrReceiptReq.cbData)) {
                                // abort looking for receipt requests.
                                goto StopSendOfReceipt; 
                            }
                            memcpy(attrReceiptReq.pbData, pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                   attrReceiptReq.cbData);
                        }

                        // Crack the contents of the receipt
                        if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_Receipt_Request,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].pbData,
                                                 pCmsSignerInfo->AuthAttrs.rgAttr[i].rgValue[0].cbData,
                                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                                 &preq, &cb)) {
                            goto StopSendOfReceipt;
                        }

                        // Encode the receipt

                        receipt.Version = 1;
                        receipt.pszOIDContent = szContentType;
                        receipt.ContentIdentifier = preq->ContentIdentifier;
                        receipt.OriginatorSignature.cbData = pCmsSignerInfo->EncryptedHash.cbData;
                        receipt.OriginatorSignature.pbData = pCmsSignerInfo->EncryptedHash.pbData;

                        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                                 szOID_SMIME_ContentType_Receipt,
                                                 &receipt, CRYPT_ENCODE_ALLOC_FLAG,
                                                 &CryptEncodeAlloc, &pbReceipt,
                                                 &cbReceipt)) {
                            goto StopSendOfReceipt;
                        }
                        
                        pSignerData->blobReceipt.cbSize = cbReceipt;
                        pSignerData->blobReceipt.pBlobData = pbReceipt;

                        pbHash = (LPBYTE)PVGetMsgParam(m_hMsg, CMSG_COMPUTED_HASH_PARAM, 
                                                         NULL, &cbHash);
                        if (pbHash == NULL) {
                            goto CryptoError;
                        }
                        pSignerData->blobHash.cbSize = cbHash;
                        pSignerData->blobHash.pBlobData = pbHash;
                    }
                }
            }

#endif // SMIME_V3
            //

            cbData = 0;
            LPBYTE  pb;
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                     &pCmsSignerInfo->AuthAttrs, CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pb, &cbData)) {
                goto CryptoError;
            }
            pSignerData->blobAuth.cbSize = cbData;
            pSignerData->blobAuth.pBlobData = pb;
        }

        if (pCmsSignerInfo->UnauthAttrs.cAttr != 0) {
            LPBYTE  pb;
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                     &pCmsSignerInfo->UnauthAttrs,
                                     CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                                     &pb, &cbData)) {
                goto CryptoError;
            }

            pSignerData->blobUnauth.cbSize = cbData;
            pSignerData->blobUnauth.pBlobData = pb;
        }

        CertFreeCertificateContext(pccertSigner);
        pccertSigner = NULL;
    }

exit:
#ifdef SMIME_V3    
    if (preq != NULL)    CryptDecodeAlloc.pfnFree(preq);
    if (plabel != NULL)  CryptDecodeAlloc.pfnFree(plabel);
    SafeMemFree(attrReceiptReq.pbData);
    SafeMemFree(attrSecLabel.pbData);
#endif // SMIME_V3    
    if (hCertStoreAddr != NULL) CertCloseStore(hCertStoreAddr, 0);
    if (hCertStoreMy != NULL)   CertCloseStore(hCertStoreMy, 0);
    if (hCertStoreCA != NULL)   CertCloseStore(hCertStoreCA, 0);
    if (hCertStoreRoot != NULL) CertCloseStore(hCertStoreRoot, 0);
    if (hMsgCertStore != NULL)  CertCloseStore(hMsgCertStore, 0);
    MemFree(szContentType);
    ReleaseMem(pSignerInfo);
#ifdef SMIME_V3
    if (pCmsSignerInfo != &cmsSignerInfo) {
        ReleaseMem(pCmsSignerInfo);
    }
    if (hstoreAll != NULL)      CertCloseStore(hstoreAll, 0);
#endif // SMIME_V3
    ReleaseCert(pccertSigner);
    return hr;

CryptoError:
    hr = HrGetLastError();

ErrorReturn:
    // On error, release the cert store
    if (m_psldData->m_hcertstor != NULL) {
        CertCloseStore(m_psldData->m_hcertstor, 0);
        m_psldData->m_hcertstor = NULL;
    }


    if (S_OK == hr)
        // our generic error message
        hr = TrapError(MIME_E_SECURITY_BADMESSAGE);
    goto exit;
}

static HRESULT GetCSP(PCCERT_CONTEXT pccert, HCRYPTPROV * phprov, DWORD * pdwKeyId)
{
    HRESULT                 hr;
    PCRYPT_KEY_PROV_INFO    pKPI = NULL;

    Assert(*phprov == NULL);
    Assert(*pdwKeyId == 0);
    
    //
    //

    hr = HrGetCertificateParam(pccert, CERT_KEY_PROV_INFO_PROP_ID,
                               (LPVOID *) &pKPI, NULL);
    if (FAILED(hr)) {
        goto exit;
    }
    *pdwKeyId = pKPI->dwKeySpec;

    // If the cert specifies the base provider OR has no specification,
    //  then try to acquire RSAENH, else get RSABASE.

    if ((PROV_RSA_FULL == pKPI->dwProvType) &&
        (UnlocStrEqNW(pKPI->pwszProvName, MS_DEF_PROV_W,
                      sizeof(MS_DEF_PROV_W)/sizeof(WCHAR)-5) ||
         (*pKPI->pwszProvName == 0))) {
        if (!CRYPT_ACQUIRE_CONTEXT(phprov, pKPI->pwszContainerName,
                                   MS_ENHANCED_PROV_W, PROV_RSA_FULL,
                                   pKPI->dwFlags)) {
            CSSDOUT("CryptAcquireContext -> %x\n", HrGetLastError());
        }
    }

    if (*phprov == NULL) {
        if (! CRYPT_ACQUIRE_CONTEXT(phprov, pKPI->pwszContainerName,
                                    pKPI->pwszProvName, pKPI->dwProvType,
                                    pKPI->dwFlags)) {
            CSSDOUT("CryptAcquireContext -> %x\n", HrGetLastError());
            hr = HrGetLastError();
            goto exit;
        }
    }
    hr = S_OK;
exit:
    ReleaseMem(pKPI);
    return hr;
}

HRESULT CCAPIStm::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipientIndex,
                             const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                             HCERTSTORE hcertstore, DWORD * pdwCtrl, 
                             CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                             PCCERT_CONTEXT * ppCertDecrypt)
{
    HRESULT                 hr;
    HCRYPTPROV              hProv = NULL;
    DWORD                   i;
    PCMSG_CTRL_DECRYPT_PARA pccdp;
    PCCERT_CONTEXT          pCertDecrypt = NULL;
    PCCERT_CONTEXT          pCertOrig = NULL;

    if (g_FSupportV3) {
        switch (pRecipInfo->dwRecipientChoice) {
            //
            //  Given the certificate reference, see if we can find it in
            //  the passed in certificate stores, if yes then we will attempt
            //  to decrypt using that certificate
            //
            //  This is a Key Transport recipient info object.  The CAPI 2.0
            //  code can deal with both SKI and Issuer/Serial Number references
            //

        case CMSG_KEY_TRANS_RECIPIENT:
            pCertDecrypt = CertFindCertificateInStore(hcertstore, X509_ASN_ENCODING,
                                                      0, CERT_FIND_CERT_ID,
                                                      &pRecipInfo->pKeyTrans->RecipientId, NULL);
        
            if (pCertDecrypt != NULL) {
                hr = GetCSP(pCertDecrypt, &pDecryptInfo->trans.hCryptProv,
                            &pDecryptInfo->trans.dwKeySpec);
                if (SUCCEEDED(hr)) {
                    //
                    //  We find a certificate for this lock box.  Setup the
                    //      structure to be used in decrypting the message.
                    //
                        
                    *pdwCtrl = CMSG_CTRL_KEY_TRANS_DECRYPT;
                    pDecryptInfo->trans.cbSize = sizeof(pDecryptInfo->trans);
                    // pDecryptInfo->trans.hCryptProv = hProv;
                    // pDecryptInfo->trans.dwKeySpec = pKPI->dwKeySpec;
                    pDecryptInfo->trans.pKeyTrans = pRecipInfo->pKeyTrans;
                    pDecryptInfo->trans.dwRecipientIndex = dwRecipientIndex;
                }
                else {
                    ReleaseCert(pCertDecrypt);
                    pCertDecrypt = NULL;
                }
            }
            break;

        //
        //  Given the certificate reference, see if we can find it in
        //  the passed in certificate stores, if yes then we will attempt
        //  to decrypt using that certificate
        //
        //  This is a Key Agreement recipient info object.  The CAPI 2.0
        //  code can deal with both SKI and Issuer/Serial Number references
        //
        //  There may be multiple certificate references within a single
        //  recipient info object
        //

        case CMSG_KEY_AGREE_RECIPIENT:
            for (i=0; i<pRecipInfo->pKeyAgree->cRecipientEncryptedKeys; i++) {
                pCertDecrypt = CertFindCertificateInStore(
                                             hcertstore, X509_ASN_ENCODING, 0,
                                             CERT_FIND_CERT_ID, 
                  &pRecipInfo->pKeyAgree->rgpRecipientEncryptedKeys[i]->RecipientId,
                                             NULL);
                if (pCertDecrypt != NULL) {
                    hr = GetCSP(pCertDecrypt, &pDecryptInfo->agree.hCryptProv,
                                &pDecryptInfo->agree.dwKeySpec);
                    if (SUCCEEDED(hr)) {
                        //
                        //  We find a certificate for this lock box.  Setup the
                        //      structure to be used in decrypting the message.
                        //
                        
                        *pdwCtrl = CMSG_CTRL_KEY_AGREE_DECRYPT;
                        pDecryptInfo->agree.cbSize = sizeof(pDecryptInfo->agree);
                        pDecryptInfo->agree.pKeyAgree = pRecipInfo->pKeyAgree;
                        pDecryptInfo->agree.dwRecipientIndex = dwRecipientIndex;
                        pDecryptInfo->agree.dwRecipientEncryptedKeyIndex = i;

                        //
                        // Need to find the originator information
                        //

                        switch(pRecipInfo->pKeyAgree->dwOriginatorChoice) {
                        case CMSG_KEY_AGREE_ORIGINATOR_CERT:
                            pCertOrig = CertFindCertificateInStore( hcertstore, X509_ASN_ENCODING, 0, CERT_FIND_CERT_ID, &pRecipInfo->pKeyAgree->OriginatorCertId, NULL);
                            if (pCertOrig == NULL) {
                                hr = S_FALSE;
                                goto exit;
                            }

                            hr = HrCopyCryptBitBlob(&pCertOrig->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                                                    &pDecryptInfo->agree.OriginatorPublicKey);
                            if (FAILED(hr)) {
                                goto exit;
                            }
                            break;
                                
                        case CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY:
                            hr = HrCopyCryptBitBlob(&pRecipInfo->pKeyAgree->OriginatorPublicKeyInfo.PublicKey,
                                                    &pDecryptInfo->agree.OriginatorPublicKey);
                            if (FAILED(hr)) {
                                goto exit;
                            }
                            break;

                        default:
                            hr = NTE_FAIL;
                            goto exit;
                        }
                        break;
                    }
                    else {
                        ReleaseCert(pCertDecrypt);
                        pCertDecrypt = NULL;
                    }
                }
            }
            break;

        //
        //   We can't find this from a certificate
        //
                    
        case CMSG_MAIL_LIST_RECIPIENT:
            break;

        default:
            hr = NTE_FAIL;
            goto exit;
        }
    }
    else {
        CERT_INFO * pCertInfo = (CERT_INFO *) pRecipInfo;
                
        for (i=0; i<m_cStores; i++) {
            pCertDecrypt = CertGetSubjectCertificateFromStore(m_rgStores[i],
                                                X509_ASN_ENCODING, pCertInfo);
            if (pCertDecrypt != NULL) {
                pccdp = (PCMSG_CTRL_DECRYPT_PARA) pDecryptInfo;
                hr = GetCSP(pCertDecrypt, &pccdp->hCryptProv, &pccdp->dwKeySpec);
                if (SUCCEEDED(hr)) {
                    //
                    //  We find a certificate for this lock box.  Setup the
                    //      structure to be used in decrypting the message.
                    //
                        
                    *pdwCtrl = CMSG_CTRL_DECRYPT;
                    pccdp->cbSize = sizeof(CMSG_CTRL_DECRYPT_PARA);
                    pccdp->dwRecipientIndex = dwRecipientIndex;
                }
                else {
                    ReleaseCert(pCertDecrypt);
                    pCertDecrypt = NULL;
                }
                break;
            }
        }
    }


    //
    //  If we did not find a certificate, then return a failure code
    //
    
    if (pCertDecrypt == NULL) {
        hr = S_FALSE;
        goto exit;
    }

    //
    //  If we have a certificate, then return it for the user to examine.
    //
    
    if (pCertDecrypt != NULL) {
        *ppCertDecrypt = pCertDecrypt;
        pCertDecrypt = NULL;
    }

    hProv = NULL;
    hr = S_OK;
exit:
    ReleaseCert(pCertDecrypt);
    ReleaseCert(pCertOrig);
    if (hProv != NULL)          CryptReleaseContext(hProv, 0);

    return hr;
}

BOOL CCAPIStm::HandleEnveloped()
{
    DWORD                               cbData;
    DWORD                               cCerts;
    DWORD                               cRecips;
    CMS_CTRL_DECRYPT_INFO               decryptInfo = {0};
    DWORD                               dexRecip;
    DWORD                               dwCtrl;
    BOOL                                f;
    BOOL                                fGotoUser = FALSE;
    HCERTSTORE                          hcertstore = NULL;
    HCERTSTORE                          hMsgCertStore = NULL;
    HRESULT                             hr;
    DWORD                               i;
    PCCERT_CONTEXT                      pCertDecrypt = NULL;
    CMSG_CMS_RECIPIENT_INFO *           pCmsCertInfo;
    LPVOID                              pv = NULL;

    //
    //  If we are not suppose to display UI -- return an error about displaying UI now.
    //

    ////////////////////////////////////////////////////////////////////////////////////////
    // 591349 - Compiler Bug For Zero Initialization of Data Structure. Active WinNT 5.1 (Whistler) 1 Server RC1
    // the line above doesn't zero the structure due to this compiler bug
    memset(&decryptInfo, 0, sizeof(decryptInfo));

    if (m_dwFlagsSEF & SEF_NOUI) {
        return MIME_E_SECURITY_UIREQUIRED;
    }

    //
    // this call exists for one and only one purpose.  We must
    //  be sure that we have read and parsed all of the RecipientInfo structures
    //  before we start processing them.  Since the algorithm parameter is after
    //  the last of the last of the recipient structures, this make sure of that.
    //
    
    pv = PVGetMsgParam(m_hMsg, CMSG_ENVELOPE_ALGORITHM_PARAM, 0, NULL);
    if (pv == NULL) {
        goto gle;
    }
    MemFree(pv);                pv = NULL;

    //
    //  Fetch the set of certificates on the message object
    //

    cbData = sizeof(cCerts);
    f = CryptMsgGetParam(m_hMsg, CMSG_CERT_COUNT_PARAM, 0, &cCerts, &cbData);
    Assert(f);

    if (f && (cCerts > 0)) {
        // since there are certs included, let's try them first when matching
        // certs with enryptors.

        // get the store set
        // make sure we keep hold of our provider
        hMsgCertStore = CertOpenStore(CERT_STORE_PROV_MSG, X509_ASN_ENCODING,
                                      m_hProv, 0, m_hMsg);
        if (hMsgCertStore) {
            m_dwFlagsStm |= CSTM_DONTRELEASEPROV;  // given unto the store
        }

        // if it failed, we just don't have a store then
        Assert(hMsgCertStore != NULL);
        m_psldData->m_hstoreEncrypt = CertDuplicateStore(hMsgCertStore);
    }

    //
    //  Retrieve the count of recipient infos on the message
    //
    
    cbData = sizeof(cRecips);
    if (!CryptMsgGetParam(m_hMsg, g_FSupportV3 ? CMSG_CMS_RECIPIENT_COUNT_PARAM :
                          CMSG_RECIPIENT_COUNT_PARAM, 0, &cRecips, &cbData)) {
        goto gle;
    }

    //
    // If we were provided an actual certificate, see if this is it...
    // We will either search for the provided certificate or in the provided
    //  certificate stores, but not both.
    //

    if (m_pUserCertDecrypt != NULL) {
        hcertstore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                   NULL, 0, NULL);
        if (hcertstore == NULL) {
            hr = HrGetLastError();
            goto exit;
        }

        if (!CertAddCertificateContextToStore(hcertstore, m_pUserCertDecrypt,
                                              CERT_STORE_ADD_ALWAYS, NULL)) {
            hr = HrGetLastError();
            goto exit;
        }
    }
    else {
        if (g_FSupportV3) {
            hcertstore = CertOpenStore(CERT_STORE_PROV_COLLECTION, X509_ASN_ENCODING,
                                       NULL, 0, NULL);
            if (hcertstore == NULL) {
                hr = HrGetLastError();
                goto exit;
            }

            for (i=0; i<m_cStores; i++) {
                CertAddStoreToCollection(hcertstore, m_rgStores[i], 0, 0);
            }

            if (hMsgCertStore != NULL) {
                CertAddStoreToCollection(hcertstore, hMsgCertStore, 0, 0);
            }
        }
    }

    //  For each possible recipient
tryAgain:
    for (dexRecip=0; dexRecip<cRecips; dexRecip++) {
        //
        //  Retrieve the desciption of the i-th recipient's lockbox
        //
            
        hr = HrGetMsgParam(m_hMsg, g_FSupportV3 ? CMSG_CMS_RECIPIENT_INFO_PARAM :
                           CMSG_RECIPIENT_INFO_PARAM, dexRecip, (LPVOID *) &pv, NULL);
        if (FAILED(hr)) {
            goto exit;
        }

        //
        //  Look to see if there is a decrypt item we can fill in here.
        //

        if (fGotoUser) {
            //
            //  Look to see if there is a decrypt item that the user can fill in.
            //
            
            hr = m_pSmimeCallback->FindKeyFor(m_hwnd, 0, dexRecip,
                                              (CMSG_CMS_RECIPIENT_INFO *) pv,
                                              &dwCtrl, &decryptInfo, &pCertDecrypt);
        }
        else {
            hr = FindKeyFor(m_hwnd, 0, dexRecip, (CMSG_CMS_RECIPIENT_INFO *) pv,
                            hcertstore, &dwCtrl, &decryptInfo, &pCertDecrypt);
        }
            
        if (FAILED(hr)) {
            goto exit;
        }

        if (hr == S_OK) {
#ifdef SMIME_V3
            if (m_pwszKeyPrompt != NULL) {
                PCMSG_CTRL_DECRYPT_PARA pccdp;
                
                switch (dwCtrl) {
                    case CMSG_CTRL_KEY_TRANS_DECRYPT:
                        CryptSetProvParam(decryptInfo.trans.hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;

                    case CMSG_CTRL_KEY_AGREE_DECRYPT:
                        CryptSetProvParam(decryptInfo.agree.hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;

                    case CMSG_CTRL_DECRYPT:
                        pccdp = (PCMSG_CTRL_DECRYPT_PARA) &decryptInfo;
                        CryptSetProvParam(pccdp->hCryptProv, 
                                          PP_UI_PROMPT, (LPBYTE) m_pwszKeyPrompt, 0);
                        break;
                    }
            }
#endif // SMIME_V3

            if (!CryptMsgControl(m_hMsg, CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
                                 dwCtrl, &decryptInfo)) {
                hr = HrGetLastError();

                //
                // Force any cleanups in the event of an error
                //

                switch (dwCtrl) {
                case CMSG_CTRL_KEY_TRANS_DECRYPT:
                    CryptReleaseContext(decryptInfo.trans.hCryptProv, 0);
                    break;
                    
                case CMSG_CTRL_KEY_AGREE_DECRYPT:
                    CryptReleaseContext(decryptInfo.agree.hCryptProv, 0);
                    break;
                    
                case CMSG_CTRL_MAIL_LIST_DECRYPT:
                    Assert(FALSE);
                    break;
                    
                case CMSG_CTRL_DECRYPT:
                    CryptReleaseContext(((PCMSG_CTRL_DECRYPT_PARA) &decryptInfo)->hCryptProv, 0);
                    break;
                }
                goto exit;
            }
            goto DecryptDone;
        }

        //
        //  Clean up the object returned describing the lock box, if we
        //      were unsuccessful in finding a decryption key.
        //

        MemFree(pv);                pv = NULL;
    }

    //
    //  If we are completely unsuccessful and the user has provided
    //  us a callback to play with, then give the user a shot at finding
    //  the correct decryption parameters.
    //
    
    if (!fGotoUser && g_FSupportV3 && (m_pSmimeCallback != NULL)) {
        fGotoUser = TRUE;
        goto tryAgain;
    }

    CSSDOUT("Could not decrypt the message");

    m_psldData->m_ulDecValidity = MSV_CANTDECRYPT;
    hr = CS_E_CANT_DECRYPT;
    goto exit;

    //
    //  If we get here, then we 
    //  1) found some parameters and
    //  2) the worked.
    //
    
DecryptDone:
    Assert(m_psldData && (m_psldData->m_pccertDecrypt == NULL));
    if (pCertDecrypt != NULL) {
        m_psldData->m_pccertDecrypt = CertDuplicateCertificateContext(pCertDecrypt);

        // Determine if certificate is expired
        if (0 != CertVerifyTimeValidityWithDelta(NULL, pCertDecrypt->pCertInfo,
                                                 TIME_DELTA_SECONDS)) {
            m_psldData->m_ulDecValidity |= MSV_ENC_FOR_EXPIREDCERT;
        }
    }
    hr = S_OK;

exit:
    if (pv != NULL)             MemFree(pv);

    CertFreeCertificateContext(pCertDecrypt);

    if (hMsgCertStore != NULL) {
        CertCloseStore(hMsgCertStore, 0);
    }
    
    if (hcertstore != NULL) {
        CertCloseStore(hcertstore, 0);
    }
        
    
    if (FAILED(hr)) {
#ifdef DEBUG
        if (NTE_BAD_DATA == hr) {
            CSSDOUT("Could not decrypt.  Maybe due to ImportKeyError since");
            CSSDOUT("NTE_BAD_DATA is the result.");
            // If this happens then it is somewhat likely that PKCS2Decrypt
            // failed inside the CSP. (assuming rsabase, rsaenh)
        }
#endif
        switch (hr) {
            case CS_E_CANT_DECRYPT:
            case CRYPT_E_STREAM_MSG_NOT_READY:
            case HRESULT_FROM_WIN32(ERROR_CANCELLED):
                break;

            default:
                // I suppose many things could have gone wrong.  We thought
                // we had a cert, though, so let's just say the message itself
                // is bogus.
                //N8 this is a bad idea if we are wrapping a signature
                // should be able to tell if the sig failed and display
                // a better error message.
                //N8 CAPI is simply going to return NTE_FAIL b/c they
                // are failing because our callback failed.  the
                // innerCAPI should have some failure state in it.
                // Maybe we could use this to set MSV_BADINNERSIG or something.
                // It would be an encryption error (inside that mask)
                //N8 also this is not being used well enough, even for
                // decryption.  the secUI should test this bit and
                // say something intelligent about the message.  NS does.
                m_psldData->m_ulDecValidity = MSV_INVALID;
                hr = CS_E_MSG_INVALID;
                break;
        }
    }

#ifdef DEBUG
    if (CRYPT_E_STREAM_MSG_NOT_READY != hr) {
        return TrapError(hr);
    } else {
        return hr;
    }
#else
    return hr;
#endif

gle:
    hr = HrGetLastError();
    Assert(S_OK != hr);
    goto exit;
}

///////////////////////////////////////////////////////////////////////////
//
// Class-static utility functions
//

HRESULT CCAPIStm::DuplicateSecurityLayerData(const PSECURITY_LAYER_DATA psldIn, PSECURITY_LAYER_DATA *const ppsldOut)
{
    if (!psldIn || !ppsldOut) {
        return E_POINTER;
    }

    // Just addref the original and return it
    psldIn->AddRef();
    *ppsldOut = psldIn;
    return(S_OK);
}

void CCAPIStm::FreeSecurityLayerData(PSECURITY_LAYER_DATA psld)
{
    if (! psld) {
        return;
    }

    psld->Release();
}


///////////////////////////////////////////////////////////////////////////
//
// Statics to file
//

static HRESULT _InitEncodedCert(IN HCERTSTORE hcertstor,
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl)
{
    DWORD               cbCerts = 0;
    DWORD               cbCRLs = 0;
    DWORD               cCerts = 0;
    DWORD               cCRLs = 0;
    DWORD               i;
    LPBYTE              pbCert = NULL;
    LPBYTE              pbCRL = NULL;
    PCCERT_CONTEXT      pccert = NULL;
    PCCRL_CONTEXT       pccrl = NULL;
    PCERT_BLOB          rgblobCerts = NULL;
    PCRL_BLOB           rgblobCRLs = NULL;

    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL) {
        cbCerts += LcbAlignLcb(pccert->cbCertEncoded);
        cCerts += 1;
    }

    while ((pccrl = CertEnumCRLsInStore(hcertstor, pccrl)) != NULL) {
        cbCRLs += LcbAlignLcb(pccrl->cbCrlEncoded);
        cCRLs += 1;
    }

    if (cCerts > 0) {
        rgblobCerts = (PCERT_BLOB) g_pMoleAlloc->Alloc(LcbAlignLcb(sizeof(CERT_BLOB) * cCerts + cbCerts));
        if (rgblobCerts == NULL) {
            return E_OUTOFMEMORY;
        }
    }

    if (cCRLs > 0) {
        rgblobCRLs = (PCRL_BLOB) g_pMoleAlloc->Alloc(LcbAlignLcb(sizeof(CRL_BLOB) * cCRLs + cbCRLs));
        if (rgblobCRLs == NULL) {
            g_pMoleAlloc->Free(rgblobCerts);
            return E_OUTOFMEMORY;
        }
    }

    if (cCerts > 0) {
        pbCert = (LPBYTE) &rgblobCerts[cCerts];
        i = 0;
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL) {
            memcpy(pbCert, pccert->pbCertEncoded, pccert->cbCertEncoded);
            rgblobCerts[i].pbData = pbCert;
            rgblobCerts[i].cbData = pccert->cbCertEncoded;
            pbCert += LcbAlignLcb(pccert->cbCertEncoded);
            i++;
        }
        Assert(i == cCerts);
    }

    if (cCRLs > 0) {
        pbCRL = (LPBYTE) &rgblobCRLs[cCRLs];
        i = 0;
        while ((pccrl = CertEnumCRLsInStore(hcertstor, pccrl)) != NULL) {
            memcpy(pbCRL, pccrl->pbCrlEncoded, pccrl->cbCrlEncoded);
            rgblobCRLs[i].pbData = pbCRL;
            rgblobCRLs[i].cbData = pccrl->cbCrlEncoded;
            pbCRL += LcbAlignLcb(pccrl->cbCrlEncoded);
            i++;
        }
        Assert(i == cCRLs);
    }

    *prgblobCerts = rgblobCerts;
    *pcCerts = cCerts;
    *prgblobCrls = rgblobCRLs;
    *pcCrl = cCRLs;

    return S_OK;
}

// Ensures that the signer certificates are included in the returned
// array of blobs.
static HRESULT _InitEncodedCertIncludingSigners(IN HCERTSTORE hcertstor,
                                DWORD cSigners, SignerData rgSigners[],
                                PCERT_BLOB * prgblobCerts, DWORD * pcCerts,
                                PCRL_BLOB * prgblobCrls, DWORD * pcCrl)
{
    HRESULT hr;
    HCERTSTORE hCollection = NULL;
    DWORD i;

    // Loop through signers. Check that they are already included in the
    // certificate store. If not, then, create a collection and memory store
    // to include.

    for (i = 0; i < cSigners; i++) {
        PCCERT_CONTEXT pSignerCert = rgSigners[i].pccert;
        PCCERT_CONTEXT pStoreCert = NULL;

        while (NULL != (pStoreCert = CertEnumCertificatesInStore(
                hcertstor, pStoreCert))) {
            if (pSignerCert->cbCertEncoded == pStoreCert->cbCertEncoded &&
                    0 == memcmp(pSignerCert->pbCertEncoded,
                            pStoreCert->pbCertEncoded,
                            pSignerCert->cbCertEncoded))
                break;
        }

        if (pStoreCert)
            // Signer cert is already included in the store
            CertFreeCertificateContext(pStoreCert);
        else {
            if (NULL == hCollection) {
                // Create collection and memory store to contain the
                // signer certificate

                HCERTSTORE hMemory = NULL;
                BOOL fResult;
                
                hCollection = CertOpenStore(
                    CERT_STORE_PROV_COLLECTION,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL
                    );
                if (NULL == hCollection)
                    goto CommonReturn;

                if (!CertAddStoreToCollection(
                        hCollection,
                        hcertstor,
                        0,                  // dwUpdateFlags
                        0                   // dwPriority
                        ))
                    goto CommonReturn;

                hMemory = CertOpenStore(
                    CERT_STORE_PROV_MEMORY,
                    X509_ASN_ENCODING,
                    NULL,
                    0,
                    NULL
                    );

                if (NULL == hMemory)
                    goto CommonReturn;

                fResult = CertAddStoreToCollection(
                    hCollection,
                    hMemory,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    1                   // dwPriority
                    );
                CertCloseStore(hMemory, 0);
                if (!fResult)
                    goto CommonReturn;

                hcertstor = hCollection;
            }

            CertAddEncodedCertificateToStore(
                hCollection,
                pSignerCert->dwCertEncodingType,
                pSignerCert->pbCertEncoded,
                pSignerCert->cbCertEncoded,
                CERT_STORE_ADD_ALWAYS,
                NULL
                );
        }
    }


CommonReturn:
    hr = _InitEncodedCert(hcertstor, prgblobCerts, pcCerts, prgblobCrls, pcCrl);
    if (hCollection)
        CertCloseStore(hCollection, 0);
    return hr;
}

#ifndef SMIME_V3
static HRESULT _InitCertInfo(
    IN PCCERT_CONTEXT * rgpCerts,
    IN DWORD            cCerts,
    OUT PCERT_INFO **   prgpCertInfo)
{
    PCERT_INFO*     rgpCertInfo = NULL;
    DWORD           dwIdx;
    HRESULT         hr = S_OK;

    Assert(prgpCertInfo);

    if (cCerts) {
        rgpCertInfo = (PCERT_INFO*)g_pMoleAlloc->Alloc(sizeof(CERT_BLOB) * cCerts);
        if (NULL == rgpCertInfo) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        for (dwIdx = 0; dwIdx < cCerts; dwIdx++) {
            rgpCertInfo[dwIdx] = rgpCerts[dwIdx]->pCertInfo;
        }
    }

exit:
    *prgpCertInfo = rgpCertInfo;
    return hr;
}
#endif // !SMIME_V3

void _SMimeCapsFromHMsg(HCRYPTMSG hMsg, DWORD idParam, LPBYTE * ppb, DWORD * pcb)
{
    DWORD                       cbData = 0;
    CRYPT_SMIME_CAPABILITY      cap;
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL                        f;
    PCRYPT_ALGORITHM_IDENTIFIER paid = NULL;
    LPBYTE                      pb = NULL;

    f = CryptMsgGetParam(hMsg, idParam, 0, NULL, &cbData);
    if ((cbData == 0) || ! MemAlloc((LPVOID *) &paid, cbData)) {
        Assert(FALSE);
        goto error;
    }

    f = CryptMsgGetParam(hMsg, idParam, 0, paid, &cbData);
    Assert(f);

    caps.cCapability = 1;
    caps.rgCapability = &cap;

    cap.pszObjId = paid->pszObjId;
    cap.Parameters.cbData = paid->Parameters.cbData;
    cap.Parameters.pbData = paid->Parameters.pbData;

    cbData = 0;
    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_RSA_SMIMECapabilities,
                             &caps, CRYPT_ENCODE_ALLOC_FLAG, &CryptEncodeAlloc,
                             &pb, &cbData)) {
        Assert(FALSE);
        goto error;
    }

    *ppb = pb;
    *pcb = cbData;

exit:
    SafeMemFree(paid);
    return;

error:
    *ppb = NULL;
    *pcb = 0;
    goto exit;
}


#ifdef SMIME_V3
////    HrBuildContentEncryptionAlg
//
//  Description:
//      This function is used to decode a smime capability and build the
//      structure we need to pass into the Crypt32 code.
//

HRESULT HrBuildContentEncryptionAlg(PSECURITY_LAYER_DATA psld, BLOB * pblob)
{
    DWORD                       cbData;
    HRESULT                     hr;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;
    CMSG_RC2_AUX_INFO *         prc2Aux;

    //
    //  Decode the capability which is the bulk encryption algorithm
    //
    
    hr = HrDecodeObject(pblob->pBlobData, pblob->cbSize, PKCS_SMIME_CAPABILITIES,
                        0, &cbData, (LPVOID *)&pcaps);
    if (FAILED(hr)) {
        goto exit;
    }

    Assert(pcaps->cCapability == 1);
    if (!MemAlloc((LPVOID *) &psld->m_ContentEncryptAlgorithm.pszObjId,
                  lstrlen(pcaps->rgCapability[0].pszObjId) + 1)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    lstrcpy(psld->m_ContentEncryptAlgorithm.pszObjId, pcaps->rgCapability[0].pszObjId);

    //
    //  If this is the RC/2 algorithm, then we need to setup the aux info
    //  to pass in the algorithm size.
    //
    
    if (lstrcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
        psld->m_ContentEncryptAlgorithm.Parameters.cbData = 0;
        psld->m_ContentEncryptAlgorithm.Parameters.pbData = NULL;

        if (!MemAlloc((LPVOID *) &(psld->m_pvEncryptAuxInfo), sizeof(*prc2Aux))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        prc2Aux = (CMSG_RC2_AUX_INFO *) psld->m_pvEncryptAuxInfo;
        prc2Aux->cbSize = sizeof(*prc2Aux);
        
        if (pcaps->rgCapability[0].Parameters.cbData == 0) {
            prc2Aux->dwBitLen = 40;
        }
        else {
            switch(pcaps->rgCapability[0].Parameters.pbData[pcaps->rgCapability[0].Parameters.cbData-1]) {
            case 128:
            case 58:
                prc2Aux->dwBitLen = 128;
                break;

            case 64:
            case 120:
                prc2Aux->dwBitLen = 64;
                break;

            case 40:
            case 160:
            default:
                prc2Aux->dwBitLen = 40;
                break;
            }
        }
    }
    else if (pcaps->rgCapability[0].Parameters.cbData != 0) {
        if (!MemAlloc((LPVOID *) &psld->m_ContentEncryptAlgorithm.Parameters.pbData,
                      pcaps->rgCapability[0].Parameters.cbData)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        memcpy(psld->m_ContentEncryptAlgorithm.Parameters.pbData,
               pcaps->rgCapability[0].Parameters.pbData,
               pcaps->rgCapability[0].Parameters.cbData);
        
        psld->m_ContentEncryptAlgorithm.Parameters.cbData =
            pcaps->rgCapability[0].Parameters.cbData;
    }
    

    hr = S_OK;
exit:
    if (pcaps != NULL)                  MemFree(pcaps);

    return hr;
}

HRESULT HrDeriveKeyWrapAlg(PSECURITY_LAYER_DATA psld, CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO * pAgree)
{
    LPCSTR      pszObjId = psld->m_ContentEncryptAlgorithm.pszObjId;
    
    if (lstrcmp(pszObjId, szOID_RSA_RC2CBC) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        pAgree->pvKeyWrapAuxInfo = psld->m_pvEncryptAuxInfo;
    }
    else if (lstrcmp(pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMS3DESwrap;
        pAgree->pvKeyWrapAuxInfo = NULL;
    }
    else if (lstrcmp(pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
        pAgree->KeyWrapAlgorithm.pszObjId = "2.16.840.1.101.2.1.1.24";
        pAgree->pvKeyWrapAuxInfo = NULL;
    }
    else {
        return NTE_NOT_FOUND;
    }
    return S_OK;
}
#endif // SMIME_V3



#ifdef SMIME_V3


//
// Read in admin option that determines whether a msg with disparate
// Labels is shown or not.
// 
BOOL FHideMsgWithDifferentLabels() 
{
    DWORD     cbData = 0;
    DWORD     dwType = 0;
    DWORD     dwValue = 0;
    BOOL      fHideMsg = FALSE;
    HKEY      hkey = NULL;
    LONG      lRes;
    
    // Open the security label admin defaults key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelAdminRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No admin label options were found.  
        goto exit;
    }

    cbData = sizeof(dwValue);
    lRes = RegQueryValueEx(hkey, c_szHideMsgWithDifferentLabels, NULL, 
                           &dwType, (LPBYTE) &dwValue, &cbData);
    if (ERROR_SUCCESS != lRes) {
        goto exit;
    }

    if (0x01 == dwValue) {
        fHideMsg = TRUE;
    }
    
exit:
    if (NULL != hkey)      RegCloseKey(hkey);
    return fHideMsg;
}

//
// Read in admin option that determines how to process a label in a 
// signture with errors.
// Returns 0, 1, 2 for ProcessAnyway, Grant, Deny(default).
//
DWORD DwProcessLabelWithCertError()
{
    DWORD     cbData = 0;
    DWORD     dwType = 0;
    DWORD     dwValue = CertErrorProcessLabelDeny;
    BOOL      dwProcessMsg = 0;
    HKEY      hkey = NULL;
    LONG      lRes;
    
    // Open the security label admin defaults key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelAdminRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No admin label options were found.  
        goto exit;
    }

    // Read in the admin option.
    cbData = sizeof(dwValue);
    lRes = RegQueryValueEx(hkey, c_szCertErrorWithLabel, NULL, 
                           &dwType, (LPBYTE) &dwValue, &cbData);
    if (ERROR_SUCCESS != lRes) {
        dwValue = CertErrorProcessLabelDeny;
        goto exit;
    }

    // If the value isn't one of the known ones, force it to the default value.
    if ( (CertErrorProcessLabelAnyway != dwValue) && (CertErrorProcessLabelGrant != dwValue) && 
         (CertErrorProcessLabelDeny != dwValue) ) {
        dwValue = CertErrorProcessLabelDeny;
    }

exit:
    if (NULL != hkey)      RegCloseKey(hkey);
    return dwValue;

}


//
// Given a label, queries the policy whether access is to be granted.
// (If reqd policy doesn't exist, it also tries to query the default
// policy, if one exists).
//
HRESULT HrCheckLabelAccess(const DWORD dwFlags, const HWND hwnd, 
           PSMIME_SECURITY_LABEL plabel, const PCCERT_CONTEXT pccertDecrypt,
           const PCCERT_CONTEXT pccertSigner, const HCERTSTORE hcertstor)
{                   
    HRESULT   hr = MIME_E_SECURITY_LABELACCESSDENIED;
    
    HKEY      hkey = NULL;
    HKEY      hkeySub = NULL;
    HINSTANCE hinstDll = NULL;
    PFNGetSMimePolicy pfnGetSMimePolicy = NULL;
    ISMimePolicyCheckAccess *pspca = NULL;
    LONG      lRes;
    DWORD     dwType;
    DWORD     cbData;
    CHAR      szDllPath[MAX_PATH];
    CHAR      szExpandedDllPath[MAX_PATH];
    CHAR      szFuncName[MAX_FUNC_NAME];

        
    if ((NULL == plabel) || (NULL == plabel->pszObjIdSecurityPolicy)) {
        hr = S_OK;    // No label/policyoid => access granted.
        goto exit;
    }



    // Open the security policies key.
    lRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szSecLabelPoliciesRegKey, 0, 
                        KEY_READ, &hkey);
    if ( (ERROR_SUCCESS != lRes) || (NULL == hkey) ) {
        // No security policies are registered. Deny access. 
        goto ErrorReturn;
    }

    // Open the security policy (or default policy regkey).
    lRes = RegOpenKeyEx(hkey, plabel->pszObjIdSecurityPolicy, 0, KEY_READ, &hkeySub); 
    if ((ERROR_SUCCESS != lRes) || (NULL == hkeySub)) {
        if (hkeySub != NULL) {
            RegCloseKey(hkeySub);
            hkeySub = NULL;
        }

        // Try opening the default policy, if one exists.
        lRes = RegOpenKeyEx(hkey, c_szDefaultPolicyOid, 0, KEY_READ, &hkeySub);
        if ((ERROR_SUCCESS != lRes) || (NULL == hkeySub)) {
            // couldn't find specified_and_default policy. deny access.
            goto ErrorReturn;
        }
    }

    Assert(NULL != hkeySub);
    // get the path to the policy dll, and load it.
    cbData = sizeof(szDllPath);
    lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyDllPath, NULL, 
                           &dwType, (LPBYTE)szDllPath, &cbData);
    if (ERROR_SUCCESS != lRes) {
        // policy not correctly registered. deny access.
        goto ErrorReturn;
    }
    szDllPath[ ARRAYSIZE(szDllPath) - 1 ] = '\0';
    // expand environment strings (if any) in the dll path we read in.
    if (REG_EXPAND_SZ == dwType)
    {
        ZeroMemory(szExpandedDllPath, ARRAYSIZE(szExpandedDllPath));
        ExpandEnvironmentStrings(szDllPath, szExpandedDllPath, ARRAYSIZE(szExpandedDllPath));
        szExpandedDllPath[ARRAYSIZE(szExpandedDllPath) - 1] = '\0';
        lstrcpy(szDllPath, szExpandedDllPath);
    }
    
    hinstDll = LoadLibraryEx(szDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);    
    if (NULL == hinstDll) {
        // couldn't load policy. deny access.
        goto ErrorReturn;
    }

    // get the entry func name.
    cbData = sizeof(szFuncName);
    lRes = RegQueryValueEx(hkeySub, c_szSecurityPolicyFuncName, NULL, 
                           &dwType, (LPBYTE)szFuncName, &cbData);
    if (ERROR_SUCCESS != lRes) {
        // policy not correctly registered. deny access.
        goto ErrorReturn;
    }
    pfnGetSMimePolicy = (PFNGetSMimePolicy) GetProcAddress(hinstDll, szFuncName);
    if (NULL == pfnGetSMimePolicy) {
        // couldn't get proc address. deny access.
        goto ErrorReturn;
    }


    hr = (pfnGetSMimePolicy) (0, plabel->pszObjIdSecurityPolicy, GetACP(), 
                              IID_ISMimePolicyCheckAccess, (LPUNKNOWN *) &pspca);
    if (FAILED(hr) || (NULL == pspca)) {
        // couldn't get required interface, 
        goto ErrorReturn;
    }

    // Call into the policy module to find out if access is to be denied/granted.
    hr = pspca->IsAccessGranted(dwFlags, hwnd, plabel, pccertDecrypt, 
                                pccertSigner, hcertstor);

        
    // fall through to exit.



exit:        
    if (pspca)     pspca->Release();
    if (hinstDll)  FreeLibrary(hinstDll);
    if (hkeySub)   RegCloseKey(hkeySub);
    if (hkey)      RegCloseKey(hkey);
    
    return hr;
    
ErrorReturn:
    if (! FAILED(hr)) {
        // If we had an error, but didn't get a failure code, force a failure.
        hr |= 0x80000000; 
    }
    goto exit;
}
#endif // SMIME_V3



/* * * END --- CAPISTM.CPP --- END * * */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\capistm.h ===
/*
**	c a p i s t m . h
**	
**	Purpose: declaration of an IStream that can talk to the
**           CAPI streaming methods
**
**  Owner:   t-erikne
**  Created: 6/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

#ifndef __WINCRYPT_H__
#include <wincrypt.h>
#endif


//
// forwards
//
class CMimePropertyContainer;   // containx.h
class CInternetConverter;   // inetconv.h
typedef struct SMIMEINFOtag SMIMEINFO;  //smime.h
#ifndef WIN16
enum CSstate;   // capistm.cpp
#else // WIN16
enum CSstate {
    STREAM_NOT_BEGUN,
    STREAM_QUESTION_TIME,
    STREAM_QUESTION_TIME_FINAL,
    STREAM_SETUP_DECRYPT,
    STREAM_FIRST_WRITE_OUT,
    STREAM_TEST_NESTING,
    STREAM_DETACHED_OCCURING,
    STREAM_DETACHED_FINAL,  // must be +1 of DO
    STREAM_OCCURING, // must be +1 of DF
    STREAM_FINAL, // must be +1 of SO
    STREAM_ERROR,
    STREAM_GOTTYPE,
    };
#endif // !WIN16


//
// errors
//
#define CAPISTM_E_MSG_CLOSED    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1414)
#define CAPISTM_E_NOT_BEGUN     MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1415)
#define CAPISTM_E_OVERDONE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1416)
#define CAPISTM_E_GOTTYPE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1417)


//
// flags
//
#define CSTM_GO_ALL_THE_WAY     0x00000000
#define CSTM_TYPE_ONLY          0x00000001
#define CSTM_DETACHED           0x00000002
#define CSTM_ALLFLAGS           0x0000ffff
// high word is reserved.  see .cpp file

// NOTES on flags:
// CSTM_TYPE_ONLY -- Can't be called with CSTM_DETACHED.  You ever heard
// of detached encryption?  Also, calling EndStreaming is optional in this
// case since I'll fail my Write() eventually.  Call it and I'll noop. Hmm,
// having said that I recommend calling it.  Less pain in the future if it
// becomes needed.  Don't use this flag on encode, K?

//
// defines
//

//
// class
//
class CCAPIStm : public IStream
{
public:
    CCAPIStm(LPSTREAM lpstmOut);
    ~CCAPIStm(void);

    // --------------------------------------------------------------------
    // IUnknown
    // --------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // --------------------------------------------------------------------
    // IStream
    // --------------------------------------------------------------------
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *)
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *);
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *)
#endif // !WIN16
        { return E_ACCESSDENIED; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *)
        { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *, DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *)
        { return E_NOTIMPL; }
    STDMETHODIMP SetSize(ULARGE_INTEGER)
        { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP Revert(void)
        { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
        { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
        { return E_NOTIMPL; }

    // --------------------------------------------------------------------
    // CCAPIStm
    // --------------------------------------------------------------------
    HRESULT     HrInitialize(DWORD dwFlagsSEF, const HWND hwndParent, const BOOL fEncode, SMIMEINFO *const psi, DWORD dwFlagsStm, IMimeSecurityCallback * pCallback, PSECURITY_LAYER_DATA psld);
    HRESULT     HrInnerInitialize(DWORD dwFlagsSEF, const HWND hwndParent, DWORD dwFlagsStm, IMimeSecurityCallback * pCallback, PSECURITY_LAYER_DATA psld);
    HRESULT     EndStreaming();
    PSECURITY_LAYER_DATA GetSecurityLayerData() const;
    static HRESULT     DuplicateSecurityLayerData(const PSECURITY_LAYER_DATA pcsldIn, PSECURITY_LAYER_DATA *const ppsldOut);
    static void        FreeSecurityLayerData(PSECURITY_LAYER_DATA psld);

protected:
    static void FreeSecurityLayerData(PSECURITY_LAYER_DATA psld, BOOL fStackVar);
    BOOL SniffForEndOfHeader( BYTE *pbData, DWORD cbData);

private:
    DWORD           m_cRef;
    CSstate         m_csStatus;
    CSstate         m_csStream;
    HCRYPTMSG       m_hMsg;
    HCRYPTPROV      m_hProv;
    CCAPIStm *      m_pCapiInner;
    IStream *       m_pstmOut;
    PCCERT_CONTEXT  m_pUserCertDecrypt;
    DWORD           m_dwFlagsStm;
    DWORD           m_cStores;
    HCERTSTORE *    m_rgStores;
    ULONG           m_cbBeginWrite;
    ULONG           m_cbBeginSize;
    CInternetConverter *m_pConverter;
    PSECURITY_LAYER_DATA m_psldData;

    PCRYPT_ATTRIBUTES m_pattrAuth;
#ifndef MAC
#ifdef DEBUG
    IStream *       m_pstmDebugFile;
#endif
#endif  // !MAC
#ifdef SMIME_V3
    IMimeSecurityCallback * m_pSmimeCallback;
    HWND                m_hwnd;
    DWORD               m_dwFlagsSEF;
    UNALIGNED WCHAR *   m_pwszKeyPrompt; 
#endif // SMIME_V3

    LPBYTE          m_pbBuffer;
    DWORD           m_cbBuffer;


    HRESULT BeginEncodeStreaming(SMIMEINFO *const psi);
    HRESULT BeginDecodeStreaming(SMIMEINFO *const psi);

    HRESULT InitInner();
    HRESULT InitInner(SMIMEINFO *const psi, CCAPIStm *pOuter = NULL, PSECURITY_LAYER_DATA psldOuter = NULL);

#ifdef SMIME_V3
    HRESULT FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipientIndex,
                       const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                       HCERTSTORE hcertstor, DWORD * pdwCtrl,
                       CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                       PCCERT_CONTEXT * ppccertDecrypt);
    PCCERT_CONTEXT GetOuterDecryptCert();
#endif // SMIME_V3
    HRESULT VerifySignedMessage();
    BOOL    HandleEnveloped();
    HRESULT HandleNesting(CMimePropertyContainer *pContHeader);

    static BOOL WINAPI CBStreamOutput(const void *pvArg, BYTE *pbData, DWORD cbData, BOOL fFinal);
    BOOL    StreamOutput(BYTE *pbData, DWORD cbData, BOOL fFinal);
};


#ifdef SMIME_V3
HRESULT HrBuildContentEncryptionAlg(PSECURITY_LAYER_DATA psld, BLOB * pblob);
HRESULT HrDeriveKeyWrapAlg(PSECURITY_LAYER_DATA psld, CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO * pAgree);
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\cryptdbg.h ===
/*  CRYPTDBG.H
**
**
**
**
*/

#ifndef __CRYPTDBG_H
#define __CRYPTDBG_H

#ifdef DEBUG
BOOL InitDebugHelpers(HINSTANCE hLib);
void DisplayCert(PCCERT_CONTEXT pCert);
void DisplayCrl(PCCRL_CONTEXT pCrl);
void PrintError(LPCSTR pszMsg);

void SMDOUT(LPSTR szFmt, ...);
void CRDOUT(LPSTR szFmt, ...);
void CSSDOUT(LPSTR szFmt, ...);

#else // !DEBUG

#define SMDOUT      1 ? (void)0 : (void)
#define CRDOUT      1 ? (void)0 : (void)
#define CSSDOUT     1 ? (void)0 : (void)
#endif

#define CRYPT_LEVEL     (1024)
#define DOUTL_SMIME     CRYPT_LEVEL
#define DOUTL_CSS       4096

#endif // include once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enriched.h ===
// --------------------------------------------------------------------------------
// Enriched.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENRICHED_H
#define __ENRICHED_H

HRESULT MimeOleConvertEnrichedToHTML(IStream *pIn, IStream *pOut);
HRESULT MimeOleConvertEnrichedToHTMLEx(IMimeBody *pBody, ENCODINGTYPE ietEncoding, IStream **ppStream);

#endif // __ENRICHED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\contain2.cpp ===
// --------------------------------------------------------------------------------
// Contain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "internat.h"
#include "inetstm.h"
#include "dllmain.h"
#include "olealloc.h"
#include "objheap.h"
#include "vstream.h"
#include "addparse.h"
#include "enumhead.h"
#include "addrenum.h"
#include "stackstr.h"
#include "stmlock.h"
#include "enumprop.h"
#ifndef WIN16
#include "wchar.h"
#endif // !WIN16
#include "symcache.h"
#ifdef MAC
#include <stdio.h>
#endif  // MAC
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD   g_cSetPidLookups;
extern DWORD   g_cHashLookups;
extern DWORD   g_cHashInserts;
extern DWORD   g_cHashCollides;
#endif

// --------------------------------------------------------------------------------
// Default Header Options
// --------------------------------------------------------------------------------
extern const HEADOPTIONS g_rDefHeadOptions;

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
static const ENCODINGTABLE g_rgEncoding[] = {
    { STR_ENC_7BIT,         IET_7BIT     },
    { STR_ENC_QP,           IET_QP       },
    { STR_ENC_BASE64,       IET_BASE64   },
    { STR_ENC_UUENCODE,     IET_UUENCODE },
    { STR_ENC_XUUENCODE,    IET_UUENCODE },
    { STR_ENC_XUUE,         IET_UUENCODE },
    { STR_ENC_8BIT,         IET_8BIT     },
    { STR_ENC_BINARY,       IET_BINARY   }
};



// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrResolveURL
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrResolveURL(LPRESOLVEURLINFO pURL)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSTRINGA   pBase=NULL;
    LPPROPSTRINGA   pContentID=NULL;
    LPPROPSTRINGA   pLocation=NULL;
    LPSTR           pszAbsURL1=NULL;
    LPSTR           pszAbsURL2=NULL;

    // Invalid Arg
    Assert(pURL);

    // Init Stack Strings
    STACKSTRING_DEFINE(rCleanCID, 255);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Content-Location
    if (m_prgIndex[PID_HDR_CNTLOC])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTLOC]->rValue));
        pLocation = &m_prgIndex[PID_HDR_CNTLOC]->rValue.rStringA;
    }

    // Content-ID
    if (m_prgIndex[PID_HDR_CNTID])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTID]->rValue));
        pContentID = &m_prgIndex[PID_HDR_CNTID]->rValue.rStringA;
    }

    // Content-Base
    if (m_prgIndex[PID_HDR_CNTBASE])
    {
        Assert(ISSTRINGA(&m_prgIndex[PID_HDR_CNTBASE]->rValue));
        pBase = &m_prgIndex[PID_HDR_CNTBASE]->rValue.rStringA;
    }

    // Both Null, no match
    if (!pLocation && !pContentID)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // If URL is a CID
    if (TRUE == pURL->fIsCID) 
    {
        // If we have a Content-Location
        if (pLocation)
        {
            // Match char for char
            if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pURL->pszURL, FALSE) == S_OK)
                goto exit;
        }

        // Otherwise, compare against pContentId
        else
        {
            // Match char for char minus cid:
            if (lstrcmpi(pURL->pszURL + 4, pContentID->pszVal) == 0)
                goto exit;

            // Get Stack Stream Read for
            STACKSTRING_SETSIZE(rCleanCID, lstrlen(pURL->pszURL));

            // Format the Cleaned CID
            wsprintf(rCleanCID.pszVal, "<%s>", pURL->pszURL + 4);

            // Match char for char minus cid:
            if (lstrcmpi(rCleanCID.pszVal, pContentID->pszVal) == 0)
                goto exit;
        }
    }

    // Otherwise, non-CID resolution
    else if (pLocation)
    {
        // Part Has Base
        if (NULL != pBase)
        {
            // Combine URLs
            CHECKHR(hr = MimeOleCombineURL(pBase->pszVal, pBase->cchVal, pLocation->pszVal, pLocation->cchVal, TRUE, &pszAbsURL1));

            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (lstrcmpi(pURL->pszURL, pszAbsURL1) == 0)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (lstrcmpi(pszAbsURL1, pszAbsURL2) == 0)
                    goto exit;
            }
        }

        // Part has no base
        else
        {
            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pURL->pszURL, FALSE) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrl(pLocation->pszVal, TRUE, pszAbsURL2, FALSE) == S_OK)
                    goto exit;
            }
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Cleanup
    STACKSTRING_FREE(rCleanCID);
    SafeMemFree(pszAbsURL1);
    SafeMemFree(pszAbsURL2);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentType
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT hr=S_OK;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && lstrcmpi(pszPriType, STR_CNT_TEXT) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Comparing pszPriType
        if (pszPriType && lstrcmpi(pszPriType, pCntType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Comparing pszSubType
        if (pszSubType && lstrcmpi(pszSubType, pSubType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimePropertySet, (LPVOID *)ppPropertySet));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(LPCONTAINER *ppContainer)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCONTAINER         pContainer=NULL;

    // Invalid ARg
    if (NULL == ppContainer)
        return TrapError(E_INVALIDARG);

    // Init
    *ppContainer = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Create new container, NULL == no outer property set
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init that new container
    CHECKHR(hr = pContainer->InitNew());

    // Interate the Properties
    CHECKHR(hr = _HrClonePropertiesTo(pContainer));

    // If I have a stream, give it to the new table
    if (m_pStmLock)
    {
        // Just pass m_pStmLock into pTable
        pContainer->m_pStmLock = m_pStmLock;
        pContainer->m_pStmLock->AddRef();
        pContainer->m_cbStart = m_cbStart;
        pContainer->m_cbSize = m_cbSize;
    }

    // Give it my state
    pContainer->m_dwState = m_dwState;

    // Give it my options
    pContainer->m_rOptions.pDefaultCharset = m_rOptions.pDefaultCharset;
    pContainer->m_rOptions.cbMaxLine = m_rOptions.cbMaxLine;
    pContainer->m_rOptions.fAllow8bit = m_rOptions.fAllow8bit;

    // Return Clone
    (*ppContainer) = pContainer;
    (*ppContainer)->AddRef();

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrClonePropertiesTo
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrClonePropertiesTo(LPCONTAINER pContainer)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pCurrHash, pCurrValue, pDestProp;

    // Invalid Arg
    Assert(pContainer);

    // Loop through the item table
    for (ULONG i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
        {
            // Walk multiple Values
            for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
            {
                // Linked Attributes are Not Copied
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ATTRIBUTE) && NULL != pCurrValue->pSymbol->pLink)
                    continue;

                // Does the Property need to be parsed ?
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
                {
                    // Make sure the address is parsed
                    CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
                }

                // Insert Copy of pCurrValue into pContiner
                CHECKHR(hr = pContainer->HrInsertCopy(pCurrValue));
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pCurrValue;

    // Walk multiple Values
    for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
    {
        // Does the Property need to be parsed ?
        if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Make sure the address is parsed
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
        }

        // Insert pProperty into pDest
        CHECKHR(hr = pDest->HrInsertCopy(pCurrValue));
    }

    // If pCurrHash has Parameters, copy those over as well
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Copy Parameters
        CHECKHR(hr = _HrCopyParameters(pProperty, pDest));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;
    
    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Remove the parameter
        CHECKHR(hr = pDest->HrInsertCopy(pParameter));

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrInsertCopy
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrInsertCopy(LPPROPERTY pSource)
{
    // Locals
    HRESULT           hr=S_OK;
    LPPROPERTY        pDest;
    LPMIMEADDRESS    pAddress;
    LPMIMEADDRESS    pNew;

    // Invalid Arg
    Assert(pSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Append a new property to the 
    CHECKHR(hr = _HrAppendProperty(pSource->pSymbol, &pDest));

    // If this is an address...
    if (ISFLAGSET(pSource->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Both Address Group Better Exist
        Assert(pSource->pGroup && pDest->pGroup && !ISFLAGSET(pSource->dwState, PRSTATE_NEEDPARSE));

        // Loop Infos...
        for (pAddress=pSource->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Append pDest->pGroup
            CHECKHR(hr = _HrAppendAddressGroup(pDest->pGroup, &pNew));

            // Copy Current to New
            CHECKHR(hr = HrMimeAddressCopy(pAddress, pNew));
        }
    }

    // Otheriwse, just set the variant data on pDest
    else
    {
        // Set It
        CHECKHR(hr = _HrSetPropertyValue(pDest, 0, &pSource->rValue));
    }

    // Copy the State
    pDest->dwState = pSource->dwState;
    pDest->dwRowNumber = pSource->dwRowNumber;
    pDest->cboffStart = pSource->cboffStart;
    pDest->cboffColon = pSource->cboffColon;
    pDest->cboffEnd = pSource->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CopyProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty,
                    pCurrValue,
                    pCurrHash,
                    pNextHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);

                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest));
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);

                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest));
                }
            }
        }
    }

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::MoveProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurrHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            pCurrHash = m_prgHashTable[i];

            // Walk the Hash Chain
            while(pCurrHash)
            {
                // Delete Property from the destination
                pDest->DeleteProp(pCurrHash->pSymbol);

                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest));

                // Delete pProperty
                _UnlinkProperty(pCurrHash, &pCurrHash);
            }
        }
    }

    // Otherwise, selective move
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);

                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest));

                    // Delete pProperty
                    _UnlinkProperty(pProperty);
                }
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetOption(const TYPEDID oid, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        if (pVariant->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        if (m_rOptions.fNoDefCntType != (pVariant->boolVal ? TRUE : FALSE))
            m_rOptions.fNoDefCntType = pVariant->boolVal ? TRUE : FALSE;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bit != (pVariant->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.fAllow8bit = pVariant->boolVal ? TRUE : FALSE;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        if (pVariant->ulVal < MIN_CBMAX_HEADER_LINE || pVariant->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.cbMaxLine = pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pVariant->ulVal && SAVE_RFC1521 != pVariant->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pVariant->ulVal;
        }
        break;    

    // -----------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetOption(const TYPEDID oid, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    pVariant->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        pVariant->ulVal = m_rOptions.ReloadType;
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        pVariant->boolVal = m_rOptions.fNoDefCntType;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        pVariant->boolVal = m_rOptions.fAllow8bit;
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        pVariant->ulVal = m_rOptions.cbMaxLine;
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        pVariant->ulVal = (ULONG)m_rOptions.savetype;
        break;    

    // -----------------------------------------------------------------------
    default:
        pVariant->vt = VT_NULL;
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetMessageFlags
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetMessageFlags(BOOL fHideTnef)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPCSTR pszPriType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_PRITYPE], STR_CNT_TEXT);
    LPCSTR pszSubType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_SUBTYPE], STR_SUB_PLAIN);
    LPCSTR pszCntDisp = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDISP], STR_DIS_INLINE);

    // Mime
    if (m_prgIndex[PID_HDR_MIMEVER])
        FLAGSET(dwFlags, IMF_MIME);

    // IMF_NEWS
    if (m_prgIndex[PID_HDR_XNEWSRDR]  || m_prgIndex[PID_HDR_NEWSGROUPS] || m_prgIndex[PID_HDR_NEWSGROUP] || m_prgIndex[PID_HDR_PATH])
        FLAGSET(dwFlags, IMF_NEWS);

    // text
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
    {
        // There is text
        FLAGSET(dwFlags, IMF_TEXT);

        // text/plain
        if (lstrcmpi(pszSubType, STR_SUB_PLAIN) == 0)
            FLAGSET(dwFlags, IMF_PLAIN);

        // text/html
        else if (lstrcmpi(pszSubType, STR_SUB_HTML) == 0)
            FLAGSET(dwFlags, IMF_HTML);
    }

    // multipart
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
    {
        // Multipart
        FLAGSET(dwFlags, IMF_MULTIPART);

        // multipart/related
        if (lstrcmpi(pszSubType, STR_SUB_RELATED) == 0)
            FLAGSET(dwFlags, IMF_MHTML);

        // multipart/signed
        else if (0 == lstrcmpi(pszSubType, STR_SUB_SIGNED))
            FLAGSET(dwFlags, IMF_SIGNED | IMF_SECURE);
    }

    // message/partial
    else if (lstrcmpi(pszPriType, STR_CNT_MESSAGE) == 0 && lstrcmpi(pszSubType, STR_SUB_PARTIAL) == 0)
        FLAGSET(dwFlags, IMF_PARTIAL);

    // application
    else if (lstrcmpi(pszPriType, STR_CNT_APPLICATION) == 0)
    {
        // application/ms-tnef
        if (0 == lstrcmpi(pszSubType, STR_SUB_MSTNEF))
            FLAGSET(dwFlags, IMF_TNEF);

        // application/x-pkcs7-mime
        else if (0 == lstrcmpi(pszSubType, STR_SUB_XPKCS7MIME) ||
            0 == lstrcmpi(pszSubType, STR_SUB_PKCS7MIME))  // nonstandard
            FLAGSET(dwFlags, IMF_SECURE);
    }

    // Raid-37086 - Cset Tagged
    if (ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        FLAGSET(dwFlags, IMF_CSETTAGGED);

    // Attachment...
    if (!ISFLAGSET(dwFlags, IMF_MULTIPART) && (FALSE == fHideTnef || !ISFLAGSET(dwFlags, IMF_TNEF)))
    {
        // Marked as an attachment ?
        if (!ISFLAGSET(dwFlags, IMF_SECURE) && 0 != lstrcmpi(pszSubType, STR_SUB_PKCS7SIG))
        {
            // Not Rendered Yet
            if (NULL == m_prgIndex[PID_ATT_RENDERED])
            {
                // Marked as an Attachment
                if (lstrcmpi(pszCntDisp, STR_DIS_ATTACHMENT) == 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Type: xxx; name=xxx
                else if (NULL != m_prgIndex[PID_PAR_NAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Disposition: xxx; filename=xxx
                else if (NULL != m_prgIndex[PID_PAR_FILENAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Else if it is not marked as text
                else if (ISFLAGSET(dwFlags, IMF_TEXT) == FALSE)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // If not text/plain and not text/html
                else if (lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0 && lstrcmpi(pszSubType, STR_SUB_HTML) != 0 && lstrcmpi(pszSubType, STR_SUB_ENRICHED) != 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetEncodingType
// --------------------------------------------------------------------------------
ENCODINGTYPE CMimePropertyContainer::GetEncodingType(void)
{
    // Locals
    ENCODINGTYPE ietEncoding=IET_7BIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPPROPERTY pCntXfer = m_prgIndex[PID_HDR_CNTXFER];

    // Do we have data the I like ?
    if (pCntXfer && ISSTRINGA(&pCntXfer->rValue))
    {
        // Local
        CStringParser cString;

        // cString...
        cString.Init(pCntXfer->rValue.rStringA.pszVal, pCntXfer->rValue.rStringA.cchVal, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS);

        // Parse to end, remove white space and comments
        SideAssert('\0' == cString.ChParse(""));

        // Loop the table
        for (ULONG i=0; i<ARRAYSIZE(g_rgEncoding); i++)
        {
            // Match Encoding Strings
            if (lstrcmpi(g_rgEncoding[i].pszEncoding, cString.PszValue()) == 0)
            {
                ietEncoding = g_rgEncoding[i].ietEncoding;
                break;
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return ietEncoding;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetInlineSymbol
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szHeader[255];
    LPSTR       pszHeader=NULL;

    // Invalid Arg
    Assert(pszData && ppSymbol);

    // _HrParseInlineHeaderName
    CHECKHR(hr = _HrParseInlineHeaderName(pszData, szHeader, sizeof(szHeader), &pszHeader, pcboffColon));

    // Find Global Property
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, ppSymbol));

exit:
    // Cleanup
    if (pszHeader != szHeader)
        SafeMemFree(pszHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInlineHeaderName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch, 
    LPSTR *ppszHeader, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=(LPSTR)pszData,
                pszStart;
    ULONG       i=0;

    // Invalid Arg
    Assert(pszData && pszScratch && ppszHeader && pcboffColon);

    // Lets Parse the name out and find the symbol
    while (*psz && (' ' == *psz || '\t' == *psz))
    {
        i++;
        psz++;
    }

    // Done
    if ('\0' == *psz)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Seek to the colon
    pszStart = psz;
    while (*psz && ':' != *psz)
    {
        i++;
        psz++;
    }

    // Set Colon Position
    (*pcboffColon) = i;

    // Done
    if ('\0' == *psz || 0 == i)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Copy the name
    if (i + 1 <= cchScratch)
        *ppszHeader = pszScratch;

    // Otherwise, allocate
    else
    {
        // Allocate space for the name
        *ppszHeader = PszAllocA(i + 1);
        if (NULL == *ppszHeader)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Copy the data
    CopyMemory(*ppszHeader, pszStart, i);

    // Null
    *((*ppszHeader) + i) = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindFirstRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Invalid Arg
    if (NULL == pFindHeader)
        return TrapError(E_INVALIDARG);

    // Init pFindHeader
    pFindHeader->dwReserved = 0;

    // FindNext
    return FindNextRow(pFindHeader, phRow);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindNextRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pFindHeader || NULL == phRow)
        return TrapError(E_INVALIDARG);

    // Init
    *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=pFindHeader->dwReserved; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pFindHeader->pszHeader || lstrcmpi(pRow->pSymbol->pszName, pFindHeader->pszHeader) == 0)
        {
            // Save Index of next item to search
            pFindHeader->dwReserved = i + 1;

            // Return the handle
            *phRow = pRow->hRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    pFindHeader->dwReserved = m_rHdrTable.cRows; 
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CountRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountRows(LPCSTR pszHeader, ULONG *pcRows)
{
    // Locals
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Init
    *pcRows = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=0; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pszHeader || lstrcmpi(pRow->pSymbol->pszName, pszHeader) == 0)
            (*pcRows)++;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData, 
    LPHHEADERROW phRow)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    ULONG           cboffColon;
    LPPROPERTY      pProperty;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Init
    if (phRow)
        *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a header, lookup the symbol
    if (pszHeader)
    {
        // HTF_NAMEINDATA better not be set
        Assert(!ISFLAGSET(dwFlags, HTF_NAMEINDATA));

        // Lookup the symbol
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, &pSymbol));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Set the Data on this row
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData, cchData));
    }

    // Otherwise...
    else if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // GetInlineSymbol
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Remove IHF_NAMELINE
        FLAGCLEAR(dwFlags, HTF_NAMEINDATA);

        // Set the Data on this row
        Assert(cboffColon + 1 < cchData);
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData + cboffColon + 1, cchData - cboffColon - 1));
    }

    // Otherwise, failed
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteRow(HHEADERROW hRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Standard Delete Prop
    CHECKHR(hr = DeleteProp(pRow->pSymbol));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchData=0;
    LPPROPERTY  pRow;
    MIMEVARIANT rValue;
    DWORD       dwPropFlags;

    // Init
    if (ppszData)
        *ppszData = NULL;
    if (pcchData)
        *pcchData = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Compute dwPropFlags
    dwPropFlags = PDF_HEADERFORMAT | ((dwFlags & HTF_NAMEINDATA) ? PDF_NAMEINDATA : 0);

    // Speicify data type
    rValue.type = MVT_STRINGA;

    // Ask the value for the data
    CHECKHR(hr = _HrGetPropertyValue(pRow, dwPropFlags, &rValue));

    // Want Length
    cchData = rValue.rStringA.cchVal;

    // Want the data
    if (ppszData)
    {
        *ppszData = rValue.rStringA.pszVal;
        rValue.rStringA.pszVal = NULL;
    }

    // Else Free It
    else
        SafeMemFree(rValue.rStringA.pszVal);

    // Verify the NULL
    Assert(ppszData ? '\0' == *((*ppszData) + cchData) : TRUE);

    // Return Length ?
    if (pcchData)
        *pcchData = cchData;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    MIMEVARIANT     rValue;
    ULONG           cboffColon;
    LPPROPSYMBOL    pSymbol;
    LPSTR           psz=(LPSTR)pszData;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // If HTF_NAMEINDATA
    if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // Extract the name
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Symbol Must be the same
        if (pRow->pSymbol != pSymbol)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Adjust pszData
        Assert(cboffColon < cchData);
        psz = (LPSTR)(pszData + cboffColon + 1);
        cchData = cchData - cboffColon - 1;
        Assert(psz[cchData] == '\0');
    }

    // Setup the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = psz;
    rValue.rStringA.cchVal = cchData;

    // Tell value about the new row data
    CHECKHR(hr = _HrSetPropertyValue(pRow, 0, &rValue));

    // Clear Position Information
    pRow->cboffStart = 0;
    pRow->cboffColon = 0;
    pRow->cboffEnd = 0;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pInfo->dwRowNumber = pRow->dwRowNumber;
    pInfo->cboffStart = pRow->cboffStart;
    pInfo->cboffColon = pRow->cboffColon;
    pInfo->cboffEnd = pRow->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowNumber
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pRow->dwRowNumber = dwRowNumber;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         iEnum=0,
                         cEnumCount;
    LPENUMHEADERROW      pEnumRow=NULL;
    LPPROPERTY           pRow;
    CMimeEnumHeaderRows *pEnum=NULL;
    LPROWINDEX           prgIndex=NULL;
    ULONG                cRows;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Lets Count the Rows
    CHECKHR(hr = CountRows(pszHeader, &cEnumCount));

    // Allocate pEnumRow
    CHECKALLOC(pEnumRow = (LPENUMHEADERROW)g_pMalloc->Alloc(cEnumCount * sizeof(ENUMHEADERROW)));

    // ZeroInit
    ZeroMemory(pEnumRow, cEnumCount * sizeof(ENUMHEADERROW));

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Is this a header the client wants
        if (NULL == pszHeader || lstrcmpi(pszHeader, pRow->pSymbol->pszName) == 0)
        {
            // Valide
            Assert(iEnum < cEnumCount);

            // Set the symbol on this enum row
            pEnumRow[iEnum].dwReserved = (DWORD)pRow->pSymbol;

            // Lets always give the handle
            pEnumRow[iEnum].hRow = pRow->hRow;

            // If Enumerating only handles...
            if (!ISFLAGSET(dwFlags, HTF_ENUMHANDLESONLY))
            {
                // Get the data for this enum row
                CHECKHR(hr = GetRowData(pRow->hRow, dwFlags, &pEnumRow[iEnum].pszData, &pEnumRow[iEnum].cchData));
            }

            // Increment iEnum
            iEnum++;
        }
    }
        
    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, dwFlags, cEnumCount, pEnumRow, FALSE));

    // Don't Free pEnumRow
    pEnumRow = NULL;

    // Return it
    (*ppEnum) = (IMimeEnumHeaderRows *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeMemFree(prgIndex);
    if (pEnumRow)
        g_cMoleAlloc.FreeEnumHeaderRowArray(cEnumCount, pEnumRow, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream, 
    ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pStream && pcAddrsWrote);
    Assert(!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        CHECKHR(hr = _HrSaveAddress(pProperty, pAddress, pStream, pcAddrsWrote, format));

        // Increment cAddresses Count
        (*pcAddrsWrote)++;
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, 
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszName=NULL;
    BOOL            fWriteEmail=FALSE;
    LPSTR           pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyA(pAddress->rFriendly.psz) && FIsEmptyA(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_szAddressFold, lstrlen(c_szAddressFold), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyA(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyA(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if (AFT_RFC822_TRANSMIT == format && fWriteEmail && StrStr(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszName = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGA;
            rSource.type = MVT_STRINGA;

            // Init pszName
            pszName = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeString(CP_ACP, pszName, &pszEscape) == S_OK)
            {
                // Escaped
                pszName = pszEscape;
                rSource.rStringA.pszVal = pszName;
                rSource.rStringA.cchVal = lstrlen(pszName);
            }

            // Otherwise
            else
            {
                rSource.rStringA.pszVal = pAddress->rFriendly.psz;
                rSource.rStringA.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
            {
                // Encode It
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC | PDF_ENCODED, 0, &rSource, &rDest)))
                    pszName = rDest.rStringA.pszVal;
            }

            // Decoded
            else if (IET_ENCODED == pAddress->ietFriendly)
            {
                // Encode It
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC, 0, &rSource, &rDest)))
                    pszName = rDest.rStringA.pszVal;
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszName)
    {
        // Write Quote
        if (fRFC822)
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));

        // Write display name
        CHECKHR(hr = pStream->Write(pszName, lstrlen(pszName), NULL));

        // Write Quote
        if (fRFC822)
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCSTR pszStart = pszName ? c_szEmailSpaceStart : c_szEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlen(pszStart), NULL));

        // Write email
        CHECKHR(hr = pStream->Write(pAddress->rEmail.psz, pAddress->rEmail.cch, NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria, 
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pszCriteria);

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        if (_HrQueryAddress(pProperty, pAddress, pszCriteria, fSubString, fCaseSensitive) == S_OK)
            goto exit;
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszDisplay;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pszCriteria);

    // Init
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Query Email Address First
    if (MimeOleQueryString(pAddress->rEmail.psz, pszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Decode Display Name
    pszDisplay = pAddress->rFriendly.psz;

    // Decode the Property
    if (IET_ENCODED == pAddress->ietFriendly)
    {
        // Set Source
        rDest.type = MVT_STRINGA;
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pAddress->rFriendly.psz;
        rSource.rStringA.cchVal = pAddress->rFriendly.cch;

        // Decode the Property
        if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, pAddress->ietFriendly, CVF_NOALLOC, 0, &rSource, &rDest)))
            pszDisplay = rDest.rStringA.pszVal;
    }

    // Query Email Address First
    if (MimeOleQueryString(pszDisplay, pszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Not Found
    hr = S_FALSE;

exit:
    // Cleanup
    MimeVariantFree(&rDest);

    // Done
    return hr;
}


// ----------------------------------------------------------------------------
// CMimePropertyContainer::Append
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly, 
    LPCSTR pszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(ADDRESSPROPS));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = (LPSTR)pszFriendly;
    }

    // Set pszEmail
    if (pszEmail)
    {
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = (LPSTR)pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Insert
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address and Address Type
    if (!ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) || (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail)))
        return TrapError(E_INVALIDARG);

    // Init
    if (phAddress)
        *phAddress = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

    // Open the group
    CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Append an Address to the group
    CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

    // The group is dirty
    Assert(pAddress->pGroup);
    pAddress->pGroup->fDirty = TRUE;

    // Set the Address Type
    pAddress->dwAdrType = pProps->dwAdrType;

    // Copy Address Props to Mime Address
    CHECKHR(hr = SetProps(pAddress->hThis, pProps));

    // Return the Handle
    if (phAddress)
        *phAddress = pAddress->hThis;

exit:
    // Failure
    if (FAILED(hr) && pAddress)
        Delete(pAddress->hThis);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
        pAddress->dwAdrType = pProps->dwAdrType;

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
        pAddress->ietFriendly = pProps->ietFriendly;

    // IAP_HCHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET) && pProps->hCharset)
    {
        // Resolve to pCharset
        LPINETCSETINFO pCharset;
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pProps->hCharset, &pCharset)))
            pAddress->pCharset = pCharset;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
        pAddress->certstate = pProps->certstate;

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
        pAddress->dwCookie = pProps->dwCookie;

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY) && pProps->pszFriendly)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenA(pProps->pszFriendly, lstrlen(pProps->pszFriendly), &pAddress->rFriendly));
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && pProps->pszEmail)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenA(pProps->pszEmail, lstrlen(pProps->pszEmail), &pAddress->rEmail));
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT) && pProps->tbSigning.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbSigning.pBlobData);
        pAddress->tbSigning.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbSigning, &pAddress->tbSigning));
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT) && pProps->tbEncryption.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbEncryption.pBlobData);
        pAddress->tbEncryption.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbEncryption, &pAddress->tbEncryption));
    }

    // pAddress->pGroup is Dirty
    Assert(pAddress->pGroup);
    if (pAddress->pGroup)
        pAddress->pGroup->fDirty = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_CHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET))
    {
        if (pAddress->pCharset && pAddress->pCharset->hCharset)
        {
            pProps->hCharset = pAddress->pCharset->hCharset;
        }
        else
        {
            pProps->hCharset = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_CHARSET);
        }
    }

    // IAP_HANDLE
    if (ISFLAGSET(pProps->dwProps, IAP_HANDLE))
    {
        Assert(pAddress->hThis);
        pProps->hAddress = pAddress->hThis;
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
    {
        Assert(pAddress->dwAdrType);
        pProps->dwAdrType = pAddress->dwAdrType;
    }

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
    {
        pProps->dwCookie = pAddress->dwCookie;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
    {
        pProps->certstate = pAddress->certstate;
    }

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
    {
        pProps->ietFriendly = pAddress->ietFriendly;
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY))
    {
        // Decode
        if (!FIsEmptyA(pAddress->rFriendly.psz))
        {
            // Encoded
            if (IET_ENCODED == pAddress->ietFriendly)
            {
                // Locals
                LPPROPSYMBOL    pSymbol;
                MIMEVARIANT     rSource;
                MIMEVARIANT     rDest;

                // Get the symbol of the address tyep
                CHECKHR(hr = g_pSymCache->HrOpenSymbol(pAddress->dwAdrType, &pSymbol));

                // Setup Source
                rSource.type = MVT_STRINGA;
                rSource.rStringA.pszVal = pAddress->rFriendly.psz;
                rSource.rStringA.cchVal = pAddress->rFriendly.cch;

                // Setup Dest
                rDest.type = MVT_STRINGA;

                // Decode It
                if (SUCCEEDED(HrConvertVariant(pSymbol, pAddress->pCharset, IET_ENCODED, 0, 0, &rSource, &rDest)))
                    pProps->pszFriendly = rDest.rStringA.pszVal;

                // Otherwise, dup it
                else
                {
                    // Dup
                    CHECKALLOC(pProps->pszFriendly = PszDupA(pAddress->rFriendly.psz));
                }
            }

            // Otherwise, just copy it
            else
            {
                // Dup
                CHECKALLOC(pProps->pszFriendly = PszDupA(pAddress->rFriendly.psz));
            }
        }
        else
        {
            pProps->pszFriendly = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLY);
        }
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL))
    {
        if (!FIsEmptyA(pAddress->rEmail.psz))
        {
            CHECKALLOC(pProps->pszEmail = PszDupA(pAddress->rEmail.psz));
        }
        else
        {
            pProps->pszEmail = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_EMAIL);
        }
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT))
    {
        if (pAddress->tbSigning.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbSigning, &pProps->tbSigning));
        }
        else
        {
            pProps->tbSigning.pBlobData = NULL;
            pProps->tbSigning.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_SIGNING_PRINT);
        }
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT))
    {
        if (pAddress->tbEncryption.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbEncryption, &pProps->tbEncryption));
        }
        else
        {
            pProps->tbEncryption.pBlobData = NULL;
            pProps->tbEncryption.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_ENCRYPTION_PRINT);
        }
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::SetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Address Type
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) && pProps->dwAdrType != pAddress->dwAdrType)
    {
        // Unlink this address from this group
        _UnlinkAddress(pAddress);

        // Get Header
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

        // Open the group
        CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // LinkAddress
        _LinkAddress(pAddress, pProperty->pGroup);

        // Dirty
        pProperty->pGroup->fDirty = TRUE;
    }

    // Changing other properties
    CHECKHR(hr = _HrSetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Email Address to Null
    CHECKHR(hr = _HrGetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetSender
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSender(LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPERTY          pProperty;
    LPPROPERTY          pSender=NULL;
    HADDRESS            hAddress=NULL;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find first from
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_FROM))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Take the first address
            if (pProperty->pGroup->pHead)
                hAddress = pProperty->pGroup->pHead->hThis;

            // Done
            break;
        }

        // Look for Sender:
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_SENDER) && NULL == pSender)
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Sender Property
            pSender = pProperty;
        }
    }

    // Is there a sender group
    if (NULL == hAddress && NULL != pSender && NULL != pSender->pGroup->pHead)
        hAddress = pSender->pGroup->pHead->hThis;

    // No Address
    if (NULL == hAddress)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get Props
    CHECKHR(hr = GetProps(hAddress, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::CountTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountTypes(DWORD dwAdrTypes, ULONG *pcAdrs)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    if (NULL == pcAdrs)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcAdrs = 0;

    // Loop through groups
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Increment Count
            (*pcAdrs) += pProperty->pGroup->cAdrs;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               iAddress;
    LPPROPERTY          pProperty;
    LPMIMEADDRESS       pAddress;

    // Invalid Arg
    if (NULL == pList)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through groups
    CHECKHR(hr = CountTypes(dwAdrTypes, &pList->cAdrs));

    // Nothing..
    if (0 == pList->cAdrs)
        goto exit;

    // Allocate an array
    CHECKHR(hr = HrAlloc((LPVOID *)&pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS)));

    // Init
    ZeroMemory(pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS));

    // Fill with types...
    for (iAddress=0, pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Loop Infos...
        for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Verify Size...
            Assert(iAddress < pList->cAdrs);

            // Zeromemory
            ZeroMemory(&pList->prgAdr[iAddress], sizeof(ADDRESSPROPS));

            // Set Desired Props
            pList->prgAdr[iAddress].dwProps = dwProps;

            // Get the Address Props
            CHECKHR(hr = _HrGetAddressProps(&pList->prgAdr[iAddress], pAddress));

            // Increment piCurrent
            iAddress++;
        }
    }

exit:
    // Failure..
    if (FAILED(hr))
    {
        g_cMoleAlloc.FreeAddressList(pList);
        ZeroMemory(pList, sizeof(ADDRESSLIST));
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::EnumTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT                hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;
    ADDRESSLIST            rList;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init out param in case of error
    *ppEnum = NULL;

    // Init rList
    ZeroMemory(&rList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the address lsit
    CHECKHR(hr = GetTypes(dwAdrTypes, dwProps, &rList));

    // Create a new Enumerator
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit((IMimeAddressTable *)this, 0, &rList, FALSE));

    // Clear rList
    rList.cAdrs = 0;
    rList.prgAdr = NULL;

    // Return it
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    if (rList.cAdrs)
        g_cMoleAlloc.FreeAddressList(&rList);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Delete
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Delete(HADDRESS hAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref Address
    pAddress = HADDRESSGET(hAddress);

    // Unlink this address
    _UnlinkAddress(pAddress);

    // Unlink this address
    _FreeAddress(pAddress);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::DeleteTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteTypes(DWORD dwAdrTypes)
{
    // Locals
    LPPROPERTY      pProperty;
    BOOL            fFound;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // While there are address types
    while(dwAdrTypes)
    {
        // Reset fFound
        fFound = FALSE;

        // Search for first delete-able address type
        for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
        {
            // Not the type I want
            if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            {
                // We found a properyt
                fFound = TRUE;

                // Clear this address type ad being deleted
                FLAGCLEAR(dwAdrTypes, pProperty->pSymbol->dwAdrType);

                // Unlink this property
                _UnlinkProperty(pProperty);

                // Done
                break;
            }
        }

        // No Property Found
        if (FALSE == fFound)
            break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetFormat
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat)
{
    // Locals
    HRESULT              hr=S_OK;
    CByteStream          cByteStream;
    ULONG                cAddrsWrote=0;
    LPPROPERTY           pProperty;

    // check params
    if (NULL == ppszFormat)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Fill with types...
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrType, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Tell the group object to write its display address into pStream
        CHECKHR(hr = _HrSaveAddressGroup(pProperty, &cByteStream, &cAddrsWrote, format));
     }

    // Did we write any for this address tyep ?
    if (cAddrsWrote)
    {
        // Get Text
        CHECKHR(hr = cByteStream.HrAcquireStringA(NULL, ppszFormat, ACQ_DISPLACE));
    }
    else
        hr = MIME_E_NO_DATA;
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszRfc822Adr;
    rValue.rStringA.cchVal = lstrlen(pszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, 
    LPCSTR pszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    LPSTR               pszData=(LPSTR)pszRfc822Adr;
    PROPVARIANT         rDecoded;
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;

    // Invalid Arg
    if (NULL == pszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // LocalInit
    ZeroMemory(&rDecoded, sizeof(PROPVARIANT));

    // ZeroParse
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Decode...
    if (IET_DECODED != ietEncoding)
    {
        // Setup rfc1522Info
        rRfc1522Info.fRfc1522Allowed = TRUE;
        rRfc1522Info.fAllow8bit = FALSE;
        rDecoded.vt = VT_LPSTR;

        // Check for 1522 Encoding...
        if (SUCCEEDED(g_pInternat->DecodeHeader(NULL, pszData, &rDecoded, &rRfc1522Info)))
            pszData = rDecoded.pszVal;
    }

    // Initialize Parse Structure
    cAdrParse.Init(pszData, lstrlen(pszData));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(ADDRESSPROPS));

        // Copy the Friendly Name
        CHECKALLOC(pAddress->pszFriendly = PszDupA(cAdrParse.PszFriendly()));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszDupA(cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = ietEncoding;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_cMoleAlloc.FreeAddressList(pList);

    // Cleanup
    MimeOleVariantFree(&rDecoded);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeAddressTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeAddressTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrGenerateFileName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGenerateFileName(DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszDefExt=NULL,
                pszData=NULL,
                pszFree=NULL,
                pszSuggest=NULL;
    LPCSTR      pszCntType=NULL;
    LPPROPERTY  pProperty;
    MIMEVARIANT rSource;

    // Compute Content Type
    pszCntType = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTTYPE], STR_MIME_TEXT_PLAIN);

    // Compute Subject as suggested base file name...
    rSource.type = MVT_STRINGA;
    if (SUCCEEDED(GetProp(SYM_HDR_SUBJECT, 0, &rSource)))
        pszSuggest = pszFree = rSource.rStringA.pszVal;

    // PID_HDR_CNTDESC
    if (NULL == pszSuggest)
    {
        // Use PID_CNTDESC
        pszSuggest = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDESC], NULL);
    }

    // message/rfc822
    if (lstrcmpi(pszCntType, (LPSTR)STR_MIME_MSG_RFC822) == 0)
    {
        // If there is a news header, use c_szDotNws
        if (ISFLAGSET(m_dwState, COSTATE_RFC822NEWS))
            pszDefExt = (LPSTR)c_szDotNws;
        else
            pszDefExt = (LPSTR)c_szDotEml;

        // I will never lookup message/rfc822 extension
        pszCntType = NULL;
    }

    // Still no default
    else if (StrCmpNI(pszCntType, STR_CNT_TEXT, lstrlen(STR_CNT_TEXT)) == 0)
        pszDefExt = (LPSTR)c_szDotTxt;

    // Generate a filename based on the content type...
    CHECKHR(hr = MimeOleGenerateFileName(pszCntType, pszSuggest, pszDefExt, &pszData));

    // Setup rSource
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = pszData;
    rSource.rStringA.cchVal = lstrlen(pszData);

    // Return per user request
    CHECKHR(hr = HrConvertVariant(SYM_ATT_GENFNAME, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\containx.h ===
// --------------------------------------------------------------------------------
// ContainX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __CONTAINX_H
#define __CONTAINX_H

// ---------------------------------------------------------------------------------------
// IID_CMimePropertyTable - {E31B34B2-8DA0-11d0-826A-00C04FD85AB4}
// ---------------------------------------------------------------------------------------
DEFINE_GUID(IID_CMimePropertyContainer, 0xe31b34b2, 0x8da0, 0x11d0, 0x82, 0x6a, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// ---------------------------------------------------------------------------------------
// Depends
// ---------------------------------------------------------------------------------------
#include "variantx.h"
#include "addressx.h"

// ---------------------------------------------------------------------------------------
// Forward Decls
// ---------------------------------------------------------------------------------------
class CInternetStream;
class CStreamLockBytes;
typedef struct tagWRAPTEXTINFO *LPWRAPTEXTINFO;
typedef struct tagRESOLVEURLINFO *LPRESOLVEURLINFO;
typedef struct tagPROPERTY *LPPROPERTY;
CODEPAGEID   MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset);

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD g_cSetPidLookups;
extern DWORD g_cHashLookups;
extern DWORD g_cHashInserts;
extern DWORD g_cHashCollides;
#endif

// --------------------------------------------------------------------------------
// HHEADERROW MACROS
// --------------------------------------------------------------------------------
#define HROWINDEX(_hrow)            (ULONG)HIWORD(_hrow)
#define HROWTICK(_hrow)             (WORD)LOWORD(_hrow)
#define HROWMAKE(_index)            (HHEADERROW)(MAKELPARAM(m_wTag, _index))
#define PRowFromHRow(_hrow)         (m_rHdrTable.prgpRow[HROWINDEX(_hrow)])

// --------------------------------------------------------------------------------
// HADDRESS MACROS
// --------------------------------------------------------------------------------
#define HADDRESSINDEX(_hadr)        (ULONG)HIWORD(_hadr)
#define HADDRESSTICK(_hadr)         (WORD)LOWORD(_hadr)
#define HADDRESSMAKE(_index)        (HADDRESS)(MAKELPARAM(m_wTag, _index))
#define HADDRESSGET(_hadr)          (m_rAdrTable.prgpAdr[HADDRESSINDEX(_hadr)])

// --------------------------------------------------------------------------------
// ADDRESSGROUP
// --------------------------------------------------------------------------------
typedef struct tagADDRESSGROUP {
    DWORD               cAdrs;                      // Number of addresses lin list    
    LPMIMEADDRESS       pHead;                      // Head Address props
    LPMIMEADDRESS       pTail;                      // Tail Address props
    LPPROPERTY          pNext;                      // Next Address Group
    LPPROPERTY          pPrev;                      // Previous Address Group
    BOOL                fDirty;                     // Dirty ?
} ADDRESSGROUP, *LPADDRESSGROUP;

// --------------------------------------------------------------------------------
// ADDRESSTABLE
// --------------------------------------------------------------------------------
typedef struct tagADDRESSTABLE {
    LPPROPERTY          pHead;                      // Head Address Group
    LPPROPERTY          pTail;                      // Tail Address Group
    ULONG               cEmpty;                     // Number of empty cells in prgAddr
    ULONG               cAdrs;                      // Count of addresses
    ULONG               cAlloc;                     // Number of items allocated in prgAddr
    LPMIMEADDRESS      *prgpAdr;                    // Array of addresses
} ADDRESSTABLE, *LPADDRESSTABLE;

// ---------------------------------------------------------------------------------------
// Container States
// ---------------------------------------------------------------------------------------
#define COSTATE_DIRTY          FLAG01               // The container is dirty
#define COSTATE_CSETTAGGED     FLAG02               // The object is tagged with a charset
#define COSTATE_1522CSETTAG    FLAG03               // I am using an rfc1522 charset as the default
#define COSTATE_HANDSONSTORAGE FLAG04               // I am holding a stream that I don't own
#define COSTATE_RFC822NEWS     FLAG05               // I am a message/rfc822 news message

// --------------------------------------------------------------------------------
// Property States
// --------------------------------------------------------------------------------
#define PRSTATE_ALLOCATED           FLAG02          // m_pbBlob has been allocated, free it
#define PRSTATE_HASDATA             FLAG03          // The value has had data set into it
#define PRSTATE_DIRTY               FLAG06          // Charset change, data change
#define PRSTATE_PARENT              FLAG07          // This prop is the parent of a multi-value prop
#define PRSTATE_RFC1522             FLAG08          // The data is encoded in rfc1522
#define PRSTATE_EXIST_BEFORE_LOAD   FLAG09          // The property existed before ::Load started
#define PRSTATE_USERSETROWNUM       FLAG10          // The user set the row number of this property
#define PRSTATE_NEEDPARSE           FLAG11          // The property contains address data, but has not been parsed into a groups
#define PRSTATE_SAVENOENCODE        FLAG12          // Don't encode or change the property data on save

// --------------------------------------------------------------------------------
// Number of Buckets in the Mime Property Container Hash Table
// --------------------------------------------------------------------------------
#define CBUCKETS        25

// --------------------------------------------------------------------------------
// PROPERTY
// --------------------------------------------------------------------------------
typedef struct tagPROPERTY {
    MIMEVARIANT         rValue;                     // Property Value
    LPINETCSETINFO      pCharset;                   // Character Set Information
    ENCODINGTYPE        ietValue;                   // State of this variable (IET_DECODED or IET_ENCODED)
    LPBYTE              pbBlob;                     // Data Blob
    ULONG               cbBlob;                     // Amount of valid date in m_pbBlob
    ULONG               cbAlloc;                    // Sizeof m_pbBlob
    BYTE                rgbScratch[170];            // Buffer to use if data fits
    HHEADERROW          hRow;                       // Handle to the header row
    LPPROPSYMBOL        pSymbol;                    // Property Symbol
    DWORD               dwState;                    // PDS_xxx
    LPPROPERTY          pNextHash;                  // Next Hash Value
    LPPROPERTY          pNextValue;                 // Next Property
    LPPROPERTY          pTailValue;                 // Tail data item (only for PRSTATE_PARENT) properties
    DWORD               dwRowNumber;                // Header Name to find
    ULONG               cboffStart;                 // Index into pStream where Header Starts (From: xxxx)
    ULONG               cboffColon;                 // Index into pStream of the Header Colon
    ULONG               cboffEnd;                   // Index into pStream where the Header Ends
    LPADDRESSGROUP      pGroup;                     // Head address if MPF_ADDRESS group
} PROPERTY;

// ---------------------------------------------------------------------------------------
// PSZDEFPRPOSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZDEFPROPSTRINGA(_pProperty, _pszDefault) \
    (((_pProperty) && ISSTRINGA(&(_pProperty)->rValue)) ? (_pProperty)->rValue.rStringA.pszVal : _pszDefault)

// --------------------------------------------------------------------------------
// HEADERTABLE
// --------------------------------------------------------------------------------
typedef struct tagHEADERTABLE {
    ULONG               cRows;                      // Number of lines in the header
    ULONG               cEmpty;                     // Number of empty (deleted) entries
    ULONG               cAlloc;                     // Number of items allocated in prgLine
    LPPROPERTY         *prgpRow;                    // Array of header rows
} HEADERTABLE, *LPHEADERTABLE;                      

// --------------------------------------------------------------------------------
// ROWINDEX
// --------------------------------------------------------------------------------
typedef struct tagROWINDEX {
    HHEADERROW          hRow;                       // Handle to the header row
    DWORD               dwWeight;                   // Position Weigth used to determine save order
    BOOL                fSaved;                     // Saved Yet?
} ROWINDEX, *LPROWINDEX;

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
typedef struct tagENCODINGTABLE {
    LPCSTR              pszEncoding;                // Encoding Name (i.e. base64)
    ENCODINGTYPE        ietEncoding;                // Encoding type
} ENCODINGTABLE;

// --------------------------------------------------------------------------------
// RESOLVEURLINFO
// --------------------------------------------------------------------------------
typedef struct tagRESOLVEURLINFO {
    LPCSTR              pszInheritBase;             // An Inherited base from multipart/realted
    LPCSTR              pszBase;                    // URL Base
    LPCSTR              pszURL;                     // Absolute or Relative URL
    BOOL                fIsCID;                     // Is pszURL a CID:<something>
} RESOLVEURLINFO, *LPRESOLVEURLINFO;

// --------------------------------------------------------------------------------
// FINDPROPERTY Information
// --------------------------------------------------------------------------------
typedef struct tagFINDPROPERTY {
    LPCSTR              pszPrefix;                  // Name Prefix to Find
    ULONG               cchPrefix;                  // Length of prefix
    LPCSTR              pszName;                    // Name of property to find par:xxx:
    ULONG               cchName;                    // Length of pszName
    DWORD               wHashIndex;                 // Current search bucket
    LPPROPERTY          pProperty;                  // Current property being searched
} FINDPROPERTY, *LPFINDPROPERTY;

// --------------------------------------------------------------------------------
// HEADOPTIONS
// --------------------------------------------------------------------------------
typedef struct tagHEADOPTIONS {
    LPINETCSETINFO      pDefaultCharset;            // Current character set for this message
    ULONG               cbMaxLine;                  // Max Line length                       
    BOOL                fAllow8bit;                 // Use rfc1522 encoding                  
    MIMESAVETYPE        savetype;                   // Save as SAVE_RFC1521 or SAVE_RFC822   
    BOOL                fNoDefCntType;              // Don't default content-type to text/plain on save
    RELOADTYPE          ReloadType;                 // How the the root header be treated on a reload
} HEADOPTIONS, *LPHEADOPTIONS;

// --------------------------------------------------------------------------------
// Global Default Header Options
// --------------------------------------------------------------------------------
extern const HEADOPTIONS g_rDefHeadOptions;
extern const ENCODINGTABLE g_rgEncoding[];

// --------------------------------------------------------------------------------
// TRIGGERTYPE
// --------------------------------------------------------------------------------
typedef DWORD                   TRIGGERTYPE;    // Trigger Type
#define IST_DELETEPROP          FLAG01          // Property is being deleted
#define IST_POSTSETPROP         FLAG02          // Before _HrSetPropertyValue
#define IST_POSTGETPROP         FLAG03          // Before _HrGetPropertyValue
#define IST_GETDEFAULT          FLAG04          // Property was not found, get the default 
#define IST_VARIANT_TO_STRINGA  FLAG05          // MVT_VARIANT -> MVT_STRINGA
#define IST_VARIANT_TO_STRINGW  FLAG06          // MVT_VARIANT -> MVT_STRINGW
#define IST_VARIANT_TO_VARIANT  FLAG07          // MVT_VARIANT -> MVT_VARIANT
#define IST_STRINGA_TO_VARIANT  FLAG08          // MVT_STRINGA -> MVT_VARIANT
#define IST_STRINGW_TO_VARIANT  FLAG09          // MVT_STRINGW -> MVT_VARIANT
#define IST_VARIANTCONVERT      (IST_VARIANT_TO_STRINGA  | IST_VARIANT_TO_STRINGW | IST_VARIANT_TO_VARIANT  | IST_VARIANT_TO_VARIANT | IST_STRINGA_TO_VARIANT  | IST_STRINGW_TO_VARIANT)

// --------------------------------------------------------------------------------
// TRIGGERCALL
// --------------------------------------------------------------------------------
typedef struct tagTRIGGERCALL {
    LPPROPSYMBOL        pSymbol;                // Property Symbol that generated the dispatch
    TRIGGERTYPE         tyTrigger;              // Reason or type of dispatch
} TRIGGERCALL, *LPTRIGGERCALL;

// --------------------------------------------------------------------------------
// TRIGGERCALLSTACK
// --------------------------------------------------------------------------------
#define CTSTACKSIZE 5
typedef struct tagTRIGGERCALLSTACK {
    WORD                cCalls;                 // Number of dispatch calls on the stack
    TRIGGERCALL         rgStack[CTSTACKSIZE];   // Dispatch Call Stack
} TRIGGERCALLSTACK, *LPTRIGGERCALLSTACK;

// --------------------------------------------------------------------------------
// DECLARE_TRIGGER Macro
// --------------------------------------------------------------------------------
#define DECLARE_TRIGGER(_pfnTrigger) \
    static HRESULT _pfnTrigger(LPCONTAINER, TRIGGERTYPE, DWORD, LPMIMEVARIANT, LPMIMEVARIANT)

// --------------------------------------------------------------------------------
// ISTRIGGERED - Does the symbol have an associated trigger
// --------------------------------------------------------------------------------
#define ISTRIGGERED(_pSymbol, _tyTrigger) \
    (NULL != (_pSymbol)->pTrigger && ISFLAGSET((_pSymbol)->pTrigger->dwTypes, _tyTrigger) && NULL != (_pSymbol)->pTrigger->pfnTrigger)

// --------------------------------------------------------------------------------
// PFNSYMBOLTRIGGER
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNSYMBOLTRIGGER)(LPCONTAINER, TRIGGERTYPE, DWORD, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// CALLTRIGGER - Executes a Trigger Based on a Symbol
// --------------------------------------------------------------------------------
#define CALLTRIGGER(_pSymbol, _pContainer, _tyTrigger, _dwFlags, _pSource, _pDest) \
    (*(_pSymbol)->pTrigger->pfnTrigger)(_pContainer, _tyTrigger, _dwFlags, _pSource, _pDest)

// --------------------------------------------------------------------------------
// CMimePropertyContainer
// --------------------------------------------------------------------------------
class CMimePropertyContainer : public IMimePropertySet,
                               public IMimeHeaderTable, 
                               public IMimeAddressTableW
{
public:
    // ----------------------------------------------------------------------------
    // CMimePropertyContainer
    // ----------------------------------------------------------------------------
    CMimePropertyContainer(void);
    ~CMimePropertyContainer(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IPersistStreamInit members
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);
    STDMETHODIMP InitNew(void);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(LPSTREAM pStream);
    STDMETHODIMP Save(LPSTREAM pStream, BOOL fClearDirty);

    // ---------------------------------------------------------------------------
    // IMimePropertySet members
    // ---------------------------------------------------------------------------
    STDMETHODIMP AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue);
    STDMETHODIMP DeleteProp(LPCSTR pszName);
    STDMETHODIMP CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet);
    STDMETHODIMP DeleteExcept(ULONG cNames, LPCSTR *prgszName);
    STDMETHODIMP QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    STDMETHODIMP GetCharset(LPHCHARSET phCharset);
    STDMETHODIMP SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype);
    STDMETHODIMP GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam);
    STDMETHODIMP Clone(IMimePropertySet **ppPropertySet);
    STDMETHODIMP SetOption(const TYPEDID oid, LPCPROPVARIANT pValue);
    STDMETHODIMP GetOption(const TYPEDID oid, LPPROPVARIANT pValue);
    STDMETHODIMP BindToObject(REFIID riid, void **ppvObject);
    STDMETHODIMP GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo);
    STDMETHODIMP SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo);
    STDMETHODIMP EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum);
    STDMETHODIMP IsContentType(LPCSTR pszCntType, LPCSTR pszSubType);
    HRESULT IsContentTypeW(LPCWSTR pszPriType, LPCWSTR pszSubType);

    // ---------------------------------------------------------------------------
    // Overloaded IMimePropertySet members
    // ---------------------------------------------------------------------------
    HRESULT AppendProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT DeleteProp(LPPROPSYMBOL pSymbol);
    HRESULT QueryProp(LPPROPSYMBOL pSymbol, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT Clone(LPCONTAINER *ppContainer);

    // ---------------------------------------------------------------------------
    // Overloaded GetProp
    // ---------------------------------------------------------------------------
    STDMETHODIMP GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue); /* IMimePropertySet */
    HRESULT GetProp(LPCSTR pszName, LPSTR *ppszData);
    HRESULT GetProp(LPPROPSYMBOL pSymbol, LPSTR *ppszData);
    HRESULT GetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT GetPropW(LPPROPSYMBOL pSymbol, LPWSTR *ppwszData);

    // ---------------------------------------------------------------------------
    // Overloaded SetProp
    // ---------------------------------------------------------------------------
    HRESULT SetProp(LPCSTR pszName, LPCSTR pszData);
    HRESULT SetProp(LPPROPSYMBOL pSymbol, LPCSTR pszData);
    HRESULT SetProp(LPCSTR pszName, DWORD dwFlags, LPCSTR pszData);
    HRESULT SetProp(LPCSTR pszName, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT SetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPCMIMEVARIANT pValue);
    STDMETHODIMP SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue); /* IMimePropertySet */

    // ---------------------------------------------------------------------------
    // IMimeHeaderTable members
    // ---------------------------------------------------------------------------
    STDMETHODIMP FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow);
    STDMETHODIMP FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow);
    STDMETHODIMP CountRows(LPCSTR pszHeader, ULONG *pcRows);
    STDMETHODIMP AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData, LPHHEADERROW phRow);
    STDMETHODIMP DeleteRow(HHEADERROW hRow);
    STDMETHODIMP GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData);
    STDMETHODIMP SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData);
    STDMETHODIMP GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo);
    STDMETHODIMP SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber);
    STDMETHODIMP EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum);
    STDMETHODIMP Clone(IMimeHeaderTable **ppTable);

    // ----------------------------------------------------------------------------
    // IMimeAddressTable
    // ----------------------------------------------------------------------------
    STDMETHODIMP Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly, LPCSTR pszEmail, LPHADDRESS phAddress);
    STDMETHODIMP Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress);
    STDMETHODIMP SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps);
    STDMETHODIMP GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps);
    STDMETHODIMP GetSender(LPADDRESSPROPS pProps);
    STDMETHODIMP CountTypes(DWORD dwAdrTypes, ULONG *pcTypes);
    STDMETHODIMP GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList);
    STDMETHODIMP EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum);
    STDMETHODIMP Delete(HADDRESS hAddress);
    STDMETHODIMP DeleteTypes(DWORD dwAdrTypes);
    STDMETHODIMP GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat);
    STDMETHODIMP AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr);
    STDMETHODIMP ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr, LPADDRESSLIST pList);
    STDMETHODIMP Clone(IMimeAddressTable **ppTable);

    // ----------------------------------------------------------------------------
    // IMimeAddressTableW
    // ----------------------------------------------------------------------------
    STDMETHODIMP AppendW(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCWSTR pwszFriendly, LPCWSTR pwszEmail, LPHADDRESS phAddress);
    STDMETHODIMP GetFormatW(DWORD dwAdrType, ADDRESSFORMAT format, LPWSTR *ppwszFormat);
    STDMETHODIMP AppendRfc822W(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCWSTR pwszRfc822Adr);
    STDMETHODIMP ParseRfc822W(DWORD dwAdrType, LPCWSTR pwszRfc822Adr, LPADDRESSLIST pList);
    // ---------------------------------------------------------------------------
    // Generic Stuff
    // ---------------------------------------------------------------------------
    HRESULT      IsState(DWORD dwState);
    void         ClearState(DWORD dwState);
    void         SetState(DWORD dwState);
    DWORD        DwGetState(LPDWORD pdwState);
    DWORD        DwGetMessageFlags(BOOL fHideTnef);
    HRESULT      Load(CInternetStream *pInternet);
    HRESULT      HrInsertCopy(LPPROPERTY pSource, BOOL fFromMovePropos);
    HRESULT      HrResolveURL(LPRESOLVEURLINFO pInfo);
    HRESULT      IsPropSet(LPCSTR pszName);
    ENCODINGTYPE GetEncodingType(void);

    // ---------------------------------------------------------------------------
    // Inline Public Stuff
    // ---------------------------------------------------------------------------
    ULONG CountProps(void) {
        EnterCriticalSection(&m_cs);
        ULONG c = m_cProps;
        LeaveCriticalSection(&m_cs);
        return c;
    }

    CODEPAGEID GetWindowsCP(void) {
        EnterCriticalSection(&m_cs);
        CODEPAGEID cp = MimeOleGetWindowsCPEx(m_rOptions.pDefaultCharset);
        LeaveCriticalSection(&m_cs);
        return cp;
    }

    // ---------------------------------------------------------------------------
    // Variant Conversion Stuff
    // ---------------------------------------------------------------------------
    HRESULT HrConvertVariant(LPPROPSYMBOL pSymbol, LPINETCSETINFO pCharset, ENCODINGTYPE ietSource, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522=NULL);
    HRESULT HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pDest);
    HRESULT HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522=NULL);

private:
    // ----------------------------------------------------------------------------
    // Property Methods
    // ----------------------------------------------------------------------------
    void    _FreeHashTableElements(void);
    void    _FreePropertyChain(LPPROPERTY pProperty);
    void    _UnlinkProperty(LPPROPERTY pProperty, LPPROPERTY *ppNextHash=NULL);
    void    _ReloadInitNew(void);
    void    _SetStateOnAllProps(DWORD dwState);
    BOOL    _FExcept(LPPROPSYMBOL pSymbol, ULONG cNames, LPCSTR *prgszName);
    HRESULT _HrFindProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrCreateProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrOpenProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrAppendProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty);
    HRESULT _HrSetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue, BOOL fFromMovePropos);
    HRESULT _HrStoreVariantValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT _HrFindFirstProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty);
    HRESULT _HrFindNextProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty);
    HRESULT _HrGetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrGetMultiValueProperty(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrClonePropertiesTo(LPCONTAINER pContainer);
    HRESULT _HrGenerateFileName(LPCWSTR pszSuggest, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest);
    HRESULT _HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest, BOOL fFromMovePropos);
    HRESULT _GetFormatBase(DWORD dwAdrType, ADDRESSFORMAT format, LPPROPVARIANT pVariant);
    CODEPAGEID _GetAddressCodePageId(LPINETCSETINFO pDefaultCset, ENCODINGTYPE ietEncoding);

    // ----------------------------------------------------------------------------
    // Dispatch Members
    // ----------------------------------------------------------------------------
    HRESULT _HrCallSymbolTrigger(LPPROPSYMBOL pSymbol, TRIGGERTYPE tyTrigger, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrIsTriggerCaller(DWORD dwPropId, TRIGGERTYPE tyTrigger);

    // ----------------------------------------------------------------------------
    // Parameter Based Members
    // ----------------------------------------------------------------------------
    void    _DeleteLinkedParameters(LPPROPERTY pProperty);
    HRESULT _HrParseParameters(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue);
    HRESULT _HrBuildParameterString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);

    // ----------------------------------------------------------------------------
    // Internet Address Members
    // ----------------------------------------------------------------------------
    HRESULT _HrAppendAddressTable(LPPROPERTY pProperty);
    HRESULT _HrBuildAddressString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue);
    HRESULT _HrParseInternetAddress(LPPROPERTY pProperty);
    HRESULT _HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format, VARTYPE vtFormat);
    HRESULT _HrSaveAddressA(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format);
    HRESULT _HrSaveAddressW(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format);
    HRESULT _HrAppendAddressGroup(LPADDRESSGROUP pGroup, LPMIMEADDRESS *ppAddress);
    HRESULT _HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT _HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
    HRESULT _HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress);
    HRESULT _HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress);
    void    _FreeAddressChain(LPADDRESSGROUP pGroup);
    void    _UnlinkAddressGroup(LPPROPERTY pProperty);
    void    _UnlinkAddress(LPMIMEADDRESS pAddress);
    void    _FreeAddress(LPMIMEADDRESS pAddress);
    void    _LinkAddress(LPMIMEADDRESS pAddress, LPADDRESSGROUP pGroup);

    // ----------------------------------------------------------------------------
    // IMimeHeaderTable Private Helpers
    // ----------------------------------------------------------------------------
    HRESULT _HrGetHeaderTableSaveIndex(ULONG *pcRows, LPROWINDEX *pprgIndex);
    void    _SortHeaderTableSaveIndex(LONG left, LONG right, LPROWINDEX prgIndex);
    BOOL    _FIsValidHRow(HHEADERROW hRow);
    BOOL    _FIsValidHAddress(HADDRESS hAddress);
    void    _UnlinkHeaderRow(HHEADERROW hRow);
    HRESULT _HrAppendHeaderTable(LPPROPERTY pProperty);
    HRESULT _HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch, LPSTR *ppszHeader, ULONG *pcboffColon);
    HRESULT _HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon);

public:
    // ----------------------------------------------------------------------------
    // Property Symbol Triggers
    // ----------------------------------------------------------------------------
    DECLARE_TRIGGER(TRIGGER_ATT_FILENAME);
    DECLARE_TRIGGER(TRIGGER_ATT_GENFNAME);
    DECLARE_TRIGGER(TRIGGER_ATT_NORMSUBJ);
    DECLARE_TRIGGER(TRIGGER_HDR_SUBJECT);
    DECLARE_TRIGGER(TRIGGER_HDR_CNTTYPE);
    DECLARE_TRIGGER(TRIGGER_ATT_PRITYPE);
    DECLARE_TRIGGER(TRIGGER_ATT_SUBTYPE);
    DECLARE_TRIGGER(TRIGGER_HDR_CNTXFER);
    DECLARE_TRIGGER(TRIGGER_PAR_NAME);
    DECLARE_TRIGGER(TRIGGER_PAR_FILENAME);
    DECLARE_TRIGGER(TRIGGER_ATT_SENTTIME);
    DECLARE_TRIGGER(TRIGGER_ATT_RECVTIME);
    DECLARE_TRIGGER(TRIGGER_ATT_PRIORITY);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;                     // Container Reference Count
    DWORD               m_dwState;                  // State of the container
    ULONG               m_cProps;                   // Current number of properties
    LPPROPERTY          m_prgIndex[PID_LAST];       // Array of pointers into local hash table for known items
    LPPROPERTY          m_prgHashTable[CBUCKETS];   // Hash table for properties
    TRIGGERCALLSTACK    m_rTrigger;                 // Current Property Id Owning the Dispatch
    WORD                m_wTag;                     // Handle Tag
    HEADERTABLE         m_rHdrTable;                // The header table
    ADDRESSTABLE        m_rAdrTable;                // The Address Table
    ULONG               m_cbSize;                   // Size of this header
    ULONG               m_cbStart;                  // Start Position of m_pStmLock
    CStreamLockBytes   *m_pStmLock;                 // Protective Wrapper for the stream object
    HEADOPTIONS         m_rOptions;                 // Header Options
    CRITICAL_SECTION    m_cs;                       // Thread Safety
};

// --------------------------------------------------------------------------------
// SYMBOLTRIGGER
// --------------------------------------------------------------------------------
typedef struct tagSYMBOLTRIGGER {
    DWORD               dwTypes;
    PFNSYMBOLTRIGGER    pfnTrigger;
} SYMBOLTRIGGER, *LPSYMBOLTRIGGER;

// --------------------------------------------------------------------------------
// Macro To Define a Trigger Function
// --------------------------------------------------------------------------------
#ifdef DEFINE_TRIGGERS
#define DEFINE_TRIGGER(_pfnTrigger, _dwTypes) \
    SYMBOLTRIGGER r##_pfnTrigger = \
    { \
        /* SYMBOLTRIGGER::dwTypes */        _dwTypes, \
        /* SYMBOLTRIGGER::pfnTrigger */     (PFNSYMBOLTRIGGER)CMimePropertyContainer::_pfnTrigger \
    }; \
    const LPSYMBOLTRIGGER LP##_pfnTrigger = &r##_pfnTrigger;
#else
#define DEFINE_TRIGGER(_pfnTrigger, _dwTypes) \
    extern const LPSYMBOLTRIGGER LP##_pfnTrigger;
#endif

// --------------------------------------------------------------------------------
// Trigger Definitions
// --------------------------------------------------------------------------------
DEFINE_TRIGGER(TRIGGER_ATT_FILENAME, IST_POSTSETPROP | IST_DELETEPROP | IST_POSTGETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_GENFNAME, IST_POSTGETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_NORMSUBJ, IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_HDR_SUBJECT,  IST_DELETEPROP);
DEFINE_TRIGGER(TRIGGER_HDR_CNTTYPE,  IST_DELETEPROP | IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_PRITYPE,  IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_SUBTYPE,  IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_HDR_CNTXFER,  IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_PAR_NAME,     IST_POSTSETPROP);
DEFINE_TRIGGER(TRIGGER_PAR_FILENAME, IST_DELETEPROP | IST_POSTSETPROP);
DEFINE_TRIGGER(TRIGGER_ATT_SENTTIME, IST_DELETEPROP | IST_POSTSETPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_RECVTIME, IST_DELETEPROP | IST_GETDEFAULT);
DEFINE_TRIGGER(TRIGGER_ATT_PRIORITY, IST_POSTSETPROP | IST_DELETEPROP | IST_GETDEFAULT | IST_VARIANTCONVERT);
   
#endif // __CONTAINX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enriched.cpp ===
// --------------------------------------------------------------------------------
// Enriched.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bookbody.h"
#include "internat.h"
#include "mimeapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Charcter Strings used in this code
// --------------------------------------------------------------------------------
static const CHAR c_szAmpersandLT[]          = "&lt;";
static const CHAR c_szAmpersandGT[]          = "&gt;";
static const CHAR c_szGreaterThan[]          = ">";
static const CHAR c_szLessThan[]             = "<";

// --------------------------------------------------------------------------------
// Number of characters in a globally defined string
// --------------------------------------------------------------------------------
#define CCHGLOBAL(_szGlobal)    (sizeof(_szGlobal) - 1)

// --------------------------------------------------------------------------------
// FReadChar
// --------------------------------------------------------------------------------
inline BOOL FReadChar(IStream *pIn, HRESULT *phr, CHAR *pch)
{
    ULONG cb;
    *phr = pIn->Read(pch, sizeof(CHAR), &cb);
    if (FAILED(*phr) || 0 == cb)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// MimeOleConvertEnrichedToHTMLEx
// --------------------------------------------------------------------------------
HRESULT MimeOleConvertEnrichedToHTMLEx(IMimeBody *pBody, ENCODINGTYPE ietEncoding, 
    IStream **ppStream)
{
    // Locals
    HRESULT             hr=S_OK;
    HCHARSET            hCharset;
    LPSTREAM            pStmEnriched=NULL;
    LPSTREAM            pStmHtml=NULL;
    LPMESSAGEBODY       pEnriched=NULL;

    // Invalid Args
    Assert(pBody && ppStream);

    // Get Data
    CHECKHR(hr = pBody->GetData(IET_DECODED, &pStmEnriched));

    // Get the Charset
    if (FAILED(pBody->GetCharset(&hCharset)))
        hCharset = CIntlGlobals::GetDefBodyCset() ? CIntlGlobals::GetDefBodyCset()->hCharset : NULL;

    // Create new virtual stream
    CHECKHR(hr = MimeOleCreateVirtualStream(&pStmHtml));

    // Make sure rewound
    CHECKHR(hr = HrRewindStream(pStmEnriched));

    // Convert
    CHECKHR(hr = MimeOleConvertEnrichedToHTML(MimeOleGetWindowsCP(hCharset), pStmEnriched, pStmHtml));

    // Make sure rewound
    CHECKHR(hr = HrRewindStream(pStmHtml));

    // Allocate pEnriched
    CHECKALLOC(pEnriched = new CMessageBody(NULL, NULL));

    // Init
    CHECKHR(hr = pEnriched->InitNew());

    // Put pstmHtml into pEnriched
    CHECKHR(hr = pEnriched->SetData(IET_DECODED, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, (LPVOID)pStmHtml));

    // Get and set the charset
    if (hCharset)
        pEnriched->SetCharset(hCharset, CSET_APPLY_ALL);

    // Get Data
    CHECKHR(hr = pEnriched->GetData(ietEncoding, ppStream));

exit:
    // Cleanup
    SafeRelease(pStmHtml);
    SafeRelease(pStmEnriched);
    SafeRelease(pEnriched);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleConvertEnrichedToHTML
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleConvertEnrichedToHTML(CODEPAGEID codepage, IStream *pIn, IStream *pOut)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        ch;
    INT         i;
    INT         paramct=0;
    INT         nofill=0;
    CHAR        token[62];
    LPSTR       p;
    BOOL        fDone;
    CHAR        szTemp[2];
    
    // Main loop
    while(FReadChar(pIn, &hr, &ch))
    {
        // LeadByte
        if (IsDBCSLeadByteEx(codepage, ch))
        {
            // Write This Character
            CHECKHR(hr = pOut->Write(&ch, 1, NULL));

            // Read Next
            if (!FReadChar(pIn, &hr, &ch))
                break;

            // Write This Character
            CHECKHR(hr = pOut->Write(&ch, 1, NULL));
        }

        // Token Start
        else if (ch == '<') 
        {
            // Read Next
            if (!FReadChar(pIn, &hr, &ch))
                break;

            // Escaped
            if (ch == '<') 
            {
                // Write
                CHECKHR(hr = pOut->Write(c_szAmpersandLT, CCHGLOBAL(c_szAmpersandLT), NULL));
            } 
            else 
            {
                // Backup One Character
                CHECKHR(hr = HrStreamSeekCur(pIn, -1));

                // Setup szTemp
                szTemp[1] = '\0';

                // Token Scanner
                for (fDone=FALSE, i=0, p=token;;i++) 
                {
                    // Read Next Char
                    if (!FReadChar(pIn, &hr, &ch))
                    {
                        fDone = TRUE;
                        break;
                    }

                    // Finished with bracketed toeksn
                    if (ch == '>')
                        break;

                    // Fill up the token buffer with lowercase chars
                    if (i < sizeof(token) - 1)
                    {
                        szTemp[0] = ch;
                        *p++ = IsUpper(szTemp) ? TOLOWERA(ch) : ch;
                    }
                }

                // Nul-term
                *p = '\0';

                // End of file
                if (fDone) 
                    break;

                // /param
                if (lstrcmpi(token, "/param") == 0) 
                {
                    paramct--;
                    CHECKHR(hr = pOut->Write(c_szGreaterThan, CCHGLOBAL(c_szGreaterThan), NULL));
                }
                else if (paramct > 0) 
                {
                    CHECKHR(hr = pOut->Write(c_szAmpersandLT, CCHGLOBAL(c_szAmpersandLT), NULL));
                    CHECKHR(hr = pOut->Write(token, lstrlen(token), NULL));
                    CHECKHR(hr = pOut->Write(c_szAmpersandGT, CCHGLOBAL(c_szAmpersandGT), NULL));
                }
                else 
                {
                    CHECKHR(hr = pOut->Write(c_szLessThan, CCHGLOBAL(c_szLessThan), NULL));
                    if (lstrcmpi(token, "nofill") == 0) 
                    {
                        nofill++;
                        CHECKHR(hr = pOut->Write("pre", 3, NULL));
                    }
                    else if (lstrcmpi(token, "/nofill") == 0) 
                    {
                        nofill--;
                        CHECKHR(hr = pOut->Write("/pre", 4, NULL));
                    }
                    else if (lstrcmpi(token, "bold") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("b", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/bold") == 0) 
                    {       
                        CHECKHR(hr = pOut->Write("/b", 2, NULL));
                    }
                    else if (lstrcmpi(token, "underline") == 0)
                    {
                        CHECKHR(hr = pOut->Write("u", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/underline") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("/u", 2, NULL));
                    }
                    else if (lstrcmpi(token, "italic") == 0) 
                    {
                        CHECKHR(hr = pOut->Write("i", 1, NULL));
                    }
                    else if (lstrcmpi(token, "/italic") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/i", 2, NULL));
                    }
                    else if (lstrcmpi(token, "fixed") == 0)
                    {
                        CHECKHR(hr = pOut->Write("tt", 2, NULL));
                    }
                    else if (lstrcmpi(token, "/fixed") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/tt", 3, NULL));
                    }
                    else if (lstrcmpi(token, "excerpt") == 0)
                    {
                        CHECKHR(hr = pOut->Write("blockquote", 10, NULL));
                    }
                    else if (lstrcmpi(token, "/excerpt") == 0)
                    {
                        CHECKHR(hr = pOut->Write("/blockquote", 11, NULL));
                    }
                    else
                    {
                        CHECKHR(hr = pOut->Write("?", 1, NULL));
                        CHECKHR(hr = pOut->Write(token, lstrlen(token), NULL));
                        if (lstrcmpi(token, "param") == 0)
                        {
                            paramct++;
                            CHECKHR(hr = pOut->Write(" ", 1, NULL));
                            continue;
                        }
                    }

                    CHECKHR(hr = pOut->Write(c_szGreaterThan, CCHGLOBAL(c_szGreaterThan), NULL));
                }
            }
        }
        else if (ch == '>')
        {
            CHECKHR(hr = pOut->Write(c_szAmpersandGT, CCHGLOBAL(c_szAmpersandGT), NULL));
        }
        else if (ch == '&')
        {
            CHECKHR(hr = pOut->Write("&amp;", 5, NULL));
        }
        else 
        {
            if ((chCR == ch || ch == chLF) && nofill <= 0 && paramct <= 0) 
            {
                ULONG cCRLF=0;
                CHAR chTemp;

                while(1)
                {
                    if (!FReadChar(pIn, &hr, &chTemp))
                        break;

                    if (chCR == chTemp)
                        continue;

                    if (chLF != chTemp)
                    {
                        CHECKHR(hr = HrStreamSeekCur(pIn, -1));
                        break;
                    }

                    if (cCRLF > 0)
                    {
                        CHECKHR(hr = pOut->Write("<br>", 4, NULL));
                    }

                    cCRLF++;
                }

                if (1 == cCRLF)
                {
                    CHECKHR(hr = pOut->Write(" ", 1, NULL));
                }
            }

            // Write the Character
            else
            {
                CHECKHR(hr = pOut->Write(&ch, 1, NULL));
            }
        }
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enumhead.cpp ===
// --------------------------------------------------------------------------------
// Enumhead.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "enumhead.h"
#include "olealloc.h"
#include "symcache.h"
#include "demand.h"

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::CMimeEnumHeaderRows
// ---------------------------------------------------------------------------
CMimeEnumHeaderRows::CMimeEnumHeaderRows(void)
{
    DllAddRef();
    m_cRef = 1;
    m_ulIndex = 0;
    m_cRows = 0;
    m_prgRow = NULL;
    m_dwFlags = 0;
    InitializeCriticalSection(&m_cs);
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::~CMimeEnumHeaderRows
// ---------------------------------------------------------------------------
CMimeEnumHeaderRows::~CMimeEnumHeaderRows(void)
{
    g_pMoleAlloc->FreeEnumHeaderRowArray(m_cRows, m_prgRow, TRUE);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeEnumHeaderRows *)this;
    else if (IID_IMimeEnumHeaderRows == riid)
        *ppv = (IMimeEnumHeaderRows *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumHeaderRows::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumHeaderRows::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Next
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Next(ULONG cWanted, LPENUMHEADERROW prgRow, ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFetch=0, 
                    ulIndex=0;
    LPPROPSYMBOL    pSymbol;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgRow || NULL == prgRow)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cRows - m_ulIndex);
    if (0 == cFetch)
        goto exit;

    // Init the array
    ZeroMemory(prgRow, sizeof(ENUMHEADERROW) * cWanted);

    // Copy cWanted
    for (ulIndex=0; ulIndex<cFetch; ulIndex++)
    {
        // Do Enumerating Only Handles
        if (!ISFLAGSET(m_dwFlags, HTF_ENUMHANDLESONLY))
        {
            // Cast symbol
            pSymbol = (LPPROPSYMBOL)m_prgRow[m_ulIndex].dwReserved;

            // Dup the Header Name
            CHECKALLOC(prgRow[ulIndex].pszHeader = PszDupA(pSymbol->pszName));

            // pszData
            if (m_prgRow[m_ulIndex].pszData)
                CHECKALLOC(prgRow[ulIndex].pszData = PszDupA(m_prgRow[m_ulIndex].pszData));

            // Size of Data
            prgRow[ulIndex].cchData = m_prgRow[m_ulIndex].cchData;    
        }

        // Handle
        prgRow[ulIndex].hRow = m_prgRow[m_ulIndex].hRow;

        // Goto Next
        m_ulIndex++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Failure
    if (FAILED(hr) && prgRow)
        g_pMoleAlloc->FreeEnumHeaderRowArray(cFetch, prgRow, FALSE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Skip
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_ulIndex + cSkip) >= m_cRows) || NULL == m_prgRow)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_ulIndex += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Reset
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Reset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset
    m_ulIndex = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Clone
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Clone(IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    CMimeEnumHeaderRows *pEnum=NULL;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows());

    // Init
    CHECKHR(hr = pEnum->HrInit(m_ulIndex, m_dwFlags, m_cRows, m_prgRow, TRUE));

    // Retrun
    (*ppEnum) = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::Count
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumHeaderRows::Count(ULONG *pcRows)
{
    // check params
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set return
    *pcRows = m_cRows;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumHeaderRows::HrInit
// ---------------------------------------------------------------------------
HRESULT CMimeEnumHeaderRows::HrInit(ULONG ulIndex, DWORD dwFlags, ULONG cRows, LPENUMHEADERROW prgRow, BOOL fDupArray)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save Lines
    m_ulIndex = ulIndex;
    m_cRows = cRows;
    m_dwFlags = dwFlags;

    // Are there lines ...
    if (m_cRows)
    {
        // Duplicate the Array
        if (fDupArray)
        {
            // Allocate memory
            CHECKALLOC(m_prgRow = (LPENUMHEADERROW)g_pMalloc->Alloc(m_cRows * sizeof(ENUMHEADERROW)));

            // ZeroInit
            ZeroMemory(m_prgRow, sizeof(ENUMHEADERROW) * m_cRows);

            // Loop
            for (i=0; i<m_cRows; i++)
            {
                // Take the symbol
                m_prgRow[i].dwReserved = prgRow[i].dwReserved;

                // Dup the Data
                if (prgRow[i].pszData)
                {
                    // Alloc Memory
                    CHECKALLOC(m_prgRow[i].pszData = (LPSTR)g_pMalloc->Alloc(prgRow[i].cchData + 1));

                    // Copy the String
                    CopyMemory(m_prgRow[i].pszData, prgRow[i].pszData, prgRow[i].cchData + 1);
                }

                // Save the Data Length
                m_prgRow[i].cchData = prgRow[i].cchData;

                // Save the Handle
                m_prgRow[i].hRow = prgRow[i].hRow;
            }
        }
        
        // Otherwise, just assume this array
        else
            m_prgRow = prgRow;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\cryptdbg.cpp ===
/*  CRYPTDBG.CPP
**
**
**
**  Owner:  t-erikne
**  Created: 8/26/96
**
*/

#include "pch.hxx"

#ifdef DEBUG

#include "capitype.h"
#include "cryptdbg.h"
#include <dllmain.h>    // DllAddRef, global critsec
#include <demand.h>

ASSERTDATA
static s_fInit = FALSE;
static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded);
static void PrintLastError(LPCSTR pszMsg);
static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry);

///////////////////////////////////////////////////////////////////////////
//
// DOUT stuff
//

void PrefDOUT(DWORD dwLevel, LPSTR szPref, LPSTR szFmt, va_list arglist);

void CSSDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_CSS, "CSS: ", szFmt, arglist);
    va_end(arglist);
}

void SMDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_SMIME, "SMIME: ", szFmt, arglist);
    va_end(arglist);
}

void CRDOUT(LPSTR szFmt, ...)
{
    va_list arglist;

    va_start(arglist, szFmt);
    PrefDOUT(DOUTL_SMIME, "CRYPT: ", szFmt, arglist);
    va_end(arglist);
}

void PrefDOUT(DWORD dwLevel, LPSTR szPref, LPSTR szFmt, va_list arglist)
{
    char sz[MAX_PATH];

    lstrcpy(sz, szPref);
    lstrcat(sz, szFmt);
    vDOUTL(dwLevel, sz, arglist);
}


BOOL InitDebugHelpers(HINSTANCE hLib)
{
    s_fInit = TRUE;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    DOUTL(CRYPT_LEVEL,"%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    DOUTL(CRYPT_LEVEL,"%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Helpful util functions
//--------------------------------------------------------------------------

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult = FALSE;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

    Assert(s_fInit);

    cbInfo = 0;

    if (pInfo = (PCERT_NAME_INFO) PVDecodeObject(pbEncoded, cbEncoded, (LPCSTR)X509_NAME, &cbInfo)) {
        for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
            for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
                LPSTR pszObjId = pAttr->pszObjId;
                if (pszObjId == NULL)
                    pszObjId = "<NULL OBJID>";
                if ((pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                    (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                    DOUTL(CRYPT_LEVEL,"  [%d,%d] %s ValueType: %d\n",
                        i, j, pszObjId, pAttr->dwValueType);
                } else
                    DOUTL(CRYPT_LEVEL,"  [%d,%d] %s %s\n",
                        i, j, pszObjId, pAttr->Value.pbData);
            }
        }

        fResult = TRUE;
    }

    SafeMemFree(pInfo);
    return fResult;
}

void DisplayCert(PCCERT_CONTEXT pCert)
{
    Assert(s_fInit);

    if (!pCert)
        {
        DOUTL(CRYPT_LEVEL, "No certificate.");
        return;
        }

    DOUTL(CRYPT_LEVEL,"Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData);
    DOUTL(CRYPT_LEVEL,"Issuer::\n");
    DecodeName(pCert->pCertInfo->Issuer.pbData,
        pCert->pCertInfo->Issuer.cbData);

    {
        DWORD cb;
        BYTE *pb;
        DOUTL(CRYPT_LEVEL,"SerialNumber::");
        for (cb = pCert->pCertInfo->SerialNumber.cbData,
             pb = pCert->pCertInfo->SerialNumber.pbData + (cb - 1);
                                                        cb > 0; cb--, pb++) {
            DOUTL(CRYPT_LEVEL," %02X", *pb);
        }
        DOUTL(CRYPT_LEVEL,"\n");
    }
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i;

    Assert(s_fInit);
    for (i = 0; i < cEntry; i++, pEntry++) {
        DWORD cb;
        BYTE *pb;
        DOUTL(CRYPT_LEVEL," [%d] SerialNumber::", i);
        for (cb = pEntry->SerialNumber.cbData,
             pb = pEntry->SerialNumber.pbData + (cb - 1); cb > 0; cb--, pb++) {
            DOUTL(CRYPT_LEVEL," %02X", *pb);
        }
        DOUTL(CRYPT_LEVEL,"\n");

    }
}

void DisplayCrl(PCCRL_CONTEXT pCrl)
{
    Assert(s_fInit);
    DOUTL(CRYPT_LEVEL,"Issuer::\n");
    DecodeName(pCrl->pCrlInfo->Issuer.pbData,
        pCrl->pCrlInfo->Issuer.cbData);

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        DOUTL(CRYPT_LEVEL,"Entries:: NONE\n");
    else {
        DOUTL(CRYPT_LEVEL,"Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry);
    }
}

#endif // debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\containx.cpp ===
// --------------------------------------------------------------------------------
// Contain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "internat.h"
#include "inetstm.h"
#include "dllmain.h"
#include "olealloc.h"
#include "objheap.h"
#include "vstream.h"
#include "addparse.h"
#include "enumhead.h"
#include "addrenum.h"
#include "stackstr.h"
#include "stmlock.h"
#include "enumprop.h"
#include "smime.h"
#ifndef WIN16
#include "wchar.h"
#endif // !WIN16
#include "symcache.h"
#ifdef MAC
#include <stdio.h>
#endif  // MAC
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "mimeutil.h"

//#define TRACEPARSE 1

// --------------------------------------------------------------------------------
// Hash Table Stats
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD   g_cSetPidLookups  = 0;
DWORD   g_cHashLookups    = 0;
DWORD   g_cHashInserts    = 0;
DWORD   g_cHashCollides   = 0;
#endif

// --------------------------------------------------------------------------------
// Default Header Options
// --------------------------------------------------------------------------------
const HEADOPTIONS g_rDefHeadOptions = {
    NULL,                           // hCharset
    DEF_CBMAX_HEADER_LINE,          // OID_CBMAX_HEADER_LINE
    DEF_ALLOW_8BIT_HEADER,          // OID_ALLOW_8BIT_HEADER
    DEF_SAVE_FORMAT,                // OID_SAVE_FORMAT
    DEF_NO_DEFAULT_CNTTYPE,         // OID_NO_DEFAULT_CNTTYPE
    DEF_HEADER_RELOAD_TYPE_PROPSET  // OID_HEADER_REALOD_TYPE
};

// --------------------------------------------------------------------------------
// ENCODINGTABLE
// --------------------------------------------------------------------------------
const ENCODINGTABLE g_rgEncoding[] = {
    { STR_ENC_7BIT,         IET_7BIT     },
    { STR_ENC_QP,           IET_QP       },
    { STR_ENC_BASE64,       IET_BASE64   },
    { STR_ENC_UUENCODE,     IET_UUENCODE },
    { STR_ENC_XUUENCODE,    IET_UUENCODE },
    { STR_ENC_XUUE,         IET_UUENCODE },
    { STR_ENC_8BIT,         IET_8BIT     },
    { STR_ENC_BINARY,       IET_BINARY   },
    { STR_ENC_BINHEX40,     IET_BINHEX40 }
};


// --------------------------------------------------------------------------------
// CMimePropertyContainer::CMimePropertyContainer
// --------------------------------------------------------------------------------
CMimePropertyContainer::CMimePropertyContainer(void)
{
    // Basic Stuff
    m_cRef = 1;
    m_dwState = 0;
    m_cProps = 0;
    m_wTag = 0;
    m_cbSize = 0;
    m_cbStart = 0;
    m_pStmLock = NULL;

    // Default Options
    CopyMemory(&m_rOptions, &g_rDefHeadOptions, sizeof(HEADOPTIONS));
    m_rOptions.pDefaultCharset = CIntlGlobals::GetDefHeadCset();

    // Address Table
    ZeroMemory(&m_rAdrTable, sizeof(ADDRESSTABLE));

    // Header Table
    ZeroMemory(&m_rHdrTable, sizeof(HEADERTABLE));

    // Dispatch Call Stack
    ZeroMemory(&m_rTrigger, sizeof(TRIGGERCALLSTACK));

    // Property Indexes
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));
    ZeroMemory(m_prgHashTable, sizeof(m_prgHashTable));

    // Thread Safety
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::~CMimePropertyContainer
// --------------------------------------------------------------------------------
CMimePropertyContainer::~CMimePropertyContainer(void)
{
    // I better not have any dispatch calls on the stack
    Assert(m_rTrigger.cCalls == 0);

    // Free Hash Table
    _FreeHashTableElements();

    // Free the Address Table
    SafeMemFree(m_rAdrTable.prgpAdr);

    // Free the Header Table
    SafeMemFree(m_rHdrTable.prgpRow);

    // Release Stream
    SafeRelease(m_pStmLock);

    // Delete CS
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimePropertySet *)this;
    else if (IID_IPersist == riid)
        *ppv = (IPersist *)(IMimePropertySet *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_IMimePropertySet == riid)
        *ppv = (IMimePropertySet *)this;
    else if (IID_IMimeHeaderTable == riid)
        *ppv = (IMimeHeaderTable *)this;
    else if (IID_IMimeAddressTable == riid)
        *ppv = (IMimeAddressTable *)this;
    else if (IID_IMimeAddressTableW == riid)
        *ppv = (IMimeAddressTableW *)this;
    else if (IID_CMimePropertyContainer == riid)
        *ppv = (CMimePropertyContainer *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimePropertyContainer::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimePropertyContainer::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsState
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, dwState)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::ClearState
// --------------------------------------------------------------------------------
void CMimePropertyContainer::ClearState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetState
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetState(LPDWORD pdwState)
{
    Assert(pdwState);
    EnterCriticalSection(&m_cs);
    DWORD dw = m_dwState;
    LeaveCriticalSection(&m_cs);
    return dw;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetState
// --------------------------------------------------------------------------------
void CMimePropertyContainer::SetState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetClassID
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetClassID(CLSID *pClassID)
{
    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimePropertySet, sizeof(CLSID));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetSizeMax
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pStream=NULL;
    ULONG       cbSize;

    // Invalid Arg
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Dirty
    if (ISFLAGSET(m_dwState, COSTATE_DIRTY))
    {
        // Create temp stream
        CHECKALLOC(pStream = new CVirtualStream);

        // Commit
        CHECKHR(hr = Save(pStream, FALSE));

        // Get the Stream Size
        CHECKHR(hr = HrGetStreamSize(pStream, &cbSize));
    }

    // Otherwise, m_cbSize should be set to current size
    else
        cbSize = m_cbSize;

    // Return the Size
#ifdef MAC
    ULISet32(*pcbSize, cbSize);
#else   // !MAC
    pcbSize->QuadPart = cbSize;
#endif  // MAC

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::IsDirty(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, COSTATE_DIRTY)) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_ReloadInitNew
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_ReloadInitNew(void)
{
    // Handle all reload types
    switch(m_rOptions.ReloadType)
    {
    // Default behavior is no InitNew
    case RELOAD_HEADER_NONE:
        return;

    // InitNew everytime Load is called
    case RELOAD_HEADER_RESET:
        InitNew();
        break;

    // Merge or replace headers
    case RELOAD_HEADER_APPEND:
        SafeRelease(m_pStmLock);
        break;

    case RELOAD_HEADER_REPLACE:
        SafeRelease(m_pStmLock);
        _SetStateOnAllProps(PRSTATE_EXIST_BEFORE_LOAD);
        break;
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_SetStateOnAllProps (only first level properties)
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_SetStateOnAllProps(DWORD dwState)
{
    // Locals
    ULONG           i;
    LPPROPERTY      pProperty;

    // Do I have any groups
    if (0 == m_cProps)
        return;

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Walk the hash list
        pProperty = m_prgHashTable[i];

        // Loop the overflows
        while(pProperty)
        {
            // Set the state on the property
            FLAGSET(pProperty->dwState, dwState);

            // Goto Next
            pProperty = pProperty->pNextHash;
        }
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::InitNew(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No dispatchs better be out...
    Assert(m_rTrigger.cCalls == 0);

    // Free the PropTable
    _FreeHashTableElements();

    // Release the Stream
    SafeRelease(m_pStmLock);

    // Reset m_wTag
    m_wTag = LOWORD(GetTickCount());
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // Clear State
    m_dwState = 0;
    m_cbSize = 0;
    m_cbStart = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Load(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    CStreamLockBytes   *pStmLock=NULL;
    CInternetStream     cInternet;
    ULONG               cbOffset;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Wrap pStream in a pStmLock
    CHECKALLOC(pStmLock = new CStreamLockBytes(pStream));

    // Get Current Stream Position
    CHECKHR(hr = HrGetStreamPos(pStream, &cbOffset));

    // Create text stream object
    cInternet.InitNew(cbOffset, pStmLock);

    // Load from text stream object
    CHECKHR(hr = Load(&cInternet));

exit:
    // Cleanup
    SafeRelease(pStmLock);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Load
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Load(CInternetStream *pInternet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbData,
                    cbStart,
                    cboffStart,
                    cboffEnd;
    LONG            cboffColon;
    LPSTR           psz;
    DWORD           dwRowNumber=1;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    MIMEVARIANT     rValue;
    PROPSTRINGA     rHeader;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Starting Position
    m_cbStart = pInternet->DwGetOffset();

    // Initialize the PropValue
    rValue.type = MVT_STRINGA;

    // Reload InitNewType
    _ReloadInitNew();

    // Read Headers into Rows
    while(1)
    {
        // Mark Start of this header
        cboffStart = pInternet->DwGetOffset();

        // Read header line...
        CHECKHR(hr = pInternet->HrReadHeaderLine(&rHeader, &cboffColon));
        Assert(ISVALIDSTRINGA(&rHeader));

        // Are we done - empty line signals end of header
        if (*rHeader.pszVal == '\0')
        {
            // Compute Header Size
            m_cbSize = (LONG)(pInternet->DwGetOffset() - m_cbStart);

            // Done
            break;
        }

        // If no colon found
        if (-1 == cboffColon)
        {
            // Use the Illegal Symbol
            pSymbol = SYM_ATT_ILLEGAL;
        }

        // Otherwise...
        else
        {
            // Skip whitespace
            cbData = cboffColon;
            psz = rHeader.pszVal;

#if 0
            while(*psz && (*psz == ' ' || *psz == '\t'))
            {
                cbData--;
                psz++;
            }
#endif

            // Save Header Name
            Assert(rHeader.pszVal[cboffColon] == ':');
            *(rHeader.pszVal + cboffColon) = '\0';

            // Find Global Property
            hr = g_pSymCache->HrOpenSymbol(rHeader.pszVal, TRUE, &pSymbol);

            // Replace the colon
            *(rHeader.pszVal + cboffColon) = ':';

            // Bad Header Name or Failure
            if (FAILED(hr))
            {
                // Unknown Failure
                if (MIME_E_INVALID_HEADER_NAME != hr)
                {
                    TrapError(hr);
                    goto exit;
                }

                // Use the Illegal Symbol
                pSymbol = SYM_ATT_ILLEGAL;

                // Were are S_OK
                hr = S_OK;
            }
        }

        // Assert pSymbol
        Assert(pSymbol);

        // If Not Illegal
        if (PID_ATT_ILLEGAL == pSymbol->dwPropId)
        {
            cbData = rHeader.cchVal;
            psz = rHeader.pszVal;
            cboffColon = 0;
        }

        // Otherwise
        else
        {
            // We better have a symbol
            Assert(rHeader.pszVal[cboffColon] == ':');

            // Step over space between colon and first character
            cbData = (rHeader.cchVal - cboffColon - 1);
            psz = rHeader.pszVal + cboffColon + 1;
            if (*psz == ' ' || *psz == '\t')
            {
                cbData--;
                psz++;
            }
        }

        // Invalid Arg
        Assert(psz && psz[cbData] == '\0');

        // Append a Property
        if (RELOAD_HEADER_REPLACE == m_rOptions.ReloadType)
        {
            // Dos the property pSymbol already exist?
            if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
            {
                // Did the property exist before the load
                if (ISFLAGSET(pProperty->dwState, PRSTATE_EXIST_BEFORE_LOAD))
                {
                    // Delete the Property
                    SideAssert(SUCCEEDED(DeleteProp(pSymbol)));
                }
            }
        }

        // Simply append any existing property
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Setup Property Value
        rValue.rStringA.pszVal = psz;
        rValue.rStringA.cchVal = cbData;

        // Store the data on the property
        CHECKHR(hr = _HrSetPropertyValue(pProperty, PDF_ENCODED, &rValue, FALSE));

        // Still Trying to detect a character set...
        if (!ISFLAGSET(m_dwState, COSTATE_CSETTAGGED) && PID_ATT_ILLEGAL != pSymbol->dwPropId)
        {
            // Content-Type charset=xxx
            if (PID_HDR_CNTTYPE == pSymbol->dwPropId && NULL != m_prgIndex[PID_PAR_CHARSET])
            {
                // Locals
                LPPROPERTY      pProperty;
                LPINETCSETINFO  pCharset;

                // Did we have a charset=xxxx yet
                pProperty = m_prgIndex[PID_PAR_CHARSET];

                // Make sure it is a valid string property
                Assert(ISSTRINGA(&pProperty->rValue));

                // Get charset handle...
                if (SUCCEEDED(g_pInternat->HrOpenCharset(pProperty->rValue.rStringA.pszVal, &pCharset)))
                {
                    // We are tagged
                    FLAGSET(m_dwState, COSTATE_CSETTAGGED);

                    // Save the charset
                    m_rOptions.pDefaultCharset = pCharset;
                }
            }

            // Otherwise, is the property encoded in an rfc1522 charset?
            else if (!ISFLAGSET(m_dwState, COSTATE_1522CSETTAG) && pProperty->pCharset)
            {
                // The header is tagged with a 1522 charset
                FLAGSET(m_dwState, COSTATE_1522CSETTAG);

                // Assume that charset
                m_rOptions.pDefaultCharset = pProperty->pCharset;
            }
        }

        // Set The Row Number
        pProperty->dwRowNumber = dwRowNumber++;

        // Set Start Offset
        pProperty->cboffStart = cboffStart;

        // Map cboffColon from Line to Stream offset
        pProperty->cboffColon = cboffColon + pProperty->cboffStart;

        // Save cbOffEnd
        pProperty->cboffEnd = pInternet->DwGetOffset();
    }

    // Save the Stream
    Assert(NULL == m_pStmLock);

    // Get the stream object from the text stream
    pInternet->GetLockBytes(&m_pStmLock);

    // If not character set tagged
    if (!ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
    {
        // If not tagged with a 1522 charset, use the default
        if (!ISFLAGSET(m_dwState, COSTATE_1522CSETTAG) && CIntlGlobals::GetDefHeadCset())
        {
            // Assume the Default character Set
            m_rOptions.pDefaultCharset = CIntlGlobals::GetDefHeadCset();
        }

        // Lookup Charset Info
        if (m_rOptions.pDefaultCharset)
        {
            // Locals
            MIMEVARIANT rValue;

            // Setup Variant
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = m_rOptions.pDefaultCharset->szName;
            rValue.rStringA.cchVal = lstrlen(m_rOptions.pDefaultCharset->szName);

            // Set the Charset Attribute
            SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, 0, &rValue)));
        }
    }

    // We better have a charset
    Assert(m_rOptions.pDefaultCharset);

    // Make sure we are not dirty
    FLAGCLEAR(m_dwState, COSTATE_DIRTY);

    // Any Illegal lines found ?
    hr = (NULL == m_prgIndex[PID_ATT_ILLEGAL]) ? S_OK : MIME_S_ILLEGAL_LINES_FOUND;

exit:
    // Failure
    if (FAILED(hr))
        InitNew();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetHeaderTableSaveIndex
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetHeaderTableSaveIndex(ULONG *pcRows, LPROWINDEX *pprgIndex)
{
    // Locals
    HRESULT      hr=S_OK;
    ULONG        i;
    LPPROPERTY   pRow;
    ULONG        cRows=0;
    LPROWINDEX   prgIndex=NULL;
    ULONG        cSymbols=g_pSymCache->GetCount();
    DWORD        dwMaxRow=0;

    // Invalid Arg
    Assert(pcRows && pprgIndex);

    // Init Row Count
    *pcRows = 0;
    *pprgIndex = NULL;

    // Allocate pprgdwIndex based on m_rHdrTable.cRows (this is the max)
    CHECKALLOC(prgIndex = (LPROWINDEX)g_pMalloc->Alloc(sizeof(ROWINDEX) * m_rHdrTable.cRows));

    // Zero
    ZeroMemory(prgIndex, sizeof(ROWINDEX) * m_rHdrTable.cRows);

    // I need to find the larged pProperty->dwRowNumber so that I can order the rows better
    for (i=0; i<m_rHdrTable.cRows; i++)
    {
        if (m_rHdrTable.prgpRow[i])
            if (!ISFLAGSET(m_rHdrTable.prgpRow[i]->dwState, PRSTATE_USERSETROWNUM))
                if (m_rHdrTable.prgpRow[i]->dwRowNumber > dwMaxRow)
                    dwMaxRow = m_rHdrTable.prgpRow[i]->dwRowNumber;
    }

    // Compute Position Weight for all items in the table
    for (i=0; i<m_rHdrTable.cRows; i++)
    {
        // Readability
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Save As SAVE_RFC822 and this is a MPF_MIME header
        if (SAVE_RFC822 == m_rOptions.savetype && ISFLAGSET(pRow->pSymbol->dwFlags, MPF_MIME))
            continue;

        // Init dwPosWeight
        prgIndex[cRows].dwWeight = 0;
        prgIndex[cRows].hRow = pRow->hRow;

        // Unknonw Row Number
        if (0 == pRow->dwRowNumber)
        {
            // Compute the Row Weigth
            Assert(pRow->pSymbol->dwRowNumber != 0);
            prgIndex[cRows].dwWeight = (ULONG)((pRow->pSymbol->dwRowNumber * 1000) / m_rHdrTable.cRows);
        }

        // User set the row number
        else if (ISFLAGSET(pRow->dwState, PRSTATE_USERSETROWNUM))
        {
            // Compute the Row Weigth
            prgIndex[cRows].dwWeight = (ULONG)((pRow->dwRowNumber * 1000) / m_rHdrTable.cRows);
        }

        // Otheriwse, this row number have been in the original row set from ::Load
        else if (dwMaxRow > 0)
        {
            // Weight within original row set
            DWORD dw1 = (DWORD)((pRow->dwRowNumber * 100) / dwMaxRow);

            // Compute global symbol row number
            DWORD dwRow = (DWORD)((float)((float)dw1 / (float)100) * cSymbols);

            // Compute the Row Weigth
            prgIndex[cRows].dwWeight = (ULONG)((dwRow * 1000) / m_rHdrTable.cRows);
        }

        // Increment Row Count
        cRows++;
    }

    // Set the Sort Order Index of all the rows
    if (cRows > 0)
        _SortHeaderTableSaveIndex(0, cRows - 1, prgIndex);

    // Return the Index
    *pprgIndex = prgIndex;
    *pcRows = cRows;
    prgIndex = NULL;

exit:
    // Cleanup
    SafeMemFree(prgIndex);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_SortHeaderTableSaveIndex
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_SortHeaderTableSaveIndex(LONG left, LONG right, LPROWINDEX prgIndex)
{
    // Locals
    register    long i, j;
    ROWINDEX    k, temp;

    i = left;
    j = right;
    CopyMemory(&k, &prgIndex[(i + j) / 2], sizeof(ROWINDEX));

    do
    {
        while(prgIndex[i].dwWeight < k.dwWeight && i < right)
            i++;
        while (prgIndex[j].dwWeight > k.dwWeight && j > left)
            j--;

        if (i <= j)
        {
            CopyMemory(&temp, &prgIndex[i], sizeof(ROWINDEX));
            CopyMemory(&prgIndex[i], &prgIndex[j], sizeof(ROWINDEX));
            CopyMemory(&prgIndex[j], &temp, sizeof(ROWINDEX));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _SortHeaderTableSaveIndex(left, j, prgIndex);
    if (i < right)
        _SortHeaderTableSaveIndex(i, right, prgIndex);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FIsValidHAddress
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FIsValidHAddress(HADDRESS hAddress)
{
    // Invalid Sig or index
    if ((WORD)(HADDRESSTICK(hAddress)) != m_wTag || HADDRESSINDEX(hAddress) >= m_rAdrTable.cAdrs)
        return FALSE;

    // Row has been deleted
    if (NULL == m_rAdrTable.prgpAdr[HADDRESSINDEX(hAddress)])
        return FALSE;

    // Otherwise, its valid
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FIsValidHRow
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FIsValidHRow(HHEADERROW hRow)
{
    // Invalid Sig or index
    if ((WORD)(HROWTICK(hRow)) != m_wTag || HROWINDEX(hRow) >= m_rHdrTable.cRows)
        return FALSE;

    // Row has been deleted
    if (NULL == m_rHdrTable.prgpRow[HROWINDEX(hRow)])
        return FALSE;

    // Otherwise, its valid
    return TRUE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    LPPROPERTY      pProperty;
    ULONG           i,
                    j,
                    cbWrote,
                    cRows;
    MIMEVARIANT     rValue;
    LPROWINDEX      prgIndex=NULL;
    INETCSETINFO    rCharset;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // There Better be a content type
    if (FALSE == m_rOptions.fNoDefCntType && NULL == m_prgIndex[PID_HDR_CNTTYPE])
    {
        // Set the content Type
        SideAssert(SUCCEEDED(SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN)));
    }

    // Validate the Charset
    if (m_rOptions.pDefaultCharset)
    {
        // Internet Encoded and Windows Encoding are CPI_AUTODETECT
        if (CP_JAUTODETECT == m_rOptions.pDefaultCharset->cpiInternet ||
            50222          == m_rOptions.pDefaultCharset->cpiInternet ||
            50221          == m_rOptions.pDefaultCharset->cpiInternet)
        {
            // Only for _autodetect
            if (CP_JAUTODETECT == m_rOptions.pDefaultCharset->cpiInternet)
            {
                // Change Charset
                SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(c_szISO2022JP, &m_rOptions.pDefaultCharset)));
            }

            // Reset It
            if (m_prgIndex[PID_PAR_CHARSET])
            {
                // Set the Charset...
                SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, c_szISO2022JP)));
            }
        }
    }

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Speicify data type
    rValue.type = MVT_STREAM;
    rValue.pStream = pStream;

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));

        // Saved already
        if (TRUE == prgIndex[i].fSaved)
            continue;

        // Readability
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Ask the value for the data
        CHECKHR(hr = _HrGetPropertyValue(pRow, PDF_HEADERFORMAT | PDF_NAMEINDATA, &rValue));

        // This block of code was disabled to fix:
        // Raid-62460: MimeOLE: IMimeAddressTable::AppendRfc822 does not work correctly
#if 0
        // Raid-43786: Mail:  Reply all to a message with multiple To: fields in header and the original recipient list is tripled
        if (ISFLAGSET(pRow->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Loop through remainin items and mark as saved
            for (j=i+1; j<cRows; j++)
            {
                // Get the row
                Assert(_FIsValidHRow(prgIndex[j].hRow));

                // Readability
                pProperty = PRowFromHRow(prgIndex[j].hRow);

                // Same Address Type
                if (pProperty->pSymbol->dwAdrType == pRow->pSymbol->dwAdrType)
                    prgIndex[j].fSaved = TRUE;
            }
        }
#endif
    }

    // Make sure we are not dirty
    if (fClearDirty)
        FLAGCLEAR(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeMemFree(prgIndex);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FreeHashTableElements
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_FreeHashTableElements(void)
{
    // Locals
    ULONG           i;
    LPPROPERTY      pCurrHash,
                    pNextHash;

    // Do I have any groups
    if (0 == m_cProps)
        return;

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Is this chain empty ?
        if (m_prgHashTable[i])
        {
            // Walk the hash list
            pCurrHash = m_prgHashTable[i];

            // Loop the overflows
            while(pCurrHash)
            {
                // Save Next
                pNextHash = pCurrHash->pNextHash;

                // Release This Chain
                _FreePropertyChain(pCurrHash);

                // Goto Next
                pCurrHash = pNextHash;
            }

            // Set to NULL
            m_prgHashTable[i] = NULL;
        }
    }

    // Empty the arrays
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));

    // No Groups
    m_cProps = 0;
    m_rAdrTable.cAdrs = 0;
    m_rHdrTable.cRows = 0;
    m_rHdrTable.cEmpty = 0;
    m_rAdrTable.cEmpty = 0;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreePropertyChain
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreePropertyChain(LPPROPERTY pProperty)
{
    // Locals
    LPPROPERTY   pCurrValue,
                 pNextValue;

    // Walk this list
    pCurrValue = pProperty;
    while(pCurrValue)
    {
        // Save Next Item
        pNextValue = pCurrValue->pNextValue;

        // Remove from header table
        if (pCurrValue->hRow)
            _UnlinkHeaderRow(pCurrValue->hRow);

        // Remove from address table
        if (pCurrValue->pGroup)
            _UnlinkAddressGroup(pCurrValue);

        // Free this item
        ObjectHeap_FreeProperty(pCurrValue);

        // Goto next
        pCurrValue = pNextValue;
    }
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkHeaderRow
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkHeaderRow(HHEADERROW hRow)
{
    // Validate the Handle
    Assert(_FIsValidHRow(hRow));

    // Get the row
    m_rHdrTable.prgpRow[HROWINDEX(hRow)] = NULL;

    // Increment Empty Count
    m_rHdrTable.cEmpty++;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkAddressGroup
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkAddressGroup(LPPROPERTY pProperty)
{
    // Invalid Arg
    Assert(pProperty && pProperty->pGroup);

    // Free This Address Chain
    _FreeAddressChain(pProperty->pGroup);

    // Prepare for unlink
    LPPROPERTY pNext = pProperty->pGroup->pNext;
    LPPROPERTY pPrev = pProperty->pGroup->pPrev;

    // If Previious...
    if (pPrev)
    {
        Assert(pPrev->pGroup);
        pPrev->pGroup->pNext = pNext;
    }

    // If Next
    if (pNext)
    {
        Assert(pNext->pGroup);
        pNext->pGroup->pPrev = pPrev;
    }

    // Was this the header ?
    if (m_rAdrTable.pHead == pProperty)
        m_rAdrTable.pHead = pNext;
    if (m_rAdrTable.pTail == pProperty)
        m_rAdrTable.pTail = pPrev;

    // Clear the Group
    ZeroMemory(pProperty->pGroup, sizeof(ADDRESSGROUP));
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreeAddressChain
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreeAddressChain(LPADDRESSGROUP pGroup)
{
    // Locals
    LPMIMEADDRESS  pCurr;
    LPMIMEADDRESS  pNext;

    // Loop through data structures
    pCurr = pGroup->pHead;
    while(pCurr)
    {
        // Set Next
        pNext = pCurr->pNext;

        // Unlink this address
        _FreeAddress(pCurr);

        // Goto Next
        pCurr = pNext;
    }

    // Fixup the Group
    pGroup->pHead = NULL;
    pGroup->pTail = NULL;
    pGroup->cAdrs = 0;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_FreeAddress
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_FreeAddress(LPMIMEADDRESS pAddress)
{
    // Validate the Handle
    Assert(_FIsValidHAddress(pAddress->hThis));

    // Get the row
    m_rAdrTable.prgpAdr[HADDRESSINDEX(pAddress->hThis)] = NULL;

    // Increment Empty Count
    m_rAdrTable.cEmpty++;

    // Free pCurr
    ObjectHeap_FreeAddress(pAddress);
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkAddress
// ---------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkAddress(LPMIMEADDRESS pAddress)
{
    // Invalid Arg
    Assert(pAddress && pAddress->pGroup);

    // Prepare for unlink
    LPMIMEADDRESS pNext = pAddress->pNext;
    LPMIMEADDRESS pPrev = pAddress->pPrev;

    // If Previious...
    if (pPrev)
    {
        Assert(pPrev->pGroup && pPrev->pGroup == pAddress->pGroup);
        pPrev->pNext = pNext;
    }

    // If Next
    if (pNext)
    {
        Assert(pNext->pGroup && pNext->pGroup == pAddress->pGroup);
        pNext->pPrev = pPrev;
    }

    // Was this the header ?
    if (pAddress->pGroup->pHead == pAddress)
        pAddress->pGroup->pHead = pNext;
    if (pAddress->pGroup->pTail == pAddress)
        pAddress->pGroup->pTail = pPrev;

    // Decrement Group Count
    pAddress->pGroup->cAdrs--;

    // Address group is dirty
    pAddress->pGroup->fDirty = TRUE;

    // Cleanup pAddress
    pAddress->pNext = NULL;
    pAddress->pPrev = NULL;
    pAddress->pGroup = NULL;
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindFirstProperty
// ---------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindFirstProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty)
{
    // Validate pFind
    Assert(pFind->pszPrefix && pFind->pszName)
    Assert(pFind->pszPrefix[pFind->cchPrefix] == '\0' && pFind->pszName[pFind->cchName] == '\0');

    // Start with first hash table bucket
    pFind->wHashIndex = 0;

    // Start with first property in the hash table
    pFind->pProperty = m_prgHashTable[pFind->wHashIndex];

    // Find Next
    return _HrFindNextProperty(pFind, ppProperty);
}

// ---------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindNextProperty
// ---------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindNextProperty(LPFINDPROPERTY pFind, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Init
    *ppProperty = NULL;

    // Continue walking buckets
    while (1)
    {
        // Continue looping chain
        while (pFind->pProperty)
        {
            // Good Symbol
            Assert(SUCCEEDED(HrIsValidSymbol(pFind->pProperty->pSymbol)));

            // Readability
            pSymbol = pFind->pProperty->pSymbol;

            // Should I delete this one
            if (pSymbol->cchName >= pFind->cchPrefix + pFind->cchName)
            {
                // Compare Prefix
                if (StrCmpNI(pSymbol->pszName, pFind->pszPrefix, pFind->cchPrefix) == 0)
                {
                    // Compare Name
                    if (StrCmpNI(pSymbol->pszName + pFind->cchPrefix, pFind->pszName, pFind->cchName) == 0)
                    {
                        // We found a property
                        *ppProperty = pFind->pProperty;

                        // Goto the next in the chain
                        pFind->pProperty = pFind->pProperty->pNextHash;

                        // Done
                        goto exit;
                    }
                }
            }

            // Next in chain
            pFind->pProperty = pFind->pProperty->pNextHash;
        }

        // Next Bucket
        pFind->wHashIndex++;

        // Done
        if (pFind->wHashIndex >= CBUCKETS)
            break;

        // If not done, goto first item in the bucket
        pFind->pProperty = m_prgHashTable[pFind->wHashIndex];
    }

    // NOt Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrFindProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrFindProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fTryName=FALSE;

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // By Known Symbol
    if (ISKNOWNPID(pSymbol->dwPropId))
    {
        // Stats
#ifdef DEBUG
        g_cSetPidLookups++;
#endif
        // Is there data
        if (m_prgIndex[pSymbol->dwPropId])
        {
            // Set It (could be NULL)
            *ppProperty = m_prgIndex[pSymbol->dwPropId];

            // Done
            goto exit;
        }
    }

    // Otherwise, lookup by name
    else
    {
        // Stats
#ifdef DEBUG
        g_cHashLookups++;
#endif
        // Loop
        Assert(pSymbol->wHashIndex < CBUCKETS);
        for (LPPROPERTY pProperty=m_prgHashTable[pSymbol->wHashIndex]; pProperty!=NULL; pProperty=pProperty->pNextHash)
        {
            // Compare
            if (pProperty && pProperty->pSymbol->dwPropId == pSymbol->dwPropId)
            {
                // Validate Hash Index
                Assert(pProperty->pSymbol->wHashIndex == pSymbol->wHashIndex);

                // Set Return
                *ppProperty = pProperty;

                // Done
                goto exit;
            }
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Not Found
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrOpenProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrOpenProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // If we dont find it, try to create it
    if (FAILED(_HrFindProperty(pSymbol, ppProperty)))
        return TrapError(_HrCreateProperty(pSymbol, ppProperty));

    // We Found It, return
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCreateProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCreateProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty;
#ifdef DEBUG
    LPPROPERTY      pTemp;
#endif

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // Allocate an item...
    CHECKHR(hr = ObjectHeap_HrAllocProperty(&pProperty));

    // Set the symbol
    pProperty->pSymbol = pSymbol;

    // The Property Better Not Exist Yet (Assumes caller did a FindProperty before CreateProperty)
    Assert(_HrFindProperty(pSymbol, &pTemp) == MIME_E_NOT_FOUND);

    // MPF_HEADER
    if (ISFLAGSET(pSymbol->dwFlags, MPF_HEADER))
    {
        // Insert into the header table
        CHECKHR(hr = _HrAppendHeaderTable(pProperty));
    }

    // MPF_ADDRESS
    if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Insert into the header table
        CHECKHR(hr = _HrAppendAddressTable(pProperty));
    }

    // Stats
#ifdef DEBUG
    g_cHashInserts++;
    if (m_prgHashTable[pSymbol->wHashIndex])
        g_cHashCollides++;
#endif

    // Set Next Hash Item
    Assert(pSymbol->wHashIndex < CBUCKETS);
    pProperty->pNextHash = m_prgHashTable[pSymbol->wHashIndex];

    // New Properties are places as the head of the overflow chain
    m_prgHashTable[pSymbol->wHashIndex] = pProperty;

    // Insert into Known Property Index
    if (ISKNOWNPID(pSymbol->dwPropId))
    {
        Assert(m_prgIndex[pSymbol->dwPropId] == NULL);
        m_prgIndex[pSymbol->dwPropId] = pProperty;
    }

    // PRSTATE_PARENT
    FLAGSET(pProperty->dwState, PRSTATE_PARENT);

    // Return this prop
    *ppProperty = pProperty;

    // Count Properties
    m_cProps++;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendProperty(LPPROPSYMBOL pSymbol, LPPROPERTY *ppProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pParent,
                    pAppend;

    // Invalid Arg
    Assert(pSymbol && ppProperty);

    // Does pTag already exist ?
    if (SUCCEEDED(_HrFindProperty(pSymbol, &pParent)))
    {
        // Better be a parent property
        Assert(ISFLAGSET(pParent->dwState, PRSTATE_PARENT));

        // Allocate an item...
        CHECKHR(hr = ObjectHeap_HrAllocProperty(&pAppend));

        // pSymbol From pTag
        pAppend->pSymbol = pParent->pSymbol;

        // If this is a header property, insert into the header table
        if (ISFLAGSET(pSymbol->dwFlags, MPF_HEADER))
        {
            // Insert into the header table
            CHECKHR(hr = _HrAppendHeaderTable(pAppend));
        }

        // MPF_ADDRESS
        if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Insert into the header table
            CHECKHR(hr = _HrAppendAddressTable(pAppend));
        }

        // Update pParent->pTailData
        if (NULL == pParent->pNextValue)
        {
            Assert(NULL == pParent->pTailValue);
            pParent->pNextValue = pAppend;
            pParent->pTailValue = pAppend;
        }
        else
        {
            Assert(pParent->pTailValue && pParent->pTailValue->pNextValue == NULL);
            pParent->pTailValue->pNextValue = pAppend;
            pParent->pTailValue = pAppend;
        }

        // Return this prop
        *ppProperty = pAppend;

        // Count Properties
        m_cProps++;
    }

    // Otherwise, create a new property
    else
    {
        // Create It
        CHECKHR(hr = _HrCreateProperty(pSymbol, ppProperty));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendAddressGroup(LPADDRESSGROUP pGroup, LPMIMEADDRESS *ppAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i=0;
    BOOL            fUsingEmpty=FALSE;
    LPMIMEADDRESS   pAddress;

    // Use Empty Cell
    if (m_rAdrTable.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rAdrTable.cAdrs; i++)
        {
            // Empty ?
            if (NULL == m_rAdrTable.prgpAdr[i])
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rAdrTable.cAdrs + 1 > m_rAdrTable.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rAdrTable.prgpAdr, sizeof(LPMIMEADDRESS) * (m_rAdrTable.cAlloc + 10)));

            // Increment alloc size
            m_rAdrTable.cAlloc += 10;
        }

        // Index to use
        i = m_rAdrTable.cAdrs;
    }

    // Allocate an address props structure
    CHECKHR(hr = ObjectHeap_HrAllocAddress(&pAddress));

    // Assign a Handle
    pAddress->hThis = HADDRESSMAKE(i);

    // Link the Address into the group
    _LinkAddress(pAddress, pGroup);

    // Put it into the Array
    m_rAdrTable.prgpAdr[i] = pAddress;

    // Return It
    *ppAddress = pAddress;

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rAdrTable.cAdrs++;
    else
        m_rAdrTable.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_LinkAddress
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_LinkAddress(LPMIMEADDRESS pAddress, LPADDRESSGROUP pGroup)
{
    // Validate Arg
    Assert(pAddress && pGroup && NULL == pAddress->pNext && NULL == pAddress->pPrev);

    // Put pGroup into pAddress
    pAddress->pGroup = pGroup;

    // Link into the list
    if (NULL == pGroup->pHead)
    {
        Assert(NULL == pGroup->pTail);
        pGroup->pHead = pAddress;
        pGroup->pTail = pAddress;
    }
    else
    {
        Assert(pGroup->pTail && pGroup->pTail->pNext == NULL);
        pGroup->pTail->pNext = pAddress;
        pAddress->pPrev = pGroup->pTail;
        pGroup->pTail = pAddress;
    }

    // Increment Count
    pGroup->cAdrs++;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendAddressTable
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendAddressTable(LPPROPERTY pProperty)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pProperty && NULL == pProperty->pGroup);

    // New Group
    CHECKALLOC(pProperty->pGroup = (LPADDRESSGROUP)g_pMalloc->Alloc(sizeof(ADDRESSGROUP)));

    // ZeroInit
    ZeroMemory(pProperty->pGroup, sizeof(ADDRESSGROUP));

    // Link this group
    if (NULL == m_rAdrTable.pHead)
    {
        Assert(m_rAdrTable.pTail == NULL);
        m_rAdrTable.pHead = pProperty;
        m_rAdrTable.pTail = pProperty;
    }
    else
    {
        Assert(m_rAdrTable.pTail && m_rAdrTable.pTail->pGroup && m_rAdrTable.pTail->pGroup->pNext == NULL);
        m_rAdrTable.pTail->pGroup->pNext = pProperty;
        pProperty->pGroup->pPrev = m_rAdrTable.pTail;
        m_rAdrTable.pTail = pProperty;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrAppendHeaderTable
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrAppendHeaderTable(LPPROPERTY pProperty)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               i=0;
    BOOL                fUsingEmpty=FALSE;

    // Invalid Arg
    Assert(pProperty && NULL == pProperty->hRow);

    // Use Empty Cell
    if (m_rHdrTable.cEmpty)
    {
        // Find First Empty Cell..
        for (i=0; i<m_rHdrTable.cRows; i++)
        {
            // Empty ?
            if (NULL == m_rHdrTable.prgpRow)
            {
                fUsingEmpty = TRUE;
                break;
            }
        }
    }

    // If not using empty
    if (FALSE == fUsingEmpty)
    {
        // Lets grow the table first...
        if (m_rHdrTable.cRows + 1 > m_rHdrTable.cAlloc)
        {
            // Grow my current property value array
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rHdrTable.prgpRow, sizeof(LPPROPERTY) * (m_rHdrTable.cAlloc + 10)));

            // Increment alloc size
            m_rHdrTable.cAlloc += 10;
        }

        // Index to use
        i = m_rHdrTable.cRows;
    }

    // Save Property index table
    m_rHdrTable.prgpRow[i] = pProperty;

    // Set Handle
    pProperty->hRow = HROWMAKE(i);

    // If not using empty cell, increment body count
    if (FALSE == fUsingEmpty)
        m_rHdrTable.cRows++;
    else
        m_rHdrTable.cEmpty--;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsPropSet
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsPropSet(LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_FALSE;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;

    // Invalid Arg
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    if (FAILED(g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol)))
        goto exit;

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
        goto exit;

    // Its Set
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurr;

    // Invalid Arg
    if (NULL == pszName || NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Find the Property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // PIM_CHARSET
    if (ISFLAGSET(pInfo->dwMask, PIM_CHARSET))
    {
        // Get Charset
        pInfo->hCharset = pProperty->pCharset ? pProperty->pCharset->hCharset : m_rOptions.pDefaultCharset->hCharset;
    }

    // PIM_ENCODINGTYPE
    if (ISFLAGSET(pInfo->dwMask, PIM_ENCODINGTYPE))
    {
        // Get Encoding
        pInfo->ietEncoding = pProperty->ietValue;
    }

    // PIM_ROWNUMBER
    if (ISFLAGSET(pInfo->dwMask, PIM_ROWNUMBER))
        pInfo->dwRowNumber = pProperty->dwRowNumber;

    // PIM_FLAGS
    if (ISFLAGSET(pInfo->dwMask, PIM_FLAGS))
        pInfo->dwFlags = pProperty->pSymbol->dwFlags;

    // PIM_PROPID
    if (ISFLAGSET(pInfo->dwMask, PIM_PROPID))
        pInfo->dwPropId = pProperty->pSymbol->dwPropId;

    // PIM_VALUES
    if (ISFLAGSET(pInfo->dwMask, PIM_VALUES))
    {
        // Let me count the ways
        for(pCurr=pProperty, pInfo->cValues=0; pCurr!=NULL; pCurr=pCurr->pNextValue)
            pInfo->cValues++;
    }

    // PIM_VTCURRENT
    if (ISFLAGSET(pInfo->dwMask, PIM_VTCURRENT))
        pInfo->vtCurrent = MimeVT_To_PropVT(&pProperty->rValue);

    // PIM_VTDEFAULT
    if (ISFLAGSET(pInfo->dwMask, PIM_VTDEFAULT))
        pInfo->vtDefault = pProperty->pSymbol->vtDefault;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurr;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == pszName || NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Find the Property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // Set All Values with the property information
    for(pCurr=pProperty; pCurr!=NULL; pCurr=pCurr->pNextValue)
    {
        // PIM_CHARSET
        if (ISFLAGSET(pInfo->dwMask, PIM_CHARSET))
        {
            // Open the Charset
            if (SUCCEEDED(g_pInternat->HrOpenCharset(pInfo->hCharset, &pCharset)))
                pProperty->pCharset = pCharset;
        }

        // PIM_ENCODED
        if (ISFLAGSET(pInfo->dwMask, PIM_ENCODINGTYPE))
        {
            // Change Encoding State of the mime Variant
            pProperty->ietValue = (IET_ENCODED == pInfo->ietEncoding) ? IET_ENCODED : IET_DECODED;
        }

        // PIM_ROWNUMBER
        if (ISFLAGSET(pInfo->dwMask, PIM_ROWNUMBER))
        {
            // Save the Row Number
            pCurr->dwRowNumber = pInfo->dwRowNumber;

            // Make a note that the use set this row number so the save order doesn't get hosed
            FLAGSET(pCurr->dwState, PRSTATE_USERSETROWNUM);
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         cProps=0,
                         cAlloc=0;
    LPENUMPROPERTY       prgProp=NULL;
    LPPROPERTY           pCurrProp;
    CMimeEnumProperties *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the item table
    for (i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrProp=m_prgHashTable[i]; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextHash)
        {
            // Grow the array ?
            if (cProps + 1 > cAlloc)
            {
                // Realloc
                CHECKALLOC(prgProp = (LPENUMPROPERTY)g_pMalloc->Realloc((LPVOID)prgProp, sizeof(ENUMPROPERTY) * (cAlloc + 10)));

                // Increment cAlloc
                cAlloc += 10;
            }

            // hRow
            prgProp[cProps].hRow = pCurrProp->hRow;

            // dwPropId
            prgProp[cProps].dwPropId = pCurrProp->pSymbol->dwPropId;

            // Init Name to Null
            prgProp[cProps].pszName = NULL;

            // Name
            if (ISFLAGSET(dwFlags, EPF_NONAME) == FALSE)
            {
                // Return name
                CHECKALLOC(prgProp[cProps].pszName = PszDupA(pCurrProp->pSymbol->pszName));
            }

            // Increment iProp
            cProps++;
        }
    }

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumProperties);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, cProps, prgProp, FALSE));

    // Don't Free pEnumRow
    prgProp = NULL;
    cProps = 0;

    // Return it
    (*ppEnum) = (IMimeEnumProperties *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    g_pMoleAlloc->FreeEnumPropertyArray(cProps, prgProp, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::BindToObject
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::BindToObject(REFIID riid, void **ppvObject)
{
    return TrapError(QueryInterface(riid, ppvObject));
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrBuildAddressString
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrBuildAddressString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cAddrsWrote=0;
    LPSTREAM        pStream=NULL;
    CByteStream     cByteStream;
    LPPROPERTY      pCurrValue;
    MIMEVARIANT     rValue;
    ADDRESSFORMAT   format;
    LPINETCSETINFO  pCharsetSource=NULL;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // Decide on a format
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
        format = AFT_RFC822_TRANSMIT;
    else if (ISFLAGSET(dwFlags, PDF_ENCODED))
        format = AFT_RFC822_ENCODED;
    else
        format = AFT_DISPLAY_BOTH;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pProperty->pSymbol->pszName, pProperty->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // Save with no encoding
    if (ISFLAGSET(pProperty->dwState, PRSTATE_SAVENOENCODE))
    {
        // Better be groupdirty
        Assert(ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

        // Convert Data...
        rValue.type = MVT_STRINGA;

        // Destination is not encoded
        pCharsetSource = pProperty->pCharset ? pProperty->pCharset : m_rOptions.pDefaultCharset;

        // Convert It
        CHECKHR(hr = HrConvertVariant(pProperty, CVF_NOALLOC | PDF_ENCODED, &rValue));

        // Write it to the stream
        CHECKHR(hr = pStream->Write(rValue.rStringA.pszVal, rValue.rStringA.cchVal, NULL));
    }

    // Otherwise, normal save
    else
    {
        // Loop through parsed addresses...
        for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
        {
            // We should have an address
            Assert(pCurrValue->pGroup && ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS));

            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));

            // Tell each address group object to write its data to the stream
            if (pCurrValue->pGroup)
            {
                // Write the data
                CHECKHR(hr = _HrSaveAddressGroup(pCurrValue, pStream, &cAddrsWrote, format, VT_LPSTR));
            }

            // Set It Yet ?
            if (NULL == pCharsetSource)
            {
                pCharsetSource = pCurrValue->pCharset ? pCurrValue->pCharset : m_rOptions.pDefaultCharset;
            }

            // No Vectoring
            if (FALSE == ISFLAGSET(dwFlags, PDF_VECTOR))
                break;
        }
    }

    // Transmit
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
    {
        // Final CRLF if Transmit Format
        CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
    }

    // Final CRLF
    if (cAddrsWrote || ISFLAGSET(dwFlags, PDF_NAMEINDATA) || ISFLAGSET(dwFlags,PDF_HEADERFORMAT))
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            CODEPAGEID cpSource=CP_ACP;
            PROPSTRINGA rStringA;

            // Init
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Determine cpSoruce
            if (pCharsetSource)
            {
                // If Encoded, use internet codepage, otherwise, use Windows codepage
                cpSource = ISFLAGSET(dwFlags, PDF_ENCODED) ? pCharsetSource->cpiInternet : MimeOleGetWindowsCPEx(pCharsetSource);
            }

            // Convert to Unicode
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(cpSource, &rStringA, &pValue->rStringW));

        }
        else
            Assert(MVT_STREAM == pValue->type);
    }

    // No Data
    else
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

exit:
    // Cleanup
    MimeVariantFree(&rValue);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrBuildParameterString
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrBuildParameterString(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    LPSTR           pszParamName;
    LPSTR           pszEscape=NULL;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;
    LPSTREAM        pStream=NULL;
    CByteStream     cByteStream;
    BOOL            fQuoted;
    ULONG           cWrote=0;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pProperty && pProperty->pNextValue == NULL && pValue);
    Assert(ISSTRINGA(&pProperty->rValue));

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init rValue
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pProperty->pSymbol->pszName, pProperty->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // Write First Prop
    CHECKHR(hr = pStream->Write(pProperty->rValue.rStringA.pszVal, pProperty->rValue.rStringA.cchVal, NULL));

    // We wrote one item
    cWrote = 1;

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);
    while(SUCCEEDED(hrFind) && pParameter)
    {
        // Transmit Format
        if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
        {
            // Write ';\r\n\t'
            CHECKHR(hr = pStream->Write(c_szParamFold, lstrlen(c_szParamFold), NULL));
        }

        // Otherwise
        else
        {
            // Write ';\r\n\t'
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }

        // Get Parameter Name
        pszParamName = PszScanToCharA((LPSTR)pParameter->pSymbol->pszName, ':');
        pszParamName++;
        pszParamName = PszScanToCharA(pszParamName, ':');
        pszParamName++;

        // Write the name
        CHECKHR(hr = pStream->Write(pszParamName, lstrlen(pszParamName), NULL));

        // Write the property...
        CHECKHR(hr = pStream->Write(c_szEqual, lstrlen(c_szEqual), NULL));

        // Convert Data...
        rValue.type = MVT_STRINGA;

        // Convert It
        CHECKHR(hr = HrConvertVariant(pParameter, CVF_NOALLOC | PDF_ENCODED, &rValue));

        // Quoted
        fQuoted = FALSE;
        if (lstrcmpi(pszParamName, (LPSTR)c_szBoundary) == 0 || lstrcmpi(pszParamName, (LPSTR)c_szFileName) == 0 ||
            lstrcmpi(pszParamName, (LPSTR)c_szName)     == 0 || lstrcmpi(pszParamName, (LPSTR)c_szID)       == 0 ||
            lstrcmpi(pszParamName, (LPSTR)c_szCharset)  == 0)
            fQuoted = TRUE;

        // Otherwise, check for must quote characters
        else
        {
            // Loop the string
            for (ULONG i=0; i<rValue.rStringA.cchVal; i++)
            {
                // Must quote character
                if (rValue.rStringA.pszVal[i] == ';'   ||
                    rValue.rStringA.pszVal[i] == '\"'  ||
                    rValue.rStringA.pszVal[i] == '/'   ||
                    rValue.rStringA.pszVal[i] == '\""' ||
                    rValue.rStringA.pszVal[i] == '\''  ||
                    rValue.rStringA.pszVal[i] == '=')
                {
                    fQuoted = TRUE;
                    break;
                }
            }
        }

        // Quoted
        if (fQuoted)
        {
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
            CHECKHR(hr = pStream->Write(rValue.rStringA.pszVal, rValue.rStringA.cchVal, NULL));
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }

        // Ohterwise, just write the data
        else
        {
            // Set pszValue
            LPSTR pszValue = rValue.rStringA.pszVal;
            ULONG cchValue = rValue.rStringA.cchVal;

            // Escape It
            if (MimeOleEscapeString(CP_ACP, pszValue, &pszEscape) == S_OK)
            {
                pszValue = pszEscape;
                cchValue = lstrlen(pszEscape);
            }

            // Write the property...
            CHECKHR(hr = pStream->Write(pszValue, cchValue, NULL));
        }

        // Count Props Wrote
        cWrote++;

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);

        // Cleanup
        MimeVariantFree(&rValue);
        SafeMemFree(pszEscape);
    }

    // Transmit
    if (ISFLAGSET(dwFlags, PDF_HEADERFORMAT))
    {
        // Final CRLF if Transmit Format
        CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
    }

    // If We Wrote Stuff
    if (cWrote)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            PROPSTRINGA rStringA;

            // Init
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Convert to variant
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(CP_ACP, &rStringA, &pValue->rStringW));
        }

        else
            Assert(MVT_STREAM == pValue->type);
    }

exit:
    // Cleanup
    MimeVariantFree(&rValue);
    SafeMemFree(pszEscape);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetMultiValueProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetMultiValueProperty(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;
    LPPROPERTY      pCurrProp;
    CByteStream     cByteStream;
    ULONG           cLines;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Variant Not Supported
    if (MVT_VARIANT == pValue->type)
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);
    if (MVT_STRINGW == pValue->type && ISFLAGSET(dwFlags, PDF_ENCODED))
        return TrapError(MIME_E_VARTYPE_NO_CONVERT);

    // Init
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // I will read it as a stream
    rValue.type = MVT_STREAM;

    // I need a stream to write to...
    if (MVT_STREAM == pValue->type)
    {
        // Validate the stream
        if (NULL == pValue->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        rValue.pStream = pValue->pStream;
    }

    // Otherwise, create my own stream
    else
        rValue.pStream = &cByteStream;

    // Count lines for rItem.hItem and mark iFirst and iLast
    for (cLines=0, pCurrProp=pProperty; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextValue, cLines++)
    {
        // Get the variant
        CHECKHR(hr = HrConvertVariant(pCurrProp, dwFlags | CVF_NOALLOC, &rValue));
        Assert(rValue.fCopy == FALSE);

        // Not Header Format, add CRLF
        if (FALSE == ISFLAGSET(dwFlags, PDF_HEADERFORMAT) && cLines > 0)
        {
            // CRLF
            CHECKHR(hr = rValue.pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));
        }
    }

    // More than 1 line
    if (cLines > 0)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pValue->type)
        {
            // pStream better be the byte stream
            Assert(rValue.pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&pValue->rStringA.cchVal, &pValue->rStringA.pszVal, ACQ_DISPLACE));
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pValue->type)
        {
            // Locals
            PROPSTRINGA rStringA;

            // ZeroMemory
            ZeroMemory(&rStringA, sizeof(PROPSTRINGA));

            // pStream better be the byte stream
            Assert(rValue.pStream == &cByteStream);

            // Get string from stream...
            CHECKHR(hr = cByteStream.HrAcquireStringA(&rStringA.cchVal, &rStringA.pszVal, ACQ_COPY));

            // Convert to Unicode
            CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(CP_ACP, &rStringA, &pValue->rStringW));

        }
        else
            Assert(MVT_STREAM == pValue->type);
    }

    // Otherwise, no data
    else
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrIsTriggerCaller
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrIsTriggerCaller(DWORD dwPropId, TRIGGERTYPE tyTrigger)
{
    // If there is 0 or 1 calls on the stack, there is no caller
    if (m_rTrigger.cCalls <= 1)
        return S_FALSE;

    // Readability
    LPTRIGGERCALL pCall = &m_rTrigger.rgStack[m_rTrigger.cCalls - 2];

    // Is the Previous entry on the stack equal to dwPropId tyTrigger
    return (dwPropId == pCall->pSymbol->dwPropId && tyTrigger == pCall->tyTrigger) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCallSymbolTrigger
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCallSymbolTrigger(LPPROPSYMBOL pSymbol, TRIGGERTYPE tyTrigger, DWORD dwFlags,
    LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    WORD        cCalls;

    // Validate Params
    Assert(pSymbol && ISTRIGGERED(pSymbol, tyTrigger));

    // Dispatch Stack Overflow - If this happens, there is a design problem
    Assert(m_rTrigger.cCalls + 1 < CTSTACKSIZE);

    // Note current number of calls
    cCalls = m_rTrigger.cCalls;

    // Put this call onto the stack
    m_rTrigger.rgStack[m_rTrigger.cCalls].pSymbol     = pSymbol;
    m_rTrigger.rgStack[m_rTrigger.cCalls].tyTrigger = tyTrigger;

    // Increment Call Stack Size
    m_rTrigger.cCalls++;

    // Property Dispatch
    hr = CALLTRIGGER(pSymbol, this, tyTrigger, dwFlags, pValue, NULL);

    // Increment Call Stack Size
    Assert(m_rTrigger.cCalls > 0);
    m_rTrigger.cCalls--;

    // Same Number of Calls in/out
    Assert(cCalls == m_rTrigger.cCalls);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetPropertyValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;

    // Delegate if MPF_ADDRESS
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Get Address Data
        CHECKHR(hr = _HrBuildAddressString(pProperty, dwFlags, pValue));
    }

    // Delegate if MPF_HASPARAMS
    else if (ISFLAGSET(dwFlags, PDF_ENCODED) && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Get Address Data
        CHECKHR(hr = _HrBuildParameterString(pProperty, dwFlags, pValue));
    }

    // Multivalue property
    else if (pProperty->pNextValue && ISFLAGSET(dwFlags, PDF_VECTOR))
    {
        // Translate pProperty->rVariant to pVariant
        CHECKHR(hr = _HrGetMultiValueProperty(pProperty, dwFlags, pValue));
    }

    // Otherwise, single value property
    else
    {
        // Translate pProperty->rVariant to pVariant
        CHECKHR(hr = HrConvertVariant(pProperty, dwFlags, pValue));
    }

    // Dispatch
    if (ISTRIGGERED(pProperty->pSymbol, IST_POSTGETPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pProperty->pSymbol, IST_POSTGETPROP, dwFlags, pValue));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags,
    DWORD dwState, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, BOOL *pfRfc1522 /* = NULL */)
{
    // Invalid Arg
    Assert(pProperty && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pProperty->pSymbol, pProperty->pCharset,
                                    pProperty->ietValue, dwFlags, dwState, pSource, pDest, pfRfc1522);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPERTY pProperty, DWORD dwFlags, LPMIMEVARIANT pDest)
{
    // Invalid Arg
    Assert(pProperty && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pProperty->pSymbol, pProperty->pCharset,
                        pProperty->ietValue, dwFlags, pProperty->dwState, &pProperty->rValue, pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrConvertVariant(LPPROPSYMBOL pSymbol, LPINETCSETINFO pCharset,
    ENCODINGTYPE ietSource, DWORD dwFlags, DWORD dwState, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, BOOL *pfRfc1522 /* = NULL */)

{
    // Locals
    LPPROPERTY      pProperty;

    // Invalid Args
    Assert(pSymbol && pSource && pDest);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Charset Passed In
    if (NULL == pCharset && SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
        pCharset = pProperty->pCharset;

    // HrConvertVariant
    HRESULT hr = ::HrConvertVariant(&m_rOptions, pSymbol, pCharset, ietSource, dwFlags, dwState, pSource, pDest, pfRfc1522);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetPropertyValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetPropertyValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue, BOOL fFromMovePropos)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPSTR           pszFree=NULL;

    // Adjust pValue if property can not be internationalized
    if (MVT_STRINGW == pValue->type && (!ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_INETCSET) || ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS)))
    {
        // Convert to ANSI
        CHECKHR(hr = g_pInternat->HrWideCharToMultiByte(CP_ACP, &pValue->rStringW, &rSource.rStringA));

        // Setup Source
        rSource.type = MVT_STRINGA;

        // Free This
        pszFree = rSource.rStringA.pszVal;

        // Change the Value
        pValue = &rSource;
    }

    // MPF_HASPARAMS
    if (ISFLAGSET(dwFlags, PDF_ENCODED) && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS) && !fFromMovePropos)
    {
        // Parse parameters into other properties
        CHECKHR(hr = _HrParseParameters(pProperty, dwFlags, pValue));
    }

    // Otherwise, just copy the data
    else
    {
        // Store the variant data
        CHECKHR(hr = _HrStoreVariantValue(pProperty, dwFlags, pValue));

        // If Encoded, check for rfc1522 character set
        if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_RFC1522) && ISFLAGSET(dwFlags, PDF_ENCODED) && MVT_STRINGA == pValue->type)
        {
            // Locals
            CHAR            szCharset[CCHMAX_CSET_NAME];
            LPINETCSETINFO  pCharset;

            // Scan for 1522 Encoding...
            if (SUCCEEDED(MimeOleRfc1522Decode(pValue->rStringA.pszVal, szCharset, sizeof(szCharset)-1, NULL)))
            {
                // Find the Charset
                if (SUCCEEDED(g_pInternat->HrOpenCharset(szCharset, &pCharset)))
                {
                    // Save Pointer to Charset
                    pProperty->pCharset = pCharset;
                }
            }
        }

        // MPF_ADDRESS
        if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Parse the address into the address group
            _FreeAddressChain(pProperty->pGroup);

            // Not Dirty
            pProperty->pGroup->fDirty = FALSE;

            // Reset the parsing flag
            FLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE);
        }
    }

    // Set some new state
    FLAGSET(pProperty->dwState, PRSTATE_HASDATA);

    // Dispatch
    if (ISTRIGGERED(pProperty->pSymbol, IST_POSTSETPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pProperty->pSymbol, IST_POSTSETPROP, dwFlags, &pProperty->rValue));
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseParameters(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cchName;
    CStringParser   cString;
    CHAR            chToken;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pParameter;

    // Invalid Arg
    Assert(pProperty && pValue && ISFLAGSET(dwFlags, PDF_ENCODED));

    // Define a Stack String to hold parameter names
    STACKSTRING_DEFINE(rName, 255);

    // Error
    if (!ISSTRINGA(pValue))
    {
        Assert(FALSE);
        hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
        goto exit;
    }

    // Init rValue
    rValue.type = MVT_STRINGA;

    // Lets delete currently linked parameters
    _DeleteLinkedParameters(pProperty);

    // Set the Members
    cString.Init(pValue->rStringA.pszVal, pValue->rStringA.cchVal, PSF_NOFRONTWS | PSF_NOTRAILWS | PSF_NOCOMMENTS);

    // Parse up to colon
    chToken = cString.ChParse(";");
    if (0 == cString.CchValue())
    {
        // Setup a variant
        rValue.rStringA.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_MIME_TEXT_PLAIN);

        // Store the variant data
        CHECKHR(hr = _HrStoreVariantValue(pProperty, PDF_ENCODED, &rValue));

        // Done
        goto exit;
    }

    // Setup a variant
    rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
    rValue.rStringA.cchVal = cString.CchValue();

    // Store the variant data
    CHECKHR(hr = _HrStoreVariantValue(pProperty, PDF_ENCODED, &rValue));

    // Done
    if (';' != chToken)
        goto exit;

    // Read all parameters
    while('\0' != chToken)
    {
        Assert(';' == chToken);
        // $$$ BUG $$$ - This fixes the bogus NDR messages returned from Netscape server.
        //               there message have a invalid Content-Type line:
        //               mulipart/alternative;; boundary="--=============12345678"
        //                                   ^^
        //               The double semi-colon is invalid, but I will handle it here since
        //               a parameter name can not begin with a semicolon.
        // Better be at a semicolon
        chToken = cString.ChSkip();
        if ('\0' == chToken)
            goto exit;

        // Parse parameter name
        chToken = cString.ChParse("=");
        if ('=' != chToken)
            goto exit;

        // Compute the length of the name
        cchName = pProperty->pSymbol->cchName + cString.CchValue() + 6;  // (YST) QFE bug

        // Grow the stack string to hold cchName
        STACKSTRING_SETSIZE(rName, cchName);

        // Make Parameter Name, set actual cchName
        cchName = wsprintf(rName.pszVal, "par:%s:%s", pProperty->pSymbol->pszName, cString.PszValue());

        // Parse parameter value
        chToken = cString.ChParse("\";");

        // Quoted ?
        if ('\"' == chToken)
        {
            // Locals
            CHAR    ch;
            DWORD   dwFlags = PSF_DBCS | PSF_ESCAPED;

            // Lookup the property symbol to see if it exist
            if (FAILED(g_pSymCache->HrOpenSymbol(rName.pszVal, FALSE, &pParameter)))
                pParameter = NULL;

            // For "par:content-disposition:filename" property assume no escaped chars
            if (pParameter && (pParameter->dwPropId == PID_PAR_FILENAME))
                dwFlags &= ~PSF_ESCAPED;

            // Raid-48365: FE-J:OExpress: JIS file name of attachment is not decoded correctly.
            while(1)
            {
                // Parse parameter value
                ch = cString.ChParse('\"', '\"', dwFlags);
                if ('\0' == ch)
                    break;

                // Not a international parameter
                if (pParameter && !ISFLAGSET(pParameter->dwFlags, MPF_INETCSET))
                    break;

                // Skip White Space
                ch = cString.ChSkipWhite();
                if ('\0' == ch || ';' == ch)
                    break;

                // Put a quote back into the string
                CHECKHR(hr = cString.HrAppendValue('\"'));

                // Add PSF_NORESET flag
                FLAGSET(dwFlags, PSF_NORESET);
            }

            // If no value, were done
            if (0 == cString.CchValue())
                goto exit;
        }

        else
            Assert(';' == chToken || '\0' == chToken);

        // Setup Value
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
        rValue.rStringA.cchVal = cString.CchValue();

        // Set the property
        CHECKHR(hr = SetProp(rName.pszVal, PDF_ENCODED, &rValue));

        // If last token was a '"', then seek to semicolon
        if ('\"' == chToken)
        {
            // Parse parameter value
            chToken = cString.ChParse(";");
        }
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInternetAddress
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInternetAddress(LPPROPERTY pProperty)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPMIMEADDRESS   pAddress;
    LPINETCSETINFO  pCharset=NULL;
    CAddressParser  cAdrParse;

    // Invalid Arg
    Assert(pProperty && pProperty->pSymbol && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_ADDRESS) && pProperty->pGroup);

    // Init
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));

    // If the property does not need PRSTATE_NEEDPARSE, return
    if (!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE))
        goto exit;

    // Setup rSource
    rSource.type = MVT_STRINGW;

    // Convert to multibyte
    CHECKHR(hr = HrConvertVariant(pProperty, CVF_NOALLOC, &rSource));

    // Figure out pCharset
    if (pProperty->pCharset)
        pCharset = pProperty->pCharset;
    else if (m_rOptions.pDefaultCharset)
        pCharset = m_rOptions.pDefaultCharset;
    else if (CIntlGlobals::GetDefHeadCset())
        pCharset = CIntlGlobals::GetDefHeadCset();

    // Initialize Parse Structure
    cAdrParse.Init(rSource.rStringW.pszVal, rSource.rStringW.cchVal);

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Append an Address
        CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

        // Set the Address Type
        pAddress->dwAdrType = pProperty->pSymbol->dwAdrType;

        // Store Friendly Name
        CHECKHR(hr = HrSetAddressTokenW(cAdrParse.PszFriendly(), cAdrParse.CchFriendly(), &pAddress->rFriendly));

        // Store Email
        CHECKHR(hr = HrSetAddressTokenW(cAdrParse.PszEmail(), cAdrParse.CchEmail(), &pAddress->rEmail));

        // Save the Address
        pAddress->pCharset = pCharset;
    }

    // No sync needed anymore
    FLAGCLEAR(pProperty->dwState, PRSTATE_NEEDPARSE);

exit:
    // Cleanup
    MimeVariantFree(&rSource);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrStoreVariantValue
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrStoreVariantValue(LPPROPERTY pProperty, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSource=0;
    LPBYTE          pbSource=NULL;
    LPBYTE         *ppbDest=NULL;
    ULONG          *pcbDest=NULL;
    LPBYTE          pbNewBlob;
    ULONG           cbNewBlob;

    // Invalid Arg
    Assert(pProperty && pValue);

    // Handle Data Type
    switch(pValue->type)
    {
    case MVT_STRINGA:
        // Invalid Arg
        if (ISVALIDSTRINGA(&pValue->rStringA) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set Byte Source
        pbSource = (LPBYTE)pValue->rStringA.pszVal;

        // Set Source Byte Count
        cbSource = pValue->rStringA.cchVal + 1;

        // Set Destination Byte Pointer
        ppbDest = (LPBYTE *)&(pProperty->rValue.rStringA.pszVal);

        // Save Length Now
        pProperty->rValue.rStringA.cchVal = pValue->rStringA.cchVal;
        break;

    case MVT_STRINGW:
        // Invalid Arg
        if (ISVALIDSTRINGW(&pValue->rStringW) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set Byte Source
        pbSource = (LPBYTE)pValue->rStringW.pszVal;

        // Set Source Byte Count
        cbSource = ((pValue->rStringW.cchVal + 1) * sizeof(WCHAR));

        // Set Destination Byte Pointer
        ppbDest = (LPBYTE *)&(pProperty->rValue.rStringW.pszVal);

        // Save Length Now
        pProperty->rValue.rStringW.cchVal = pValue->rStringW.cchVal;
        break;

    case MVT_VARIANT:
        pProperty->rValue.rVariant.vt = pValue->rVariant.vt;
        switch(pValue->rVariant.vt)
        {
        case VT_FILETIME:
            CopyMemory(&pProperty->rValue.rVariant.filetime, &pValue->rVariant.filetime, sizeof(FILETIME));
            pbSource = (LPBYTE)&pValue->rVariant.filetime;
            cbSource = sizeof(pValue->rVariant.filetime);
            break;

        case VT_I4:
            pProperty->rValue.rVariant.lVal = pValue->rVariant.lVal;
            pbSource = (LPBYTE)&pValue->rVariant.lVal;
            cbSource = sizeof(pValue->rVariant.lVal);
            break;

        case VT_UI4:
            pProperty->rValue.rVariant.ulVal = pValue->rVariant.ulVal;
            pbSource = (LPBYTE)&pValue->rVariant.ulVal;
            cbSource = sizeof(pValue->rVariant.ulVal);
            break;

        default:
            Assert(FALSE);
            hr = TrapError(MIME_E_INVALID_VARTYPE);
            goto exit;
        }
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Better have a source
    Assert(cbSource && cbSource);

    // Store the data
    if (cbSource > pProperty->cbAlloc)
    {
        // Fits into static buffer ?
        if (cbSource <= sizeof(pProperty->rgbScratch))
        {
            // If not reallocing...
            if (ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED))
            {
                Assert(pProperty->pbBlob);
                g_pMalloc->Free(pProperty->pbBlob);
                FLAGCLEAR(pProperty->dwState, PRSTATE_ALLOCATED);
            }

            // Use Scratch Buffer
            pProperty->pbBlob = pProperty->rgbScratch;
            pProperty->cbAlloc = sizeof(pProperty->rgbScratch);
        }

        // Was my current buffer allocated
        else
        {
            // If not reallocing...
            if (!ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED))
            {
                pProperty->pbBlob = NULL;
                pProperty->cbAlloc = 0;
            }
            else
                Assert(pProperty->cbAlloc > sizeof(pProperty->rgbScratch) && g_pMalloc->DidAlloc(pProperty->pbBlob) == 1);

            // Compute Size of new blob
            cbNewBlob = pProperty->cbAlloc + (cbSource - pProperty->cbAlloc);

            // Realloc New Blob
            CHECKALLOC(pbNewBlob = (LPBYTE)g_pMalloc->Realloc((LPVOID)pProperty->pbBlob, cbNewBlob));

            // We've allocated it
            FLAGSET(pProperty->dwState, PRSTATE_ALLOCATED);

            // Assume the new blob
            pProperty->pbBlob = pbNewBlob;
            pProperty->cbAlloc = cbNewBlob;
        }
    }

    // Copy the data
    CopyMemory(pProperty->pbBlob, pbSource, cbSource);

    // Set Size of Data in m_pbBlob
    pProperty->cbBlob = cbSource;

    // If there is a ppbDest assign to it
    if (ppbDest)
        *ppbDest = pProperty->pbBlob;

    // Save Encoding Type
    pProperty->ietValue = (ISFLAGSET(dwFlags, PDF_ENCODED)) ? IET_ENCODED : IET_DECODED;

    // PRSTATE_SAVENOENCODE
    if (ISFLAGSET(dwFlags, PDF_SAVENOENCODE))
        FLAGSET(pProperty->dwState, PRSTATE_SAVENOENCODE);

    // Save Type
    pProperty->rValue.type = pValue->type;

exit:
    // Failure
    if (FAILED(hr))
        ZeroMemory(&pProperty->rValue, sizeof(MIMEVARIANT));

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPCSTR pszName, LPSTR *ppszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName && ppszData);

    // Init
    *ppszData = NULL;

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Init the variant
    rValue.type = MVT_STRINGA;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringA.pszVal);
    *ppszData = rValue.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPPROPSYMBOL pSymbol, LPSTR *ppszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && ppszData);

    // Init
    *ppszData = NULL;

    // Init the variant
    rValue.type = MVT_STRINGA;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringA.pszVal);
    *ppszData = rValue.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetPropW
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetPropW(LPPROPSYMBOL pSymbol, LPWSTR *ppwszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && ppwszData);

    // Init
    *ppwszData = NULL;

    // Init the variant
    rValue.type = MVT_STRINGW;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, 0, &rValue));

    // Set the string
    Assert(rValue.rStringW.pszVal);
    *ppwszData = rValue.rStringW.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invaid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Symbol Better have a supported variant type
    Assert(ISSUPPORTEDVT(pSymbol->vtDefault));

    // Set rValue Variant
    if (VT_EMPTY == pVariant->vt)
        rValue.rVariant.vt = pVariant->vt = pSymbol->vtDefault;
    else
        rValue.rVariant.vt = pVariant->vt;

    // Map to MIMEVARIANT
    if (VT_LPSTR == pVariant->vt || VT_EMPTY == pVariant->vt)
        rValue.type = MVT_STRINGA;
    else if (VT_LPWSTR == pVariant->vt)
        rValue.type = MVT_STRINGW;
    else
        rValue.type = MVT_VARIANT;

    // Get Property by Symbol
    CHECKHR(hr = GetProp(pSymbol, dwFlags, &rValue));

    // Map to PROPVARIANT
    if (MVT_STRINGA == rValue.type)
        pVariant->pszVal = rValue.rStringA.pszVal;
    else if (MVT_STRINGW == rValue.type)
        pVariant->pwszVal = rValue.rStringW.pszVal;
    else
        CopyMemory(pVariant, &rValue.rVariant, sizeof(PROPVARIANT));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the property
    hr = _HrFindProperty(pSymbol, &pProperty);

    // Failure
    if (FAILED(hr))
    {
        // See if there is a default value for this property
        if (MIME_E_NOT_FOUND != hr)
        {
            hr = TrapError(hr);
            goto exit;
        }

        // Dispatch Default Request, otherwise, hr is still equal to MIME_E_NOT_FOUND....
        if (ISTRIGGERED(pSymbol, IST_GETDEFAULT))
        {
            // Property Dispatch
            CHECKHR(hr = _HrCallSymbolTrigger(pSymbol, IST_GETDEFAULT, dwFlags, pValue));
        }
    }

    // Otherwise, get the property data
    else
    {
        // Raid-62460: Dependency Hack to make sure the GetProp works the same when getting addresses
        // PDF_VECTOR is always supported by _HrBuildAddressString, which gets called by _HrGetPropertyValue
        if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
            FLAGSET(dwFlags, PDF_VECTOR);

        // Get the property value
        CHECKHR(hr = _HrGetPropertyValue(pProperty, dwFlags, pValue));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName && pValue);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, dwFlags, pValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, LPCSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pszName && pszData);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // Init the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszData;
    rValue.rStringA.cchVal = lstrlen(pszData);

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, 0, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPPROPSYMBOL pSymbol, LPCSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rValue;

    // Invalid Arg
    Assert(pSymbol && pszData);

    // Init the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszData;
    rValue.rStringA.cchVal = lstrlen(pszData);

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, 0, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // MVT_STRINGW
    if (VT_LPSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Setup rValue
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = pVariant->pszVal;
        rValue.rStringA.cchVal = lstrlen(pVariant->pszVal);
    }

    // MVT_STRINGW
    else if (VT_LPWSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pwszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGW;
        rValue.rStringW.pszVal = pVariant->pwszVal;
        rValue.rStringW.cchVal = lstrlenW(pVariant->pwszVal);
    }

    // MVT_VARIANT
    else
    {
        rValue.type = MVT_VARIANT;
        CopyMemory(&rValue.rVariant, pVariant, sizeof(PROPVARIANT));
    }

    // Get Property by Symbol
    CHECKHR(hr = SetProp(pSymbol, dwFlags, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPCMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty=NULL;

    // Invalid Arg
    Assert(pSymbol && pValue);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read-Only
    if (ISFLAGSET(pSymbol->dwFlags, MPF_READONLY))
    {
        AssertSz(FALSE, "This property has the MPF_READONLY flag.");
        hr = TrapError(MIME_E_READ_ONLY);
        goto exit;
    }

    // Find the property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        // Create it
        CHECKHR(hr = _HrCreateProperty(pSymbol, &pProperty));
    }

    // This better be a root property
    Assert(ISFLAGSET(pProperty->dwState, PRSTATE_PARENT));

    // Remove multi-values
    if (pProperty->pNextValue)
    {
        // Free the chain
        _FreePropertyChain(pProperty->pNextValue);

        // No more pNextValue or pTailValue
        pProperty->pNextValue = pProperty->pTailValue = NULL;
    }

    // Store the data
    CHECKHR(hr = _HrSetPropertyValue(pProperty, dwFlags, pValue, FALSE));

    // Dirty
    if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
        FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Failure
    if (FAILED(hr) && pProperty)
    {
        // Delete the Property
        _UnlinkProperty(pProperty);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    MIMEVARIANT     rValue;

    // Invalid Arg
    if (NULL == pszName || NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, TRUE, &pSymbol));

    // MVT_STRINGW
    if (VT_LPSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = pVariant->pszVal;
        rValue.rStringA.cchVal = lstrlen(pVariant->pszVal);
    }

    // MVT_STRINGW
    else if (VT_LPWSTR == pVariant->vt)
    {
        // Invalid Arg
        if (NULL == pVariant->pwszVal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Fill rValue
        rValue.type = MVT_STRINGW;
        rValue.rStringW.pszVal = pVariant->pwszVal;
        rValue.rStringW.cchVal = lstrlenW(pVariant->pwszVal);
    }

    // MVT_VARIANT
    else
    {
        rValue.type = MVT_VARIANT;
        CopyMemory(&rValue.rVariant, pVariant, sizeof(PROPVARIANT));
    }

    // Get Property by Symbol
    CHECKHR(hr = AppendProp(pSymbol, dwFlags, &rValue));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::AppendProp(LPPROPSYMBOL pSymbol, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty=NULL;
    BOOL        fAppended=FALSE;

    // Invalid Arg
    Assert(pSymbol && pValue);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read-Only
    if (ISFLAGSET(pSymbol->dwFlags, MPF_READONLY))
    {
        AssertSz(FALSE, "This property has the MPF_READONLY flag.");
        hr = TrapError(MIME_E_READ_ONLY);
        goto exit;
    }

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        // If not found... treat as basic set prop...
        CHECKHR(hr = SetProp(pSymbol, dwFlags, pValue));
    }

    // Otherwise, of not multiline, fail
    else
    {
        // Its appended
        fAppended = TRUE;

        // Append a property
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Store the data
        CHECKHR(hr = _HrSetPropertyValue(pProperty, dwFlags, pValue, FALSE));

        // I am now dirty
        if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
            FLAGSET(m_dwState, COSTATE_DIRTY);
    }

exit:
    // Failure
    if (FAILED(hr) && pProperty && fAppended)
    {
        // Delete the Property
        _UnlinkProperty(pProperty);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_UnlinkProperty
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_UnlinkProperty(LPPROPERTY pProperty, LPPROPERTY *ppNextHash)
{
    // Locals
    LPPROPERTY  pCurrHash;
    LPPROPERTY  pNextHash;
    LPPROPERTY  pPrevHash=NULL;
#ifdef DEBUG
    BOOL        fUnlinked=FALSE;
#endif

    // Invalid Arg
    Assert(pProperty && pProperty->pSymbol && ISFLAGSET(pProperty->dwState, PRSTATE_PARENT) && pProperty->pSymbol->wHashIndex < CBUCKETS);

    // Remove from array
    if (ISKNOWNPID(pProperty->pSymbol->dwPropId))
        m_prgIndex[pProperty->pSymbol->dwPropId] = NULL;

    // Include Parameters
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
        _DeleteLinkedParameters(pProperty);

    // Remove Property from the hash table
    for (pCurrHash=m_prgHashTable[pProperty->pSymbol->wHashIndex]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
    {
        // Is this pProp
        if (pCurrHash == pProperty)
        {
            // NextHash
            pNextHash = pCurrHash->pNextHash;

            // Set Previous
            if (pPrevHash)
                pPrevHash->pNextHash = pNextHash;
            else
                m_prgHashTable[pProperty->pSymbol->wHashIndex] = pNextHash;

            // Free pCurrHash
            _FreePropertyChain(pCurrHash);

            // Set this after I set pCurr in case *ppNextHash is &pProperty
            if (ppNextHash)
                *ppNextHash = pNextHash;

            // One less property
            m_cProps--;

#ifdef DEBUG
            fUnlinked = TRUE;
#endif
            // Done
            break;
        }

        // Set Previous
        pPrevHash = pCurrHash;
    }

    // We better have found it
    Assert(fUnlinked);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteProp(LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Delete by symbol
    CHECKHR(hr = DeleteProp(pSymbol));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteProp(LPPROPSYMBOL pSymbol)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    Assert(pSymbol);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the property
    CHECKHR(hr = _HrFindProperty(pSymbol, &pProperty));

    // Delete Prop
    _UnlinkProperty(pProperty);

    // Cascade Delete Dispatch
    if (ISTRIGGERED(pSymbol, IST_DELETEPROP))
    {
        // Property Dispatch
        CHECKHR(hr = _HrCallSymbolTrigger(pSymbol, IST_DELETEPROP, 0, NULL));
    }

    // Dirty
    if (!ISFLAGSET(pSymbol->dwFlags, MPF_NODIRTY))
        FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_DeleteLinkedParameters
// --------------------------------------------------------------------------------
void CMimePropertyContainer::_DeleteLinkedParameters(LPPROPERTY pProperty)
{
    // Locals
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;

    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Raid-13506 - Basically PID_ATT_FILENAME doesn't get removed when all other associated props are gone.
        if (ISTRIGGERED(pParameter->pSymbol, IST_DELETEPROP))
        {
            // Call the Trigger
            _HrCallSymbolTrigger(pParameter->pSymbol, IST_DELETEPROP, 0, NULL);
        }

        // Remove the parameter
        _UnlinkProperty(pParameter, &rFind.pProperty);

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_FExcept
// --------------------------------------------------------------------------------
BOOL CMimePropertyContainer::_FExcept(LPPROPSYMBOL pSymbol, ULONG cNames, LPCSTR *prgszName)
{
    // Verify the array
    for (ULONG i=0; i<cNames; i++)
    {
        // By PID
        if (ISPIDSTR(prgszName[i]))
        {
            // Compare by id
            if (pSymbol->dwPropId == STRTOPID(prgszName[i]))
                return TRUE;

            // Else if pSymbol is linked to prgszName[i]
            else if (pSymbol->pLink && pSymbol->pLink->dwPropId == STRTOPID(prgszName[i]))
                return TRUE;
        }

        // Otherwise, by name
        else
        {
            // Compare by name
            if (lstrcmpi(pSymbol->pszName, prgszName[i]) == 0)
                return TRUE;

            // Otherwise if pSymbol is linked to prgszName[i]
            else if (pSymbol->pLink && lstrcmpi(pSymbol->pLink->pszName, prgszName[i]) == 0)
                return TRUE;
        }
    }

    // Not Except
    return FALSE;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteExcept
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::DeleteExcept(ULONG cNames, LPCSTR *prgszName)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;
    ULONG       i;

    // Invalid Arg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Delete Everything
    if (0 == cNames)
    {
        // Free the PropTable
        _FreeHashTableElements();
    }

    // Otherwise
    else
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Walk through the chain...
            pProperty = m_prgHashTable[i];
            while(pProperty)
            {
                // Loop through the tags
                if (!_FExcept(pProperty->pSymbol, cNames, prgszName))
                    _UnlinkProperty(pProperty, &pProperty);
                else
                    pProperty = pProperty->pNextHash;
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Arg
    Assert(pszName);

    // Open Property Symbol
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Get Property by Symbol
    CHECKHR(hr = QueryProp(pSymbol, pszCriteria, fSubString, fCaseSensitive));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::QueryProp
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::QueryProp(LPPROPSYMBOL pSymbol, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pProperty,
                    pCurrProp;
    LPCSTR          pszSearch;
    MIMEVARIANT     rValue;

    // Parameters
    if (NULL == pSymbol || NULL == pszCriteria)
        return TrapError(E_INVALIDARG);

    // Init
    STACKSTRING_DEFINE(rCritLower, 255);
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));

    // Init pszsearch
    pszSearch = pszCriteria;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find the Property
    if (FAILED(_HrFindProperty(pSymbol, &pProperty)))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Need Lower Case...?
    if (TRUE == fSubString && FALSE == fCaseSensitive)
    {
        // Get Length
        ULONG cchCriteria = lstrlen(pszCriteria);

        // Get the length of pszCritieria
        STACKSTRING_SETSIZE(rCritLower, cchCriteria + 1);

        // Copy It
        CopyMemory(rCritLower.pszVal, pszCriteria, cchCriteria + 1);

        // Lower Case...
        CharLower(rCritLower.pszVal);

        // Set Search
        pszSearch = rCritLower.pszVal;
    }

    // Walk multiline properties...
    for (pCurrProp=pProperty; pCurrProp!=NULL; pCurrProp=pCurrProp->pNextValue)
    {
        // Better have the same symbol
        Assert(pCurrProp->pSymbol == pSymbol);

        // If Address...
        if (ISFLAGSET(pCurrProp->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Better have an address group
            Assert(pCurrProp->pGroup);

            // Search the address group
            if (_HrQueryAddressGroup(pCurrProp, pszSearch, fSubString, fCaseSensitive) == S_OK)
                goto exit;
        }

        // Otherwise
        else
        {
            // Convert to a MVT_STRINGA
            rValue.type = MVT_STRINGA;

            // Convert to string
            CHECKHR(hr = HrConvertVariant(pCurrProp, CVF_NOALLOC, &rValue));

            // Query String
            if (MimeOleQueryString(rValue.rStringA.pszVal, pszSearch, fSubString, fCaseSensitive) == S_OK)
                goto exit;

            // Cleanup
            MimeVariantFree(&rValue);
        }
    }

    // Not Equal
    hr = S_FALSE;

exit:
    // Cleanup
    STACKSTRING_FREE(rCritLower);
    MimeVariantFree(&rValue);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetCharset
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetCharset(LPHCHARSET phCharset)
{
    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Charset...
    Assert(m_rOptions.pDefaultCharset);

    // Return
    *phCharset = m_rOptions.pDefaultCharset->hCharset;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetCharset
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;
    LPCODEPAGEINFO  pCodePage;
    MIMEVARIANT     rValue;
    LPINETCSETINFO  pCset;
    LPPROPERTY      pProperty;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IE v. 5.0 37562 multiple charsets are ignored on inbound message
    // if we are already tagged and called with CSET_APPLY_UNTAGGED then don't overwrite
    // the existing charset.
    if(CSET_APPLY_UNTAGGED == applytype && ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        goto exit;

    // Lookiup Charset Info
    CHECKHR(hr = g_pInternat->HrOpenCharset(hCharset, &pCharset));

#ifdef OLD // See attachemnt to bug 40626

    // RAID-22767 - FE-H : Athena Mail: Header should be encoded to the "EUC-KR" for the Korean
    if (SUCCEEDED(g_pInternat->HrFindCodePage(pCharset->cpiInternet, &pCodePage)) && pCodePage->dwMask & ILM_HEADERCSET)
    {
        // Map New Charset...
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pCodePage->szHeaderCset, &pCset)))
        {

            // Example: When hCharset == ISO-2022-KR, we map to EUC-KR == hHeaderCset, and we use that as
            //          the header of the message, but we set param charset=iso-2022-kr and encode the body
            //          using iso-2022-kr. This is why rCsetInfo contains iso-2022-kr and not euc-kr.
            pCharset = pCset;
        }
    }
#else // !OLD
    // We always use now WebCharSet (see attachment message to bug 40626
    if (SUCCEEDED(g_pInternat->HrFindCodePage(pCharset->cpiInternet, &pCodePage)) && pCodePage->dwMask & ILM_WEBCSET)
    {
        // Map New Charset...
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pCodePage->szWebCset, &pCset)))
            pCharset = pCset;
    }
#endif // OLD

    // Setup a variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = pCharset->szName;
    rValue.rStringA.cchVal = lstrlen(pCharset->szName);

    // Set the Charset Attribute
    SideAssert(SUCCEEDED(SetProp(SYM_PAR_CHARSET, 0, &rValue)));

    // Return
    m_rOptions.pDefaultCharset = pCharset;

    // Remove any specific charset information on each property
    if (CSET_APPLY_ALL == applytype && m_cProps > 0)
    {
        // Locals
        LPPROPERTY      pCurrHash;
        LPPROPERTY      pCurrValue;

        // Loop through the item table
        for (ULONG i=0; i<CBUCKETS; i++)
        {
            // Walk the hash list
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Walk the multi-value chain
                for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
                {
                    // This will force it to use the default
                    pCurrValue->pCharset = NULL;
                }
            }
        }
    }

    // Raid-38725: FE: Selecting EUC does not immediately change the encoding of sender name in preview pane
    //
    // $$HACKHACK$$ - This block of code is a hack because it only works if an address group has been parsed
    //                and not modified. Only in this case, will the new charset be applied to the addresses.
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // If the property has been parsed into addresses
        if (!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE))
        {
            // We should have an address group
            Assert(pProperty->pGroup);

            // If we have an address group and its dirty
            if (pProperty->pGroup && FALSE == pProperty->pGroup->fDirty)
            {
                // Free the curent list of parsed addresses
                _FreeAddressChain(pProperty->pGroup);

                // Not Dirty
                pProperty->pGroup->fDirty = FALSE;

                // Reset the parsing flag
                FLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE);
            }
        }
    }

    // Tag It ?
    if (CSET_APPLY_TAG_ALL == applytype)
    {
        // Mark as being tagged
        FLAGSET(m_dwState, COSTATE_CSETTAGGED);
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    FINDPROPERTY    rFind;
    LPMIMEPARAMINFO prgParam=NULL;
    ULONG           cParams=0,
                    cAlloc=0;
    LPSTR           pszParamName;
    LPPROPERTY      pParameter;
    MIMEVARIANT     rValue;
    LPPROPSYMBOL    pSymbol;

    // Parameters
    if (NULL == pszName || NULL == pcParams || NULL == pprgParam)
        return TrapError(E_INVALIDARG);

    // Init
    *pcParams = 0;
    *pprgParam = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find Symbol from pszName
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pSymbol->pszName;
    rFind.cchName = pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Grow my array
        if (cParams + 1 >= cAlloc)
        {
            // Realloc
            CHECKHR(hr = HrRealloc((LPVOID *)&prgParam, sizeof(MIMEPARAMINFO) * (cAlloc + 5)));

            // Inc cAlloc
            cAlloc+=5;
        }

        // Get Parameter Name
        pszParamName = PszScanToCharA((LPSTR)pParameter->pSymbol->pszName, ':');
        pszParamName++;
        pszParamName = PszScanToCharA(pszParamName, ':');
        pszParamName++;

        // Copy Name
        CHECKALLOC(prgParam[cParams].pszName = PszDupA(pszParamName));

        // Copy Data
        rValue.type = MVT_STRINGA;
        CHECKHR(hr = GetProp(pParameter->pSymbol, 0, &rValue));

        // Save this
        prgParam[cParams].pszData = rValue.rStringA.pszVal;

        // Increment cParams
        cParams++;

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

    // Return it
    *pcParams = cParams;
    *pprgParam = prgParam;

exit:
    // Failure...
    if (FAILED(hr) && prgParam)
        g_pMoleAlloc->FreeParamInfoArray(cParams, prgParam, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#ifndef WIN16

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrResolveURL
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrResolveURL(LPRESOLVEURLINFO pURL)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszTemp=NULL;
    LPSTR           pszBase=NULL;
    LPSTR           pszContentID=NULL;
    LPSTR           pszLocation=NULL;
    LPSTR           pszAbsURL1=NULL;
    LPSTR           pszAbsURL2=NULL;
    LPSTR           pszT=NULL;
    ULONG           cch;

    // Invalid Arg
    Assert(pURL);

    // Init Stack Strings
    STACKSTRING_DEFINE(rCleanCID, 255);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Content-Location
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTLOC, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszLocation, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszLocation, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Content-ID
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTID, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszContentID, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszContentID, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Content-Base
    if(SUCCEEDED(GetPropW(SYM_HDR_CNTBASE, &pwszTemp)))
    {
        cch = lstrlenW(pwszTemp) + 1;

        if(SUCCEEDED(HrAlloc((LPVOID *)&pszBase, cch * sizeof(WCHAR))))
            WideCharToMultiByte(CP_ACP, 0, pwszTemp, -1, pszBase, cch * sizeof(WCHAR), NULL, NULL);
        
        MemFree(pwszTemp);
    }

    // Both Null, no match
    if (!pszLocation && !pszContentID)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // If URL is a CID
    if (TRUE == pURL->fIsCID)
    {
        // Locals
        ULONG cb;
        
        if(pszLocation)
        {
            // Match char for char
            if (MimeOleCompareUrl(pszLocation, TRUE, pURL->pszURL, FALSE) == S_OK)
                goto exit;            
        }

        if(pszContentID)
        {
            // Match char for char minus cid:
            if (MimeOleCompareUrlSimple(pURL->pszURL, pszContentID) == S_OK)
                goto exit;

            // Dup the string
            CHECKALLOC(pszT = PszDupA(pURL->pszURL));

            // Strip leading and trailing whitespace
            cb = lstrlen(pszT);
            UlStripWhitespace(pszT, TRUE, TRUE, &cb);

            // Get Stack Stream Read for
            STACKSTRING_SETSIZE(rCleanCID, cb + 4);

            // Format the string
            wsprintf(rCleanCID.pszVal, "<%s>", pszT);

            // Match char for char minus cid:
            if (MimeOleCompareUrlSimple(rCleanCID.pszVal, pszContentID) == S_OK)
                goto exit;
        }
    }

    // Otherwise, non-CID resolution
    else if (pszLocation)
    {
        // Raid-62579: Athena: Need to support MHTML content-base inheritance
        if (NULL == pszBase && pURL->pszInheritBase)
        {
            // Jimmy up a fake base
            pszBase = StrDupA(pURL->pszInheritBase);
        }

        // Part Has Base
        if (NULL != pszBase)
        {
            // Combine URLs
            CHECKHR(hr = MimeOleCombineURL(pszBase, lstrlen(pszBase), pszLocation, lstrlen(pszLocation), TRUE, &pszAbsURL1));

            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrlSimple(pURL->pszURL, pszAbsURL1) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrlSimple(pszAbsURL1, pszAbsURL2) == S_OK)
                    goto exit;
            }
        }

        // Part has no base
        else
        {
            // URI has no base
            if (NULL == pURL->pszBase)
            {
                // Compare
                if (MimeOleCompareUrl(pszLocation, TRUE, pURL->pszURL, FALSE) == S_OK)
                    goto exit;
            }

            // URI Has a Base
            else
            {
                // Combine URLs
                CHECKHR(hr = MimeOleCombineURL(pURL->pszBase, lstrlen(pURL->pszBase), pURL->pszURL, lstrlen(pURL->pszURL), FALSE, &pszAbsURL2));

                // Compare
                if (MimeOleCompareUrl(pszLocation, TRUE, pszAbsURL2, FALSE) == S_OK)
                    goto exit;
            }
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Cleanup
    STACKSTRING_FREE(rCleanCID);
    MemFree(pszBase);
    MemFree(pszContentID);
    MemFree(pszLocation);
    MemFree(pszAbsURL1);
    MemFree(pszAbsURL2);
    MemFree(pszT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentType
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT hr=S_OK;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && lstrcmpi(pszPriType, STR_CNT_TEXT) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Comparing pszPriType
        if (pszPriType && lstrcmpi(pszPriType, pCntType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Comparing pszSubType
        if (pszSubType && lstrcmpi(pszSubType, pSubType->rValue.rStringA.pszVal) != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::IsContentTypeW
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::IsContentTypeW(LPCWSTR pszPriType, LPCWSTR pszSubType)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszT1=NULL;
    LPWSTR      pszT2=NULL;

    // Wildcard everyting
    if (NULL == pszPriType && NULL == pszSubType)
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Known
    LPPROPERTY pCntType = m_prgIndex[PID_ATT_PRITYPE];
    LPPROPERTY pSubType = m_prgIndex[PID_ATT_SUBTYPE];

    // No Data
    if (NULL == pCntType || NULL == pSubType || !ISSTRINGA(&pCntType->rValue) || !ISSTRINGA(&pSubType->rValue))
    {
        // Compare Against STR_CNT_TEXT
        if (pszPriType && StrCmpIW(pszPriType, L"text") != 0)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Compare Against STR_CNT_TEXT
        if (pszSubType && StrCmpIW(pszSubType, L"plain") != 0)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    else
    {
        // Compare pszPriType
        if (pszPriType)
        {
            // To Unicode
            IF_NULLEXIT(pszT1 = PszToUnicode(CP_ACP, pCntType->rValue.rStringA.pszVal));

            // Compare
            if (StrCmpIW(pszPriType, pszT1) != 0)
            {
                hr = S_FALSE;
                goto exit;
            }
        }

        // Compare pszSubType
        if (pszSubType)
        {
            // To Unicode
            IF_NULLEXIT(pszT2 = PszToUnicode(CP_ACP, pSubType->rValue.rStringA.pszVal));

            // Comparing pszSubType
            if (StrCmpIW(pszSubType, pszT2) != 0)
            {
                hr = S_FALSE;
                goto exit;
            }
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    MemFree(pszT1);
    MemFree(pszT2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimePropertySet, (LPVOID *)ppPropertySet));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::Clone(LPCONTAINER *ppContainer)
{
    // Locals
    HRESULT             hr=S_OK;
    LPCONTAINER         pContainer=NULL;

    // Invalid ARg
    if (NULL == ppContainer)
        return TrapError(E_INVALIDARG);

    // Init
    *ppContainer = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Create new container, NULL == no outer property set
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init that new container
    CHECKHR(hr = pContainer->InitNew());

    // Interate the Properties
    CHECKHR(hr = _HrClonePropertiesTo(pContainer));

    // If I have a stream, give it to the new table
    if (m_pStmLock)
    {
        // Just pass m_pStmLock into pTable
        pContainer->m_pStmLock = m_pStmLock;
        pContainer->m_pStmLock->AddRef();
        pContainer->m_cbStart = m_cbStart;
        pContainer->m_cbSize = m_cbSize;
    }

    // Give it my state
    pContainer->m_dwState = m_dwState;

    // Give it my options
    pContainer->m_rOptions.pDefaultCharset = m_rOptions.pDefaultCharset;
    pContainer->m_rOptions.cbMaxLine = m_rOptions.cbMaxLine;
    pContainer->m_rOptions.fAllow8bit = m_rOptions.fAllow8bit;

    // Return Clone
    (*ppContainer) = pContainer;
    (*ppContainer)->AddRef();

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrClonePropertiesTo
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrClonePropertiesTo(LPCONTAINER pContainer)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pCurrHash, pCurrValue, pDestProp;

    // Invalid Arg
    Assert(pContainer);

    // Loop through the item table
    for (ULONG i=0; i<CBUCKETS; i++)
    {
        // Walk the Hash Chain
        for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
        {
            // Walk multiple Values
            for (pCurrValue=pCurrHash; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
            {
                // Linked Attributes are Not Copied
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ATTRIBUTE) && NULL != pCurrValue->pSymbol->pLink)
                    continue;

                // Does the Property need to be parsed ?
                if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
                {
                    // Make sure the address is parsed
                    CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
                }

                // Insert Copy of pCurrValue into pContiner
                CHECKHR(hr = pContainer->HrInsertCopy(pCurrValue, FALSE));
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyProperty
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyProperty(LPPROPERTY pProperty, LPCONTAINER pDest, BOOL fFromMovePropos)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pCurrValue;

    // Walk multiple Values
    for (pCurrValue=pProperty; pCurrValue!=NULL; pCurrValue=pCurrValue->pNextValue)
    {
        // Does the Property need to be parsed ?
        if (ISFLAGSET(pCurrValue->pSymbol->dwFlags, MPF_ADDRESS))
        {
            // Make sure the address is parsed
            CHECKHR(hr = _HrParseInternetAddress(pCurrValue));
        }

        // Insert pProperty into pDest
        CHECKHR(hr = pDest->HrInsertCopy(pCurrValue, fFromMovePropos));
    }

    // If pCurrHash has Parameters, copy those over as well
    if (ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS))
    {
        // Copy Parameters
        CHECKHR(hr = _HrCopyParameters(pProperty, pDest));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrCopyParameters
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrCopyParameters(LPPROPERTY pProperty, LPCONTAINER pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrFind;
    FINDPROPERTY    rFind;
    LPPROPERTY      pParameter;

    // Invalid Arg
    Assert(pProperty && ISFLAGSET(pProperty->pSymbol->dwFlags, MPF_HASPARAMS));

    // Initialize rFind
    ZeroMemory(&rFind, sizeof(FINDPROPERTY));
    rFind.pszPrefix = "par:";
    rFind.cchPrefix = 4;
    rFind.pszName = pProperty->pSymbol->pszName;
    rFind.cchName = pProperty->pSymbol->cchName;

    // Find First..
    hrFind = _HrFindFirstProperty(&rFind, &pParameter);

    // While we find them, delete them
    while (SUCCEEDED(hrFind) && pParameter)
    {
        // Remove the parameter
        CHECKHR(hr = pDest->HrInsertCopy(pParameter, FALSE));

        // Find Next
        hrFind = _HrFindNextProperty(&rFind, &pParameter);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrInsertCopy
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::HrInsertCopy(LPPROPERTY pSource, BOOL fFromMovePropos)
{
    // Locals
    HRESULT           hr=S_OK;
    LPPROPERTY        pDest;
    LPMIMEADDRESS    pAddress;
    LPMIMEADDRESS    pNew;

    // Invalid Arg
    Assert(pSource);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Append a new property to the
    CHECKHR(hr = _HrAppendProperty(pSource->pSymbol, &pDest));

    // If this is an address...
    if (ISFLAGSET(pSource->pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Both Address Group Better Exist
        Assert(pSource->pGroup && pDest->pGroup && !ISFLAGSET(pSource->dwState, PRSTATE_NEEDPARSE));

        // Loop Infos...
        for (pAddress=pSource->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Append pDest->pGroup
            CHECKHR(hr = _HrAppendAddressGroup(pDest->pGroup, &pNew));

            // Copy Current to New
            CHECKHR(hr = HrMimeAddressCopy(pAddress, pNew));
        }
    }

    // Otheriwse, just set the variant data on pDest
    else
    {
        // Set It
        CHECKHR(hr = _HrSetPropertyValue(pDest, ((pSource->ietValue == IET_ENCODED) ? PDF_ENCODED : 0), &pSource->rValue, fFromMovePropos));
    }

    // Copy the State
    pDest->dwState = pSource->dwState;
    pDest->dwRowNumber = pSource->dwRowNumber;
    pDest->cboffStart = pSource->cboffStart;
    pDest->cboffColon = pSource->cboffColon;
    pDest->cboffEnd = pSource->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CopyProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty,
                    pCurrValue,
                    pCurrHash,
                    pNextHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Raid-62016: CDO: Bodypart promotion causes loss of charset
    // Delete All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);
                }
            }
        }
    }

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest, FALSE));
            }
        }
    }

    // Otherwise, copy selected properties
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest, FALSE));
                }
            }
        }
    }

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::MoveProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPPROPERTY      pCurrHash;
    LPCONTAINER     pDest=NULL;

    // Invalid ARg
    if ((0 == cNames && NULL != prgszName) || (NULL == prgszName && 0 != cNames) || NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for destination continer
    CHECKHR(hr = pPropertySet->BindToObject(IID_CMimePropertyContainer, (LPVOID *)&pDest));

    // Raid-62016: CDO: Bodypart promotion causes loss of charset
    // Delete Properties in the Destination First
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            for (pCurrHash=m_prgHashTable[i]; pCurrHash!=NULL; pCurrHash=pCurrHash->pNextHash)
            {
                // Delete from Destination Container
                pDest->DeleteProp(pCurrHash->pSymbol);
            }
        }
    }

    // Otherwise, selective delete
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Delete from Destination Container
                    pDest->DeleteProp(pSymbol);
                }
            }
        }
    }

    // Move All Properties
    if (0 == cNames)
    {
        // Loop through the item table
        for (i=0; i<CBUCKETS; i++)
        {
            // Init First Item
            pCurrHash = m_prgHashTable[i];

            // Walk the Hash Chain
            while(pCurrHash)
            {
                // Copy the Property To
                CHECKHR(hr = _HrCopyProperty(pCurrHash, pDest, TRUE));

                // Delete pProperty
                _UnlinkProperty(pCurrHash, &pCurrHash);
            }
        }
    }

    // Otherwise, selective move
    else
    {
        // Call Into InetPropSet
        for (i=0; i<cNames; i++)
        {
            // Bad Name..
            if (NULL == prgszName[i])
            {
                Assert(FALSE);
                continue;
            }

            // Open Property Symbol
            if (SUCCEEDED(g_pSymCache->HrOpenSymbol(prgszName[i], FALSE, &pSymbol)))
            {
                // Find the Property
                if (SUCCEEDED(_HrFindProperty(pSymbol, &pProperty)))
                {
                    // Copy the Property To
                    CHECKHR(hr = _HrCopyProperty(pProperty, pDest, FALSE));

                    // Delete pProperty
                    _UnlinkProperty(pProperty);
                }
            }
        }
    }

    // Dirty
    FLAGSET(m_dwState, COSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pDest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::SetOption(const TYPEDID oid, LPCPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        if (pVariant->ulVal > RELOAD_HEADER_REPLACE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ReloadType != (RELOADTYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.ReloadType = (RELOADTYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        if (m_rOptions.fNoDefCntType != (pVariant->boolVal ? TRUE : FALSE))
            m_rOptions.fNoDefCntType = pVariant->boolVal ? TRUE : FALSE;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        if (m_rOptions.fAllow8bit != (pVariant->boolVal ? TRUE : FALSE))
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.fAllow8bit = pVariant->boolVal ? TRUE : FALSE;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        if (pVariant->ulVal < MIN_CBMAX_HEADER_LINE || pVariant->ulVal > MAX_CBMAX_HEADER_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.cbMaxLine = pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        if (SAVE_RFC822 != pVariant->ulVal && SAVE_RFC1521 != pVariant->ulVal)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.savetype != (MIMESAVETYPE)pVariant->ulVal)
        {
            FLAGSET(m_dwState, COSTATE_DIRTY);
            m_rOptions.savetype = (MIMESAVETYPE)pVariant->ulVal;
        }
        break;

    // -----------------------------------------------------------------------
    default:
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetOption
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetOption(const TYPEDID oid, LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT     hr=S_OK;

    // check params
    if (NULL == pVariant)
        return TrapError(E_INVALIDARG);

    pVariant->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    // -----------------------------------------------------------------------
    case OID_HEADER_RELOAD_TYPE:
        pVariant->ulVal = m_rOptions.ReloadType;
        break;

    // -----------------------------------------------------------------------
    case OID_NO_DEFAULT_CNTTYPE:
        pVariant->boolVal = (VARIANT_BOOL) !!m_rOptions.fNoDefCntType;
        break;

    // -----------------------------------------------------------------------
    case OID_ALLOW_8BIT_HEADER:
        pVariant->boolVal = (VARIANT_BOOL) !!m_rOptions.fAllow8bit;
        break;

    // -----------------------------------------------------------------------
    case OID_CBMAX_HEADER_LINE:
        pVariant->ulVal = m_rOptions.cbMaxLine;
        break;

    // -----------------------------------------------------------------------
    case OID_SAVE_FORMAT:
        pVariant->ulVal = (ULONG)m_rOptions.savetype;
        break;

    // -----------------------------------------------------------------------
    default:
        pVariant->vt = VT_NULL;
        hr = TrapError(MIME_E_INVALID_OPTION_ID);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DwGetMessageFlags
// --------------------------------------------------------------------------------
DWORD CMimePropertyContainer::DwGetMessageFlags(BOOL fHideTnef)
{
    // Locals
    DWORD dwFlags=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPCSTR pszPriType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_PRITYPE], STR_CNT_TEXT);
    LPCSTR pszSubType = PSZDEFPROPSTRINGA(m_prgIndex[PID_ATT_SUBTYPE], STR_SUB_PLAIN);
    LPCSTR pszCntDisp = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTDISP], STR_DIS_INLINE);

    // Mime
    if (m_prgIndex[PID_HDR_MIMEVER])
        FLAGSET(dwFlags, IMF_MIME);

    // VoiceMail
    if (S_OK == IsPropSet(STR_HDR_XVOICEMAIL))
        FLAGSET(dwFlags, IMF_VOICEMAIL);

    // IMF_NEWS
    if (m_prgIndex[PID_HDR_XNEWSRDR]  || m_prgIndex[PID_HDR_NEWSGROUPS] || m_prgIndex[PID_HDR_NEWSGROUP] || m_prgIndex[PID_HDR_PATH])
        FLAGSET(dwFlags, IMF_NEWS);

    // text
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
    {
        // There is text
        FLAGSET(dwFlags, IMF_TEXT);

        // text/plain
        if (lstrcmpi(pszSubType, STR_SUB_PLAIN) == 0)
            FLAGSET(dwFlags, IMF_PLAIN);

        // text/html
        else if (lstrcmpi(pszSubType, STR_SUB_HTML) == 0)
            FLAGSET(dwFlags, IMF_HTML);

        // text/enriched = text/html
        else if (lstrcmpi(pszSubType, STR_SUB_ENRICHED) == 0)
            FLAGSET(dwFlags, IMF_HTML);

        // text/v-card
        else if (lstrcmpi(pszSubType, STR_SUB_VCARD) == 0)
            FLAGSET(dwFlags, IMF_HASVCARD);
    }

    // multipart
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
    {
        // Multipart
        FLAGSET(dwFlags, IMF_MULTIPART);

        // multipart/related
        if (lstrcmpi(pszSubType, STR_SUB_RELATED) == 0)
            FLAGSET(dwFlags, IMF_MHTML);

        // multipart/signed
        else if (0 == lstrcmpi(pszSubType, STR_SUB_SIGNED))
            if (IsSMimeProtocol(this))
                FLAGSET(dwFlags, IMF_SIGNED | IMF_SECURE);
    }

    // message/partial
    else if (lstrcmpi(pszPriType, STR_CNT_MESSAGE) == 0 && lstrcmpi(pszSubType, STR_SUB_PARTIAL) == 0)
        FLAGSET(dwFlags, IMF_PARTIAL);

    // application
    else if (lstrcmpi(pszPriType, STR_CNT_APPLICATION) == 0)
    {
        // application/ms-tnef
        if (0 == lstrcmpi(pszSubType, STR_SUB_MSTNEF))
            FLAGSET(dwFlags, IMF_TNEF);

        // application/x-pkcs7-mime
        else if (0 == lstrcmpi(pszSubType, STR_SUB_XPKCS7MIME) ||
            0 == lstrcmpi(pszSubType, STR_SUB_PKCS7MIME))  // nonstandard
            FLAGSET(dwFlags, IMF_SECURE);
    }

    // Raid-37086 - Cset Tagged
    if (ISFLAGSET(m_dwState, COSTATE_CSETTAGGED))
        FLAGSET(dwFlags, IMF_CSETTAGGED);

    // Attachment...
    if (!ISFLAGSET(dwFlags, IMF_MULTIPART) && (FALSE == fHideTnef || !ISFLAGSET(dwFlags, IMF_TNEF)))
    {
        // Marked as an attachment ?
        if (!ISFLAGSET(dwFlags, IMF_HASVCARD) && 
            !ISFLAGSET(dwFlags, IMF_SECURE) && 
            0 != lstrcmpi(pszSubType, STR_SUB_PKCS7SIG) &&
            0 != lstrcmpi(pszSubType, STR_SUB_XPKCS7SIG)) // Raid-1960
        {
            // Not Rendered Yet
            if (NULL == m_prgIndex[PID_ATT_RENDERED] || 0 == m_prgIndex[PID_ATT_RENDERED]->rValue.rVariant.ulVal)
            {
                // Marked as an Attachment
                if (lstrcmpi(pszCntDisp, STR_DIS_ATTACHMENT) == 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Type: xxx; name=xxx
                else if (NULL != m_prgIndex[PID_PAR_NAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Is there a Content-Disposition: xxx; filename=xxx
                else if (NULL != m_prgIndex[PID_PAR_FILENAME])
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // Else if it is not marked as text
                else if (ISFLAGSET(dwFlags, IMF_TEXT) == FALSE)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);

                // If not text/plain and not text/html
                else if (lstrcmpi(pszSubType, STR_SUB_PLAIN) != 0 && lstrcmpi(pszSubType, STR_SUB_HTML) != 0 && lstrcmpi(pszSubType, STR_SUB_ENRICHED) != 0)
                    FLAGSET(dwFlags, IMF_ATTACHMENTS);
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetEncodingType
// --------------------------------------------------------------------------------
ENCODINGTYPE CMimePropertyContainer::GetEncodingType(void)
{
    // Locals
    ENCODINGTYPE ietEncoding=IET_7BIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get pritype/subtype
    LPPROPERTY pCntXfer = m_prgIndex[PID_HDR_CNTXFER];

    // Do we have data the I like ?
    if (pCntXfer && ISSTRINGA(&pCntXfer->rValue))
    {
        // Local
        CStringParser cString;

        // cString...
        cString.Init(pCntXfer->rValue.rStringA.pszVal, pCntXfer->rValue.rStringA.cchVal, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS);

        // Parse to end, remove white space and comments
        SideAssert('\0' == cString.ChParse(""));

        // Loop the table
        for (ULONG i=0; i<ARRAYSIZE(g_rgEncoding); i++)
        {
            // Match Encoding Strings
            if (lstrcmpi(g_rgEncoding[i].pszEncoding, cString.PszValue()) == 0)
            {
                ietEncoding = g_rgEncoding[i].ietEncoding;
                break;
            }
        }
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return ietEncoding;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetInlineSymbol
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetInlineSymbol(LPCSTR pszData, LPPROPSYMBOL *ppSymbol, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szHeader[255];
    LPSTR       pszHeader=NULL;

    // Invalid Arg
    Assert(pszData && ppSymbol);

    // _HrParseInlineHeaderName
    CHECKHR(hr = _HrParseInlineHeaderName(pszData, szHeader, sizeof(szHeader), &pszHeader, pcboffColon));

    // Find Global Property
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, ppSymbol));

exit:
    // Cleanup
    if (pszHeader != szHeader)
        SafeMemFree(pszHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrParseInlineHeaderName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrParseInlineHeaderName(LPCSTR pszData, LPSTR pszScratch, ULONG cchScratch,
    LPSTR *ppszHeader, ULONG *pcboffColon)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       psz=(LPSTR)pszData,
                pszStart;
    ULONG       i=0;

    // Invalid Arg
    Assert(pszData && pszScratch && ppszHeader && pcboffColon);

    // Lets Parse the name out and find the symbol
    while (*psz && (' ' == *psz || '\t' == *psz))
    {
        i++;
        psz++;
    }

    // Done
    if ('\0' == *psz)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Seek to the colon
    pszStart = psz;
    while (*psz && ':' != *psz)
    {
        i++;
        psz++;
    }

    // Set Colon Position
    (*pcboffColon) = i;

    // Done
    if ('\0' == *psz || 0 == i)
    {
        hr = TrapError(MIME_E_INVALID_HEADER_NAME);
        goto exit;
    }

    // Copy the name
    if (i + 1 <= cchScratch)
        *ppszHeader = pszScratch;

    // Otherwise, allocate
    else
    {
        // Allocate space for the name
        *ppszHeader = PszAllocA(i + 1);
        if (NULL == *ppszHeader)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Copy the data
    CopyMemory(*ppszHeader, pszStart, i);

    // Null
    *((*ppszHeader) + i) = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindFirstRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindFirstRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Invalid Arg
    if (NULL == pFindHeader)
        return TrapError(E_INVALIDARG);

    // Init pFindHeader
    pFindHeader->dwReserved = 0;

    // FindNext
    return FindNextRow(pFindHeader, phRow);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::FindNextRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::FindNextRow(LPFINDHEADER pFindHeader, LPHHEADERROW phRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pFindHeader || NULL == phRow)
        return TrapError(E_INVALIDARG);

    // Init
    *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=pFindHeader->dwReserved; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pFindHeader->pszHeader || lstrcmpi(pRow->pSymbol->pszName, pFindHeader->pszHeader) == 0)
        {
            // Save Index of next item to search
            pFindHeader->dwReserved = i + 1;

            // Return the handle
            *phRow = pRow->hRow;

            // Done
            goto exit;
        }
    }

    // Not Found
    pFindHeader->dwReserved = m_rHdrTable.cRows;
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::CountRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountRows(LPCSTR pszHeader, ULONG *pcRows)
{
    // Locals
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pcRows)
        return TrapError(E_INVALIDARG);

    // Init
    *pcRows = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through the table
    for (ULONG i=0; i<m_rHdrTable.cRows; i++)
    {
        // Next Row
        pRow = m_rHdrTable.prgpRow[i];
        if (NULL == pRow)
            continue;

        // Is this the header
        if (NULL == pszHeader || lstrcmpi(pRow->pSymbol->pszName, pszHeader) == 0)
            (*pcRows)++;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::AppendRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRow(LPCSTR pszHeader, DWORD dwFlags, LPCSTR pszData, ULONG cchData,
    LPHHEADERROW phRow)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    ULONG           cboffColon;
    LPPROPERTY      pProperty;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Init
    if (phRow)
        *phRow = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a header, lookup the symbol
    if (pszHeader)
    {
        // HTF_NAMEINDATA better not be set
        Assert(!ISFLAGSET(dwFlags, HTF_NAMEINDATA));

        // Lookup the symbol
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pszHeader, TRUE, &pSymbol));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Set the Data on this row
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData, cchData));
    }

    // Otherwise...
    else if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // GetInlineSymbol
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Create a row
        CHECKHR(hr = _HrAppendProperty(pSymbol, &pProperty));

        // Remove IHF_NAMELINE
        FLAGCLEAR(dwFlags, HTF_NAMEINDATA);

        // Set the Data on this row
        Assert(cboffColon + 1 < cchData);
        CHECKHR(hr = SetRowData(pProperty->hRow, dwFlags, pszData + cboffColon + 1, cchData - cboffColon - 1));
    }

    // Otherwise, failed
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Return phRow
    if (phRow && pProperty)
        *phRow = pProperty->hRow;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::DeleteRow
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteRow(HHEADERROW hRow)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Standard Delete Prop
    CHECKHR(hr = DeleteProp(pRow->pSymbol));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowData(HHEADERROW hRow, DWORD dwFlags, LPSTR *ppszData, ULONG *pcchData)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchData=0;
    LPPROPERTY  pRow;
    MIMEVARIANT rValue;
    DWORD       dwPropFlags;

    // Init
    if (ppszData)
        *ppszData = NULL;
    if (pcchData)
        *pcchData = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Compute dwPropFlags
    dwPropFlags = PDF_HEADERFORMAT | ((dwFlags & HTF_NAMEINDATA) ? PDF_NAMEINDATA : 0);

    // Speicify data type
    rValue.type = MVT_STRINGA;

    // Ask the value for the data
    CHECKHR(hr = _HrGetPropertyValue(pRow, dwPropFlags, &rValue));

    // Want Length
    cchData = rValue.rStringA.cchVal;

    // Want the data
    if (ppszData)
    {
        *ppszData = rValue.rStringA.pszVal;
        rValue.rStringA.pszVal = NULL;
    }

    // Else Free It
    else
        SafeMemFree(rValue.rStringA.pszVal);

    // Verify the NULL
    Assert(ppszData ? '\0' == *((*ppszData) + cchData) : TRUE);

    // Return Length ?
    if (pcchData)
        *pcchData = cchData;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowData
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowData(HHEADERROW hRow, DWORD dwFlags, LPCSTR pszData, ULONG cchData)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPERTY      pRow;
    MIMEVARIANT     rValue;
    ULONG           cboffColon;
    LPPROPSYMBOL    pSymbol;
    LPSTR           psz=(LPSTR)pszData;

    // InvalidArg
    if (NULL == pszData || '\0' != pszData[cchData])
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // If HTF_NAMEINDATA
    if (ISFLAGSET(dwFlags, HTF_NAMEINDATA))
    {
        // Extract the name
        CHECKHR(hr = _HrGetInlineSymbol(pszData, &pSymbol, &cboffColon));

        // Symbol Must be the same
        if (pRow->pSymbol != pSymbol)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Adjust pszData
        Assert(cboffColon < cchData);
        psz = (LPSTR)(pszData + cboffColon + 1);
        cchData = cchData - cboffColon - 1;
        Assert(psz[cchData] == '\0');
    }

    // Setup the variant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = psz;
    rValue.rStringA.cchVal = cchData;

    // Tell value about the new row data
    CHECKHR(hr = _HrSetPropertyValue(pRow, 0, &rValue, FALSE));

    // Clear Position Information
    pRow->cboffStart = 0;
    pRow->cboffColon = 0;
    pRow->cboffEnd = 0;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::GetRowInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetRowInfo(HHEADERROW hRow, LPHEADERROWINFO pInfo)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // InvalidArg
    if (NULL == pInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pInfo->dwRowNumber = pRow->dwRowNumber;
    pInfo->cboffStart = pRow->cboffStart;
    pInfo->cboffColon = pRow->cboffColon;
    pInfo->cboffEnd = pRow->cboffEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::SetRowNumber
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetRowNumber(HHEADERROW hRow, DWORD dwRowNumber)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pRow;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the Handle
    CHECKEXP(_FIsValidHRow(hRow) == FALSE, MIME_E_INVALID_HANDLE);

    // Get the row
    pRow = PRowFromHRow(hRow);

    // Copy the row info
    pRow->dwRowNumber = dwRowNumber;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::EnumRows
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumRows(LPCSTR pszHeader, DWORD dwFlags, IMimeEnumHeaderRows **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    ULONG                i,
                         iEnum=0,
                         cEnumCount;
    LPENUMHEADERROW      pEnumRow=NULL;
    LPPROPERTY           pRow;
    CMimeEnumHeaderRows *pEnum=NULL;
    LPROWINDEX           prgIndex=NULL;
    ULONG                cRows;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // This builds an inverted index on the header rows sorted by postion weight
    CHECKHR(hr = _HrGetHeaderTableSaveIndex(&cRows, &prgIndex));

    // Lets Count the Rows
    CHECKHR(hr = CountRows(pszHeader, &cEnumCount));

    // Allocate pEnumRow
    CHECKALLOC(pEnumRow = (LPENUMHEADERROW)g_pMalloc->Alloc(cEnumCount * sizeof(ENUMHEADERROW)));

    // ZeroInit
    ZeroMemory(pEnumRow, cEnumCount * sizeof(ENUMHEADERROW));

    // Loop through the rows
    for (i=0; i<cRows; i++)
    {
        // Get the row
        Assert(_FIsValidHRow(prgIndex[i].hRow));
        pRow = PRowFromHRow(prgIndex[i].hRow);

        // Is this a header the client wants
        if (NULL == pszHeader || lstrcmpi(pszHeader, pRow->pSymbol->pszName) == 0)
        {
            // Valide
            Assert(iEnum < cEnumCount);

            // Set the symbol on this enum row
            pEnumRow[iEnum].dwReserved = (DWORD_PTR)pRow->pSymbol;

            // Lets always give the handle
            pEnumRow[iEnum].hRow = pRow->hRow;

            // If Enumerating only handles...
            if (!ISFLAGSET(dwFlags, HTF_ENUMHANDLESONLY))
            {
                // Get the data for this enum row
                CHECKHR(hr = GetRowData(pRow->hRow, dwFlags, &pEnumRow[iEnum].pszData, &pEnumRow[iEnum].cchData));
            }

            // Increment iEnum
            iEnum++;
        }
    }

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumHeaderRows);

    // Initialize
    CHECKHR(hr = pEnum->HrInit(0, dwFlags, cEnumCount, pEnumRow, FALSE));

    // Don't Free pEnumRow
    pEnumRow = NULL;

    // Return it
    (*ppEnum) = (IMimeEnumHeaderRows *)pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    SafeMemFree(prgIndex);
    if (pEnumRow)
        g_pMoleAlloc->FreeEnumHeaderRowArray(cEnumCount, pEnumRow, TRUE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressGroup(LPPROPERTY pProperty, IStream *pStream,
    ULONG *pcAddrsWrote, ADDRESSFORMAT format, VARTYPE vtFormat)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pStream && pcAddrsWrote);
    Assert(!ISFLAGSET(pProperty->dwState, PRSTATE_NEEDPARSE));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Multibyte
        if (VT_LPSTR == vtFormat)
        {
            // Tell the Address Info object to write its display information
            CHECKHR(hr = _HrSaveAddressA(pProperty, pAddress, pStream, pcAddrsWrote, format));
        }

        // Otherwise
        else
        {
            // Validate 
            Assert(VT_LPWSTR == vtFormat);

            // Tell the Address Info object to write its display information
            CHECKHR(hr = _HrSaveAddressW(pProperty, pAddress, pStream, pcAddrsWrote, format));
        }

        // Increment cAddresses Count
        (*pcAddrsWrote)++;
    }

exit:
    // Done
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  bIsInLineEncodedA
//
//  [PaulHi] 6/29/99
//  Helper function to determine if single byte string contains RFC1522 inline
//  encoding.  
//  Format is: "=?[charset]?[encoding]?[data]?=".
///////////////////////////////////////////////////////////////////////////////
BOOL bIsInLineEncodedA(LPCSTR pcszName)
{
    Assert(pcszName);

    int nState = 0; // 0-Begin,charset; 1-encoding; 2-data; 3-Ending

    while(*pcszName)
    {
        // Check for beginning delimiter.
        if ( (*pcszName == '=') && (*(pcszName+1) == '?') )
        {
            // Set/reset state
            nState = 1;
            pcszName += 1;  // Skip past.
        }
        else
        {
            switch (nState)
            {
            case 1:
            case 2:
                // Find encoding, data bodies.
                if (*pcszName == '?')
                {
                    ++nState;
                    ++pcszName; // Skip past body
                }
                break;

            case 3:
                // Find ending delimiter.
                if ( (*pcszName == '?') && (*(pcszName+1) == '=') )
                    return TRUE;
                break;
            }
        }

        if (*pcszName != '\0')
        {
            if (IsDBCSLeadByte(*pcszName))
                ++pcszName;
            ++pcszName;
        }
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressA
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressA(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszNameW=NULL;
    LPSTR           pszNameA=NULL;
    LPSTR           pszEmailA=NULL;
    BOOL            fWriteEmail=FALSE;
    LPWSTR          pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    BOOL            fRFC1522=FALSE;
    DWORD           dwFlags;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyW(pAddress->rFriendly.psz) && FIsEmptyW(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_szAddressFold, lstrlen(c_szAddressFold), NULL));
        }

        // AFT_RFC822_DECODED, AFT_RFC822_ENCODED
        else if (AFT_RFC822_DECODED == format ||  AFT_RFC822_ENCODED == format)
        {
            // ', '
            CHECKHR(hr = pStream->Write(c_szCommaSpace, lstrlen(c_szCommaSpace), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_szSemiColonSpace, lstrlen(c_szSemiColonSpace), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyW(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyW(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if ((AFT_RFC822_TRANSMIT == format || AFT_DISPLAY_BOTH == format) && fWriteEmail && StrStrW(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszNameA = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGA;
            rSource.type = MVT_STRINGW;

            // Init pszName
            pszNameW = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeStringW(pszNameW, &pszEscape) == S_OK)
            {
                // Escaped
                pszNameW = pszEscape;
                rSource.rStringW.pszVal = pszNameW;
                rSource.rStringW.cchVal = lstrlenW(pszNameW);
            }

            // Otherwise
            else
            {
                rSource.rStringW.pszVal = pAddress->rFriendly.psz;
                rSource.rStringW.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
                dwFlags = CVF_NOALLOC | PDF_ENCODED;
            else
                dwFlags = CVF_NOALLOC;

            // Convert to ansi
            if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, IET_DECODED, dwFlags, 0, &rSource, &rDest, &fRFC1522)))
            {
                // Set pszNameA
                pszNameA = rDest.rStringA.pszVal;
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszNameA)
    {
        // [PaulHi] 6/29/99  Raid 81539
        // Double quote all display names unless they are in-line encoded.
        BOOL    fInLineEncoded = bIsInLineEncodedA(pszNameA);
        // if (fRFC822 && !fRFC1522)

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR(hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }

        // Write display name
        CHECKHR(hr = pStream->Write(pszNameA, lstrlen(pszNameA), NULL));

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR (hr = pStream->Write(c_szDoubleQuote, lstrlen(c_szDoubleQuote), NULL));
        }
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCSTR pszStart = pszNameA ? c_szEmailSpaceStart : c_szEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlen(pszStart), NULL));

        // Convert to ansi
        CHECKALLOC(pszEmailA = PszToANSI(CP_ACP, pAddress->rEmail.psz));

        // Write email
        CHECKHR(hr = pStream->Write(pszEmailA, lstrlen(pszEmailA), NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    SafeMemFree(pszEmailA);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//  bIsInLineEncodedW
//
//  [PaulHi] 6/29/99
//  Helper function to determine if double byte string contains RFC1522 inline
//  encoding.
//  Format is: "=?[charset]?[encoding]?[data]?=".
///////////////////////////////////////////////////////////////////////////////
BOOL bIsInLineEncodedW(LPCWSTR pcwszName)
{
    Assert(pcwszName);

    int nState = 0;  // 0-Begin,charset; 1-encoding; 2-data; 3-Ending

    while(*pcwszName)
    {
        if ( (*pcwszName == L'=') && (*(pcwszName+1) == L'?') )
        {
            // Set/reset state.
            nState = 1;
            ++pcwszName; // Skip past
        }
        else
        {
            switch (nState)
            {
            case 1:
            case 2:
                // Find encoding, data bodies.
                if (*pcwszName == L'?')
                {
                    ++nState;
                    ++pcwszName; // Skip past body
                }
                break;

            case 3:
                // Find ending delimiter.
                if ( (*pcwszName == L'?') && (*(pcwszName+1) == L'=') )
                    return TRUE;
                break;
            }
        }

        if (*pcwszName != 0)
            ++pcwszName;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrSaveAddressW
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSaveAddressW(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    IStream *pStream, ULONG *pcAddrsWrote, ADDRESSFORMAT format)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszNameW=NULL;
    BOOL            fWriteEmail=FALSE;
    LPWSTR          pszEscape=NULL;
    BOOL            fRFC822=FALSE;
    BOOL            fRFC1522=FALSE;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    Assert(pProperty && pAddress && pStream && pcAddrsWrote);

    // Init Dest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Deleted or Empty continue
    if (FIsEmptyW(pAddress->rFriendly.psz) && FIsEmptyW(pAddress->rEmail.psz))
    {
        Assert(FALSE);
        goto exit;
    }

    // RFC822 Format
    if (AFT_RFC822_TRANSMIT == format || AFT_RFC822_ENCODED == format || AFT_RFC822_DECODED == format)
        fRFC822 = TRUE;

    // Decide Delimiter
    if (*pcAddrsWrote > 0)
    {
        // AFT_RFC822_TRANSMIT
        if (AFT_RFC822_TRANSMIT == format)
        {
            // ',\r\n\t'
            CHECKHR (hr = pStream->Write(c_wszAddressFold, lstrlenW(c_wszAddressFold) * sizeof(WCHAR), NULL));
        }

        // AFT_RFC822_DECODED, AFT_RFC822_ENCODED
        else if (AFT_RFC822_DECODED == format ||  AFT_RFC822_ENCODED == format)
        {
            // ', '
            CHECKHR(hr = pStream->Write(c_wszCommaSpace, lstrlenW(c_wszCommaSpace) * sizeof(WCHAR), NULL));
        }

        // AFT_DISPLAY_FRIENDLY, AFT_DISPLAY_EMAIL, AFT_DISPLAY_BOTH
        else
        {
            // '; '
            CHECKHR(hr = pStream->Write(c_wszSemiColonSpace, lstrlenW(c_wszSemiColonSpace) * sizeof(WCHAR), NULL));
        }
    }

    // Only format that excludes writing the email name
    if (AFT_DISPLAY_FRIENDLY != format && FIsEmptyW(pAddress->rEmail.psz) == FALSE)
        fWriteEmail = TRUE;

    // Only format that excludes writing the display name
    if (AFT_DISPLAY_EMAIL != format && FIsEmptyW(pAddress->rFriendly.psz) == FALSE)
    {
        // Should we write the name
        if ((AFT_RFC822_TRANSMIT == format || AFT_DISPLAY_BOTH == format) && fWriteEmail && StrStrW(pAddress->rFriendly.psz, pAddress->rEmail.psz))
            pszNameW = NULL;
        else
        {
            // Setup Types
            rDest.type = MVT_STRINGW;
            rSource.type = MVT_STRINGW;

            // Init pszName
            pszNameW = pAddress->rFriendly.psz;

            // Escape It
            if (fRFC822 && MimeOleEscapeStringW(pszNameW, &pszEscape) == S_OK)
            {
                // Escaped
                pszNameW = pszEscape;
                rSource.rStringW.pszVal = pszNameW;
                rSource.rStringW.cchVal = lstrlenW(pszNameW);
            }

            // Otherwise
            else
            {
                rSource.rStringW.pszVal = pAddress->rFriendly.psz;
                rSource.rStringW.cchVal = pAddress->rFriendly.cch;
            }

            // Encoded
            if (AFT_RFC822_ENCODED == format || AFT_RFC822_TRANSMIT == format)
            {
                // Convert to ansi
                if (SUCCEEDED(HrConvertVariant(pProperty->pSymbol, pAddress->pCharset, IET_DECODED, CVF_NOALLOC | PDF_ENCODED, 0, &rSource, &rDest, &fRFC1522)))
                {
                    // Set pszNameA
                    pszNameW = rDest.rStringW.pszVal;
                }
            }
        }
    }

    // Write Display Name ?
    if (NULL != pszNameW)
    {
        // [PaulHi] 6/29/99  Raid 81539
        // Double quote all display names unless they are in-line encoded.
        BOOL    fInLineEncoded = bIsInLineEncodedW(pszNameW);
        // if (fRFC822 && !fRFC1522)

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR(hr = pStream->Write(c_wszDoubleQuote, lstrlenW(c_wszDoubleQuote) * sizeof(WCHAR), NULL));
        }

        // Write display name
        CHECKHR(hr = pStream->Write(pszNameW, lstrlenW(pszNameW) * sizeof(WCHAR), NULL));

        // Write Quote
        if ((AFT_DISPLAY_FRIENDLY != format) && !fInLineEncoded)
        {
            // Write It
            CHECKHR (hr = pStream->Write(c_wszDoubleQuote, lstrlenW(c_wszDoubleQuote) * sizeof(WCHAR), NULL));
        }
    }

    // Write Email
    if (TRUE == fWriteEmail)
    {
        // Set Start
        LPCWSTR pszStart = pszNameW ? c_wszEmailSpaceStart : c_wszEmailStart;

        // Begin Email '>'
        CHECKHR(hr = pStream->Write(pszStart, lstrlenW(pszStart) * sizeof(WCHAR), NULL));

        // Write email
        CHECKHR(hr = pStream->Write(pAddress->rEmail.psz, pAddress->rEmail.cch * sizeof(WCHAR), NULL));

        // End Email '>'
        CHECKHR(hr = pStream->Write(c_wszEmailEnd, lstrlenW(c_wszEmailEnd) * sizeof(WCHAR), NULL));
    }

exit:
    // Cleanup
    SafeMemFree(pszEscape);
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddressGroup
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddressGroup(LPPROPERTY pProperty, LPCSTR pszCriteria,
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT           hr=S_OK;
    LPMIMEADDRESS    pAddress;

    // Invalid Arg
    Assert(pProperty && pProperty->pGroup && pszCriteria);

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Loop Infos...
    for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
    {
        // Tell the Address Info object to write its display information
        if (_HrQueryAddress(pProperty, pAddress, pszCriteria, fSubString, fCaseSensitive) == S_OK)
            goto exit;
    }

    // Not Found
    hr = S_FALSE;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::_HrQueryAddress
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrQueryAddress(LPPROPERTY pProperty, LPMIMEADDRESS pAddress,
    LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszCriteria=NULL;

    // Invalid Arg
    Assert(pProperty && pAddress && pszCriteria);

    // Convert to Unicode
    CHECKALLOC(pwszCriteria = PszToUnicode(CP_ACP, pszCriteria));

    // Query Email Address First
    if (MimeOleQueryStringW(pAddress->rEmail.psz, pwszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Query Display Address First
    if (MimeOleQueryStringW(pAddress->rFriendly.psz, pwszCriteria, fSubString, fCaseSensitive) == S_OK)
        goto exit;

    // Not Found
    hr = S_FALSE;

exit:
    // Cleanup
    SafeMemFree(pwszCriteria);

    // Done
    return hr;
}


// ----------------------------------------------------------------------------
// CMimePropertyContainer::Append
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Append(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCSTR pszFriendly,
    LPCSTR pszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(rProps));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = (LPSTR)pszFriendly;
    }

    // Set pszEmail
    if (pszEmail)
    {
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = (LPSTR)pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendW
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendW(DWORD dwAdrType, ENCODINGTYPE ietFriendly, LPCWSTR pwszFriendly,
    LPCWSTR pwszEmail, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    ADDRESSPROPS    rProps;
    LPSTR           pszFriendly = NULL,
                    pszEmail = NULL;

    // Setup rProps
    ZeroMemory(&rProps, sizeof(rProps));

    // Set AddrTyupe
    rProps.dwProps = IAP_ADRTYPE | IAP_ENCODING;
    rProps.dwAdrType = dwAdrType;
    rProps.ietFriendly = ietFriendly;

    // Set pszFriendly
    if (pwszFriendly)
    {
        FLAGSET(rProps.dwProps, IAP_FRIENDLYW);
        rProps.pszFriendlyW = (LPWSTR)pwszFriendly;

        IF_NULLEXIT(pszFriendly = PszToANSI(CP_ACP, pwszFriendly));
        FLAGSET(rProps.dwProps, IAP_FRIENDLY);
        rProps.pszFriendly = pszFriendly;
    }

    // Set pszEmail
    if (pwszEmail)
    {
        IF_NULLEXIT(pszEmail = PszToANSI(CP_ACP, pwszEmail));
        FLAGSET(rProps.dwProps, IAP_EMAIL);
        rProps.pszEmail = pszEmail;
    }

    // Set the Email Address
    CHECKHR(hr = Insert(&rProps, phAddress));

exit:
    MemFree(pszFriendly);
    MemFree(pszEmail);

    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Insert
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Insert(LPADDRESSPROPS pProps, LPHADDRESS phAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address and Address Type
    if (!ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) || (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail)))
        return TrapError(E_INVALIDARG);

    // Init
    if (phAddress)
        *phAddress = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

    // Open the group
    CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

    // Does the Property need to be parsed ?
    CHECKHR(hr = _HrParseInternetAddress(pProperty));

    // Append an Address to the group
    CHECKHR(hr = _HrAppendAddressGroup(pProperty->pGroup, &pAddress));

    // The group is dirty
    Assert(pAddress->pGroup);
    pAddress->pGroup->fDirty = TRUE;

    // Set the Address Type
    pAddress->dwAdrType = pProps->dwAdrType;

    // Copy Address Props to Mime Address
    CHECKHR(hr = SetProps(pAddress->hThis, pProps));

    // Return the Handle
    if (phAddress)
        *phAddress = pAddress->hThis;

exit:
    // Failure
    if (FAILED(hr) && pAddress)
        Delete(pAddress->hThis);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_GetAddressCodePageId
// --------------------------------------------------------------------------------
CODEPAGEID CMimePropertyContainer::_GetAddressCodePageId(LPINETCSETINFO pCharset,
    ENCODINGTYPE ietEncoding)
{
    // Locals
    CODEPAGEID cpiCodePage=CP_ACP;

    // No Charset Yet
    if (NULL == pCharset)
    {
        // Try to use the default
        if (m_rOptions.pDefaultCharset)
            pCharset = m_rOptions.pDefaultCharset;

        // Use the global default
        else if (CIntlGlobals::GetDefHeadCset())
            pCharset = CIntlGlobals::GetDefHeadCset();
    }

    // If we have a charset, compute the friendly name codepage
    if (pCharset)
    {
        // Decoded
        if (IET_DECODED == ietEncoding)
        {
            // Get Windows
            cpiCodePage = (CP_UNICODE == pCharset->cpiWindows) ? CP_ACP : MimeOleGetWindowsCPEx(pCharset);
        }

        // Otherwise
        else
        {
            // Use Internet Codepage
            cpiCodePage = (CP_UNICODE == pCharset->cpiInternet) ? CP_ACP : pCharset->cpiInternet;
        }
    }

    // Done
    return(cpiCodePage);
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrSetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrSetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset=NULL;
    LPWSTR          pszFriendlyW=NULL;
    LPWSTR          pszEmailW=NULL;
    ENCODINGTYPE    ietFriendly;

    // Set ietFriendly
    ietFriendly = (ISFLAGSET(pProps->dwProps, IAP_ENCODING)) ? pProps->ietFriendly : IET_DECODED;

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
        pAddress->dwAdrType = pProps->dwAdrType;

    // IAP_HCHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET) && pProps->hCharset)
    {
        // Resolve to pCharset
        if (SUCCEEDED(g_pInternat->HrOpenCharset(pProps->hCharset, &pCharset)))
            pAddress->pCharset = pCharset;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
        pAddress->certstate = pProps->certstate;

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
        pAddress->dwCookie = pProps->dwCookie;

    // IAP_FRIENDLYW
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLYW) && pProps->pszFriendlyW)
    {
        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pProps->pszFriendlyW, lstrlenW(pProps->pszFriendlyW), &pAddress->rFriendly));
    }

    // IAP_FRIENDLY
    else if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY) && pProps->pszFriendly)
    {
        // If the string is encoded, then we have to convert from cpiInternet to a Unicode
        if (IET_DECODED != ietFriendly)
        {
            // No Charset Yet
            if (NULL == pCharset)
            {
                // Try to use the default
                if (m_rOptions.pDefaultCharset)
                    pCharset = m_rOptions.pDefaultCharset;

                // Use the global default
                else if (CIntlGlobals::GetDefHeadCset())
                    pCharset = CIntlGlobals::GetDefHeadCset();
            }

            // If we have a charset
            if (pCharset)
            {
                // Locals
                RFC1522INFO Rfc1522Info={0};
                PROPVARIANT Decoded;

                // rfc1522 ?
                Rfc1522Info.fRfc1522Allowed = TRUE;

                // Init
                Decoded.vt = VT_LPWSTR;

                // Decode the header
                if (SUCCEEDED(g_pInternat->DecodeHeader(pCharset->hCharset, pProps->pszFriendly, &Decoded, &Rfc1522Info)))
                {
                    // Set
                    pszFriendlyW = Decoded.pwszVal;
                }
            }
        }

        // Otherwise, just convert to unicode
        else
        {
            // Convert To Unicode
            pszFriendlyW = PszToUnicode(_GetAddressCodePageId(pCharset, IET_DECODED), pProps->pszFriendly);
        }

        // If we haven't set pszFriendlyW, then just copy pszFriendly
        if (NULL == pszFriendlyW)
        {
            // Convert from CP_ACP to unicode
            CHECKALLOC(pszFriendlyW = PszToUnicode(CP_ACP, pProps->pszFriendly));
        }

        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pszFriendlyW, lstrlenW(pszFriendlyW), &pAddress->rFriendly));
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && pProps->pszEmail)
    {
        // Convert To Unicode
        CHECKALLOC(pszEmailW = PszToUnicode(CP_ACP, pProps->pszEmail));

        // Set It
        CHECKHR(hr = HrSetAddressTokenW(pszEmailW, lstrlenW(pszEmailW), &pAddress->rEmail));
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT) && pProps->tbSigning.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbSigning.pBlobData);
        pAddress->tbSigning.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbSigning, &pAddress->tbSigning));
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT) && pProps->tbEncryption.pBlobData)
    {
        // Free Current Blob
        SafeMemFree(pAddress->tbEncryption.pBlobData);
        pAddress->tbEncryption.cbSize = 0;

        // Dup
        CHECKHR(hr = HrCopyBlob(&pProps->tbEncryption, &pAddress->tbEncryption));
    }

    // pAddress->pGroup is Dirty
    Assert(pAddress->pGroup);
    if (pAddress->pGroup)
        pAddress->pGroup->fDirty = TRUE;

exit:
    // Cleanup
    SafeMemFree(pszFriendlyW);
    SafeMemFree(pszEmailW);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::_HrGetAddressProps
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGetAddressProps(LPADDRESSPROPS pProps, LPMIMEADDRESS pAddress)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_CHARSET
    if (ISFLAGSET(pProps->dwProps, IAP_CHARSET))
    {
        if (pAddress->pCharset && pAddress->pCharset->hCharset)
        {
            pProps->hCharset = pAddress->pCharset->hCharset;
        }
        else
        {
            pProps->hCharset = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_CHARSET);
        }
    }

    // IAP_HANDLE
    if (ISFLAGSET(pProps->dwProps, IAP_HANDLE))
    {
        Assert(pAddress->hThis);
        pProps->hAddress = pAddress->hThis;
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE))
    {
        Assert(pAddress->dwAdrType);
        pProps->dwAdrType = pAddress->dwAdrType;
    }

    // IAP_COOKIE
    if (ISFLAGSET(pProps->dwProps, IAP_COOKIE))
    {
        pProps->dwCookie = pAddress->dwCookie;
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pProps->dwProps, IAP_CERTSTATE))
    {
        pProps->certstate = pAddress->certstate;
    }

    // IAP_ENCODING
    if (ISFLAGSET(pProps->dwProps, IAP_ENCODING))
    {
        pProps->ietFriendly = IET_DECODED;
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLY))
    {
        // Decode
        if (pAddress->rFriendly.psz)
        {
            // Compute the correct codepage...
            CHECKALLOC(pProps->pszFriendly = PszToANSI(_GetAddressCodePageId(pAddress->pCharset, IET_DECODED), pAddress->rFriendly.psz));
        }
        else
        {
            pProps->pszFriendly = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLY);
        }
    }

    // IAT_FRIENDLYW
    if (ISFLAGSET(pProps->dwProps, IAP_FRIENDLYW))
    {
        // Get the email address
        if (pAddress->rFriendly.psz)
        {
            CHECKALLOC(pProps->pszFriendlyW = PszDupW(pAddress->rFriendly.psz));
        }
        else
        {
            pProps->pszFriendlyW = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_FRIENDLYW);
        }
    }

    // IAP_EMAIL
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL))
    {
        // Get the email address
        if (pAddress->rEmail.psz)
        {
            CHECKALLOC(pProps->pszEmail = PszToANSI(CP_ACP, pAddress->rEmail.psz));
        }
        else
        {
            pProps->pszEmail = NULL;
            FLAGCLEAR(pProps->dwProps, IAP_EMAIL);
        }
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_SIGNING_PRINT))
    {
        if (pAddress->tbSigning.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbSigning, &pProps->tbSigning));
        }
        else
        {
            pProps->tbSigning.pBlobData = NULL;
            pProps->tbSigning.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_SIGNING_PRINT);
        }
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pProps->dwProps, IAP_ENCRYPTION_PRINT))
    {
        if (pAddress->tbEncryption.pBlobData)
        {
            CHECKHR(hr = HrCopyBlob(&pAddress->tbEncryption, &pProps->tbEncryption));
        }
        else
        {
            pProps->tbEncryption.pBlobData = NULL;
            pProps->tbEncryption.cbSize = 0;
            FLAGCLEAR(pProps->dwProps, IAP_ENCRYPTION_PRINT);
        }
    }

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::SetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::SetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;
    LPPROPERTY      pProperty;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Must have an Email Address
    if (ISFLAGSET(pProps->dwProps, IAP_EMAIL) && FIsEmptyA(pProps->pszEmail))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Address Type
    if (ISFLAGSET(pProps->dwProps, IAP_ADRTYPE) && pProps->dwAdrType != pAddress->dwAdrType)
    {
        // Unlink this address from this group
        _UnlinkAddress(pAddress);

        // Get Header
        CHECKHR(hr = g_pSymCache->HrOpenSymbol(pProps->dwAdrType, &pSymbol));

        // Open the group
        CHECKHR(hr = _HrOpenProperty(pSymbol, &pProperty));

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // LinkAddress
        _LinkAddress(pAddress, pProperty->pGroup);

        // Dirty
        pProperty->pGroup->fDirty = TRUE;
    }

    // Changing other properties
    CHECKHR(hr = _HrSetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetProps
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetProps(HADDRESS hAddress, LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref
    pAddress = HADDRESSGET(hAddress);

    // Changing Email Address to Null
    CHECKHR(hr = _HrGetAddressProps(pProps, pAddress));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetSender
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetSender(LPADDRESSPROPS pProps)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPERTY          pProperty;
    LPPROPERTY          pSender=NULL;
    HADDRESS            hAddress=NULL;

    // Invalid Arg
    if (NULL == pProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find first from
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_FROM))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Take the first address
            if (pProperty->pGroup->pHead)
                hAddress = pProperty->pGroup->pHead->hThis;

            // Done
            break;
        }

        // Look for Sender:
        if (ISFLAGSET(pProperty->pSymbol->dwAdrType, IAT_SENDER) && NULL == pSender)
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Sender Property
            pSender = pProperty;
        }
    }

    // Is there a sender group
    if (NULL == hAddress && NULL != pSender && NULL != pSender->pGroup->pHead)
        hAddress = pSender->pGroup->pHead->hThis;

    // No Address
    if (NULL == hAddress)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get Props
    CHECKHR(hr = GetProps(hAddress, pProps));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::CountTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::CountTypes(DWORD dwAdrTypes, ULONG *pcAdrs)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;

    // Invalid Arg
    if (NULL == pcAdrs)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcAdrs = 0;

    // Loop through groups
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
        {
            // Does the Property need to be parsed ?
            CHECKHR(hr = _HrParseInternetAddress(pProperty));

            // Increment Count
            (*pcAdrs) += pProperty->pGroup->cAdrs;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               iAddress;
    LPPROPERTY          pProperty;
    LPMIMEADDRESS       pAddress;

    // Invalid Arg
    if (NULL == pList)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through groups
    CHECKHR(hr = CountTypes(dwAdrTypes, &pList->cAdrs));

    // Nothing..
    if (0 == pList->cAdrs)
        goto exit;

    // Allocate an array
    CHECKHR(hr = HrAlloc((LPVOID *)&pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS)));

    // Init
    ZeroMemory(pList->prgAdr, pList->cAdrs * sizeof(ADDRESSPROPS));

    // Fill with types...
    for (iAddress=0, pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Loop Infos...
        for (pAddress=pProperty->pGroup->pHead; pAddress!=NULL; pAddress=pAddress->pNext)
        {
            // Verify Size...
            Assert(iAddress < pList->cAdrs);

            // Zeromemory
            ZeroMemory(&pList->prgAdr[iAddress], sizeof(ADDRESSPROPS));

            // Set Desired Props
            pList->prgAdr[iAddress].dwProps = dwProps;

            // Get the Address Props
            CHECKHR(hr = _HrGetAddressProps(&pList->prgAdr[iAddress], pAddress));

            // Increment piCurrent
            iAddress++;
        }
    }

exit:
    // Failure..
    if (FAILED(hr))
    {
        g_pMoleAlloc->FreeAddressList(pList);
        ZeroMemory(pList, sizeof(ADDRESSLIST));
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::EnumTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::EnumTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT                hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;
    ADDRESSLIST            rList;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init out param in case of error
    *ppEnum = NULL;

    // Init rList
    ZeroMemory(&rList, sizeof(ADDRESSLIST));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the address lsit
    CHECKHR(hr = GetTypes(dwAdrTypes, dwProps, &rList));

    // Create a new Enumerator
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit((IMimeAddressTable *)this, 0, &rList, FALSE));

    // Clear rList
    rList.cAdrs = 0;
    rList.prgAdr = NULL;

    // Return it
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);
    if (rList.cAdrs)
        g_pMoleAlloc->FreeAddressList(&rList);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Delete
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Delete(HADDRESS hAddress)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMIMEADDRESS   pAddress;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Handle
    if (_FIsValidHAddress(hAddress) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Deref Address
    pAddress = HADDRESSGET(hAddress);

    // Unlink this address
    _UnlinkAddress(pAddress);

    // Unlink this address
    _FreeAddress(pAddress);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::DeleteTypes
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::DeleteTypes(DWORD dwAdrTypes)
{
    // Locals
    LPPROPERTY      pProperty;
    BOOL            fFound;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // While there are address types
    while(dwAdrTypes)
    {
        // Reset fFound
        fFound = FALSE;

        // Search for first delete-able address type
        for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
        {
            // Not the type I want
            if (ISFLAGSET(dwAdrTypes, pProperty->pSymbol->dwAdrType))
            {
                // We found a properyt
                fFound = TRUE;

                // Clear this address type ad being deleted
                FLAGCLEAR(dwAdrTypes, pProperty->pSymbol->dwAdrType);

                // Unlink this property
                _UnlinkProperty(pProperty);

                // Done
                break;
            }
        }

        // No Property Found
        if (FALSE == fFound)
            break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// GetFormatW
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::GetFormatW(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPWSTR *ppwszFormat)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     Variant;

    // Trace
    TraceCall("CMimePropertyContainer::GetFormatW");

    // Invalid Args
    if (NULL == ppwszFormat)
        return(TraceResult(E_INVALIDARG));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&Variant, sizeof(PROPVARIANT));

    // I want a unicode string
    Variant.vt = VT_LPWSTR;

    // Get the address format
    CHECKHR(hr = _GetFormatBase(dwAdrType, format, &Variant));

    // Return the String
    *ppwszFormat = Variant.pwszVal;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::GetFormat
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::GetFormat(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPSTR *ppszFormat)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     Variant;

    // Trace
    TraceCall("CMimePropertyContainer::GetFormat");

    // Invalid Args
    if (NULL == ppszFormat)
        return(TraceResult(E_INVALIDARG));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(&Variant, sizeof(PROPVARIANT));

    // I want a unicode string
    Variant.vt = VT_LPSTR;

    // Get the address format
    CHECKHR(hr = _GetFormatBase(dwAdrType, format, &Variant));

    // Return the String
    *ppszFormat = Variant.pszVal;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return(hr);
}
// ----------------------------------------------------------------------------
// CMimePropertyContainer::_GetFormatBase
// ----------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_GetFormatBase(DWORD dwAdrType, ADDRESSFORMAT format, 
    LPPROPVARIANT pVariant)
{
    // Locals
    HRESULT              hr=S_OK;
    CByteStream          cByteStream;
    ULONG                cAddrsWrote=0;
    LPPROPERTY           pProperty;

    // Validate
    Assert(pVariant && (VT_LPWSTR == pVariant->vt || VT_LPSTR == pVariant->vt));

    // Fill with types...
    for (pProperty=m_rAdrTable.pHead; pProperty!=NULL; pProperty=pProperty->pGroup->pNext)
    {
        // Not the type I want
        if (!ISFLAGSET(dwAdrType, pProperty->pSymbol->dwAdrType))
            continue;

        // Does the Property need to be parsed ?
        CHECKHR(hr = _HrParseInternetAddress(pProperty));

        // Tell the group object to write its display address into pStream
        CHECKHR(hr = _HrSaveAddressGroup(pProperty, &cByteStream, &cAddrsWrote, format, pVariant->vt));
     }

    // Did we write any for this address tyep ?
    if (cAddrsWrote)
    {
        // Multibyte
        if (VT_LPSTR == pVariant->vt)
        {
            // Get Text
            CHECKHR(hr = cByteStream.HrAcquireStringA(NULL, &pVariant->pszVal, ACQ_DISPLACE));
        }

        // Otherwise, unicode
        else
        {
            // Validate
            Assert(VT_LPWSTR == pVariant->vt);

            // Get Text
            CHECKHR(hr = cByteStream.HrAcquireStringW(NULL, &pVariant->pwszVal, ACQ_DISPLACE));
        }
    }
    else
        hr = MIME_E_NO_DATA;

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCSTR pszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGA;
    rValue.rStringA.pszVal = (LPSTR)pszRfc822Adr;
    rValue.rStringA.cchVal = lstrlen(pszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::AppendRfc822W
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::AppendRfc822W(DWORD dwAdrType, ENCODINGTYPE ietEncoding, LPCWSTR pwszRfc822Adr)
{
    // Locals
    HRESULT             hr=S_OK;
    MIMEVARIANT         rValue;
    LPPROPSYMBOL        pSymbol;

    // Invalid Arg
    if (NULL == pwszRfc822Adr)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // MimeVariant
    rValue.type = MVT_STRINGW;
    rValue.rStringW.pszVal = (LPWSTR)pwszRfc822Adr;
    rValue.rStringW.cchVal = lstrlenW(pwszRfc822Adr);

    // Store as a property
    CHECKHR(hr = AppendProp(pSymbol, (IET_ENCODED == ietEncoding) ? PDF_ENCODED : 0, &rValue));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822(DWORD dwAdrType, ENCODINGTYPE ietEncoding,
    LPCSTR pszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    LPWSTR              pwszData=NULL;
    PROPVARIANT         rDecoded;
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;
    CODEPAGEID          cpiAddress=CP_ACP;
    INETCSETINFO        CsetInfo;

    // Invalid Arg
    if (NULL == pszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // LocalInit
    ZeroMemory(&rDecoded, sizeof(PROPVARIANT));

    // ZeroParse
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Get codepage
    cpiAddress = _GetAddressCodePageId(NULL, IET_DECODED);

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Decode...
    if (IET_DECODED != ietEncoding)
    {
        // Setup rfc1522Info
        rRfc1522Info.fRfc1522Allowed = TRUE;
        rRfc1522Info.fAllow8bit = FALSE;
        rDecoded.vt = VT_LPWSTR;

        // Check for 1522 Encoding...
        if (SUCCEEDED(g_pInternat->DecodeHeader(NULL, pszRfc822Adr, &rDecoded, &rRfc1522Info)))
        {
            // Set the data
            pwszData = rDecoded.pwszVal;

            // Get the pCharset
            if (rRfc1522Info.hRfc1522Cset)
            {
                // Get the charset info
                if (SUCCEEDED(MimeOleGetCharsetInfo(rRfc1522Info.hRfc1522Cset, &CsetInfo)))
                {
                    // Set cpiAddress
                    cpiAddress = MimeOleGetWindowsCPEx(&CsetInfo);

                    // Can't be unicode
                    if (CP_UNICODE == cpiAddress)
                        cpiAddress = CP_ACP;
                }
            }
        }
    }

    // Otherwise, convert to unicode...
    else
    {
        // Convert
        CHECKALLOC(pwszData = PszToUnicode(cpiAddress, pszRfc822Adr));
    }

    // Initialize Parse Structure
    cAdrParse.Init(pwszData, lstrlenW(pwszData));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(*pAddress));

        // Copy the Friendly Name
        CHECKALLOC(pAddress->pszFriendly = PszToANSI(cpiAddress, cAdrParse.PszFriendly()));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszToANSI(CP_ACP, cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = IET_DECODED;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_pMoleAlloc->FreeAddressList(pList);

    // Cleanup
    MemFree(pwszData);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::ParseRfc822W
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::ParseRfc822W(DWORD dwAdrType, LPCWSTR pwszRfc822Adr, LPADDRESSLIST pList)
{
    // Locals
    HRESULT             hr=S_OK;
    LPPROPSYMBOL        pSymbol;
    LPADDRESSPROPS      pAddress;
    ULONG               cAlloc=0;
    PROPVARIANT         rDecoded = {0};
    RFC1522INFO         rRfc1522Info;
    CAddressParser      cAdrParse;

    // Invalid Arg
    if (NULL == pwszRfc822Adr || NULL == pList)
        return TrapError(E_INVALIDARG);

    // ZeroParse
    ZeroMemory(pList, sizeof(*pList));

    // Get Header
    CHECKHR(hr = g_pSymCache->HrOpenSymbol(dwAdrType, &pSymbol));

    // Setup rfc1522Info
    rRfc1522Info.hRfc1522Cset = NULL;

    // Initialize Parse Structure
    cAdrParse.Init(pwszRfc822Adr, lstrlenW(pwszRfc822Adr));

    // Parse
    while(SUCCEEDED(cAdrParse.Next()))
    {
        // Grow my address array ?
        if (pList->cAdrs + 1 > cAlloc)
        {
            // Realloc the array
            CHECKHR(hr = HrRealloc((LPVOID *)&pList->prgAdr, sizeof(ADDRESSPROPS) * (cAlloc + 5)));

            // Increment alloc size
            cAlloc += 5;
        }

        // Readability
        pAddress = &pList->prgAdr[pList->cAdrs];

        // Init
        ZeroMemory(pAddress, sizeof(*pAddress));
        
        IF_NULLEXIT(pAddress->pszFriendlyW = StrDupW(cAdrParse.PszFriendly()));
        
        IF_NULLEXIT(pAddress->pszFriendly = PszToANSI(CP_ACP, pAddress->pszFriendlyW));

        // Copy the Email Name
        CHECKALLOC(pAddress->pszEmail = PszToANSI(CP_ACP, cAdrParse.PszEmail()));

        // Charset
        if (rRfc1522Info.hRfc1522Cset)
        {
            pAddress->hCharset = rRfc1522Info.hRfc1522Cset;
            FLAGSET(pAddress->dwProps, IAP_CHARSET);
        }

        // Encoding
        pAddress->ietFriendly = IET_DECODED;

        // Set Property Mask
        FLAGSET(pAddress->dwProps, IAP_FRIENDLY | IAP_EMAIL | IAP_ENCODING | IAP_FRIENDLYW);

        // Increment Count
        pList->cAdrs++;
    }

exit:
    // Failure
    if (FAILED(hr))
        g_pMoleAlloc->FreeAddressList(pList);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMimePropertyContainer::Clone
// ----------------------------------------------------------------------------
STDMETHODIMP CMimePropertyContainer::Clone(IMimeAddressTable **ppTable)
{
    // Locals
    HRESULT              hr=S_OK;
    LPCONTAINER          pContainer=NULL;

    // InvalidArg
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppTable = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Ask the container to clone itself
    CHECKHR(hr = Clone(&pContainer));

    // Bind to the IID_IMimeHeaderTable View
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeAddressTable, (LPVOID *)ppTable));

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::HrGenerateFileName
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::_HrGenerateFileName(LPCWSTR pszSuggest, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszDefExt=NULL;
    LPWSTR      pszData=NULL;
    LPWSTR      pszFree=NULL;
    LPCSTR      pszCntType=NULL;
    LPPROPERTY  pProperty;
    MIMEVARIANT rSource;

    // Compute Content Type
    pszCntType = PSZDEFPROPSTRINGA(m_prgIndex[PID_HDR_CNTTYPE], STR_MIME_TEXT_PLAIN);

    // No suggestion yet
    if (NULL == pszSuggest)
    {
        // Get as Unicode
        rSource.type = MVT_STRINGW;

        // Compute Subject as suggested base file name...
        if (SUCCEEDED(GetProp(SYM_HDR_SUBJECT, 0, &rSource)))
        {
            // Save as new suggest and free it later
            pszSuggest = pszFree = rSource.rStringW.pszVal;
        }

        // If still nothing, then get the content-description header
        if (NULL == pszSuggest)
        {
            // Get Content-Description as unicode
            if (SUCCEEDED(GetProp(SYM_HDR_CNTDESC, 0, &rSource)))
            {
                // Save as new suggest and free it later
                pszSuggest = pszFree = rSource.rStringW.pszVal;
            }
        }
    }

    // message/rfc822
    if (lstrcmpi(pszCntType, (LPSTR)STR_MIME_MSG_RFC822) == 0)
    {
        // If there is a news header, use c_szDotNws
        if (ISFLAGSET(m_dwState, COSTATE_RFC822NEWS))
            pszDefExt = (LPWSTR)c_wszDotNws;
        else
            pszDefExt = (LPWSTR)c_wszDotEml;

        // I will never lookup message/rfc822 extension
        pszCntType = NULL;
    }

    // message/disposition-notification
    else if (lstrcmpi(pszCntType, "message/disposition-notification") == 0)
        pszDefExt = (LPWSTR)c_wszDotTxt;

    // Still no default
    else if (StrCmpNI(pszCntType, STR_CNT_TEXT, lstrlen(STR_CNT_TEXT)) == 0)
        pszDefExt = (LPWSTR)c_wszDotTxt;

    // Generate a filename based on the content type...
    CHECKHR(hr = MimeOleGenerateFileNameW(pszCntType, pszSuggest, pszDefExt, &pszData));

    // Setup rSource
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));
    rSource.type = MVT_STRINGW;
    rSource.rStringW.pszVal = pszData;
    rSource.rStringW.cchVal = lstrlenW(pszData);

    // Return per user request
    CHECKHR(hr = HrConvertVariant(SYM_ATT_GENFNAME, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enumhead.h ===
// --------------------------------------------------------------------------------
// Enumhead.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENUMHEAD_H
#define __ENUMHEAD_H

// --------------------------------------------------------------------------------
// CMimeEnumHeaderRows
// --------------------------------------------------------------------------------
class CMimeEnumHeaderRows : public IMimeEnumHeaderRows
{
public:
    // ---------------------------------------------------------------------------
    // Construction
    // ---------------------------------------------------------------------------
    CMimeEnumHeaderRows(void);
    ~CMimeEnumHeaderRows(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cRows, LPENUMHEADERROW prgRow, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cRows);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumHeaderRows **ppEnum);
    STDMETHODIMP Count(ULONG *pcRows);

    // ---------------------------------------------------------------------------
    // CMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    HRESULT HrInit(ULONG ulIndex, DWORD dwFlags, ULONG cRows, LPENUMHEADERROW prgRow, BOOL fDupArray);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;     // Reference count
    DWORD               m_dwFlags;  // Flags (HEADERFLAGS from mimeole.idl)
    ULONG               m_ulIndex;  // Current enum index
    ULONG               m_cRows;    // Number of lines in prgRow
    LPENUMHEADERROW     m_prgRow;   // Array of header lines being enumerated
    CRITICAL_SECTION    m_cs;       // Critical Section
};

#endif // __ENUMHEAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enumprop.h ===
// --------------------------------------------------------------------------------
// Enumprop.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ENUMPROP_H
#define __ENUMPROP_H

// --------------------------------------------------------------------------------
// CMimeEnumProperties
// --------------------------------------------------------------------------------
class CMimeEnumProperties : public IMimeEnumProperties
{
public:
    // ---------------------------------------------------------------------------
    // Construction
    // ---------------------------------------------------------------------------
    CMimeEnumProperties(void);
    ~CMimeEnumProperties(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMimeEnumHeaderRows members
    // ---------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cProps, LPENUMPROPERTY prgProp, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cProps);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumProperties **ppEnum);
    STDMETHODIMP Count(ULONG *pcProps);

    // ---------------------------------------------------------------------------
    // CMimeEnumProperties members
    // ---------------------------------------------------------------------------
    HRESULT HrInit(ULONG ulIndex, ULONG cProps, LPENUMPROPERTY prgProp, BOOL fDupArray);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;     // Reference count
    ULONG               m_ulIndex;  // Current enum index
    ULONG               m_cProps;   // Number of lines in prgRow
    LPENUMPROPERTY      m_prgProp;  // Array of header lines being enumerated
    CRITICAL_SECTION    m_cs;       // Critical Section

};

#endif // __ENUMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\enumprop.cpp ===
// --------------------------------------------------------------------------------
// EnumProp.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "enumprop.h"
#include "olealloc.h"
#include "demand.h"

// ---------------------------------------------------------------------------
// CMimeEnumProperties::CMimeEnumProperties
// ---------------------------------------------------------------------------
CMimeEnumProperties::CMimeEnumProperties(void)
{
    DllAddRef();
    m_cRef = 1;
    m_ulIndex = 0;
    m_cProps = 0;
    m_prgProp = NULL;
    InitializeCriticalSection(&m_cs);
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::~CMimeEnumProperties
// ---------------------------------------------------------------------------
CMimeEnumProperties::~CMimeEnumProperties(void)
{
    g_pMoleAlloc->FreeEnumPropertyArray(m_cProps, m_prgProp, TRUE);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeEnumProperties *)this;
    else if (IID_IMimeEnumProperties == riid)
        *ppv = (IMimeEnumProperties *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumProperties::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumProperties::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Next
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Next(ULONG cWanted, LPENUMPROPERTY prgProp, ULONG *pcFetched)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFetch=0, 
                    ulIndex=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgProp || NULL == prgProp)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cProps - m_ulIndex);
    if (0 == cFetch)
        goto exit;

    // Init the array
    ZeroMemory(prgProp, sizeof(ENUMPROPERTY) * cWanted);

    // Copy cWanted
    for (ulIndex=0; ulIndex<cFetch; ulIndex++)
    {
        // Set the information
        prgProp[ulIndex].hRow = m_prgProp[m_ulIndex].hRow;

        // Set dwPropId
        prgProp[ulIndex].dwPropId = m_prgProp[m_ulIndex].dwPropId;

        // Not NONAME
        if (m_prgProp[m_ulIndex].pszName)
        {
            // Dup It
            CHECKALLOC(prgProp[ulIndex].pszName = PszDupA(m_prgProp[m_ulIndex].pszName));
        }

        // Goto Next
        m_ulIndex++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Failure
    if (FAILED(hr) && prgProp)
        g_pMoleAlloc->FreeEnumPropertyArray(cFetch, prgProp, FALSE);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Skip
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_ulIndex + cSkip) >= m_cProps) || NULL == m_prgProp)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_ulIndex += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Reset
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Reset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reset
    m_ulIndex = 0;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Clone
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Clone(IMimeEnumProperties **ppEnum)
{
    // Locals
    HRESULT              hr=S_OK;
    CMimeEnumProperties *pEnum=NULL;

    // check params
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Init
    *ppEnum = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Allocate
    CHECKALLOC(pEnum = new CMimeEnumProperties());

    // Init
    CHECKHR(hr = pEnum->HrInit(m_ulIndex, m_cProps, m_prgProp, TRUE));

    // Retrun
    (*ppEnum) = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::Count
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeEnumProperties::Count(ULONG *pcProps)
{
    // check params
    if (NULL == pcProps)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set return
    *pcProps = m_cProps;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ---------------------------------------------------------------------------
// CMimeEnumProperties::HrInit
// ---------------------------------------------------------------------------
HRESULT CMimeEnumProperties::HrInit(ULONG ulIndex, ULONG cProps, LPENUMPROPERTY prgProp, BOOL fDupArray)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Save Lines
    m_ulIndex = ulIndex;
    m_cProps = cProps;

    // Are there lines ...
    if (m_cProps)
    {
        // Duplicate the Array
        if (fDupArray)
        {
            // Allocate memory
            CHECKALLOC(m_prgProp = (LPENUMPROPERTY)g_pMalloc->Alloc(m_cProps * sizeof(ENUMPROPERTY)));

            // ZeroInit
            ZeroMemory(m_prgProp, sizeof(ENUMPROPERTY) * m_cProps);

            // Loop
            for (i=0; i<m_cProps; i++)
            {
                // Set the information
                m_prgProp[i].hRow = prgProp[i].hRow;

                // Set dwPropId
                m_prgProp[i].dwPropId = prgProp[i].dwPropId;

                // Not NONAME
                if (prgProp[i].pszName)
                {
                    // Dup It
                    CHECKALLOC(m_prgProp[i].pszName = PszDupA(prgProp[i].pszName));
                }
            }
        }
        
        // Otherwise, just assume this array
        else
            m_prgProp = prgProp;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdylock.cpp ===
// --------------------------------------------------------------------------------
// Ibdylock.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifndef WIN16
#include "ibdylock.h"
#endif // !WIn16
#include "stmlock.h"
#include "booktree.h"
#ifdef WIN16
#include "ibdylock.h"
#endif // WIn16
#include "demand.h"

// --------------------------------------------------------------------------------
// CBodyLockBytes::CBodyLockBytes
// --------------------------------------------------------------------------------
CBodyLockBytes::CBodyLockBytes(ILockBytes *pLockBytes, LPTREENODEINFO pNode)
{
    // Invalid ARg
    Assert(pLockBytes && pNode);

    // Set Initialize Ref Count and State
    m_cRef = 1;
    m_dwState = 0;

    // AddRef the LockBytes
    m_pLockBytes = pLockBytes;
    m_pLockBytes->AddRef();

    // Save State
    FLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE);

    // Save the bind state
    m_bindstate = pNode->bindstate;

    // Save body start and body end..
    Assert(pNode->cbBodyStart <= pNode->cbBodyEnd);

    // Save Body Start
#ifdef MAC
    ULISet32(m_uliBodyStart, pNode->cbBodyStart);
    ULISet32(m_uliBodyEnd, pNode->cbBodyEnd);

    // This condition is here to insure that we don't have a problem...
    if (m_uliBodyStart.LowPart > m_uliBodyEnd.LowPart)
        m_uliBodyStart.LowPart = m_uliBodyEnd.LowPart;
#else   // !MAC
    m_uliBodyStart.QuadPart = pNode->cbBodyStart;
    m_uliBodyEnd.QuadPart = pNode->cbBodyEnd;

    // This condition is here to insure that we don't have a problem...
    if (m_uliBodyStart.QuadPart > m_uliBodyEnd.QuadPart)
        m_uliBodyStart.QuadPart = m_uliBodyEnd.QuadPart;
#endif  // MAC

    // Initialize the CriticalSection
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::~CBodyLockBytes
// --------------------------------------------------------------------------------
CBodyLockBytes::~CBodyLockBytes(void)
{
    SafeRelease(m_pLockBytes);
    Assert(!ISFLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE));
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyLockBytes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_ILockBytes == riid)
        *ppv = (ILockBytes *)this;
    else if (IID_CBodyLockBytes == riid)
        *ppv = (CBodyLockBytes *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyLockBytes::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyLockBytes::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::ReadAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CBodyLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CBodyLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbGet;
    ULONG           cbRead;
    ULARGE_INTEGER  uliActualOffset;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Reading from ILockBytes...
    Assert(m_pLockBytes);

#ifdef MAC
    // Compute Actual offset
    AssertSz(m_uliBodyStart.HighPart >= 0, "How can the start be negative??");
    ULISet32(uliActualOffset, m_uliBodyStart.LowPart);

    AssertSz((uliActualOffset.LowPart + ulOffset.LowPart) >= uliActualOffset.LowPart,
                    "Oops! We don't handle backwards reads correctly!");

    uliActualOffset.LowPart += ulOffset.LowPart;

    // Compute amount to read
    cbGet = min(cb, m_uliBodyEnd.LowPart - uliActualOffset.LowPart);
#else   // !MAC
    // Compute Actual offset
    uliActualOffset.QuadPart = ulOffset.QuadPart + m_uliBodyStart.QuadPart;

    // Compute amount to read
    cbGet = (ULONG)min(cb, m_uliBodyEnd.QuadPart - uliActualOffset.QuadPart);
#endif  // MAC

    // Read a block of data...
    CHECKHR(hr = m_pLockBytes->ReadAt(uliActualOffset, pv, cbGet, &cbRead));

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

    // E_PENDING
    if (0 == cbRead && BINDSTATE_COMPLETE != m_bindstate)
    {
        hr = TrapError(E_PENDING);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(pstatstg, sizeof(STATSTG));

    // Reading from ILockBytes...
    pstatstg->type = STGTY_LOCKBYTES;

    // Set Size
#ifdef MAC
    AssertSz(0 == m_uliBodyEnd.HighPart, "We have too big of a file!");
    AssertSz(0 == m_uliBodyStart.HighPart, "We have too big of a file!");
    ULISet32(pstatstg->cbSize, (m_uliBodyEnd.LowPart - m_uliBodyStart.LowPart));
#else   // !MAC
    pstatstg->cbSize.QuadPart = m_uliBodyEnd.QuadPart - m_uliBodyStart.QuadPart;
#endif  // MAC

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::HrHandsOffStorage
// --------------------------------------------------------------------------------
HRESULT CBodyLockBytes::HrHandsOffStorage(void)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pstmTemp=NULL;
    ULARGE_INTEGER  uliCopy;
    BYTE            rgbBuffer[4096];
    ULONG           cbRead;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If I live in the tree, copy data to temporary location...
    if (ISFLAGSET(m_dwState, BODYLOCK_HANDSONSTORAGE) && BINDSTATE_COMPLETE == m_bindstate)
    {
        // If more than one reference count
        if (m_cRef > 1)
        {
            // Create Temp Stream
            CHECKHR(hr = CreateTempFileStream(&pstmTemp));

            // Set offset
#ifdef MAC
            ULISet32(uliCopy, 0);
#else   // !MAC
            uliCopy.QuadPart = 0;
#endif  // MAC

            // Copy m_pLockBytes to pstmTemp
            while(1)
            {
                // Read
                CHECKHR(hr = ReadAt(uliCopy, rgbBuffer, sizeof(rgbBuffer), &cbRead));

                // Done
                if (0 == cbRead)
                    break;

                // Write to stream
                CHECKHR(hr = pstmTemp->Write(rgbBuffer, cbRead, NULL));

                // Increment offset
#ifdef MAC
                uliCopy.LowPart += cbRead;
#else   // !MAC
                uliCopy.QuadPart += cbRead;
#endif  // MAC
            }

            // Kill offsets, but maintain bodyend for stat command and Size esitmates
#ifdef MAC
            AssertSz(0 == m_uliBodyEnd.HighPart, "We have too big of a file!");
            m_uliBodyEnd.LowPart -= m_uliBodyStart.LowPart;
            ULISet32(m_uliBodyStart, 0);
#else   // !MAC
            m_uliBodyEnd.QuadPart -= m_uliBodyStart.QuadPart;
            m_uliBodyStart.QuadPart = 0;
#endif  // MAC

            // Rewind and commit
            CHECKHR(hr = pstmTemp->Commit(STGC_DEFAULT));

            // Release current lockbytes
            SafeRelease(m_pLockBytes);

            // New CBodyLockBytes
            CHECKALLOC(m_pLockBytes = new CStreamLockBytes(pstmTemp));
        }

        // Remove lives in tree flag
        FLAGCLEAR(m_dwState, BODYLOCK_HANDSONSTORAGE);
    }

exit:
    // Cleanup
    SafeRelease(pstmTemp);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyLockBytes::OnDataAvailable
// --------------------------------------------------------------------------------
void CBodyLockBytes::OnDataAvailable(LPTREENODEINFO pNode)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Bind Complete
    m_bindstate = pNode->bindstate;

    // Save body start and body end..
#ifdef MAC
    Assert(m_uliBodyStart.LowPart <= pNode->cbBodyEnd);

    // Save start and End
    ULISet32(m_uliBodyEnd, pNode->cbBodyEnd);
#else   // !MAC
    Assert(m_uliBodyStart.QuadPart <= pNode->cbBodyEnd);

    // Save start and End
    m_uliBodyEnd.QuadPart = pNode->cbBodyEnd;
#endif  // MAC

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdylock.h ===
// --------------------------------------------------------------------------------
// Ibdylock.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IBDYLOCK_H
#define __IBDYLOCK_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef enum tagBINDNODESTATE BINDNODESTATE;

// --------------------------------------------------------------------------------
// CBodyLockBytes - {62A83703-52A2-11d0-8205-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CBodyLockBytes, 0x62a83703, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// BODYLOCK_xxx States
// --------------------------------------------------------------------------------
#define BODYLOCK_HANDSONSTORAGE     FLAG01

// -----------------------------------------------------------------------------
// Wraps a MIME stream object, and provides thread safe access to the 
// a shared stream. When this object wraps a message stream, it is owned by
// IMimeBody
// -----------------------------------------------------------------------------
class CBodyLockBytes : public ILockBytes
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBodyLockBytes(ILockBytes *pLockBytes, LPTREENODEINFO pNode);
    ~CBodyLockBytes(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // ILockBytes methods
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead);
#else
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead);
#endif // !WIN16
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP SetSize(ULARGE_INTEGER cb) {
        return E_NOTIMPL; }
    STDMETHODIMP Flush(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
#ifndef WIN16
    STDMETHODIMP WriteAt(ULARGE_INTEGER, void const *, ULONG, ULONG *) {
#else
    STDMETHODIMP WriteAt(ULARGE_INTEGER, void const HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }

    // -------------------------------------------------------------------------
    // CMimeLockBytes methods
    // -------------------------------------------------------------------------
    HRESULT HrHandsOffStorage(void);
    void OnDataAvailable(LPTREENODEINFO pNode);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;             // Reference count
    DWORD               m_dwState;          // State
    BINDNODESTATE       m_bindstate;        // Current bind state
    ULARGE_INTEGER      m_uliBodyStart;     // Offset to start of body in m_pLockBytes
    ULARGE_INTEGER      m_uliBodyEnd;       // Offset to end of body in m_pLockBytes
    ILockBytes         *m_pLockBytes;       // Actual lockbytes implementation (CMimeMessageTree or CStreamLockBytes)
    CRITICAL_SECTION    m_cs;               // Critical Section for m_pStream
};

#endif // __IBDYLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdystm.cpp ===
// --------------------------------------------------------------------------------
// Ibdystm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "ibdystm.h"
#include "dllmain.h"
#include "inetconv.h"
#include "internat.h"
#include "symcache.h"
#include "bookbody.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Encoding Type Names
// --------------------------------------------------------------------------------
const ENCODINGMAP g_rgEncodingMap[IET_LAST] = {
    { IET_BINARY,       STR_ENC_BINARY,     TRUE   },
    { IET_BASE64,       STR_ENC_BASE64,     TRUE   },
    { IET_UUENCODE,     STR_ENC_UUENCODE,   TRUE   },
    { IET_QP,           STR_ENC_QP,         TRUE   },
    { IET_7BIT,         STR_ENC_7BIT,       TRUE   },
    { IET_8BIT,         STR_ENC_8BIT,       TRUE   },
    { IET_INETCSET,     NULL,               FALSE  },
    { IET_UNICODE,      NULL,               FALSE  },
    { IET_RFC1522,      NULL,               FALSE  },
    { IET_ENCODED,      NULL,               FALSE  },
    { IET_CURRENT,      NULL,               FALSE  },
    { IET_UNKNOWN,      NULL,               FALSE  },
    { IET_BINHEX40,     STR_ENC_BINHEX40,   TRUE   }
};

// --------------------------------------------------------------------------------
// Document Covnert Map
// --------------------------------------------------------------------------------
const CONVERSIONMAP g_rgConversionMap[IET_LAST] = {
    { DCT_NONE,   DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_ENCODE, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_ENCODE }, // IET_BINARY
    { DCT_DECODE, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_BASE64
    { DCT_DECODE, DCT_DECENC, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_UUENCODE
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_QP
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_7BIT
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_DECENC }, // IET_8BIT
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_INETCSET
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_UNICODE
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_RFC1522
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_ENCODED
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_CURRENT 
    { DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,   DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_UNKNOWN
    { DCT_DECODE, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_DECENC, DCT_NONE,  DCT_NONE,  DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE, DCT_NONE   }, // IET_BINHEX40
    // BINARY     BASE64      UUENCODE    QP          7BIT        8BIT        INETCSET   UNICODE    RFC1522   ENCODED   CURRENT   UNKNOWN   BINHEX40
};

// --------------------------------------------------------------------------------
// FIsValidBodyEncoding
// --------------------------------------------------------------------------------
BOOL FIsValidBodyEncoding(ENCODINGTYPE ietEncoding)
{
    // Try to find the correct body encoding
    for (ULONG i=0; i<IET_LAST; i++)
    {
        // Is this it?
        if (ietEncoding == g_rgEncodingMap[i].ietEncoding)
            return g_rgEncodingMap[i].fValidBodyEncoding;
    }

    // Failure
    return FALSE;
}

// --------------------------------------------------------------------------------
// CBodyStream::CBodyStream
// --------------------------------------------------------------------------------
CBodyStream::CBodyStream(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pszFileName = NULL;
    m_uliIntOffset.QuadPart = 0;
    m_uliIntSize.QuadPart = 0;
    m_liLastWrite.QuadPart = 0;
    m_pLockBytes = NULL;
    m_dctConvert = DCT_NONE;
    m_pEncoder = NULL;
    m_pDecoder = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBodyStream::~CBodyStream
// --------------------------------------------------------------------------------
CBodyStream::~CBodyStream(void)
{
    SafeMemFree(m_pszFileName);
    SafeRelease(m_pLockBytes);
    SafeRelease(m_pEncoder);
    SafeRelease(m_pDecoder);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CBodyStream::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else if (IID_CBodyStream == riid)
        *ppv = (CBodyStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBodyStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyStream::AddRef(void)
{    
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBodyStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBodyStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CBodyStream::GetEncodeWrapInfo
// --------------------------------------------------------------------------------
void CBodyStream::GetEncodeWrapInfo(LPCONVINITINFO pInitInfo, LPMESSAGEBODY pBody)
{
    // Locals
    PROPVARIANT     rOption;

    // Export 7bit or 8bit
    if (IET_7BIT != pInitInfo->ietEncoding && IET_8BIT != pInitInfo->ietEncoding)
        return;

    // OID_WRAP_BODY_TEXT
    if (FAILED(pBody->GetOption(OID_WRAP_BODY_TEXT, &rOption)) || FALSE == rOption.boolVal)
        return;

    // Get Wrapping Width
    if (FAILED(pBody->GetOption(OID_CBMAX_BODY_LINE, &rOption)))
        rOption.ulVal = DEF_CBMAX_BODY_LINE;

    // We are wrapping
    pInitInfo->dwFlags |= ICF_WRAPTEXT;

    // Max Line
    pInitInfo->cchMaxLine = rOption.ulVal;

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CBodyStream::GetCodePageInfo
// --------------------------------------------------------------------------------
void CBodyStream::GetCodePageInfo(LPCONVINITINFO pInitInfo, BOOL fDoCharset, CODEPAGEID cpiSource, CODEPAGEID cpiDest)
{
    // Decide if we should do a code page conversion
    if (TRUE == fDoCharset && cpiSource != cpiDest)
    {
        // No Conversions between 28591 and 1252
        if ((1252 == cpiSource || 28591 == cpiSource) && (1252 == cpiDest || 28591 == cpiDest))
        {
            // Do a code page conversion
            FLAGCLEAR(pInitInfo->dwFlags, ICF_CODEPAGE);
        }

        // Can the conversion between the internal and external code pages be performed ?
        else if (g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK)
        {
            // Do a code page conversion
            FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);
        }

        // Otherwise...
        else
        {
            // Time to Whine
            DOUTL(4, "MLANG.DLL Can't Convert CodePage %d to CodePage %d\n", cpiSource, cpiDest);

            // If cpiSource is unicode and cpiDest is not unicode, we need to set cpiDest to a legal multibyte code page
            if (CP_UNICODE == cpiSource && CP_UNICODE != cpiDest)
            {
                // Default to system acp
                cpiDest = GetACP();

                // We better be able to do this conversion...
                Assert(g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK);

                // Do the conversion...
                FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);

                // Whine some more
                DOUTL(4, "Modified: CODEPAGE(%d -> %d, 0x%0X -> 0x%0X)\n", cpiSource, cpiDest, cpiSource, cpiDest);
            }

            // multibyte to unicode
            else if (CP_UNICODE != cpiSource && CP_UNICODE == cpiDest)
            {
                // Default to system acp
                cpiSource = GetACP();

                // We better be able to do this conversion...
                Assert(g_pInternat->CanConvertCodePages(cpiSource, cpiDest) == S_OK);

                // Do the conversion...
                FLAGSET(pInitInfo->dwFlags, ICF_CODEPAGE);

                // Whine some more
                DOUTL(4, "Modified: CODEPAGE(%d -> %d, 0x%0X -> 0x%0X)\n", cpiSource, cpiDest, cpiSource, cpiDest);
            }
        }
    }

    // Set Source Code Page
    pInitInfo->cpiSource = cpiSource;

    // Set Destination Code Page
    pInitInfo->cpiDest = cpiDest;

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CBodyStream::ComputeCodePageMapping
// --------------------------------------------------------------------------------
void CBodyStream::ComputeCodePageMapping(LPBODYSTREAMINIT pInitInfo)
{
    // We should always have a charset...
    Assert(pInitInfo->pCharset && g_pInternat);

    // External is IET_UNICODE
    if (IET_UNICODE == pInitInfo->ietExternal)
    {
        pInitInfo->cpiExternal = CP_UNICODE;
        pInitInfo->ietExternal = IET_BINARY;
    }

    // External is in Windows CodePage
    else if (IET_BINARY == pInitInfo->ietExternal)
    {
        // RAID-32777: User does not want unicode, so make sure we return multibyte
        pInitInfo->cpiExternal = (CP_UNICODE == pInitInfo->pCharset->cpiWindows) ? GetACP() : pInitInfo->pCharset->cpiWindows;

        // Map outof autodetect
        if (CP_JAUTODETECT == pInitInfo->cpiExternal)
            pInitInfo->cpiExternal = 932;
    }

    // External is in Internet CodePage
    else
    {
        // RAID-25300 - FE-J:Athena: Newsgroup article and mail sent with charset=_autodetect
        pInitInfo->cpiExternal = (CP_JAUTODETECT == pInitInfo->pCharset->cpiInternet) ? 50220 : pInitInfo->pCharset->cpiInternet;

        // Better not be unicode - Removed because of Raid 40228
        /// Assert(CP_UNICODE != pInitInfo->cpiExternal);

        // Adjust ietExternal
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pInitInfo->ietExternal))
            pInitInfo->ietExternal = IET_BINARY;
    }

    // Internal is IET_UNICODE
    if (IET_UNICODE == pInitInfo->ietInternal)
    {
        pInitInfo->cpiInternal = CP_UNICODE;
        pInitInfo->ietInternal = IET_BINARY;
    }

    // Internal is in Windows CodePage
    else if (IET_BINARY == pInitInfo->ietInternal)
    {
        // The internal data is not unicode so make sure we don't say its unicode
        pInitInfo->cpiInternal = (CP_UNICODE == pInitInfo->pCharset->cpiWindows) ? GetACP() : pInitInfo->pCharset->cpiWindows;
    }

    // Internal is in Internet CodePage
    else
    {
        // Internet CodePage
        pInitInfo->cpiInternal = pInitInfo->pCharset->cpiInternet;

        // Adjust ietExternal
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pInitInfo->ietInternal))
            pInitInfo->ietInternal = IET_BINARY;
    }
}

// --------------------------------------------------------------------------------
// CBodyStream::GenerateDefaultMacBinaryHeader
// --------------------------------------------------------------------------------
void CBodyStream::GenerateDefaultMacBinaryHeader(LPMACBINARY pMacBinary)
{
    // ZeroInit
    ZeroMemory(pMacBinary, sizeof(MACBINARY));
}

// --------------------------------------------------------------------------------
// CBodyStream::HrInitialize
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrInitialize(LPBODYSTREAMINIT pInitInfo, LPMESSAGEBODY pBody)
{
    // Locals
    HRESULT         hr=S_OK;
    STATSTG         rStat;
    BOOL            fDoCharset=FALSE;
    BOOL            fIsText;
    CONVINITINFO    rEncodeInit;
    CONVINITINFO    rDecodeInit;
    PROPVARIANT     rVariant;

    // Parameters
    Assert(pBody);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Code Page Mappings
    ComputeCodePageMapping(pInitInfo);

    // Debug
    //DebugTrace("IBodyStream: ENCODING(%s -> %s) CODEPAGE(%d -> %d)\n", g_rgEncodingMap[pInitInfo->ietInternal].pszName,g_rgEncodingMap[pInitInfo->ietExternal].pszName, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

    // Initialize Convert Init Structs
    ZeroMemory(&rEncodeInit, sizeof(CONVINITINFO));
    rEncodeInit.fEncoder = TRUE;
    ZeroMemory(&rDecodeInit, sizeof(CONVINITINFO));
    rDecodeInit.fEncoder = FALSE;

    // Get the class id of this stream
    rVariant.vt = VT_LPSTR;
    if (SUCCEEDED(pBody->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant)))
        m_pszFileName = rVariant.pszVal;

    // Lets test my IBodyStream::Stat function
#ifdef DEBUG
    Stat(&rStat, STATFLAG_NONAME);
#endif

    // Get LockBytes from the body
    hr = pBody->HrGetLockBytes(&m_pLockBytes);
    if (FAILED(hr) && MIME_E_NO_DATA != hr)
    {
        TrapError(hr);
        goto exit;
    }

    // Else, ok
    hr = S_OK;

    // Otherwise, query the size
    if (m_pLockBytes)
    {
        // Get the size of the lockbytes object...
        CHECKHR(hr = m_pLockBytes->Stat(&rStat, STATFLAG_NONAME));

        m_uliIntSize.QuadPart = rStat.cbSize.QuadPart;
    }

    // Special Case for IET_CURRENT
    if (IET_CURRENT == pInitInfo->ietExternal)
    {
        // No Conversion
        m_dctConvert = DCT_NONE;

        // Done
        goto exit;
    }

    // Otheriwse, lookup conversion type
    Assert(FIsValidBodyEncoding(pInitInfo->ietInternal) && FIsValidBodyEncoding(pInitInfo->ietExternal));
    m_dctConvert = (DOCCONVTYPE)(g_rgConversionMap[pInitInfo->ietInternal].rgDestType[pInitInfo->ietExternal]);

    // If we have data...
    if (m_uliIntSize.QuadPart > 0)
    {
        // Is Text
        fIsText = (pBody->IsContentType(STR_CNT_TEXT, NULL) == S_OK) ? TRUE : FALSE;

        // Get the character set for this body...
        if (fIsText)
        {
            // Raid-6832: Mail : We fail to display Plain Text messages when they have a name parameter in the Content Type header
            // If multibyte to unicode or unicode to multibyte, then we must do a charset translation
            if ((CP_UNICODE == pInitInfo->cpiInternal && CP_UNICODE != pInitInfo->cpiExternal) ||
                (CP_UNICODE != pInitInfo->cpiInternal && CP_UNICODE == pInitInfo->cpiExternal))
                fDoCharset = TRUE;

            // If Tagged with a Character Set, then always apply charset dencode/encode
            else if (pBody->IsType(IBT_CSETTAGGED) == S_OK)
                fDoCharset = TRUE;

            // Otherwise, if its not an attachment, then always apply charset dencode/encode
            else if (pBody->IsType(IBT_AUTOATTACH) == S_OK || pBody->IsType(IBT_ATTACHMENT) == S_FALSE)
                fDoCharset = TRUE;
        }

        // If currently no conversion, see if we are translating between code pages
        if (fDoCharset && DCT_NONE == m_dctConvert && pInitInfo->cpiInternal != pInitInfo->cpiExternal)
            m_dctConvert = DCT_DECODE;

        // Encode
        if (DCT_ENCODE == m_dctConvert)
        {
            // Do Code Page Convsion
            GetCodePageInfo(&rEncodeInit, fDoCharset, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

            // Remove NBSPs
            if ((TRUE == fIsText) && (CP_UNICODE == pInitInfo->cpiInternal) && (TRUE == pInitInfo->fRemoveNBSP))
                rEncodeInit.dwFlags |= ICF_KILLNBSP;

            // Set Encoding Type
            rEncodeInit.ietEncoding = pInitInfo->ietExternal;

            // BinHex Encoding...
            if (IET_BINHEX40 == rEncodeInit.ietEncoding)
            {
                // Locals
                PROPVARIANT rOption;

                // Init rOption
                rOption.vt = VT_BLOB;
                rOption.blob.cbSize = sizeof(MACBINARY);
                rOption.blob.pBlobData = (LPBYTE)&rEncodeInit.rMacBinary;

                GenerateDefaultMacBinaryHeader(&rEncodeInit.rMacBinary);
            }

            // GetEncodeWrapInfo
            if (fIsText)
                GetEncodeWrapInfo(&rEncodeInit, pBody);

            // Create Internet Encoder
            CHECKHR(hr = HrCreateInternetConverter(&rEncodeInit, &m_pEncoder));
        }

        // Decode
        else if (DCT_DECODE == m_dctConvert)
        {
            // Do Code Page Convsion
            GetCodePageInfo(&rDecodeInit, fDoCharset, pInitInfo->cpiInternal, pInitInfo->cpiExternal);

            // Remove NBSPs
            if ((TRUE == fIsText) && (CP_UNICODE == pInitInfo->cpiInternal) && (TRUE == pInitInfo->fRemoveNBSP))
                rDecodeInit.dwFlags |= ICF_KILLNBSP;

            // Set Encoding Type
            rDecodeInit.ietEncoding = pInitInfo->ietInternal;

            // BinHex Dencoding...
            if (IET_BINHEX40 == rDecodeInit.ietEncoding)
            {
                // Locals
                PROPVARIANT rOption;
            
                // OID_SHOW_MACBINARY
                if (SUCCEEDED(pBody->GetOption(OID_SHOW_MACBINARY, &rOption)))
                {
                    rDecodeInit.fShowMacBinary = rOption.boolVal;
                }
            }
            
            // Create Internet DeCoder
            CHECKHR(hr = HrCreateInternetConverter(&rDecodeInit, &m_pDecoder));
        }

        // Decode -> Encode
        else if (DCT_DECENC == m_dctConvert)
        {
            // Do Code Page Convsion
            if (pInitInfo->cpiInternal != pInitInfo->cpiExternal)
            {
                // Internal -> Unicode
                GetCodePageInfo(&rDecodeInit, fDoCharset, pInitInfo->cpiInternal, CP_UNICODE);

                // Unicode -> Extnernal
                GetCodePageInfo(&rEncodeInit, fDoCharset, CP_UNICODE, pInitInfo->cpiExternal);
            }

            // Set Encoding Type
            rDecodeInit.ietEncoding = pInitInfo->ietInternal;

            // Create Internet Decoder
            CHECKHR(hr = HrCreateInternetConverter(&rDecodeInit, &m_pDecoder));

            // Set Encoding Type
            rEncodeInit.ietEncoding = pInitInfo->ietExternal;

            // GetEncodeWrapInfo
            if (fIsText)
                GetEncodeWrapInfo(&rEncodeInit, pBody);

            // Create Internet Encoder
            CHECKHR(hr = HrCreateInternetConverter(&rEncodeInit, &m_pEncoder));
        }

        // No Conversion
        else
            Assert(DCT_NONE == m_dctConvert);
    }

    // Otherwise, handle zero length data
    else
    {
        // Converting to IET_UUENCODE
        if (IET_UUENCODE == pInitInfo->ietExternal)
        {
            // Save Size
            m_uliIntOffset.QuadPart = m_uliIntSize.QuadPart = lstrlen(c_szUUEncodeZeroLength);

            // Single byte
            CHECKHR(hr = m_cVirtualStream.Write(c_szUUEncodeZeroLength, lstrlen(c_szUUEncodeZeroLength), NULL));

            // Rewind that stream
            HrRewindStream(&m_cVirtualStream);

            // Change the DC type to any other type
            m_dctConvert = DCT_ENCODE;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertDataLast
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertDataLast(void)
{
    // Locals
    HRESULT hr=S_OK;
    HRESULT hrWarnings=S_OK;

    // Handle Conversion type
    switch(m_dctConvert)
    {
    // ----------------------------------------------------------------------------
    case DCT_ENCODE:
        // Encode
        CHECKHR(hr = m_pEncoder->HrInternetEncode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECODE:
        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pDecoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECENC:
        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrWriteConverted(m_pEncoder));

        // Convert
        CHECKHR(hr = m_pEncoder->HrInternetEncode(TRUE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    default:
        AssertSz(FALSE, "I should be fired and shot if this line of code executes.");
        break;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertData
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertData(LPBLOB pConvert)
{
    // Locals
    HRESULT hr=S_OK;
    HRESULT hrWarnings=S_OK;

    // Handle Conversion type
    switch(m_dctConvert)
    {
    // ----------------------------------------------------------------------------
    case DCT_ENCODE:
        // Fill Buffer
        CHECKHR(hr = m_pEncoder->HrFillAppend(pConvert));

        // Encode
        CHECKHR(hr = m_pEncoder->HrInternetEncode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECODE:
        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrFillAppend(pConvert));

        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pDecoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    case DCT_DECENC:
        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrFillAppend(pConvert));

        // Convert
        CHECKHR(hr = m_pDecoder->HrInternetDecode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill Buffer
        CHECKHR(hr = m_pDecoder->HrWriteConverted(m_pEncoder));

        // Convert
        CHECKHR(hr = m_pEncoder->HrInternetEncode(FALSE));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Write
        CHECKHR(hr = m_pEncoder->HrWriteConverted(&m_cVirtualStream));
        break;

    // ----------------------------------------------------------------------------
    default:
        AssertSz(FALSE, "I should be fired and shot if this line of code executes.");
        break;
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertToOffset
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertToOffset(ULARGE_INTEGER uliOffset)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    BYTE            rgbBuffer[4096];
    ULONG           cbBuffer=0;
    ULONG           cb;
    ULARGE_INTEGER  uliCur, uliSize;
    LARGE_INTEGER   liStart;
    BLOB            rConvert;

    // Big Problems...
    Assert(m_pLockBytes);

    // Fatal Error: This can happen if we are persisting an IMimeMessage back into its original source.
    if (NULL == m_pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Query Current position and uliSize
    m_cVirtualStream.QueryStat(&uliCur, &uliSize);
    liStart.QuadPart = uliCur.QuadPart;
    Assert(m_liLastWrite.QuadPart == liStart.QuadPart);

    // Convert until no more to read or virtual offset is correct
    while(1)
    {
        // Done
        if (uliCur.QuadPart >= uliOffset.QuadPart)
            break;

        // Read a buffer
        Assert(m_uliIntOffset.QuadPart <= m_uliIntSize.QuadPart);
        CHECKHR(hr = m_pLockBytes->ReadAt(m_uliIntOffset, rgbBuffer, sizeof(rgbBuffer), &cbBuffer));

        // Done
        if (0 == cbBuffer)
            break;

        // Last Buffer ?
        Assert(m_uliIntOffset.QuadPart + cbBuffer <= m_uliIntSize.QuadPart);

        // Setup Blob to Convert
        rConvert.cbSize = cbBuffer;
        rConvert.pBlobData = rgbBuffer;

        // Convert the buffer
        CHECKHR(hr = HrConvertData(&rConvert));
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Increment internal offset...
        m_uliIntOffset.QuadPart += cbBuffer;

        // Get current virtual offset
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Save position as last write position...
        m_liLastWrite.QuadPart = uliCur.QuadPart;
    }

    // Done ?
    if (0 == cbBuffer || m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart)
    {
        // Well we don't need m_pLockBytes anymore, its all in m_cVirtualStream
        Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart);

        // Do the last one
        CHECKHR(hr = HrConvertDataLast());
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Get current virtual offset
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Save position as last write position...
        m_liLastWrite.QuadPart = uliCur.QuadPart;

        // Release objects
        SafeRelease(m_pLockBytes);
        SafeRelease(m_pEncoder);
        SafeRelease(m_pDecoder);
    }

    // Rewind virtual stream back to 
    CHECKHR(hr = m_cVirtualStream.Seek(liStart, STREAM_SEEK_SET, NULL));

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::HrConvertToEnd
// --------------------------------------------------------------------------------
HRESULT CBodyStream::HrConvertToEnd(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            rgbBuffer[4096];
    ULONG           cbRead;
    
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Move virtual stream to last write position
    CHECKHR(hr = m_cVirtualStream.Seek(m_liLastWrite, STREAM_SEEK_SET, NULL));

    // Copy m_pLockBytes to pstmTemp
    while(1)
    {
        // Read
        CHECKHR(hr = Read(rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
        {
            // Well we don't need m_pLockBytes anymore, its all in m_cVirtualStream
            Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart);
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::Read
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CBodyStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CBodyStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    ULARGE_INTEGER  uliCur, 
                    uliSize;
    ULONG           cbRead=0,
                    cbLeft=0,
                    cbGet;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Convert Case
    if (DCT_NONE == m_dctConvert)
    {
        // Do I Have data
        if (m_pLockBytes)
        {
            // Read Buffer
            CHECKHR(hr = m_pLockBytes->ReadAt(m_uliIntOffset, pv, cb, &cbRead));

            // Done
            m_uliIntOffset.QuadPart += cbRead;
        }
    }

    // Otherwise
    else
    {
        // Read until we have cb
        cbLeft = cb;
        while(cbLeft)
        {
            // Query Current position and uliSize
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Convert more into the virtual stream
            if (uliCur.QuadPart == uliSize.QuadPart)
            {
                // Done
                if (m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart)
                    break;

                // Grow
                uliCur.QuadPart += g_dwSysPageSize;

                // Convert to offset...
                CHECKHR(hr = HrConvertToOffset(uliCur));
                if ( S_OK != hr )
                    hrWarnings = TrapError(hr);
            }

            // Compute amount that can be read from the current cache
            CHECKHR(hr = m_cVirtualStream.Read((LPVOID)((LPBYTE)pv + cbRead), cbLeft, &cbGet));

            // Increment cbRead
            cbRead+=cbGet;
            cbLeft-=cbGet;
        }
    }

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT             hr=S_OK;
    HRESULT             hrWarnings=S_OK;
    ULARGE_INTEGER      uliNew;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Convert Case
    if (DCT_NONE == m_dctConvert)
    {
        // Seek the file pointer
        switch (dwOrigin)
        {
        // --------------------------------------------------------
   	    case STREAM_SEEK_SET:
            uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart < 0)
            {
                if ((DWORDLONG)(0 - dlibMove.QuadPart) > m_uliIntOffset.QuadPart)
                {
                    hr = TrapError(E_FAIL);
                    goto exit;
                }
            }
            uliNew.QuadPart = m_uliIntOffset.QuadPart + dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_END:
            if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > m_uliIntSize.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
            uliNew.QuadPart = m_uliIntSize.QuadPart - dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        default:
            hr = TrapError(STG_E_INVALIDFUNCTION);
            goto exit;
        }

        // New offset greater than size...
        m_uliIntOffset.QuadPart = min(uliNew.QuadPart, m_uliIntSize.QuadPart);

        // Return Position
        if (plibNewPosition)
            plibNewPosition->QuadPart = (LONGLONG)m_uliIntOffset.QuadPart;
    }

    // Otherwise
    else
    {
        // Locals
        ULARGE_INTEGER uliCur, uliSize;
        LARGE_INTEGER liNew;

        // Query Current position and uliSize
        m_cVirtualStream.QueryStat(&uliCur, &uliSize);

        // Seek the file pointer
        switch (dwOrigin)
        {
        // --------------------------------------------------------
   	    case STREAM_SEEK_SET:
            // Assume new position
            uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart < 0)
            {
                if ((DWORDLONG)(0 - dlibMove.QuadPart) > uliCur.QuadPart)
                {
                    hr = TrapError(E_FAIL);
                    goto exit;
                }
            }
            uliNew.QuadPart = uliCur.QuadPart + dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        case STREAM_SEEK_END:
            // Do I need to convert any more ?
            if (m_uliIntOffset.QuadPart < m_uliIntSize.QuadPart)
            {
                // Then Convert to the end
                CHECKHR(hr = HrConvertToEnd());

                // Better be done...
                Assert(m_uliIntOffset.QuadPart == m_uliIntSize.QuadPart && NULL == m_pLockBytes);
            }

            // Query Current Position
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Can I really move there
            if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > uliSize.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Assume new position
            uliNew.QuadPart = uliSize.QuadPart - dlibMove.QuadPart;
            break;

        // --------------------------------------------------------
        default:
            hr = TrapError(STG_E_INVALIDFUNCTION);
            goto exit;
        }

        // New offset greater than size...
        if (uliNew.QuadPart > uliSize.QuadPart)
        {
            // Do I need to convert any more ?
            if (m_uliIntOffset.QuadPart < m_uliIntSize.QuadPart)
            {
                // Seek m_cVirtualStream to m_uliIntOffset
                CHECKHR(hr = m_cVirtualStream.Seek(m_liLastWrite, STREAM_SEEK_SET, NULL));

                // Convert to offset
                CHECKHR(hr = HrConvertToOffset(uliNew));
                if ( S_OK != hr )
                    hrWarnings = TrapError(hr);
            }

            // Query Current position and uliSize
            m_cVirtualStream.QueryStat(&uliCur, &uliSize);

            // Reposition uliNew.QuadPart
            uliNew.QuadPart = (uliNew.QuadPart > uliSize.QuadPart) ? uliSize.QuadPart : uliNew.QuadPart;
        }

        // Otherwise, seek m_cVirtualStream to new location
        liNew.QuadPart = uliNew.QuadPart;
        CHECKHR(hr = m_cVirtualStream.Seek(liNew, STREAM_SEEK_SET, NULL));

        // Return Position
        if (plibNewPosition)
            plibNewPosition->QuadPart = (LONGLONG)uliNew.QuadPart;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CBodyStream::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::CopyTo(IStream *pstmDest, ULARGE_INTEGER cb, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten)
{
    return HrCopyStreamCB((IStream *)this, pstmDest, cb, puliRead, puliWritten);
}

// --------------------------------------------------------------------------------
// CBodyStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBodyStream::Stat(STATSTG *pStat, DWORD grfStatFlag)
{
    // Locals
    HRESULT         hr=S_OK;
    LARGE_INTEGER   liSeek;
    ULARGE_INTEGER  uliCurrent;

    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pStat, sizeof(STATSTG));

    // Set Storage Type
    pStat->type = STGTY_STREAM;

    // Set the name ?
    if (m_pszFileName && !(grfStatFlag & STATFLAG_NONAME))
        pStat->pwcsName = PszToUnicode(CP_ACP, m_pszFileName);

    // Seek current position
    liSeek.QuadPart = 0;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_CUR, &uliCurrent));

    // Seek to the end
    liSeek.QuadPart = 0;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_END, &pStat->cbSize));

    // Seek back to current position
    liSeek.QuadPart = uliCurrent.QuadPart;
    CHECKHR(hr = Seek(liSeek, STREAM_SEEK_SET, &uliCurrent));
    Assert(uliCurrent.QuadPart == (DWORDLONG)liSeek.QuadPart);

    // init clsid
    pStat->clsid = CLSID_NULL;

    // If we have a filename, get the class id...
    if (m_pszFileName)
    {
        // Locals
        CHAR szExt[MAX_PATH];

        // Split the filename
        if (SUCCEEDED(MimeOleGetFileExtension(m_pszFileName, szExt, ARRAYSIZE(szExt))))
            MimeOleGetExtClassId(szExt, &pStat->clsid);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetcode.cpp ===
// --------------------------------------------------------------------------------
// Inetcode.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetconv.h"
#include "stmutil.h"
#include "inetstm.h"

// --------------------------------------------------------------------------------
// MimeOleEncodeStream
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeStream(ENCODINGTYPE format, LPWRAPTEXTINFO pWrapInfo, IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT     hr=S_OK;

    // Handle enctype
    switch(format)
    {
    case IET_BINARY:
        CHECKHR(hr = HrCopyStream(pstmIn, pstmOut, NULL));
        break;

    case IET_7BIT:
    case IET_8BIT:
        if (pWrapInfo)
            CHECKHR(hr = MimeOleWrapTextStream(pWrapInfo, pstmIn, pstmOut));
        else
            CHECKHR(hr = MimeOleEncodeStreamRW(pstmIn, pstmOut));
        break;

    case IET_QP:
        CHECKHR(hr = MimeOleEncodeStreamQP(pstmIn, pstmOut));
        break;

    case IET_BASE64:
        CHECKHR(hr = MimeOleEncodeStream64(pstmIn, pstmOut));
        break;

    case IET_UUENCODE:
        CHECKHR(hr = MimeOleEncodeStreamUU(pstmIn, pstmOut));
        break;

    default:
        hr = TrapError(MIME_E_INVALID_ENCODING_TYPE);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleDecodeStream
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeStream(ENCODINGTYPE format, IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT     hr=S_OK;

    // Handle enctype
    switch (format)
    {
    case IET_BINARY:
        CHECKHR(hr = HrCopyStream(pstmIn, pstmOut, NULL));
        break;

    case IET_7BIT:
    case IET_8BIT:
        CHECKHR(hr = MimeOleDecodeStreamRW(pstmIn, pstmOut));
        break;

    case IET_QP:
        CHECKHR(hr = MimeOleDecodeStreamQP(pstmIn, pstmOut));
        break;

    case IET_BASE64:
        CHECKHR(hr = MimeOleDecodeStream64(pstmIn, pstmOut));
        break;

    case IET_UUENCODE:
        CHECKHR(hr = MimeOleDecodeStreamUU(pstmIn, pstmOut));
        break;

    default:
        hr = TrapError(MIME_E_INVALID_ENCODING_TYPE);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleEncodeStream64
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeStream64(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr = S_OK;
    UCHAR           buf[CCHMAX_ENCODE64_IN], 
                    bigbuf[4096];
    CHAR            szBuffer[4096];
    ULONG           cbRead, 
                    i, 
                    cbBuffer=0, 
                    cbBigBuf=0, 
                    iBigBuf=0, 
                    cbCopy;
    UCHAR           ch[3];   

    // Check Params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Convert pstmIn into pstmOut
    while (1)
    {
        // Init
        cbRead = 0;

        // Do we need to read some data ?
        if (iBigBuf + CCHMAX_ENCODE64_IN >= cbBigBuf)
        {
            // Copy Remainder of bigbuf into buf
            CopyMemory (buf, bigbuf + iBigBuf, cbBigBuf - iBigBuf);
            cbRead += (cbBigBuf - iBigBuf);

            // Reads enough from attachment to encode one base64 line
            CHECKHR (hr = pstmIn->Read (bigbuf, sizeof (bigbuf), &cbBigBuf));
            iBigBuf = 0;

            // Copy in a little more
            cbCopy = min (CCHMAX_ENCODE64_IN - cbRead, cbBigBuf);
            CopyMemory (buf + cbRead, bigbuf, cbCopy);
            iBigBuf += cbCopy;
            cbRead += cbCopy;
        }

        else
        {
            CopyMemory (buf, bigbuf + iBigBuf, CCHMAX_ENCODE64_IN);
            iBigBuf += CCHMAX_ENCODE64_IN;
            cbRead = CCHMAX_ENCODE64_IN;
        }

        // Done
        if (cbRead == 0)
            break;

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            ch[0] = buf[i];
            ch[1] = (i+1 < cbRead) ? buf[i+1] : '\0';
            ch[2] = (i+2 < cbRead) ? buf[i+2] : '\0';

            szBuffer[cbBuffer++] = g_rgchEncodeBase64[ ( ch[0] >> 2 ) & 0x3F ];
            szBuffer[cbBuffer++] = g_rgchEncodeBase64[ ( ch[0] << 4 | ch[1] >> 4 ) & 0x3F ];

            if (i+1 < cbRead)
                szBuffer[cbBuffer++] = g_rgchEncodeBase64[ ( ch[1] << 2 | ch[2] >> 6 ) & 0x3F ];
            else
                szBuffer[cbBuffer++] = '=';

            if (i+2 < cbRead)
                szBuffer[cbBuffer++] = g_rgchEncodeBase64[ ( ch[2] ) & 0x3F ];
            else
                szBuffer[cbBuffer++] = '=';
        }

        // Ends encoded line and writes to storage
        szBuffer[cbBuffer++] = chCR;
        szBuffer[cbBuffer++] = chLF;

        // Dump Buffer
        if (cbBuffer + CCHMAX_ENCODE64_IN + CCHMAX_ENCODE64_IN > sizeof (szBuffer))
        {
            // Write the line
            CHECKHR (hr = pstmOut->Write (szBuffer, cbBuffer, NULL));
            cbBuffer = 0;
        }

        // Tests for end of item
        if (cbRead < CCHMAX_ENCODE64_IN)
            break;
    }

    // Dump rest of Buffer
    if (cbBuffer)
    {
        // Write the line
        CHECKHR (hr = pstmOut->Write (szBuffer, cbBuffer, NULL));
        cbBuffer = 0;
    }

exit:
    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// MimeOleDecodeStream64
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeStream64(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbIn=0,
                    cbPad=0, 
                    i, 
                    cbBigBuf=0, 
                    cbLine;
    UCHAR           ucIn[4], 
                    ch, 
                    bigbuf[4096];
    LPSTR           pszLine;
    CInternetStream cInternet;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create a text stream
	CHECKHR(hr = cTextStream.HrInit(pstmIn, NULL));

    // Decodes one line at a time
    while (1)
    {
        // Read a line
        CHECKHR(hr = cTextStream.HrReadLine(&pszLine, &cbLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (cbLine == 0)
            break;

        // Checks for illegal end of data
        if (cbPad > 2)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Strip CRLF
        StripCRLF(pszLine, &cbLine);

        // Should we write the current buffer ?
        if (cbBigBuf + cbLine + cbLine > sizeof (bigbuf))
        {
            CHECKHR(hr = pstmOut->Write (bigbuf, cbBigBuf, NULL));
            cbBigBuf = 0;
        }

        // Decodes characters in line buffer
        i = 0;
        while (i < cbLine)
        {
            // Gets 4 legal Base64 characters, ignores if illegal
            ch = pszLine[i++];
            ucIn[cbIn] = DECODE64(ch);
            if ((ucIn[cbIn] < 64) || ((ch == '=') && (cbIn > 1)))
                cbIn++;

            if((ch == '=') && (cbIn > 1))
                cbPad++;

            // Outputs when 4 legal Base64 characters are in the buffer
            if (cbIn == 4)
            {
                if (cbPad < 3)
                    bigbuf[cbBigBuf++] = (ucIn[0] << 2 | ucIn[1] >> 4);
                if (cbPad < 2)
                    bigbuf[cbBigBuf++] = (ucIn[1] << 4 | ucIn[2] >> 2);
                if (cbPad < 1)
                    bigbuf[cbBigBuf++] = (ucIn[2] << 6 | ucIn[3]);
                cbIn = 0;
            }
        }
    }

    // Checks for non-integral encoding
    if (cbIn != 0)
    {
        ULONG ulT;
       
        // Inserts missing padding
        for (ulT=cbIn; ulT<4; ulT++)
            ucIn[ulT] = '=';
        cbPad = 4 - cbIn;
        if (cbPad < 3)
            bigbuf[cbBigBuf++] = (ucIn[0] << 2 | ucIn[1] >> 4);
        if (cbPad < 2)
            bigbuf[cbBigBuf++] = (ucIn[1] << 4 | ucIn[2] >> 2);
        if( cbPad < 1 )
            bigbuf[cbBigBuf++] = (ucIn[2] << 6 | ucIn[3]);
        cbIn = 0;
    }

    // Write the rest of the bigbuf
    if (cbBigBuf)
    {
        CHECKHR(hr = pstmOut->Write (bigbuf, cbBigBuf, NULL));
        cbBigBuf = 0;
    }

exit:
    // Cleanup
cInternet.Free();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleEncodeStreamQP
// --------------------------------------------------------------------------------
#define ENCODEQPBUF 4096
MIMEOLEAPI MimeOleEncodeStreamQP(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fSeenCR=FALSE,
                    fEOLN=FALSE;
    CHAR            szBuffer[4096];
    ULONG           cbRead=0, 
                    cbCurr=1, 
                    cbAttLast=0,
                    cbBffLast=0, 
                    cbBuffer=0;
    UCHAR           chThis=0, 
                    chPrev=0,
                    buf[ENCODEQPBUF];

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Read from pstmIn and encode into pstmOut
    while (1)
    {    
        // Reads one buffer full from the attachment
        if (cbCurr >= cbRead)
        {
            // Moves buffer from the last white space to front
            cbCurr = 0;
            while (cbAttLast < cbRead)
                buf[cbCurr++] = buf[cbAttLast++];

            // RAID-33342 - Reset cbAttLast - buff[0] is now equal to cbAttLast !!!
            cbAttLast = 0;

            // Read into buf
            CHECKHR(hr = pstmIn->Read(buf+cbCurr, ENCODEQPBUF-cbCurr, &cbRead));

            // No more ?
            if (cbRead == 0)
                break;

            // Adjusts buffer length
            cbRead += cbCurr;
        }

        // Gets the next character
        chThis = buf[cbCurr++]; 

        // Tests for end of line
        if (chThis == chLF && fSeenCR == TRUE)
            fEOLN = TRUE;
        
        // Tests for an isolated CR
        else if (fSeenCR == TRUE)
        {
            szBuffer[cbBuffer++] = '=';
            szBuffer[cbBuffer++] = '0';
            szBuffer[cbBuffer++] = 'D';
            chPrev = 0xFF;
        }

        // CR has been taken care of
        fSeenCR = FALSE;

        // Tests for trailing white space if end of line
        if (fEOLN == TRUE)
        {
            if (chPrev == ' ' || chPrev == '\t')
            {
                cbBuffer--;
                szBuffer[cbBuffer++] = '=';
                szBuffer[cbBuffer++] = g_rgchHex[chPrev >>    4];
                szBuffer[cbBuffer++] = g_rgchHex[chPrev &  0x0F];
                chPrev = 0xFF;
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }
        }

        // Tests for a must quote character
        else if (((chThis < 32) && (chThis != chCR && chThis != '\t')) || (chThis > 126 ) || (chThis == '='))
        {
            szBuffer[cbBuffer++] = '=';
            szBuffer[cbBuffer++] = g_rgchHex[chThis >>    4];
            szBuffer[cbBuffer++] = g_rgchHex[chThis &  0x0F];
            chPrev = 0xFF;
        }

        // Tests for possible end of line
        else if (chThis == chCR)
        {
            fSeenCR = TRUE;
        }

        // Other characters (includes ' ' and '\t')
        else
        {
            // Stuffs leading '.'
            if (chThis == '.' && cbBuffer == 0)
                szBuffer[cbBuffer++] = '.';

            szBuffer[cbBuffer++] = chThis;
            chPrev = chThis;

            // Tests for white space and saves location
            if (chThis == ' ' || chThis == '\t')
            {
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }
        }

        // Tests for line break
        if (cbBuffer > 72 || fEOLN == TRUE || chThis == chLF)
        {
            // Backtracks to last whitespace
            if (cbBuffer > 72 && cbBffLast > 0)
            {
                // RAID-33342
                AssertSz(cbAttLast <= cbCurr, "Were about to eat some text.");
                cbCurr = cbAttLast;
                cbBuffer = cbBffLast;
            }
            else
            {
                cbAttLast = cbCurr;
                cbBffLast = cbBuffer;
            }

            // Adds soft line break, if necessary
            if (fEOLN == FALSE)
                szBuffer[cbBuffer++] = '=';

            // Ends line and writes to storage
            szBuffer[cbBuffer++] = chCR;
            szBuffer[cbBuffer++] = chLF;

            // Write the buffer
            CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));

            // Resets counters
            fEOLN = FALSE;
            cbBuffer = 0;
            chPrev = 0xFF;
            cbBffLast = 0;
        }
    }

    // Writes last line to storage
    if (cbBuffer > 0)
    {
        // Write the line
        CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleDecodeStreamQP
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeStreamQP(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szOut[4096], 
                    ch1=0,
                    ch2=0;
    BOOL            fSoftNL=FALSE, 
                    fNeedNL=FALSE,
                    fHasCRLF=FALSE;
    ULONG           dwLast=0, 
                    i, 
                    iLast, 
                    cbOut=0, 
                    cbLine, 
                    cbBeforeStrip;
    UCHAR           ch;    
    LPSTR           pszLine,
                    psz;
    CInternetStream cInternet;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create a text stream
	CHECKHR(hr = cTextStream.HrInit(pstmIn, NULL));

    // Decodes one line at a time
    while (1)
    {
        // Read a line
        CHECKHR(hr = cTextStream.HrReadLine(&pszLine, &cbLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (cbLine == 0)
            break;

        // Strip CRLF
        cbBeforeStrip = cbLine;
        StripCRLF(pszLine, &cbLine);
        if (cbBeforeStrip != cbLine)
            fHasCRLF = TRUE;
        else
            fHasCRLF = FALSE;

        // Strips traling blanks
        UlStripWhitespace(pszLine, FALSE, TRUE, &cbLine);

        // Dump Buffer
        if (cbOut + cbLine + 10 > sizeof (szOut))
        {
            CHECKHR(hr = pstmOut->Write(szOut, cbOut, NULL));
            cbOut = 0;
        }

        // Fixes end of line with CRLF
        if (fNeedNL == TRUE)
        {
            szOut[cbOut++] = chCR;
            szOut[cbOut++] = chLF;
        }

        // Init
        fSoftNL = FALSE;
        fNeedNL = FALSE;
        i       = 0;

        // Step Over Perioud
        if (pszLine[0] == '.')
            i++;
            
        // Decodes characters in line buffer
        while (i < cbLine)
        {
            ch = pszLine[i++];
            if (ch == '=')
            {
                if (i == cbLine)
                    fSoftNL = TRUE;

                else if ((i + 2) <= cbLine)
                {
                    iLast = i;
                    ch1 = ChConvertFromHex(pszLine[i++]);
                    ch2 = ChConvertFromHex(pszLine[i++]);

                    if (ch1 == 255 || ch2 == 255)
                    {
                        szOut[cbOut++] = '=';
                        i = iLast;
                    }

                    else
                        szOut[cbOut++] = (ch1 << 4) | ch2;
                }

                else
                    szOut[cbOut++] = ch;
            }
            else
                szOut[cbOut++] = ch;

            Assert (cbOut < sizeof (szOut));
        }

        // Saves end of line requirement until boundary is checked
        // If the next line is a boundary, body does not end with CRLF
        if (fHasCRLF)
            fNeedNL = fSoftNL ? FALSE : TRUE;
    }

    // Dump Buffer
    if (cbOut)
    {
        // Fixes end of line with CRLF
        if (fNeedNL == TRUE)
        {
            szOut[cbOut++] = chCR;
            szOut[cbOut++] = chLF;
        }

        CHECKHR (hr = pstmOut->Write (szOut, cbOut, NULL));
        cbOut = 0;
    }

exit:
    // Cleanup
cInternet.Free();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleEncodeStreamRW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeStreamRW(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszLine;
    ULONG           cbLine;
    CInternetStream cInternet;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

	// Create text stream object
	CHECKHR(hr = cTextStream.HrInit(pstmIn, NULL));

    // Read lines and stuff dots
    while (1)
    {
        // Read a line from the stream
        CHECKHR(hr = cTextStream.HrReadLine(&pszLine, &cbLine));

        // Done
        if (cbLine == 0)
            break;

        // Stuff dots
        if ('.' == *pszLine)
        {
            // Write the data
            CHECKHR(hr = pstmOut->Write(c_szPeriod, lstrlen(c_szPeriod), NULL));
        }

        // Write the data
        CHECKHR(hr = pstmOut->Write(pszLine, cbLine, NULL));
    }

exit:
	// Cleanup
	cTextStream.Free();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleDecodeStreamRW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeStreamRW(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbLine;
    LPSTR           pszLine;
    CInternetStream cInternet;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create a text stream
	CHECKHR(hr = cTextStream.HrInit(pstmIn, NULL));

    // Decodes one line at a time
    while(1)
    {
        // Read a line
        CHECKHR(hr = cTextStream.HrReadLine(&pszLine, &cbLine));

        // Zero bytes read
        if (cbLine == 0)
            break;

        // Write the line
        if ('.' == *pszLine)
        {
            CHECKHR(hr = pstmOut->Write(pszLine + 1, cbLine - 1, NULL));
        }
        else
        {
            CHECKHR(hr = pstmOut->Write(pszLine, cbLine, NULL));
        }
    }

exit:
    // Cleanup
cInternet.Free();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleEncodeStreamUU
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeStreamUU(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr = S_OK;
    UCHAR           buf[CCHMAX_ENCODEUU_IN], 
                    bigbuf[4096];
    CHAR            szBuffer[4096];
    ULONG           cbRead=0,
                    i,
                    cbBuffer=0,
                    iBigBuf=0,
                    cbBigBuf=0,
                    cbCopy = 0;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Convert pstmIn into pstmOut
    while (1)
    {
        // Init
        cbRead = 0;

        // Do we need to read some data ?
        if (iBigBuf + CCHMAX_ENCODEUU_IN >= cbBigBuf)
        {
            // Copy Remainder of bigbuf into buf
            CopyMemory(buf, bigbuf + iBigBuf, cbBigBuf - iBigBuf);
            cbRead += (cbBigBuf - iBigBuf);

            // Reads enough from attachment to encode one base64 line
            CHECKHR(hr = pstmIn->Read(bigbuf, sizeof (bigbuf), &cbBigBuf));
            iBigBuf = 0;

            // Copy in a little more
            cbCopy = min(CCHMAX_ENCODEUU_IN - cbRead, cbBigBuf);
            CopyMemory (buf + cbRead, bigbuf, cbCopy);
            ZeroMemory(buf + cbRead + cbCopy, sizeof(buf) - (cbRead + cbCopy));
            iBigBuf += cbCopy;
            cbRead += cbCopy;
        }

        else
        {
            CopyMemory(buf, bigbuf + iBigBuf, CCHMAX_ENCODEUU_IN);
            iBigBuf += CCHMAX_ENCODEUU_IN;
            cbRead = CCHMAX_ENCODEUU_IN;
        }

        // Checks for EOF
        if (cbRead == 0)
            break;

        // Encodes line length;  escapes if necessary (UUENCODE(14) = '.')
        if (cbRead == 14)
            szBuffer[cbBuffer++] = '.';

        // Encode Line length
        szBuffer[cbBuffer++] = UUENCODE ((UCHAR)cbRead);

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            szBuffer[cbBuffer++] = UUENCODE ((buf[i]   >> 2));
            szBuffer[cbBuffer++] = UUENCODE ((buf[i]   << 4) | (buf[i+1] >> 4));
            szBuffer[cbBuffer++] = UUENCODE ((buf[i+1] << 2) | (buf[i+2] >> 6));
            szBuffer[cbBuffer++] = UUENCODE ((buf[i+2]));
        }

        // Ends encoded line and writes to storage
        szBuffer[cbBuffer++] = chCR;
        szBuffer[cbBuffer++] = chLF;

        // Write Buffer
        if (cbBuffer + CCHMAX_ENCODEUU_IN + CCHMAX_ENCODEUU_IN > sizeof (szBuffer))
        {
            // Write the line
            CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));
            cbBuffer = 0;
        }

        // Tests for end of attachment
        if (cbRead < CCHMAX_ENCODEUU_IN)
            break;
    }

    // Write Buffer
    if (cbBuffer)
    {
        // Write the line
        CHECKHR(hr = pstmOut->Write(szBuffer, cbBuffer, NULL));
        cbBuffer = 0;
    }

    // Outputs zero length uuencoded line
    szBuffer[0] = UUENCODE (0);
    szBuffer[1] = chCR;
    szBuffer[2] = chLF;

    // Write it
    CHECKHR(hr = pstmOut->Write(szBuffer, 3, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleDecodeStreamUU
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeStreamUU(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbIn,
                    cbBigBuf=0, 
                    cbLineLength, 
                    cbScan, 
                    i, 
                    cbLine, 
                    cbOffset, 
                    cbTolerance, 
                    cbExpected;
    UCHAR           ucIn[4], 
                    ch, 
                    bigbuf[4096];
    LPSTR           pszLine;
    CInternetStream cInternet;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create a text stream
	CHECKHR(hr = cTextStream.HrInit(pstmIn, NULL));
   
    // Decodes one line at a time
    while (1)
    {
        // Read a line
        CHECKHR(hr = cTextStream.HrReadLine(&pszLine, &cbLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (cbLine == 0)
            break;

        // Strip CRLF
        StripCRLF(pszLine, &cbLine);

        // RAID-25953: "BEGIN --- CUT HERE --- Cut Here --- cut here ---" - WinVN post
        //             partial messages that have the following line at the beginning of
        //             each partial. B = 66 and the length of this line is 48, so the following
        //             code thinks that this line is a valid UUENCODED line, so, to fix this,
        //             we will throw out all lines that start with BEGIN since this is not valid
        //             to be in uuencode.
        if (StrCmpNI("BEGIN", pszLine, 5) == 0)
            continue;
        else if (StrCmpNI("END", pszLine, 3) == 0)
            continue;

        // Checks line length
        ch = *pszLine;
        cbLineLength = UUDECODE (ch);

        // Comput tolerance and offset for non-conforming even line lengths
        cbOffset = (cbLineLength % 3);
        if (cbOffset != 0) 
        {
            cbOffset++;
            cbTolerance = 4 - cbOffset;
        }
        else 
            cbTolerance = 0;
    
        // Compute expected line length
        cbExpected = 4 * (cbLineLength / 3) + cbOffset + 1; 

        // Always check for '-'
        if (cbLine < cbExpected)
            continue;

        // Wack off trailing spaces
        while (pszLine[cbLine-1] == ' ' && cbLine > 0 && cbLine != cbExpected)
            --cbLine;

        // Checksum character and encoders which include the count char in the line count
        if (cbExpected != cbLine && cbExpected + cbTolerance != cbLine &&
            cbExpected + 1 != cbLine && cbExpected + cbTolerance + 1 != cbLine &&
            cbExpected - 1 != cbLine && cbExpected + cbTolerance - 1 != cbLine)
            continue;

        // Wack off all white space
        pszLine[cbLine] = '\0';

        // Write buffer
        if (cbBigBuf + cbLine + cbLine > sizeof (bigbuf))
        {
            CHECKHR(hr = pstmOut->Write(bigbuf, cbBigBuf, NULL));
            cbBigBuf = 0;
        }

        // Decodes 4 characters at a time
        cbIn=cbScan=0;
        i = 1;
        while (cbScan < cbLineLength)
        {
            // Gets 4 characters, pads with blank if necessary
            if (i < cbLine)
                ch = pszLine[i++];
            else
                ch = ' ';

            ucIn[cbIn++] = UUDECODE (ch);

            // Outputs decoded characters
            if (cbIn == 4)
            {
                if (cbScan++ < cbLineLength)
                    bigbuf[cbBigBuf++] = (ucIn[0] << 2) | (ucIn[1] >> 4);
                if (cbScan++ < cbLineLength)
                    bigbuf[cbBigBuf++] = (ucIn[1] << 4) | (ucIn[2] >> 2);
                if (cbScan++ < cbLineLength)
                    bigbuf[cbBigBuf++] = (ucIn[2] << 6) | (ucIn[3]);
                cbIn = 0;
            }
        }
    }

    // Write whats left buffer
    if (cbBigBuf)
    {
        CHECKHR(hr = pstmOut->Write(bigbuf, cbBigBuf, NULL));
        cbBigBuf = 0;
    }

exit:
    // Cleanup
cInternet.Free();

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\ibdystm.h ===
// --------------------------------------------------------------------------------
// Ibdystm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IBDYSTM_H
#define __IBDYSTM_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "mimeole.h"
#include "vstream.h"
#include "inetconv.h"

// --------------------------------------------------------------------------------
// Forwards
// --------------------------------------------------------------------------------
class CMimePropertySet;
class CInternetConverter;
class CMessageBody;
typedef CMessageBody *LPMESSAGEBODY;

// --------------------------------------------------------------------------------
// CBodyStream - {62A83704-52A2-11d0-8205-00C04FD85AB4}
// --------------------------------------------------------------------------------
DEFINE_GUID(IID_CBodyStream, 0x62a83704, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// -----------------------------------------------------------------------------
// DOCCONVTYPE
// -----------------------------------------------------------------------------
typedef enum tagDOCCONVTYPE {
    DCT_NONE   = 1000,
    DCT_ENCODE = 1001,
    DCT_DECODE = 1002,
    DCT_DECENC = 1003
} DOCCONVTYPE;

// -----------------------------------------------------------------------------
// ENCODINGMAP
// -----------------------------------------------------------------------------
typedef struct tagENCODINGMAP {
    ENCODINGTYPE    ietEncoding;
    LPCSTR          pszName;
    BOOL            fValidBodyEncoding;      // Allowed to perform body encoding
} ENCODINGMAP, *LPENCODINGMAP;

BOOL FIsValidBodyEncoding(ENCODINGTYPE ietEncoding);

// -----------------------------------------------------------------------------
// Public
// -----------------------------------------------------------------------------
extern const ENCODINGMAP g_rgEncodingMap[IET_LAST];

// -----------------------------------------------------------------------------
// CONVERSIONMAP
// -----------------------------------------------------------------------------
typedef struct tagCONVERSIONMAP {
    DOCCONVTYPE rgDestType[IET_LAST];
} CONVERSIONMAP, *LPCONVERSIONMAP;

// -----------------------------------------------------------------------------
// Public
// -----------------------------------------------------------------------------
extern const CONVERSIONMAP g_rgConversionMap[IET_LAST];

// -----------------------------------------------------------------------------
// BODYSTREAMINIT
// -----------------------------------------------------------------------------
typedef struct tagBODYSTREAMINIT {
    LPINETCSETINFO      pCharset;            // Current character set
    BOOL                fRemoveNBSP;         // Conversion Flags
    ENCODINGTYPE        ietInternal;         // Internal Encoding Type   
    ENCODINGTYPE        ietExternal;         // External Encoding Type
    CODEPAGEID          cpiInternal;         // Internal Code Page Id
    CODEPAGEID          cpiExternal;         // Extneral Code Page Id
} BODYSTREAMINIT, *LPBODYSTREAMINIT;

// -----------------------------------------------------------------------------
// Wraps a ILockBytes object. CBodyStream is the interface that is 
// always returned by IMimeBody::GetData or QueryInterface(IID_IStream, ...)
// -----------------------------------------------------------------------------
class CBodyStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBodyStream(void);
    ~CBodyStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *) {
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CBodyStream
    // -------------------------------------------------------------------------
    HRESULT HrInitialize(LPBODYSTREAMINIT pInitInfo, LPMESSAGEBODY pBody);

private:
    // -------------------------------------------------------------------------
    // Utilities
    // -------------------------------------------------------------------------
    HRESULT HrConvertToOffset(ULARGE_INTEGER uliOffset);
    HRESULT HrConvertToEnd(void);
    HRESULT HrConvertData(LPBLOB pConvert);
    HRESULT HrConvertDataLast(void);

    // -------------------------------------------------------------------------
    // Initialization Helpers
    // -------------------------------------------------------------------------
    void GetEncodeWrapInfo(LPCONVINITINFO pInitInfo, LPMESSAGEBODY pBody);
    void GetCodePageInfo(LPCONVINITINFO pInitInfo, BOOL fIsText, CODEPAGEID cpiSource, CODEPAGEID cpiDest);
    void ComputeCodePageMapping(LPBODYSTREAMINIT pInitInfo);
    void GenerateDefaultMacBinaryHeader(LPMACBINARY pMacBinary);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;              // Reference count
    LPSTR               m_pszFileName;       // File Name of this body stream...
    DOCCONVTYPE         m_dctConvert;        // Body Conversion type
    ULARGE_INTEGER      m_uliIntOffset;      // 64bit Addressable internal lockbyte space
    ULARGE_INTEGER      m_uliIntSize;        // Size of data in m_pLockBytes
    LARGE_INTEGER       m_liLastWrite;       // Last location writen to in m_cVirtualStream
    ILockBytes         *m_pLockBytes;        // Lock bytes
    CVirtualStream      m_cVirtualStream;    // Full encode/encode
    CInternetConverter *m_pEncoder;          // Internet Encoder
    CInternetConverter *m_pDecoder;          // Internet Encoder
    CRITICAL_SECTION    m_cs;                // Critical Section for m_pStream
};

#endif // __IBDYSTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetconv.cpp ===
// --------------------------------------------------------------------------------
// Inetconv.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "inetconv.h"
#include "internat.h"
#ifndef MAC
#include <shlwapi.h>
#include <mlang.h>
#endif  // !MAC
#include "mimeapi.h"
#include "icoint.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// FGROWBUFFER
// --------------------------------------------------------------------------------
#define FGROWBUFFER(_pBuffer, _cb)       ((_pBuffer)->cb + _cb >= (_pBuffer)->cbAlloc)

// --------------------------------------------------------------------------------
// QP Encoder
// --------------------------------------------------------------------------------
const CHAR g_rgchHex[] = "0123456789ABCDEF";

// --------------------------------------------------------------------------------
// Base64 Decoding Table
// ---------------------
// Decodes one Base64 character into a numeric value
//  
// 0         1         2         3         4         5         6
// 0123456789012345678901234567890123456789012345678901234567890123
// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 
// --------------------------------------------------------------------------------
const char g_rgchDecodeBase64[256] = {
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x00
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x10    
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x20
    64, 64, 64, 62, 64, 64, 64, 63,
    52, 53, 54, 55, 56, 57, 58, 59,  // 0x30
    60, 61, 64, 64, 64,  0, 64, 64,
    64,  0,  1,  2,  3,  4,  5,  6,  // 0x40
     7,  8,  9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22,  // 0x50
    23, 24, 25, 64, 64, 64, 64, 64,
    64, 26, 27, 28, 29, 30, 31, 32,  // 0x60        
    33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48,  // 0x70
    49, 50, 51, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x80
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0x90
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xA0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xB0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xC0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xD0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xE0
    64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64,  // 0xF0
    64, 64, 64, 64, 64, 64, 64, 64,
};

// --------------------------------------------------------------------------------
// Base64 Encoder
// --------------------------------------------------------------------------------
extern const CHAR g_rgchEncodeBase64[] = 
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ ";

// --------------------------------------------------------------------------------
// BinHex Decoding Table
// ---------------------
// Decodes one BinHex character into a numeric value
//  
// 0         1         2         3         4         5         6
// 0123456789012345678901234567890123456789012345678901234567890123
// !"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr 
// --------------------------------------------------------------------------------
#undef BINHEX_INVALID
#undef BINHEX_REPEAT
#undef XXXX

const UCHAR BINHEX_INVALID = 0x40;
const UCHAR BINHEX_REPEAT = 0x90;
const UCHAR BINHEX_TERM = ':';
const UCHAR XXXX = BINHEX_INVALID;
const ULONG cbMinBinHexHeader = 22;
const WORD  wBinHexZero = 0;

const UCHAR g_rgchDecodeBinHex[256] = {
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x00
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x10
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,  // 0x20
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, XXXX, XXXX,
    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, XXXX,  // 0x30
    0x14, 0x15, 0x16, XXXX, XXXX, XXXX, XXXX, XXXX,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,  // 0x40
    0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, XXXX,
    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, XXXX,  // 0x50
    0x2C, 0x2D, 0x2E, 0x2F, XXXX, XXXX, XXXX, XXXX,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, XXXX,  // 0x60
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, XXXX, XXXX,
    0x3D, 0x3E, 0x3F, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x70
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x80
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0x90
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xA0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xB0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xC0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xD0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xE0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,  // 0xF0
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
};

// --------------------------------------------------------------------------------
// HrCreateLineBreaker
// --------------------------------------------------------------------------------
HRESULT HrCreateLineBreaker(IMLangLineBreakConsole **ppLineBreak)
{
    // Locals
    HRESULT             hr=S_OK;
    PFNGETCLASSOBJECT   pfnDllGetClassObject=NULL;
    IClassFactory      *pFactory=NULL;

    // Invalid Args
    Assert(ppLineBreak);

    // Init
    *ppLineBreak = NULL;

    // Thread Safety
    EnterCriticalSection(&g_csMLANG);

    // If not loaded yet
    if (NULL == g_hinstMLANG)
    {
        // Load MLANG - This should be fast most of the time because MLANG is usually loaded
        g_hinstMLANG = LoadLibrary("MLANG.DLL");
        if (NULL == g_hinstMLANG)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Get DllClassObject
    pfnDllGetClassObject = (PFNGETCLASSOBJECT)GetProcAddress(g_hinstMLANG, "DllGetClassObject");
    if (NULL == pfnDllGetClassObject)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Get the MLANG Class Factory
    CHECKHR(hr = (*pfnDllGetClassObject)(CLSID_CMultiLanguage, IID_IClassFactory, (LPVOID *)&pFactory));

    // Finally, create the object that I actually wanted
    CHECKHR(hr = pFactory->CreateInstance(NULL, IID_IMLangLineBreakConsole, (LPVOID *)ppLineBreak)); 

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csMLANG);

    // Cleanup
    SafeRelease(pFactory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrCreateInternetConverter
// --------------------------------------------------------------------------------
HRESULT HrCreateInternetConverter(LPCONVINITINFO pInitInfo, CInternetConverter **ppConverter)
{
    // Allocate It
    *ppConverter = new CInternetConverter();
    if (NULL == *ppConverter)
        return TrapError(E_OUTOFMEMORY);

    // Initialize
    return TrapError((*ppConverter)->HrInit(pInitInfo));
}

// --------------------------------------------------------------------------------
// BinHexCalcCRC16
// --------------------------------------------------------------------------------
void BinHexCalcCRC16( LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC )
{
    LPBYTE  lpb;
    BYTE    b;
    WORD    uCRC;
    WORD    fWrap;
    ULONG   i;

    uCRC = *wCRC;

    for ( lpb = lpbBuff; lpb < lpbBuff + cBuff; lpb++ )
    {
        b = *lpb;

        for ( i = 0; i < 8; i++ )
        {
            fWrap = uCRC & 0x8000;
            uCRC = (uCRC << 1) | (b >> 7);

            if ( fWrap )
            {
                uCRC = uCRC ^ 0x1021;
            }

            b = b << 1;
        }
    }

    *wCRC = uCRC;
}

// --------------------------------------------------------------------------------
// HrCreateMacBinaryHeader
// --------------------------------------------------------------------------------
HRESULT HrCreateMacBinaryHeader(LPCONVERTBUFFER prBinHexHeader, LPCONVERTBUFFER prMacBinaryHeader)
{
    HRESULT hr = S_OK;
    LPMACBINARY pmacbin;
    LPBYTE pbBinHex;
#ifndef _MAC
    WORD wCRC = 0;
#endif  // _MAC
    
    if ((NULL == prBinHexHeader) || (NULL == prMacBinaryHeader))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    
    pmacbin = (LPMACBINARY)(prMacBinaryHeader->pb);
    pbBinHex = (LPBYTE)(prBinHexHeader->pb);
    
    // Zero it out first
    ZeroMemory(pmacbin, sizeof(MACBINARY));

    // Write in the filename length
    pmacbin->cchFileName = pbBinHex[0];
    pbBinHex += 1;
    
    // Copy over the filename
    CopyMemory(pmacbin->rgchFileName, pbBinHex, pmacbin->cchFileName);
    pbBinHex += pmacbin->cchFileName + 1;

    // Copy over the type and creator
    CopyMemory(&(pmacbin->dwType), pbBinHex, sizeof(pmacbin->dwType));
    pbBinHex += 4;
    
    CopyMemory(&(pmacbin->dwCreator), pbBinHex, sizeof(pmacbin->dwCreator));
    pbBinHex += 4;
    
    // Copy over the finder flags
    pmacbin->bFinderFlags = *pbBinHex;
    pbBinHex++;

    pmacbin->bFinderFlags2 = *pbBinHex;
    pbBinHex++;

    // Copy over the data fork length
    CopyMemory(&(pmacbin->lcbDataFork), pbBinHex, sizeof(pmacbin->lcbDataFork));
    pbBinHex += 4;
    
    // Copy over the resource fork length
    CopyMemory(&(pmacbin->lcbResourceFork), pbBinHex, sizeof(pmacbin->lcbResourceFork));
    pbBinHex += 4;

    // Drop on the version stamps
    pmacbin->bVerMacBin2 = 129;
    pmacbin->bMinVerMacBin2 = 129;

    // Calculate the CRC
#ifdef _MAC
    BinHexCalcCRC16((LPBYTE) pmacbin, 124, &(pmacbin->wCRC));
    BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(pmacbin->wCRC));
#else   // !_MAC
    BinHexCalcCRC16((LPBYTE) pmacbin, 124, &(wCRC));
    BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(wCRC));
    
    // Need to keep it in Mac order
    pmacbin->wCRC = HIBYTE(wCRC);
    pmacbin->wCRC |= (LOBYTE(wCRC) << 8);
#endif  // _MAC

    prMacBinaryHeader->cb += sizeof(MACBINARY);
    
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
CInternetConverter::CInternetConverter(void)
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_cbConvert = 0;
    m_ietEncoding = IET_BINARY;
    m_cpiSource = CP_ACP;
    m_cpiDest = CP_ACP;
    m_fLastBuffer = FALSE;
    m_fEncoder = FALSE;
    m_uchPrev = '\0';
    m_pAppend = NULL;
    m_pWrite = NULL;
    m_convtype = ICT_UNKNOWN;
    m_cchMaxLine = 0;
    m_pBinhexEncode = NULL;
    m_eBinHexStateDec = sSTARTING;
    m_fRepeating = FALSE;
    m_cAccum = 0;
    m_prBinhexOutput = &m_rOut;
    m_cbToProcess = 0;
    m_cbDataFork = 0;
    m_cbResourceFork = 0;
    m_wCRC = 0;
    m_wCRCForFork = 0;
    m_fDataForkOnly = FALSE;
    m_pLineBreak = NULL;
    ZeroMemory(&m_rIn, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rOut, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rCset, sizeof(CONVERTBUFFER));
    ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));
}

// --------------------------------------------------------------------------------
// CInternetConverter::~CInternetConverter
// --------------------------------------------------------------------------------
CInternetConverter::~CInternetConverter(void)
{
    if (m_pBinhexEncode)
        delete m_pBinhexEncode;
    SafeMemFree(m_rIn.pb);
    SafeMemFree(m_rOut.pb);
    SafeMemFree(m_rCset.pb);
    SafeMemFree(m_rBinhexHeader.pb);
    SafeRelease(m_pLineBreak);
}

// --------------------------------------------------------------------------------
// CInternetConverter::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetConverter::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CInternetConverter::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetConverter::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CInternetConverter::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetConverter::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInit
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInit(LPCONVINITINFO pInitInfo)
{
    // Locals
    HRESULT hr=S_OK;

    // Save Flags
    m_dwFlags = pInitInfo->dwFlags;

    // Save Format
    m_ietEncoding = pInitInfo->ietEncoding;

    // Save Source Code Page
    m_cpiSource = pInitInfo->cpiSource;

    // Save Dest Code Page
    m_cpiDest = pInitInfo->cpiDest;

    // Are we an encoder..
    m_fEncoder = pInitInfo->fEncoder;

    // Save Wrap Info
    m_cchMaxLine = pInitInfo->cchMaxLine;

    // Save MacBinary state
    m_fDataForkOnly = !pInitInfo->fShowMacBinary;
    
    // InitConvertType
    CHECKHR(hr = HrInitConvertType(pInitInfo));

    // DoubleCheck
    Assert(m_pWrite && m_pAppend && ICT_UNKNOWN != m_convtype);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInitConvertType
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInitConvertType(LPCONVINITINFO pInitInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    CODEPAGEINFO    CodePage;
    CODEPAGEID      cpiLCID;

    // Time to compute m_pAppend and m_pDump...
    if (ICF_WRAPTEXT & m_dwFlags)
    {
        // Check Assumptions
        Assert((IET_7BIT == m_ietEncoding || IET_8BIT == m_ietEncoding) && TRUE == m_fEncoder);

        // Code Page Conversion...
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_WRAPTEXT_CODEPAGE;
        else
            m_convtype = ICT_WRAPTEXT;

        // Load MLANG
        CHECKHR(hr = HrCreateLineBreaker(&m_pLineBreak));

        // Set cpiLCID
        cpiLCID = m_cpiSource;

        // Unicode ?
        if (CP_UNICODE == m_cpiSource)
        {
            // Get Destination Code Page Info
            if (SUCCEEDED(g_pInternat->GetCodePageInfo(m_cpiDest, &CodePage)))
            {
                // Set cpiLCID
                cpiLCID = CodePage.cpiFamily;
            }
        }

        // Map m_cpiSource to lcid
        switch(cpiLCID)
        {
            case 874:   m_lcid = 0x041E; break;
            case 932:   m_lcid = 0x0411; break;
            case 936:   m_lcid = 0x0804; break;
            case 949:   m_lcid = 0x0412; break;
            case 950:   m_lcid = 0x0404; break;
            case 1250:  m_lcid = 0x040e; break;
            case 1251:	m_lcid = 0x0419; break;
            case 1252:	m_lcid = 0x0409; break;
            case 1253:	m_lcid = 0x0408; break;
            case 1254:	m_lcid = 0x041f; break;
            case 1255:	m_lcid = 0x040d; break;
            case 1256:	m_lcid = 0x0401; break;
            case 1257:	m_lcid = 0x0426; break;
            default: m_lcid = GetSystemDefaultLCID(); break;
        }
    }

    // Otherwise, if encoding
    else if (TRUE == m_fEncoder)
    {
        // If CodePage Conversion
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_CODEPAGE_ENCODE;
        else
            m_convtype = ICT_ENCODE;

        // Need binhex encoder
        if (IET_BINHEX40 == m_ietEncoding)
        {
            // Create me an encoder
            CHECKALLOC(m_pBinhexEncode = new CBinhexEncoder);

            // Initialize
            CHECKHR(hr = m_pBinhexEncode->HrConfig(0, 0, &pInitInfo->rMacBinary));
        }
    }

    // Otherwise, if not encoding
    else
    {
        // If CodePage Conversion
        if (ICF_CODEPAGE & m_dwFlags)
            m_convtype = ICT_DECODE_CODEPAGE;
        else
            m_convtype = ICT_DECODE;
    }

    // Map Write and Append Buffers from Conversion Type
    switch(m_convtype)
    {
    // m_rIn --> m_rCset
    case ICT_WRAPTEXT_CODEPAGE:
    case ICT_DECODE_CODEPAGE:           
        m_pAppend = &m_rIn;
        m_pWrite  = &m_rCset;
        break;

    // m_rIn --> m_rOut
    case ICT_WRAPTEXT:
    case ICT_ENCODE:
    case ICT_DECODE:       
        m_pAppend = &m_rIn;
        m_pWrite  = &m_rOut;
        break;

    // m_rCset --> m_rOut
    case ICT_CODEPAGE_ENCODE:
        m_pAppend = &m_rCset;
        m_pWrite  = &m_rOut;
        break;

    // Error
    default:
        AssertSz(FALSE, "INVALID INETCONVTYPE");
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrConvBuffAppendBlock
// --------------------------------------------------------------------------------
inline HRESULT CInternetConverter::HrConvBuffAppendBlock(LPBYTE pb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;

    // Do I need to grow
    if (FGROWBUFFER(&m_rOut, cb))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(&m_rOut, cb));
    }

    // Copy the buffer
    CopyMemory(m_rOut.pb + m_rOut.cb, pb, cb);

    // Increment Size
    m_rOut.cb += cb;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::PszConvBuffGetNextLine
// --------------------------------------------------------------------------------
inline LPSTR CInternetConverter::PszConvBuffGetNextLine(ULONG *pcbLine, ULONG *pcbRead, BOOL *pfFound)
{
    // Locals
    UCHAR       uchThis, uchPrev;
    ULONG       cbLine=0;

    // Invalid Arg
    Assert(pcbLine && pcbRead && pfFound);

    // Init
    *pfFound = FALSE;

    // Read to next \n
    while(m_rIn.i + cbLine < m_rIn.cb)
    {
        // Get a character...
        uchThis = m_rIn.pb[m_rIn.i + cbLine];

        // Better not be null
        Assert(uchThis);

        // Increment Line Length
        cbLine++;

        // Done
        if (chLF == uchThis)
        {
            *pfFound = TRUE;
            break;
        }

        // Remember Previous Char
        uchPrev = uchThis;
    }

    // Set Next Line
    *pcbRead = cbLine;

    // Fixup cbLine
    if (chLF == uchThis)
        cbLine--;
    if (chCR == uchPrev)
        cbLine--;

    // Set Length
    *pcbLine = cbLine;

    // Done
    return (LPSTR)(m_rIn.pb + m_rIn.i);
}

// --------------------------------------------------------------------------------
// CInternetConverter::CopyMemoryRemoveNBSP
// --------------------------------------------------------------------------------
void CInternetConverter::CopyMemoryRemoveNBSP(LPBYTE pbDest, LPBYTE pbSource, ULONG cbSource)
{
    // Locals
    ULONG       iDest=0;
    ULONG       iSource=0;

    // Invalid ARg
    Assert(pbDest && pbSource && CP_UNICODE == m_cpiSource);

    // Do It
    while(1)
    {
        // If not a null lead, copy next two bytes...
        if (iSource + 1 < cbSource)
        {
            // Better not be 0x00A0 - insert space
            Assert(iSource % 2 == 0);
            if (0xA0 == pbSource[iSource] && 0x00 == pbSource[iSource + 1])
            {
                // 0x0020 = Space
                pbDest[iDest++] = 0x20;
                pbDest[iDest++] = 0x00;

                // Step Over this character...
                iSource+=2;
            }

            // Otherwise, copy the character
            else
            {
                // Copy This Char
                pbDest[iDest++] = pbSource[iSource++];

                // Copy Next Char
                if (iSource < cbSource)
                    pbDest[iDest++] = pbSource[iSource++];
            }
        }

        // Otherwise, just copy this once character and stop
        else
        {
            // Copy It
            if (iSource < cbSource)
                pbDest[iDest++] = pbSource[iSource++];

            // Done
            break;
        }
    }
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrFillAppend
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrFillAppend(LPBLOB pData)
{
    // Locals
    HRESULT hr=S_OK;

    // Invlaid ARg
    Assert(pData && m_pAppend);

    // Call Internal Function
    CHECKHR(hr = HrAppendBuffer(m_pAppend, pData, (m_dwFlags & ICF_KILLNBSP)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrAppendBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrAppendBuffer(LPCONVERTBUFFER pBuffer, LPBLOB pData, BOOL fKillNBSP)
{
    // Locals
    HRESULT hr=S_OK;

    // Collapse Current Buffer
    if (pBuffer->i != 0)
    {
        // Move Memory
        MoveMemory(pBuffer->pb, pBuffer->pb + pBuffer->i, pBuffer->cb - pBuffer->i);

        // Decrease Size
        pBuffer->cb -= pBuffer->i;

        // Reset Start
        pBuffer->i = 0;
    }

    // Enought Space ?
    // Do I need to grow
    if (FGROWBUFFER(pBuffer, pData->cbSize))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(pBuffer, pData->cbSize));
    }
    
    // Append the buffer...
    if (fKillNBSP)
        CopyMemoryRemoveNBSP(pBuffer->pb + pBuffer->cb, pData->pBlobData, pData->cbSize);

    // Otherwise, this is a simple copy
    else
        CopyMemory(pBuffer->pb + pBuffer->cb, pData->pBlobData, pData->cbSize);

    // Increment Amount of Data
    pBuffer->cb += pData->cbSize;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrGrowBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrGrowBuffer(LPCONVERTBUFFER pBuffer, ULONG cbAppend)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbGrow;

    // Better need a grow
    Assert(FGROWBUFFER(pBuffer, cbAppend));

    // Compute Grow By
    cbGrow = (cbAppend - (pBuffer->cbAlloc - pBuffer->cb)) + 256;

    // Realloc the buffer
    CHECKHR(hr = HrRealloc((LPVOID *)&pBuffer->pb, pBuffer->cbAlloc + cbGrow));

    // Adjust cbAlloc
    pBuffer->cbAlloc += cbGrow;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWriteConverted
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWriteConverted(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Anything to write
    if (m_pWrite->cb)
    {
        // Write the current block
        CHECKHR(hr = pStream->Write(m_pWrite->pb, m_pWrite->cb, NULL));

        // Nothing in m_rOut
        m_pWrite->cb = 0;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWriteConverted
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWriteConverted(CInternetConverter *pConverter)
{
    // Locals
    HRESULT     hr=S_OK;
    BLOB        rData;

    // Anything to write
    if (m_pWrite->cb)
    {
        // Setup Blob
        rData.pBlobData = m_pWrite->pb;
        rData.cbSize = m_pWrite->cb;

        // Write the current block
        CHECKHR(hr = pConverter->HrFillAppend(&rData));

        // Nothing in m_rOut
        m_pWrite->cb = 0;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInternetEncode
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInternetEncode(BOOL fLastBuffer)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;

    // We Better be an encoder
    Assert(m_fEncoder);

    // Set Last Buffer
    m_fLastBuffer = fLastBuffer;

    // Text Wrapping ?
    if (ICF_WRAPTEXT & m_dwFlags)
    {
        // Wrap It: m_rIn -> m_rOut
        if (CP_UNICODE == m_cpiSource)
            CHECKHR(hr = HrWrapInternetTextW());
        else
            CHECKHR(hr = HrWrapInternetTextA());

        // Character Set Encoding: m_rOut -> m_rCset
        if (ICF_CODEPAGE & m_dwFlags)
        {
            // Charset Encode
            CHECKHR(hr = HrCodePageFromOutToCset());
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }
    }

    // Otherwise
    else
    {
        // Character Set Encoding: m_rCset -> m_rIn
        if (ICF_CODEPAGE & m_dwFlags)
        {
            // Charset Encode
            CHECKHR(hr = HrCodePageFromCsetToIn());
            if ( S_OK != hr )
                hrWarnings = TrapError(hr);
        }

        // Handle Conversion type
        switch(m_ietEncoding)
        {
        // Binary
        case IET_BINARY:
        case IET_7BIT:
        case IET_8BIT:
            // Better be at zero
            Assert(m_rIn.i == 0);

            // Initialize Blob to copy
            rData.pBlobData = m_rIn.pb;
            rData.cbSize = m_rIn.cb;

            // Append to outbound buffer
            CHECKHR(hr = HrAppendBuffer(&m_rOut, &rData, FALSE));

            // Increment offset
            m_rIn.i = m_rIn.cb = 0;
            break;

        // Quoted-Printable
        case IET_QP:
            CHECKHR(hr = HrEncodeQP());
            break;

        // Bas 64
        case IET_BASE64:
            CHECKHR(hr = HrEncode64());
            break;

        // UUENCODE
        case IET_UUENCODE:
            CHECKHR(hr = HrEncodeUU());
            break;

        // BINHEX
        case IET_BINHEX40:
#ifdef NEVER
            CHECKHR(hr = HrEncodeBinhex());
#endif  // NEVER
            // IE v. 5.0:33596 HrEncodeBinhex returns E_FAIL if body size is too small
            // Binhex encoding doesn't currently work.  I believe that it should work (or almost work)
            // if the header CBinhexEncoder::m_lpmacbinHdr is initialized properly.  However, this
            // requires understanding the Mac file format and parsing the body stream contents into
            // data and resource forks.
            // - sethco 8/19/1998
            CHECKHR(hr = MIME_E_INVALID_ENCODINGTYPE);
            break;

        // Bummer
        default:
            AssertSz(FALSE, "MIME_E_INVALID_ENCODINGTYPE");
            break;
        }
    }

exit:
    // If Last Buffer, we better be done
    Assert(m_fLastBuffer ? m_rIn.i == m_rIn.cb : TRUE);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrInternetDecode
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrInternetDecode(BOOL fLastBuffer)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;

    // We Better not be an encoder
    Assert(!m_fEncoder);

    // Set Last Buffer
    m_fLastBuffer = fLastBuffer;

    // Handle Format
    switch(m_ietEncoding)
    {
    // Binary
    case IET_BINARY:
    case IET_7BIT:
    case IET_8BIT:
        // Better be at zero
        Assert(m_rIn.i == 0);

        // Initialize Blob to copy
        rData.pBlobData = m_rIn.pb;
        rData.cbSize = m_rIn.cb;

        // Append to outbound buffer
        CHECKHR(hr = HrAppendBuffer(&m_rOut, &rData, FALSE));

        // Increment offset
        m_rIn.i = m_rIn.cb = 0;
        break;

    // Quoted-Printable
    case IET_QP:
        CHECKHR(hr = HrDecodeQP());
        break;

    // Bas64
    case IET_BASE64:
        CHECKHR(hr = HrDecode64());
        break;

    // UUENCODE
    case IET_UUENCODE:
        CHECKHR(hr = HrDecodeUU());
        break;

    // BINHEX
    case IET_BINHEX40:
        CHECKHR(hr = HrDecodeBinHex());
        break;

    // Bummer
    default:
        AssertSz(FALSE, "MIME_E_INVALID_ENCODINGTYPE");
        break;
    }

    // Character Set Decoding ?
    if (ICF_CODEPAGE & m_dwFlags)
    {
        // Charset Decoder
        CHECKHR(hr = HrCodePageFromOutToCset());
        if ( S_OK != hr )
           hrWarnings = TrapError(hr);
    }

exit:
    // If Last Buffer, we better be done
    Assert(m_fLastBuffer ? m_rIn.i == m_rIn.cb : TRUE);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrCodePageFromOutToCset
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrCodePageFromOutToCset(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;
    BLOB        rDecoded={0};
    ULONG       cbRead;

    // Nothing to convert...
    if (0 == m_rOut.cb)
        return S_OK;

    // Setup Convert Blob
    rData.pBlobData = m_rOut.pb;
    rData.cbSize = m_rOut.cb;

    // Decode text from m_intformat
    hr = g_pInternat->ConvertBuffer(m_cpiSource, m_cpiDest, &rData, &rDecoded, &cbRead);
    if (SUCCEEDED(hr) )
    {
        // save HRESULT from charset conversion
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill m_rIn...
        CHECKHR(hr = HrAppendBuffer(&m_rCset, &rDecoded, FALSE));
    }

    // Otherwise, just put m_rCset as the inbound buffer
    else
    {
        // SBAILEY: Raid-74506: MIMEOLE: error decoding text body in q-p encoded iso-2022-jp message
        // CHECKHR(hr = HrAppendBuffer(&m_rCset, &rData, FALSE));
        hr = S_OK;

        // We read all of it
        cbRead = rData.cbSize;
    }

    // Adjust m_rOut if cbRead != m_rOut.cb
    if (cbRead != m_rOut.cb)
    {
        // Move Memory
        MoveMemory(m_rOut.pb, m_rOut.pb + cbRead, m_rOut.cb - cbRead);
    }

    // Decrease Size
    Assert(cbRead <= m_rOut.cb);
    m_rOut.cb -= cbRead;

exit:
    // Cleanup
    SafeMemFree(rDecoded.pBlobData);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrCodePageFromCsetToIn
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrCodePageFromCsetToIn(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BLOB        rData;
    BLOB        rEncoded={0};
    ULONG       cbRead;

    // Check State
    Assert(m_rCset.i == 0);

    // Nothing to convert
    if (0 == m_rCset.cb)
        return S_OK;

    // Setup Convert Blob
    rData.pBlobData = m_rCset.pb;
    rData.cbSize = m_rCset.cb;

    // Decode text from m_intformat
    hr = g_pInternat->ConvertBuffer(m_cpiSource, m_cpiDest, &rData, &rEncoded, &cbRead);
    if (SUCCEEDED(hr) )
    {
        // save HRESULT from charset conversion
        if ( S_OK != hr )
            hrWarnings = TrapError(hr);

        // Fill m_rIn...
        CHECKHR(hr = HrAppendBuffer(&m_rIn, &rEncoded, FALSE));
    }

    // Otherwise, just put m_rCset as the inbound buffer
    else
    {
        // SBAILEY: Raid-74506: MIMEOLE: error decoding text body in q-p encoded iso-2022-jp message
        // CHECKHR(hr = HrAppendBuffer(&m_rIn, &rData, FALSE));
        hr = S_OK;

        // Set Read
        cbRead = m_rCset.cb;
    }

    // Adjust m_rOut if cbRead != m_rOut.cb
    if (cbRead != m_rCset.cb)
    {
        // Move Memory
        MoveMemory(m_rCset.pb, m_rCset.pb + cbRead, m_rCset.cb - cbRead);
    }

    // Decrease Size
    Assert(cbRead <= m_rCset.cb);
    m_rCset.cb -= cbRead;
    m_rCset.i = 0;

exit:
    // Cleanup
    SafeMemFree(rEncoded.pBlobData);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncode64
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncode64(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;
    ULONG       i;
    UCHAR       uch[3];
    UCHAR      *pbuf;

    // Read lines and stuff dots
    while(1)
    {
        // Compute encode buffer length
        cbRead = min(CCHMAX_ENCODE64_IN, m_rIn.cb - m_rIn.i);

        // Should we encode this buffer ?
        if (0 == cbRead || (cbRead < CCHMAX_ENCODE64_IN && FALSE == m_fLastBuffer))
            goto exit;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODE64_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODE64_OUT));
        }

        // Set Buffer Pointer
        pbuf = (m_rIn.pb + m_rIn.i);

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            // Setup Buffer
            uch[0] = pbuf[i];
            uch[1] = (i+1 < cbRead) ? pbuf[i+1] : '\0';
            uch[2] = (i+2 < cbRead) ? pbuf[i+2] : '\0';

            // Encode first tow
            ConvBuffAppend(g_rgchEncodeBase64[(uch[0] >> 2) & 0x3F]);
            ConvBuffAppend(g_rgchEncodeBase64[(uch[0] << 4 | uch[1] >> 4) & 0x3F]);

            // Encode Next
            if (i+1 < cbRead)
                ConvBuffAppend(g_rgchEncodeBase64[(uch[1] << 2 | uch[2] >> 6) & 0x3F]);
            else
                ConvBuffAppend('=');

            // Encode Net
            if (i+2 < cbRead)
                ConvBuffAppend(g_rgchEncodeBase64[(uch[2] ) & 0x3F]);
            else
                ConvBuffAppend('=');
        }

        // Increment iIn
        m_rIn.i += cbRead;

        // Ends encoded line and writes to storage
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecode64
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecode64(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    ULONG       i;
    ULONG       cPad=0;
    ULONG       cbRead=0;
    ULONG       cbLine;
    BOOL        fFound;
    LPSTR       pszLine;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
            goto exit;

        // Do I need to grow - decoded line will always be smaller than cbLine
        if (FGROWBUFFER(&m_rOut, cbLine))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cbLine));
        }

        // Decodes characters in line buffer
        for (i=0; i<cbLine; i++)
        {
            // Gets 4 legal Base64 characters, ignores if illegal
            uchThis = pszLine[i];

            // Decode It
            m_uchConvert[m_cbConvert] = DECODE64(uchThis);

            // Test for valid non-pad
            if ((m_uchConvert[m_cbConvert] < 64) || ((uchThis == '=') && (m_cbConvert > 1)))
                m_cbConvert++;

            // Test for pad
            if ((uchThis == '=') && (m_cbConvert > 1))
                cPad++;

            // Outputs when 4 legal Base64 characters are in the buffer
            if (4 == m_cbConvert)
            {
                // Validate Buffer
                Assert(m_rOut.cb + 4 <= m_rOut.cbAlloc);

                // Convert
                if (cPad < 3)
                    ConvBuffAppend((m_uchConvert[0] << 2 | m_uchConvert[1] >> 4));
                if (cPad < 2)
                    ConvBuffAppend((m_uchConvert[1] << 4 | m_uchConvert[2] >> 2));
                if (cPad < 1)
                    ConvBuffAppend((m_uchConvert[2] << 6 | m_uchConvert[3]));

                // Reset
                m_cbConvert = 0;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeUU
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncodeUU(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead, i;
    UCHAR       buf[CCHMAX_ENCODEUU_IN];

    // Read lines and stuff dots
    while(1)
    {
        // Compute encode buffer length
        cbRead = min(CCHMAX_ENCODEUU_IN, m_rIn.cb - m_rIn.i);
        if (0 == cbRead || (cbRead < CCHMAX_ENCODEUU_IN && FALSE == m_fLastBuffer))
            goto exit;

        // Copy the bytes
        CopyMemory(buf, m_rIn.pb + m_rIn.i, cbRead);

        // Zero the Rest
        ZeroMemory(buf + cbRead, sizeof(buf) - cbRead);

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODEUU_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODEUU_OUT));
        }

        // Encode Line length
        ConvBuffAppend(UUENCODE((UCHAR)cbRead));

        // Encodes 3 characters at a time
        for (i=0; i<cbRead; i+=3)
        {
            ConvBuffAppend(UUENCODE((buf[i] >> 2)));
            ConvBuffAppend(UUENCODE((buf[i] << 4) | (buf[i+1] >> 4)));
            ConvBuffAppend(UUENCODE((buf[i+1] << 2) | (buf[i+2] >> 6)));
            ConvBuffAppend(UUENCODE((buf[i+2])));
        }                                   

        // Increment i
        m_rIn.i += cbRead;

        // Ends encoded line and writes to storage
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

exit:
    // If last buffer and we can't read anymore
    if (TRUE == m_fLastBuffer && FALSE == FConvBuffCanRead(m_rIn))
    {
        // RAID-21179: ZeroLength uuencoded attachments m_rOut may not have been allocated
        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, CCHMAX_ENCODEUU_OUT))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, CCHMAX_ENCODEUU_OUT));
        }

        // Better have space
        Assert(m_rOut.cb + 3 < m_rOut.cbAlloc);

        // End
        ConvBuffAppend(UUENCODE(0));
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::FUUEncodeThrowAway
// --------------------------------------------------------------------------------
BOOL CInternetConverter::FUUEncodeThrowAway(LPSTR pszLine, ULONG cbLine, ULONG *pcbActual, ULONG *pcbLine)
{
    // Locals
    CHAR    ch;
    ULONG   cchOffset, cbEncoded, cbTolerance=0, cbExpected;

    // RAID-25953: "BEGIN --- CUT HERE --- Cut Here --- cut here ---" - WinVN post
    //             partial messages that have the following line at the beginning of
    //             each partial. B = 66 and the length of this line is 48, so the following
    //             code thinks that this line is a valid UUENCODED line, so, to fix this,
    //             we will throw out all lines that start with BEGIN since this is not valid
    //             to be in uuencode.
    if (StrCmpNI("BEGIN", pszLine, 5) == 0)
        return TRUE;

    // END Line
    else if (StrCmpNI("END", pszLine, 3) == 0)
        return TRUE;

    // Checks line length
    ch = *pszLine;
    *pcbLine = cbEncoded = UUDECODE(ch);

    // Comput tolerance and offset for non-conforming even line lengths
    cchOffset = (cbEncoded % 3);
    if (cchOffset != 0) 
    {
        cchOffset++;
        cbTolerance = 4 - cchOffset;
    }

    // Compute expected line length
    cbExpected = 4 * (cbEncoded / 3) + cchOffset; 

    // Always check for '-'
    if (cbLine < cbExpected)
        return TRUE;

    // Wack off trailing spaces
    while(pszLine[cbLine-1] == ' ' && cbLine > 0 && cbLine != cbExpected)
        --cbLine;

    // Checksum character and encoders which include the count char in the line count
    if (cbExpected != cbLine && cbExpected + cbTolerance != cbLine &&
        cbExpected + 1 != cbLine && cbExpected + cbTolerance + 1 != cbLine &&
        cbExpected - 1 != cbLine && cbExpected + cbTolerance - 1 != cbLine)
        return TRUE;

    // Set actual line length
    *pcbActual = cbLine;

    // Done
    return FALSE;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeUU
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeUU(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbLine;
    LPSTR       pszLine;
    ULONG       cbRead=0;
    ULONG       cbLineLength;
    BOOL        fFound;
    ULONG       cbConvert;
    ULONG       cbScan;
    ULONG       i;
    UCHAR       uchConvert[4];
    UCHAR       uchThis;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
            goto exit;

        // UUENCODE ThrowAway
        if (FUUEncodeThrowAway(pszLine, cbLine, &cbLine, &cbLineLength))
            continue;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, cbLineLength + 20))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cbLineLength + 20));
        }

        // Decodes 4 characters at a time
        for (cbConvert=0, cbScan=0, i=1; cbScan < cbLineLength; i++)
        {
            // Gets 4 characters, pads with blank if necessary
            uchThis = (i < cbLine) ? pszLine[i] : ' ';

            // Decode
            uchConvert[cbConvert++] = UUDECODE(uchThis);

            // Outputs decoded characters
            if (cbConvert == 4)
            {
                // Covnert
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[0] << 2) | (uchConvert[1] >> 4));
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[1] << 4) | (uchConvert[2] >> 2));
                if (cbScan++ < cbLineLength)
                    ConvBuffAppend((uchConvert[2] << 6) | (uchConvert[3]));

                // Reset
                cbConvert = 0;
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeQP
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrEncodeQP(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    ULONG       cbLine=0;
    ULONG       iCurrent;
    LONG        iLastWhite=-1;
    LONG        iLineWhite=-1;
    UCHAR       szLine[CCHMAX_QPLINE+30];

    // Set iCurrent
    iCurrent = m_rIn.i;

    // Read lines and stuff dots
    while (iCurrent < m_rIn.cb)
    {
        // Gets the next character
        uchThis = m_rIn.pb[iCurrent];

        // End of line...
        if (chLF == uchThis || cbLine > CCHMAX_QPLINE)
        {
            // Soft Line break
            if (chLF != uchThis)
            {
                // Lets back track to last white
                if (iLastWhite != -1)
                {
                    cbLine = iLineWhite + 1;
                    iCurrent = iLastWhite + 1;
                }

                // Hex encode the 8bit octet
                Assert(cbLine + 3 <= sizeof(szLine));
                szLine[cbLine++] = '=';
                szLine[cbLine++] = chCR;
                szLine[cbLine++] = chLF;
            }

            // Otherwise, we may need to encode the last space
            else
            {
                // Encode Straggling '\n'
                if (chCR != m_uchPrev)
                {
                    Assert(cbLine + 4 <= sizeof(szLine));
                    szLine[cbLine++] = '=';
                    szLine[cbLine++] = g_rgchHex[uchThis >> 4];
                    szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
                    szLine[cbLine++] = '=';
                }

                // Detect preceding whitespace ...
                if (cbLine && (' ' == szLine[cbLine - 1] || '\t' == szLine[cbLine - 1]))
                {
                    // Hex encode the 8bit octet
                    UCHAR chWhite = szLine[cbLine - 1];
                    cbLine--;
                    Assert(cbLine + 3 <= sizeof(szLine));
                    szLine[cbLine++] = '=';
                    szLine[cbLine++] = g_rgchHex[chWhite >> 4];
                    szLine[cbLine++] = g_rgchHex[chWhite & 0x0F];
                }

                // Otherwise, hard line break
                Assert(cbLine + 2 <= sizeof(szLine));
                szLine[cbLine++] = chCR;
                szLine[cbLine++] = chLF;
                iCurrent++;
            }

            // Copy the line
            CHECKHR(hr = HrConvBuffAppendBlock(szLine, cbLine));

            // Reset
            iLastWhite = -1;
            iLineWhite = -1;
            cbLine = 0;
            *szLine = '\0';

            // We processed this buffer
            m_rIn.i = iCurrent;
        }

        // Encode empty '\r'
        else if (chCR == uchThis)
        {
            // Overflow detection
            if (iCurrent + 1 < m_rIn.cb && m_rIn.pb[iCurrent + 1] != chLF || iCurrent + 1 >= m_rIn.cb)
            {
                Assert(cbLine + 3 <= sizeof(szLine));
                szLine[cbLine++] = '=';
                szLine[cbLine++] = g_rgchHex[uchThis >> 4];
                szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
            }

            // Next Character
            iCurrent++;
        }

        // Rule #1: Replace 8-bit and equal signs
        else if (('\t' != uchThis) && (uchThis < 32 || uchThis == 61 || uchThis > 126 || '=' == uchThis))
        {
            // Hex encode the 8bit octet
            Assert(chLF != uchThis);
            Assert(cbLine + 3 <= sizeof(szLine));
            szLine[cbLine++] = '=';
            szLine[cbLine++] = g_rgchHex[uchThis >> 4];
            szLine[cbLine++] = g_rgchHex[uchThis & 0x0F];
            iCurrent++;
        }

        // Otherwise, write the character
        else
        {
            // Save position of last white space
            if (' ' == uchThis || '\t' == uchThis)
            {
                iLastWhite = iCurrent;
                iLineWhite = cbLine;
            }

            // Rule #2: Printable literals
            Assert(cbLine + 1 <= sizeof(szLine));
            szLine[cbLine++] = uchThis;
            iCurrent++;
        }

        // Save Previous Char
        m_uchPrev = uchThis;
    }

    // Last line
    if (cbLine && m_fLastBuffer)
    {
        // Append the Line
        CHECKHR(hr = HrConvBuffAppendBlock(szLine, cbLine));

        // Set i
        m_rIn.i = m_rIn.cb;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeQP
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeQP(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UCHAR       uchThis;
    UCHAR       uchNext1;
    UCHAR       uchNext2;
    UCHAR       uch1;
    UCHAR       uch2;

    // Read lines and stuff dots
    while (FConvBuffCanRead(m_rIn))
    {
        // bug #35230 - display trash in trident
		// Can I read 2 more characters
		if (FALSE == m_fLastBuffer && m_rIn.i + 2 >= m_rIn.cb)
			break;

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, 3))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, 3));
        }

        // Gets the next character
        uchThis = m_rIn.pb[m_rIn.i];

        // Determine next couple of characers for end of line detection...
        uchNext1 = (m_rIn.i + 1 < m_rIn.cb) ? m_rIn.pb[m_rIn.i + 1] : '\0';
        uchNext2 = (m_rIn.i + 2 < m_rIn.cb) ? m_rIn.pb[m_rIn.i + 2] : '\0';

        // Dont break on \r\n
        if (chCR == uchNext1 && chLF == uchNext2 && m_rIn.i + 3 >= m_rIn.cb)
        {
            // If last buffer, then save characters
            if (m_fLastBuffer)
            {
                // If not a soft line break
                if ('=' != uchThis)
                {
                    ConvBuffAppend(uchThis);
                    ConvBuffAppend(chCR);
                    ConvBuffAppend(chLF);
                }

                // Done
                m_rIn.i += 3;
            }

            // Done
            goto exit;
        }

        // If not end of line...
        if ('=' == uchThis)
        {
            // Soft NL
            if (chCR == uchNext1 && chLF == uchNext2)
            {
                // Step over =\r\n
                m_rIn.i += 3;
            }

            // If not end of line...
            else if (m_rIn.i + 2 < m_rIn.cb)
            {
                // Step Over Equal Sign
                m_rIn.i++;

                // Convert Hex Characters
                uch1 = ChConvertFromHex(m_rIn.pb[m_rIn.i++]);
                uch2 = ChConvertFromHex(m_rIn.pb[m_rIn.i++]);

                // Store Hex characters 
                if (uch1 == 255 || uch2 == 255) 
                    ConvBuffAppend('=');
                else 
                    ConvBuffAppend((uch1 << 4) | uch2);
            }

            else
            {
                // Last Buffer ?
                ConvBuffAppend(uchThis);
                m_rIn.i++;
            }
        }

        // Otherwise store the character
        else if (chCR == uchThis && chLF == uchNext1)
        {
            // Stuff CRLF
            ConvBuffAppend(chCR);
            ConvBuffAppend(chLF);

            // Increment i
            m_rIn.i += 2;
        }

        // Otherwise, store the character
        else
        {
            ConvBuffAppend(uchThis);
            m_rIn.i++;
        }

        // Set Previous
        m_uchPrev = uchThis;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWrapInternetTextA
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWrapInternetTextA(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LONG        cchLine;
    LONG        cchSkip;

    // Read lines and stuff dots
    while(FConvBuffCanRead(m_rIn))
    {
        // Not enough to encode a full line and not the last buffer
        if ((FALSE == m_fLastBuffer) && ((LONG)(m_rIn.cb - m_rIn.i) < m_cchMaxLine))
            goto exit;

        // Call LineBreaker
        if (*((CHAR*)(m_rIn.pb + m_rIn.i)) == '\0')
        {
            // This is to prevent the endless loop in case of malformed data stream
            hr = TrapError(MIME_E_BAD_TEXT_DATA);
            goto exit;
        }
		
		CHECKHR(hr = m_pLineBreak->BreakLineA(m_lcid, m_cpiSource, (LPCSTR)(m_rIn.pb + m_rIn.i), (m_rIn.cb - m_rIn.i), m_cchMaxLine, &cchLine, &cchSkip));

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, cchLine + 5))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, cchLine + 5));
        }
    
        // Have some data ?
        if (cchLine)
        {
            // Write the line
            CHECKHR(hr = HrConvBuffAppendBlock(m_rIn.pb + m_rIn.i, cchLine));
        }

        // Write CRLF
        Assert(m_rOut.cb + 2 < m_rOut.cbAlloc);
        ConvBuffAppend(chCR);
        ConvBuffAppend(chLF);

        // Increment iText
        m_rIn.i += (cchLine + cchSkip);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrWrapInternetTextW
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrWrapInternetTextW(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LONG        cchLine;
    LONG        cchSkip;

    // Invalid State
    Assert(m_pLineBreak);

    // Read lines and stuff dots
    while(FConvBuffCanRead(m_rIn))
    {
        // Not enough to encode a full line and not the last buffer
        if ((FALSE == m_fLastBuffer) && ((LONG)((m_rIn.cb - m_rIn.i) / sizeof(WCHAR)) < m_cchMaxLine))
            goto exit;

        // Call LineBreaker
        if (*((WCHAR*)(m_rIn.pb + m_rIn.i)) == L'\0')
        {
            // This is to prevent the endless loop in case of malformed data stream
            hr = TrapError(MIME_E_BAD_TEXT_DATA);
            goto exit;
        }

        CHECKHR(hr = m_pLineBreak->BreakLineW(m_lcid, (LPCWSTR)(m_rIn.pb + m_rIn.i), ((m_rIn.cb - m_rIn.i) / sizeof(WCHAR)), m_cchMaxLine, &cchLine, &cchSkip));

        // Do I need to grow
        if (FGROWBUFFER(&m_rOut, ((cchLine + 5) * sizeof(WCHAR))))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rOut, ((cchLine + 5) * sizeof(WCHAR))));
        }

        // Have some data
        if (cchLine)
        {
            // Write the line
            CHECKHR(hr = HrConvBuffAppendBlock(m_rIn.pb + m_rIn.i, (cchLine * sizeof(WCHAR))));
        }

        // Write CRLF
        Assert(m_rOut.cb + (2 * sizeof(WCHAR)) < m_rOut.cbAlloc);
        ConvBuffAppendW(wchCR);
        ConvBuffAppendW(wchLF);

        // Increment iText
        m_rIn.i += ((cchLine + cchSkip) * sizeof(WCHAR));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrEncodeDecodeBinhex
// --------------------------------------------------------------------------------
const CHAR szBINHEXSTART[] = "(This file must be converted with BinHex";
const ULONG cbBINHEXSTART = lstrlen(szBINHEXSTART);
HRESULT CInternetConverter::HrEncodeBinhex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrError;
    ULONG       cbLeft;
    ULONG       cbRead;
    ULONG       cbMaxEncode;
    ULONG       cbWrite;

    // cbLeft
    cbLeft = m_rIn.cb - m_rIn.i;

    // cbMaxEncode - this should always insure enough room
    cbMaxEncode = cbLeft * 2;

    // Do I need to grow
    if (FGROWBUFFER(&m_rOut, cbMaxEncode))
    {
        // Grow the buffer
        CHECKHR(hr = HrGrowBuffer(&m_rOut, cbMaxEncode));
    }

    // Set max amount to read
    cbRead = cbLeft;

    // Set max amount to write
    cbWrite = cbLeft;

    // We better want to read some
    Assert(cbRead && cbWrite);

    // Encode/Decode some data
    if (m_fEncoder)
    {
        // Encode
        if (ERROR_SUCCESS != m_pBinhexEncode->HrEmit(m_rIn.pb + m_rIn.i, &cbRead, m_rOut.pb + m_rOut.cb, &cbWrite))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Increment Amount Read
    m_rIn.i += cbRead;

    // Increment Amount Wrote
    m_rOut.cb += cbWrite;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrBinhexThrowAway
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrBinhexDecodeBuffAppend(UCHAR uchIn, ULONG cchIn, ULONG cchLeft, ULONG * pcbProduced)
{
    HRESULT hr = S_FALSE;
    ULONG   cbPad = 0;
    LPBYTE  pbBinHex = NULL;
    
    if (m_eBinHexStateDec == sHDRFILESIZE)
    {
        // First incoming character is always the size of the stream.
        Assert(cchIn == 1);
        if ((uchIn < 1) || (uchIn > 63))
        {
            hr = E_FAIL; // ERROR_INVALID_DATA
            m_eBinHexStateDec = sENDED;
            goto exit;
        }

        // Allocate the binhex header
        if (FGROWBUFFER(&m_rBinhexHeader, cbMinBinHexHeader + uchIn))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cbMinBinHexHeader + uchIn));
        }
        
        // Mark how many characters are left to process
        m_cbToProcess = cbMinBinHexHeader + uchIn;
        
        // Switch to filling the header sHEADER
        m_prBinhexOutput = &m_rBinhexHeader;
        m_eBinHexStateDec = sHEADER;
    }

    if (1 == cchIn)
    {
        m_prBinhexOutput->pb[m_prBinhexOutput->cb++] = uchIn;
    }
    else
    {
        // Check output buffer for space
        if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
        }

        // Fill output buffer
        FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn, uchIn);
        m_prBinhexOutput->cb += cchIn;
    }

    // Are we done processing this fork?
    if (m_cbToProcess <= (LONG) cchIn)
    {
        switch (m_eBinHexStateDec)
        {
        case sHEADER:
            // Verify that we have the correct CRC
            m_wCRC = 0;
            
            BinHexCalcCRC16((LPBYTE) m_rBinhexHeader.pb, cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 2, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            if ( HIBYTE( m_wCRC ) != m_rBinhexHeader.pb[cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 2] 
              || LOBYTE( m_wCRC ) != m_rBinhexHeader.pb[cbMinBinHexHeader + *(m_rBinhexHeader.pb) - 1] )
            {
                hr = E_FAIL; // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            *pcbProduced = 0;
            
            // Switch to using the correct buffer
            m_prBinhexOutput = &m_rOut;
            cchIn -= m_cbToProcess;
            
            // Save off the size of the two forks
            pbBinHex = m_rBinhexHeader.pb + m_rBinhexHeader.pb[0] + cbMinBinHexHeader - 10;
            m_cbDataFork = NATIVE_LONG_FROM_BIG(pbBinHex);
            m_cbResourceFork =NATIVE_LONG_FROM_BIG(pbBinHex + 4);
            
            if (FALSE == m_fDataForkOnly)
            {
                // Copy extra data into new buffer
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn + sizeof(MACBINARY)))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn + sizeof(MACBINARY)));
                }

                // Write out the MacBinary header
                CHECKHR(hr = HrCreateMacBinaryHeader(&m_rBinhexHeader, m_prBinhexOutput));
            }
            
            if (m_cbDataFork > 0)
            {
                // Fill output buffer
                FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn, uchIn);
                m_prBinhexOutput->cb += cchIn;
                
                // delete binhex header buffer
                SafeMemFree(m_rBinhexHeader.pb);
                ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

                m_cbToProcess = m_cbDataFork;
                
                // Switch to doing the data fork.
                m_eBinHexStateDec = sDATA;
            }
            else
            {
                BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
                
                // Save off the CRC until we can get the CRC from the fork.
                m_wCRCForFork = m_wCRC;
                
                m_prBinhexOutput = &m_rBinhexHeader;
                
                // Remove the HEADER from the buffer
                FillMemory(m_prBinhexOutput->pb, cchIn, uchIn);
                m_prBinhexOutput->cb = cchIn;
                
                // Switch to filling the data CRC
                m_cbToProcess = 2;
                m_eBinHexStateDec = sDATACRC;
                
            }
            break;
            
        case sDATA:
            // Verify that we have the correct CRC
            BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn - *pcbProduced,
                                    m_cbToProcess + *pcbProduced, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            // Save off the CRC until we can get the CRC from the fork.
            m_wCRCForFork = m_wCRC;
            m_wCRC = 0;
            *pcbProduced = 0;
            cchIn -= m_cbToProcess;
            
            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(&m_rBinhexHeader, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_rBinhexHeader.pb + m_rBinhexHeader.cb),
                        (m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn);
            m_rBinhexHeader.cb += cchIn;
                
            // We only need to pad for a real Mac file...
            if (FALSE == m_fDataForkOnly)
            {
                // Check to see if the size of the fork is a multiple of 128?
                cbPad = 128 - (m_cbDataFork % 128);
                if (cbPad != 0)
                {
                    uchIn = '\0';
                    
                    // Check output buffer for space
                    if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cbPad - cchIn))
                    {
                        // Grow the buffer
                        CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cbPad - cchIn));
                    }

                    // Fill output buffer
                    FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn), cbPad, uchIn);
                    m_prBinhexOutput->cb += cbPad - cchIn;
                }
            }
            
            // Switch to filling the data fork CRC
            m_prBinhexOutput = &m_rBinhexHeader;
            m_cbToProcess = 2;
            m_eBinHexStateDec = sDATACRC;
            
            break;
            
        case sDATACRC:
            if ( HIBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[0] 
              || LOBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[1] )
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            cchIn -= m_cbToProcess;
            *pcbProduced = 0;

            if (m_cbResourceFork > 0)
            {
                m_prBinhexOutput = &m_rOut;
                
                // Switch to the proper buffer for CRC calculations
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
                }
                
                // Move any current bytes so we don't overwrite anything
                CopyMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb),
                            (m_rBinhexHeader.pb + m_rBinhexHeader.cb), cchIn);
                m_prBinhexOutput->cb += cchIn;
                    
                // delete binhex header buffer
                SafeMemFree(m_rBinhexHeader.pb);
                ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

                // Switch to filling the resource fork
                if (FALSE == m_fDataForkOnly)
                {
                    m_cbToProcess = m_cbResourceFork;
                    m_eBinHexStateDec = sRESOURCE;
                }
                else
                {
                    m_cbToProcess = 0x0;
                    m_eBinHexStateDec = sENDING;
                }
            }
            else
            {
                // Set the CRC for the data fork.
                BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
                
                // Save off the CRC until we can get the CRC from the fork.
                m_wCRCForFork = m_wCRC;
                
                // Remove the DATA CRC from the buffer
                MoveMemory(m_prBinhexOutput->pb, m_prBinhexOutput->pb + 2, m_prBinhexOutput->cb - 2);
                m_prBinhexOutput->cb -= 2;
                
                // Switch to filling the resource CRC
                m_cbToProcess = 2;
                m_eBinHexStateDec = sRESOURCECRC;
            }
            break;
            
        case sRESOURCE:
            // Verify that we have the correct CRC
            BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn - *pcbProduced,
                                    m_cbToProcess + *pcbProduced, &(m_wCRC));
            BinHexCalcCRC16((LPBYTE) &wBinHexZero, sizeof(wBinHexZero), &(m_wCRC));
            
            // Save off the CRC until we can get the CRC from the fork.
            m_wCRCForFork = m_wCRC;
            m_wCRC = 0;
            *pcbProduced = 0;
            cchIn -= m_cbToProcess;

            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(&m_rBinhexHeader, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(&m_rBinhexHeader, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_rBinhexHeader.pb + m_rBinhexHeader.cb),
                        (m_prBinhexOutput->pb + m_prBinhexOutput->cb), cchIn);
            m_rBinhexHeader.cb += cchIn;
                
            // Check to see if the size of the fork is a multiple of 128?
            cbPad = 128 - (m_cbResourceFork % 128);
            if (cbPad != 0)
            {
                uchIn = '\0';
                
                // Check output buffer for space
                if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cbPad - cchIn))
                {
                    // Grow the buffer
                    CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cbPad - cchIn));
                }

                // Fill output buffer
                FillMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb - cchIn), cbPad, uchIn);
                m_prBinhexOutput->cb += cbPad - cchIn;
            }
            
            // Switch to filling the resource fork CRC
            m_prBinhexOutput = &m_rBinhexHeader;
            m_cbToProcess = 2;
            m_eBinHexStateDec = sRESOURCECRC;
            break;
            
        case sRESOURCECRC:
            if ( HIBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[0] 
              || LOBYTE( m_wCRCForFork ) != m_prBinhexOutput->pb[1] )
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }
            
            m_wCRC = 0;
            cchIn -= m_cbToProcess;
            m_prBinhexOutput = &m_rOut;
            *pcbProduced = 0;

            // Switch to the proper buffer for CRC calculations
            if (FGROWBUFFER(m_prBinhexOutput, cchLeft + cchIn))
            {
                // Grow the buffer
                CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cchLeft + cchIn));
            }
            
            // Move any current bytes so we don't overwrite anything
            CopyMemory((m_prBinhexOutput->pb + m_prBinhexOutput->cb),
                        (m_rBinhexHeader.pb + m_rBinhexHeader.cb), cchIn);
            m_prBinhexOutput->cb += cchIn;
                
            // delete binhex header buffer
            SafeMemFree(m_rBinhexHeader.pb);
            ZeroMemory(&m_rBinhexHeader, sizeof(CONVERTBUFFER));

            // Switch to filling the resource fork
            m_cbToProcess = 0x0;
            m_eBinHexStateDec = sENDING;
            break;
            
        default:
            Assert(FALSE);
            break;
        }
    }

    m_cbToProcess -= cchIn;
    
    *pcbProduced += cchIn;
    
    hr = S_OK;
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrBinhexThrowAway
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrBinhexThrowAway(LPSTR pszLine, ULONG cbLine)
{
    HRESULT hr = S_FALSE;
    
    if (m_eBinHexStateDec == sSTARTING)
    {
        // Ingore all lines before we start that only have whitespace characters
        // or the start tag.
        hr = S_OK;
        
        for (LPSTR pszEnd = pszLine + cbLine; pszLine < pszEnd; pszLine++)
        {
            if (!FBINHEXRETURN(*pszLine))
            {
                // Need to ignore lines that start with the tag
                if (((ULONG)(pszEnd - pszLine) >= cbBINHEXSTART) && (StrCmpNI(szBINHEXSTART, pszLine, cbBINHEXSTART) == 0))
                {
                    m_eBinHexStateDec = sSTARTED;
                    break;
                }
                
                // We must have gotten bad data
                hr = E_FAIL;    // ERROR_INVALID_DATA
                m_eBinHexStateDec = sENDED;
                goto exit;
            }
        }
        
    }
    else if (m_eBinHexStateDec == sENDED)
    {
        // We can ignore any lines after we are done.
        hr = S_OK;
    }
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetConverter::HrDecodeBinHex
// --------------------------------------------------------------------------------
HRESULT CInternetConverter::HrDecodeBinHex(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbLine;
    LPSTR       pszLine;
    ULONG       cbRead=0;
    ULONG       cbLineLength;
    BOOL        fFound;
    ULONG       cbConvert;
    ULONG       cbScan;
    ULONG       i;
    UCHAR       uchConvert[4];
    UCHAR       uchThis;
    UCHAR       uchDecoded;
    UCHAR       cuchWrite;
    UCHAR       rgbShift[] = {0, 4, 2, 0};
    ULONG       cbProduced = 0;

    // Read lines and stuff dots
    while(1)
    {
        // Increment Index
        m_rIn.i += cbRead;

        // Get Next Line
        pszLine = PszConvBuffGetNextLine(&cbLine, &cbRead, &fFound);
        if (0 == cbRead || (FALSE == fFound && FALSE == m_fLastBuffer))
        {
            goto exit;
        }

        // UUENCODE ThrowAway
        hr = HrBinhexThrowAway(pszLine, cbLine);
        if (FAILED(hr))
        {
            goto exit;
        }
        else if (S_OK == hr)
        {
            continue;
        }

        hr = S_OK;

        // Do I need to grow
        if (FGROWBUFFER(m_prBinhexOutput, cbLine + 20))
        {
            // Grow the buffer
            CHECKHR(hr = HrGrowBuffer(m_prBinhexOutput, cbLine + 20));
        }

        AssertSz((m_eBinHexStateDec != sSTARTING) && (m_eBinHexStateDec != sENDED),
                                "Why haven't we found the start of the stream yet??\n");
        
        // Decodes characters in line buffer
        for (i=0; i<cbLine; i++)
        {
            uchThis = pszLine[i];

            // Check for valid white space
            if (FBINHEXRETURN(uchThis))
                continue;
                
            // Check for start or end of stream
            if (BINHEX_TERM == uchThis)
            {
                if (m_eBinHexStateDec == sSTARTED)
                {
                    m_eBinHexStateDec = sHDRFILESIZE;
                    continue;
                }
                else if (m_eBinHexStateDec == sENDING)
                {
                    m_eBinHexStateDec = sENDED;
                    break;
                }
            }
            
            if (m_eBinHexStateDec == sENDING)
            {
                if (('!' == uchThis) || (TRUE == m_fDataForkOnly))
                {
                    continue;
                }
                else
                {
                    // ensure that we're not in an invalid state. If we made it to sENDING and we got
                    // valid CRCs and everything is hunky dory, just ignore the terminating stuff.
                    continue;
                }
            }
            
            // Decode It
            uchDecoded = DECODEBINHEX(uchThis);

            // Test for valid char
            if (uchDecoded == BINHEX_INVALID)
            {
                hr = E_FAIL;    // ERROR_INVALID_DATA
                goto exit;
            }

            if ( m_cAccum == 0 )
            {
                m_ulAccum = uchDecoded;
                ++m_cAccum;
                continue;
            }
            else
            {
                m_ulAccum = ( m_ulAccum << 6 ) | uchDecoded;
                uchDecoded = (BYTE)(m_ulAccum >> rgbShift[m_cAccum]) & 0xff;
                m_cAccum++;
                m_cAccum %= sizeof(m_ulAccum);
            }

            // If we are repeating then fill the buffer with char
            if (m_fRepeating)
            {
                m_fRepeating = FALSE;
                
                // Check to see if it's just a literal 0x90
                if (0x00 == uchDecoded)
                {
                    // Just write out one BINHEX_REPEAT char
                    m_uchPrev = BINHEX_REPEAT;
                    cuchWrite = 1;
                }
                else
                {
                    cuchWrite = uchDecoded - 1;
                }
            }
            
            // Check for repeat character
            else if (BINHEX_REPEAT == uchDecoded)
            {
                m_fRepeating = TRUE;
                continue;
            }

            // Else it's just a normal character.
            else
            {
                m_uchPrev = uchDecoded;
                cuchWrite = 1;
            }

            CHECKHR(HrBinhexDecodeBuffAppend(m_uchPrev, cuchWrite, cbLine - i, &cbProduced));
        }

        BinHexCalcCRC16((LPBYTE) m_prBinhexOutput->pb + m_prBinhexOutput->cb - cbProduced, cbProduced, &(m_wCRC));
        cbProduced = 0;
    }

    hr = S_OK;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetdate.cpp ===
// --------------------------------------------------------------------------------
// Inetdate.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "strconst.h"
#include "dllmain.h"

// ------------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------------
BOOL FFindMonth(LPCSTR pszMonth, LPSYSTEMTIME pst);
BOOL FFindDayOfWeek(LPCSTR pszDayOfWeek, LPSYSTEMTIME pst);
void ProcessTimeZoneInfo(LPCSTR pszTimeZone, ULONG cchTimeZone, LONG *pcHoursToAdd, LONG *pcMinutesToAdd);

// ------------------------------------------------------------------------------------------
// Date Conversion Data
// ------------------------------------------------------------------------------------------
#define CCHMIN_INTERNET_DATE    5

// ------------------------------------------------------------------------------------------
// Date Conversion States
// ------------------------------------------------------------------------------------------
#define IDF_MONTH       FLAG01
#define IDF_DAYOFWEEK   FLAG02
#define IDF_TIME        FLAG03
#define IDF_TIMEZONE    FLAG04
#define IDF_MACTIME     FLAG05
#define IDF_DAYOFMONTH  FLAG06
#define IDF_YEAR        FLAG07

static const char c_szTZ[] = "TZ";

// ------------------------------------------------------------------------------------------
// MimeOleInetDateToFileTime - Tue, 21 Jan 1997 18:25:40 GMT
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleInetDateToFileTime(LPCSTR pszDate, LPFILETIME pft)
{
    // Locals
    HRESULT         hr=S_OK;
    SYSTEMTIME      st={0};
    ULONG           cchToken;
    LPCSTR          pszToken;
    LONG            cHoursToAdd=0, cMinutesToAdd=0;
    DWORD           dwState=0;
    LONG            lUnitsToAdd = 0;
    CStringParser   cString;
    LARGE_INTEGER   liTime;
    BOOL            fRemovedDash = FALSE;
    LONGLONG        liHoursToAdd = 1i64, liMinutesToAdd = 1i64;

    // Check Params
    if (NULL == pszDate || NULL == pft)
        return TrapError(E_INVALIDARG);

    // Init the String Parser
    cString.Init(pszDate, lstrlen(pszDate), PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_NOCOMMENTS | PSF_ESCAPED);

    // Init systime
    st.wMonth = st.wDay = 1;

    // SetTokens
    cString.SetTokens(c_szCommaSpaceDash);

    // While we have characters to process
    while(1)
    {
        // IMAP has non-standard date format that uses "-" delimiter instead of " ".
        // When we're pretty sure we don't need "-" anymore, jettison from token list
        // otherwise we will mess up timezone parsing (which can start with a "-")
        // NOTE that we assume that we NEVER have to stuff the dash back in. We only need
        // the dash for IMAP dates, and IMAP dates should ALWAYS come before the time.
        if (FALSE == fRemovedDash &&
            ((dwState & IDF_YEAR) || ((dwState & (IDF_TIME | IDF_TIMEZONE)) == IDF_TIME))) // In case NO DATE or time BEFORE date
        {
            cString.SetTokens(c_szCommaSpace); // Remove dash from token list
            fRemovedDash = TRUE;
        }

        // Scan to ", " or "-" in IMAP case
        cString.ChParse();

        // Get parsed Token
        cchToken = cString.CchValue();
        pszToken = cString.PszValue();

        // Done
        if (0 == cchToken)
            break;

        // If the Word is not a digit
        if (IsDigit((LPSTR)pszToken) == FALSE)
        {
            // We haven't found the month
            if (!(IDF_MONTH & dwState))
            {
                // Lookup the Month
                if (FFindMonth(pszToken, &st) == TRUE)
                {
                    dwState |= IDF_MONTH;
                    continue;
                }
            }

            // We haven't found the day of the week
            if (!(IDF_DAYOFWEEK & dwState))
            {
                // Lookup the Month
                if (FFindDayOfWeek(pszToken, &st) == TRUE)
                {
                    dwState |= IDF_DAYOFWEEK;
                    continue;
                }
            }

            // Time Zone
            if ((IDF_TIME & dwState) && !(IDF_TIMEZONE & dwState))
            {
                dwState |= IDF_TIMEZONE;
                ProcessTimeZoneInfo(pszToken, cchToken, &cHoursToAdd, &cMinutesToAdd);
            }

            // Support "AM" and "PM" from Mac Mail Gateway
            if (IDF_MACTIME & dwState)
            {
                // Token Length
                if (2 == cchToken)
                {
                    if (lstrcmpi("PM", pszToken) == 0)
                    {
                        if (st.wHour < 12)
                            st.wHour += 12;
                    }
                    else if (lstrcmpi("AM", pszToken) == 0)
                    {
                        if (st.wHour == 12)
                            st.wHour = 0;
                    }
                }
            }
        }

        else
        {
            // Does string have a colon in it
            LPSTR pszColon = PszScanToCharA((LPSTR)pszToken, ':');

            // Found colon and time has not been found
            if (!(IDF_TIME & dwState) && '\0' != *pszColon)
            {
                // Its a time stamp - TBD - DBCS this part - AWN 28 Mar 94
                if (7 == cchToken || 8 == cchToken)
                {
                    // Locals
                    CHAR szTemp[CCHMAX_INTERNET_DATE];

                    // Prefix with zero to make eight
                    if (cchToken == 7)
                        wsprintf(szTemp, "0%s", pszToken);
                    else
                        lstrcpy(szTemp, pszToken);

                    // convert the time into system time
                    st.wHour   = (WORD) StrToInt(szTemp);
                    st.wMinute = (WORD) StrToInt(szTemp + 3);
                    st.wSecond = (WORD) StrToInt(szTemp + 6);

                    // Adjustments if needed
                    if (st.wHour < 0 || st.wHour > 24)
                        st.wHour = 0;
                    if (st.wMinute < 0 || st.wMinute > 59)
                        st.wMinute = 0;
                    if (st.wSecond < 0 || st.wSecond > 59)
                        st.wSecond = 0;

                    // We found the time
                    dwState |= IDF_TIME;
                }

                // This if process times of the time 12:01 AM or 01:45 PM
                else if (cchToken < 6 && lstrlen(pszColon) <= 3)
                {
                    // rgchWord is pointing to hour.
                    st.wHour = (WORD) StrToInt(pszToken);

                    // Step over colon
                    Assert(':' == *pszColon);
                    pszColon++;

                    // Get Minute
                    st.wMinute = (WORD) StrToInt(pszColon);
                    st.wSecond = 0;

                    // It should never happen, but do bounds check anyway.
                    if (st.wHour < 0 || st.wHour > 24)
                         st.wHour = 0;
                    if (st.wMinute < 0 || st.wMinute > 59)
                         st.wMinute = 0;

                    // Mac Time
                    dwState |= IDF_TIME;
                    dwState |= IDF_MACTIME;
                }
            }
            else
            {
                // Convert to int
                ULONG ulValue = StrToInt(pszToken);

                // Day of month
                if (!(IDF_DAYOFMONTH & dwState) && ulValue < 32)
                {
                    // Set Day of Month
                    st.wDay = (WORD)ulValue;

                    // Adjust
                    if (st.wDay < 1 || st.wDay > 31)
                         st.wDay = 1;

                    // Set State
                    dwState |= IDF_DAYOFMONTH;
                }

                // Year
                else if (!(IDF_YEAR & dwState))
                {
                    // 2-digit year
                    if (ulValue < 100) // 2-digit year
                    {
                        // Compute Current Year
                        ulValue += (((ulValue > g_ulY2kThreshold) ? g_ulUpperCentury - 1 : g_ulUpperCentury) * 100);
                    }

                    // Set Year
                    st.wYear = (WORD)ulValue;

                    // Set State
                    dwState |= IDF_YEAR;
                }
            }
        }
    }

    // Convert sys time to file time
    if (SystemTimeToFileTime(&st, pft) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_INET_DATE);
        goto exit;
    }

    // No time zone was found ?
    if (!ISFLAGSET(dwState, IDF_TIMEZONE))
    {
        // Get default time zone
        ProcessTimeZoneInfo(c_szTZ, lstrlen(c_szTZ), &cHoursToAdd, &cMinutesToAdd);
    }

    // Init
    liTime.LowPart  = pft->dwLowDateTime;
    liTime.HighPart = pft->dwHighDateTime;

    // Adjust the hour
    if (cHoursToAdd != 0)
    {
        lUnitsToAdd = cHoursToAdd * 3600;
        liHoursToAdd *= lUnitsToAdd;
        liHoursToAdd *= 10000000i64;
        liTime.QuadPart += liHoursToAdd;
    }

    // Adjust the minutes
    if (cMinutesToAdd != 0)
    {
        lUnitsToAdd = cMinutesToAdd * 60;
        liMinutesToAdd *= lUnitsToAdd;
        liMinutesToAdd *= 10000000i64;
        liTime.QuadPart += liMinutesToAdd;
    }

    // Assign the result to FILETIME
    pft->dwLowDateTime  = liTime.LowPart;
    pft->dwHighDateTime = liTime.HighPart;

exit:
    // Failure Defaults to current time...
    if (FAILED(hr))
    {
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, pft);
    }

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// FFindMonth
// ------------------------------------------------------------------------------------------
BOOL FFindMonth(LPCSTR pszMonth, LPSYSTEMTIME pst)
{
    // Locals
    ULONG ulIndex;

    // Index of Month, one-based
    if (FAILED(HrIndexOfMonth(pszMonth, &ulIndex)))
        return FALSE;

    // Set It
    pst->wMonth = (WORD)ulIndex;

    // Found It
    return TRUE;
}

// ------------------------------------------------------------------------------------------
// FFindDayOfWeek
// ------------------------------------------------------------------------------------------
BOOL FFindDayOfWeek(LPCSTR pszDayOfWeek, LPSYSTEMTIME pst)
{
    // Locals
    ULONG ulIndex;

    // Index of Day, 0 based
    if (FAILED(HrIndexOfWeek(pszDayOfWeek, &ulIndex)))
        return FALSE;

    // Set It
    pst->wDayOfWeek = (WORD)ulIndex;

    // Failure
    return TRUE;
}

// ------------------------------------------------------------------------------------------
// ProcessTimeZoneInfo
// ------------------------------------------------------------------------------------------
void ProcessTimeZoneInfo(LPCSTR pszTimeZone, ULONG cchTimeZone, LONG *pcHoursToAdd, LONG *pcMinutesToAdd)
{
    // Locals
    CHAR szTimeZone[CCHMAX_INTERNET_DATE];

    // Invalid Arg
    Assert(pszTimeZone && pcHoursToAdd && pcMinutesToAdd && cchTimeZone <= sizeof(szTimeZone));

    // Copy buffer so we can but nulls into it...
    CopyMemory(szTimeZone, pszTimeZone, (sizeof(szTimeZone) < cchTimeZone + 1)?sizeof(szTimeZone):cchTimeZone + 1);

    // Init
    *pcHoursToAdd = *pcMinutesToAdd = 0;

    // +hhmm or -hhmm
    if (('-' == *szTimeZone || '+' == *szTimeZone) && cchTimeZone <= 5)
    {
        // Take off
        cchTimeZone -= 1;

        // determine the hour/minute offset
        if (cchTimeZone == 4)
        {
            *pcMinutesToAdd = StrToInt(szTimeZone + 3);
            *(szTimeZone + 3) = 0x00;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        // 3
        else if (cchTimeZone == 3)
        {
            *pcMinutesToAdd = StrToInt(szTimeZone + 2);
            *(szTimeZone + 2) = 0x00;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        // 2
        else if (cchTimeZone == 2 || cchTimeZone == 1)
        {
            *pcMinutesToAdd = 0;
            *pcHoursToAdd = StrToInt(szTimeZone + 1);
        }

        if ('+' == *szTimeZone)
        {
            *pcHoursToAdd = -(*pcHoursToAdd);
            *pcMinutesToAdd = -(*pcMinutesToAdd);
        }
    }

    //  Xenix conversion:  TZ = current time zone or other unknown tz types.
    else if (lstrcmpi(szTimeZone, "TZ") == 0 || lstrcmpi(szTimeZone, "LOCAL") == 0 || lstrcmpi(szTimeZone, "UNDEFINED") == 0)
    {
        // Locals
        TIME_ZONE_INFORMATION tzi ;
        DWORD dwResult;
        LONG  cMinuteBias;

        // Get Current System Timezone Information
        dwResult = GetTimeZoneInformation (&tzi);
        AssertSz(dwResult != 0xFFFFFFFF, "GetTimeZoneInformation Failed.");

        // If that didn't fail
        if (dwResult != 0xFFFFFFFF)
        {
            // Locals
            cMinuteBias = tzi.Bias;

            // Modify Minute Bias
            if (dwResult == TIME_ZONE_ID_STANDARD)
                cMinuteBias += tzi.StandardBias;
            else if (dwResult == TIME_ZONE_ID_DAYLIGHT)
                cMinuteBias += tzi.DaylightBias ;

            // Adjust ToAdd Returs
            *pcHoursToAdd = cMinuteBias / 60;
            *pcMinutesToAdd = cMinuteBias % 60;
        }
    }

    // Loop through known time zone standards
    else
    {
        // Locals
        INETTIMEZONE rTimeZone;

        // Find time zone info
        if (FAILED(HrFindInetTimeZone(szTimeZone, &rTimeZone)))
            DebugTrace("Unrecognized zone info: [%s]\n", szTimeZone);
        else
        {
            *pcHoursToAdd = rTimeZone.cHourOffset;
            *pcMinutesToAdd = rTimeZone.cMinuteOffset;
        }
    }
}

// ------------------------------------------------------------------------------------------
// MimeOleFileTimeToInetDate
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFileTimeToInetDate(LPFILETIME pft, LPSTR pszDate, ULONG cchMax)
{
    // Locals
    SYSTEMTIME st;
    DWORD      dwTimeZoneId=TIME_ZONE_ID_UNKNOWN;
    CHAR       cDiff;
    LONG       ltzBias=0;
    LONG       ltzHour;
    LONG       ltzMinute;
    TIME_ZONE_INFORMATION tzi;

    // Invalid Arg
    if (NULL == pszDate)
        return TrapError(E_INVALIDARG);
    if (cchMax < CCHMAX_INTERNET_DATE)
        return TrapError(MIME_E_BUFFER_TOO_SMALL);

    // Verify lpst is set
    if (pft == NULL || (pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0))
    {
        GetLocalTime(&st);
    }
    else
    {
        FILETIME ftLocal;
        FileTimeToLocalFileTime(pft, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &st);
    }

    // Gets TIME_ZONE_INFORMATION
    dwTimeZoneId = GetTimeZoneInformation (&tzi);
    switch (dwTimeZoneId)
    {
    case TIME_ZONE_ID_STANDARD:
        ltzBias = tzi.Bias + tzi.StandardBias;
        break;

    case TIME_ZONE_ID_DAYLIGHT:
        ltzBias = tzi.Bias + tzi.DaylightBias;
        break;

    case TIME_ZONE_ID_UNKNOWN:
    default:
        ltzBias = tzi.Bias;
        break;
    }

    // Set Hour Minutes and time zone dif
    ltzHour = ltzBias / 60;
    ltzMinute = ltzBias % 60;
    cDiff = (ltzHour < 0) ? '+' : '-';

    // Constructs RFC 822 format: "ddd, dd mmm yyyy hh:mm:ss +/- hhmm\0"
    Assert(st.wMonth);
    wsprintf(pszDate, "%3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",
                      PszDayFromIndex(st.wDayOfWeek),          // "ddd"
                      st.wDay,                                 // "dd"
                      PszMonthFromIndex(st.wMonth),            // "mmm"
                      st.wYear,                                // "yyyy"
                      st.wHour,                                // "hh"
                      st.wMinute,                              // "mm"
                      st.wSecond,                              // "ss"
                      cDiff,                                   // "+" / "-"
                      abs (ltzHour),                           // "hh"
                      abs (ltzMinute));                        // "mm"

    // Done
    return S_OK;
}


#ifdef WININET_DATE
// ------------------------------------------------------------------------------------------
// MimeOleInetDateToFileTime
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleInetDateToFileTime(LPCSTR pszDate, LPFILETIME pft)
{
    // Locals
    SYSTEMTIME st;

    // Check Params
    if (NULL == pszDate || NULL == pft)
        return TrapError(E_INVALIDARG);

    // Use wininet to convert date...
    if (InternetTimeToSystemTime(pszDate, &st, 0) == 0)
        return TrapError(E_FAIL);

    // Convert to file time
    SystemTimeToFileTime(&st, pft);

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleFileTimeToInetDate
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFileTimeToInetDate(LPFILETIME pft, LPSTR pszDate, ULONG cchMax)
{
    // Locals
    SYSTEMTIME st;

    // Invalid Arg
    if (NULL == pszDate)
        return TrapError(E_INVALIDARG);
    if (cchMax < CCHMAX_INTERNET_TIME)
        return TrapError(MIME_E_BUFFER_TOO_SMALL);

    // Verify lpst is set
    if (pft == NULL || (pft->dwLowDateTime == 0 && pft->dwHighDateTime == 0))
        GetLocalTime(&st);
    else
        FileTimeToSystemTime(pft, &st);

    // Use wininet to convert date...
    if (InternetTimeFromSystemTime(&st, INTERNET_RFC1123_FORMAT, pszDate, cchMax) == 0)
        return TrapError(E_FAIL);

    // Done
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetprot.cpp ===
// --------------------------------------------------------------------------------
// Inetprot.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetprot.h"
#include "icdebug.h"

// --------------------------------------------------------------------------------
// HrPluggableProtocolRead
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolRead(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in,out */    LPVOID              pv,
            /* in */        ULONG               cb, 
            /* out */       ULONG              *pcbRead)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pv && cbRead > 0)
        return TrapError(E_INVALIDARG);

    // Init
    if (pcbRead)
        *pcbRead = 0;

    // No Stream Yet
    Assert(pSource);
    if (NULL == pSource->pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Read from the external offset
    CHECKHR(hr = pSource->pLockBytes->ReadAt(pSource->offExternal, pv, cb, &cbRead));

    // Tracking
#ifdef MAC
    DOUTL(APP_DOUTL, "HrPluggableProtocolRead - Offset = %d, cbWanted = %d, cbRead = %d, fDownloaded = %d", (DWORD)pSource->offExternal.LowPart, cb, cbRead, ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED));

    // Increment External Offset
    Assert(0 == pSource->offExternal.HighPart);
    Assert(INT_MAX - cbRead >= pSource->offExternal.LowPart);
    pSource->offExternal.LowPart += cbRead;
#else   // !MAC
    DOUTL(APP_DOUTL, "HrPluggableProtocolRead - Offset = %d, cbWanted = %d, cbRead = %d, fDownloaded = %d", (DWORD)pSource->offExternal.QuadPart, cb, cbRead, ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED));

    // Increment External Offset
    pSource->offExternal.QuadPart += cbRead;
#endif  // MAC

    // Return Read Count
    if (pcbRead)
        *pcbRead = cbRead;

    // No Data Read
    if (0 == cbRead)
    {
        // Finished
        if (ISFLAGSET(pSource->dwFlags, INETPROT_DOWNLOADED))
            hr = S_FALSE;

        // Not all data could be read
        else
            hr = E_PENDING;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrPluggableProtocolSeek
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolSeek(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in */        LARGE_INTEGER       dlibMove, 
            /* in */        DWORD               dwOrigin, 
            /* out */       ULARGE_INTEGER     *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliNew;

    // Invalid Arg
    Assert(pSource);

    // Tracking
    DOUTL(APP_DOUTL, "HrPluggableProtocolSeek");

    // No Stream Yet
    if (NULL == pSource->pLockBytes)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Seek pSource->offExternal
    switch (dwOrigin)
    {
   	case STREAM_SEEK_SET:
#ifdef MAC
        Assert(0 == dlibMove.HighPart);
        ULISet32(uliNew, dlibMove.LowPart);
#else   // !MAC
        uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
#endif  // MAC
        break;

    case STREAM_SEEK_CUR:
#ifdef MAC
        if (dlibMove.LowPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.LowPart) > pSource->offExternal.LowPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        Assert(0 == pSource->offExternal.HighPart);
        uliNew = pSource->offExternal;
        Assert(INT_MAX - uliNew.LowPart >= dlibMove.LowPart);
        uliNew.LowPart += dlibMove.LowPart;
#else   // !MAC
        if (dlibMove.QuadPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.QuadPart) > pSource->offExternal.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        uliNew.QuadPart = pSource->offExternal.QuadPart + dlibMove.QuadPart;
#endif  // MAC
        break;

    case STREAM_SEEK_END:
#ifdef MAC
        if (dlibMove.LowPart < 0 || dlibMove.LowPart > pSource->offInternal.LowPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        Assert(0 == pSource->cbSize.HighPart);
        uliNew = pSource->cbSize;
        Assert(INT_MAX - uliNew.LowPart >= dlibMove.LowPart);
        uliNew.LowPart -= dlibMove.LowPart;
#else   // !MAC
        if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > pSource->offInternal.QuadPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        uliNew.QuadPart = pSource->cbSize.QuadPart - dlibMove.QuadPart;
#endif  // MAC
        break;

    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // New offset greater than size...
#ifdef MAC
    Assert(0 == pSource->offInternal.HighPart);
    Assert(0 == uliNew.HighPart);
    ULISet32(pSource->offExternal, min(uliNew.LowPart, pSource->offInternal.LowPart));

    // Return Position
    if (plibNew)
    {
        Assert(0 == pSource->offExternal.HighPart);
        LISet32(*plibNew, pSource->offExternal.LowPart);
    }
#else   // !MAC
    pSource->offExternal.QuadPart = min(uliNew.QuadPart, pSource->offInternal.QuadPart);

    // Return Position
    if (plibNew)
        plibNew->QuadPart = (LONGLONG)pSource->offExternal.QuadPart;
#endif  // MAC

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetprot.h ===
// --------------------------------------------------------------------------------
// Inetprot.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETPROP_H
#define __INETPROP_H

// --------------------------------------------------------------------------------
// INETPROT
// --------------------------------------------------------------------------------
#define INETPROT_SIZEISKNOWN    FLAG01      // Total size of the protocol data is known
#define INETPROT_DOWNLOADED     FLAG02      // The data is all present in pLockBytes

// --------------------------------------------------------------------------------
// PROTOCOLSOURCE
// --------------------------------------------------------------------------------
typedef struct tagPROTOCOLSOURCE {
    DWORD               dwFlags;            // INETPROT_xxx Flags
    ILockBytes         *pLockBytes;         // Lock Bytes
    ULARGE_INTEGER      cbSize;             // Total sizeof pLockBytes if INETPROT_TOTALSIZE
    ULARGE_INTEGER      offExternal;        // External UrlMon Offset
    ULARGE_INTEGER      offInternal;        // Internal MsgMon Offset
} PROTOCOLSOURCE, *LPPROTOCOLSOURCE;

// --------------------------------------------------------------------------------
// HrPluggableProtocolRead
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolRead(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in,out */    LPVOID              pv,
            /* in */        ULONG               cb, 
            /* out */       ULONG              *pcbRead);

// --------------------------------------------------------------------------------
// HrPluggableProtocolSeek
// --------------------------------------------------------------------------------
HRESULT HrPluggableProtocolSeek(
            /* in,out */    LPPROTOCOLSOURCE    pSource,
            /* in */        LARGE_INTEGER       dlibMove, 
            /* in */        DWORD               dwOrigin, 
            /* out */       ULARGE_INTEGER     *plibNew);

#endif // __INETPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetconv.h ===
// --------------------------------------------------------------------------------
// Inetconv.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETCONV_H
#define __INETCONV_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "binhex.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
#ifdef MAC
typedef PMAC_LineBreakConsole   LPLINEBREAKER;
#else   // !MAC
interface IMLangLineBreakConsole;
typedef IMLangLineBreakConsole *LPLINEBREAKER;
#endif  // !MAC

// --------------------------------------------------------------------------------
// Rfc1522.cpp Uses This Table for Base64 Encoding
// --------------------------------------------------------------------------------
extern const CHAR g_rgchDecodeBase64[256];
extern const CHAR g_rgchEncodeBase64[];
extern const CHAR g_rgchHex[];

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define CCHMAX_ENCODEUU_IN      45 
#define CCHMAX_ENCODEUU_OUT     70 
#define CCHMAX_QPLINE           72
#define CCHMAX_ENCODE64_IN      57
#define CCHMAX_ENCODE64_OUT     80
#define CCHMAX_DECODE64_OUT     60

// --------------------------------------------------------------------------------
// UU decoder
// --------------------------------------------------------------------------------
#define UUDECODE(c) (((c) == '`') ? '\0' : ((c) - ' ') & 0x3F)
#define UUENCODE(c) ((c) ? ((c) & 0x3F ) + ' ' : '`')

// --------------------------------------------------------------------------------
// Macros shared with Rfc1522.cpp
// --------------------------------------------------------------------------------
#define DECODE64(_ch) (g_rgchDecodeBase64[(unsigned)_ch])

// --------------------------------------------------------------------------------
// BinHex decoder
// --------------------------------------------------------------------------------
#define DECODEBINHEX(_ch) (g_rgchDecodeBinHex[(unsigned)_ch])
#define FBINHEXRETURN(_ch) (((_ch) == '\t') || ((_ch) == chCR) || ((_ch) == chLF) || ((_ch) == ' '))

// --------------------------------------------------------------------------------
// CConvertBuffer
// --------------------------------------------------------------------------------
typedef struct tagCONVERTBUFFER {
    LPBYTE              pb;                 // Pointer to static buffer (or allocated buffer)
    ULONG               cbAlloc;            // Size of pb
    ULONG               cb;                 // End of data window 
    ULONG               i;                  // Read read/write position (offset from iStart)
} CONVERTBUFFER, *LPCONVERTBUFFER;

// --------------------------------------------------------------------------------
// Converter Flags
// --------------------------------------------------------------------------------
#define ICF_CODEPAGE    FLAG01              // Code Page Conversion
#define ICF_WRAPTEXT    FLAG02              // Wrapping Text
#define ICF_KILLNBSP    FLAG03              // Removed NBSPs from Uncicode Source

// --------------------------------------------------------------------------------
// CONVINITINFO
// --------------------------------------------------------------------------------
typedef struct tagCONVINITINFO {
    DWORD               dwFlags;            // ICF Flags    
    ENCODINGTYPE        ietEncoding;        // Encoding Type
    CODEPAGEID          cpiSource;          // Source Code Page
    CODEPAGEID          cpiDest;            // Destination Code Page
    LONG                cchMaxLine;         // Maxline length for wrapping
    BOOL                fEncoder;           // Is this an encoder or decoder...
    BOOL                fShowMacBinary;     // Show we give back the data fork only?
    MACBINARY           rMacBinary;         // Macbinary Header
} CONVINITINFO, *LPCONVINITINFO;

// --------------------------------------------------------------------------------
// INETCONVTYPE
// --------------------------------------------------------------------------------
typedef enum tagINETCONVTYPE {              // Append       Write
    ICT_UNKNOWN           = 0,              // --------------------
    ICT_WRAPTEXT_CODEPAGE = 1000,           // m_rIn    --> m_rCset
    ICT_WRAPTEXT          = 1001,           // m_rIn    --> m_rOut
    ICT_CODEPAGE_ENCODE   = 1002,           // m_rCset  --> m_rOut
    ICT_ENCODE            = 1003,           // m_rIn    --> m_rOut
    ICT_DECODE_CODEPAGE   = 1004,           // m_rIn    --> m_rCset
    ICT_DECODE            = 1005,           // m_rIn    --> m_rOut
} INETCONVTYPE;

// --------------------------------------------------------------------------------
// BINHEXSTATEDEC
// --------------------------------------------------------------------------------
typedef enum tagBINHEXSTATEDEC
{
    sSTARTING, sSTARTED, sHDRFILESIZE, sHEADER, sDATA, sDATACRC, sRESOURCE, sRESOURCECRC, sENDING, sENDED
} BINHEXSTATEDEC;

// --------------------------------------------------------------------------------
// Stores the character in _uch in pCon
// --------------------------------------------------------------------------------
#define FConvBuffCanRead(_rCon) \
    (_rCon.i < _rCon.cb)

// --------------------------------------------------------------------------------
// ConvBuffAppend
// --------------------------------------------------------------------------------
#define ConvBuffAppend(_uch) \
    m_rOut.pb[m_rOut.cb++] = _uch

// --------------------------------------------------------------------------------
// ConvBuffAppendW
// --------------------------------------------------------------------------------
#define ConvBuffAppendW(_wch) \
    { \
        *((WCHAR *)&m_rOut.pb[m_rOut.cb]) = _wch; \
        m_rOut.cb += 2; \
    }

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
class CInternetConverter : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // CInternetConverter
    // ----------------------------------------------------------------------------
    CInternetConverter(void);
    ~CInternetConverter(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CInternetConverter Methods
    // ----------------------------------------------------------------------------
    HRESULT HrInit(LPCONVINITINFO pInitInfo);
    HRESULT HrInternetEncode(BOOL fLastBuffer);
    HRESULT HrInternetDecode(BOOL fLastBuffer);

    // ----------------------------------------------------------------------------
    // Methods used to set the current conversion buffer
    // ----------------------------------------------------------------------------
    HRESULT HrFillAppend(LPBLOB pData);
    HRESULT HrWriteConverted(IStream *pStream);
    HRESULT HrWriteConverted(CInternetConverter *pConverter);

private:
    // ----------------------------------------------------------------------------
    // Encoders/Decoders
    // ----------------------------------------------------------------------------
    HRESULT HrEncode64(void);
    HRESULT HrDecode64(void);
    HRESULT HrEncodeUU(void);
    HRESULT HrDecodeUU(void);
    HRESULT HrEncodeQP(void);
    HRESULT HrDecodeQP(void);
    HRESULT HrEncodeBinhex(void);
    HRESULT HrDecodeBinHex(void);


    // ----------------------------------------------------------------------------
    // HrWrapInternetText
    // ----------------------------------------------------------------------------
    HRESULT HrWrapInternetTextA(void);
    HRESULT HrWrapInternetTextW(void);

    // ----------------------------------------------------------------------------
    // Character Set Encoders
    // ----------------------------------------------------------------------------
    HRESULT HrCodePageFromOutToCset(void); // Was HrDecodeCharset
    HRESULT HrCodePageFromCsetToIn(void);  // Was HrEncodeCharset

    // ----------------------------------------------------------------------------
    // Utilities
    // ----------------------------------------------------------------------------
    BOOL FUUEncodeThrowAway(LPSTR pszLine, ULONG cbLine, ULONG *pcbActual, ULONG *pcbLine);
    HRESULT HrBinhexThrowAway(LPSTR pszLine, ULONG cbLine);
    HRESULT HrAppendBuffer(LPCONVERTBUFFER pBuffer, LPBLOB pData, BOOL fKillNBSP);
    void CopyMemoryRemoveNBSP(LPBYTE pbDest, LPBYTE pbSource, ULONG cbSource);
    HRESULT HrInitConvertType(LPCONVINITINFO pInitInfo);
    HRESULT HrBinhexDecodeBuffAppend(UCHAR uchIn, ULONG cchIn, ULONG cchLeft, ULONG * cbProduced);

    // ----------------------------------------------------------------------------
    // Please Inline
    // ----------------------------------------------------------------------------
    inline HRESULT HrGrowBuffer(LPCONVERTBUFFER pBuffer, ULONG cbAppend);
    inline HRESULT HrConvBuffAppendBlock(LPBYTE pb, ULONG cb);
    inline LPSTR   PszConvBuffGetNextLine(ULONG *pcbLine, ULONG *pcbRead, BOOL *pfFound);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG               m_cRef;             // Reference Counting
    DWORD               m_dwFlags;          // ICF Flags
    ENCODINGTYPE        m_ietEncoding;      // Conversion Format
    CODEPAGEID          m_cpiSource;        // Source Code Page
    CODEPAGEID          m_cpiDest;          // Destination Code Page
    LONG                m_cchMaxLine;       // Maxline Length for wrapping
    BOOL                m_fEncoder;         // Encoder ?
    BOOL                m_fLastBuffer;      // There is no more data
    UCHAR               m_uchPrev;          // Used in qp 
    CONVERTBUFFER       m_rIn;              // Used for reading
    CONVERTBUFFER       m_rOut;             // Used for writing
    CONVERTBUFFER       m_rCset;            // Used for writing
    LPCONVERTBUFFER     m_pAppend;          // Buffer appended to in public HrFillAppend
    LPCONVERTBUFFER     m_pWrite;           // Buffer dumped when HrWriteConverted is called
    INETCONVTYPE        m_convtype;         // Conversion type
    LPLINEBREAKER       m_pLineBreak;       // Line Breaker Object
    LCID                m_lcid;             // Locale id used only for line wrapping
    ULONG               m_cbConvert;        // Base64 Convert Buffer Count
    UCHAR               m_uchConvert[4];    // Base64 Convert Buffer
    CBinhexEncoder     *m_pBinhexEncode;    // Binhex Encoder
    BINHEXSTATEDEC      m_eBinHexStateDec;  // Binhex Decoder state
    BOOL                m_fRepeating;       // Binhex repeating flag
    ULONG               m_ulAccum;          // Binhex accumulator
    ULONG               m_cAccum;           // BinHex accumulator count
    CONVERTBUFFER       m_rBinhexHeader;    // BinHex header buffer
    LPCONVERTBUFFER     m_prBinhexOutput;   // BinHex output buffer
    LONG                m_cbToProcess;      // BinHex section count
    ULONG               m_cbDataFork;       // BinHex data fork size
    ULONG               m_cbResourceFork;   // BinHex resource fork size
    WORD                m_wCRC;             // BinHex working CRC holder
    WORD                m_wCRCForFork;      // BinHex the CRC for the current fork
    BOOL                m_fDataForkOnly;    // BinHex give back only the data fork
};

// --------------------------------------------------------------------------------
// CInternetConverter
// --------------------------------------------------------------------------------
HRESULT HrCreateInternetConverter(LPCONVINITINFO pInitInfo, CInternetConverter **ppConverter);

#endif __INETCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetstm.cpp ===
// --------------------------------------------------------------------------------
// InetStm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetstm.h"
#include "stmlock.h"
#include "shlwapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// INETSTMTRACING
// --------------------------------------------------------------------------------
//#define INETSTMTRACING 1
#ifdef INETSTMTRACING
#define INETSTMTRACE DebugTrace
#else
#define INETSTMTRACE
#endif

// --------------------------------------------------------------------------------
// CInternetStream::CInternetStream
// --------------------------------------------------------------------------------
CInternetStream::CInternetStream(void)
{
    m_cRef = 1;
    m_pStmLock = NULL;
    m_fFullyAvailable = TRUE;
    ULISet32(m_uliOffset, 0);
    ZeroMemory(&m_rLine, sizeof(INETSTREAMLINE));
    m_rLine.pb = m_rLine.rgbScratch;
    m_rLine.cbAlloc = sizeof(m_rLine.rgbScratch);
}

// --------------------------------------------------------------------------------
// CInternetStream::~CInternetStream
// --------------------------------------------------------------------------------
CInternetStream::~CInternetStream(void)
{
    // Do i need to free the line
    if (m_rLine.pb && m_rLine.pb != m_rLine.rgbScratch)
        g_pMalloc->Free(m_rLine.pb);

    // Reset the position of the stream to the real current offset
    if (m_pStmLock)
    {
        // Preserve the position of the stream
        SideAssert(SUCCEEDED(m_pStmLock->HrSetPosition(m_uliOffset)));

        // Release the LockBytes
        m_pStmLock->Release();
    }
}

// --------------------------------------------------------------------------------
// CInternetStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetStream::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CInternetStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInternetStream::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrInitNew
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrInitNew(IStream *pStream)
{
    // Locals
    HRESULT             hr=S_OK;
    CStreamLockBytes   *pStmLock=NULL;
    DWORD               cbOffset;

    // Invalid Arg
    Assert(pStream);

    // Wrap pStream in a pStmLock
    CHECKALLOC(pStmLock = new CStreamLockBytes(pStream));

    // Get Current Stream Position
    CHECKHR(hr = HrGetStreamPos(pStream, &cbOffset));

    // Create text stream object
    InitNew(cbOffset, pStmLock);

exit:
    // Cleanup
    SafeRelease(pStmLock);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::InitNew
// --------------------------------------------------------------------------------
void CInternetStream::InitNew(DWORD dwOffset, CStreamLockBytes *pStmLock)
{
    // Invalid Arg
    Assert(pStmLock);

    // Release Current
    SafeRelease(m_pStmLock);

    // Zero Current Buffer
    ZeroMemory(&m_rBuffer, sizeof(INETSTREAMBUFFER));

    // Reset m_rLine
    m_rLine.cb = 0;

    // Assume new StreamLockBytes
    m_pStmLock = pStmLock;
    m_pStmLock->AddRef();

    // Safe the Offset
    m_uliOffset.QuadPart = dwOffset;
}

// --------------------------------------------------------------------------------
// CInternetStream::GetLockBytes
// --------------------------------------------------------------------------------
void CInternetStream::GetLockBytes(CStreamLockBytes **ppStmLock)
{
    // Invalid Arg
    Assert(ppStmLock && m_pStmLock);

    // Return It
    (*ppStmLock) = m_pStmLock;
    (*ppStmLock)->AddRef();
}

// --------------------------------------------------------------------------------
// CInternetStream::HrGetSize
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrGetSize(DWORD *pcbSize)
{
    // Locals
    HRESULT     hr=S_OK;
    STATSTG     rStat;

    // Invalid Arg
    Assert(pcbSize && m_pStmLock);

    // Get the Stat
    CHECKHR(hr = m_pStmLock->Stat(&rStat, STATFLAG_NONAME));

    // Return Size
    *pcbSize = (DWORD)rStat.cbSize.QuadPart;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::Seek
// --------------------------------------------------------------------------------
void CInternetStream::Seek(DWORD dwOffset)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fResetCache=FALSE;
    DWORD       dw;

    // State Check
    Assert((m_rBuffer.cb == 0) || (m_uliOffset.QuadPart == m_rBuffer.uliOffset.QuadPart + m_rBuffer.i));

    // Already at the requested position
    if (dwOffset == m_uliOffset.QuadPart)
        goto exit;

    // Less than current position
    if (dwOffset < m_uliOffset.QuadPart)
    {
        // Compute Offset from current location
        dw = (DWORD)m_uliOffset.QuadPart - dwOffset;

        // Less than beginning
        if (dw > m_rBuffer.i)
            fResetCache = TRUE;
        else
        {
            Assert(dw <= m_rBuffer.i);
            m_rBuffer.i -= dw;
        }
    }

    // Else dwOffset > m_uliOffset.QuadPart
    else
    {
        // Compute Offset from current location
        dw = dwOffset - (DWORD)m_uliOffset.QuadPart;

        // Less than beginning
        if (m_rBuffer.i + dw > m_rBuffer.cb)
            fResetCache = TRUE;
        else
        {
            m_rBuffer.i += dw;
            Assert(m_rBuffer.i <= m_rBuffer.cb);
        }
    }

    // Reset the cache
    if (fResetCache)
    {
        // Empty current line and buffer
        *m_rLine.pb = *m_rBuffer.rgb = '\0';

        // No buffer
        m_rBuffer.uliOffset.QuadPart = m_rLine.cb = m_rBuffer.i = m_rBuffer.cb = 0;
    }

    // Save this position
    m_uliOffset.QuadPart = dwOffset;

exit:
    // Done
    return;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadToEnd
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadToEnd(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // While
    while(1)
    {
        // Validate
        Assert(m_rBuffer.i <= m_rBuffer.cb);

        // Increment Offset to end of current buffer
        m_uliOffset.QuadPart += (m_rBuffer.cb - m_rBuffer.i);

        // Set m_rBuffer.i to end of current buffer
        m_rBuffer.i = m_rBuffer.cb;
        
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // No more data
        if (0 == m_rBuffer.cb)
            break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::_HrGetNextBuffer
// --------------------------------------------------------------------------------
HRESULT CInternetStream::_HrGetNextBuffer(void)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Validate
    Assert(m_rBuffer.i <= m_rBuffer.cb);

    // Do we need to read a new buffer
    if (m_rBuffer.i == m_rBuffer.cb)
    {
        // Read a block from the stream, this could return E_PENDING
        CHECKHR(hr = m_pStmLock->ReadAt(m_uliOffset, m_rBuffer.rgb, sizeof(m_rBuffer.rgb), &cbRead));

        // Raid 43408: Work around Urlmon IStream::Read returning S_FALSE when it should return E_PENDING
#ifdef DEBUG
        if (FALSE == m_fFullyAvailable && 0 == cbRead && S_FALSE == hr)
        {
            //AssertSz(FALSE, "Raid-43408 - Danpo Zhang is working on this bug, I hope.");
            //hr = E_PENDING;
            //goto exit;
        }
#endif

        // Save cbRead
        m_rBuffer.cb = cbRead;

        // Save the offset of the start of this buffer
        m_rBuffer.uliOffset.QuadPart = m_uliOffset.QuadPart;

        // Reset buffer index
        m_rBuffer.i = 0;
    }
    else
        Assert(m_uliOffset.QuadPart == m_rBuffer.uliOffset.QuadPart + m_rBuffer.i);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadLine
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadLine(LPPROPSTRINGA pLine)
{
    // Locals
    HRESULT  hr=S_OK;
    UCHAR    ch, 
             chEndOfLine;
    ULONG    cbRead, 
             iStart;
    BOOL     fEndOfLine=FALSE;

    // Init
    pLine->pszVal = NULL;
    pLine->cchVal = 0;

    // Reset the line
    if (m_rLine.fReset)
    {
        m_rLine.cb = 0;
        m_rLine.fReset = 0;
    }

    // Do the loop
    while(1)
    {
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // Nothing Read ?
        if (m_rBuffer.cb == 0)
            break;

        // Seek to first '\n'
        iStart = m_rBuffer.i;

        Assert(chLF<32);
        Assert(chCR<32);
        Assert(0<32);

        // For large messages, the while-loop below ends up being a big
        // percentage of the execution time for IMimeMessage::Load.  So,
        // we have carefully crafted our C++ code so that we get the
        // optimum code generation for this loop (at least, on Intel, with
        // VC 11.00.7071...)
        {
            register UCHAR *pCurr = m_rBuffer.rgb + m_rBuffer.i;
            register UCHAR *pEnd = m_rBuffer.rgb + m_rBuffer.cb;

            // We need to initialize this variable for two reasons:  First,
            // if we don't initialize it, then for some reason VC decides that
            // it doesn't want to enregister it.  And more importantly, if
            // we don't enter the while-loop at all, we need this variable
            // to be set this way...
            register UCHAR chPrev = m_rBuffer.chPrev;

            ch = m_rBuffer.chPrev;

            // While we have data
            while (pCurr < pEnd)
            {

                // Remember the previous character.
                chPrev = ch;

                // Get Character, and Increment
                ch = *pCurr;
                pCurr++;

                // The most common case - it's just a regular
                // character, and we haven't seen a carriage-return.
                // So jump back to the top of the loop and keep lookin'...
                if ((chCR != chPrev) && (ch >= 32))
                {
                    continue;
                }

                // The next most common case - we are at end-of-line because
                // of a line-feed.
                if (chLF == ch)
                {
                    chPrev = ch;
                    chEndOfLine = ch;
                    fEndOfLine = TRUE;
                    break;
                }

                // This case really only happens when we are getting malformed
                // e-mail - there are embedded carriage-returns, which are *not*
                // followed by line-feeds.  When we see those lonely CR's,
                // we make it look like we got a normal CR LF sequence.
                if (chCR == chPrev)
                {
                    chPrev = chLF;
                    pCurr--;
                    chEndOfLine = chCR;
                    fEndOfLine = TRUE;
                    break;
                }

                // Fairly rare case - these are malformed messages because they
                // have NULL's embedded in them.  We silently convert the
                // NULL's to dots.
                if ('\0' == ch)
                {
                    ch = '.';
                    *(pCurr-1) = ch;
                }
            }

            m_rBuffer.i = (ULONG) (pCurr - m_rBuffer.rgb);
            m_rBuffer.chPrev = chPrev;
        }

        // Number of bytes Read
        cbRead = (m_rBuffer.i - iStart);

        // Increment Position
        m_uliOffset.QuadPart += cbRead;

        // Do we need to realloc the line buffer ?
        if (m_rLine.cb + cbRead + 2 > m_rLine.cbAlloc)
        {
            // Fixup pszLine
            if (m_rLine.pb == m_rLine.rgbScratch)
            {
                // Null It
                m_rLine.pb = NULL;

                // Allocate it to m_rLine.cb
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rLine.pb, m_rLine.cb + 1));

                // Copy static buffer
                CopyMemory(m_rLine.pb, m_rLine.rgbScratch, m_rLine.cb);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rLine.cbAlloc = m_rLine.cb + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rLine.pb, m_rLine.cbAlloc));
        }

        // Copy the data
        CopyMemory(m_rLine.pb + m_rLine.cb, m_rBuffer.rgb + iStart, cbRead);

        // Update Counters and indexes
        m_rLine.cb += cbRead;

        // If End of line and last character was a '\r', append a '\n'
        if (TRUE == fEndOfLine)
        {
            // Better have something in the line
            Assert(m_rLine.cb);

            // If line ended with a '\r'
            if (chCR == chEndOfLine)
            {
                // Better have room for one more char
                Assert(m_rLine.cb + 1 < m_rLine.cbAlloc);

                // Append a '\n'
                m_rLine.pb[m_rLine.cb] = chLF;

                // Increment Length
                m_rLine.cb++;
            }

            // Otherwise...
            else
            {
                // Line better have ended with a \n
                Assert(chLF == chEndOfLine && chLF == m_rLine.pb[m_rLine.cb - 1]);

                // If Previous Character was not a \r 
                if (m_rLine.cb < 2 || chCR != m_rLine.pb[m_rLine.cb - 2])
                {
                    // Convert last char from \n to a \r
                    m_rLine.pb[m_rLine.cb - 1] = chCR;

                    // Better have room for one more char
                    Assert(m_rLine.cb + 1 < m_rLine.cbAlloc);

                    // Append a '\n'
                    m_rLine.pb[m_rLine.cb] = chLF;

                    // Increment Length
                    m_rLine.cb++;
                }
            }

            // Done
            break;
        }
    }

    // A little check
    Assert(fEndOfLine ? m_rLine.cb >= 2 && chLF == m_rLine.pb[m_rLine.cb-1] && chCR == m_rLine.pb[m_rLine.cb-2] : TRUE);

    // Null terminator
    m_rLine.pb[m_rLine.cb] = '\0';

    // Set return values
    pLine->pszVal = (LPSTR)m_rLine.pb;
    pLine->cchVal = m_rLine.cb;

    // Tracking
    INETSTMTRACE("CInternetStream: %s", (LPSTR)m_rLine.pb);

    // No Line
    m_rLine.fReset = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetStream::HrReadHeaderLine
// --------------------------------------------------------------------------------
HRESULT CInternetStream::HrReadHeaderLine(LPPROPSTRINGA pLine, LONG *piColonPos)
{
    // Locals
    HRESULT   hr=S_OK;
    CHAR      ch;
    ULONG     cbRead=0, 
              iStart, 
              i;
    BOOL      fEndOfLine=FALSE;
    DWORD     cTrailingSpace=0;

    // Init
    *piColonPos = -1;
    pLine->pszVal = NULL;
    pLine->cchVal = 0;

    // Reset the line
    if (m_rLine.fReset)
    {
        m_rLine.cb = 0;
        m_rLine.fReset = 0;
    }

    // Do the loop
    while(1)
    {
        // Get next buffer
        CHECKHR(hr = _HrGetNextBuffer());

        // Nothing Read ?
        if (m_rBuffer.cb == 0)
            break;

        // Reset fSeenN
        fEndOfLine = FALSE;

        // Initialize
        iStart = m_rBuffer.i;

        // Seek to first '\n'
        while (m_rBuffer.i < m_rBuffer.cb)
        {
            // Get Character
            ch = *(m_rBuffer.rgb + m_rBuffer.i);

            // Convert Nulls to '.'
            if ('\0' == ch)
            {
                ch = '.';
                *(m_rBuffer.rgb + m_rBuffer.i) = ch;
            }

            // Goto next character
            m_rBuffer.i++;

            // New Line
            if (chLF == ch)
            {
                m_rBuffer.chPrev = ch;
                fEndOfLine = TRUE;
                break;
            }

            // Otherwise, if previous character was a '\r', then end of line
            else if (chCR == m_rBuffer.chPrev)
            {
                AssertSz(m_rBuffer.i > 0, "This is an un-handled boundary condition");
                if (m_rBuffer.i > 0)
                    m_rBuffer.i--;
                m_rBuffer.chPrev = '\0';
                fEndOfLine = TRUE;
                break;
            }

            // Is Space
            if (' ' == ch || '\t' == ch)
                cTrailingSpace++;
            else
                cTrailingSpace = 0;

            // Save Previous Character
            m_rBuffer.chPrev = ch;
        }

        // Number of bytes Read
        cbRead = (m_rBuffer.i - iStart);

        // Increment Position
        m_uliOffset.QuadPart += cbRead;

        // Adjust cbRead to remove CRLF
        if (cbRead && chLF == m_rBuffer.rgb[iStart + cbRead - 1])
            cbRead--;
        if (cbRead && chCR == m_rBuffer.rgb[iStart + cbRead - 1])
            cbRead--;

        // Do we need to realloc the line buffer ?
        if (m_rLine.cb + cbRead + 3 > m_rLine.cbAlloc)
        {
            // Fixup pszLine
            if (m_rLine.pb == m_rLine.rgbScratch)
            {
                // Null It
                m_rLine.pb = NULL;

                // Allocate it to m_rLine.cb
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rLine.pb, m_rLine.cb + 3));

                // Copy static buffer
                CopyMemory(m_rLine.pb, m_rLine.rgbScratch, m_rLine.cb);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rLine.cbAlloc = m_rLine.cb + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rLine.pb, m_rLine.cbAlloc));
        }

        // Copy the data
        CopyMemory(m_rLine.pb + m_rLine.cb, m_rBuffer.rgb + iStart, cbRead);

        // Increment line byte count
        m_rLine.cb += cbRead;

        // If fSeenN, then check for continuation line (i.e. next character is ' ' or '\t'
        if (fEndOfLine)
        {
            // Get next buffer
            CHECKHR(hr = _HrGetNextBuffer());

            // Compare for continuation
            ch = m_rBuffer.rgb[m_rBuffer.i];

            // If line starts with a TAB or a space, this is a continuation line, keep reading
            if ((ch != ' ' && ch != '\t') || (0 == cbRead && 0 == m_rLine.cb))
            {
                // Done
                break;
            }

            // Otherwise, strip continuation...
            else
            {
                // Per RFC822, we should not step over a space
                if (ch == '\t')
                {
                    m_rBuffer.i++;
                    m_uliOffset.QuadPart++;
                }

                // No characters since last whitespace
                if (0 == cTrailingSpace)
                {
                    // Locals
                    DWORD cFrontSpace=0;

                    // Look ahead in the buffer a little
                    for (DWORD iLookAhead = m_rBuffer.i; iLookAhead < m_rBuffer.cb; iLookAhead++)
                    {
                        // Get Char
                        ch = m_rBuffer.rgb[iLookAhead];

                        // Break on non space
                        if (' ' != ch && '\t' != ch)
                            break;

                        // Count Front Space
                        cFrontSpace++;
                    }

                    // No Front Space ?
                    if (0 == cFrontSpace)
                    {
                        // Lets do this only fro Received: and for Date: since dates that get split don't get parsed correctly?
                        if ((m_rLine.cb >= 4 && 0 == StrCmpNI("Date", (LPCSTR)m_rLine.pb, 4)) || (m_rLine.cb >= 8 && 0 == StrCmpNI("Received", (LPCSTR)m_rLine.pb, 8)))
                        {
                            // Put a space in
                            *(m_rLine.pb + m_rLine.cb) = ' ';

                            // Increment line byte count
                            m_rLine.cb += 1;
                        }
                    }
                }

                // Get next buffer
                CHECKHR(hr = _HrGetNextBuffer());

                // If Next character is a \r or \n, then stop, NETSCAPE bug
                ch = m_rBuffer.rgb[m_rBuffer.i];
                if (chCR == ch || chLF == ch)
                    break;
            }

            // Reset
            cTrailingSpace = 0;
        }
    }

    // A little check
#ifndef _WIN64
    Assert(chLF != m_rLine.pb[m_rLine.cb-1] && chCR != m_rLine.pb[m_rLine.cb-1]);
#endif 

    // Null terminator
    *(m_rLine.pb + m_rLine.cb) = '\0';

    // Lets locate the colon
    for (i=0; i<m_rLine.cb; i++)
    {
        // Colon ?
        if (':' == m_rLine.pb[i])
        {
            *piColonPos = i;
            break;
        }
    }

    // Set return values
    pLine->pszVal = (LPSTR)m_rLine.pb;
    pLine->cchVal = m_rLine.cb;

    // Tracking
    INETSTMTRACE("CInternetStream: %s\n", (LPSTR)m_rLine.pb);

    // Reset the Line
    m_rLine.fReset = TRUE;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\internat.h ===
// --------------------------------------------------------------------------------
// Internat.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INTERNAT_H
#define __INTERNAT_H
#include  "exrwlck.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERT *LPVARIANTCONVERT;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef struct tagPROPSTRINGA *LPPROPSTRINGA;
typedef struct tagPROPSTRINGW *LPPROPSTRINGW;
typedef const struct tagPROPSTRINGA *LPCPROPSTRINGA;
typedef const struct tagPROPSTRINGW *LPCPROPSTRINGW;
typedef struct tagMIMEVARIANT *LPMIMEVARIANT;

// --------------------------------------------------------------------------------
// Extern Global
// --------------------------------------------------------------------------------
class CIntlGlobals {
    public:
        static void Init();
        static void Term();
        static LPINETCSETINFO GetDefBodyCset();
        static LPINETCSETINFO GetDefHeadCset();
        static LPINETCSETINFO GetDefaultCharset();
        static void SetDefBodyCset(LPINETCSETINFO pCharset);
        static void SetDefHeadCset(LPINETCSETINFO pCharset);
    private:
        static void DoInit();
        static BOOL mg_bInit;
        static CRITICAL_SECTION mg_cs;
        static LPINETCSETINFO mg_pDefBodyCset;
        static LPINETCSETINFO mg_pDefHeadCset;
        static INETCSETINFO mg_rDefaultCharset;
};

// --------------------------------------------------------------------------------
// IsDBCSCodePage
// --------------------------------------------------------------------------------
#define IsDBCSCodePage(_cpi) \
    (932 == _cpi || 936 == _cpi || 950 == _cpi || 949 == _cpi || 874 == _cpi || 10001 == _cpi)

// --------------------------------------------------------------------------------
// HCSET Handle Macros
// --------------------------------------------------------------------------------
#define HCSET_SIGN                 (WORD)40
#define HCSETMAKE(_index)          (HCHARSET)MAKELPARAM(m_wTag + HCSET_SIGN, _index)
#define HCSETINDEX(_hcset)         (ULONG)HIWORD(_hcset)
#define HCSETTICK(_hcset)          (WORD)LOWORD(_hcset)
#define HCSETVALID(_hcset)         ((WORD)(HCSETTICK(_hcset) - HCSET_SIGN) == m_wTag && HCSETINDEX(_hcset) < m_cst.cCharsets)
#define PCsetFromHCset(_hcset)     m_cst.prgpCharset[HCSETINDEX(_hcset)]

// --------------------------------------------------------------------------------
// CSTABLE - Character Set Table
// --------------------------------------------------------------------------------
typedef struct tagCSTABLE {
    ULONG               cCharsets;          // Number of items in prgpCset
    ULONG               cAlloc;             // Number of items allocated in prgCset    
    LPINETCSETINFO     *prgpCharset;        // Array of INETCSETINFO structs
} CSTABLE, *LPCSTABLE;

// --------------------------------------------------------------------------------
// CPTABLE - Code Page Table
// --------------------------------------------------------------------------------
typedef struct tagCPTABLE {
    ULONG               cPages;             // Number of items in prgpCset
    ULONG               cAlloc;             // Number of items allocated in prgCset    
    LPCODEPAGEINFO     *prgpPage;           // Array of INETCSETINFO structs
} CPTABLE, *LPCPTABLE;

// --------------------------------------------------------------------------------
// CMimeInternational
// --------------------------------------------------------------------------------
class CMimeInternational : public IMimeInternational
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeInternational(void);
    ~CMimeInternational(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IMimeInternational Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP GetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset);
    STDMETHODIMP SetDefaultCharset(HCHARSET hCharset);
    STDMETHODIMP GetDefaultCharset(LPHCHARSET phCharset);
    STDMETHODIMP FindCharset(LPCSTR pszCharset, LPHCHARSET phCharset);
    STDMETHODIMP GetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo);
    STDMETHODIMP GetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePageInfo);
    STDMETHODIMP ConvertBuffer(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPBLOB pIn, LPBLOB pOut, ULONG *pcbRead);
    STDMETHODIMP ConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPPROPVARIANT pIn, LPPROPVARIANT pOut);
    STDMETHODIMP MLANG_ConvertInetReset(void);
    STDMETHODIMP MLANG_ConvertInetString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPCSTR pSourceStr,
        LPINT pnSizeOfSourceStr, LPSTR pDestinationStr, LPINT pnSizeOfDestBuffer);

    STDMETHODIMP DecodeHeader(HCHARSET hCharset, LPCSTR pszData, LPPROPVARIANT pDecoded, LPRFC1522INFO pRfc1522Info);
    STDMETHODIMP EncodeHeader(HCHARSET hCharset, LPPROPVARIANT pData, LPSTR *ppszEncoded, LPRFC1522INFO pRfc1522Info);
    STDMETHODIMP Rfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded);
    STDMETHODIMP Rfc1522Encode(LPCSTR pszValue, HCHARSET hCharset, LPSTR *ppszEncoded);
    STDMETHODIMP CanConvertCodePages(CODEPAGEID cpiSource, CODEPAGEID cpiDest);

    // -------------------------------------------------------------------------
    // LPINETCSETINFO Based Methods
    // -------------------------------------------------------------------------
    HRESULT HrOpenCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPINETCSETINFO *ppCharset);
    HRESULT HrOpenCharset(LPCSTR pszCharset, LPINETCSETINFO *ppCharset);
    HRESULT HrOpenCharset(HCHARSET hCharset, LPINETCSETINFO *ppCharset);
    HRESULT HrFindCodePage(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage);
    HRESULT HrConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrDecodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrEncodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);

    // -------------------------------------------------------------------------
    // Helpers to do Header Properties
    // -------------------------------------------------------------------------
    HRESULT HrEncodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrDecodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest);
    HRESULT HrWideCharToMultiByte(CODEPAGEID cpiCodePage, LPCPROPSTRINGW pStringW, LPPROPSTRINGA pStringA);
    HRESULT HrMultiByteToWideChar(CODEPAGEID cpiCodePage, LPCPROPSTRINGA pStringA, LPPROPSTRINGW pStringW);
    HRESULT HrValidateCodepages(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, LPBYTE *ppbSource, ULONG *pcbSource, CODEPAGEID *pcpiSource, CODEPAGEID *pcpiDest);

    // -------------------------------------------------------------------------
    // CMimeInternational Methods
    // -------------------------------------------------------------------------
    BOOL    FIsValidHandle(HCHARSET hCharset);
    HRESULT IsDBCSCharset(HCHARSET hCharset);

private:
    // ----------------------------------------------------------------------------
    // Private Utils
    // ----------------------------------------------------------------------------
    void    _FreeInetCsetTable(void);
    void    _FreeCodePageTable(void);
    void    _QuickSortPageInfo(long left, long right);
    void    _QuickSortCsetInfo(long left, long right);
    HRESULT _HrReadPageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppLangInfo);
    HRESULT _HrReadCsetInfo(LPCSTR pszCharset, LPINETCSETINFO *ppCsetInfo);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                           m_cRef;             // Reference Counting
    WORD                           m_wTag;             // Used to create and verify hCharsets
    CSTABLE                        m_cst;              // Character Sets
    CPTABLE                        m_cpt;              // CodePages
    CExShareLockWithNestAllowed    m_lock;             // Thread Safety
    DWORD                          m_dwConvState;      // Used to save convert state from MLANG
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void InitInternational(void);
HRESULT HrRegisterMlangDll(void);

#endif // __INTERNAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\inetstm.h ===
// --------------------------------------------------------------------------------
// InetStm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __INETTEXT_H
#define __INETTEXT_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "variantx.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CStreamLockBytes;

// --------------------------------------------------------------------------------
// INETSTREAMBUFFER
// --------------------------------------------------------------------------------
typedef struct tagINETSTREAMBUFFER {
    ULARGE_INTEGER      uliOffset;              // Global offset of the start of this cache
    BYTE                rgb[4096];              // Cached portion of m_pStmLock
    ULONG               cb;                     // How many valid bytes in rgbCache
    ULONG               i;                      // Current Read Offset into rgb
    CHAR                chPrev;                 // Previous character, could be in previous buffer
} INETSTREAMBUFFER, *LPINETSTREAMBUFFER;

// --------------------------------------------------------------------------------
// INETSTREAMLINE
// --------------------------------------------------------------------------------
typedef struct tagINETSTREAMLINE {
    BOOL                fReset;                 // Reset to 0 on next call to ReadLine
    BYTE                rgbScratch[1024];       // Cached portion of m_pStmLock
    LPBYTE              pb;                     // Actual line (could be allocated != rgb)
    ULONG               cb;                     // How many valid bytes in rgbCache
    ULONG               cbAlloc;                // Size of buffer pointed to by pb
} INETSTREAMLINE, *LPINETSTREAMLINE;

// --------------------------------------------------------------------------------
// CInternetStream
// --------------------------------------------------------------------------------
class CInternetStream : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CInternetStream(void);
    ~CInternetStream(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) {
        return TrapError(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IInternetStream Members
    // ----------------------------------------------------------------------------
    HRESULT HrInitNew(IStream *pStream);
    HRESULT HrReadToEnd(void);
    HRESULT HrReadLine(LPPROPSTRINGA pLine);
    HRESULT HrReadHeaderLine(LPPROPSTRINGA pHeader, LONG *piColonPos);
    HRESULT HrGetSize(DWORD *pcbSize);
#ifdef MAC
    DWORD   DwGetOffset(void) { return m_uliOffset.LowPart; }
#else   // !MAC
    DWORD   DwGetOffset(void) { return (DWORD)m_uliOffset.QuadPart; }
#endif  // MAC
    void    InitNew(DWORD dwOffset, CStreamLockBytes *pStmLock);
    void    GetLockBytes(CStreamLockBytes **ppStmLock);
    void    Seek(DWORD dwOffset);
    void    SetFullyAvailable(BYTE fFullyAvailable) { m_fFullyAvailable = fFullyAvailable; }

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGetNextBuffer(void);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG               m_cRef;         // Reference Count
    BYTE                m_fFullyAvailable; // Is all the data available
    CStreamLockBytes   *m_pStmLock;     // Thread Safe Data Source
    ULARGE_INTEGER      m_uliOffset;    // Last Read Postion of m_pStmLock
    INETSTREAMBUFFER    m_rBuffer;      // Current Buffer
    INETSTREAMLINE      m_rLine;        // Current Line
};

#endif // __INETTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\macapi.cpp ===
// Copyright (c)1993-1997 Microsoft Corporation, All Rights Reserved
// Brian A. Moore
//
// This file is used for Mac only functions to assist in the Mac port of
// inetcomm.
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifdef MAC
#include "dllmain.h"
#include <stdio.h>
#include "resource.h"

#ifdef DEBUG
#define PRIVATE 
#else   // !DEBUG
#define PRIVATE static
#endif  // DEBUG

#define HEX_ESCAPE L'%'
#define URL_ESCAPE_PERCENT  0x00001000
#define POUND       L'#'
#define QUERY       L'?'

#define TERMSTR(pch)      *(pch) = L'\0'

PRIVATE CONST WORD isSafe[96] =

/*   Bit 0       alphadigit     -- 'a' to 'z', '0' to '9', 'A' to 'Z'
**   Bit 1       Hex            -- '0' to '9', 'a' to 'f', 'A' to 'F'
**   Bit 2       valid scheme   -- alphadigit | "-" | "." | "+"
**   Bit 3       mark           -- "%" | "$"| "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")" | ","
*/
/*   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
//    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 4, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
// IE4 BETA1: allow + through unmolested.  Should consider other options
// post beta1.  12feb97 tonyci
    {0, 8, 0, 0, 8, 8, 0, 8, 8, 8, 8, 12, 8,12,12, 0,    /* 2x   !"#$%&'()*+,-./  */
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 0, 8, 0, 0,    /* 3x  0123456789:;<=>?  */
     8, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 4x  @ABCDEFGHIJKLMNO  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 8,    /* 5X  PQRSTUVWXYZ[\]^_  */
     0, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1,    /* 6x  `abcdefghijklmno  */
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 8, 0};   /* 7X  pqrstuvwxyz{|}~  DEL */

PRIVATE const WCHAR hex[] = {L"0123456789ABCDEF"};

PRIVATE inline BOOL IsSafe(WCHAR ch, WORD mask)
{
    if(ch > 31 && ch < 128 && (isSafe[ch - 32] & mask))
        return TRUE;

    return FALSE;
}

#define IsAlphaDigit(c)         IsSafe(c, 1)
#define IsHex(c)                IsSafe(c, 2)
#define IsValidSchemeCharA(c)    IsSafe(c, 5)
#define IsSafePathChar(c)       IsSafe(c, 9)

/////////////////////////////////////////////////////////////////////////////
// Line Break Character Table

const WCHAR MAC_awchNonBreakingAtLineEnd[] = {
    0x0028, // LEFT PARENTHESIS
    0x005B, // LEFT SQUARE BRACKET
    0x007B, // LEFT CURLY BRACKET
    0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x2018, // LEFT SINGLE QUOTATION MARK
    0x201C, // LEFT DOUBLE QUOTATION MARK
    0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x2045, // LEFT SQUARE BRACKET WITH QUILL
    0x207D, // SUPERSCRIPT LEFT PARENTHESIS
    0x208D, // SUBSCRIPT LEFT PARENTHESIS
    0x226A, // MUCH LESS THAN
    0x3008, // LEFT ANGLE BRACKET
    0x300A, // LEFT DOUBLE ANGLE BRACKET
    0x300C, // LEFT CORNER BRACKET
    0x300E, // LEFT WHITE CORNER BRACKET
    0x3010, // LEFT BLACK LENTICULAR BRACKET
    0x3014, // LEFT TORTOISE SHELL BRACKET
    0x3016, // LEFT WHITE LENTICULAR BRACKET
    0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
    0x301A, // LEFT WHITE SQUARE BRACKET
    0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
    0xFD3E, // ORNATE LEFT PARENTHESIS
    0xFE35, // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    0xFE37, // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    0xFE39, // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
    0xFE3B, // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
    0xFE3D, // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
    0xFE3F, // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
    0xFE41, // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    0xFE43, // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
    0xFE59, // SMALL LEFT PARENTHESIS
    0xFE5B, // SMALL LEFT CURLY BRACKET
    0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
    0xFF08, // FULLWIDTH LEFT PARENTHESIS
    0xFF1C, // FULLWIDTH LESS-THAN SIGN
    0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
    0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
    0xFF62, // HALFWIDTH LEFT CORNER BRACKET
    0xFFE9  // HALFWIDTH LEFTWARDS ARROW
};

const WCHAR MAC_awchNonBreakingAtLineStart[] = {
    0x0029, // RIGHT PARENTHESIS
    0x002D, // HYPHEN
    0x005D, // RIGHT SQUARE BRACKET
    0x007D, // RIGHT CURLY BRACKET
    0x00AD, // OPTIONAL HYPHEN
    0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x02C7, // CARON
    0x02C9, // MODIFIER LETTER MACRON
    0x055D, // ARMENIAN COMMA
    0x060C, // ARABIC COMMA
    0x2013, // EN DASH
    0x2014, // EM DASH
    0x2016, // DOUBLE VERTICAL LINE
    0x201D, // RIGHT DOUBLE QUOTATION MARK
    0x2022, // BULLET
    0x2025, // TWO DOT LEADER
    0x2026, // HORIZONTAL ELLIPSIS
    0x2027, // HYPHENATION POINT
    0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x2046, // RIGHT SQUARE BRACKET WITH QUILL
    0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
    0x208E, // SUBSCRIPT RIGHT PARENTHESIS
    0x226B, // MUCH GREATER THAN
    0x2574, // BOX DRAWINGS LIGHT LEFT
    0x3001, // IDEOGRAPHIC COMMA
    0x3002, // IDEOGRAPHIC FULL STOP
    0x3003, // DITTO MARK
    0x3005, // IDEOGRAPHIC ITERATION MARK
    0x3009, // RIGHT ANGLE BRACKET
    0x300B, // RIGHT DOUBLE ANGLE BRACKET
    0x300D, // RIGHT CORNER BRACKET
    0x300F, // RIGHT WHITE CORNER BRACKET
    0x3011, // RIGHT BLACK LENTICULAR BRACKET
    0x3015, // RIGHT TORTOISE SHELL BRACKET
    0x3017, // RIGHT WHITE LENTICULAR BRACKET
    0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
    0x301B, // RIGHT WHITE SQUARE BRACKET
    0x301E, // DOUBLE PRIME QUOTATION MARK
    0x3041, // HIRAGANA LETTER SMALL A
    0x3043, // HIRAGANA LETTER SMALL I
    0x3045, // HIRAGANA LETTER SMALL U
    0x3047, // HIRAGANA LETTER SMALL E
    0x3049, // HIRAGANA LETTER SMALL O
    0x3063, // HIRAGANA LETTER SMALL TU
    0x3083, // HIRAGANA LETTER SMALL YA
    0x3085, // HIRAGANA LETTER SMALL YU
    0x3087, // HIRAGANA LETTER SMALL YO
    0x308E, // HIRAGANA LETTER SMALL WA
    0x309B, // KATAKANA-HIRAGANA VOICED SOUND MARK
    0x309C, // KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
    0x309D, // HIRAGANA ITERATION MARK
    0x309E, // HIRAGANA VOICED ITERATION MARK
    0x30A1, // KATAKANA LETTER SMALL A
    0x30A3, // KATAKANA LETTER SMALL I
    0x30A5, // KATAKANA LETTER SMALL U
    0x30A7, // KATAKANA LETTER SMALL E
    0x30A9, // KATAKANA LETTER SMALL O
    0x30C3, // KATAKANA LETTER SMALL TU
    0x30E3, // KATAKANA LETTER SMALL YA
    0x30E5, // KATAKANA LETTER SMALL YU
    0x30E7, // KATAKANA LETTER SMALL YO
    0x30EE, // KATAKANA LETTER SMALL WA
    0x30F5, // KATAKANA LETTER SMALL KA
    0x30F6, // KATAKANA LETTER SMALL KE
    0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0x30FD, // KATAKANA ITERATION MARK
    0x30FE, // KATAKANA VOICED ITERATION MARK
    0xFD3F, // ORNATE RIGHT PARENTHESIS
    0xFE30, // VERTICAL TWO DOT LEADER
    0xFE31, // VERTICAL EM DASH
    0xFE33, // VERTICAL LOW LINE
    0xFE34, // VERTICAL WAVY LOW LINE
    0xFE36, // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    0xFE38, // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    0xFE3A, // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
    0xFE3C, // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
    0xFE3E, // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
    0xFE40, // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    0xFE42, // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
    0xFE44, // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
    0xFE4F, // WAVY LOW LINE
    0xFE50, // SMALL COMMA
    0xFE51, // SMALL IDEOGRAPHIC COMMA
    0xFE5A, // SMALL RIGHT PARENTHESIS
    0xFE5C, // SMALL RIGHT CURLY BRACKET
    0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
    0xFF09, // FULLWIDTH RIGHT PARENTHESIS
    0xFF0C, // FULLWIDTH COMMA
    0xFF0E, // FULLWIDTH FULL STOP
    0xFF1E, // FULLWIDTH GREATER-THAN SIGN
    0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
    0xFF40, // FULLWIDTH GRAVE ACCENT
    0xFF5C, // FULLWIDTH VERTICAL LINE
    0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
    0xFF5E, // FULLWIDTH TILDE
    0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
    0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
    0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA
    0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
    0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
    0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
    0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
    0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
    0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
    0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
    0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
    0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
    0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0xFF9E, // HALFWIDTH KATAKANA VOICED SOUND MARK
    0xFF9F, // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
    0xFFEB  // HALFWIDTH RIGHTWARDS ARROW
};

const WCHAR MAC_awchRomanInterWordSpace[] = {
    0x0009, // TAB
    0x0020, // SPACE
    0x2002, // EN SPACE
    0x2003, // EM SPACE
    0x2004, // THREE-PER-EM SPACE
    0x2005, // FOUR-PER-EM SPACE
    0x2006, // SIX-PER-EM SPACE
    0x2007, // FIGURE SPACE
    0x2008, // PUNCTUATION SPACE
    0x2009, // THIN SPACE
    0x200A, // HAIR SPACE
    0x200B  // ZERO WIDTH SPACE
};

BOOL MAC_ScanWChar(const WCHAR awch[], int nArraySize, WCHAR wch)
{
    int iMin = 0;
    int iMax = nArraySize - 1;

    while (iMax - iMin >= 2)
    {
        int iTry = (iMax + iMin + 1) / 2;
        if (wch < awch[iTry])
            iMax = iTry;
        else if  (wch > awch[iTry])
            iMin = iTry;
        else
            return TRUE;
    }

    return (wch == awch[iMin] || wch == awch[iMax]);
}

// --------------------------------------------------------------------------------
// Mac_StrStrIA
// --------------------------------------------------------------------------------
STDAPI_(LPSTR) Mac_StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
    LPSTR lpFirstI;
    LPSTR lpSrchI;
    LPSTR lpRet;

    if ((NULL == lpFirst) || (NULL == lpSrch))
    {
        return NULL;
    }
    
    lpFirstI = StrDupA(lpFirst);
    lpSrchI = StrDupA(lpSrch);

    lpRet = StrStr(lpFirstI, lpSrchI);
    
    SafeMemFree(lpFirstI);
    SafeMemFree(lpSrchI);

    return lpRet;
}

// --------------------------------------------------------------------------------
// MAC_StrFormatByteSize
// --------------------------------------------------------------------------------
LPSTR MAC_StrFormatByteSize(DWORD dw, LPSTR szBuf, UINT uiBufSize)
{
    CHAR    szUnit[15];
    
    szUnit[0] = '\0';
    if (dw > 1024)
    {
        LoadString(g_hLocRes, idsBytes, szUnit, ARRAYSIZE(szUnit));
        _snprintf(szBuf, uiBufSize, szUnit, dw);
    }
    else
    {
        LoadString(g_hLocRes, idsKilo, szUnit, ARRAYSIZE(szUnit));
        _snprintf(szBuf, uiBufSize, szUnit, (ULONG) (dw / 1024));
    }
    
    return szBuf;
}

// --------------------------------------------------------------------------------
// MAC_PathFindExtension
// --------------------------------------------------------------------------------
STDAPI_(LPSTR) MAC_PathFindExtension(LPCSTR pszPath)
{
    LPSTR   pszWalk;
    LPSTR   pszFileName = (LPSTR) pszPath;
    LPSTR   pszLastDot = NULL;
    
    for (pszWalk = (LPSTR) pszPath; *pszWalk != '\0'; pszWalk++)
    {
        // $REVIEW: Should we be looking for Macintosh directories
        //          or Windows directories???
        if (':' == *pszWalk)
        {
            // Point to the character after the seperator
            // because that might be the start of the file name
            pszFileName = pszWalk + 1;
        }
        else if ('.' == *pszWalk)
        {
            pszLastDot = pszWalk;
        }
    }
    
    if (pszLastDot < pszFileName)
    {
        pszLastDot = pszWalk;
    }
    
    return pszLastDot;
}

// --------------------------------------------------------------------------------
// MAC_PathFindFileName
// --------------------------------------------------------------------------------
STDAPI_(LPSTR) MAC_PathFindFileName(LPCSTR pszPath)
{
    LPSTR   pszWalk;
    LPSTR   pszFileName = (LPSTR) pszPath;
    
    for (pszWalk = (LPSTR) pszPath; *pszWalk != '\0'; pszWalk++)
    {
        // $REVIEW: Should we be looking for Macintosh directories
        //          or Windows directories???
        if (':' == *pszWalk)
        {
            // Point to the character after the seperator
            // because that might be the start of the file name
            pszFileName = pszWalk + 1;
        }
    }
    
    return pszFileName;
}

// --------------------------------------------------------------------------------
// MAC_BreakLineW
// --------------------------------------------------------------------------------
HRESULT MAC_BreakLineW(LCID locale, const WCHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip)
{
    HRESULT hr = S_OK;
    long cColumns = 0;
    long lCandPos;
    long lBreakPos = -1;
    long lSkipLen = 0;
    struct {
        unsigned fDone : 1;
        unsigned fInSpaces : 1;
        unsigned fFEChar : 1;
        unsigned fInFEChar : 1;
        unsigned fBreakByEndOfLine : 1;
        unsigned fNonBreakNext : 1;
        unsigned fHaveCandPos : 1;
        unsigned fSlashR : 1;
    } Flags = {0, 0, 0, 0, 0, 0, 0, 0};

    locale; // Not used yet...

    // While we still have characters left
    for (int iCh = 0; iCh < cchSrc; iCh++)
    {
        const WCHAR wch = pszSrc[iCh];

        if (wch == wchCR && !Flags.fSlashR)
        {
            Flags.fSlashR = TRUE;
        }
        else if (wch == wchLF || Flags.fSlashR) // End of line
        {
            Flags.fDone = TRUE;
            Flags.fBreakByEndOfLine = TRUE;
            if (Flags.fInSpaces)
            {
                Flags.fHaveCandPos = FALSE;
                lBreakPos = lCandPos;
                lSkipLen++; // Skip spaces and line break character
            }
            else
            {
                lBreakPos = iCh; // Break at right before the end of line
                if (Flags.fSlashR)
                    lBreakPos--;

                lSkipLen = 1; // Skip line break character
            }
            if (wch == wchLF && Flags.fSlashR)
                lSkipLen++;
            break;
        }
        else if (MAC_ScanWChar(MAC_awchRomanInterWordSpace, ARRAYSIZE(MAC_awchRomanInterWordSpace), wch)) // Spaces
        {
            if (!Flags.fInSpaces && !Flags.fNonBreakNext)
            {
                Flags.fHaveCandPos = TRUE;
                lCandPos = iCh; // Break at right before the spaces
                lSkipLen = 0;
            }
            Flags.fInSpaces = TRUE;
            lSkipLen++; // Skip continuous spaces after breaking
        }
        else // Other characters
        {
            // Don't use this code.  We'll pick it up when MLANG is ported.
#ifdef NEVER
            Flags.fFEChar = ((wCharType3 & (C3_KATAKANA | C3_HIRAGANA | C3_FULLWIDTH | C3_IDEOGRAPH)) != 0);

            if ((Flags.fFEChar || Flags.fInFEChar) && !Flags.fNonBreakNext && !Flags.fInSpaces)
            {
                Flags.fHaveCandPos = TRUE;
                lCandPos = lSrcPosTemp + iCh; // Break at right before or after the FE char
                lSkipLen = 0;
            }
            Flags.fInFEChar = Flags.fFEChar;
#endif  // NEVER
            Flags.fInSpaces = FALSE;

            if (Flags.fHaveCandPos)
            {
                Flags.fHaveCandPos = FALSE;
                if (!MAC_ScanWChar(MAC_awchNonBreakingAtLineStart, ARRAYSIZE(MAC_awchNonBreakingAtLineStart), wch))
                    lBreakPos = lCandPos;
            }

            if (cColumns + 1 > cMaxColumns)
            {
                Flags.fDone = TRUE;
                break;
            }

            Flags.fNonBreakNext = MAC_ScanWChar(MAC_awchNonBreakingAtLineEnd, ARRAYSIZE(MAC_awchNonBreakingAtLineEnd), wch);
        }

        cColumns++;
    }

    if (Flags.fHaveCandPos)
        lBreakPos = lCandPos;

    if (!Flags.fBreakByEndOfLine && lBreakPos < 0)
    {
        lBreakPos = min(cchSrc, cMaxColumns); // Default breaking
        lSkipLen = 0;
    }

    if (!Flags.fDone)
    {
        if (Flags.fInSpaces)
        {
            lBreakPos = cchSrc - lSkipLen;
        }
        else
        {
            lBreakPos = cchSrc;
            lSkipLen = 0;
        }
        if (Flags.fSlashR)
        {
            lBreakPos--;
            lSkipLen++;
        }
    }
    
    if (pcchLine)
        *pcchLine = lBreakPos;
    if (pcchSkip)
        *pcchSkip = lSkipLen;
    
    return hr;
}

// --------------------------------------------------------------------------------
// MAC_BreakLineA
// --------------------------------------------------------------------------------
HRESULT MAC_BreakLineA(LCID locale, UINT uCodePage, const CHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip)
{
    HRESULT hr;
    LPWSTR wszBuff = NULL;
    long    cchLineTemp;
    long    cchSkipTemp;
    int     cwch;

    // Check parameters
    if ((NULL == pszSrc) || (cMaxColumns < 0))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    if (0 == cchSrc)
    {
        hr = S_OK;
        if (pcchLine)
        {
            *pcchLine = 0;
        }

        if (pcchSkip)
        {
            *pcchSkip = 0;
        }

        goto exit;
    }

    cwch = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, pszSrc, cchSrc, NULL, NULL);
    if (!cwch)
    {
        hr = E_FAIL;
        goto exit;
    }

    CHECKALLOC(wszBuff = (LPWSTR)g_pMalloc->Alloc(cwch * sizeof(WCHAR)));

    cwch = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, pszSrc, cchSrc, wszBuff, cwch);
    Assert(cwch);

    CHECKHR(hr = MAC_BreakLineW(locale, wszBuff, cwch, cMaxColumns, &cchLineTemp, &cchSkipTemp));

    if (pcchLine)
    {
        if (cchLineTemp != 0)
        {
            *pcchLine = WideCharToMultiByte(uCodePage, 0, wszBuff, cchLineTemp, NULL, 0, NULL, NULL);
        } else 
        {
            *pcchLine = 0;
        }
    }

    if (pcchSkip)
    {
        *pcchSkip = WideCharToMultiByte(uCodePage, 0, wszBuff + cchLineTemp, cchSkipTemp, NULL, 0, NULL, NULL);
    }

exit:

    SafeMemFree(wszBuff);
    
    return hr;
}

//---------------------------------------------------------------------------------
// MAC_IsConvertINetStringAvailable
//---------------------------------------------------------------------------------
STDAPI MAC_IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding)
{
    HRESULT hrResult = S_OK;
    
    if (!(IsValidCodePage(dwSrcEncoding) && IsValidCodePage(dwDstEncoding)))
    {
        hrResult = S_FALSE;
    }

    return hrResult;
}

//---------------------------------------------------------------------------------
// MAC_ConvertINetString
//---------------------------------------------------------------------------------
STDAPI MAC_ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding,
                    LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize)   
{
    HRESULT hrResult;
    INT     cch;
    INT     cwch;
    INT     cchSrcSize;
    INT     cchDstSize;
    LPWSTR  pwsz = NULL;

    // Check parameters....
    if (lpdwMode)
    {
        AssertSz(FALSE, "We don't support any variations");
        hrResult = E_FAIL;
        cchDstSize = 0;
        goto exit;
    }

    if ((!lpSrcStr) || (FALSE == IsValidCodePage(dwSrcEncoding)) || (FALSE == IsValidCodePage(dwDstEncoding)))
    {
        hrResult = E_FAIL;
        cchDstSize = 0;
        goto exit;
    }
    
    if(lpnSrcSize)
    {
        cchSrcSize = *lpnSrcSize;
    }
    else
    {
        cchSrcSize = -1;
    }

    if(!lpDstStr)
    {
        cchDstSize = 0;
    }
    else if (lpnDstSize)
    {
        cchDstSize = *lpnDstSize;
    }
    else
    {
        cchDstSize = 0;
    }
        
    if (-1 == cchSrcSize)
    {
        AssertSz(FALSE, "We don't support any variations");
        hrResult = E_FAIL;
        goto exit;
    }
    
    // Allocate the buffer
    hrResult = HrAlloc((LPVOID *)&pwsz, cchSrcSize * sizeof(WCHAR));
    if (FAILED(hrResult))
        goto exit;

    cwch = MultiByteToWideChar(dwSrcEncoding, MB_PRECOMPOSED, lpSrcStr,
                    cchSrcSize, pwsz, cchSrcSize * sizeof(WCHAR));    
    if (0 == cwch)
    {
        hrResult = E_FAIL;
        goto exit;
    }

    cchDstSize = WideCharToMultiByte(dwDstEncoding, 0, pwsz, cwch, lpDstStr, cchDstSize, NULL, NULL);
    if (0 == cchDstSize)
    {
        hrResult = E_FAIL;
        goto exit;
    }

exit:
    if (lpnDstSize)
    {
        *lpnDstSize = cchDstSize;
    }
    
    SafeMemFree(pwsz);
    
    return hrResult;
}

STDAPI MAC_CoInternetCombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags,          
                        LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)                                  
{
    UINT    cchSizeNeeded = 0;
    UINT    cchBaseUrl;
    HRESULT hr;
    LPWSTR  pwzTempUrl;

    // Check the parameters
    if ((!pwzBaseUrl) || dwCombineFlags || dwReserved)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Do we have enough room for the string?
    cchBaseUrl = lstrlenW(pwzBaseUrl);
    cchSizeNeeded = cchBaseUrl + lstrlenW(pwzRelativeUrl) + 1;

    // Add one for the connecting '\' or subtract one if we have too many...
    if ((L'/' != pwzBaseUrl[cchBaseUrl]) && (L'/' != pwzRelativeUrl[0]))
    {
        cchSizeNeeded++;
    }
    else if ((L'/' == pwzBaseUrl[cchBaseUrl]) && (L'/' == pwzRelativeUrl[0]))
    {
        cchSizeNeeded--;
    }

    if (cchSizeNeeded < cchResult)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Copy the base url
    wcscpy(pszResult, pwzBaseUrl);

    // Do we need a ending slash?
    if (L'/' != pwzBaseUrl[cchBaseUrl])
    {
        pszResult[cchBaseUrl + 1] = L'/';
    }

    // concatenate relative url
    wcscat(pszResult, ((L'/' == pwzRelativeUrl[0]) ? pwzRelativeUrl + 1: pwzRelativeUrl));

    hr = S_OK;
   
exit:
    // set count of result buffer
    if (pcchResult)
    {
        *pcchResult = cchSizeNeeded;
    }
    
    return hr;
}

// --------------------------------------------------------------------------------
// Mac_SzGetLocalPackedIP
// --------------------------------------------------------------------------------
LPSTR Mac_SzGetLocalPackedIP(void)
{
    return "127.0.0.1";
}

// --------------------------------------------------------------------------------
// Mac_SzGetLocalHostNameForID
// --------------------------------------------------------------------------------
LPSTR Mac_SzGetLocalHostNameForID(void)
{
    return "localhost";
}

/*+++

  SHUrlUnescape()
    Unescapes a string in place.  this is ok because 
    it should never grow

  Parameters
  IN -
    psz         string to unescape inplace
    dwFlags     the relevant URL_* flags, 
     
  Returns   
  HRESULT -
    SUCCESS     S_OK
    ERROR       DOESNT error right now


  Helper Routines
    HexToWord               takes a hexdigit and returns WORD with the right number or -1
    IsEscapedChar           looks at a ptr for "%XX" where X is a hexdigit
    TranslateEscapedChar    translates "%XX" to an 8 bit char
---*/

PRIVATE WORD
Mac_HexToWord(WCHAR ch)
{
    if(ch >= L'0' && ch <= L'9')
        return (WORD) ch - L'0';
    if(ch >= L'A' && ch <= L'F')
        return (WORD) ch - L'A' + 10;
    if(ch >= L'a' && ch <= L'f')
        return (WORD) ch - L'a' + 10;

    Assert(FALSE);  //we have tried to use a non-hex number
    return (WORD) -1;
}

PRIVATE BOOL inline
MAC_IsEscapedOctet(LPCWSTR pch)
{
    return (pch[0] == HEX_ESCAPE && IsHex(pch[1]) && IsHex(pch[2])) ? TRUE : FALSE;
}

PRIVATE WCHAR 
MAC_TranslateEscapedOctet(LPCWSTR pch)
{
    WCHAR ch;
    Assert(MAC_IsEscapedOctet(pch));

    pch++;
    ch = (WCHAR) Mac_HexToWord(*pch++) * 16; // hi nibble
    ch += Mac_HexToWord(*pch); // lo nibble

    return ch;
}

HRESULT MAC_SHUrlUnescape(LPWSTR psz, DWORD dwFlags)
{
    WCHAR *pchSrc = psz;
    WCHAR *pchDst = psz;
    BOOL  fTrailByte = FALSE;

    while (*pchSrc) 
    {
        if ((*pchSrc == POUND || *pchSrc == QUERY) && (dwFlags & URL_DONT_ESCAPE_EXTRA_INFO))
        {
            lstrcpyW(pchDst, pchSrc);
            pchDst += lstrlenW(pchDst);
            break;
        }

        if (MAC_IsEscapedOctet(pchSrc))
        {
            WCHAR ch =  MAC_TranslateEscapedOctet(pchSrc);

            *pchDst++ = ch;

            pchSrc += 3; // enuff for "%XX"
        }
        else
        {
            *pchDst++ = *pchSrc++;
        }
    }

    TERMSTR(pchDst);

    return S_OK;

}

PRIVATE HRESULT
MAC_CopyOutA(LPSTR pszIn, LPSTR pszOut, LPDWORD pcch)
{
    HRESULT hr = S_OK;
    DWORD cch;
    Assert(pszIn);
    Assert(pszOut);
    Assert(pcch);

    cch = lstrlen(pszIn);
    if(*pcch > cch)
        lstrcpyA(pszOut, pszIn);
    else
        hr = E_POINTER;

    *pcch = cch + (FAILED(hr) ? 1 : 0);

    return hr;
}

STDAPI
MAC_UrlUnescapeA(LPSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszIn = NULL;
    LPSTR   pszOutT = NULL;

    if(pszIn)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
        
    CHECKALLOC(pwszIn = PszToUnicode(CP_ACP, pszIn));

    MAC_SHUrlUnescape(pwszIn, dwFlags);

    CHECKALLOC(pszOutT = PszToANSI(CP_ACP, pwszIn));

    if(dwFlags & URL_UNESCAPE_INPLACE)
    {
        lstrcpyA(pszIn, pszOutT);
    }
    else if(pszOut && pcchOut && *pcchOut)
    {
        hr = MAC_CopyOutA(pszOutT, pszOut, pcchOut);
    }
    else
        hr = E_INVALIDARG;

exit:
    // Cleanup
    SafeMemFree(pwszIn);
    SafeMemFree(pszOutT);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CoCreateInstance
// --------------------------------------------------------------------------------
STDAPI Athena_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwContext,
                            REFIID iid, LPVOID * ppv)
{
    HRESULT         hr;
    IClassFactory * pICFactory;

    *ppv = NULL;

    hr = Ares_DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID *) &pICFactory);
    if (CLASS_E_CLASSNOTAVAILABLE == hr)
    {
        hr = Athena_DllGetClassObject(rclsid, IID_IClassFactory, (LPVOID *) &pICFactory);
    }
    
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = pICFactory->CreateInstance(pUnkOuter, iid, ppv);

    pICFactory->Release();

Error:
    return hr;
}

EXTERN_C INT CchFileTimeToLongDateTimeSz(FILETIME * pft, TCHAR * szDateTime,
                                                    UINT cchStr, BOOL fNoSeconds);
// 
// This function just goes off and uses a function in Capone to do it's work.
STDAPI_(INT) MAC_CchFileTimeToDateTimeSz(FILETIME * pft, TCHAR * szDateTime, int cch, DWORD dwFlags)
{
    Assert(dwFlags & DTM_LONGDATE);
    return CchFileTimeToLongDateTimeSz(pft, szDateTime, (UINT) cch, dwFlags & DTM_NOSECONDS);
}
#endif  // MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\internat.cpp ===
// --------------------------------------------------------------------------------
// Internat.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "internat.h"
#include "variantx.h"
#include "containx.h"
#include "symcache.h"
#include "icoint.h"
#include "mlang.h"
#include "demand.h"
#include "strconst.h"
#include "mimeapi.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "qstrcmpi.h"

// In rfc1522.cpp
BOOL FContainsExtended(LPPROPSTRINGA pStringA, ULONG *pcExtended);

// --------------------------------------------------------------------------------
// Global Default Charset - This is only used if mlang is not installed
// --------------------------------------------------------------------------------
INETCSETINFO CIntlGlobals::mg_rDefaultCharset = {
    "ISO-8859-1",
    NULL,
    1252,
    28591,
    0
};

// --------------------------------------------------------------------------------
// InitInternational
// --------------------------------------------------------------------------------
void InitInternational(void)
{

    // Allocate g_pInternat
    g_pInternat = new CMimeInternational;
    if (NULL == g_pInternat)
    {
        AssertSz(FALSE, "Unable to allocate g_pInternat.");
        return;
    }
    CIntlGlobals::Init();
}

// --------------------------------------------------------------------------------
// CMimeInternational::CMimeInternational
// --------------------------------------------------------------------------------
CMimeInternational::CMimeInternational(void)
{
    // Var Init
    m_cRef = 1;
    ZeroMemory(&m_cst, sizeof(CSTABLE));
    ZeroMemory(&m_cpt, sizeof(CPTABLE));

    // Init HCHARSET tagger, don't let it be zero
    m_wTag = LOWORD(GetTickCount());
    while(m_wTag == 0 || m_wTag == 0xffff)
        m_wTag++;

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    m_dwConvState = 0 ; 
}
 
// --------------------------------------------------------------------------------
// CMimeInternational::~CMimeInternational
// --------------------------------------------------------------------------------
CMimeInternational::~CMimeInternational(void)
{
    // Clean up globals
    CIntlGlobals::Term();

    // Free data
    _FreeInetCsetTable();
    _FreeCodePageTable();
}

// --------------------------------------------------------------------------------
// CMimeInternational::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeInternational == riid)
        *ppv = (IMimeInternational *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeInternational::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeInternational::AddRef(void)
{
    // Raid 26762
    DllAddRef();
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeInternational::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeInternational::Release(void)
{
    // Raid 26762
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    else
        DllRelease();
    return (ULONG)cRef;
}

// -------------------------------------------------------------------------
// CMimeInternational::_FreeInetCsetTable
// -------------------------------------------------------------------------
void CMimeInternational::_FreeInetCsetTable(void)
{
    // Free Each Charset
    for (ULONG i=0; i<m_cst.cCharsets; i++)
        g_pMalloc->Free((LPVOID)m_cst.prgpCharset[i]);

    // Free the Array
    SafeMemFree(m_cst.prgpCharset);

    // Clear the Table
    ZeroMemory(&m_cst, sizeof(CSTABLE));
}

// -------------------------------------------------------------------------
// CMimeInternational::_FreeCodePageTable
// -------------------------------------------------------------------------
void CMimeInternational::_FreeCodePageTable(void)
{
    // Free Each Charset
    for (ULONG i=0; i<m_cpt.cPages; i++)
        g_pMalloc->Free((LPVOID)m_cpt.prgpPage[i]);

    // Free the Array
    SafeMemFree(m_cpt.prgpPage);

    // Clear the Table
    ZeroMemory(&m_cpt, sizeof(CPTABLE));
}

// -------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// -------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(LPCSTR pszCharset, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUpper,
                    lLower,
                    lMiddle,
                    nCompare;
    ULONG           i;
    BOOL            fExcLock;

    fExcLock = FALSE;

    // Invalid Arg
    Assert(pszCharset && ppCharset);

    // Init
    *ppCharset = NULL;

    // Thread Safety
    m_lock.ShareLock();

again:
    // Do we have anything yet
    if (m_cst.cCharsets > 0)
    {
        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_cst.cCharsets - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // Get string to compare against
            i = m_cst.prgpCharset[lMiddle]->dwReserved1;

            // Do compare
            nCompare = OEMstrcmpi(pszCharset, m_cst.prgpCharset[i]->szName);

            // If Equal, then were done
            if (nCompare == 0)
            {
                *ppCharset = m_cst.prgpCharset[i];
                goto exit;
            }

            // Compute upper and lower 
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }
    if(FALSE == fExcLock)
    {
        m_lock.ShareUnlock();       //Release the Sharelock before
        m_lock.ExclusiveLock();     //getting the exclusive lock
        fExcLock = TRUE; 
        //during the change of lock the value might have changed
        //check it again
        goto again;
    }
    // Not found, lets open the registry
    CHECKHR(hr = _HrReadCsetInfo(pszCharset, ppCharset));

exit:
    // Thread Safety
    if(TRUE==fExcLock)
        m_lock.ExclusiveUnlock();
    else
        m_lock.ShareUnlock();

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::_HrReadCsetInfo
// -------------------------------------------------------------------------
HRESULT CMimeInternational::_HrReadCsetInfo(LPCSTR pszCharset, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset=NULL;
    IMultiLanguage  *pMLang1 = NULL;
    IMultiLanguage2 *pMLang2 = NULL;
    MIMECSETINFO    mciInfo;
    BSTR            strCharset = NULL;
    int				iRes;
    
    // Invalid Arg
    Assert(pszCharset && ppCharset);
    
    // Init
    *ppCharset = NULL;
    
    // Try to create an IMultiLanguage2 interface
    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_MLANG2))
    {
        
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage2, (LPVOID *) &pMLang2);
        if (!SUCCEEDED(hr)) 
        {
            // Ok that failed, so lets try to create an IMultiLanaguage interface
            hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
            if (!SUCCEEDED(hr)) 
            {
                TrapError(hr);
                goto exit;
            }
        }
    }
    else
    {
        // Ok that failed, so lets try to create an IMultiLanaguage interface
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            goto exit;
        }
    }
    // MLANG wants the charset name as a BSTR, so we need to convert it from ANSI...
    strCharset = SysAllocStringLen(NULL,lstrlen(pszCharset));
    if (!strCharset) 
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    iRes = MultiByteToWideChar(CP_ACP,0,pszCharset,-1,strCharset,SysStringLen(strCharset)+1);
    if (iRes == 0) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr)) 
        {
            hr = E_FAIL;
        }
        TrapError(hr);
        goto exit;
    }
    
    // Use pMLang2
    if (pMLang2)
    {
        // Use mlang2
        hr = pMLang2->GetCharsetInfo(strCharset, &mciInfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;
            goto exit;
        }
    }
    
    else
    {
        // Now just call MLANG to get the info...
        hr = pMLang1->GetCharsetInfo(strCharset, &mciInfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;
            goto exit;
        }
    }
    
    // Add a new entry into the language table
    if (m_cst.cCharsets + 1 >= m_cst.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_cst.prgpCharset, sizeof(LPINETCSETINFO) * (m_cst.cAlloc +  5)));
        
        // Increment Alloc
        m_cst.cAlloc += 5;
    }
    
    // Allocate a Charset
    CHECKALLOC(pCharset = (LPINETCSETINFO)g_pMalloc->Alloc(sizeof(INETCSETINFO)));
    
    // Initialize
    ZeroMemory(pCharset, sizeof(INETCSETINFO));
    
    // Set Sort Index
    pCharset->dwReserved1 = m_cst.cCharsets;
    
    // Set HCharset
    pCharset->hCharset = HCSETMAKE(m_cst.cCharsets);
    
    // Read Data
    lstrcpyn(pCharset->szName, pszCharset, ARRAYSIZE(pCharset->szName));
    pCharset->cpiInternet = mciInfo.uiInternetEncoding;
    pCharset->cpiWindows = mciInfo.uiCodePage;
    
    // Readability
    m_cst.prgpCharset[m_cst.cCharsets] = pCharset;
    
    // Return it
    *ppCharset = pCharset;
    
    // Don't Free It
    pCharset = NULL;
    
    // Increment Count
    m_cst.cCharsets++;
    
    // Let Sort the cset table
    _QuickSortCsetInfo(0, m_cst.cCharsets - 1);
    
exit:
    // Cleanup
    SafeRelease(pMLang1);
    SafeRelease(pMLang2);
    if (strCharset) 
    {
        SysFreeString(strCharset);
    }
    SafeMemFree(pCharset);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::_QuickSortCsetInfo
// --------------------------------------------------------------------------------
void CMimeInternational::_QuickSortCsetInfo(long left, long right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_cst.prgpCharset[(i + j) / 2]->dwReserved1;

    do  
    {
        while(OEMstrcmpi(m_cst.prgpCharset[m_cst.prgpCharset[i]->dwReserved1]->szName, m_cst.prgpCharset[k]->szName) < 0 && i < right)
            i++;
        while (OEMstrcmpi(m_cst.prgpCharset[m_cst.prgpCharset[j]->dwReserved1]->szName, m_cst.prgpCharset[k]->szName) > 0 && j > left)
            j--;

        if (i <= j)
        {
            temp = m_cst.prgpCharset[i]->dwReserved1;
            m_cst.prgpCharset[i]->dwReserved1 = m_cst.prgpCharset[j]->dwReserved1;
            m_cst.prgpCharset[j]->dwReserved1 = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QuickSortCsetInfo(left, j);
    if (i < right)
        _QuickSortCsetInfo(i, right);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(HCHARSET hCharset, LPINETCSETINFO *ppCharset)
{
    // Invalid Arg
    Assert(hCharset && ppCharset);

    // Init
    *ppCharset = NULL;

    // Invalid Handle
    if (HCSETVALID(hCharset) == FALSE)
        return TrapError(MIME_E_INVALID_HANDLE);

    // Deref
    *ppCharset = PCsetFromHCset(hCharset);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrFindCodePage
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrFindCodePage(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lUpper,
                    lLower,
                    lMiddle,
                    nCompare;
    BOOL            fExcLock;

    fExcLock = FALSE;


    // Invalid Arg
    Assert(ppCodePage);

    // Init
    *ppCodePage = NULL;

    // Thread Safety
    m_lock.ShareLock();

again:
    // Do We have anything yet
    if (m_cpt.cPages > 0)
    {
        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_cpt.cPages - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // If Equal, then were done
            if (cpiCodePage == m_cpt.prgpPage[lMiddle]->cpiCodePage)
            {
                *ppCodePage = m_cpt.prgpPage[lMiddle];
                goto exit;
            }

            // Compute upper and lower 
            if (cpiCodePage > m_cpt.prgpPage[lMiddle]->cpiCodePage)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }
    if(FALSE == fExcLock)
    {
        m_lock.ShareUnlock();       //Release the Sharelock before
        m_lock.ExclusiveLock();     //getting the exclusive lock
        fExcLock = TRUE; 
        //during the change of lock the value might have changed
        //check it again
        goto again;
    }

    // Not found, lets open the registry
    CHECKHR(hr = _HrReadPageInfo(cpiCodePage, ppCodePage));

exit:
    // Thread Safety
    if(TRUE==fExcLock)
        m_lock.ExclusiveUnlock();
    else
        m_lock.ShareUnlock();

    // Done
    return hr;
}

HRESULT convert_mimecpinfo_element(LPCWSTR pszFrom,
                                   LPSTR pszTo,
                                   DWORD cchTo,
                                   DWORD& refdwFlags,
                                   DWORD dwFlag) {
    HRESULT hr = S_OK;
    int iRes;

    if (pszFrom[0]) {
        iRes = WideCharToMultiByte(CP_ACP,
                                   0,
                                   pszFrom,
                                   -1,
                                   pszTo,
                                   cchTo,
                                   NULL,
                                   NULL);
        if (iRes == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr)) {
                hr = E_FAIL;
            }
        } else {
            FLAGSET(refdwFlags,dwFlag);
        }
    }
    return (hr);
}


#define CONVERT_MIMECPINFO_ELEMENT(__FROM__,__TO__,__FLAG__) \
    hr = convert_mimecpinfo_element(cpinfo.__FROM__, \
                                    pCodePage->__TO__, \
                                    sizeof(pCodePage->__TO__)/sizeof(pCodePage->__TO__[0]), \
                                    pCodePage->dwMask, \
                                    __FLAG__); \
    if (!SUCCEEDED(hr)) { \
        TrapError(hr); \
        goto exit; \
    }

// -------------------------------------------------------------------------
// CMimeInternational::_HrReadPageInfo
// -------------------------------------------------------------------------
HRESULT CMimeInternational::_HrReadPageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO *ppCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pCodePage=NULL;
    MIMECPINFO		cpinfo;
    IMultiLanguage 	*pMLang1=NULL;
    IMultiLanguage2	*pMLang2=NULL;
    int				iRes;
    
    // Invalid Arg
    Assert(ppCodePage);
    
    // Init
    *ppCodePage = NULL;
    
    // Try to create an IMultiLanguage2 interface
    // If we are in OE5 compat mode...
    if (TRUE == ISFLAGSET(g_dwCompatMode, MIMEOLE_COMPAT_MLANG2))
    {
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage2, (LPVOID *) &pMLang2);
        if (!SUCCEEDED(hr)) 
        {
            // Ok that failed, so lets try to create an IMultiLanaguage interface
            hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
            if (!SUCCEEDED(hr)) 
            {
                TrapError(hr);
                goto exit;
            }
        }
    }
    else
    {
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL,CLSCTX_INPROC, IID_IMultiLanguage, (LPVOID *) &pMLang1);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            goto exit;
        }
    }
    
    // Use mlang2 ?
    if (pMLang2)
    {
        // use mlang2
        hr = pMLang2->GetCodePageInfo(cpiCodePage, MLGetUILanguage(), &cpinfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;	// tbd - MLang doesn't define good error codes, so...
            goto exit;
        }
    }
    
    // Otherwise use ie4 mlang
    else
    {
        // use mlang1
        hr = pMLang1->GetCodePageInfo(cpiCodePage, &cpinfo);
        if (!SUCCEEDED(hr)) 
        {
            TrapError(hr);
            hr = MIME_E_NOT_FOUND;	// tbd - MLang doesn't define good error codes, so...
            goto exit;
        }
    }
    
    
    // Add a new entry into the language table
    if (m_cpt.cPages + 1 >= m_cpt.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_cpt.prgpPage, sizeof(LPCODEPAGEINFO) * (m_cpt.cAlloc +  5)));
        
        // Increment Alloc
        m_cpt.cAlloc += 5;
    }
    
    // Allocate Code Page Structure
    CHECKALLOC(pCodePage = (LPCODEPAGEINFO)g_pMalloc->Alloc(sizeof(CODEPAGEINFO)));
    
    // Initialize
    ZeroMemory(pCodePage, sizeof(CODEPAGEINFO));
    
    // Set Sort Index
    pCodePage->dwReserved1 = m_cpt.cPages;
    
    // Set Charset
    pCodePage->cpiCodePage = cpiCodePage;
    
    // IsValidCodePage
    pCodePage->fIsValidCodePage = IsValidCodePage(cpiCodePage);
    
    // Default
    pCodePage->ulMaxCharSize = 1;
    
    // Raid 43508: GetCPInfo faults in Kernal when passed an invalid codepage on Win95
    // if (pCodePage->fIsValidCodePage  && GetCPInfo(pCodePage->cpiCodePage, &cpinfo))
    if (IsDBCSCodePage(cpiCodePage) || CP_UNICODE == cpiCodePage)
        pCodePage->ulMaxCharSize = 2;
    
    // c_szDescription
    CONVERT_MIMECPINFO_ELEMENT(wszDescription,szName,ILM_NAME)
        
        // c_szBodyCharset
        CONVERT_MIMECPINFO_ELEMENT(wszBodyCharset,szBodyCset,ILM_BODYCSET)
        
        // c_szHeaderCharset
        CONVERT_MIMECPINFO_ELEMENT(wszHeaderCharset,szHeaderCset,ILM_HEADERCSET)
        
        // c_szWebCharset
        CONVERT_MIMECPINFO_ELEMENT(wszWebCharset,szWebCset,ILM_WEBCSET)
        
        // c_szFixedWidthFont
        CONVERT_MIMECPINFO_ELEMENT(wszFixedWidthFont,szFixedFont,ILM_FIXEDFONT)
        
        // c_szProportionalFont
        CONVERT_MIMECPINFO_ELEMENT(wszProportionalFont,szVariableFont,ILM_VARIABLEFONT)
        
        // Set the Family CodePage
        pCodePage->cpiFamily = cpinfo.uiFamilyCodePage;
    
    // The family codepage is valid
    FLAGSET(pCodePage->dwMask,ILM_FAMILY);
    
    // See if this is an internet codepage
    if (cpinfo.uiFamilyCodePage != cpinfo.uiCodePage) 
        pCodePage->fInternetCP = TRUE;
    
    // c_szMailMimeEncoding
    // tbd - not supported by IMultiLanguage
    pCodePage->ietMailDefault = IET_BINARY;
    
    // c_szNewsMimeEncoding
    // tbd - not supported by IMultiLanguage
    pCodePage->ietNewsDefault = IET_BINARY;
    
    // Readability
    m_cpt.prgpPage[m_cpt.cPages] = pCodePage;
    
    // Return it
    *ppCodePage = pCodePage;
    
    // Don't Free It
    pCodePage = NULL;
    
    // Increment Count
    m_cpt.cPages++;
    
    // Let Sort the lang table
    _QuickSortPageInfo(0, m_cpt.cPages - 1);
    
exit:
    // Cleanup
    SafeRelease(pMLang1);
    SafeRelease(pMLang2);
    SafeMemFree(pCodePage);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::_QuickSortPageInfo
// --------------------------------------------------------------------------------
void CMimeInternational::_QuickSortPageInfo(long left, long right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_cpt.prgpPage[(i + j) / 2]->dwReserved1;

    do  
    {
        while(m_cpt.prgpPage[m_cpt.prgpPage[i]->dwReserved1]->cpiCodePage < m_cpt.prgpPage[k]->cpiCodePage && i < right)
            i++;
        while (m_cpt.prgpPage[m_cpt.prgpPage[j]->dwReserved1]->cpiCodePage > m_cpt.prgpPage[k]->cpiCodePage && j > left)
            j--;

        if (i <= j)
        {
            temp = m_cpt.prgpPage[i]->dwReserved1;
            m_cpt.prgpPage[i]->dwReserved1 = m_cpt.prgpPage[j]->dwReserved1;
            m_cpt.prgpPage[j]->dwReserved1 = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _QuickSortPageInfo(left, j);
    if (i < right)
        _QuickSortPageInfo(i, right);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrOpenCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrOpenCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPINETCSETINFO *ppCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pCodePage;

    // Invalid Arg
    Assert(ppCharset);

    // Init
    *ppCharset = NULL;

    // Get the body charset
    CHECKHR(hr = HrFindCodePage(cpiCodePage, &pCodePage));

    // CHARSET_HEADER
    if (CHARSET_HEADER == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_HEADERCSET) || FIsEmptyA(pCodePage->szHeaderCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szHeaderCset, ppCharset));
    }

    // CHARSET_WEB
    else if (CHARSET_WEB == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_WEBCSET) || FIsEmptyA(pCodePage->szWebCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szWebCset, ppCharset));
    }

    // CHARSET_BODY
    else if (CHARSET_BODY == ctCsetType)
    {
        // MIME_E_NO_DATA
        if (!ISFLAGSET(pCodePage->dwMask, ILM_BODYCSET) || FIsEmptyA(pCodePage->szBodyCset))
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        // Find the Handle
        CHECKHR(hr = HrOpenCharset(pCodePage->szBodyCset, ppCharset));
    }

    // Error
    else
    {
        hr = TrapError(MIME_E_INVALID_CHARSET_TYPE);
        goto exit;
    }
   
exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCodePageCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Call Method
    CHECKHR(hr = HrOpenCharset(cpiCodePage, ctCsetType, &pCharset));

    // Return the Handle
    *phCharset = pCharset->hCharset;

exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::SetDefaultCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::SetDefaultCharset(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;
    LPINETCSETINFO  pDefHeadCset;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Bad Handle
    if (HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Get Charset Info
    pCharset = PCsetFromHCset(hCharset);

    // Get g_hSysBodyCset and g_hSysHeadCset
    if (FAILED(g_pInternat->HrOpenCharset(pCharset->cpiInternet, CHARSET_HEADER, &pDefHeadCset)))
        pDefHeadCset = pCharset;

    // Set Globals
    CIntlGlobals::SetDefBodyCset(pCharset);
    CIntlGlobals::SetDefHeadCset(pDefHeadCset);

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetDefaultCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetDefaultCharset(LPHCHARSET phCharset)
{
    // Invalid Arg
    if (NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // NOT SET YET
    if (NULL == CIntlGlobals::GetDefBodyCset())
        return TrapError(E_FAIL);

    // Return g_hDefBodyCset
    *phCharset = CIntlGlobals::GetDefBodyCset()->hCharset;
   
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CMimeInternational::FindCharset
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::FindCharset(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCharset;

    // Invalid Arg
    if (NULL == pszCharset || NULL == phCharset)
        return TrapError(E_INVALIDARG);

    // Init
    *phCharset = NULL;

    // Find CsetInfo
    CHECKHR(hr = HrOpenCharset(pszCharset, &pCharset));

    // Return Charset Handles
    *phCharset = pCharset->hCharset;

exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCharsetInfo
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo)
{
    // Invalid Arg
    if (NULL == hCharset || NULL == pCsetInfo)
        return TrapError(E_INVALIDARG);

    // Bad Handle
    if (HCSETVALID(hCharset) == FALSE)
        return TrapError(MIME_E_INVALID_HANDLE);

    // Copy the data
    CopyMemory(pCsetInfo, PCsetFromHCset(hCharset), sizeof(INETCSETINFO));

    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CMimeInternational::GetCodePageInfo
// -------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::GetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePage)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCODEPAGEINFO  pInfo;

    // Invalid Arg
    if (NULL == pCodePage)
        return TrapError(E_INVALIDARG);

    // Default the code page to CP_ACP if 0...
    if (CP_ACP == cpiCodePage)
        cpiCodePage = GetACP();

    // Get Language Info
    CHECKHR(hr = HrFindCodePage(cpiCodePage, &pInfo));

    // Copy the data
    CopyMemory(pCodePage, pInfo, sizeof(CODEPAGEINFO));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::CanConvertCodePages
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::CanConvertCodePages(CODEPAGEID cpiSource, CODEPAGEID cpiDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Can Encode
    if (S_OK != IsConvertINetStringAvailable(cpiSource, cpiDest))
    {
        hr = S_FALSE;
        goto exit;
    }

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    m_dwConvState = 0 ;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::ConvertBuffer
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::ConvertBuffer(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPBLOB pIn, LPBLOB pOut, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cbOut;
    INT             cbIn;

    // Invalid Arg
    if (NULL == pIn || NULL == pIn->pBlobData || NULL == pOut)
        return TrapError(E_INVALIDARG);

    // Init Out
    pOut->pBlobData = NULL;
    pOut->cbSize = 0;
    cbIn = pIn->cbSize;

    // Raid-63765: INETCOMM needs to call MLANG even if Src == Dst for charset set conversion
#if 0
    if (cpiSource == cpiDest)
    {
        // Allocated
        CHECKALLOC(pOut->pBlobData = (LPBYTE)g_pMalloc->Alloc(pIn->cbSize));

        // Copy Memory
        CopyMemory(pOut->pBlobData, pIn->pBlobData, pIn->cbSize);

        // Set Size
        pOut->cbSize = pIn->cbSize;

        // Set pcbRead
        if (pcbRead)
            *pcbRead = pIn->cbSize;

        // Done
        goto exit;
    }
#endif

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    // Check the size of the buffer
    ConvertINetString(&m_dwConvState, cpiSource, cpiDest, (LPCSTR)pIn->pBlobData, &cbIn, NULL, &cbOut);

    // If something to convert...
    if (0 == cbOut)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Allocate the buffer
    CHECKHR(hr = HrAlloc((LPVOID *)&pOut->pBlobData, max(cbIn, cbOut) + 1));

    // BUGS - temporary solution for MLANG new API - m_dwConvState
    // Do the actual convertion
    hr = ConvertINetString(&m_dwConvState, cpiSource, cpiDest, (LPCSTR)pIn->pBlobData, &cbIn, (LPSTR)pOut->pBlobData, (LPINT)&cbOut);

    if ( hr == S_FALSE )    // propagate the charset conflict return value
        hr = MIME_S_CHARSET_CONFLICT ; 

    // Set Out Size
    if (pcbRead)
        *pcbRead = cbIn;

    // Set Out Size
    pOut->cbSize = cbOut;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::ConvertString
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::ConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPPROPVARIANT pIn, LPPROPVARIANT pOut)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pIn || NULL == pOut)
        return TrapError(E_INVALIDARG);

    // VT_LPSTR
    if (VT_LPSTR == pIn->vt)
    {
        // Setup Source
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pIn->pszVal;
        rSource.rStringA.cchVal = lstrlen(pIn->pszVal);
    }

    // VT_LPWSTR
    else if (VT_LPWSTR == pIn->vt)
    {
        // Setup Source
        rSource.type = MVT_STRINGW;
        rSource.rStringW.pszVal = pIn->pwszVal;
        rSource.rStringW.cchVal = lstrlenW(pIn->pwszVal);
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // VT_LPSTR
    if (VT_LPSTR == pOut->vt)
        rDest.type = MVT_STRINGA;

    // VT_LPWSTR
    else if (VT_LPWSTR == pOut->vt)
        rDest.type = MVT_STRINGW;

    // CP_UNICODE
    else if (CP_UNICODE == cpiDest)
    {
        pOut->vt = VT_LPWSTR;
        rDest.type = MVT_STRINGW;
    }

    // Multibyte
    else
    {
        pOut->vt = VT_LPSTR;
        rDest.type = MVT_STRINGA;
    }

    // HrConvertString
    hr = HrConvertString(cpiSource, cpiDest, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // VT_LPSTR
    if (VT_LPSTR == pOut->vt)
    {
        // Set Dest
        Assert(ISSTRINGA(&rDest));
        pOut->pszVal = rDest.rStringA.pszVal;
    }

    // VT_LPWSTR
    else
    {
        // Set Dest
        Assert(ISSTRINGW(&rDest));
        pOut->pwszVal = rDest.rStringW.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrValidateCodepages
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrValidateCodepages(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest,
    LPBYTE *ppbSource, ULONG *pcbSource, CODEPAGEID *pcpiSource, CODEPAGEID *pcpiDest)
{
    // Locals
    HRESULT     hr=S_OK;
    CODEPAGEID  cpiSource=(*pcpiSource);
    CODEPAGEID  cpiDest=(*pcpiDest);
    LPBYTE      pbSource;
    ULONG       cbSource;

    // Invalid ARg
    Assert(pcpiSource && pcpiDest);

    // MVT_STRINGA
    if (MVT_STRINGA == pSource->type)
    {
        // E_INVALIDARG
        if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // cpiSource should not be unicode
        cpiSource = (CP_UNICODE == cpiSource) ? GetACP() : cpiSource;

        // Init Out
        cbSource = pSource->rStringA.cchVal;

        // Set Source
        pbSource = (LPBYTE)pSource->rStringA.pszVal;
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pSource->type)
    {
        // E_INVALIDARG
        if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // cpiSource should be Unicode
        cpiSource = CP_UNICODE;

        // Init Out
        cbSource = (pSource->rStringW.cchVal * sizeof(WCHAR));

        // Set Source
        pbSource = (LPBYTE)pSource->rStringW.pszVal;
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // cpiDest shoudl not be unicode
        cpiDest = (CP_UNICODE == cpiDest) ? GetACP() : ((CP_JAUTODETECT == cpiDest) ? 932 : cpiDest);
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // Destination is Unicode
        cpiDest = CP_UNICODE;
    }

    // E_INVALIDARG
    else
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Set Return Values
    if (pcpiSource)
        *pcpiSource = cpiSource;
    if (pcpiDest)
        *pcpiDest = cpiDest;
    if (ppbSource)
        *ppbSource = pbSource;
    if (pcbSource)
        *pcbSource = cbSource;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrConvertString
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrConvertString(CODEPAGEID cpiSource, CODEPAGEID cpiDest, 
        LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cbNeeded=0;
    INT             cbDest;
    INT             cbSource;
    LPBYTE          pbSource;
    LPBYTE          pbDest=NULL;

    // Invalid Arg
    if (NULL == pSource || NULL == pDest)
        return TrapError(E_INVALIDARG);

    // Adjust the Codepages
    CHECKHR(hr = HrValidateCodepages(pSource, pDest, &pbSource, (ULONG *)&cbSource, &cpiSource, &cpiDest));

    // Raid-63765: INETCOMM needs to call MLANG even if Src == Dst for charset set conversion
#if 0
    if (cpiSource == cpiDest)
    {
        // Copy the variant
        CHECKHR(hr = HrMimeVariantCopy(0, pSource, pDest));

        // Done
        goto exit;
    }
#endif

    // Check the size of the buffer
    if (FAILED(ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pbSource, &cbSource, NULL, &cbNeeded)) || 
        (0 == cbNeeded && cbSource > 0))
    {
        hr = E_FAIL;
        goto exit;
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // Allocate the buffer
        CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(cbNeeded + sizeof(CHAR)));

        // Set Dest
        pbDest = (LPBYTE)pDest->rStringA.pszVal;
    }

    // Allocate unicode
    else 
    {
        // Allocate the buffer
        CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cbNeeded + sizeof(WCHAR)));

        // Set Dest
        pbDest = (LPBYTE)pDest->rStringW.pszVal;
    }

    // Set cbOut
    cbDest = cbNeeded;

    // Do the actual convertion
    if (FAILED(ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pbSource, &cbSource, (LPSTR)pbDest, &cbDest)))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Better not have grown
    Assert(cbDest <= cbNeeded);

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // Save Size
        pDest->rStringA.cchVal = cbDest;

        // Pound in a Null
        pDest->rStringA.pszVal[pDest->rStringA.cchVal] = '\0';

        // Validate the String
        Assert(ISSTRINGA(pDest));
    }

    // MVT_STRINGW
    else
    {
        // Save Size
        pDest->rStringW.cchVal = (cbDest / 2);

        // Pound in a Null
        pDest->rStringW.pszVal[pDest->rStringW.cchVal] = L'\0';

        // Validate the String
        Assert(ISSTRINGW(pDest));
    }

    // Success
    pbDest = NULL;

exit:
    // Cleanup
    SafeMemFree(pbDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrEncodeHeader
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrEncodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, 
    LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszNarrow=NULL;
    LPSTR           pszRfc1522=NULL;
    BOOL            fRfc1522Used=FALSE;
    BOOL            fRfc1522Tried=FALSE;
    MIMEVARIANT     rRedirected;

    // Invalid Arg
    Assert(pSource && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type));
    Assert(pDest && MVT_STRINGA == pDest->type);

    // ZeroInit
    ZeroMemory(&rRedirected, sizeof(MIMEVARIANT));

    // Default hCharset
    if (NULL == pCharset)
        pCharset = CIntlGlobals::GetDefHeadCset();

    // No Charset..
    if (NULL == pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Init
    if (pRfc1522Info)
        pRfc1522Info->fRfc1522Used = FALSE;

    // Raid-62535: MimeOle always 1521 encodes headers when header value is Unicode
    // If source is unicode and were not using a UTF character set to encode with, then convert to multibyte
    if (MVT_STRINGW == pSource->type && CP_UNICODE != pCharset->cpiWindows)
    {
        // Setup MimeVariant
        rRedirected.type = MVT_STRINGA;

        // Convert to pCharset->cpiWindows
        CHECKHR(hr = HrWideCharToMultiByte(pCharset->cpiWindows, &pSource->rStringW, &rRedirected.rStringA));

        // Reset pSource
        pSource = &rRedirected;
    }

    // Decode
    if ((65000 == pCharset->cpiInternet || 65001 == pCharset->cpiInternet) ||
        (NULL == pRfc1522Info || ((FALSE == pRfc1522Info->fAllow8bit) && (TRUE == pRfc1522Info->fRfc1522Allowed))))
    {
        // Locals
        CODEPAGEID cpiSource=pCharset->cpiWindows;
        CODEPAGEID cpiDest=pCharset->cpiInternet;

        // Adjust the Codepages
        CHECKHR(hr = HrValidateCodepages(pSource, pDest, NULL, NULL, &cpiSource, &cpiDest));

        // We Tried rfc1522
        fRfc1522Tried = TRUE;

        // 1522 Encode this dude
        if (SUCCEEDED(HrRfc1522Encode(pSource, pDest, cpiSource, cpiDest, pCharset->szName, &pszRfc1522)))
        {
            // We used Rfc1522
            fRfc1522Used = TRUE;

            // Return Information
            if (pRfc1522Info)
            {
                pRfc1522Info->fRfc1522Used = TRUE;
                pRfc1522Info->hRfc1522Cset = pCharset->hCharset;
            }

            // Setup rStringA
            pDest->rStringA.pszVal = pszRfc1522;
            pDest->rStringA.cchVal = lstrlen(pszRfc1522);
            pszRfc1522 = NULL;
        }
    }

    // If we didn't use RFC 1522, then do a convert string
    if (FALSE == fRfc1522Used)
    {
        // If UTF-7 or UTF-8 and source is ANSI with no 8bit, just dup it
        if (65000 == pCharset->cpiInternet || 65001 == pCharset->cpiInternet)
        {
            // Source is ansi
            if (MVT_STRINGA == pSource->type)
            {
                // Locals
                ULONG c;
                
                // No 8bit
                if (FALSE == FContainsExtended(&pSource->rStringA, &c))
                {
                    // Convert
                    hr = HrConvertString(pCharset->cpiWindows, pCharset->cpiWindows, pSource, pDest);

                    // Were Done
                    goto exit;
                }

                // We must not have tried 1522, because thats what we should have done
                Assert(fRfc1522Tried == FALSE);
            }
        }

        // Do the charset conversion
        hr = HrConvertString(pCharset->cpiWindows, pCharset->cpiInternet, pSource, pDest);
        if (FAILED(hr))
            goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszRfc1522);
    MimeVariantFree(&rRedirected);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrDecodeHeader
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrDecodeHeader(LPINETCSETINFO pCharset, LPRFC1522INFO pRfc1522Info, 
    LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pRfc1522Charset=NULL;
    PROPSTRINGA     rTempA;
    LPSTR           pszRfc1522=NULL;
    LPSTR           pszNarrow=NULL;
    MIMEVARIANT     rSource;
    CHAR            szRfc1522Cset[CCHMAX_CSET_NAME];

    // Invalid Arg
    Assert(pSource && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type));
    Assert(pDest && (MVT_STRINGA == pDest->type || MVT_STRINGW == pDest->type));

    // Copy Source
    CopyMemory(&rSource, pSource, sizeof(MIMEVARIANT));

    // MVT_STRINGW
    if (MVT_STRINGW == pSource->type)
    {
        // Better be a valid string
        Assert(ISVALIDSTRINGW(&pSource->rStringW));

        // Conversion
        CHECKHR(hr = HrWideCharToMultiByte(CP_ACP, &pSource->rStringW, &rTempA));
        
        // Free This
        pszNarrow = rTempA.pszVal;

        // Update rSource
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = rTempA.pszVal;
        rSource.rStringA.cchVal = rTempA.cchVal;
    }

    // Decode
    if (NULL == pRfc1522Info || TRUE == pRfc1522Info->fRfc1522Allowed)
    {
        // Perform rfc1522 decode...
        if (SUCCEEDED(MimeOleRfc1522Decode(rSource.rStringA.pszVal, szRfc1522Cset, ARRAYSIZE(szRfc1522Cset), &pszRfc1522)))
        {
            // It was encoded...
            if (pRfc1522Info)
                pRfc1522Info->fRfc1522Used = TRUE;

            // Look up the charset
            if (SUCCEEDED(HrOpenCharset(szRfc1522Cset, &pRfc1522Charset)) && pRfc1522Info)
            {
                // Return in the Info Struct
                pRfc1522Info->hRfc1522Cset = pRfc1522Charset->hCharset;
            }

            // Reset Source
            rSource.rStringA.pszVal = pszRfc1522;
            rSource.rStringA.cchVal = lstrlen(pszRfc1522);

            // No pCharset
            if (NULL == pCharset)
                pCharset = pRfc1522Charset;
        }

        // No Rfc1522
        else if (pRfc1522Info)
        {
            pRfc1522Info->fRfc1522Used = FALSE;
            pRfc1522Info->hRfc1522Cset = NULL;
        }
    }

    // Charset is Still Null, use Default
    if (NULL == pCharset)
        pCharset = CIntlGlobals::GetDefHeadCset();

    // No Charset..
    if (NULL == pCharset)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Convert the String
    hr = HrConvertString(pCharset->cpiInternet, pCharset->cpiWindows, &rSource, pDest);
    if (FAILED(hr))
    {
        // If it was rfc1522 decoded, then return it and a warning
        if (pszRfc1522)
        {
            // pszRfc1522 should be in rSource
            Assert(rSource.rStringA.pszVal == pszRfc1522);

            // Return MVT_STRINGA
            if (MVT_STRINGA == pDest->type)
            {
                pDest->rStringA.pszVal = rSource.rStringA.pszVal;
                pDest->rStringA.cchVal = rSource.rStringA.cchVal;
                pszRfc1522 = NULL;
            }

            // MVT_STRINGW
            else
            {
                CHECKHR(hr = HrMultiByteToWideChar(CP_ACP, &rSource.rStringA, &pDest->rStringW));
                pszRfc1522 = NULL;
            }

            // This is not a failure, but just a warning
            hr = MIME_S_NO_CHARSET_CONVERT;
        }

        // Done
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszNarrow);
    SafeMemFree(pszRfc1522);

    // Done
    return hr;
}



//---------------------------------------------------------------------------------
// Function: MLANG_ConvertInetReset
//
// Purpose:
//   This function is a wrapper function for MLANG.DLL's ConvertInetReset.
//
// Returns:
//   Same as for MLANG.DLL's ConvertInetReset.
//---------------------------------------------------------------------------------
HRESULT CMimeInternational::MLANG_ConvertInetReset(void)
{
    HRESULT hrResult;

    // a stub for now
    return S_OK;

} // MLANG_ConvertInetReset



//---------------------------------------------------------------------------------
// Function: MLANG_ConvertInetString
//
// Purpose:
//   This function is a wrapper function which passes its arguments through to
// MLANG's ConvertInetString.
//
// Arguments:
//   Same as for MLANG.DLL's ConvertInetString.
//
// Returns:
//   Same as for MLANG.DLL's ConvertInetString.
//---------------------------------------------------------------------------------
HRESULT CMimeInternational::MLANG_ConvertInetString(CODEPAGEID cpiSource,
                                                    CODEPAGEID cpiDest,
                                                    LPCSTR pSourceStr,
                                                    LPINT pnSizeOfSourceStr,
                                                    LPSTR pDestinationStr,
                                                    LPINT pnSizeOfDestBuffer)
{
    HRESULT hrResult;

    // Codify Assumptions
    Assert(sizeof(UCHAR) == sizeof(char));

    // Pass the arguments through
    return ConvertINetString(NULL, cpiSource, cpiDest, (LPCSTR)pSourceStr, pnSizeOfSourceStr, (LPSTR) pDestinationStr, pnSizeOfDestBuffer);
} // MLANG_ConvertInetString



// --------------------------------------------------------------------------------
// CMimeInternational::DecodeHeader ANSI -> (ANSI or UNICODE)
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::DecodeHeader(HCHARSET hCharset, LPCSTR pszData, 
    LPPROPVARIANT pDecoded, LPRFC1522INFO pRfc1522Info)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pszData || NULL == pDecoded || (VT_LPSTR != pDecoded->vt && VT_LPWSTR != pDecoded->vt))
        return TrapError(E_INVALIDARG);

    // Setup Source
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = (LPSTR)pszData;
    rSource.rStringA.cchVal = lstrlen(pszData);

    // Setup Destination
    rDest.type = (VT_LPSTR == pDecoded->vt) ? MVT_STRINGA : MVT_STRINGW;

    // Valid Charset
    if (hCharset && HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // HrDecodeHeader
    hr = HrDecodeHeader((NULL == hCharset) ? NULL : PCsetFromHCset(hCharset), pRfc1522Info, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // Put rDest into pDecoded
    if (MVT_STRINGA == rDest.type)
        pDecoded->pszVal = rDest.rStringA.pszVal;
    else
        pDecoded->pwszVal = rDest.rStringW.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::EncodeHeader
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::EncodeHeader(HCHARSET hCharset, LPPROPVARIANT pData, 
        LPSTR *ppszEncoded, LPRFC1522INFO pRfc1522Info)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    MIMEVARIANT     rDest;

    // Invalid Arg
    if (NULL == pData || NULL == ppszEncoded || (VT_LPSTR != pData->vt && VT_LPWSTR != pData->vt))
        return TrapError(E_INVALIDARG);

    // Init
    *ppszEncoded = NULL;

    // VT_LPSTR
    if (VT_LPSTR == pData->vt)
    {
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = pData->pszVal;
        rSource.rStringA.cchVal = lstrlen(pData->pszVal);
    }

    // VT_LPWSTR
    else
    {
        rSource.type = MVT_STRINGW;
        rSource.rStringW.pszVal = pData->pwszVal;
        rSource.rStringW.cchVal = lstrlenW(pData->pwszVal);
    }

    // Setup Destination
    rDest.type = MVT_STRINGA;

    // Valid Charset
    if (hCharset && HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // HrDecodeHeader
    hr = HrEncodeHeader((NULL == hCharset) ? NULL : PCsetFromHCset(hCharset), pRfc1522Info, &rSource, &rDest);
    if (FAILED(hr))
        goto exit;

    // Put rDest into pDecoded
    *ppszEncoded = rDest.rStringA.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::Rfc1522Decode
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::Rfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded)
{
    return MimeOleRfc1522Decode(pszValue, pszCharset, cchmax, ppszDecoded);
}

// --------------------------------------------------------------------------------
// CMimeInternational::Rfc1522Encode
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeInternational::Rfc1522Encode(LPCSTR pszValue, HCHARSET hCharset, LPSTR *ppszEncoded)
{
    return MimeOleRfc1522Encode(pszValue, hCharset, ppszEncoded);
}

// --------------------------------------------------------------------------------
// CMimeInternational::FIsValidHandle
// --------------------------------------------------------------------------------
BOOL CMimeInternational::FIsValidHandle(HCHARSET hCharset)
{
    m_lock.ShareLock();
    BOOL f = HCSETVALID(hCharset);
    m_lock.ShareUnlock();
    return f;
}

// --------------------------------------------------------------------------------
// CMimeInternational::IsDBCSCharset
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::IsDBCSCharset(HCHARSET hCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPINETCSETINFO  pCsetInfo;

    // Invlaid Handle
    if (HCSETVALID(hCharset) == FALSE)
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // Get the charset info
    pCsetInfo = PCsetFromHCset(hCharset);

    // Special Cases
    if (pCsetInfo->cpiWindows == CP_JAUTODETECT  ||
        pCsetInfo->cpiWindows == CP_KAUTODETECT  ||
        pCsetInfo->cpiWindows == CP_ISO2022JPESC ||
        pCsetInfo->cpiWindows == CP_ISO2022JPSIO)
    {
        hr = S_OK;
        goto exit;
    }

    // Is Windows Code Page DBCS ?
    hr = (IsDBCSCodePage(pCsetInfo->cpiWindows) == TRUE) ? S_OK : S_FALSE;
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrEncodeProperty
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrEncodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    RFC1522INFO     rRfc1522Info;
    MIMEVARIANT     rSource;

    // Invalid Arg
    Assert(pConvert && pConvert->pSymbol && pConvert->pCharset && pConvert->pOptions && pSource && pDest);
    Assert(ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET));
    Assert(pConvert->ietSource == IET_ENCODED || pConvert->ietSource == IET_DECODED);

    // Init
    ZeroMemory(&rSource, sizeof(MIMEVARIANT));

    // Setup Rfc1522 Info
    ZeroMemory(&rRfc1522Info, sizeof(RFC1522INFO));
    rRfc1522Info.fRfc1522Allowed = ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_RFC1522);
    rRfc1522Info.fAllow8bit = (SAVE_RFC1521 == pConvert->pOptions->savetype) ? pConvert->pOptions->fAllow8bit : TRUE;

    // If Property is Encoded, decode it first
    if (IET_ENCODED == pConvert->ietSource)
    {
        // Set rSource.type
        rSource.type = pDest->type;

        // Decode It
        hr = HrDecodeHeader(pConvert->pCharset, &rRfc1522Info, pSource, &rSource);
        if (FAILED(hr))
            goto exit;
    }

    // Otherwise, use pSource as rSource
    else
    {
        // Setup Source
        CopyMemory(&rSource, pSource, sizeof(MIMEVARIANT));
        rSource.fCopy = TRUE;
    }

    // HrEncodeHeader
    hr = HrEncodeHeader(pConvert->pCharset, &rRfc1522Info, &rSource, pDest);
    if (FAILED(hr))
        goto exit;

    // Set PRSTATE_RFC1511
    if (rRfc1522Info.fRfc1522Used)
        FLAGSET(pConvert->dwState, PRSTATE_RFC1522);

exit:
    // Cleanup
    MimeVariantFree(&rSource);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrDecodeProperty
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrDecodeProperty(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest)
{
    // Locals
    RFC1522INFO     rRfc1522Info;

    // Invalid Arg
    Assert(pConvert && pConvert->pSymbol && pConvert->pCharset && pConvert->pOptions && pSource && pDest);
    Assert(ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET) && pConvert->ietSource == IET_ENCODED);

    // Setup Rfc1522 Info
    ZeroMemory(&rRfc1522Info, sizeof(RFC1522INFO));
    rRfc1522Info.fRfc1522Allowed = ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_RFC1522);
    rRfc1522Info.fAllow8bit = (SAVE_RFC1521 == pConvert->pOptions->savetype) ? pConvert->pOptions->fAllow8bit : TRUE;

    // HrDecodeHeader
    return HrDecodeHeader(pConvert->pCharset, &rRfc1522Info, pSource, pDest);
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrWideCharToMultiByte
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrWideCharToMultiByte(CODEPAGEID cpiCodePage, LPCPROPSTRINGW pStringW, 
    LPPROPSTRINGA pStringA)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(ISVALIDSTRINGW(pStringW) && pStringA);

    // Adjust cpiCodePage
    if (CP_UNICODE == cpiCodePage)
        cpiCodePage = CP_ACP;

    // Init
    pStringA->pszVal = NULL;
    pStringA->cchVal = 0;

    // Determine how much space is needed for translated widechar
    pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, NULL, 0, NULL, NULL);
    if (pStringA->cchVal == 0 && pStringW->cchVal != 0)
    {
        DOUTL(4, "WideCharToMultiByte Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());

        // WideCharToMultiByte failed for some other reason than cpiCodePage being a bad codepage
        if (TRUE == IsValidCodePage(cpiCodePage))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Reset cpiCodePage to a valid codepage
        cpiCodePage = CP_ACP;

        // Use the system acp
        pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, NULL, 0, NULL, NULL);
        if (pStringA->cchVal == 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Allocate It
    CHECKALLOC(pStringA->pszVal = (LPSTR)g_pMalloc->Alloc((pStringA->cchVal + 1)));

    // Do the actual translation
    pStringA->cchVal = ::WideCharToMultiByte(cpiCodePage, 0, pStringW->pszVal, pStringW->cchVal, pStringA->pszVal, pStringA->cchVal + 1, NULL, NULL);
    if (pStringA->cchVal == 0 && pStringW->cchVal != 0)
    {
        DOUTL(4, "WideCharToMultiByte Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Insert the Null
    pStringA->pszVal[pStringA->cchVal] = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeInternational::HrMultiByteToWideChar
// --------------------------------------------------------------------------------
HRESULT CMimeInternational::HrMultiByteToWideChar(CODEPAGEID cpiCodePage, LPCPROPSTRINGA pStringA, 
    LPPROPSTRINGW pStringW)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    // Bad codepage is okay and will be dealt with below
    Assert(ISVALIDSTRINGA(pStringA) && pStringW);

    // Adjust cpiCodePage
    if (CP_UNICODE == cpiCodePage)
        cpiCodePage = CP_ACP;

    // Init
    pStringW->pszVal = NULL;
    pStringW->cchVal = 0;

    // Determine how much space is needed for translated widechar
    pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, NULL, 0);
    if (pStringW->cchVal == 0 && pStringA->cchVal != 0)
    {
        DOUTL(4, "MultiByteToWideChar Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());

        // MultiByteToWideChar failed for some other reason than cpiCodePage being a bad codepage
        if (TRUE == IsValidCodePage(cpiCodePage))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Reset cpiCodePage to a valid codepage
        cpiCodePage = CP_ACP;

        // Use the system acp
        pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, NULL, 0);
        if (pStringW->cchVal == 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

    }

    // Allocate It
    CHECKALLOC(pStringW->pszVal = (LPWSTR)g_pMalloc->Alloc((pStringW->cchVal + 1) * sizeof(WCHAR)));

    // Do the actual translation
    pStringW->cchVal = ::MultiByteToWideChar(cpiCodePage, MB_PRECOMPOSED, pStringA->pszVal, pStringA->cchVal, pStringW->pszVal, pStringW->cchVal + 1);
    if (pStringW->cchVal == 0 && pStringA->cchVal != 0)
    {
        DOUTL(4, "MultiByteToWideChar Failed - CodePageID = %d, GetLastError = %d\n", cpiCodePage, GetLastError());
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Insert the Null
    pStringW->pszVal[pStringW->cchVal] = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------

void CIntlGlobals::Init()
{

    mg_bInit = FALSE;
    InitializeCriticalSection(&mg_cs);
    mg_pDefBodyCset = NULL;
    mg_pDefHeadCset = NULL;
}

void CIntlGlobals::Term()
{

    DeleteCriticalSection(&mg_cs);
}

void CIntlGlobals::DoInit()
{

    if (!mg_bInit)
    {
        EnterCriticalSection(&mg_cs);
        if (!mg_bInit)
        {
            // Locals
            CODEPAGEID  cpiSystem;

            // Get the system codepage
            cpiSystem = GetACP();

            // Get the default body charset
            if (FAILED(g_pInternat->HrOpenCharset(cpiSystem, CHARSET_BODY, &mg_pDefBodyCset)))
                mg_pDefBodyCset = &mg_rDefaultCharset;

            // Get the Default Header Charset
            if (FAILED(g_pInternat->HrOpenCharset(cpiSystem, CHARSET_HEADER, &mg_pDefHeadCset)))
                mg_pDefHeadCset = mg_pDefBodyCset;

            mg_bInit = TRUE;
        }
        LeaveCriticalSection(&mg_cs);
    }
}

LPINETCSETINFO CIntlGlobals::GetDefBodyCset()
{

    DoInit();
    Assert(mg_pDefBodyCset);
    return (mg_pDefBodyCset);
}

LPINETCSETINFO CIntlGlobals::GetDefHeadCset()
{

    DoInit();
    Assert(mg_pDefHeadCset);
    return (mg_pDefHeadCset);
}

LPINETCSETINFO CIntlGlobals::GetDefaultCharset()
{

    DoInit();
    return (&mg_rDefaultCharset);
}

void CIntlGlobals::SetDefBodyCset(LPINETCSETINFO pCharset)
{

    DoInit();
    mg_pDefBodyCset = pCharset;
}

void CIntlGlobals::SetDefHeadCset(LPINETCSETINFO pCharset)
{

    DoInit();
    mg_pDefHeadCset = pCharset;
}

BOOL CIntlGlobals::mg_bInit = FALSE;
LPINETCSETINFO CIntlGlobals::mg_pDefBodyCset = NULL;
LPINETCSETINFO CIntlGlobals::mg_pDefHeadCset = NULL;
CRITICAL_SECTION CIntlGlobals::mg_cs;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mimeapi.cpp ===
// --------------------------------------------------------------------------------
// Mimeapi.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "olealloc.h"
#include "partial.h"
#include "smime.h"
#include "vstream.h"
#include "internat.h"
#include "stackstr.h"
#include "ixputil.h"
#include "webdocs.h"
#include "containx.h"
#include "inetstm.h"
#include "mhtmlurl.h"
#include "booktree.h"
#include "bookbody.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include "mlang.h"
#include "strconst.h"
#include "symcache.h"
#include "mimeapi.h"
#include "hash.h"
#include "shared.h"
#include "demand.h"

// ------------------------------------------------------------------------------------------
// Special Partial Headers
// ------------------------------------------------------------------------------------------
static LPCSTR g_rgszPartialPids[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
        PIDTOSTR(PID_HDR_CNTXFER),
        PIDTOSTR(PID_HDR_CNTDESC),
        PIDTOSTR(PID_HDR_MESSAGEID),
        PIDTOSTR(PID_HDR_MIMEVER),
        PIDTOSTR(PID_HDR_CNTID),
        PIDTOSTR(PID_HDR_CNTDISP),
        STR_HDR_ENCRYPTED
};

// --------------------------------------------------------------------------------
// MimeGetAddressFormatW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeGetAddressFormatW(REFIID riid, LPVOID pvObject, DWORD dwAdrType,
    ADDRESSFORMAT format, LPWSTR *ppszFormat)
{
    // Locals
    HRESULT                 hr=S_OK;
    CMimePropertyContainer *pContainer=NULL;

    // Trace
    TraceCall("MimeGetAddressFormatW");

    // Invalid Args
    if (NULL == pvObject)
        return(TraceResult(E_INVALIDARG));

    // Is a messageW object ?
    if (IID_IMimeMessageW == riid)
    {
        // Get It
        CHECKHR(hr = ((IMimeMessageW *)pvObject)->GetAddressFormatW(dwAdrType, format, ppszFormat));
    }

    // Is a message object ?
    else if (IID_IMimeMessage == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeMessage *)pvObject)->BindToObject(HBODY_ROOT, IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimePropertySet
    else if (IID_IMimePropertySet == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimePropertySet *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimeAddressTable
    else if (IID_IMimeAddressTable == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeAddressTable *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // IID_IMimeHeaderTable
    else if (IID_IMimeHeaderTable == riid)
    {
        // Query for IID_CMimePropertyContainer
        CHECKHR(hr = ((IMimeHeaderTable *)pvObject)->QueryInterface(IID_CMimePropertyContainer, (LPVOID *)&pContainer));

        // Get the format
        CHECKHR(hr = pContainer->GetFormatW(dwAdrType, format, ppszFormat));
    }

    // Final
    else
    {
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pContainer);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCP
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetCompatMode(DWORD dwMode)
{
    // Add in the bit
    FLAGSET(g_dwCompatMode, dwMode);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCP
// --------------------------------------------------------------------------------
CODEPAGEID MimeOleGetWindowsCP(HCHARSET hCharset)
{
    // Locals
    INETCSETINFO rCharset;

    // Invalid Arg
    if (NULL == hCharset)
        return CP_ACP;

    // Loopup charset
    Assert(g_pInternat);
    if (FAILED(g_pInternat->GetCharsetInfo(hCharset, &rCharset)))
        return CP_ACP;

    // Return
    return MimeOleGetWindowsCPEx(&rCharset);

}

// --------------------------------------------------------------------------------
// MimeOleStripHeaders
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleStripHeaders(IMimeMessage *pMessage, HBODY hBody, LPCSTR pszNameDelete,
    LPCSTR pszHeaderAdd, IStream **ppStream)
{
    // Locals
    HRESULT             hr=S_OK;
    IMimeHeaderTable   *pHdrTable=NULL;
    LPSTREAM            pStmSource=NULL;
    LPSTREAM            pStmDest=NULL;
    HHEADERROW          hRow;
    HEADERROWINFO       Info;
    DWORD               cbLastRead=0;
    FINDHEADER          Find={0};
    ULARGE_INTEGER      uliCopy;

    // Trace
    TraceCall("MimeOleStripHeaders");

    // Invalid Arg
    if (NULL == pMessage || NULL == hBody || NULL == pszNameDelete || NULL == ppStream)
        return TraceResult(E_INVALIDARG);

    // Initialize
    *ppStream = NULL;

    // Get the message source, no commit
    IF_FAILEXIT(hr = pMessage->GetMessageSource(&pStmSource, 0));

    // Get the Header Table for hBody
    IF_FAILEXIT(hr = pMessage->BindToObject(hBody, IID_IMimeHeaderTable, (LPVOID *)&pHdrTable));

    // Initialize the Find
    Find.pszHeader = pszNameDelete;

    // Find this row
    IF_FAILEXIT(hr = pHdrTable->FindFirstRow(&Find, &hRow));

    // Create a stream
    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pStmDest));

    // Delete this row
    while(1)
    {
        // Get the row information
        IF_FAILEXIT(hr = pHdrTable->GetRowInfo(hRow, &Info));

        // Setup uliCopy
        uliCopy.QuadPart = Info.cboffStart - cbLastRead;

        // Seek
        IF_FAILEXIT(hr = HrStreamSeekSet(pStmSource, cbLastRead));

        // Write from cbLast to Info.cboffStart
        IF_FAILEXIT(hr = HrCopyStreamCB(pStmSource, pStmDest, uliCopy, NULL, NULL));

        // Set cbLast
        cbLastRead = Info.cboffEnd;

        // Find the next
        hr = pHdrTable->FindNextRow(&Find, &hRow);

        // Failure
        if (FAILED(hr))
        {
            // MIME_E_NOT_FOUND
            if (MIME_E_NOT_FOUND == hr)
            {
                hr = S_OK;
                break;
            }
            else
            {
                TraceResult(hr);
                goto exit;
            }
        }
    }

    // Add on pszHeaderAdd
    if (pszHeaderAdd)
    {
        // Write the Add Header
        IF_FAILEXIT(hr = pStmDest->Write(pszHeaderAdd, lstrlen(pszHeaderAdd), NULL));
    }

    // Write the Rest of pStmSource
    IF_FAILEXIT(hr = HrStreamSeekSet(pStmSource, cbLastRead));

    // Write the Rest
    IF_FAILEXIT(hr = HrCopyStream(pStmSource, pStmDest, NULL));

    // Commit
    IF_FAILEXIT(hr = pStmDest->Commit(STGC_DEFAULT));

    // Rewind It
    IF_FAILEXIT(hr = HrRewindStream(pStmDest));

    // Return pStmDest
    *ppStream = pStmDest;
    (*ppStream)->AddRef();

exit:
    // Cleanup
    SafeRelease(pStmSource);
    SafeRelease(pHdrTable);
    SafeRelease(pStmDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetWindowsCPEx
// --------------------------------------------------------------------------------
CODEPAGEID MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset)
{
    // Invalid Arg
    if (NULL == pCharset)
        return CP_ACP;

    // Check for Auto-Detect
    if (CP_JAUTODETECT == pCharset->cpiWindows)
        return 932;
    else if (CP_ISO2022JPESC == pCharset->cpiWindows)
        return 932;
    else if (CP_ISO2022JPSIO == pCharset->cpiWindows)
        return 932;
    else if (CP_KAUTODETECT == pCharset->cpiWindows)
        return 949;
    else
        return pCharset->cpiWindows;
}

// --------------------------------------------------------------------------------
// MimeOleClearDirtyTree
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleClearDirtyTree(IMimeMessageTree *pITree)
{
    // Locals
    HRESULT          hr=S_OK;
    CMessageTree    *pTree=NULL;

    // Invalid Arg
    if (NULL == pITree)
        return TrapError(E_INVALIDARG);

    // I need a private IID_CMessageTree to do this
    CHECKHR(hr = pITree->QueryInterface(IID_CMessageTree, (LPVOID *)&pTree));

    // ClearDirty
    pTree->ClearDirty();

    // Validate
    Assert(pTree->IsDirty() == S_FALSE);

exit:
    // Cleanup
    SafeRelease(pTree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PszDefaultSubType
// --------------------------------------------------------------------------------
LPCSTR PszDefaultSubType(LPCSTR pszPriType)
{
    if (lstrcmpi(pszPriType, STR_CNT_TEXT) == 0)
        return STR_SUB_PLAIN;
    else if (lstrcmpi(pszPriType, STR_CNT_MULTIPART) == 0)
        return STR_SUB_MIXED;
    else
        return STR_SUB_OCTETSTREAM;
}

// --------------------------------------------------------------------------------
// MimeOleContentTypeFromUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleContentTypeFromUrl(
                                     /* in */        LPCSTR              pszBase,
                                     /* in */        LPCSTR              pszUrl,
                                     /* out */       LPSTR              *ppszCntType)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszFree=NULL;
    LPSTR       pszCombined=NULL;
    LPWSTR      pwszUrl=NULL;
    LPWSTR      pwszCntType=NULL;

    // Invalid Arg
    if (NULL == pszUrl || NULL == ppszCntType)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszCntType = NULL;

    // Combine the URL
    if (pszBase)
    {
        // Allocate Base + URL
        CHECKALLOC(pszFree = (LPSTR)g_pMalloc->Alloc(lstrlen(pszUrl) + lstrlen(pszBase) + 1));

        // Format It
        wsprintf(pszFree, "%s%s", pszBase, pszUrl);

        // Set combined
        pszCombined = pszFree;

        // Convert to Unicode
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszCombined));
    }

    // To Unicode
    else
    {
        // Set combined
        pszCombined = (LPSTR)pszUrl;

        // Convert to Unicode
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszUrl));
    }

    // Get the Mime Content Type from the Url
    CHECKHR(hr = FindMimeFromData(NULL, pwszUrl, NULL, NULL, NULL, 0, &pwszCntType, 0));

    // Convert to ANSI
    CHECKALLOC(*ppszCntType = PszToANSI(CP_ACP, pwszCntType));

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pwszUrl);
    SafeMemFree(pwszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleObjectFromMoniker
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleObjectFromMoniker(
                                    /* in */        BINDF               bindf,
                                    /* in */        IMoniker           *pmkOriginal,
                                    /* in */        IBindCtx           *pBindCtx,
                                    /* in */        REFIID              riid,
                                    /* out */       LPVOID             *ppvObject,
                                    /* out */       IMoniker          **ppmkNew)
{
    Assert(g_pUrlCache);
    return TrapError(g_pUrlCache->ActiveObjectFromMoniker(bindf, pmkOriginal, pBindCtx, riid, ppvObject, ppmkNew));
}

// --------------------------------------------------------------------------------
// MimeOleObjectFromUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleObjectFromUrl(
                                /* in */        LPCSTR              pszUrl,
                                /* in */        BOOL                fCreate,
                                /* in */        REFIID              riid,
                                /* out */       LPVOID             *ppvObject,
                                /* out */       IUnknown          **ppUnkKeepAlive)
{
    Assert(g_pUrlCache);
    return TrapError(g_pUrlCache->ActiveObjectFromUrl(pszUrl, fCreate, riid, ppvObject, ppUnkKeepAlive));
}

// --------------------------------------------------------------------------------
// MimeOleCombineMhtmlUrl
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCombineMhtmlUrl(
                                  /* in */        LPSTR              pszRootUrl,
                                  /* in */        LPSTR              pszBodyUrl,
                                  /* out */       LPSTR             *ppszUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == pszBodyUrl || NULL == ppszUrl)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszUrl = NULL;

    // Allocate memory: pszRootUrl + ! + pszBodyUrl
    CHECKALLOC(*ppszUrl = (LPSTR)g_pMalloc->Alloc(cchPrefix + lstrlen(pszRootUrl) + lstrlen(pszBodyUrl) + 2));

    // Root must start with mhtml://pszRootUrl!pszBodyUrl
    if (StrCmpNI(pszRootUrl, c_szMHTMLColon, cchPrefix) != 0)
        wsprintf(*ppszUrl, "%s%s!%s", c_szMHTMLColon, pszRootUrl, pszBodyUrl);
    else
        wsprintf(*ppszUrl, "%s!%s", pszRootUrl, pszBodyUrl);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSplitMhtmlUrl - Returns E_INVLAIDARG if pszUrl does not start with mhtml:
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseMhtmlUrl(
                                /* in */        LPSTR               pszUrl,
                                /* out */       LPSTR              *ppszRootUrl,
                                /* out */       LPSTR              *ppszBodyUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    CStringParser   cString;
    CHAR            chToken;
    ULONG           cchUrl;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);

    // Invalid Arg
    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    // Init
    if (ppszRootUrl)
        *ppszRootUrl = NULL;
    if (ppszBodyUrl)
        *ppszBodyUrl = NULL;

    // No an mhtml Url ?
    if (StrCmpNI(pszUrl, c_szMHTMLColon, cchPrefix) != 0)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Get the length
    cchUrl = lstrlen(pszUrl);

    // Init the Parser
    cString.Init(pszUrl + cchPrefix, cchUrl - cchPrefix, PSF_NOFRONTWS | PSF_NOTRAILWS);

    // Skip Over any '/'
    cString.ChSkip("/");

    // Parse
    chToken = cString.ChParse("!");
    if (0 == cString.CchValue())
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Client Wants ppszRootUrl
    if (ppszRootUrl)
    {
        // Allocate length for root part
        CHECKALLOC(*ppszRootUrl = (LPSTR)g_pMalloc->Alloc(cString.CchValue() + 1));

        // Copy It
        CopyMemory((LPBYTE)*ppszRootUrl, (LPBYTE)cString.PszValue(), cString.CchValue() + 1);
    }

    // Client Wants ppszBodyUrl
    if (ppszBodyUrl)
    {
        // Parse to the end of the string
        chToken = cString.ChParse(NULL);
        Assert('\0' == chToken);

        // Is there data
        if (cString.CchValue() > 0)
        {
            // Allocate length for root part
            CHECKALLOC(*ppszBodyUrl = (LPSTR)g_pMalloc->Alloc(cString.CchValue() + 1));

            // Copy It
            CopyMemory((LPBYTE)*ppszBodyUrl, (LPBYTE)cString.PszValue(), cString.CchValue() + 1);
        }
    }

exit:
    // Failure
    if (FAILED(hr))
    {
        if (ppszRootUrl)
            SafeMemFree(*ppszRootUrl);
        if (ppszBodyUrl)
            SafeMemFree(*ppszBodyUrl);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCombineURL
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCombineURL(
         /* in */        LPCSTR              pszBase,
         /* in */        ULONG               cchBase,
         /* in */        LPCSTR              pszURL,
         /* in */        ULONG               cchURL,
         /* in */        BOOL                fUnEscape,
         /* out */       LPSTR               *ppszAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszBase=NULL;
    LPWSTR          pwszUrl=NULL;
    LPWSTR          pwszCombined=NULL;
    ULONG           cchCombined;
    ULONG           cchActual;
    WCHAR           wchCombined[255];
    LPSTR           pszT;
    CStringParser   cString;

    // Invalid Arg
    if (NULL == pszBase || '\0' != pszBase[cchBase] || NULL == pszURL || '\0' != pszURL[cchURL] || NULL == ppszAbsolute)
        return TrapError(E_INVALIDARG);

    // INit
    *ppszAbsolute = NULL;

    // Raid-2621: Mail : Can't display images when message is only in HTML and the Content Base is in the headers
    pszT = PszSkipWhiteA((LPSTR)pszBase);
    if (pszT && '\"' == *pszT)
    {
        // Init the String
        cString.Init(pszBase, cchBase, PSF_NOTRAILWS | PSF_NOFRONTWS | PSF_ESCAPED | PSF_DBCS);

        // Remove Quotes
        if ('\"' == cString.ChParse("\"") && '\"' == cString.ChParse("\""))
        {
            // Reset pszBase
            pszBase = cString.PszValue();
            cchBase = cString.CchValue();
        }
    }

    // Convert to Wide
    CHECKALLOC(pwszBase = PszToUnicode(CP_ACP, pszBase));
    CHECKALLOC(pwszUrl =  PszToUnicode(CP_ACP, pszURL));

    // Combine
    if (SUCCEEDED(CoInternetCombineUrl(pwszBase, pwszUrl, 0, wchCombined, ARRAYSIZE(wchCombined) - 1, &cchCombined, 0)))
    {
        // Convert to ANSI
        CHECKALLOC(*ppszAbsolute = PszToANSI(CP_ACP, wchCombined));
    }

    // Otherwise, allocate
    else
    {
        // Allocate
        CHECKALLOC(pwszCombined = PszAllocW(cchCombined));

        // Combine
        CHECKHR(hr = CoInternetCombineUrl(pwszBase, pwszUrl, 0, pwszCombined, cchCombined, &cchActual, 0));

        // Valid?
        Assert(cchCombined == cchActual);

        // Convert to ANSI
        CHECKALLOC(*ppszAbsolute = PszToANSI(CP_ACP, pwszCombined));
    }

    // Unescape
    if (fUnEscape)
    {
        // Do it
        CHECKHR(hr = UrlUnescapeA(*ppszAbsolute, NULL, NULL, URL_UNESCAPE_INPLACE));
    }

exit:
    // Cleanup
    SafeMemFree(pwszBase);
    SafeMemFree(pwszUrl);
    SafeMemFree(pwszCombined);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetSubjectFileName
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetSubjectFileName(IMimePropertySet *pPropertySet, ULONG *pulPart, ULONG *pulTotal,
                                     LPSTR pszFileName, ULONG cchMax)
{
    return E_FAIL;
#if 0
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rSubject;
    PARSESTRINGINFO rParse;
    PARSESTRINGINFO rTemp;
    CHAR            szScratch[255],
        szFileName[MAX_PATH];
    ULONG           i,
        iString;
    BOOL            fValid;

    // Invalid Arg
    if (NULL == pPropertySet || NULL == pszFileName || NULL == pulPart || NULL == pulTotal)
        return TrapError(E_INVALIDARG);

    // Zero the Structure
    ZeroMemory(&rParse, sizeof(PARSESTRINGINFO));

    // Init
    *pulPart = 0;
    *pulTotal = 0;
    *pszFileName = '\0';
    *szFileName = '\0';

    // Init
    rSubject.vt = VT_LPSTR;
    rSubject.pszVal = NULL;

    // Get the subject
    CHECKHR(hr = pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject));

    // Set the Members
    rParse.cpiCodePage = CP_ACP;
    rParse.pszString   = rSubject.pszVal;
    rParse.cchString   = lstrlen(rSubject.pszVal);
    rParse.pszScratch  = szScratch;
    rParse.pszValue    = szScratch;
    rParse.cchValMax   = sizeof(szScratch);
    rParse.dwFlags     = PARSTR_SKIP_FORWARD_WS | PARSTR_STRIP_TRAILING_WS | PARSTR_GROW_VALUE_ALLOWED;

    // Initialize My String Parser
    MimeOleSetParseTokens(&rParse, " ([");

    // Loop for a while
    while(1)
    {
        // Parse up to colon
        CHECKHR(hr = MimeOleParseString(&rParse));

        // Done
        if (rParse.fDone)
            break;

        // Space, just save the last value
        if (' ' == rParse.chToken)
        {
            // Less than MAX_PATH
            if (rParse.cchValue < MAX_PATH)
                lstrcpy(szFileName, rParse.pszValue);
        }

        // Loop Next few characters (001\010)
        else
        {
            // Less than MAX_PATH
            if (rParse.cchValue && rParse.cchValue < MAX_PATH)
                lstrcpy(szFileName, rParse.pszValue);

            // Save the Current State
            iString = rParse.iString;

            // Find the Ending Token
            if ('(' == rParse.chToken)
                MimeOleSetParseTokens(&rParse, ")");
            else
                MimeOleSetParseTokens(&rParse, "]");

            // Parse up to colon
            CHECKHR(hr = MimeOleParseString(&rParse));

            // Done
            if (rParse.fDone)
                break;

            // (000/000) All Numbers in rParse.pszValue are numbers
            for (fValid=TRUE, i=0; i<rParse.cchValue; i++)
            {
                // End of Part Number
                if ('/' == rParse.pszValue[i])
                {
                    rParse.pszValue[i] = '\0';
                    *pulPart = StrToInt(rParse.pszValue);
                    *pulTotal = StrToInt((rParse.pszValue + i + 1));
                }

                // Digit
                else if (IsDigit(rParse.pszValue) == FALSE)
                {
                    fValid = FALSE;
                    break;
                }
            }

            // Valid ?
            if (fValid)
            {
                // Dup It
                lstrcpyn(pszFileName, szFileName, cchMax);

                // Done
                goto exit;
            }

            // Reset Parser
            rParse.iString = iString;

            // Initialize My String Parser
            MimeOleSetParseTokens(&rParse, " ([");
        }
    }

    // Not Found
    hr = MIME_E_NOT_FOUND;

exit:
    // Cleanup
    SafeMemFree(rSubject.pszVal);
    MimeOleFreeParseString(&rParse);

    // Done
    return hr;
#endif
}

// --------------------------------------------------------------------------------
// MimeOleCreateWebDocument
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateWebDocument(
                                    LPCSTR              pszBase,
                                    LPCSTR              pszURL,
                                    IMimeWebDocument  **ppDocument)
{
    // Locals
    HRESULT             hr=S_OK;
    CMimeWebDocument   *pDocument=NULL;

    // Invalid Arg
    if (NULL == pszURL || NULL == ppDocument)
        return TrapError(E_INVALIDARG);

    // Create a Web Document Object
    CHECKALLOC(pDocument = new CMimeWebDocument);

    // Initialize It
    CHECKHR(hr = pDocument->HrInitialize(pszBase, pszURL));

    // Return It
    *ppDocument = (IMimeWebDocument *)pDocument;
    (*ppDocument)->AddRef();

exit:
    // Cleanup
    SafeRelease(pDocument);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleComputeContentBase
// --------------------------------------------------------------------------------
HRESULT MimeOleComputeContentBase(IMimeMessage *pMessage, HBODY hRelated,
    LPSTR *ppszBase, BOOL *pfMultipartBase)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hBase=NULL;

    // Init
    if (pfMultipartBase)
        *pfMultipartBase = FALSE;

    // If no hRelated was passed in, lets try to find one
    if (NULL == hRelated)
    {
        // Find the related section
        if (FAILED(MimeOleGetRelatedSection(pMessage, FALSE, &hRelated, NULL)))
        {
            // Get the root body
            pMessage->GetBody(IBL_ROOT, NULL, &hRelated);
        }
    }

    // Get the text/html body
    if (FAILED(pMessage->GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBase)))
        hBase = hRelated;

    // No Base
    if (NULL == hBase)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Call utility function
    *ppszBase = MimeOleContentBaseFromBody(pMessage, hBase);

    // If that failed and we used the text body
    if (NULL == *ppszBase && hRelated && hBase != hRelated)
        *ppszBase = MimeOleContentBaseFromBody(pMessage, hRelated);

    // Did this come from the multipart related
    if (NULL != *ppszBase && hBase == hRelated && pfMultipartBase)
        *pfMultipartBase = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleContentBaseFromBody
// --------------------------------------------------------------------------------
LPSTR MimeOleContentBaseFromBody(IMimeMessageTree *pTree, HBODY hBody)
{
    // Locals
    PROPVARIANT rVariant;

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = NULL;

    // Get Content-Base first, and then try Content-Location
    if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTBASE), NOFLAGS, &rVariant)))
    {
        // Try Content-Location
        if (FAILED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)))
            rVariant.pszVal = NULL;
    }

    // Return
    return rVariant.pszVal;
}

// --------------------------------------------------------------------------------
// MimeOleGetRelatedSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetRelatedSection(
                                    IMimeMessageTree   *pTree,
                                    boolean             fCreate,
                                    LPHBODY             phRelated,
                                    boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hRoot;
    FINDBODY    rFind;
    PROPVARIANT rVariant;

    // Invalid Args
    if (NULL == pTree || NULL == phRelated)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/related section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_RELATED;

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phRelated)))
    {
        // Is there another multipart/related section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hRoot)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // If no Create, fail
    if (FALSE == fCreate)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get the Root Body
    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)STR_MIME_MPART_RELATED;

    // If Root is empty
    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

        // Set phRelated
        *phRelated = hRoot;
    }

    // If root is non-multipart, convert it to multipart/related
    else if (pTree->IsContentType(hRoot, STR_CNT_MULTIPART, NULL) == S_FALSE)
    {
        // Conver this body to a multipart/related
        CHECKHR(hr = pTree->ToMultipart(hRoot, STR_SUB_RELATED, phRelated));
    }

    // Otherwise, if root is multipart/mixed
    else if (pTree->IsContentType(hRoot, NULL, STR_SUB_MIXED) == S_OK)
    {
        // Insert First Child of multipart/mixed as multipart/related
        CHECKHR(hr = pTree->InsertBody(IBL_FIRST, hRoot, phRelated));

        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(*phRelated, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Otherwise, if root is multipart/alternative
    else if (pTree->IsContentType(HBODY_ROOT, NULL, STR_SUB_ALTERNATIVE) == S_OK)
    {
        // Convert this body to a multipart/related (alternative becomes first child)
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));

        // Should I set multipart/related; start=multipart/alternative at this point ?
    }

    // Otherwise, for unknown multipart content types
    else
    {
        // Convert this body to a multipart/related
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_RELATED, phRelated));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetMixedSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetMixedSection(
                                  IMimeMessageTree   *pTree,
                                  boolean             fCreate,
                                  LPHBODY             phMixed,
                                  boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hTemp;
    HBODY       hRoot;
    FINDBODY    rFind;
    PROPVARIANT rVariant;

    // Invalid Args
    if (NULL == pTree || NULL == phMixed)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/mixed section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_MIXED;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phMixed)))
    {
        // Is there another multipart/mixed section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // If no Create, fail
    if (FALSE == fCreate)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Get the Root Body
    CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot));

    // If Root is empty
    if (pTree->IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Setup Variant
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)STR_MIME_MPART_MIXED;

        // Set the Content Type
        CHECKHR(hr = pTree->SetBodyProp(hRoot, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

        // Set phRelated
        *phMixed = hRoot;
    }

    // Otherwise, convert it to a multipart
    else
    {
        // Conver this body to a multipart/mixed
        CHECKHR(hr = pTree->ToMultipart(HBODY_ROOT, STR_SUB_MIXED, phMixed));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetAlternativeSection
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetAlternativeSection(
                                        IMimeMessageTree   *pTree,
                                        LPHBODY             phAlternative,
                                        boolean            *pfMultiple)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hTemp;
    FINDBODY    rFind;

    // Invalid Args
    if (NULL == pTree || NULL == phAlternative)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(&rFind, sizeof(FINDBODY));

    // Find first multipart/mixed section
    rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
    rFind.pszSubType = (LPSTR)STR_SUB_ALTERNATIVE;

    // Find First
    if (SUCCEEDED(pTree->FindFirst(&rFind, phAlternative)))
    {
        // Is there another multipart/mixed section
        if (pfMultiple && SUCCEEDED(pTree->FindNext(&rFind, &hTemp)))
            *pfMultiple = TRUE;

        // Done
        goto exit;
    }

    // Init
    if (pfMultiple)
        *pfMultiple = FALSE;

    // If no Create, fail
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGenerateCID
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateCID(LPSTR pszCID, ULONG cchMax, boolean fAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cch;
    FILETIME        ft;
    SYSTEMTIME      st;
    WORD            wCounter;

    // Invalid Arg
    if (NULL == pszCID)
        return TrapError(E_INVALIDARG);

    // Get Current Time
    GetSystemTime(&st);

    // Convert to FileTime
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    if (FALSE == fAbsolute)
        cch = wsprintf(pszCID, "%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());
    else
        cch = wsprintf(pszCID, "CID:%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());

    // Buffer Overwrite
    Assert(cch + 1 <= CCHMAX_CID);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGenerateMID
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateMID(LPSTR pszMID, ULONG cchMax, boolean fAbsolute)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cch;
    FILETIME        ft;
    SYSTEMTIME      st;
    WORD            wCounter;

    // Invalid Arg
    if (NULL == pszMID || cchMax < CCHMAX_MID)
        return TrapError(E_INVALIDARG);

    // Get Current Time
    GetSystemTime(&st);

    // Convert to FileTime
    SystemTimeToFileTime(&st, &ft);

    // Build MessageID
    if (FALSE == fAbsolute)
        cch = wsprintf(pszMID, "<%04x%08.8lx$%08.8lx$%s@%s>", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());
    else
        cch = wsprintf(pszMID, "MID:%04x%08.8lx$%08.8lx$%s@%s", DwCounterNext(), ft.dwHighDateTime, ft.dwLowDateTime, (LPTSTR)SzGetLocalPackedIP(), PszGetDomainName());

    // Buffer Overwrite
    Assert(cch + 1 <= CCHMAX_MID);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateByteStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateByteStream(
                                   IStream             **ppStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Alocate It
    CHECKALLOC((*ppStream) = new CByteStream);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGetPropertySchema
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropertySchema(
                                    IMimePropertySchema **ppSchema)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == ppSchema)
        return TrapError(E_INVALIDARG);

    // Out of memory
    if (NULL == g_pSymCache)
        return TrapError(E_OUTOFMEMORY);

    // Create me
    *ppSchema = (IMimePropertySchema *)g_pSymCache;

    // Add Ref
    (*ppSchema)->AddRef();

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateHeaderTable
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateHeaderTable(IMimeHeaderTable **ppTable)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCONTAINER     pContainer=NULL;

    // check params
    if (NULL == ppTable)
        return TrapError(E_INVALIDARG);

    // Create a new Container Object
    CHECKALLOC(pContainer = new CMimePropertyContainer);

    // Init
    CHECKHR(hr = pContainer->InitNew());

    // Bind to Header table
    CHECKHR(hr = pContainer->QueryInterface(IID_IMimeHeaderTable, (LPVOID *)ppTable));

exit:
    // Failure
    SafeRelease(pContainer);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateVirtualStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateVirtualStream(IStream **ppStream)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Allocate Virtual Stream
    *ppStream = new CVirtualStream;
    if (NULL == *ppStream)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleOpenFileStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleOpenFileStream(LPCSTR pszFilePath, DWORD dwCreationDistribution, DWORD dwAccess, IStream **ppstmFile)
{
    // Invalid Arg
    if (NULL == pszFilePath || NULL == ppstmFile)
        return TrapError(E_INVALIDARG);

    // Call Internal Tool
    return OpenFileStream((LPSTR)pszFilePath, dwCreationDistribution, dwAccess, ppstmFile);
}

// ------------------------------------------------------------------------------------------
// MimeOleIsEnrichedStream, text must start with <x-rich>
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleIsEnrichedStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszT;
    BYTE        rgbBuffer[30 + 1];
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Rewind the stream
    CHECKHR(hr = HrRewindStream(pStream));

    // Read the first four bytes
    CHECKHR(hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer) - 1, &cbRead));

    // Less than four bytes read ?
    if (cbRead < (ULONG)lstrlen(c_szXRich))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Stick in a null
    rgbBuffer[cbRead] = '\0';

    // Skip White Space
    pszT = (LPSTR)rgbBuffer;

    // Skip White
    pszT = PszSkipWhiteA(pszT);
    if ('\0' == *pszT)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Compare
    if (StrCmpNI(pszT, c_szXRich, lstrlen(c_szXRich)) != 0)
    {
        hr = S_FALSE;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleIsTnefStream
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleIsTnefStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    BYTE        rgbSignature[4];
    ULONG       cbRead;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Read the first four bytes
    CHECKHR(hr = pStream->Read(rgbSignature, sizeof(rgbSignature), &cbRead));

    // Less than four bytes read ?
    if (cbRead < 4)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Compare bytes
    if (rgbSignature[0] != 0x78 && rgbSignature[1] != 0x9f &&
        rgbSignature[2] != 0x3e && rgbSignature[3] != 0x22)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Its TNEF
    hr = S_OK;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGenerateFileName
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateFileName(LPCSTR pszContentType, LPCSTR pszSuggest, LPCSTR pszDefaultExt, LPSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszExt=NULL,
                    pszName=NULL;
    CHAR            szName[10];
    LPCSTR          pszExtension=NULL,
                    pszPrefix=NULL;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszFileName = NULL;

    // Find a filename extension
    if (pszContentType)
    {
        // Get the content type...
        if (SUCCEEDED(MimeOleGetContentTypeExt(pszContentType, &pszExt)))
            pszExtension = (LPCSTR)pszExt;
    }

    // Extension is still null
    if (NULL == pszExtension)
    {
        // Use default extension...
        if (pszDefaultExt)
            pszExtension = pszDefaultExt;

        // Otherwise, internal default
        else
            pszExtension = c_szDotDat;
    }

    // We Should have an extension
    Assert(pszExtension);

    // Suggested file name ?
    if (pszSuggest)
    {
        // Dup It
        pszName = PszDupA(pszSuggest);
        if (NULL == pszName)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Dupit and remove illegal filename characters...
        CleanupFileNameInPlaceA(CP_ACP, pszName);

        // Set Prefix
        pszPrefix = (LPCSTR)pszName;
    }

    // Otherwise, build a filename...
    else
    {
        // Locals
        CHAR szNumber[30];

        // Get a number...
        wsprintf(szNumber, "%05d", DwCounterNext());

        // Allocate pszName
        wsprintf(szName, "ATT%s", szNumber);

        // Set Prefix
        pszPrefix = (LPCSTR)szName;
    }

    // Build Final FileNmae= pszPrefix + pszExtension + dot + null
    *ppszFileName = PszAllocA(lstrlen(pszPrefix) + lstrlen(pszExtension) + 2);
    if (NULL == *ppszFileName)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Build filename
    wsprintf(*ppszFileName, "%s%s", pszPrefix, pszExtension);

exit:
    // Failure
    if (FAILED(hr) && E_OUTOFMEMORY != hr)
    {
        // Assume Success
        hr = S_OK;

        // Use default Attachment name
        *ppszFileName = PszDupA(c_szDefaultAttach);

        // Memory Failure
        if (NULL == *ppszFileName)
            hr = TrapError(E_OUTOFMEMORY);
    }

    // Cleanup
    SafeMemFree(pszExt);
    SafeMemFree(pszName);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// MimeOleGenerateFileNameW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGenerateFileNameW(LPCSTR pszContentType, LPCWSTR pszSuggest, 
    LPCWSTR pszDefaultExt, LPWSTR *ppszFileName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszExtA=NULL;
    LPWSTR          pszExtW=NULL;
    LPWSTR          pszName=NULL;
    WCHAR           szName[10];
    LPWSTR          pszExtension=NULL;
    LPWSTR          pszPrefix=NULL;
    int             cch = 0;

    // Invalid Arg
    if (NULL == ppszFileName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszFileName = NULL;

    // Find a filename extension
    if (pszContentType)
    {
        // Get the content type...
        if (SUCCEEDED(MimeOleGetContentTypeExt(pszContentType, &pszExtA)))
        {
            // I'm going to convert to unicode because I assume extensions are usascii
            IF_NULLEXIT(pszExtW = PszToUnicode(CP_ACP, pszExtA));

            // Save as the extension
            pszExtension = pszExtW;
        }
    }

    // Extension is still null
    if (NULL == pszExtension)
    {
        // Use default extension...
        if (pszDefaultExt)
            pszExtension = (LPWSTR)pszDefaultExt;

        // Otherwise, internal default
        else
            pszExtension = (LPWSTR)c_wszDotDat;
    }

    // We Should have an extension
    Assert(pszExtension);

    // Suggested file name ?
    if (pszSuggest)
    {
        // Dup It
        IF_NULLEXIT(pszName = PszDupW(pszSuggest));

        // Dupit and remove illegal filename characters...
        CleanupFileNameInPlaceW(pszName);

        // Set Prefix
        pszPrefix = pszName;
    }

    // Otherwise, build a filename...
    else
    {
        // Locals
        WCHAR szNumber[30];

        // Get a number...
        AthwsprintfW(szNumber, ARRAYSIZE(szNumber), L"%05d", DwCounterNext());

        // Allocate pszName
        AthwsprintfW(szName, ARRAYSIZE(szName), L"ATT%s", szNumber);

        // Set Prefix
        pszPrefix = szName;
    }

    // Build Final FileNmae= pszPrefix + pszExtension + dot + null
    cch = lstrlenW(pszPrefix) + lstrlenW(pszExtension) + 2;
    IF_NULLEXIT(*ppszFileName = PszAllocW(cch));

    // Build filename
    AthwsprintfW(*ppszFileName, cch, L"%s%s", pszPrefix, pszExtension);

exit:
    // Failure
    if (FAILED(hr) && E_OUTOFMEMORY != hr)
    {
        // Assume Success
        hr = S_OK;

        // Use default Attachment name
        *ppszFileName = PszDupW(c_wszDefaultAttach);

        // Memory Failure
        if (NULL == *ppszFileName)
            hr = TrapError(E_OUTOFMEMORY);
    }

    // Cleanup
    SafeMemFree(pszExtA);
    SafeMemFree(pszExtW);
    SafeMemFree(pszName);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CreateMimeSecurity
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateSecurity(IMimeSecurity **ppSecurity)
{
    // check params
    if (NULL == ppSecurity)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppSecurity = (IMimeSecurity *) new CSMime;
    if (NULL == *ppSecurity)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessageParts
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessageParts(IMimeMessageParts **ppParts)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeMessageParts *pParts=NULL;

    // check params
    if (NULL == ppParts)
        return TrapError(E_INVALIDARG);

    // Init
    *ppParts = NULL;

    // Allocate Message Parts
    pParts = new CMimeMessageParts;
    if (NULL == pParts)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Success
    *ppParts = pParts;
    (*ppParts)->AddRef();

exit:
    // Done
    SafeRelease(pParts);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleGetAllocator
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetAllocator(IMimeAllocator **ppMalloc)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == ppMalloc)
        return TrapError(E_INVALIDARG);

    // Allocate MimeOleMalloc
    *ppMalloc = new CMimeAllocator;
    if (NULL == *ppMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessage
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateHashTable(DWORD dwSize, BOOL fDupeKeys, IHashTable **ppHashTable)
{
    // Locals
    HRESULT               hr=S_OK;
    IHashTable            *pHash;

    // check params
    if (NULL == ppHashTable)
        return TrapError(E_INVALIDARG);

    // Init
    *ppHashTable = NULL;

    // Allocate MimeMessage
    CHECKALLOC(pHash = new CHash(NULL));

    // Init New
    CHECKHR(hr = pHash->Init(dwSize, fDupeKeys));

    // Success
    *ppHashTable = pHash;
    (*ppHashTable)->AddRef();

exit:
    // Done
    SafeRelease(pHash);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessage
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessage(IUnknown *pUnkOuter, IMimeMessage **ppMessage)
{
    // Locals
    HRESULT               hr=S_OK;
    LPMESSAGETREE         pTree=NULL;

    // check params
    if (NULL == ppMessage)
        return TrapError(E_INVALIDARG);

    // Init
    *ppMessage = NULL;

    // Allocate MimeMessage
    CHECKALLOC(pTree = new CMessageTree(pUnkOuter));

    // Init New
    CHECKHR(hr = pTree->InitNew());

    // Success
    *ppMessage = pTree;
    (*ppMessage)->AddRef();

exit:
    // Done
    SafeRelease(pTree);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreateMessageTree
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreateMessageTree(IUnknown *pUnkOuter, IMimeMessageTree **ppMessageTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGETREE   pTree=NULL;

    // check params
    if (NULL == ppMessageTree)
        return TrapError(E_INVALIDARG);

    // INit
    *ppMessageTree = NULL;

    // Allocate MimeMessageTree
    CHECKALLOC(pTree = new CMessageTree(pUnkOuter));

    // Init New
    CHECKHR(hr = pTree->InitNew());

    // Success
    *ppMessageTree = pTree;
    (*ppMessageTree)->AddRef();

exit:
    // Done
    SafeRelease(pTree);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------------
// MimeOleCreatePropertySet
// ------------------------------------------------------------------------------------------
MIMEOLEAPI MimeOleCreatePropertySet(IUnknown *pUnkOuter, IMimePropertySet **ppPropertySet)
{
    // Locals
    HRESULT             hr=S_OK;
    LPMESSAGEBODY       pBody=NULL;

    // check params
    if (NULL == ppPropertySet)
        return TrapError(E_INVALIDARG);

    // Init
    *ppPropertySet = NULL;

    // Allocate MimePropertySet
    CHECKALLOC(pBody = new CMessageBody(NULL, pUnkOuter));

    // Init New
    CHECKHR(hr = pBody->InitNew());

    // Success
    *ppPropertySet = (IMimePropertySet *)pBody;
    (*ppPropertySet)->AddRef();

exit:
    // Done
    SafeRelease(pBody);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleMergePartialHeaders
// -------------------------------
// Rules
// -----
// (1) All of the header fields from the initial enclosing entity
//     (part one), except those that start with "Content-" and the
//     specific header fields "Message-ID", "Encrypted", and "MIME-
//     Version", must be copied, in order, to the new message.
//
// (2) Only those header fields in the enclosed message which start
//     with "Content-" and "Message-ID", "Encrypted", and "MIME-Version"
//     must be appended, in order, to the header fields of the new
//     message.  Any header fields in the enclosed message which do not
//     start with "Content-" (except for "Message-ID", "Encrypted", and
//     "MIME-Version") will be ignored.
//
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleMergePartialHeaders(IStream *pstmIn, IStream *pstmOut)
{
    // Locals
    HRESULT              hr = S_OK;
    LPCONTAINER          pc1=NULL;
    LPCONTAINER          pc2=NULL;
    ULONG                i;
    ULONG                cboffStart;
    CInternetStream      cInternet;
    LONG                 iColon;
    PROPSTRINGA          rHeader;
    PROPVARIANT          rOption;

    // check params
    if (NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Create text stream object
    CHECKHR(hr = cInternet.HrInitNew(pstmIn));

    // Create Property Sets
    CHECKALLOC(pc1 = new CMimePropertyContainer);
    CHECKALLOC(pc2 = new CMimePropertyContainer);

    // Init
    CHECKHR(hr = pc1->InitNew());
    CHECKHR(hr = pc2->InitNew());

    // Load the first header
    CHECKHR(hr = pc1->Load(&cInternet));

    // RAID-18376: POPDOG adds extra lines after the header, so I must read the blank lines
    // until I hit the next header, then backup.
    while(1)
    {
        // Get current position
        cboffStart = cInternet.DwGetOffset();

        // Read a line
        CHECKHR(hr = cInternet.HrReadHeaderLine(&rHeader, &iColon));

        // If line is not empty, assume its the start of the next header...
        if ('\0' != *rHeader.pszVal)
        {
            // Line better have a length
            Assert(rHeader.cchVal);

            // Reset position back to cboffStart
            cInternet.Seek(cboffStart);

            // Done
            break;
        }
    }

    // Load the second header
    CHECKHR(hr = pc2->Load(&cInternet));

    // Delete Props From Header 1
    for (i=0; i<ARRAYSIZE(g_rgszPartialPids); i++)
        pc1->DeleteProp(g_rgszPartialPids[i]);

    // Delete Except from header 2
    pc2->DeleteExcept(ARRAYSIZE(g_rgszPartialPids), g_rgszPartialPids);

    // Save as Mime
    rOption.vt = VT_UI4;
    rOption.ulVal = SAVE_RFC1521;

    // Store Some Options
    pc1->SetOption(OID_SAVE_FORMAT, &rOption);
    pc2->SetOption(OID_SAVE_FORMAT, &rOption);

    // Don't default to text/plain if Content-Type is not yet set...
    rOption.vt = VT_BOOL;
    rOption.boolVal = TRUE;
    pc1->SetOption(OID_NO_DEFAULT_CNTTYPE, &rOption);
    pc2->SetOption(OID_NO_DEFAULT_CNTTYPE, &rOption);

    // Save Header 1
    CHECKHR(hr = pc1->Save(pstmOut, TRUE));
    CHECKHR(hr = pc2->Save(pstmOut, TRUE));

exit:
    // Cleanup
    SafeRelease(pc1);
    SafeRelease(pc2);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleParseRfc822Address
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseRfc822Address(
                                     DWORD               dwAdrType,
                                     ENCODINGTYPE        ietEncoding,
                                     LPCSTR              pszRfc822Adr,
                                     LPADDRESSLIST       pList)
{
    // Locals
    CMimePropertyContainer cContainer;

    // Parse the address
    return cContainer.ParseRfc822(dwAdrType, ietEncoding, pszRfc822Adr, pList);
}

// --------------------------------------------------------------------------------
// MimeOleParseRfc822Address
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleParseRfc822AddressW(
                                     DWORD               dwAdrType,
                                     LPCWSTR             pwszRfc822Adr,
                                     LPADDRESSLIST       pList)
{
    // Locals
    CMimePropertyContainer cContainer;

    // Parse the address
    return cContainer.ParseRfc822W(dwAdrType, pwszRfc822Adr, pList);
}

// --------------------------------------------------------------------------------
// MimeOleGetInternat
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetInternat(IMimeInternational **ppInternat)
{
    // check params
    if (NULL == ppInternat)
        return TrapError(E_INVALIDARG);

    // Out of memory
    if (NULL == g_pInternat)
        return TrapError(E_OUTOFMEMORY);

    // Assume Global
    *ppInternat = (IMimeInternational *)g_pInternat;

    // Set database
    (*ppInternat)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MimeOleSplitContentType
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSplitContentType(LPWSTR pszFull, LPWSTR *ppszCntType, LPWSTR *ppszSubType)
{
    // Locals
    HRESULT         hr = E_FAIL;
    LPWSTR           pszFreeMe = NULL,
                    psz = NULL,
                    pszStart;

    // check params
    if (NULL == pszFull)
        return TrapError(E_INVALIDARG);

    // Lets dup pszFull to make sure we have read access
    psz = pszFreeMe = PszDupW(pszFull);
    if (NULL == psz)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find '/'
    pszStart = psz;
    while(*psz && *psz != L'/')
        psz++;

    // If not found, return
    if (L'\0' == *psz)
        goto exit;

    // Otherwise stuff a null
    *psz = L'\0';

    // Dup
    *ppszCntType = PszDupW(pszStart);
    if (NULL == *ppszCntType)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Step over
    *psz = L'/';
    psz++;

    // If not found, return
    if (L'\0' == *psz)
        goto exit;

    // Save position
    pszStart = psz;
    while(*psz && L';' != *psz)
        psz++;

    // Save character...
    *psz = L'\0';

    // Dup as sub type
    *ppszSubType = PszDupW(pszStart);
    if (NULL == *ppszSubType)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Success
    hr = S_OK;

exit:
    // If failed
    if (FAILED(hr))
    {
        SafeMemFree((*ppszCntType));
        SafeMemFree((*ppszSubType));
    }

    // Cleanup
    SafeMemFree(pszFreeMe);

    // Done
    return hr;
}     

// --------------------------------------------------------------------------------
// MimeEscapeString - quotes '"' and '\'
//
// Returns S_OK if *ppszOut was allocated and set to the escaped string
// Retruns S_FALSE if *ppszOut is NULL - pszIn did not require escaping
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEscapeString(CODEPAGEID cpiCodePage, LPCSTR pszIn, LPSTR *ppszOut)
{
    // Locals
    HRESULT hr=S_FALSE;
    LPSTR   pszOut,
        psz;
    ULONG   cb,
        c;

    // check parameters
    if (NULL == pszIn || NULL == ppszOut)
        return TrapError(E_INVALIDARG);

    // $$ INFO $$ This is basically as fast as doing an lstrlen
    // I've decided to first detect if we need to escape
    c = 0;
    cb = 0;
    psz = (LPSTR)pszIn;
    while (*psz)
    {
        // If DBCS Lead-Byte, then skip
        if (IsDBCSLeadByteEx(cpiCodePage, *psz))
        {
            cb  += 2;
            psz += 2;
        }

        // Otherwise, text for escaped character
        else
        {
            // Count the number of character to escape
            if ('\"' == *psz || '\\' == *psz || '(' == *psz || ')' == *psz)
                c++;

            // Step one more character
            psz++;
            cb++;
        }
    }

    // No escape needed
    if (0 == c)
        goto exit;

    // Adjust number of bytes to allocate
    cb += (c + 1);

    // worst case - escape every character, so use double original strlen
    CHECKHR(hr = HrAlloc((LPVOID *)ppszOut, cb));

    // Start copy
    psz = (LPSTR)pszIn;
    pszOut = *ppszOut;
    while (*psz)
    {
        // If DBCS Lead-Byte, then skip
        if (IsDBCSLeadByteEx(cpiCodePage, *psz))
        {
            *pszOut++ = *psz++;
            *pszOut++ = *psz++;
        }

        // Otherwise, non-DBCS
        else
        {
            // Do escape
            if ('\"' == *psz || '\\' == *psz || '(' == *psz || ')' == *psz)
                *pszOut++ = '\\';

            // Regular char
            *pszOut++ = *psz++;
        }
    }

    // Null term
    *pszOut = '\0';

exit:
    // Done
    return hr;
}

MIMEOLEAPI MimeOleUnEscapeStringInPlace(LPSTR pszIn)
{
    HRESULT hr = S_OK;
    ULONG   cchOffset = 0;
    ULONG   i = 0;

    IF_TRUEEXIT((pszIn == NULL), E_INVALIDARG);

    for(;;i++)
    {
        if((pszIn[i + cchOffset] == '\\') &&
           (pszIn[i + cchOffset + 1] == '\\' ||
            pszIn[i + cchOffset + 1] == '\"' ||
            pszIn[i + cchOffset + 1] == '('  ||
            pszIn[i + cchOffset + 1] == ')'))
            cchOffset++;

        pszIn[i] = pszIn[i + cchOffset];
        if(pszIn[i] == 0)
            break;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// MimeEscapeString - quotes '"' and '\'
//
// Returns S_OK if *ppszOut was allocated and set to the escaped string
// Retruns S_FALSE if *ppszOut is NULL - pszIn did not require escaping
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEscapeStringW(LPCWSTR pszIn, LPWSTR *ppszOut)
{
    // Locals
    HRESULT hr=S_FALSE;
    LPWSTR  pszOut;
    LPWSTR  psz;
    ULONG   cch;
    ULONG   cchExtra;

    // check parameters
    if (NULL == pszIn || NULL == ppszOut)
        return TrapError(E_INVALIDARG);

    // $$ INFO $$ This is basically as fast as doing an lstrlen
    // I've decided to first detect if we need to escape
    cchExtra = 0;
    cch = 0;
    psz = (LPWSTR)pszIn;
    while (*psz)
    {
        // Count the number of character to escape
        if (L'\"' == *psz || L'\\' == *psz || L'(' == *psz || L')' == *psz)
            cchExtra++;

        // Step one more character
        psz++;
        cch++;
    }

    // No escape needed
    if (0 == cchExtra)
        goto exit;

    // Adjust number of bytes to allocate
    cch += (cchExtra + 1);

    // worst case - escape every character, so use double original strlen
    CHECKHR(hr = HrAlloc((LPVOID *)ppszOut, cch * sizeof(WCHAR)));

    // Start copy
    psz = (LPWSTR)pszIn;
    pszOut = *ppszOut;
    while (*psz)
    {
        // Do escape
        if (L'\"' == *psz || L'\\' == *psz || L'(' == *psz || L')' == *psz)
            *pszOut++ = L'\\';

        // Regular char
        *pszOut++ = *psz++;
    }

    // Null term
    *pszOut = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetFileExtension
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetFileExtension(LPCSTR pszFilePath, LPSTR pszExt, ULONG cchMax)
{
    // Locals
    CHAR        *pszExtT;

    // Invalid Arg
    if (NULL == pszFilePath || NULL == pszExt || cchMax < _MAX_EXT)
        return TrapError(E_INVALIDARG);

    // Locate the extension of the file
    pszExtT = PathFindExtension(pszFilePath);
    lstrcpyn(pszExt, pszExtT, cchMax);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MimeOleGetExtClassId
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetExtClassId(LPCSTR pszExtension, LPCLSID pclsid)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cb;
    LPSTR           pszCLSID=NULL;
    HKEY            hkeyExt=NULL;
    HKEY            hkeyCLSID=NULL;
    LPSTR           pszData=NULL;
    LPWSTR          pwszCLSID=NULL;

    // check params
    if (NULL == pszExtension || NULL == pclsid)
        return TrapError(E_INVALIDARG);

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Query Value
    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Allocate Size
    cb += 1;
    CHECKHR(hr = HrAlloc((LPVOID *)&pszData, cb));

    // Get the data
    if (RegQueryValueEx(hkeyExt, NULL, 0, NULL, (LPBYTE)pszData, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Close this regkey
    RegCloseKey(hkeyExt);
    hkeyExt = NULL;

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszData, 0, KEY_READ, &hkeyExt) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyEx(hkeyExt, c_szCLSID, 0, KEY_READ, &hkeyCLSID) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Get the data
    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Add One
    cb += 1;
    CHECKHR(hr = HrAlloc((LPVOID *)&pszCLSID, cb));

    // Get the data
    if (RegQueryValueEx(hkeyCLSID, NULL, 0, NULL, (LPBYTE)pszCLSID, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // ToUnicode
    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, pszCLSID));

    // Convert to class id
    CHECKHR(hr = CLSIDFromString(pwszCLSID, pclsid));

exit:
    // Close Reg Keys
    if (hkeyExt)
        RegCloseKey(hkeyExt);
    if (hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    SafeMemFree(pszData);
    SafeMemFree(pwszCLSID);
    SafeMemFree(pszCLSID);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetExtContentType
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetExtContentType(LPCSTR pszExtension, LPSTR *ppszContentType)
{
    LPWSTR  pwszExt,
            pwszContType = NULL;
    HRESULT hr = S_OK;
    
    if (NULL == pszExtension || NULL == ppszContentType || '.' != *pszExtension)
        return TrapError(E_INVALIDARG);

    IF_NULLEXIT(pwszExt = PszToUnicode(CP_ACP, pszExtension));

    IF_FAILEXIT(hr = MimeOleGetExtContentTypeW(pwszExt, &pwszContType));

    IF_NULLEXIT(*ppszContentType = PszToANSI(CP_ACP, pwszContType));

exit:
    MemFree(pwszExt);
    MemFree(pwszContType);

    return hr;
}

MIMEOLEAPI MimeOleGetExtContentTypeW(LPCWSTR pszExtension, LPWSTR *ppszContentType)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    HKEY            hkeyExt=NULL;
    LPWSTR          pszFull=NULL;
    ULONG           cb;

    // check params
    if (NULL == pszExtension || NULL == ppszContentType || '.' != *pszExtension)
        return TrapError(E_INVALIDARG);

    // Otherwise, lets lookup the extension in HKEY_CLASSESS_ROOT
    if (RegOpenKeyExWrapW(HKEY_CLASSES_ROOT, pszExtension, 0, KEY_READ, &hkeyExt) == ERROR_SUCCESS)
    {
        // Query Value
        if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, NULL, &cb) == ERROR_SUCCESS)
        {
            // Add One
            cb += 1;

            // Allocate Size
            pszFull = PszAllocW(cb);
            if (NULL == pszFull)
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            // Get the data
            if (RegQueryValueExWrapW(hkeyExt, c_szContentTypeW, 0, NULL, (LPBYTE)pszFull, &cb) == ERROR_SUCCESS)
            {
                // Set It
                *ppszContentType = pszFull;
                pszFull = NULL;
                goto exit;
            }
        }
    }

    // Not found
    hr = MIME_E_NOT_FOUND;

exit:
    // Close Reg Keys
    if (hkeyExt)
        RegCloseKey(hkeyExt);

    // Cleanup
    MemFree(pszFull);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetFileInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetFileInfo(
                              LPSTR    pszFilePath,   LPSTR   *ppszCntType,
                              LPSTR   *ppszSubType,   LPSTR   *ppszCntDesc,
                              LPSTR   *ppszFileName,  LPSTR   *ppszExtension)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszFilePath,
            pwszCntType = NULL,
            pwszSubType = NULL,
            pwszCntDesc = NULL,
            pwszFileName = NULL,
            pwszExtension = NULL;
    LPSTR   pszCntType = NULL,
            pszSubType = NULL,
            pszCntDesc = NULL,
            pszFileName = NULL,
            pszExtension = NULL;

    // check params
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    IF_NULLEXIT(pwszFilePath = PszToUnicode(CP_ACP, pszFilePath));

    // Only pass in parameters for items that 
    IF_FAILEXIT(hr = MimeOleGetFileInfoW(pwszFilePath,
        ppszCntType     ? &pwszCntType      : NULL,
        ppszSubType     ? &pwszSubType      : NULL,
        ppszCntDesc     ? &pwszCntDesc      : NULL,
        ppszFileName    ? &pwszFileName     : NULL,
        ppszExtension   ? &pwszExtension    : NULL));

    if (ppszCntType)
    {
        Assert(pwszCntType);
        IF_NULLEXIT(pszCntType = PszToANSI(CP_ACP, pwszCntType));
    }
    if (ppszSubType)
    {
        Assert(pwszSubType);
        IF_NULLEXIT(pszSubType = PszToANSI(CP_ACP, pwszSubType));
    }
    if (ppszCntDesc)
    {
        Assert(pwszCntDesc);
        IF_NULLEXIT(pszCntDesc = PszToANSI(CP_ACP, pwszCntDesc));
    }
    if (ppszFileName)
    {
        Assert(pwszFileName);
        IF_NULLEXIT(pszFileName = PszToANSI(CP_ACP, pwszFileName));
    }
    if (ppszExtension)
    {
        Assert(pwszExtension);
        IF_NULLEXIT(pszExtension = PszToANSI(CP_ACP, pwszExtension));
    }

    if (ppszCntType)
        *ppszCntType = pszCntType;

    if (ppszSubType)
        *ppszSubType = pszSubType;

    if (ppszCntDesc)
        *ppszCntDesc = pszCntDesc;

    if (ppszFileName)
        *ppszFileName = pszFileName;

    if (ppszExtension)
        *ppszExtension = pszExtension;


exit:
    MemFree(pwszCntType);
    MemFree(pwszSubType);
    MemFree(pwszCntDesc);
    MemFree(pwszFileName);
    MemFree(pwszExtension);
    MemFree(pwszFilePath);

    if (FAILED(hr))
    {
        MemFree(pszCntType);
        MemFree(pszSubType);
        MemFree(pszCntDesc);
        MemFree(pszFileName);
        MemFree(pszExtension);
    }

    return hr;     
}

MIMEOLEAPI MimeOleGetFileInfoW(
                              LPWSTR    pszFilePath,  LPWSTR   *ppszCntType,
                              LPWSTR   *ppszSubType,  LPWSTR   *ppszCntDesc,
                              LPWSTR   *ppszFileName, LPWSTR   *ppszExtension)
{
    // Locals
    HRESULT         hr=S_OK;
    SHFILEINFOW     rShFileInfo;
    LPWSTR          pszFull=NULL,
                    pszExt,
                    pszFname;

    // check params
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    // Init
    if (ppszCntType)
        *ppszCntType = NULL;
    if (ppszSubType)
        *ppszSubType = NULL;
    if (ppszCntDesc)
        *ppszCntDesc = NULL;
    if (ppszFileName)
        *ppszFileName = NULL;
    if (ppszExtension)
        *ppszExtension = NULL;

    // Locate the extension of the file
    pszFname = PathFindFileNameW(pszFilePath);
    pszExt = PathFindExtensionW(pszFilePath);

    // Did the user want the actual filename...
    if (ppszFileName)
    {
        // Allocate
        *ppszFileName = PszDupW(pszFname);
        if (NULL == *ppszFileName)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // Empty extension
    if (FIsEmptyW(pszExt))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // User wanted the extension
    if (ppszExtension)
    {
        // Allocate
        *ppszExtension = PszDupW(pszExt);
        if (NULL == *ppszExtension)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    // User wanted ppszCntDesc
    if (ppszCntDesc)
    {
        // Lets try to get the extension file information first
        if (SHGetFileInfoWrapW(pszExt, FILE_ATTRIBUTE_NORMAL, &rShFileInfo, sizeof(rShFileInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME | SHGFI_TYPENAME))
        {
            // Set lppszCntDesc + ( )
            *ppszCntDesc = PszAllocW(lstrlenW(rShFileInfo.szDisplayName) + lstrlenW(rShFileInfo.szTypeName) + 5);
            if (NULL == *ppszCntDesc)
            {
                hr = TrapError(E_OUTOFMEMORY);
                goto exit;
            }

            // Format the string
            StrCpyW(*ppszCntDesc, rShFileInfo.szDisplayName);
            StrCatW(*ppszCntDesc, L", (");
            StrCatW(*ppszCntDesc, rShFileInfo.szTypeName);
            StrCatW(*ppszCntDesc, L")");
        }
    }

    // Content type
    if (ppszCntType && ppszSubType)
    {
        // Lookup content type
        if (SUCCEEDED(MimeOleGetExtContentTypeW(pszExt, &pszFull)))
        {
            // Split content type
            CHECKHR(hr = MimeOleSplitContentType(pszFull, ppszCntType, ppszSubType));
        }
    }

exit:
    // Set defaults if something was not found...
    if (ppszCntType && NULL == *ppszCntType)
        *ppszCntType = PszDupW((LPWSTR)STR_CNT_APPLICATIONW);
    if (ppszSubType && NULL == *ppszSubType)
        *ppszSubType = PszDupW((LPWSTR)STR_SUB_OCTETSTREAMW);
    if (ppszCntDesc && NULL == *ppszCntDesc)
        *ppszCntDesc = PszDupW((LPWSTR)c_szEmptyW);

    // Cleanup
    SafeMemFree(pszFull);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetContentTypeExt
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetContentTypeExt(LPCSTR pszContentType, LPSTR *ppszExtension)
{
    // Locals
    HRESULT   hr=S_OK;
    HKEY      hDatabase=NULL;
    HKEY      hContentType=NULL;
    ULONG     cb;

    // check params
    if (NULL == pszContentType || NULL == ppszExtension)
        return TrapError(E_INVALIDARG);

    // Open Content-Type --> file extension MIME Database registry key
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szMDBContentType, 0, KEY_READ, &hDatabase) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Open Content Type
    if (RegOpenKeyEx(hDatabase, pszContentType, 0, KEY_READ, &hContentType) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Query for size
    if (RegQueryValueEx(hContentType, c_szExtension, 0, NULL, NULL, &cb) != ERROR_SUCCESS)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Allocate It
    *ppszExtension = PszAllocA(cb + 1);
    if (NULL == *ppszExtension)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Query for extension
    cb = cb + 1;
    if (RegQueryValueEx(hContentType, c_szExtension, 0, NULL, (LPBYTE)*ppszExtension, &cb) != ERROR_SUCCESS)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }


exit:
    // Cleanup
    if (hContentType)
        RegCloseKey(hContentType);
    if (hDatabase)
        RegCloseKey(hDatabase);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleFindCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleFindCharset(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->FindCharset(pszCharset, phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleGetCharsetInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCharsetInfo(HCHARSET hCharset, LPINETCSETINFO pCsetInfo)
{
    Assert(g_pInternat);
    return g_pInternat->GetCharsetInfo(hCharset, pCsetInfo);
}

// --------------------------------------------------------------------------------
// MimeOleGetCodePageInfo
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCodePageInfo(CODEPAGEID cpiCodePage, LPCODEPAGEINFO pCodePageInfo)
{
    Assert(g_pInternat);
    return g_pInternat->GetCodePageInfo(cpiCodePage, pCodePageInfo);
}

// --------------------------------------------------------------------------------
// MimeOleGetDefaultCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetDefaultCharset(LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->GetDefaultCharset(phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleSetDefaultCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetDefaultCharset(HCHARSET hCharset)
{
    Assert(g_pInternat);
    return g_pInternat->SetDefaultCharset(hCharset);
}

// --------------------------------------------------------------------------------
// MimeOleGetCodePageCharset
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetCodePageCharset(CODEPAGEID cpiCodePage, CHARSETTYPE ctCsetType, LPHCHARSET phCharset)
{
    Assert(g_pInternat);
    return g_pInternat->GetCodePageCharset(cpiCodePage, ctCsetType, phCharset);
}

// --------------------------------------------------------------------------------
// MimeOleEncodeHeader
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleEncodeHeader(
                               HCHARSET            hCharset,
                               LPPROPVARIANT       pData,
                               LPSTR              *ppszEncoded,
                               LPRFC1522INFO       pRfc1522Info)
{
    Assert(g_pInternat);
    return g_pInternat->EncodeHeader(hCharset, pData, ppszEncoded, pRfc1522Info);
}

// --------------------------------------------------------------------------------
// MimeOleDecodeHeader
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleDecodeHeader(
                               HCHARSET            hCharset,
                               LPCSTR              pszData,
                               LPPROPVARIANT       pDecoded,
                               LPRFC1522INFO       pRfc1522Info)
{
    Assert(g_pInternat);
    return g_pInternat->DecodeHeader(hCharset, pszData, pDecoded, pRfc1522Info);
}

// --------------------------------------------------------------------------------
// MimeOleVariantFree
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleVariantFree(LPPROPVARIANT pProp)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(pProp);

    // Handle Variant Type...
    switch(pProp->vt)
    {
    case VT_NULL:
    case VT_EMPTY:
    case VT_ILLEGAL:
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_CF:
    case VT_CLSID:
    case VT_LPWSTR:
    case VT_LPSTR:
        if ((LPVOID)pProp->pszVal != NULL)
            MemFree((LPVOID)pProp->pszVal);
        break;

    case VT_BLOB:
        if (pProp->blob.pBlobData)
            MemFree(pProp->blob.pBlobData);
        break;

    case VT_STREAM:
        if (pProp->pStream)
            pProp->pStream->Release();
        break;

    case VT_STORAGE:
        if (pProp->pStorage)
            pProp->pStorage->Release();
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_INVALIDARG);
        break;
    }

    // Init
    MimeOleVariantInit(pProp);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleVariantCopy
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleVariantCopy(LPPROPVARIANT pDest, LPPROPVARIANT pSource)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Invalid Arg
    Assert(pSource && pDest);

    // Handle Variant Type...
    switch(pSource->vt)
    {
    case VT_UI1:
        pDest->bVal = pSource->bVal;
        break;

    case VT_I2:
        pDest->iVal= pSource->iVal;
        break;

    case VT_UI2:
        pDest->uiVal = pSource->uiVal;
        break;

    case VT_I4:
        pDest->lVal = pSource->lVal;
        break;

    case VT_UI4:
        pDest->ulVal = pSource->ulVal;
        break;

    case VT_I8:
        pDest->hVal.QuadPart = pSource->hVal.QuadPart;
        break;

    case VT_UI8:
        pDest->uhVal.QuadPart = pSource->uhVal.QuadPart;
        break;

    case VT_R4:
        pDest->fltVal = pSource->fltVal;
        break;

    case VT_R8:
        pDest->dblVal = pSource->dblVal;
        break;

    case VT_CY:
        CopyMemory(&pDest->cyVal, &pSource->cyVal, sizeof(CY));
        break;

    case VT_DATE:
        pDest->date = pSource->date;
        break;

    case VT_BOOL:
        pDest->boolVal = pSource->boolVal;
        break;

    case VT_ERROR:
        pDest->scode = pSource->scode;
        break;

    case VT_FILETIME:
        CopyMemory(&pDest->filetime, &pSource->filetime, sizeof(FILETIME));
        break;

    case VT_CF:
        // Invalid Arg
        if (NULL == pSource->pclipdata)
            return TrapError(E_INVALIDARG);

        // Duplicate the clipboard format
        CHECKALLOC(pDest->pclipdata = (CLIPDATA *)g_pMalloc->Alloc(sizeof(CLIPDATA)));

        // Copy the data
        CopyMemory(pDest->pclipdata, pSource->pclipdata, sizeof(CLIPDATA));
        break;

    case VT_CLSID:
        // Invalid Arg
        if (NULL == pDest->puuid)
            return TrapError(E_INVALIDARG);

        // Duplicate the CLSID
        CHECKALLOC(pDest->puuid = (CLSID *)g_pMalloc->Alloc(sizeof(CLSID)));

        // Copy
        CopyMemory(pDest->puuid, pSource->puuid, sizeof(CLSID));
        break;

    case VT_LPWSTR:
        // Invalid Arg
        if (NULL == pSource->pwszVal)
            return TrapError(E_INVALIDARG);

        // Get Size
        cb = (lstrlenW(pSource->pwszVal) + 1) * sizeof(WCHAR);

        // Dup the unicode String
        CHECKALLOC(pDest->pwszVal = (LPWSTR)g_pMalloc->Alloc(cb));

        // Copy the data
        CopyMemory(pDest->pwszVal, pSource->pwszVal, cb);
        break;

    case VT_LPSTR:
        // Invalid Arg
        if (NULL == pSource->pszVal)
            return TrapError(E_INVALIDARG);

        // Get Size
        cb = lstrlen(pSource->pszVal) + 1;

        // Dup the unicode String
        CHECKALLOC(pDest->pszVal = (LPSTR)g_pMalloc->Alloc(cb));

        // Copy the data
        CopyMemory(pDest->pszVal, pSource->pszVal, cb);
        break;

    case VT_BLOB:
        // Invalid Arg
        if (NULL == pSource->blob.pBlobData)
            return TrapError(E_INVALIDARG);

        // Duplicate the blob
        CHECKALLOC(pDest->blob.pBlobData = (LPBYTE)g_pMalloc->Alloc(pSource->blob.cbSize));

        // Copy the data
        CopyMemory(pDest->blob.pBlobData, pSource->blob.pBlobData, pSource->blob.cbSize);
        break;

    case VT_STREAM:
        // Invalid Arg
        if (NULL == pSource->pStream)
            return TrapError(E_INVALIDARG);

        // Assume the new stream
        pDest->pStream = pSource->pStream;
        pDest->pStream->AddRef();
        break;

    case VT_STORAGE:
        // Invalid Arg
        if (NULL == pSource->pStorage)
            return TrapError(E_INVALIDARG);

        // Assume the new storage
        pDest->pStorage = pSource->pStorage;
        pDest->pStorage->AddRef();
        break;

    default:
        Assert(FALSE);
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Success, return vt
    pDest->vt = pSource->vt;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleRecurseSetProp
// --------------------------------------------------------------------------------
HRESULT MimeOleRecurseSetProp(IMimeMessageTree *pTree, HBODY hBody, LPCSTR pszName,
    DWORD dwFlags, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrFind;
    HBODY       hChild;

    // Invalid Arg
    Assert(pTree && hBody && pValue);

    // multipart/alternative
    if (pTree->IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Get First Child
        hrFind = pTree->GetBody(IBL_FIRST, hBody, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Go down to the child
            CHECKHR(hr = MimeOleRecurseSetProp(pTree, hChild, pszName, dwFlags, pValue));

            // Next Child
            hrFind = pTree->GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Otherwise
    else
    {
        // Go down to the child
        CHECKHR(hr = pTree->SetBodyProp(hBody, pszName, dwFlags, pValue));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropA(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPSTR              *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;

    // Call Method
    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetPropA(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPCSTR              pszData)
{
    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)pszData;

    // Call Method
    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));
}


// --------------------------------------------------------------------------------
// MimeOleGetPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetPropW(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPWSTR             *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;

    // Call Method
    CHECKHR(hr = pPropertySet->GetProp(pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pwszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetPropW(
                           IMimePropertySet   *pPropertySet,
                           LPCSTR              pszName,
                           DWORD               dwFlags,
                           LPWSTR              pszData)
{
    // Invaid Arg
    if (NULL == pPropertySet)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = (LPWSTR)pszData;

    // Call Method
    return TrapError(pPropertySet->SetProp(pszName, dwFlags, &rVariant));
}

// --------------------------------------------------------------------------------
// MimeOleGetBodyPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetBodyPropA(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPSTR              *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;

    // Call Method
    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetBodyPropA
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetBodyPropA(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPCSTR              pszData)
{
    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)pszData;

    // Call Method
    return TrapError(pTree->SetBodyProp(hBody, pszName, dwFlags, &rVariant));
}

// --------------------------------------------------------------------------------
// MimeOleGetBodyPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleGetBodyPropW(
                               IMimeMessageTree   *pTree,
                               HBODY               hBody,
                               LPCSTR              pszName,
                               DWORD               dwFlags,
                               LPWSTR             *ppszData)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;

    // Call Method
    CHECKHR(hr = pTree->GetBodyProp(hBody, pszName, dwFlags, &rVariant));

    // Return the Data
    *ppszData = rVariant.pwszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleSetBodyPropW
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSetBodyPropW(
        IMimeMessageTree   *pTree,
        HBODY               hBody,
        LPCSTR              pszName,
        DWORD               dwFlags,
        LPCWSTR             pszData)
{
    // Invaid Arg
    if (NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Initialzie PropVariant
    PROPVARIANT rVariant;
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = (LPWSTR)pszData;

    // Call Method
    return TrapError(pTree->SetBodyProp(hBody, pszName, dwFlags, &rVariant));
}


// --------------------------------------------------------------------------------
// MimeOleQueryString
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleQueryString(
        LPCSTR              pszSearchMe,
        LPCSTR              pszCriteria,
        boolean             fSubString,
        boolean             fCaseSensitive)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszDataLower=NULL;

    // Invalid Arg
    Assert(pszSearchMe && pszCriteria);

    // Init
    STACKSTRING_DEFINE(rDataLower, 255);

    // No SubString Search
    if (FALSE == fSubString)
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (lstrcmp(pszSearchMe, pszCriteria) == 0)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (lstrcmpi(pszSearchMe, pszCriteria) == 0)
            goto exit;
    }

    // Otheriwse, comparing substring
    else
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrStr(pszSearchMe, pszCriteria) != NULL)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else
        {
            // Get the Length
            ULONG cchSearchMe = lstrlen(pszSearchMe);

            // Set size the stack string
            STACKSTRING_SETSIZE(rDataLower, cchSearchMe + 1);

            // Copy the data
            CopyMemory(rDataLower.pszVal, pszSearchMe, cchSearchMe + 1);

            // Lower Case Compare
            CharLower(rDataLower.pszVal);

            // Compare Strings...
            if (StrStr(rDataLower.pszVal, pszCriteria) != NULL)
                goto exit;
        }
    }

    // No Match
    hr = S_FALSE;

exit:
    // Cleanup
    STACKSTRING_FREE(rDataLower);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleQueryStringW
// --------------------------------------------------------------------------------
HRESULT MimeOleQueryStringW(LPCWSTR pszSearchMe, LPCWSTR pszCriteria,
    boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    Assert(pszSearchMe && pszCriteria);

    // No SubString Search
    if (FALSE == fSubString)
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrCmpW(pszSearchMe, pszCriteria) == 0)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (StrCmpIW(pszSearchMe, pszCriteria) == 0)
            goto exit;
    }

    // Otheriwse, comparing substring
    else
    {
        // Case Sensitive
        if (fCaseSensitive)
        {
            // Equal
            if (StrStrW(pszSearchMe, pszCriteria) != NULL)
                goto exit;
        }

        // Otherwise, Not Case Sensitive
        else if (StrStrIW(pszSearchMe, pszCriteria) != NULL)
            goto exit;
    }

    // No Match
    hr = S_FALSE;

exit:
    // Done
    return hr;
}


#define FILETIME_SECOND    10000000     // 100ns intervals per second
LONG CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset) {
    LONG lRet;
    FILETIME ftNow;
    __int64  i64Offset;
#ifdef WIN32
    union {
        FILETIME ftDelta;
        __int64 i64Delta;
    };
#else
    // FILETIME ftDelta;
    // __int64  i64Delta;
    //
    // WIN32 specific.  I've commented this for WIN32 so that it will produce a compilation
    // error on non Win32 platforms.  The following code is specific to i386 since it relies on
    // __int64 being stored low dword first.
    //
    // I would have used right shift by 32 but it is not in iert.lib  Maybe you unix and mac folks
    // can get it in there.  On the other hand, maybe you won't need to.
#endif

    lRet = CertVerifyTimeValidity(pTimeToVerify, pCertInfo);

    if (lRet < 0) {
        if (! pTimeToVerify) {
            // Get the current time in filetime format so we can add the offset
            GetSystemTimeAsFileTime(&ftNow);
            pTimeToVerify = &ftNow;
        }

        i64Delta = pTimeToVerify->dwHighDateTime;
        i64Delta = i64Delta << 32;
        i64Delta += pTimeToVerify->dwLowDateTime;

        // Add the offset into the original time to get us a new time to check
        i64Offset = FILETIME_SECOND;
        i64Offset *= ulOffset;
        i64Delta += i64Offset;

        // ftDelta.dwLowDateTime = (ULONG)i64Delta & 0xFFFFFFFF;
        // ftDelta.dwHighDateTime = (ULONG)(i64Delta >> 32);

        lRet = CertVerifyTimeValidity(&ftDelta, pCertInfo);
    }

    return(lRet);
}


/*  GetCertsFromThumbprints:
**
**  Purpose:
**      Given a set of thumbprints, return an equivalent set of certificates.
**  Takes:
**      IN rgThumbprint - array of thumbprints to lookup
**      INOUT pResults  - the hr array contains error info for each cert
**                          lookup.  The pCert array has the certs.
**                          cEntries must be set on IN
**                          arrays must be alloc'd on IN
**      IN rghCertStore - set of stores to search
**      IN cCertStore   - size of rghCertStore
**  Returns:
**      MIME_S_SECURITY_ERROROCCURED if any of the lookups fail
**      (CERTIFICATE_NOT_PRESENT in the cs array for such cases)
**      MIME_S_SECURITY_NOOP if you call it with 0 in cEntries
**      E_INVALIDARG if any of the parameters are null
**      S_OK implies that all certs were found
**  Note:
**      only indexes with non-null thumbprints are considered
*/
MIMEOLEAPI  MimeOleGetCertsFromThumbprints(
                                           THUMBBLOB *const            rgThumbprint,
                                           X509CERTRESULT *const       pResults,
                                           const HCERTSTORE *const     rghCertStore,
                                           const DWORD                 cCertStore)
{
    HRESULT     hr;
    ULONG       iEntry, iStore;

    if (!(rgThumbprint &&
        pResults && pResults->rgpCert && pResults->rgcs &&
        rghCertStore && cCertStore))
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }
    if (0 == pResults->cEntries)
    {
        hr = MIME_S_SECURITY_NOOP;
        goto exit;
    }

    hr = S_OK;
    for (iEntry = 0; iEntry < pResults->cEntries; iEntry++)
    {
        if (rgThumbprint[iEntry].pBlobData)
        {
            for (iStore = 0; iStore < cCertStore; iStore++)
            {
                // We have a thumbprint, so do lookup
                pResults->rgpCert[iEntry] = CertFindCertificateInStore(rghCertStore[iStore],
                    X509_ASN_ENCODING,
                    0,                  //dwFindFlags
                    CERT_FIND_HASH,
                    (void *)(CRYPT_DIGEST_BLOB *)&(rgThumbprint[iEntry]),
                    NULL);
                if (pResults->rgpCert[iEntry])
                    {
                    break;
                    }
            }

            if (!pResults->rgpCert[iEntry])
            {
                DOUTL(1024, "CRYPT: Cert lookup failed.  #%d", iEntry);
                pResults->rgcs[iEntry] = CERTIFICATE_NOT_PRESENT;
                hr = MIME_S_SECURITY_ERROROCCURED;
            }
            else
            {
                // Validity check

                if (0 != CertVerifyTimeValidityWithDelta(NULL,
                  PCCERT_CONTEXT(pResults->rgpCert[iEntry])->pCertInfo,
                  TIME_DELTA_SECONDS))
                {
                    pResults->rgcs[iEntry] = CERTIFICATE_EXPIRED;
                }
                else
                {
                    pResults->rgcs[iEntry] = CERTIFICATE_OK;
                }
            }
        }
        else
        {
            CRDOUT("For want of a thumbprint... #%d", iEntry);
            pResults->rgpCert[iEntry] = NULL;
            pResults->rgcs[iEntry] = CERTIFICATE_NOPRINT;
            hr = MIME_S_SECURITY_ERROROCCURED;
        }
    }
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleMapSpecialCodePage
// --------------------------------------------------------------------------------
HRESULT MimeOleMapSpecialCodePage(CODEPAGEID cpIn, BOOL fRead, CODEPAGEID *pcpOut)
{
    // Locals
    DWORD           i;
    INETCSETINFO    CsetInfo;

    // Trace
    TraceCall("MimeOleMapSpecialCodePage");

    // Invalid Args
    if (NULL == pcpOut)
        return(TraceResult(E_INVALIDARG));

    // Initialize
    *pcpOut = cpIn;

    // Walk through the non-standard codepages list
    for (i=0; OENonStdCPs[i].Codepage != 0; i++)
    {
        // Is this it?
        if (OENonStdCPs[i].Codepage == cpIn)
        {
            // Read ?
            if (fRead && OENonStdCPs[i].cpRead)
                *pcpOut = OENonStdCPs[i].cpRead;

            // Send ?
            else if (OENonStdCPs[i].cpSend)
                *pcpOut = OENonStdCPs[i].cpSend;

            // Done
            break;
        }
    }

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// MimeOleMapCodePageToCharset
// --------------------------------------------------------------------------------
HRESULT MimeOleMapCodePageToCharset(CODEPAGEID cpIn, LPHCHARSET phCharset)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszCharset;
    CODEPAGEINFO    CodePage;

    // Trace
    TraceCall("MimeOleMapCodePageToCharset");

    // Invalid Args
    if (NULL == phCharset)
        return(TraceResult(E_INVALIDARG));

    // Get codepage info
    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(cpIn, &CodePage));

    // Default to using the body charset
    pszCharset = CodePage.szBodyCset;

    // Use WebCharset if body charset starts with '_' and the codepage is not 949
    if (*CodePage.szBodyCset != '_' && 949 != CodePage.cpiCodePage)
        pszCharset = CodePage.szWebCset;

    // Find the Charset
    IF_FAILEXIT(hr = MimeOleFindCharset(pszCharset, phCharset));

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MimeOleSplitMessage
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleSplitMessage(IMimeMessage *pMessage, ULONG cbMaxPart, IMimeMessageParts **ppParts)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cbMessage,
                        cbHeader,
                        cParts,
                        iPart,
                        cbActual,
                        cbRead=0,
                        cAttach,
                        i,
                        cbSubjectAddOn,
                        cbSubjectNew;
    LPHBODY             prghAttach=NULL;
    IStream            *pstmMsg=NULL,
                        *pstmPart=NULL;
    ULARGE_INTEGER      ulicbHeader;
    IMimePropertySet   *pRootProps=NULL;
    CMimeMessageParts  *pParts=NULL;
    IMimeMessage       *pmsgPart=NULL;
    FILETIME            ft;
    SYSTEMTIME          st;
    CHAR                szMimeId[CCHMAX_MID],
                        szNumber[30],
                        szFormat[50];
    MIMESAVETYPE        savetype;
    BODYOFFSETS         rOffsets;
    IMimeBody          *pRootBody=NULL;
    LPSTR               pszSubjectAddOn=NULL,
                        pszSubjectNew=NULL;
    PROPVARIANT         rVariant,
                        rSubject,
                        rFileName;
    float               dParts;
    HCHARSET            hCharset=NULL;
    INETCSETINFO        CsetInfo;

    // Invalid Arg
    if (NULL == ppParts)
        return TrapError(E_INVALIDARG);

    // Initialize Variants
    MimeOleVariantInit(&rSubject);
    MimeOleVariantInit(&rFileName);

    // Init
    *ppParts = NULL;

    // Get Option
    rVariant.vt = VT_UI4;
    pMessage->GetOption(OID_SAVE_FORMAT, &rVariant);
    savetype = (MIMESAVETYPE)rVariant.ulVal;

    // Raid-73119: OE : Kor: the charset for the message sent in broken apart is shown as "_autodetect_kr"
    if (SUCCEEDED(pMessage->GetCharset(&hCharset)))
    {
        // Get the charset info for the HCHARSET
        if (SUCCEEDED(MimeOleGetCharsetInfo(hCharset, &CsetInfo)))
        {
            // Map the codepage
            CODEPAGEID cpActual;
            
            // Map the codepage to the correct codepage..
            if (SUCCEEDED(MimeOleMapSpecialCodePage(CsetInfo.cpiInternet, FALSE, &cpActual)))
            {
                // If Different
                if (cpActual != CsetInfo.cpiInternet)
                {
                    // Map the codepage to a character set
                    MimeOleMapCodePageToCharset(cpActual, &hCharset);

                    // Reset the character set....
                    SideAssert(SUCCEEDED(pMessage->SetCharset(hCharset, CSET_APPLY_TAG_ALL)));
                }
            }
        }
    }

    // Get Message Source
    CHECKHR(hr = pMessage->GetMessageSource(&pstmMsg, COMMIT_ONLYIFDIRTY));

    // Create Parts Object
    CHECKALLOC(pParts = new CMimeMessageParts);

    // Rewind the stream
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Get Stream Size
    CHECKHR(hr = HrSafeGetStreamSize(pstmMsg, &cbMessage));

    // Is this size larger than the max part size
    if (cbMessage <= cbMaxPart)
    {
        // Add Single Parts to parts object
        CHECKHR(hr = pParts->AddPart(pMessage));

        // Done
        goto exit;
    }

    // Get the root body
    CHECKHR(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody));

    // Get Root body offset info
    CHECKHR(hr = pRootBody->GetOffsets(&rOffsets));

    // If the header is bigger than the max message size, we have a problem
    cbHeader = (ULONG)rOffsets.cbBodyStart - rOffsets.cbHeaderStart;
    if (cbHeader >= cbMessage || cbHeader + 256 >= cbMaxPart)
    {
        AssertSz(FALSE, "SplitMessage: The header is bigger than the max message size");
        hr = TrapError(MIME_E_MAX_SIZE_TOO_SMALL);
        goto exit;
    }

    // Get a copy of the root header
    CHECKHR(hr = pRootBody->Clone(&pRootProps));

    // Lets cleanup this header...
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTTYPE));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTDISP));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTDESC));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTID));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTLOC));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_MIMEVER));
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_CNTXFER));
    pRootProps->DeleteProp("Disposition-Notification-To");
    pRootProps->DeleteProp(PIDTOSTR(PID_HDR_MESSAGEID));

    // Compute the number of parts as a float
    dParts = (float)((float)cbMessage / (float)(cbMaxPart - cbHeader));

    // If dParts is not an integer, round up.
    cParts = (dParts - ((ULONG)dParts)) ? ((ULONG)dParts) + 1 : ((ULONG)dParts);

    // Set Max Parts in parts object
    CHECKHR(hr = pParts->SetMaxParts(cParts));

    // If MIME, create id
    if (SAVE_RFC1521 == savetype)
    {
        // Create Mime Id
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        wsprintf(szMimeId, "%08.8lX.%08.8lX@%s", ft.dwHighDateTime, ft.dwLowDateTime, (LPSTR)SzGetLocalHostName());

        // total=X
        wsprintf(szNumber, "%d", cParts);

        // number=x
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = szNumber;
        CHECKHR(hr = pRootProps->SetProp(STR_PAR_TOTAL, 0, &rVariant));

        // id=XXXX
        rVariant.pszVal = szMimeId;
        CHECKHR(hr = pRootProps->SetProp(STR_PAR_ID, 0, &rVariant));

        // MIME Version
        rVariant.pszVal = (LPSTR)c_szMimeVersion;
        CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_MIMEVER), 0, &rVariant));
    }

    // Otherwise, seek pstmMsg to end of header
    else
    {
        // Get Stream Position
        CHECKHR(hr = HrStreamSeekSet(pstmMsg, rOffsets.cbBodyStart));

        // Reduce the message size
        cbMessage -= rOffsets.cbBodyStart;
    }

    // Init the variant
    rSubject.vt = VT_LPSTR;

    // Get Subject
    if (FAILED(pRootBody->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject)))
        rSubject.pszVal = NULL;

    // Enumerate bodies and get the first file name and use it in the new subject...
    if (SUCCEEDED(pMessage->GetAttachments(&cAttach, &prghAttach)))
    {
        // Init the variant
        rFileName.vt = VT_LPSTR;

        // Loop Attached
        for (i=0; i<cAttach; i++)
        {
            // Get File Name...
            if (SUCCEEDED(pMessage->GetBodyProp(prghAttach[i], PIDTOSTR(PID_ATT_FILENAME), 0, &rFileName)))
                break;
        }
    }

    // Format Number
    wsprintf(szNumber, "%d", cParts);

    // Have a file name
    if (rFileName.pszVal)
    {
        // Make Format String...
        wsprintf(szFormat, "%%s [%%0%dd/%d]", lstrlen(szNumber), cParts);

        // Size of subject add on string
        cbSubjectAddOn = lstrlen(rFileName.pszVal) + lstrlen(szFormat) + lstrlen(szNumber) + 1;
    }

    // Otherwise, no filename
    else
    {
        // Make Format String...
        wsprintf(szFormat, "[%%0%dd/%d]", lstrlen(szNumber), cParts);

        // Size of subject add on string
        cbSubjectAddOn = lstrlen(szFormat) + lstrlen(szNumber) + 1;
    }

    // Allocate Subject Add On
    CHECKALLOC(pszSubjectAddOn = PszAllocA(cbSubjectAddOn));

    // Allocate new subject
    if (rSubject.pszVal)
        cbSubjectNew = cbSubjectAddOn + lstrlen(rSubject.pszVal) + 5;
    else
        cbSubjectNew = cbSubjectAddOn + 5;

    // Allocate Subject New
    CHECKALLOC(pszSubjectNew = PszAllocA(cbSubjectNew));

    // Loop throught the number of parts
    for (iPart=0; iPart<cParts; iPart++)
    {
        // Create a new stream...
        CHECKHR(hr = CreateTempFileStream(&pstmPart));

        // If MIME, I can do the partial stuff for them
        if (SAVE_RFC1521 == savetype)
        {
            // Content-Type: message/partial; number=X; total=X; id=XXXXXX
            rVariant.vt = VT_LPSTR;
            rVariant.pszVal = (LPSTR)STR_MIME_MSG_PART;
            CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));

            // number=X
            wsprintf(szNumber, "%d", iPart+1);
            rVariant.pszVal = szNumber;
            CHECKHR(hr = pRootProps->SetProp(STR_PAR_NUMBER, 0, &rVariant));
        }

        // Build Subject AddOn
        if (rFileName.pszVal)
            wsprintf(pszSubjectAddOn, szFormat, rFileName.pszVal, iPart + 1);
        else
            wsprintf(pszSubjectAddOn, szFormat, iPart + 1);

        // Build New Subject
        if (rSubject.pszVal)
            wsprintf(pszSubjectNew, "%s %s", rSubject.pszVal, pszSubjectAddOn);
        else
            wsprintf(pszSubjectNew, "%s", pszSubjectAddOn);

        // Set New Subject
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszSubjectNew;
        CHECKHR(hr = pRootProps->SetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant));

        // Save Root Header
        CHECKHR(hr = pRootProps->Save(pstmPart, TRUE));

        // Emit Line Break
        CHECKHR(hr = pstmPart->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

        // Copy bytes from lpstmMsg to pstmPart
        CHECKHR(hr = HrCopyStreamCBEndOnCRLF(pstmMsg, pstmPart, cbMaxPart - cbHeader, &cbActual));

        // Increment read
        cbRead += cbActual;

        // If cbActual is less than cbMaxMsgSize-cbHeader, better be the last part
#ifdef DEBUG
        if (iPart + 1 < cParts && cbActual < (cbMaxPart - cbHeader))
            AssertSz (FALSE, "One more partial message is going to be produced than needed. This should be harmless.");
#endif

        // Commit pstmPart
        CHECKHR(hr = pstmPart->Commit(STGC_DEFAULT));

        // Rewind it
        CHECKHR(hr = HrRewindStream(pstmPart));

        // Create Message Part...
        CHECKHR(hr = MimeOleCreateMessage(NULL, &pmsgPart));

        // Make the message build itself
        CHECKHR (hr = pmsgPart->Load(pstmPart));

        // We need another message and stream
        CHECKHR (hr = pParts->AddPart(pmsgPart));

        // Cleanup
        SafeRelease(pmsgPart);
        SafeRelease(pstmPart);
    }

    // Lets hope we read everything...
    AssertSz(cbRead == cbMessage, "Please let sbailey know if these fails.");

exit:
    // Succeeded
    if (SUCCEEDED(hr))
    {
        // Returns Parts Object
        (*ppParts) = pParts;
        (*ppParts)->AddRef();
    }

    // Cleanup
    SafeRelease(pRootBody);
    SafeRelease(pstmMsg);
    SafeRelease(pParts);
    SafeRelease(pRootProps);
    SafeRelease(pmsgPart);
    SafeRelease(pstmPart);
    SafeMemFree(pszSubjectAddOn);
    SafeMemFree(pszSubjectNew);
    SafeMemFree(prghAttach);
    MimeOleVariantFree(&rSubject);
    MimeOleVariantFree(&rFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CompareBlob
// --------------------------------------------------------------------------------
int CompareBlob(LPCBLOB pBlob1, LPCBLOB pBlob2)
{
    // Locals
    register int ret = 0;

    Assert(pBlob1 && pBlob2);

    if (pBlob1->cbSize != pBlob2->cbSize)
        ret = pBlob1->cbSize - pBlob2->cbSize;
    else
        ret = memcmp(pBlob1->pBlobData, pBlob2->pBlobData, pBlob2->cbSize);

    return ret;
}

// --------------------------------------------------------------------------------
// HrCopyBlob
// --------------------------------------------------------------------------------
HRESULT HrCopyBlob(LPCBLOB pIn, LPBLOB pOut)
{
    // Locals
    HRESULT hr;
    ULONG cb = 0;

    Assert(pIn && pOut);
    if (pIn->cbSize == 0)
    {
        pOut->cbSize = 0;
        pOut->pBlobData = NULL;
        return S_OK;
    }

    // Dup It...
    cb  = pIn->cbSize;
#ifdef _WIN64
    cb = LcbAlignLcb(cb);
#endif //_WIN64

    if (SUCCEEDED(hr = HrAlloc((LPVOID *)&pOut->pBlobData, cb)))
    {
        // Copy Memory
        CopyMemory(pOut->pBlobData, pIn->pBlobData, pIn->cbSize);

        // Set Size
        pOut->cbSize = pIn->cbSize;
    }
    else
    {
        pOut->cbSize = 0;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// PriorityFromStringA
// --------------------------------------------------------------------------------
IMSGPRIORITY PriorityFromStringA(LPCSTR pszPriority)
{
    // Locals
    IMSGPRIORITY priority=IMSG_PRI_NORMAL;
    DWORD        dwPriority;

    // If IsDigit...
    if (IsDigit((LPSTR)pszPriority))
    {
        // Convert
        dwPriority = (DWORD)StrToInt(pszPriority);

        // Map to pri type
        if (dwPriority <= 2)
            priority = IMSG_PRI_HIGH;
        else if (dwPriority > 3)
            priority = IMSG_PRI_LOW;
    }

    // Otheriwse, map from high, normal and low...
    else
    {
        // High, Highest, Low, Lowest
        if (lstrcmpi(pszPriority, STR_PRI_MS_HIGH) == 0)
            priority = IMSG_PRI_HIGH;
        else if (lstrcmpi(pszPriority, STR_PRI_MS_LOW) == 0)
            priority = IMSG_PRI_LOW;
        else if (lstrcmpi(pszPriority, STR_PRI_HIGHEST) == 0)
            priority = IMSG_PRI_HIGH;
        else if (lstrcmpi(pszPriority, STR_PRI_LOWEST) == 0)
            priority = IMSG_PRI_LOW;
    }

    // Done
    return priority;
}

// --------------------------------------------------------------------------------
// PriorityFromStringW
// --------------------------------------------------------------------------------
IMSGPRIORITY PriorityFromStringW(LPCWSTR pwszPriority)
{
    // Locals
    HRESULT      hr=S_OK;
    LPSTR        pszPriority=NULL;
    IMSGPRIORITY priority=IMSG_PRI_NORMAL;

    // Convert to ANSI
    CHECKALLOC(pszPriority = PszToANSI(CP_ACP, pwszPriority));

    // Normal Conversion
    priority = PriorityFromStringA(pszPriority);

exit:
    // Done
    return priority;
}

// --------------------------------------------------------------------------------
// MimeOleCompareUrlSimple
// --------------------------------------------------------------------------------
HRESULT MimeOleCompareUrlSimple(LPCSTR pszUrl1, LPCSTR pszUrl2)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        chUrl1;
    CHAR        chUrl2;

    // Skip leading white space
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Start the loop
    while(*pszUrl1 && *pszUrl2)
    {
        // Case Insensitive
        chUrl1 = TOUPPERA(*pszUrl1);
        chUrl2 = TOUPPERA(*pszUrl2);

        // Not Equal
        if (chUrl1 != chUrl2)
        {
            hr = S_FALSE;
            break;
        }

        // Next
        pszUrl1++;
        pszUrl2++;
    }

    // Skip over trailing whitespace
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // No substrings
    if ('\0' != *pszUrl1 || '\0' != *pszUrl2)
        hr = S_FALSE;

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCompareUrl
// --------------------------------------------------------------------------------
HRESULT MimeOleCompareUrl(LPCSTR pszCurrentUrl, BOOL fUnEscapeCurrent, LPCSTR pszCompareUrl, BOOL fUnEscapeCompare)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszUrl1=(LPSTR)pszCurrentUrl;
    LPSTR       pszUrl2=(LPSTR)pszCompareUrl;
    CHAR        chPrev='\0';
    CHAR        chUrl1;
    CHAR        chUrl2;
    ULONG       cb;

    // Stack Strings
    STACKSTRING_DEFINE(rCurrentUrl, 255);
    STACKSTRING_DEFINE(rCompareUrl, 255);

    // fUnEscapeCurrent
    if (fUnEscapeCurrent)
    {
        // Get Size
        cb = lstrlen(pszCurrentUrl) + 1;

        // Set Size
        STACKSTRING_SETSIZE(rCurrentUrl, cb);

        // Copy
        CopyMemory(rCurrentUrl.pszVal, pszCurrentUrl, cb);

        // Dupe It
        CHECKHR(hr = UrlUnescapeA(rCurrentUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Adjust pszUrl1
        pszUrl1 = rCurrentUrl.pszVal;
    }

    // fUnEscapeCurrent
    if (fUnEscapeCompare)
    {
        // Get Size
        cb = lstrlen(pszCompareUrl) + 1;

        // Set Size
        STACKSTRING_SETSIZE(rCompareUrl, cb);

        // Copy
        CopyMemory(rCompareUrl.pszVal, pszCompareUrl, cb);

        // Dupe It
        CHECKHR(hr = UrlUnescapeA(rCompareUrl.pszVal, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Adjust pszUrl2
        pszUrl2 = rCompareUrl.pszVal;
    }

    // Skip leading white space
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Start the loop
    while(*pszUrl1 && *pszUrl2)
    {
        // Case Insensitive
        chUrl1 = TOUPPERA(*pszUrl1);
        chUrl2 = TOUPPERA(*pszUrl2);

        // Special case search for '/'
        if (':' == chPrev && '/' == chUrl2 && '/' != *(pszUrl2 + 1) && '/' == chUrl1 && '/' == *(pszUrl1 + 1))
        {
            // Next
            pszUrl1++;

            // Done
            if ('\0' == *pszUrl1)
            {
                hr = S_FALSE;
                break;
            }

            // Rset chUrl1
            chUrl1 = TOUPPERA(*pszUrl1);
        }

        // Not Equal
        if (chUrl1 != chUrl2)
        {
            hr = S_FALSE;
            break;
        }

        // Save Prev
        chPrev = *pszUrl1;

        // Next
        pszUrl1++;
        pszUrl2++;
    }

    // Skip over trailing whitespace
    while(*pszUrl1 && (' ' == *pszUrl1 || '\t' == *pszUrl1))
        pszUrl1++;
    while(*pszUrl2 && (' ' == *pszUrl2 || '\t' == *pszUrl2))
        pszUrl2++;

    // Raid 63823: Mail : Content-Location Href's inside the message do not work if there is a Start Parameter in headers
    // Skim over remaining '/' in both urls
    while (*pszUrl1 && '/' == *pszUrl1)
        pszUrl1++;
    while (*pszUrl2 && '/' == *pszUrl2)
        pszUrl2++;

    // No substrings
    if ('\0' != *pszUrl1 || '\0' != *pszUrl2)
        hr = S_FALSE;

    // file://d:\test\foo.mhtml == d:\test\foo.mhtml
    if (S_FALSE == hr && StrCmpNI(pszCurrentUrl, "file:", 5) == 0)
    {
        // Skip over file:
        LPSTR pszRetryUrl = (LPSTR)(pszCurrentUrl + 5);

        // Skip over forward slashes
        while(*pszRetryUrl && '/' == *pszRetryUrl)
            pszRetryUrl++;

        // Compare Again
        hr = MimeOleCompareUrl(pszRetryUrl, fUnEscapeCurrent, pszCompareUrl, fUnEscapeCompare);
    }


exit:
    // Cleanup
    STACKSTRING_FREE(rCurrentUrl);
    STACKSTRING_FREE(rCompareUrl);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleWrapHeaderText
// --------------------------------------------------------------------------------
HRESULT MimeOleWrapHeaderText(CODEPAGEID codepage, ULONG cchMaxLine, LPCSTR pszLine,
    ULONG cchLine, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchIndex=0;
    ULONG       cchWrite;

    // Invalid Arg
    Assert(pszLine && pszLine[cchLine] == '\0' && pStream && cchMaxLine >= 2);

    // Start Writing
    while(1)
    {
        // Validate
        Assert(cchIndex <= cchLine);

        // Compute cchWrite
        cchWrite = min(cchLine - cchIndex, cchMaxLine - 2);

        // Done
        if (0 == cchWrite)
        {
            // Final Line Wrap
            CHECKHR(hr = pStream->Write(c_szCRLF, 2, NULL));

            // Done
            break;
        }

        // Write the line
        CHECKHR(hr = pStream->Write(pszLine + cchIndex, cchWrite, NULL));

        // If there is still more text
        if (cchIndex + cchWrite < cchLine)
        {
            // Write '\r\n\t'
            CHECKHR(hr = pStream->Write(c_szCRLFTab, 3, NULL));
        }

        // Increment iText
        cchIndex += cchWrite;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleCreateBody
// --------------------------------------------------------------------------------
HRESULT MimeOleCreateBody(IMimeBody **ppBody)
{
    HRESULT             hr;
    CMessageBody *pNew;

    pNew = new CMessageBody(NULL, NULL);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    hr = pNew->QueryInterface(IID_IMimeBody, (LPVOID *)ppBody);

    pNew->Release();
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleGetSentTime
// --------------------------------------------------------------------------------
HRESULT MimeOleGetSentTime(LPCONTAINER pContainer, DWORD dwFlags, LPMIMEVARIANT pValue)
{
    // Locals
    HRESULT hr=S_OK;

    // Get the data: header field
    if (FAILED(pContainer->GetProp(SYM_HDR_DATE, dwFlags, pValue)))
    {
        // Locals
        SYSTEMTIME  st;
        MIMEVARIANT rValue;

        // Setup rValue
        rValue.type = MVT_VARIANT;
        rValue.rVariant.vt = VT_FILETIME;

        // Get current systemtime
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &rValue.rVariant.filetime);

        // If the Conversion Fails, get the current time
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_SENTTIME, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mhtmlurl.h ===
// --------------------------------------------------------------------------------
// MHTMLURL.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __MHTMLURL_H
#define __MHTMLURL_H

#ifndef MAC
// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "privunk.h"
#include "inetprot.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CMessageTree;
typedef CMessageTree *LPMESSAGETREE;
class CMimeActiveUrlCache;
typedef class CActiveUrlRequest *LPURLREQUEST;

// --------------------------------------------------------------------------------
// Global Active Url Cache Object
// --------------------------------------------------------------------------------
extern CMimeActiveUrlCache *g_pUrlCache;

// --------------------------------------------------------------------------------
// REQSTATE_xxxx States
// --------------------------------------------------------------------------------
#define REQSTATE_RESULTREPORTED      0x00000001      // I have called ReportResult, don't call again
#define REQSTATE_DOWNLOADED          0x00000002      // The data is all present in pLockBytes
#define REQSTATE_BINDF_NEEDFILE      0x00000004      // Need to use a file

// --------------------------------------------------------------------------------
// CActiveUrlRequest
// --------------------------------------------------------------------------------
class CActiveUrlRequest : public CPrivateUnknown, 
                          public IOInetProtocol,
                          public IOInetProtocolInfo,
                          public IServiceProvider
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CActiveUrlRequest(IUnknown *pUnkOuter=NULL);
    virtual ~CActiveUrlRequest(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // ----------------------------------------------------------------------------
    // IOInetProtocol methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, IOInetBindInfo *pBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved);
    STDMETHODIMP Terminate(DWORD dwOptions);
    STDMETHODIMP Read(LPVOID pv,ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP LockRequest(DWORD dwOptions) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRequest(void) { return E_NOTIMPL; }
    STDMETHODIMP Suspend(void) { return E_NOTIMPL; }
    STDMETHODIMP Resume(void) { return E_NOTIMPL; }
    STDMETHODIMP Abort(HRESULT hrReason, DWORD dwOptions) { return E_NOTIMPL; }
    STDMETHODIMP Continue(PROTOCOLDATA *pStateInfo) { return E_NOTIMPL; }

    // ----------------------------------------------------------------------------
    // IServiceProvider methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void **ppvObj); /* IServiceProvider */

    // ----------------------------------------------------------------------------
    // IOInetProtocolInfo methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP ParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwCompareFlags) { return E_NOTIMPL; }
    STDMETHODIMP QueryInfo(LPCWSTR pwzUrl, QUERYOPTION OueryOption, DWORD dwQueryFlags, LPVOID pBuffer,DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved);

    // ----------------------------------------------------------------------------
    // Called from CMimeMessageTree during Binding
    // ----------------------------------------------------------------------------
    void OnFullyAvailable(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pWebBook, HBODY hBody);

    // Async Binding Methods
    void OnStartBinding(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pWebBook, HBODY hBody);
    void OnBindingDataAvailable(void);
    void OnBindingComplete(HRESULT hrResult);

    // ----------------------------------------------------------------------------
    // CActiveUrlRequest Members
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    void    _ReportResult(HRESULT hrResult);
    HRESULT _FillReturnString(LPCWSTR pszUrl, DWORD cchUrl, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult);
    HRESULT _HrStreamToNeedFile(void);
    HRESULT _HrReportData(void);
    HRESULT _HrInitializeNeedFile(LPMESSAGETREE pTree, HBODY hBody);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    IOInetProtocolSink *m_pProtSink;        // Protocol Sink from IOInetProtocol::Start
    IOInetBindInfo     *m_pBindInfo;        // BindInfo from IOInetProtocol::Start
    IStream            *m_pStream;          // The data source
    LPSTR               m_pszRootUrl;       // Root document Url
    LPSTR               m_pszBodyUrl;       // Body Url
    IUnknown           *m_pUnkKeepAlive;    // This protocol may activate an object
    LPURLREQUEST        m_pNext;            // Next Request
    LPURLREQUEST        m_pPrev;            // Prev Request
    DWORD               m_dwState;          // Keep track of some state
    HANDLE              m_hNeedFile;        // Need File
    DWORD               m_dwBSCF;           // Bind Status Callback Flags That I've Reported
    CRITICAL_SECTION    m_cs;               // Thread Safety

    // ----------------------------------------------------------------------------
    // Friend 
    // ----------------------------------------------------------------------------
    friend CMessageTree;             // Accesses, m_pszRootUrl, m_pNext, m_pPrev
};

// --------------------------------------------------------------------------------
// ACTIVEURL_xxx
// --------------------------------------------------------------------------------
#define ACTIVEURL_ISFAKEURL   0x00000001    // Specifies that the activeurl is a mid

// --------------------------------------------------------------------------------
// CActiveUrl
// --------------------------------------------------------------------------------
class CActiveUrl : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CActiveUrl(void);
    ~CActiveUrl(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // CActiveUrl Members
    // ---------------------------------------------------------------------------
    HRESULT Init(BINDF bindf, LPMESSAGETREE pWebBook);
    HRESULT IsActive(void);
    HRESULT CompareRootUrl(LPCSTR pszUrl);
    HRESULT BindToObject(REFIID riid, LPVOID *ppv);
    HRESULT CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, DWORD dwReserved, IMoniker **ppMoniker);
    void RevokeWebBook(LPMESSAGETREE pWebBook);
    CActiveUrl *PGetNext(void) { return m_pNext; }
    CActiveUrl *PGetPrev(void) { return m_pPrev; }
    void SetNext(CActiveUrl *pNext) { m_pNext = pNext; }
    void SetPrev(CActiveUrl *pPrev) { m_pPrev = pPrev; }
    void DontKeepAlive(void);

    // ---------------------------------------------------------------------------
    // CActiveUrl Inline Members
    // ---------------------------------------------------------------------------
    void SetFlag(DWORD dwFlags) {
        EnterCriticalSection(&m_cs);
        FLAGSET(m_dwFlags, dwFlags);
        LeaveCriticalSection(&m_cs);
    }

    BOOL FIsFlagSet(DWORD dwFlags) {
        EnterCriticalSection(&m_cs);
        BOOL f = ISFLAGSET(m_dwFlags, dwFlags);
        LeaveCriticalSection(&m_cs);
        return f;
    }

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                 m_cRef;         // Reference Count
    IUnknown            *m_pUnkAlive;    // Keep it alive
    IUnknown            *m_pUnkInner;    // The ActiveUrl's Inner Unknown
    LPMESSAGETREE        m_pWebBook;     // Pointer to the active Url
    CActiveUrl          *m_pNext;        // Next Active Url
    CActiveUrl          *m_pPrev;        // Prev Active Url
    DWORD                m_dwFlags;      // Flags
    CRITICAL_SECTION     m_cs;           // Thread Safety    
};
typedef CActiveUrl *LPACTIVEURL;

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache
// --------------------------------------------------------------------------------
class CMimeActiveUrlCache : public IUnknown
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeActiveUrlCache(void);
    ~CMimeActiveUrlCache(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // ObjectFromMoniker - Called from Trident
    // ---------------------------------------------------------------------------
    HRESULT ActiveObjectFromMoniker(
            /* in */        BINDF               bindf,
            /* in */        IMoniker            *pmkOriginal,
            /* in */        IBindCtx            *pBindCtx,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IMoniker            **ppmkNew);

    // ---------------------------------------------------------------------------
    // ObjectFromUrl - Called from CActiveUrlRequest::Start
    // ---------------------------------------------------------------------------
    HRESULT ActiveObjectFromUrl(
            /* in */        LPCSTR              pszRootUrl,
            /* in */        BOOL                fCreate,
            /* in */        REFIID              riid, 
            /* out */       LPVOID              *ppvObject,
            /* out */       IUnknown            **ppUnkKeepAlive);

    // ---------------------------------------------------------------------------
    // RegisterActiveObject - Called from CMimeMessageTree::CreateRootMoniker
    // ---------------------------------------------------------------------------
    HRESULT RegisterActiveObject(
            /* in */        LPCSTR              pszRootUrl,
            /* in */        LPMESSAGETREE       pWebBook);

    HRESULT RemoveUrl(LPACTIVEURL pActiveUrl);

private:
    // ---------------------------------------------------------------------------
    // Memory
    // ---------------------------------------------------------------------------
    void    _FreeActiveUrlList(BOOL fAll);
    void    _HandlePragmaNoCache(BINDF bindf, LPCSTR pszUrl);
    HRESULT _RegisterUrl(LPMESSAGETREE pWebBook, BINDF bindf, LPACTIVEURL *ppActiveUrl);
    HRESULT _ResolveUrl(LPCSTR pszUrl, LPACTIVEURL *ppActiveUrl);
    HRESULT _RemoveUrl(LPACTIVEURL pActiveUrl);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    ULONG               m_cActive;      // Number of active items
    LPACTIVEURL         m_pHead;        // Head Active Url
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

#endif	// !MAC

#endif // __MHTMLURL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mhtmlurl.cpp ===
// --------------------------------------------------------------------------------
// Mhtmlurl.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "mhtmlurl.h"
#include "icoint.h"
#include "dllmain.h"
#include "booktree.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <demand.h>
#include "icdebug.h"
#include "stmlock.h"
#include "strconst.h"
#include "mimeapi.h"

// --------------------------------------------------------------------------------
// TraceProtocol
// --------------------------------------------------------------------------------
#define TraceProtocol(_pszFunction) \
    DOUTL(APP_DOUTL, "%08x > 0x%08X CActiveUrlRequest::%s (RootUrl = '%s', BodyUrl = '%s')", GetCurrentThreadId(), this, _pszFunction, m_pszRootUrl ? m_pszRootUrl : "", m_pszBodyUrl ? m_pszBodyUrl : "")

// --------------------------------------------------------------------------------
// AcitveUrlRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeHtmlProtocol_CreateInstance(IUnknown *pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Set the mimeole compat mode
    MimeOleSetCompatMode(MIMEOLE_COMPAT_OE5);

    // Create me
    CActiveUrlRequest *pNew = new CActiveUrlRequest(pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::CActiveUrlRequest
// --------------------------------------------------------------------------------
CActiveUrlRequest::CActiveUrlRequest(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_pProtSink = NULL;
    m_pBindInfo = NULL;
    m_pszRootUrl = NULL;
    m_pszBodyUrl = NULL;
    m_pUnkKeepAlive = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_dwState = 0;
    m_pStream = NULL;
    m_hNeedFile = INVALID_HANDLE_VALUE;
    m_dwBSCF = 0;
    InitializeCriticalSection(&m_cs);
    TraceProtocol("CActiveUrlRequest");
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::~CActiveUrlRequest
// --------------------------------------------------------------------------------
CActiveUrlRequest::~CActiveUrlRequest(void)
{
    // Tracing
    TraceProtocol("~CActiveUrlRequest");

    // These should have been release in IOInetProtocl::Terminate
    Assert(NULL == m_pProtSink && NULL == m_pBindInfo && NULL == m_pUnkKeepAlive);

    // Release the protcol object just in case
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);
    SafeMemFree(m_pszRootUrl);
    SafeMemFree(m_pszBodyUrl);
    SafeRelease(m_pUnkKeepAlive);
    SafeRelease(m_pStream);

    // Close file...
    if (INVALID_HANDLE_VALUE != m_hNeedFile)
        CloseHandle(m_hNeedFile);

    // Kill the CS
    DeleteCriticalSection(&m_cs);

    // Release the Dll
    DllRelease();
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IOInetProtocol == riid)
        *ppv = (IOInetProtocol *)this;
    else if (IID_IOInetProtocolInfo == riid)
        *ppv = (IOInetProtocolInfo *)this;
    else if (IID_IOInetProtocolRoot == riid)
        *ppv = (IOInetProtocolRoot *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else
    {
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrInitializeNeedFile
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrInitializeNeedFile(LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szFilePath[MAX_PATH + MAX_PATH];
    ULONG       cch;
    LPSTR       pszFilePath=NULL;
    LPWSTR      pwszFile=NULL;

    // Invalid Args
    Assert(INVALID_HANDLE_VALUE == m_hNeedFile);

    // Don't need a file ?
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
        goto exit;

    // Set sizeof szFilePath
    cch = ARRAYSIZE(szFilePath);

    // If cid:
    if (!m_pszBodyUrl || StrCmpNIA(m_pszBodyUrl, "cid:", 4) == 0 || FAILED(PathCreateFromUrlA(m_pszBodyUrl, szFilePath, &cch, 0)))
    {
        // Create temp file (m_pszFileName could be null)
        CHECKHR(hr = CreateTempFile(NULL, NULL, &pszFilePath, &m_hNeedFile));
    }
    else
    {
        // Create temp file
        CHECKHR(hr = CreateTempFile(szFilePath, NULL, &pszFilePath, &m_hNeedFile));
    }

    // Convert To Unicode
    CHECKALLOC(pwszFile = PszToUnicode(CP_ACP, pszFilePath));

    // Enter global Critical Section
    DeleteTempFileOnShutdownEx(pszFilePath, NULL);

    // Don't Free this
    pszFilePath = NULL;

    // Report the File...
    SideAssert(SUCCEEDED(m_pProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, pwszFile)));

exit:
    // Cleanup
    SafeMemFree(pwszFile);
    SafeMemFree(pszFilePath);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnFullyAvailable
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnFullyAvailable(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Invalid Arg
    Assert(pszCntType && pStream);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && pStream && NULL == m_pStream);

    // Tracing
    TraceProtocol("OnFullyAvailable");

    // Feed the content-type to trident
    m_pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pszCntType);

    // GetNeedFile
    CHECKHR(hr = _HrInitializeNeedFile(pTree, hBody));

    // Create Stream Lock wrapper
    m_pStream = pStream;
    m_pStream->AddRef();

    // Rewind that bad boy
    CHECKHR(hr = HrRewindStream(m_pStream));

    // Were complete
    FLAGSET(m_dwState, REQSTATE_DOWNLOADED);

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_DATAFULLYAVAILABLE | BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION;

    // Go into report data loop
    CHECKHR(hr = _HrReportData());

    // First Report Data
    if (m_pProtSink)
        m_pProtSink->ReportResult(S_OK, 0, NULL);

    // We have reported the result
    FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnStartBinding
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnStartBinding(LPCWSTR pszCntType, IStream *pStream, LPMESSAGETREE pTree, HBODY hBody)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && pStream && NULL == m_pStream);

    // Tracing
    TraceProtocol("OnBinding(pszCntType, pStream)");

    // Feed the content-type to trident
    m_pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pszCntType ? pszCntType : L"application/octet-stream");

    // GetNeedFile
    CHECKHR(hr = _HrInitializeNeedFile(pTree, hBody));

    // Create Stream Lock wrapper
    m_pStream = pStream;
    m_pStream->AddRef();

    // Rewind that bad boy
    CHECKHR(hr = HrRewindStream(m_pStream));

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION;

    // Go into report data loop, if not writing to needfile (needfile is processed only when all the data is available)
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Report me some data
        CHECKHR(hr = _HrReportData());
    }

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnBindingDataAvailable
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnBindingDataAvailable(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Validate the state
    Assert(m_pProtSink && m_pStream);

    // Tracing
    TraceProtocol("OnBindingDataAvailable");

    // Initialize bind status callback falgs
    FLAGSET(m_dwBSCF, BSCF_INTERMEDIATEDATANOTIFICATION);

    // Go into report data loop, if not writing to needfile (needfile is processed only when all the data is available)
    if (FALSE == ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Report some data
        CHECKHR(hr = _HrReportData());
    }

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::OnBindingComplete
// --------------------------------------------------------------------------------
void CActiveUrlRequest::OnBindingComplete(HRESULT hrResult)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Were complete
    FLAGSET(m_dwState, INETPROT_DOWNLOADED);

    // Tracing
    TraceProtocol("OnBindingComplete");

    // No Sink ?
    if (NULL == m_pProtSink)
        return;

    // Failure
    if (FAILED(hrResult))
    {
        _ReportResult(hrResult);
        goto exit;
    }

    // Initialize bind status callback falgs
    m_dwBSCF = BSCF_DATAFULLYAVAILABLE | BSCF_AVAILABLEDATASIZEUNKNOWN | BSCF_FIRSTDATANOTIFICATION | BSCF_INTERMEDIATEDATANOTIFICATION | BSCF_LASTDATANOTIFICATION;

    // Report last amount of data
    CHECKHR(hr = _HrReportData());

    // Tell sink to use the default protocol
    m_pProtSink->ReportResult(S_OK, 0, NULL);

    // We have reported the result
    FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);

exit:
    // Failure
    if (FAILED(hr))
        _ReportResult(hr);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_ReportResult
// --------------------------------------------------------------------------------
void CActiveUrlRequest::_ReportResult(HRESULT hrResult)
{
    // Locals
    LPWSTR pwszRedirUrl=NULL;

    // We should have a sink
    Assert(m_pProtSink);

    // No Sink ?
    if (m_pProtSink && !ISFLAGSET(m_dwState, REQSTATE_RESULTREPORTED))
    {
        // If Failure
        if (FAILED(hrResult))
        {
            // If we have a body Url
            if (m_pszBodyUrl)
                pwszRedirUrl = PszToUnicode(CP_ACP, m_pszBodyUrl);

            // Report Result,
            if (pwszRedirUrl)
            {
                TraceProtocol("_ReportResult(BINDSTATUS_REDIRECTING)");
                m_pProtSink->ReportResult(INET_E_REDIRECTING, 0, pwszRedirUrl);
            }
            else
            {
                TraceProtocol("_ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER)");
                m_pProtSink->ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER, 0, NULL);
            }
        }

        // Otherwise, report the result
        else
        {
            TraceProtocol("_ReportResult(INET_E_USE_DEFAULT_PROTOCOLHANDLER)");
            m_pProtSink->ReportResult(S_OK, 0, NULL);
        }

        // Cleanup
        SafeMemFree(pwszRedirUrl);

        // We have reported the result
        FLAGSET(m_dwState, REQSTATE_RESULTREPORTED);
    }
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrReportData
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrReportData(void)
{
    // Locals
    HRESULT hr=S_OK;

    // We better have a data source
    Assert(m_pStream);

    // Tracing
    TraceProtocol("_HrReportData");

    // BINDF_NEEDFILE
    if (ISFLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE))
    {
        // Dump to File
        CHECKHR(hr = _HrStreamToNeedFile());
    }
    else
    {
        // Report Data
        SideAssert(SUCCEEDED(m_pProtSink->ReportData(m_dwBSCF, 0, 0)));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_HrStreamToNeedFile
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_HrStreamToNeedFile(void) 
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbTotal=0;

    // We better have a needfile
    Assert(INVALID_HANDLE_VALUE != m_hNeedFile && ISFLAGSET(m_dwState, REQSTATE_DOWNLOADED));

    // Write the stream to a file
    hr = WriteStreamToFileHandle(m_pStream, m_hNeedFile, &cbTotal);
    if (FAILED(hr) && E_PENDING != hr)
    {
        TrapError(hr);
        goto exit;
    }

    // Close the 77file
    CloseHandle(m_hNeedFile);
    m_hNeedFile = INVALID_HANDLE_VALUE;

    // Rewind the stream incase urlmon trys to read from me as well
    HrRewindStream(m_pStream);

    // All the data is there
    SideAssert(SUCCEEDED(m_pProtSink->ReportData(m_dwBSCF, 0, 0)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Start
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, 
    IOInetBindInfo *pBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved)
{
    // Locals
    HRESULT              hr=S_OK;
    LPSTR                pszUrl=NULL;
    LPMESSAGETREE        pTree=NULL;
    DWORD                dwBindF;
    BINDINFO 	         rBindInfo;

    // Invalid Args
    if (NULL == pwszUrl || NULL == pProtSink || NULL == pBindInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(g_pUrlCache && m_pProtSink == NULL && m_pBindInfo == NULL);

    // BINDF_NEEDFILE
    ZeroMemory(&rBindInfo, sizeof(BINDINFO));
    rBindInfo.cbSize = sizeof(BINDINFO);
	if (SUCCEEDED(pBindInfo->GetBindInfo(&dwBindF, &rBindInfo)) && ISFLAGSET(dwBindF, BINDF_NEEDFILE))
    {
        // Set Flag
        FLAGSET(m_dwState, REQSTATE_BINDF_NEEDFILE);
    }

    // Assume the Sink
    m_pProtSink = pProtSink;
    m_pProtSink->AddRef();

    // Assume the BindInfo
    m_pBindInfo = pBindInfo;
    m_pBindInfo->AddRef();

    // Dup the Url
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Split the Url
    CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &m_pszRootUrl, &m_pszBodyUrl));

    // Tracing
    TraceProtocol("Start");

    // Try to resolve the root url
    CHECKHR(hr = g_pUrlCache->ActiveObjectFromUrl(m_pszRootUrl, TRUE, IID_CMessageTree, (LPVOID *)&pTree, &m_pUnkKeepAlive));

    // Ask the BindTree to Resolve this Url
    CHECKHR(hr = pTree->HrActiveUrlRequest(this));

exit:
    // Cleanup
    SafeMemFree(pszUrl);
    SafeRelease(pTree);

    // Failure
    if (FAILED(hr))
        _ReportResult(E_FAIL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Terminate
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Terminate(DWORD dwOptions)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("Terminate");

    // Release Objects
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);
    SafeRelease(m_pUnkKeepAlive);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Read (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Read(LPVOID pv,ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;

    // Init
    if (pcbRead)
        *pcbRead = 0;

    // No Stream Yet
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Read from the external offset
    CHECKHR(hr = m_pStream->Read(pv, cb, &cbRead));

    // Done
    if (0 == cbRead)
    {
        // S_FALSE = Were Done, E_PENDING = more data is coming
        hr = (ISFLAGSET(m_dwState, INETPROT_DOWNLOADED)) ? S_FALSE : E_PENDING;
    }

    // Otherwise, set to ok
    else
        hr = S_OK;

    // Return pcbRead
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::Seek (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("Seek");

    // No Stream Yet
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Call Utility Function
    CHECKHR(hr = m_pStream->Seek(dlibMove, dwOrigin, plibNew));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::QueryService
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::QueryService(REFGUID rsid, REFIID riid, void **ppvObject) /* IServiceProvider */
{
    // Locals
    HRESULT             hr=S_OK;
    IServiceProvider   *pSP=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Tracing
    TraceProtocol("QueryService");

    // No Protocol Sink Yet ?
    if (NULL == m_pProtSink)
    {
        hr = TrapError(E_UNEXPECTED);
        goto exit;
    }

    // QI the Sink for the IServiceProvider
    CHECKHR(hr = m_pProtSink->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP));

    // Query Service the Service Provider
    CHECKHR(hr = pSP->QueryService(rsid, riid, ppvObject));

exit:
    // Cleanup
    SafeRelease(pSP);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::_FillReturnString
// --------------------------------------------------------------------------------
HRESULT CActiveUrlRequest::_FillReturnString(LPCWSTR pszUrl, DWORD cchUrl, LPWSTR pszResult, 
    DWORD cchResult, DWORD *pcchResult)
{
    // Locals
    HRESULT     hr=S_OK;

    // Want the Size
    if (pcchResult)
        *pcchResult = cchUrl;

    // No return value
    if (NULL == pszResult)
        goto exit;

    // Dest is big enought
    if (cchResult < cchUrl+1)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Copy to dest buffer
    CopyMemory((LPBYTE)pszResult, (LPBYTE)pszUrl, ((cchUrl + 1) * sizeof(WCHAR)));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::ParseUrl
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::ParseUrl(LPCWSTR pwzUrl, PARSEACTION ParseAction, 
    DWORD dwParseFlags, LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchUrl;
    LPSTR       pszUrl=NULL;
    LPSTR       pszRootUrl=NULL;
    LPSTR       pszBodyUrl=NULL;
    LPWSTR      pwszBodyUrl=NULL;
    LPWSTR      pszRootUrlW=NULL;
    LPWSTR      pszSecurityUrlW=NULL;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pwzUrl)
        return TrapError(E_INVALIDARG);
   
    // Tracing
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::ParseUrl (pwzUrl = %ls)", GetCurrentThreadId(), this, pwzUrl);

    // Setup Variant
    ZeroMemory(&rVariant, sizeof(PROPVARIANT));

    // Only handle PARSE_CANONICALIZE
    if (PARSE_CANONICALIZE == ParseAction)
    {
        // Fill return value
        CHECKHR(hr = _FillReturnString(pwzUrl, lstrlenW(pwzUrl), pwzResult, cchResult, pcchResult));
    }

    // Strip MHTML: and return
#ifndef WIN16
    else if (StrCmpNIW(pwzUrl, L"mhtml:", 6) == 0)
#else
    else if (StrCmpNIW(pwzUrl, "mhtml:", 6) == 0)
#endif // !WIN16
    {
        // If Getting Friendly
        if (PARSE_FRIENDLY == ParseAction)
        {
            // To ANSI
            CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwzUrl));

            // Split It
            CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, &pszBodyUrl));

            // Convert To Unicode
            CHECKALLOC(pwszBodyUrl = PszToUnicode(CP_ACP, pszBodyUrl));

            // Fill return value
            CHECKHR(hr = _FillReturnString(pwszBodyUrl, lstrlenW(pwszBodyUrl), pwzResult, cchResult, pcchResult));
        }

        // If the content-location is available, use it as the security URL
        else if (PARSE_SECURITY_URL == ParseAction)
        {
            BOOL            fGotSecURL = FALSE;
            LPMESSAGETREE   pTree=NULL;
            HBODY           hBody;
            IInternetSecurityManager *pISM;
            DWORD           dwZone=URLZONE_UNTRUSTED;
    
            // Base to ANSI
            CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwzUrl));

            // UnEscape the Url
            CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

            // Split It
            CHECKHR(hr = MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, &pszBodyUrl));

            // RootUrl to UNICODE
            CHECKALLOC(pszRootUrlW = PszToUnicode(CP_ACP, pszRootUrl));

            // Check and see what ZONE the root url is running in
            if (CoInternetCreateSecurityManager(NULL, &pISM, 0)==S_OK)
            {
                pISM->MapUrlToZone(pszRootUrlW, &dwZone, 0);
                pISM->Release();
            }

            // default to the root-body part 
            pszSecurityUrlW = pszRootUrlW;

            // if the root url is in the local-machine, then respect the Content-Location header
            // as the source of the url, otherwise defer to the root url
            if ((dwZone == URLZONE_LOCAL_MACHINE) && 
                SUCCEEDED(g_pUrlCache->ActiveObjectFromUrl(pszRootUrl, FALSE, IID_CMessageTree, (LPVOID *)&pTree, NULL)))
            {
                if ( (pszBodyUrl != NULL && SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszBodyUrl, 0, &hBody))) ||
                      SUCCEEDED(pTree->GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBody)))
                {
                    // Locals
                    LPWSTR      pwszSecURL = NULL;
                    PSUACTION   psua = (dwParseFlags == PSU_SECURITY_URL_ONLY)? PSU_SECURITY_URL_ONLY: PSU_DEFAULT;

                    rVariant.vt = VT_LPWSTR; 

                    if (SUCCEEDED(pTree->GetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)) && rVariant.pwszVal && *rVariant.pwszVal)
                    {
                        pszSecurityUrlW  = rVariant.pwszVal;
                    }
                    SafeMemFree(pwszSecURL);
                }
            }

            // Fill return value
            CHECKHR(hr = _FillReturnString(pszSecurityUrlW, lstrlenW(pszSecurityUrlW), pwzResult, cchResult, pcchResult));

            SafeRelease(pTree);
        }

        else if (PARSE_ENCODE == ParseAction)
        {
            hr = INET_E_DEFAULT_ACTION;
        }

        // Simply remove mhtml:
        else
        {
            // Fill return value
            CHECKHR(hr = _FillReturnString(pwzUrl + 6, lstrlenW(pwzUrl) - 6, pwzResult, cchResult, pcchResult));
        }
    }

    // INET_E_DEFAULT_ACTION
    else
    {
        hr = INET_E_DEFAULT_ACTION;
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszUrl);
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszRootUrlW);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pwszBodyUrl);
    SafeMemFree(rVariant.pwszVal);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrlRequest::QueryInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::QueryInfo(LPCWSTR pwzUrl, QUERYOPTION OueryOption, 
    DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD *pcbBuf, DWORD dwReserved)
{
    // QUERY_RECOMBINE
    if (QUERY_RECOMBINE == OueryOption)
    {
        // Sure
        if (cbBuffer < sizeof(DWORD))
            return S_FALSE;

        // True
        DWORD dw=TRUE;
        CopyMemory(pBuffer, &dw, sizeof(dw));
        *pcbBuf = sizeof(dw);

        // Done
        return S_OK;
    }

    // Failure
    return INET_E_QUERYOPTION_UNKNOWN;
}   

// --------------------------------------------------------------------------------
// CActiveUrlRequest::CombineUrl
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrlRequest::CombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, 
    LPWSTR pwzResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszBaseUrl=NULL;
    LPSTR           pszRootUrl=NULL;
    LPSTR           pszBodyUrl=NULL;
    LPSTR           pszRelativeUrl=NULL;
    LPSTR           pszNewUrl=NULL;
    LPSTR           pszDocUrl=NULL;
    LPSTR           pszPageUrl=NULL;
    LPWSTR          pwszBodyUrl=NULL;
    LPWSTR          pwszNewUrl=NULL;
    LPWSTR          pwszSource=NULL;
    BOOL            fCombine=FALSE;
    LPMESSAGETREE   pTree=NULL;
    ULONG           cchSource;
    ULONG           cchPrefix=lstrlen(c_szMHTMLColon);
    HBODY           hBody;

    // Invalid Arg
    if (NULL == pwzRelativeUrl)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // DebugTraceing
#ifndef WIN16
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::CombineUrl - Base = %ls, Relative = %ls", GetCurrentThreadId(), this, pwzBaseUrl ? pwzBaseUrl : L"" , pwzRelativeUrl ? pwzRelativeUrl : L"");
#else
    DOUTL(APP_DOUTL, "%08X > 0x%08X CActiveUrlRequest::CombineUrl - Base = %ls, Relative = %ls", GetCurrentThreadId(), this, pwzBaseUrl ? pwzBaseUrl : "" , pwzRelativeUrl ? pwzRelativeUrl : "");
#endif // !WIN16

    // Raid-42722: MHTML: Bookmarks don't work
    if (L'#' == pwzRelativeUrl[0])
    {
        hr = E_FAIL;
        goto exit;
    }

    // Convert relative to ANSI
    CHECKALLOC(pszRelativeUrl = PszToANSI(CP_ACP, pwzRelativeUrl));

    // We should UnEscape only Url, but doesn't touch a query
    CHECKHR(hr = UrlUnescapeA(pszRelativeUrl, NULL, NULL, URL_UNESCAPE_INPLACE | URL_DONT_ESCAPE_EXTRA_INFO));

    // If the relative is already mhtml:, then retur that...
    if (StrCmpNI(pszRelativeUrl, c_szMHTMLColon, cchPrefix) == 0)
    {
        // Split It
        CHECKHR(hr = MimeOleParseMhtmlUrl(pszRelativeUrl, &pszRootUrl, &pszBodyUrl));

        // If no body url, then just return pszRelativeUrl
        if (NULL == pszBodyUrl)
        {
            // Set pwszSource
            pwszSource = (LPWSTR)(pwzRelativeUrl + cchPrefix);

            // Get Length
            cchSource = lstrlenW(pwzRelativeUrl) - cchPrefix;

            // Done
            goto set_return;
        }
    }

    // Otherwise, build a new url
    else
    {
        // Base to ANSI
        CHECKALLOC(pszBaseUrl = PszToANSI(CP_ACP, pwzBaseUrl));

        // UnEscape the Url
        CHECKHR(hr = UrlUnescapeA(pszBaseUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

        // Split It
        CHECKHR(hr = MimeOleParseMhtmlUrl(pszBaseUrl, &pszRootUrl, &pszPageUrl));

        // Set pszBodyUrl
        pszBodyUrl = pszRelativeUrl;

        // Don't need pszRelativeUrl anymore
        pszRelativeUrl = NULL;
    }

    // Better have a root and a body url
    Assert(pszRootUrl && pszBodyUrl);

    // Try to resolve the root url
    if (SUCCEEDED(g_pUrlCache->ActiveObjectFromUrl(pszRootUrl, FALSE, IID_CMessageTree, (LPVOID *)&pTree, NULL)))
    {
        // If pszBodyUrl is in the WebBook or the bind is not finished...then do the url combine
        if (SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszBodyUrl, 0, NULL)) || pTree->IsState(TREESTATE_BINDDONE) == S_FALSE)
        {
            // Combine the Urls
            fCombine = TRUE;
        }
        // fCombine = TRUE;
    }

    // Should we combine
    if (fCombine)
    {
        // Allocate Some Memory
        CHECKALLOC(pszNewUrl = PszAllocA(cchPrefix + lstrlen(pszRootUrl) + lstrlen(pszBodyUrl) + 2));

        // Format the string
        wsprintf(pszNewUrl, "%s%s!%s", c_szMHTMLColon, pszRootUrl, pszBodyUrl);

        // Convert to unicode
        CHECKALLOC(pwszNewUrl = PszToUnicode(CP_ACP, pszNewUrl));

        // Get length
        cchSource = lstrlenW(pwszNewUrl);

        // Set Source
        pwszSource = pwszNewUrl;
    }

    // No Combine
    else
    {
        // If we have a WebBook
        if (pTree)
        {
            // If we don't have a page Url, then just call GetTextBody(html)
            if (NULL == pszPageUrl)
                MimeOleComputeContentBase(pTree, NULL, &pszDocUrl, NULL);

            // Otherwise, try to resolve the page url
            else if (SUCCEEDED(pTree->ResolveURL(NULL, NULL, pszPageUrl, 0, &hBody)))
                pszDocUrl = MimeOleContentBaseFromBody(pTree, hBody);

            // If we have Url
            if (pszDocUrl)
            {
                // Unescape It
                CHECKHR(hr = UrlUnescapeA(pszDocUrl, NULL, NULL, URL_UNESCAPE_INPLACE));
            }

            // Otheriwse, if the WebBook was loaded by a moniker, then use pszRootUrl
            else if (pTree->IsState(TREESTATE_LOADEDBYMONIKER) == S_OK)
            {
                // pszRootUrl is the pszDocUrl
                CHECKALLOC(pszDocUrl = PszDupA(pszRootUrl));
            }
        }

        // If there is a pszDocUrl
        if (pszDocUrl)
        {
            // Lets Combine with this url
            CHECKHR(hr = MimeOleCombineURL(pszDocUrl, lstrlen(pszDocUrl), pszBodyUrl, lstrlen(pszBodyUrl), FALSE, &pszNewUrl));

            // Convert to unicode
            CHECKALLOC(pwszNewUrl = PszToUnicode(CP_ACP, pszNewUrl));

            // Get length
            cchSource = lstrlenW(pwszNewUrl);

            // Set Source
            pwszSource = pwszNewUrl;
        }
        else
        {
            // Need a wide body Url
            CHECKALLOC(pwszBodyUrl = PszToUnicode(CP_ACP, pszBodyUrl));

            // Get length
            cchSource = lstrlenW(pwszBodyUrl);

            // Set Source
            pwszSource = pwszBodyUrl;
        }
    }

set_return:
    // Set Dest Size
    if (pcchResult)
        *pcchResult = cchSource;

    // No return value
    if (NULL == pwzResult)
        goto exit;

    // Dest is big enought
    if (cchResult <= cchSource)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Copy to dest buffer
    CopyMemory((LPBYTE)pwzResult, (LPBYTE)pwszSource, ((cchSource + 1) * sizeof(WCHAR)));

exit:
    // Cleanup
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszRelativeUrl);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pszNewUrl);
    SafeMemFree(pwszNewUrl);
    SafeMemFree(pszBaseUrl);
    SafeMemFree(pszDocUrl);
    SafeMemFree(pwszBodyUrl);
    SafeMemFree(pszPageUrl);
    SafeRelease(pTree);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::CActiveUrl
// --------------------------------------------------------------------------------
CActiveUrl::CActiveUrl(void)
{
    m_cRef = 1;
    m_pUnkAlive = NULL;
    m_pUnkInner = NULL;
    m_pWebBook = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_dwFlags = 0;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::~CActiveUrl
// --------------------------------------------------------------------------------
CActiveUrl::~CActiveUrl(void)
{
    SafeRelease(m_pUnkAlive);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CActiveUrl::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CActiveUrl::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CActiveUrl::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CActiveUrl::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CActiveUrl::Init
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::Init(BINDF bindf, LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better not have data
    Assert(NULL == m_pWebBook && NULL == m_pUnkInner);

    // No Message Object Passed in ?
    if (NULL == pTree)
    {
        // Allocate the Message Object
        CHECKALLOC(pTree = new CMessageTree);

        // Set pMessage
        m_pUnkAlive = pTree->GetInner();

        // Init
        CHECKHR(hr = pTree->InitNew());
    }

    // Set BINDF_PRAGMA_NO_CACHE
    if (ISFLAGSET(bindf, BINDF_RESYNCHRONIZE))
    {
        // Set State
        pTree->SetState(TREESTATE_RESYNCHRONIZE);
    }

    // Set pMessage
    m_pWebBook = pTree;

    // Get the Message Object's Inner Unknown
    m_pUnkInner = pTree->GetInner();

    // Register pActiveUrl as a handle in the message object
    m_pWebBook->SetActiveUrl(this);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::DontKeepAlive
// --------------------------------------------------------------------------------
void CActiveUrl::DontKeepAlive(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set pMessage
    if (m_pUnkAlive)
    {
        // Somebody should still have a refcount on this dude
        SideAssert(m_pUnkAlive->Release() > 0);

        // Null It
        m_pUnkAlive = NULL;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::IsActive
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::IsActive(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pWebBook ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::RevokeWebBook
// --------------------------------------------------------------------------------
void CActiveUrl::RevokeWebBook(LPMESSAGETREE pTree)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Arg
    Assert(NULL == pTree || m_pWebBook == pTree);

    // Revoke This from the message
    if (m_pWebBook)
        m_pWebBook->SetActiveUrl(NULL);

    // Null m_pWebBook
    m_pWebBook = NULL;
    m_pUnkInner = NULL;

    // Check Ref Count
    Assert(1 == m_cRef);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CActiveUrl::CompareRootUrl
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::CompareRootUrl(LPCSTR pszUrl)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Compare Root Url
    HRESULT hr = m_pWebBook ? m_pWebBook->CompareRootUrl(pszUrl) : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::BindToObject
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::BindToObject(REFIID riid, LPVOID *ppv)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Compare Root Url
    HRESULT hr = m_pUnkInner ? m_pUnkInner->QueryInterface(riid, ppv) : TrapError(E_FAIL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CActiveUrl::CreateWebPage
// --------------------------------------------------------------------------------
HRESULT CActiveUrl::CreateWebPage(IStream *pStmRoot, LPWEBPAGEOPTIONS pOptions, 
    DWORD dwReserved, IMoniker **ppMoniker)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Message
    if (NULL == m_pWebBook)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // CreateWebPage
    CHECKHR(hr = m_pWebBook->CreateWebPage(pStmRoot, pOptions, NULL, ppMoniker));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::CMimeActiveUrlCache
// --------------------------------------------------------------------------------
CMimeActiveUrlCache::CMimeActiveUrlCache(void)
{
    m_cRef = 1;
    m_cActive = 0;
    m_pHead = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::~CMimeActiveUrlCache
// --------------------------------------------------------------------------------
CMimeActiveUrlCache::~CMimeActiveUrlCache(void)
{
    _FreeActiveUrlList(TRUE);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_FreeActiveUrlList
// --------------------------------------------------------------------------------
void CMimeActiveUrlCache::_FreeActiveUrlList(BOOL fAll)
{
    // Locals
    LPACTIVEURL     pCurr;
    LPACTIVEURL     pNext;

    // Init
    pCurr = m_pHead;

    // All
    if (fAll)
    {
        // Loop and Free
        while(pCurr)
        {
            // Set Next
            pNext = pCurr->PGetNext();

            // Revoke the handle
            pCurr->RevokeWebBook(NULL);

            // Free the Active Url
            pCurr->Release();

            // Goto Next
            pCurr = pNext;
        }

        // No Active
        m_cActive = 0;
        m_pHead = NULL;
    }

    else
    {
        // Loop and Free
        while(pCurr)
        {
            // Set Next
            pNext = pCurr->PGetNext();

            // Revoke the handle
            if (pCurr->IsActive() == S_FALSE)
                _RemoveUrl(pCurr);

            // Goto Next
            pCurr = pNext;
        }
    }
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeActiveUrlCache::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeActiveUrlCache::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeActiveUrlCache::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_RegisterUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_RegisterUrl(LPMESSAGETREE pTree, BINDF bindf,
    LPACTIVEURL *ppActiveUrl)
{
    // Locals
    HRESULT         hr=S_OK;
    LPACTIVEURL     pActiveUrl=NULL;

    // Invalid Arg
    Assert(ppActiveUrl);

    // Init
    *ppActiveUrl = NULL;

    // Allocate an ActiveUrl
    CHECKALLOC(pActiveUrl = new CActiveUrl);

    // Init the Active Url
    CHECKHR(hr = pActiveUrl->Init(bindf, pTree));

    // Link Into Chain
    if (NULL == m_pHead)
        m_pHead = pActiveUrl;
    else
    {
        pActiveUrl->SetNext(m_pHead);
        m_pHead->SetPrev(pActiveUrl);
        m_pHead = pActiveUrl;
    }

    // Increment Count
    m_cActive++;

    // Return It
    *ppActiveUrl = pActiveUrl;
    pActiveUrl = NULL;

exit:
    // Release the Active Url
    SafeRelease(pActiveUrl);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_ResolveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_ResolveUrl(LPCSTR pszUrl, LPACTIVEURL *ppActiveUrl)
{
    // Locals
    HRESULT     hr=S_OK;
    LPACTIVEURL pActiveUrl;

    // Invalid Arg
    Assert(pszUrl && ppActiveUrl);

    // Init
    *ppActiveUrl = NULL;

    // Should not have mhtml:
    Assert(StrCmpNI(pszUrl, "mhtml:", 6) != 0);

    // Walk the Table
    for (pActiveUrl=m_pHead; pActiveUrl!=NULL; pActiveUrl=pActiveUrl->PGetNext())
    {
        // Is this the Url
        if (pActiveUrl->CompareRootUrl(pszUrl) == S_OK)
        {
            // Return the Active Url
            *ppActiveUrl = pActiveUrl;

            // Done
            goto exit;
        }
    }

    // Not Found
    hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_RemoveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::_RemoveUrl(LPACTIVEURL pActiveUrl)
{
    EnterCriticalSection(&m_cs);

    // Fixup Linked List
    LPACTIVEURL pNext = pActiveUrl->PGetNext();
    LPACTIVEURL pPrev = pActiveUrl->PGetPrev();

    // Fixup
    if (pPrev)
        pPrev->SetNext(pNext);
    if (pNext)
        pNext->SetPrev(pPrev);

    // Fixup m_pHead
    if (m_pHead == pActiveUrl)
        m_pHead = pNext;

    // Revoke the handle
    pActiveUrl->RevokeWebBook(NULL);

    // Release the ActiveUrl
    SideAssert(0 == pActiveUrl->Release());

    // One less active 
    m_cActive--;

    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::RemoveUrl
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::RemoveUrl(LPACTIVEURL pActiveUrl)
{
    return _RemoveUrl(pActiveUrl);
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::_HandlePragmaNoCache
// --------------------------------------------------------------------------------
void CMimeActiveUrlCache::_HandlePragmaNoCache(BINDF bindf, LPCSTR pszUrl)
{
    // Locals
    CActiveUrl *pActiveUrl;

    // Invalid Arg
    Assert(pszUrl);

    // BINDF_PRAGMA_NO_CACHE - Reload the WebBook from original source (can't do if activeurl has a fake url)
    if (ISFLAGSET((DWORD)bindf, BINDF_PRAGMA_NO_CACHE))
    {
        // Try to find the ActiveUrl associated with pszUrl
        if (SUCCEEDED(_ResolveUrl(pszUrl, &pActiveUrl)))
        {
            // If it is a fakeurl, then lets not unload it
            if (FALSE == pActiveUrl->FIsFlagSet(ACTIVEURL_ISFAKEURL))
            {
                // Kill it from the cache so that its not found and reloaded
                _RemoveUrl(pActiveUrl);
            }
        }
    }
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::ActiveObjectFromMoniker - Called from Trident
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::ActiveObjectFromMoniker(
        /* in */        BINDF               bindf,
        /* in */        IMoniker            *pmkOriginal,
        /* in */        IBindCtx            *pBindCtx,
        /* in */        REFIID              riid, 
        /* out */       LPVOID              *ppvObject,
        /* out */       IMoniker            **ppmkNew)
{
    // Locals
    HRESULT             hr=S_OK;
    LPWSTR              pwszUrl=NULL;
    LPSTR               pszUrl=NULL;
    LPSTR               pszRootUrl=NULL;
    IMoniker           *pMoniker=NULL;
    IPersistMoniker    *pPersist=NULL;
    LPACTIVEURL         pActiveUrl=NULL;
    BOOL                fAsync=FALSE;
    WEBPAGEOPTIONS      Options={0};

    // Invalid Arg
    if (NULL == pmkOriginal || NULL == ppvObject || NULL == ppmkNew)
        return TrapError(E_INVALIDARG);

    // Init
    *ppmkNew = NULL;
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the Url from the Moniker
    CHECKHR(hr = pmkOriginal->GetDisplayName(NULL, NULL, &pwszUrl));

    // Convert to ANSI
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Unescape inplace
    CHECKHR(hr = UrlUnescapeA(pszUrl, NULL, NULL, URL_UNESCAPE_INPLACE));

    // Raid-2508: Comment tag ( <! comment> ) doesn't work in mhtml
    if (StrCmpNI(pszUrl, c_szMHTMLColon, lstrlen(c_szMHTMLColon)) != 0)
    {
        // Fixup
        ReplaceChars(pszUrl, '!', '_');
    }

    // Free pwszUrl
    SafeMemFree(pwszUrl);

    // This will fail if pszUrl is not an mhtml: url, if it succeeds it gives me the part Url
    if (SUCCEEDED(MimeOleParseMhtmlUrl(pszUrl, &pszRootUrl, NULL)))
    {
        // _HandlePragmaNoCache
        _HandlePragmaNoCache(bindf, pszRootUrl);

        // See if pszUrl - mhtml: is an active Url
        if (FAILED(_ResolveUrl(pszRootUrl, &pActiveUrl)))
        {
            // Register an ActiveUrl
            CHECKHR(hr = _RegisterUrl(NULL, bindf, &pActiveUrl));

            // Convert pszRootUrl to a wide
            CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszRootUrl));

            // Create an Actual Url Moniker
            CHECKHR(hr = CreateURLMoniker(NULL, pwszUrl, &pMoniker));

            // Get an IPersistMoniker
            CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

            // Load the message with pmkOriginal
            hr = pPersist->Load(FALSE, pMoniker, NULL, 0);
            if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
            {
                hr = TrapError(hr);
                goto exit;
            }

            // Otheriwse, good
            hr = S_OK;
        }

        // Return pmkOriginal
        (*ppmkNew) = pmkOriginal;
        (*ppmkNew)->AddRef();

        // QI for the requested object iid
        CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));
    }

    // Otherwise Simply see if this Url is Active
    else 
    {
        // _HandlePragmaNoCache
        _HandlePragmaNoCache(bindf, pszUrl);

        // Try to resolve this url
        if (FAILED(_ResolveUrl(pszUrl, &pActiveUrl)))
        {
            // Register an ActiveUrl
            CHECKHR(hr = _RegisterUrl(NULL, bindf, &pActiveUrl));

            // Get an IPersistMoniker
            CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

            // Load the message with pmkOriginal
            hr = pPersist->Load(FALSE, pmkOriginal, pBindCtx, 0);
            if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
            {
                hr = TrapError(hr);
                goto exit;
            }

            // Otheriwse, good
            hr = S_OK;
        }

        // Setup WebPage Options
        Options.cbSize = sizeof(WEBPAGEOPTIONS);
        Options.dwFlags = WPF_NOMETACHARSET | WPF_HTML | WPF_AUTOINLINE;
        
        // Create the root moniker
        CHECKHR(hr = pActiveUrl->CreateWebPage(NULL, &Options, 0, ppmkNew));

        // QI for the requested object iid
        CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));

        // Don't Keep Alive, assume ppvObject controls the lifetime, not pActiveUrl
        pActiveUrl->DontKeepAlive();
    }

exit:
    // Cleanup
    SafeRelease(pPersist);
    SafeRelease(pMoniker);
    SafeMemFree(pszRootUrl);
    SafeMemFree(pszUrl);
    SafeMemFree(pwszUrl);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Failed, return hr, otherwise, return MK_S_ASYNCHRONOUS if going async
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::ActiveObjectFromUrl - Called from CActiveUrlRequest::Start
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::ActiveObjectFromUrl(
        /* in */        LPCSTR              pszRootUrl,
        /* in */        BOOL                fCreate,
        /* in */        REFIID              riid, 
        /* out */       LPVOID              *ppvObject,
        /* out */       IUnknown            **ppUnkKeepAlive)
{
    // Locals
    HRESULT          hr=S_OK;
    LPWSTR           pwszUrl=NULL;
    LPACTIVEURL      pActiveUrl;
    IMoniker        *pMoniker=NULL;
    IPersistMoniker *pPersist=NULL;

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == ppvObject || (TRUE == fCreate && NULL == ppUnkKeepAlive))
        return TrapError(E_INVALIDARG);

    // Better not start with mhtml:
    Assert(StrCmpNI(pszRootUrl, "mhtml:", 6) != 0);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Try to resolve this url
    if (FAILED(_ResolveUrl(pszRootUrl, &pActiveUrl)))
    {
        // NoCreate ?
        if (FALSE == fCreate)
        {
            hr = TrapError(MIME_E_NOT_FOUND);
            goto exit;
        }

        // Register an ActiveUrl
        CHECKHR(hr = _RegisterUrl(NULL, (BINDF)0, &pActiveUrl));

        // Convert pszRootUrl to a wide
        CHECKALLOC(pwszUrl = PszToUnicode(CP_ACP, pszRootUrl));

        // Create an Actual Url Moniker
        CHECKHR(hr = CreateURLMoniker(NULL, pwszUrl, &pMoniker));

        // Get an IPersistMoniker
        CHECKHR(hr = pActiveUrl->BindToObject(IID_IPersistMoniker, (LPVOID *)&pPersist));

        // Load the message with pmkOriginal
        hr = pPersist->Load(FALSE, pMoniker, NULL, 0);
        if (FAILED(hr) && E_PENDING != hr && MK_S_ASYNCHRONOUS != hr)
        {
            hr = TrapError(hr);
            goto exit;
        }

        // Return the IUnknown Keep Alive Object
        CHECKHR(hr = pActiveUrl->BindToObject(IID_IUnknown, (LPVOID *)ppUnkKeepAlive));

        // Don't Keep Alive, assume ppvObject controls the lifetime, not pActiveUrl
        pActiveUrl->DontKeepAlive();
    }

    // Return an Interface
    CHECKHR(hr = pActiveUrl->BindToObject(riid, ppvObject));

exit:
    // Cleanup
    SafeMemFree(pwszUrl);
    SafeRelease(pMoniker);
    SafeRelease(pPersist);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeActiveUrlCache::RegisterActiveObject
// --------------------------------------------------------------------------------
HRESULT CMimeActiveUrlCache::RegisterActiveObject(
        /* in */        LPCSTR               pszRootUrl,
        /* in */        LPMESSAGETREE        pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPCSTR          pszUrl;
    LPACTIVEURL     pActiveUrl;

    // Invalid Arg
    if (NULL == pszRootUrl || NULL == pTree)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better start with mhtml:
    Assert(StrCmpNI(pszRootUrl, "mhtml:", 6) == 0);

    // Fixup pszUrl
    pszUrl = (pszRootUrl + 6);

    // Better not already be running
    if (SUCCEEDED(_ResolveUrl(pszUrl, &pActiveUrl)))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Register an ActiveUrl
    CHECKHR(hr = _RegisterUrl(pTree, (BINDF)0, &pActiveUrl));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mimeapi.h ===
// --------------------------------------------------------------------------------
// Mimeapi.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIMEAPI_H
#define __MIMEAPI_H

// Time to allow cert start times to be be early
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CMimePropertyContainer;
typedef CMimePropertyContainer *LPCONTAINER;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
int          CompareBlob(LPCBLOB pBlob1, LPCBLOB pBlob2);
HRESULT      HrCopyBlob(LPCBLOB pIn, LPBLOB pOut);
IMSGPRIORITY PriorityFromStringA(LPCSTR pszPriority);
IMSGPRIORITY PriorityFromStringW(LPCWSTR pwszPriority);
HRESULT      MimeOleCompareUrl(LPCSTR pszCurrentUrl, BOOL fUnEscapeCurrent, LPCSTR pszComareUrl, BOOL fUnEscapeCompare);
HRESULT      MimeOleCompareUrlSimple(LPCSTR pszUrl1, LPCSTR pszUrl2);
HRESULT      MimeOleWrapHeaderText(CODEPAGEID codepage, ULONG cchMaxLine, LPCSTR pszLine, ULONG cchLine, LPSTREAM pStream);
HRESULT      MimeOleRecurseSetProp(IMimeMessageTree *pTree, HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue);
HRESULT      HrRfc1522Encode(LPMIMEVARIANT pSource, LPMIMEVARIANT pEncoded, CODEPAGEID cpiSource, CODEPAGEID cpiDest, LPCSTR pszCharset, LPSTR *ppszEncoded);
LPCSTR       PszDefaultSubType(LPCSTR pszPriType);
HRESULT      MimeOleGetSentTime(LPCONTAINER pContainer, DWORD dwFlags, LPMIMEVARIANT pValue);
CODEPAGEID   MimeOleGetWindowsCPEx(LPINETCSETINFO pCharset);
CODEPAGEID   MimeOleGetWindowsCP(HCHARSET hCharset);
LPSTR        MimeOleContentBaseFromBody(IMimeMessageTree *pTree, HBODY hBody);
HRESULT      MimeOleComputeContentBase(IMimeMessage *pMessage, HBODY hRelated, LPSTR *ppszBase, BOOL *pfMultipartBase);
LONG         CertVerifyTimeValidityWithDelta(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo, ULONG ulOffset);
MIMEOLEAPI   MimeOleEscapeStringW(LPCWSTR pszIn, LPWSTR *ppszOut);
HRESULT      MimeOleQueryStringW(LPCWSTR pszSearchMe, LPCWSTR pszCriteria, boolean fSubString, boolean fCaseSensitive);
MIMEOLEAPI   MimeOleGenerateFileNameW(LPCSTR pszContentType, LPCWSTR pszSuggest, LPCWSTR pszDefaultExt, LPWSTR *ppszFileName);

#endif // __MIMEAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\objheap.h ===
// --------------------------------------------------------------------------------
// Objheap.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __OBJHEAP_H
#define __OBJHEAP_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef struct tagPROPERTY *LPPROPERTY;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagTREENODEINFO *LPTREENODEINFO;
typedef struct tagMIMEADDRESS *LPMIMEADDRESS;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void    InitObjectHeaps(void);
void    FreeObjectHeaps(void);
HRESULT ObjectHeap_HrAllocProperty(LPPROPERTY *ppProperty);
HRESULT ObjectHeap_HrAllocAddress(LPMIMEADDRESS *ppAddress);
void    ObjectHeap_FreeProperty(LPPROPERTY pProperty);
void    ObjectHeap_FreeAddress(LPMIMEADDRESS pAddress);

#endif // __OBJHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\objres.cpp ===
#include "pch.hxx"
#include "objres.h"
#include "msoedbg.h"
#include "dllmain.h"
#include "mhtmlurl.h"

// =================================================================================
// Wrapper for Trident
// =================================================================================

STDMETHODIMP CMimeObjResolver::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    TraceCall("CMimeObjResolver::QueryInterface");

    if(!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = SAFECAST(this, IUnknown *);
    else if (IsEqualIID(riid, IID_IMimeObjResolver))
        *ppvObj = SAFECAST(this, IMimeObjResolver *);
    else
        return E_NOINTERFACE;
    
    InterlockedIncrement(&m_cRef);
    return NOERROR;
}

STDMETHODIMP_(ULONG) CMimeObjResolver::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMimeObjResolver::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (cRef > 0)
        return (ULONG)cRef;

    delete this;
    return 0;
}
    

//***************************************************
HRESULT CMimeObjResolver::CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMimeObjResolver *pNew = new CMimeObjResolver(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IUnknown *);

    // Done
    return S_OK;
}

HRESULT CMimeObjResolver::MimeOleObjectFromMoniker(BINDF bindf, IMoniker *pmkOriginal, 
                                                   IBindCtx *pBindCtx, REFIID riid, 
                                                   LPVOID *ppvObject, IMoniker **ppmkNew)
{
    Assert(g_pUrlCache);
    if (g_pUrlCache)
        return (g_pUrlCache->ActiveObjectFromMoniker(bindf, pmkOriginal, pBindCtx, riid, ppvObject, ppmkNew));
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\objheap.cpp ===
// --------------------------------------------------------------------------------
// Objheap.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "objheap.h"
#include "dllmain.h"
#include "containx.h"

#include "stddef.h"
#include "objpool.h"

// --------------------------------------------------------------------------------
// Object Heap Limits
// --------------------------------------------------------------------------------
#define COBJHEAPMAX_BODY    100
#define COBJHEAPMAX_ADDR    100
#define COBJHEAPMAX_PROP    200

// --------------------------------------------------------------------------------
// Object Heap Definitions
// --------------------------------------------------------------------------------

class CPropAlloc : public CAllocObjWithIMalloc<PROPERTY,offsetof(PROPERTY,pNextValue)>
{
    public:
        static void CleanObject(PROPERTY *pProperty) {
            // Free name ?
            if (ISFLAGSET(pProperty->dwState, PRSTATE_ALLOCATED) && pProperty->pbBlob)
            {
                Assert(pProperty->pbBlob != pProperty->rgbScratch);
                g_pMalloc->Free(pProperty->pbBlob);
                pProperty->pbBlob = NULL;
            }

            // Release Address Group
            SafeMemFree(pProperty->pGroup);
            CAllocObjWithIMalloc<PROPERTY,offsetof(PROPERTY,pNextValue)>::CleanObject(pProperty);
        };
};
class CAddrAlloc : public CAllocObjWithIMalloc<MIMEADDRESS,offsetof(MIMEADDRESS,pNext)>
{
    public:
        static void CleanObject(MIMEADDRESS *pAddress) {

            MimeAddressFree(pAddress);

            // We don't actually need to do this - since the base object's
            // CleanObject() just does a memset(), and the MimeAddressFree()
            // method above also does a memset().  So we'll just comment it
            // out, and save outselves the bandwidth on the memory bus...
            // CAllocObjWithIMalloc<MIMEADDRESS,g_pMalloc>::CleanObject(pAddress);

        };
};

static CAutoObjPoolMulti<PROPERTY,offsetof(PROPERTY,pNextValue),CPropAlloc> g_PropPool;
static CAutoObjPool<MIMEADDRESS,offsetof(MIMEADDRESS,pNext),CAddrAlloc> g_AddrPool;

// ---------------------------------------------------------------------------
// InitObjectHeaps
// ---------------------------------------------------------------------------
void InitObjectHeaps(void)
{
    g_PropPool.Init(COBJHEAPMAX_PROP);
    g_AddrPool.Init(COBJHEAPMAX_ADDR);
}

// ---------------------------------------------------------------------------
// FreeObjectHeaps
// ---------------------------------------------------------------------------
void FreeObjectHeaps(void)
{
    g_AddrPool.Term();
    g_PropPool.Term();
}

// ---------------------------------------------------------------------------
// ObjectHeap_HrAllocProperty
// ---------------------------------------------------------------------------
HRESULT ObjectHeap_HrAllocProperty(LPPROPERTY *ppProperty)
{
    *ppProperty = g_PropPool.GetFromPool();
    if (NULL == *ppProperty)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// --------------------------------------------------------------------------------
// ObjectHeap_HrAllocAddress
// --------------------------------------------------------------------------------
HRESULT ObjectHeap_HrAllocAddress(LPMIMEADDRESS *ppAddress)
{
    *ppAddress = g_AddrPool.GetFromPool();
    if (NULL == *ppAddress)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// ---------------------------------------------------------------------------
// ObjectHeap_FreeProperty
// ---------------------------------------------------------------------------
void ObjectHeap_FreeProperty(LPPROPERTY pProperty)
{
    g_PropPool.AddToPool(pProperty);
}

// ---------------------------------------------------------------------------
// ObjectHeap_FreeAddress
// ---------------------------------------------------------------------------
void ObjectHeap_FreeAddress(LPMIMEADDRESS pAddress)
{
    g_AddrPool.AddToPool(pAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\objpool.h ===
#ifndef __OBJPOOL_INC
#define __OBJPOOL_INC

// --------------------------------------------------------------------------------
// ObjPool.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Don Dumitru (dondu@microsoft.com)
// --------------------------------------------------------------------------------

/*
    Typical usage of this set of templates is like this:

    Say you want to provide a pool of structs of type PROPERTY.  You
    would first define the allocator class that you want to use for
    allocating those structs - if you wanted to use operator new and
    operator delete, you would do this...
        typedef CAllocObjWithNew<PROPERTY> PROPERTY_ALLOCATOR;
    Now, you can define a pool of PROPERTY structs, using that allocator
    class, by doing this...
        typedef CAutoObjPool<PROPERTY,offsetof(PROPERTY,pNext),PROPERTY_ALLOCATOR> PROPERTY_POOL;
    and then declare instances of the PROPERTY pool by doing this...
        PROPERTY_POOL g_PropPool;

    If you want to use a different allocator, just change the definition of
    the PROPERTY_ALLOCATOR typedef - templates for using operator new and
    operator delete, or for using an instance of interface IMalloc are
    provided.  Or you can implement your own allocator class using
    whatever mechanism you want.

    If for some reason you can't use the provided auto-allocator mechanism
    in CAutoObjPool<> (maybe you need to pass parameters to the constructor
    or somesuch - although you might be able to solve that by how you define
    the allocator class...), you can implement your own version of
    CAutoObjPool<> which does it the way you want.

    One feature of this set of templates is the ability to adjust the size
    of the pool.  This would let you, for example, adjust the pool size up
    as container objects were allocated, and adjust it back down as those
    container objects were freed.  This would let the pool be sized based
    on how many container objects were being held by the application - so
    the overall caching strategy of the subsystem would be responsive to
    how the top-level objects were being cached by the application.
*/

//#include <stdarg.h>

// Since InterlockedExchangeAdd is not available on Win95, we'll just
// disable all of this stats stuff...
#if 0
class CPoolStatsDebug {
    public:
        CPoolStatsDebug() {
            m_lTotalAllocs = 0;
            m_lFailedAllocs = 0;
            m_lTotalAllocOverhead = 0;
            m_lTotalFrees = 0;
            m_lFailedFrees = 0;
            m_lTotalFreeOverhead = 0;
        };
        void AllocSuccess(DWORD dwOverhead) {
            InterlockedIncrement(&m_lTotalAllocs);
            InterlockedExchangeAdd(&m_lTotalAllocOverhead,dwOverhead);
        };
        void AllocFail() {
            InterlockedIncrement(&m_lTotalAllocs);
            InterlockedIncrement(&m_lFailedAllocs);
        };
        void FreeSuccess(DWORD dwOverhead) {
            InterlockedIncrement(&m_lTotalFrees);
            InterlockedExchangeAdd(&m_lTotalFreeOverhead,dwOverhead);
        };
        void FreeFail() {
            InterlockedIncrement(&m_lTotalFrees);
            InterlockedIncrement(&m_lFailedFrees);
        };
        void Dump() {
            DbgPrintF("Object Pool Stats:\r\n");
            DbgPrintF("  Total Allocs - %u\r\n",m_lTotalAllocs);
            DbgPrintF("  Failed Allocs - %u\r\n",m_lFailedAllocs);
            DbgPrintF("  Total Alloc Overhead - %u\r\n",m_lTotalAllocOverhead);
            if (m_lTotalAllocs-m_lFailedAllocs) {
                DbgPrintF("  Average Alloc Overhead - %u\r\n",m_lTotalAllocOverhead/(m_lTotalAllocs-m_lFailedAllocs));
            }
            DbgPrintF("  Total Frees - %u\r\n",m_lTotalFrees);
            DbgPrintF("  Failed Frees - %u\r\n",m_lFailedFrees);
            DbgPrintF("  Total Free Overhead - %u\r\n",m_lTotalFreeOverhead);
            if (m_lTotalFrees-m_lFailedFrees) {
                DbgPrintF("  Average Free Overhead - %u\r\n",m_lTotalFreeOverhead/(m_lTotalFrees-m_lFailedFrees));
            }
        };
    private:
        static void DbgPrintF(LPCSTR pszFmt, ...) {
            char szOutput[512];
            va_list val;

            va_start(val,pszFmt);
            wvsprintf(szOutput,pszFmt,val);
            va_end(val);
            OutputDebugString(szOutput);
        };
        long m_lTotalAllocs;
        long m_lFailedAllocs;
        long m_lTotalAllocOverhead;
        long m_lTotalFrees;
        long m_lFailedFrees;
        long m_lTotalFreeOverhead;
};
#endif

class CPoolStatsRetail {
    public:
        static void AllocSuccess(DWORD) {
        };
        static void AllocFail() {
        };
        static void FreeSuccess(DWORD) {
        };
        static void FreeFail() {
        };
        static void Dump() {
        };
};

#if 0
#ifdef DEBUG
    typedef CPoolStatsDebug CPoolStats;
#else
    typedef CPoolStatsRetail CPoolStats;
#endif
#else
typedef CPoolStatsRetail CPoolStats;
#endif

// This class provides the base implementation of the object pool operations.
// Basically, this class implements everything that doesn't depend in any way
// on the type of the object being pooled.  By doing a base class for all of
// these methods, we minimize the number of instances of these methods which
// will be generated by the compiler (since these particular methods are not
// dependent on the template parameters, we only need to have one version of
// them).
//
// This class' locking is based on critical sections.  On multi-proc machines
// you can get much better contention behavior by keeping the length of time
// that you hold critical sections at an absolute minimum, and by using the
// InitializeCriticalSectionAndSpinCount function (provided by NT4.sp3).  This
// class does this - and since the function is not available on older versions
// of NT, or on Win95, this class uses LoadLibrary/GetProcAddress to attempt
// to call the new function, and it falls back on InitializeCriticalSection
// if the new function is not available.
class CObjPoolImplBase : public CPoolStats
{
    private:
        typedef BOOL (WINAPI *PFN_ICSASC)(LPCRITICAL_SECTION,DWORD);
    public:
        void Init(DWORD dwMax)
        {
            HMODULE hmod;
            PFN_ICSASC pfn = NULL;

            m_pvList = NULL;
            m_lCount = 0;
            m_lMax = dwMax;
            // WARNING!  This Init() method might be called from within
            // DllEntryPoint - which means that calling LoadLibrary is
            // a Bad Idea.  But, we know that kernel32.dll is always
            // loaded already, so it happens to be safe in this one
            // instance...
            hmod = LoadLibrary("kernel32.dll");
            if (hmod)
            {
                pfn = (PFN_ICSASC) GetProcAddress(hmod,"InitializeCriticalSectionAndSpinCount");
            }
            if (!pfn || !pfn(&m_cs,4000))
            {
                // Either we didn't get the function pointer, or
                // the function failed - either way, fall-back to
                // using a normal critsec.
                InitializeCriticalSection(&m_cs);
            }
            if (hmod)
            {
                FreeLibrary(hmod);
            }
        };
        LPVOID Term()
        {
            LPVOID pvResult;

            Assert(m_lCount>=0);
            EnterCriticalSection(&m_cs);
            pvResult = m_pvList;
            m_pvList = NULL;
            m_lCount = 0;
            m_lMax = 0;
            LeaveCriticalSection(&m_cs);
            DeleteCriticalSection(&m_cs);
            Dump();
            return (pvResult);
        };
        void GrowPool(DWORD dwGrowBy)
        {
            EnterCriticalSection(&m_cs);
            m_lMax += dwGrowBy;
            LeaveCriticalSection(&m_cs);
            Assert(m_lMax>=0);
        };
        LPVOID GetAll() {
            LPVOID pvObject;

            EnterCriticalSection(&m_cs);
            pvObject = m_pvList;
            m_pvList = NULL;
            m_lCount = 0;
            LeaveCriticalSection(&m_cs);
            return (pvObject);
        };
    protected:
        volatile LPVOID m_pvList;
        volatile LONG m_lCount;
        volatile LONG m_lMax;
        CRITICAL_SECTION m_cs;
};

// This template class inherits from the base class, and adds all of the
// things which depend on the offset of the "next" field in the objects
// being pooled.  The compiler will instantiate a version of this template
// class for each object pool which has the "next" field at a different
// offset within the pooled objects.
template <DWORD dwNextLinkOffset>
class CObjPoolImpl : public CObjPoolImplBase
{
    public:
        LPVOID GetFromPool()
        {
            LPVOID pvResult = NULL;

            Assert(m_lCount>=0);
            EnterCriticalSection(&m_cs);
            Assert(!m_pvList||(m_lCount>0));
            if (m_pvList)
            {
                pvResult = m_pvList;
                m_pvList = *off(m_pvList);
                *off(pvResult) = NULL;
                m_lCount--;
                AllocSuccess(m_lMax-m_lCount);
            } else {
                AllocFail();
            }
            LeaveCriticalSection(&m_cs);
            return (pvResult);
        };
        BOOL AddToPool(LPVOID pvObject)
        {
            BOOL bResult = FALSE;

            Assert((m_lCount>=0)&&(m_lCount<=m_lMax));
            EnterCriticalSection(&m_cs);
            if (m_lCount < m_lMax)
            {
                *off(pvObject) = m_pvList;
                m_pvList = pvObject;
                m_lCount++;
                bResult = TRUE;
                FreeSuccess(m_lMax-m_lCount);
            } else {
                FreeFail();
            }
            LeaveCriticalSection(&m_cs);
            return (bResult);
        };
        LPVOID ShrinkPool(DWORD dwShrinkBy)
        {
            LPVOID pvResult = NULL;
            DWORD dwCount;

            Assert((m_lCount>=0)&&(m_lCount<=m_lMax));
            Assert((DWORD) m_lMax>=dwShrinkBy);
            EnterCriticalSection(&m_cs);
            m_lMax -= dwShrinkBy;
            while (m_lCount > m_lMax)
            {
                LPVOID pvTmp;

                pvTmp = m_pvList;
                m_pvList = *off(m_pvList);
                *off(pvTmp) = pvResult;
                pvResult = pvTmp;
                m_lCount--;
            }
            LeaveCriticalSection(&m_cs);
            return (pvResult);
        };
        static LPVOID *off(LPVOID pvObject)
        {
            return ((LPVOID *) (((LPBYTE) pvObject)+dwNextLinkOffset));
        };
};

// This template class just wraps the CObjPoolImpl<> template class
// with type conversion for the actual object type being pooled - it
// hides the fact that the underlying implementation is dealing with
// void pointers.  The compiler will instantiate a version of this
// template for each different type of object being pooled.  However,
// since all of the methods of this template class are doing trivial
// type casting, this template class shouldn't actually cause any code
// to be generated.
template <class T, DWORD dwNextLinkOffset, class A>
class CObjPool : public CObjPoolImpl<dwNextLinkOffset>
{
    private:
        typedef CObjPoolImpl<dwNextLinkOffset> O;
    public:
        T *Term()
        {
            return ((T *) O::Term());
        };
        T *GetFromPool()
        {
            return ((T *) O::GetFromPool());
        };
        BOOL AddToPool(T *pObject)
        {
            A::CleanObject(pObject);
            return (O::AddToPool(pObject));
        };
        void GrowPool(DWORD dwGrowBy)
        {
            O::GrowPool(dwGrowBy);
        };
        T *ShrinkPool(DWORD dwShrinkBy)
        {
            return ((T *) O::ShrinkPool(dwShrinkBy));
        };
        T *GetAll() {
            return ((T *) O::GetAll());
        };
        static T **off(T *pObject)
        {
            return ((T ** ) O::off(pObject));
        };
};

// This template class provides multi-proc scalability for
// a pool, by creating up to eight sub-pools - the actual
// number of sub-pools is equal to the number of processors
// on the machine, and the objects are evenly distributed
// between the sub-pools.
template <class T, DWORD dwNextLinkOffset, class O>
class CObjPoolMultiBase
{
    public:
        void Init(DWORD dwMax)
        {
            SYSTEM_INFO siInfo;
            DWORD dwIdx;

            m_dwNext = 0;
            GetSystemInfo(&siInfo);
            m_dwMax = siInfo.dwNumberOfProcessors;
            if (m_dwMax < 1) {
                m_dwMax = 1;
            }
            if (m_dwMax > sizeof(m_abPool)/sizeof(m_abPool[0])) {
                m_dwMax = sizeof(m_abPool)/sizeof(m_abPool[0]);
            }
            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                m_abPool[dwIdx].Init(Calc(dwMax));
            }
        };
        T *Term() {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].Term();
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        T *GetFromPool() {
            return (m_abPool[PickNext()].GetFromPool());
        };
        BOOL AddToPool(T* pObject) {
            return (m_abPool[PickNext()].AddToPool(pObject));
        };
        void GrowPool(DWORD dwGrowBy) {
            for (DWORD dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                m_abPool[dwIdx].GrowPool(Calc(dwGrowBy));
            }
        };
        T *ShrinkPool(DWORD dwShrinkBy) {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].ShrinkPool(Calc(dwGrowBy));
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        T *GetAll() {
            T *pObject = NULL;
            T **ppLast = &pObject;
            DWORD dwIdx;

            for (dwIdx=0;dwIdx<m_dwMax;dwIdx++) {
                *ppLast = m_abPool[dwIdx].GetAll();
                while (*ppLast) {
                    ppLast = off(*ppLast);
                }
            }
            return (pObject);
        };
        static T **off(T* pObject) {
            return (O::off(pObject));
        };
    private:
        DWORD Calc(DWORD dwInput) {
            return ((dwInput+m_dwMax-1)/m_dwMax);
        };
        DWORD PickNext() {
            return (((DWORD) InterlockedIncrement((LONG *) &m_dwNext)) % m_dwMax);
        };
        O m_abPool[8];
        DWORD m_dwMax;
        DWORD m_dwNext;
};

// This template class implements a pool object with automatic
// allocation and freeing of objects.  It does this by taking
// an "allocator" class as a template parameter, and using
// methods on that allocator class to perform the allocation
// and freeing of the objects.
template <class T, DWORD dwNextLinkOffset, class A>
class CAutoObjPool : public CObjPool<T,dwNextLinkOffset,A>
{
    private:
        typedef CObjPool<T,dwNextLinkOffset,A> O;
    public:
        T *Term()
        {
            A::FreeList(O::Term());
            return (NULL);
        };
        T *GetFromPool()
        {
            T *pObject = O::GetFromPool();
            if (!pObject)
            {
                pObject = A::AllocObject();
            }
            return (pObject);
        };
        BOOL AddToPool(T *pObject)
        {
            if (!O::AddToPool(pObject))
            {
                A::FreeObject(pObject);
            }
            return (TRUE);
        };
        T *ShrinkPool(DWORD dwShrinkBy)
        {
            A::FreeList(O::ShrinkPool(dwShrinkBy));
            return (NULL);
        };
};

// This template class provides a multi-proc pool without automatic allocation.
template <class T, DWORD dwNextLinkOffset, class A>
class CObjPoolMulti : public CObjPoolMultiBase<T,dwNextLinkOffset,CObjPool<T,dwNextLinkOffset,A> >
{
    // nothing
};

// The template class provides a multi-proc pool with automatic allocation.
template <class T, DWORD dwNextLinkOffset, class A>
class CAutoObjPoolMulti : public CObjPoolMultiBase<T,dwNextLinkOffset,CAutoObjPool<T,dwNextLinkOffset,A> >
{
    // nothing
};

// This template class provides a base implementation for allocator classes.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjBase
{
    public:
        static void InitObject(T *pObject) {
            memset(pObject,0,sizeof(*pObject));
        };
        static void CleanObject(T *pObject) {
            memset(pObject,0,sizeof(*pObject));
        };
        static void TermObject(T *pObject) {
            // memset(pObject,0xfe,sizeof(*pObject));
        };
        static T **Off(T *pObject) {
            return (T **) (((LPBYTE) pObject)+dwNextLinkOffset);
        };
};

// This template class provides a base implementation for allocator classes
// which use new and delete.
template <class T, class O>
class CAllocObjWithNewBase
{
    public:
        static T *AllocObject()
        {
            T *pObject = new T;
            if (pObject) {
                O::InitObject(pObject);
            }
            return (pObject);
        };
        static void FreeObject(T *pObject)
        {
            if (pObject) {
                O::TermObject(pObject);
            }
            delete pObject;
        };
    static void FreeList(T *pObject) {
        while (pObject) {
            T *pNext;

            pNext = *O::Off(pObject);
            FreeObject(pObject);
            pObject = pNext;
        }
    };
};

// This template class provides an allocator using operator
// new and operator delete.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjWithNew :
    public CAllocObjBase<T,dwNextLinkOffset>,
    public CAllocObjWithNewBase<T,CAllocObjBase<T,dwNextLinkOffset> >
{
    // nothing
};

// This template class provides a base implementation for allocator classes
// which use an instance of IMalloc.
template <class T, class O>
class CAllocObjWithIMallocBase
{
    public:
        static T *AllocObject()
        {
            T *pObject = (T *) g_pMalloc->Alloc(sizeof(T));
            if (pObject) {
                O::InitObject(pObject);
            }
            return (pObject);
        };
        static void FreeObject(T *pObject)
        {
            if (pObject) {
                O::TermObject(pObject);
            }
            g_pMalloc->Free(pObject);
        }
        static void FreeList(T *pObject) {
            while (pObject) {
                T *pNext;

                pNext = *O::Off(pObject);
                FreeObject(pObject);
                pObject = pNext;
            }
        };
};

// This template class provides an allocator using an
// instance of the IMalloc interface.
template <class T, DWORD dwNextLinkOffset>
class CAllocObjWithIMalloc :
    public CAllocObjBase<T,dwNextLinkOffset>,
    public CAllocObjWithIMallocBase<T, CAllocObjBase<T,dwNextLinkOffset> >
{
    // nothing
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\msgmon.h ===
/*
 *    m s g m o n . h
 *    
 *    Purpose:
 *        IMoniker implementation for messages.
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MSGMON_H
#define _MSGMON_H

#include "urlmon.h"

class CMsgMon :
    public IMoniker,
    public IBinding
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // *** IPersist methods ***
    HRESULT STDMETHODCALLTYPE GetClassID (LPCLSID pCLSDID);

    // *** IPersistStream methods ***
    HRESULT STDMETHODCALLTYPE IsDirty();
    HRESULT STDMETHODCALLTYPE Load (LPSTREAM pstm);
    HRESULT STDMETHODCALLTYPE Save (LPSTREAM pstm, BOOL fClearDirty);
    HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IMoniker methods ***
    HRESULT STDMETHODCALLTYPE BindToObject(LPBC pbc, LPMONIKER pmkToLeft, REFIID riidResult, LPVOID *ppvResult);
    HRESULT STDMETHODCALLTYPE BindToStorage (LPBC pbc, LPMONIKER pmkToLeft, REFIID riid, LPVOID *ppvObj);
    HRESULT STDMETHODCALLTYPE Reduce(LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *ppmkToLeft, LPMONIKER *ppmkReduced);
    HRESULT STDMETHODCALLTYPE ComposeWith (LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric, LPMONIKER *ppmkComposite);
    HRESULT STDMETHODCALLTYPE Enum(BOOL fForward, LPENUMMONIKER *ppenumMoniker);
    HRESULT STDMETHODCALLTYPE IsEqual(LPMONIKER pmkOtherMoniker);
    HRESULT STDMETHODCALLTYPE Hash(LPDWORD pdwHash);
    HRESULT STDMETHODCALLTYPE IsRunning(LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER pmkNewlyRunning);
    HRESULT STDMETHODCALLTYPE GetTimeOfLastChange(LPBC pbc, LPMONIKER pmkToLeft, LPFILETIME pFileTime);
    HRESULT STDMETHODCALLTYPE Inverse(LPMONIKER * ppmk);
    HRESULT STDMETHODCALLTYPE CommonPrefixWith(LPMONIKER  pmkOther, LPMONIKER *ppmkPrefix);
    HRESULT STDMETHODCALLTYPE RelativePathTo(LPMONIKER pmkOther, LPMONIKER *ppmkRelPath);
    HRESULT STDMETHODCALLTYPE GetDisplayName(LPBC pbc, LPMONIKER pmkToLeft, LPOLESTR *ppszDisplayName);
    HRESULT STDMETHODCALLTYPE ParseDisplayName(LPBC pbc, LPMONIKER pmkToLeft, LPOLESTR pszDisplayName, ULONG *pchEaten, LPMONIKER *ppmkOut);
    HRESULT STDMETHODCALLTYPE IsSystemMoniker(DWORD *pdwMksys);

    // IBinding
    HRESULT STDMETHODCALLTYPE Abort();
    HRESULT STDMETHODCALLTYPE Suspend();
    HRESULT STDMETHODCALLTYPE Resume();
    HRESULT STDMETHODCALLTYPE SetPriority(LONG nPriority);
    HRESULT STDMETHODCALLTYPE GetPriority(LPLONG pnPriority);
    HRESULT STDMETHODCALLTYPE GetBindResult(LPCLSID pclsidProtocol, LPDWORD pdwResult, LPWSTR *pszResult, LPDWORD pdwReserved);

    CMsgMon();
    ~CMsgMon();

    HRESULT HrInit(REFIID riid, LPUNKNOWN pUnk);

private:
    ULONG                   m_cRef;
    LPBINDSTATUSCALLBACK    m_pbsc;
    LPSTREAM                m_pstmRoot;
    LPBC                    m_pbc;
    IID                     m_iid;
    LPUNKNOWN               m_pUnk;
    BOOL                    m_fRootMoniker;
#ifdef DEBUG
    DWORD                   m_dwThread;
#endif

    HRESULT HrHandOffDataStream(LPSTREAM pstm, CLIPFORMAT cf);
    HRESULT HrPrepareForBind(LPBC pbc);
    HRESULT HrStartBinding();
    HRESULT HrBindToMessage();
    HRESULT HrBindToBodyPart();
    HRESULT HrStopBinding();
};

typedef CMsgMon *LPMSGMONIKER;

HRESULT HrCreateMsgMoniker(REFIID riid, LPUNKNOWN pUnk, LPMONIKER *ppmk);


#endif //_MSGMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\objres.h ===
#ifndef _OBJRES_H
#define _OBJRES_H

#include "mimeole.h"
#include <ocidl.h>

// =================================================================================
// Font Cache Definition
// =================================================================================
class CMimeObjResolver :  public IMimeObjResolver
{
private:
    LONG m_cRef;     // Private Ref Count

public:
    CMimeObjResolver(IUnknown *pUnkOuter=NULL): m_cRef(1) { };
    virtual ~CMimeObjResolver() { } ;
    
    static HRESULT CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

    // IUnknown members
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IMimeObjResolver functions
    virtual HRESULT STDMETHODCALLTYPE MimeOleObjectFromMoniker(BINDF bindf,
        IMoniker *pmkOriginal, IBindCtx *pBindCtx, REFIID riid, LPVOID *ppvObject,
        IMoniker **ppmkNew);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\msgmon.cpp ===
/*
 *    m s g m o n . c p p
 *    
 *    Purpose:
 *        IMoniker implementation for messages.
 *
 *  History
 *      September '96: brettm - created
 *      March '97: moved from mailnews to inetcomm
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include "pch.hxx"
#include "dllmain.h"
#include "resource.h"
#include "strconst.h"
#include "msgmon.h"
#ifdef MAC
#include "commdlg.h"
#else   // !MAC
#include <shlwapi.h>
#endif  // MAC
#include "demand.h"

ASSERTDATA

/*
 *  m a c r o s
 */

#define AssertThread    AssertSz(m_dwThread == GetCurrentThreadId(), "Moniker called on thread other than it's owner!!")

/*
 *  t y p e d e f s
 */

/*
 *  c o n s t a n t s
 */
/*
 *  g l o b a l s 
 */


/*
 *  f u n c t i o n   p r o t y p e s
 */

HRESULT HrGetObjectParam(LPBC pbc, LPOLESTR pszKey, REFIID riid, LPUNKNOWN *ppUnk);

void DebugDumpStreamToFile(LPSTREAM pstm, LPSTR lpszFile)
{
    LPSTREAM    pstmFile;

    if (!FAILED(OpenFileStream(lpszFile, CREATE_ALWAYS, GENERIC_WRITE, &pstmFile)))
        {
        HrRewindStream(pstm);
        HrCopyStream (pstm, pstmFile, NULL);
        pstmFile->Release();
        HrRewindStream(pstm);
        }
};

/*
 *  f u n c t i o n s
 */

CMsgMon::CMsgMon()
{
    m_cRef=1;
    m_pbsc=0;
    m_pstmRoot=0;
    m_pbc = 0;
    m_pUnk=0;

    ZeroMemory(&m_iid, sizeof(IID));

#ifdef DEBUG
    m_dwThread = GetCurrentThreadId();
#endif

}

CMsgMon::~CMsgMon()
{
    AssertThread;

    ReleaseObj(m_pbsc);
    ReleaseObj(m_pstmRoot);
    ReleaseObj(m_pUnk);
    if (m_pbc)
        {
        m_pbc->RevokeObjectParam((LPOLESTR)REG_BC_ATHENAMESSAGE);
        m_pbc->Release();
        }
}

HRESULT CMsgMon::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    AssertThread;

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    if (IsEqualIID(riid, IID_IMoniker))
        {
        DOUTL(64, "CMsgMon::QI - IID_IMoniker");
        *lplpObj = (LPVOID)(LPMONIKER)this;
        }

    if (IsEqualIID(riid, IID_IBinding))
        {
        DOUTL(64, "CMsgMon::QI - IID_IBinding");
        *lplpObj = (LPVOID)(LPBINDING)this;
        }

    if(!*lplpObj)
        {
#ifdef DEBUG
        LPOLESTR    szW=0;
        char        sz[MAX_PATH];
        char        szOut[512];
        char        *pszIFName=0;

        StringFromIID(riid, &szW);
#ifdef MAC
        wsprintf(szOut, "CMsgMon::QI [not supported]:%s", pszIFName?pszIFName:szW);
#else   // !MAC
        WideCharToMultiByte(CP_ACP, 0, szW, -1, sz, MAX_PATH, NULL, NULL);
        
        wsprintf(szOut, "CMsgMon::QI [not supported]:%s", pszIFName?pszIFName:sz);
#endif  // MAC
        DOUTL(64, szOut);
        if(szW)
            CoTaskMemFree(szW);
#endif
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}

ULONG CMsgMon::AddRef()
{
    AssertThread;

    return ++m_cRef;
}

ULONG CMsgMon::Release()
{
    AssertThread;

    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


// *** IPersist ***
HRESULT CMsgMon::GetClassID (LPCLSID pCLSDID)
{
    AssertThread;
    return E_NOTIMPL;
}


// *** IPersistStream methods ***
HRESULT CMsgMon::IsDirty()
{
    AssertThread;
    return S_FALSE;
}

HRESULT CMsgMon::Load (LPSTREAM pstm)
{
    AssertThread;

    if (!pstm)
        return E_INVALIDARG;

    if (m_fRootMoniker)
        {
        // if we're a root moniker, allow setting of the root stream
        SafeRelease(m_pstmRoot);
        m_pstmRoot = pstm;
        pstm->AddRef();
        return S_OK;
        }

    return E_NOTIMPL;
}

HRESULT CMsgMon::Save (LPSTREAM pstm, BOOL fClearDirty)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    AssertThread;
    return E_NOTIMPL;
}

// *** IMoniker methods ***
HRESULT CMsgMon::BindToObject(LPBC pbc, LPMONIKER pmkToLeft, REFIID riidResult, LPVOID *ppvResult)
{
    AssertThread;

    DOUTL(64, "CMsgMon::BindToObject");
    return E_NOTIMPL;
}

HRESULT CMsgMon::BindToStorage (LPBC pbc, LPMONIKER pmkToLeft, REFIID riid, LPVOID *ppvObj)
{
    HRESULT             hr;
    
    AssertThread;

    if(ppvObj==NULL || pbc==NULL)
        return E_INVALIDARG;

    *ppvObj=NULL;

    if(!IsEqualIID(riid, IID_IStream))  // can't handle bind to a non-stream
        return E_FAIL;

    // async bind: NB: this is actually fake async right now, so no need for custom mashalling
    // across threads. This code needs to change when we need true asyncronisity
    hr = HrPrepareForBind(pbc);
    if (FAILED(hr))
        goto error;

    hr=HrStartBinding();
    if(FAILED(hr))
        goto error;

    if (m_fRootMoniker)
        {
        hr = HrBindToMessage();
        if(FAILED(hr))
            goto error;
        }
    else
        {
        hr = HrBindToBodyPart();
        if (FAILED(hr))
            goto error;
        }

    hr=HrStopBinding();
    if(FAILED(hr))
        goto error;

    // if all went well, return ASYNC so the bindoperation
    // continues
    if(SUCCEEDED(hr))
        hr=MK_S_ASYNCHRONOUS;

error:
    return hr;
}

HRESULT CMsgMon::Reduce(LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *ppmkToLeft, LPMONIKER *ppmkReduced)
{
    AssertThread;
    return E_NOTIMPL;
}


HRESULT CMsgMon::ComposeWith (LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric, LPMONIKER *ppmkComposite)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::Enum(BOOL fForward, LPENUMMONIKER *ppenumMoniker)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::IsEqual(LPMONIKER pmkOtherMoniker)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::Hash(LPDWORD pdwHash)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::IsRunning(LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER pmkNewlyRunning)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::GetTimeOfLastChange(LPBC pbc, LPMONIKER pmkToLeft, LPFILETIME pFileTime)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::Inverse(LPMONIKER * ppmk)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::CommonPrefixWith(LPMONIKER  pmkOther, LPMONIKER *ppmkPrefix)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::RelativePathTo(LPMONIKER pmkOther, LPMONIKER *ppmkRelPath)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::GetDisplayName(LPBC pbc, LPMONIKER pmkToLeft, LPOLESTR *ppszDisplayName)
{
    AssertThread;

    TCHAR   sz[MAX_PATH];

    DOUTL(64, "CMsgMon::GetDisplayName");

    if(ppszDisplayName==NULL)
        return E_NOTIMPL;

    *ppszDisplayName = (LPOLESTR)CoTaskMemAlloc(MAX_PATH * sizeof(OLECHAR));
    if (!*ppszDisplayName)
        return E_OUTOFMEMORY;

    **ppszDisplayName=0;
#ifdef MAC
    lstrcpy(*ppszDisplayName, "mailnews://");
#else   // !MAC
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, "mailnews://", -1, *ppszDisplayName, MAX_PATH);
#endif  // MAC
    return NOERROR;
}

HRESULT CMsgMon::ParseDisplayName(LPBC pbc, LPMONIKER pmkToLeft, LPOLESTR pszDisplayName, ULONG *pchEaten, LPMONIKER *ppmkOut)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::IsSystemMoniker(DWORD *pdwMksys)
{
    AssertThread;
    return E_NOTIMPL;
}

HRESULT CMsgMon::HrInit(REFIID riid, LPUNKNOWN pUnk)
{
    AssertThread;

    if(pUnk==NULL)
        return E_INVALIDARG;

    if (!IsEqualIID(riid, IID_IMimeMessage) && !IsEqualIID(riid, IID_IMimeBody))
        return E_NOINTERFACE;

    m_pUnk=pUnk;
    pUnk->AddRef();

    CopyMemory((LPVOID)&m_iid, (LPCVOID)&riid, sizeof(IID));

    m_fRootMoniker=IsEqualIID(m_iid, IID_IMimeMessage);
    return NOERROR;
}



HRESULT CMsgMon::Abort()
{
    return E_NOTIMPL;
}

HRESULT CMsgMon::Suspend()
{
    AssertSz(FALSE, "IBinding::Suspend - why did we get called if we're synchronous?");
    return NOERROR;
}

HRESULT CMsgMon::Resume()
{
    AssertSz(FALSE, "IBinding::Resume - why did we get called if we're synchronous?");
    return NOERROR;
}

HRESULT CMsgMon::SetPriority(LONG nPriority)
{
    AssertSz(FALSE, "IBinding::SetPriority - why did we get called if we're synchronous?");
    return NOERROR;
}

HRESULT CMsgMon::GetPriority(LPLONG pnPriority)
{
    AssertSz(FALSE, "IBinding::GetPriority - why did we get called if we're synchronous?");
    if(pnPriority==NULL)
        return E_INVALIDARG;

    *pnPriority = GetThreadPriority(GetCurrentThread());
    return NOERROR;
}

HRESULT CMsgMon::GetBindResult(LPCLSID pclsidProtocol, LPDWORD pdwResult, LPWSTR *pszResult, LPDWORD pdwReserved)
{
    AssertSz(FALSE, "IBinding::GetBindResult - NYI.");
    return E_NOTIMPL;
}


HRESULT CMsgMon::HrHandOffDataStream(LPSTREAM pstm, CLIPFORMAT cf)
{
    HRESULT                 hr;
    FORMATETC               fetc    = {cf, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM               stgmed;
    ULONG                   cb=0;
    
    if(pstm==NULL)
        return E_INVALIDARG;

    AssertSz(m_pbsc, "this should never be called without one!!");

    stgmed.tymed = TYMED_ISTREAM;
    stgmed.pstm=pstm;
    stgmed.pUnkForRelease=pstm;
    HrGetStreamSize(pstm, &cb);
    HrRewindStream(pstm);
    hr=m_pbsc->OnDataAvailable(BSCF_FIRSTDATANOTIFICATION|BSCF_LASTDATANOTIFICATION, cb, &fetc, &stgmed);
    return hr;
}


HRESULT CMsgMon::HrPrepareForBind(LPBC pbc)
{
    HRESULT     hr;

    AssertSz(pbc!=NULL, "This should be checked higher up the foodchain");

    SafeRelease(m_pbc);
    m_pbc = pbc;
    m_pbc->AddRef();

    SafeRelease(m_pbsc);

    hr = HrGetObjectParam(pbc, (LPOLESTR)REG_BC_BINDSTATUSCALLBACK, IID_IBindStatusCallback, (LPUNKNOWN *)&m_pbsc);
    if(FAILED(hr))
        goto error;

    if (m_fRootMoniker)
        {
        // if we are the root moniker we make sure to register our IMimeMessage in the bind context
        // if this fails, don't fail here, fail in the next msgmon bind when GetObjParam will fail.
        pbc->RegisterObjectParam((LPOLESTR)REG_BC_ATHENAMESSAGE, m_pUnk);
        }

error:
    return hr;
}



HRESULT CMsgMon::HrStartBinding()
{
    HRESULT     hr;
    BINDINFO    bi;
    DWORD       dwBind=0;

    AssertSz(m_pbc!=NULL, "This should be checked higher up the foodchain");
    AssertSz(m_pbsc!=NULL, "This should be checked higher up the foodchain");

    ZeroMemory(&bi, sizeof(bi));

    bi.cbSize=sizeof(BINDINFO);
    hr=m_pbsc->GetBindInfo(&dwBind, &bi);
    if(FAILED(hr))
        goto error;

    hr=m_pbsc->OnStartBinding(0, (LPBINDING)this);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CMsgMon::HrStopBinding()
{
    HRESULT     hr;

    AssertSz(m_pbsc!=NULL, "This should be checked higher up the foodchain");

#ifndef WIN16
    hr=m_pbsc->OnStopBinding(NOERROR, L"");
#else
    hr=m_pbsc->OnStopBinding(NOERROR, "");
#endif // !WIN16
    SafeRelease(m_pbsc);
    return hr;
}

HRESULT CMsgMon::HrBindToBodyPart()
{
    HRESULT     hr;
    TCHAR       *pszExt;
    LPSTR       lpszFileName=0,
                lpszCntType=0,
                lpszCF=0;
    LPSTREAM    pstm=0;
    IMimeBody   *pBody = (IMimeBody *)m_pUnk;

    Assert (m_pUnk != NULL && IsEqualIID(m_iid, IID_IMimeBody));

    hr = MimeOleGetPropA(pBody, PIDTOSTR(PID_ATT_FILENAME), NOFLAGS, &lpszFileName);
    if (!FAILED(hr))
        {
        // if there's a filename, try and infer type from filename
        pszExt = PathFindExtension(lpszFileName);
        MimeOleGetExtContentType(pszExt, &lpszCntType);
        }

    // if no filename, or couldn't infer type, try to get from header
    if (!lpszCntType)
        {
        hr = MimeOleGetPropA(pBody, PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, &lpszCntType);
        if (FAILED(hr))
            goto error;
        }    

    // if no content-type then give raw-data
    if (!lpszCntType)
        lpszCF = CFSTR_MIME_RAWDATA;
    else
        lpszCF = lpszCntType;

    hr = pBody->BindToObject(IID_IStream, (LPVOID *)&pstm);
    if (FAILED(hr))
        goto error;

    hr = HrHandOffDataStream(pstm, (CLIPFORMAT) RegisterClipboardFormat(lpszCF));
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pstm);
    SafeMemFree(lpszCntType);
    SafeMemFree(lpszFileName);
    return hr;
}



HRESULT CMsgMon::HrBindToMessage()
{
    HRESULT             hr=NOERROR;
    LPSTREAM            pstmLoad=0;
    LPCSTR              lpszCF=CFSTR_MIME_HTML;
    IMimeMessage        *pMsg = (IMimeMessage *)m_pUnk;

    Assert (m_pUnk != NULL && IsEqualIID(m_iid, IID_IMimeMessage));

    if (m_pstmRoot)
        {
        pstmLoad=m_pstmRoot;
        m_pstmRoot->AddRef();
        }
    else
        {
        // if no root-stream override, then get html or plain text body part
        hr = pMsg->GetTextBody(TXT_HTML, IET_DECODED, &pstmLoad, NULL);
        if (FAILED(hr))
            {
            lpszCF = CFSTR_MIME_TEXT;
            hr = pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pstmLoad, NULL);
            if (FAILED(hr))
                goto error;
            }
        }

    // when we implement Async binding, figure out the body part we need and put into
    // pstmLoad.
    hr=HrHandOffDataStream(pstmLoad, (CLIPFORMAT) RegisterClipboardFormat(lpszCF));
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pstmLoad);
    return hr;
}


/* 
 * pMsg 
 *      - should always be valid
 *
 * fIsRootMoniker 
 *      - if this is set, then we require special handling. This is the root moniker of the bind, in this case it
 *        will register the pMsg in the bind context in the call to BindToStorage. This will enable the BindHost to
 *        perform IMimeMessage lookup from the context and quickly bind to a subpart. Also, it will determine the richest
 *        format of text to display - html or plaintext and pump it to the bindstatuscallback, unless pstmRoot is set
 *        in which case it will use this as the root stream. pstmRoot can't be set if fIsRoot is False.
 * 
 * hBody
 *      - if we're not a root moniker, then we're a body moniker, in which case hBody will be set to the body part it is,
 *        related to, in theory this could be HBODY_ROOT, which would mean it would pump "message/rfc822" at the bscb.
 *
 */
HRESULT HrCreateMsgMoniker(REFIID riid, LPUNKNOWN pUnk, LPMONIKER *ppmk)
{
    LPMSGMONIKER    pMsgMon=0;
    HRESULT         hr;

    if(!ppmk)
        return E_INVALIDARG;

    *ppmk = 0;

    pMsgMon = new CMsgMon();
    if(!pMsgMon)
        return E_OUTOFMEMORY;

    hr=pMsgMon->HrInit(riid, pUnk);
    if(FAILED(hr))
        goto error;

    hr=pMsgMon->QueryInterface(IID_IMoniker, (LPVOID *)ppmk);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pMsgMon);
    return hr;
}


HRESULT HrGetObjectParam(LPBC pbc, LPOLESTR pszKey, REFIID riid, LPUNKNOWN *ppUnk)
{
    HRESULT     hr;
    LPUNKNOWN   pUnk=0;

    if(pbc==NULL)
        return E_INVALIDARG;

    // Try to get an IUnknown pointer from the bind context
    hr = pbc->GetObjectParam(pszKey, &pUnk);
    if (FAILED(hr))
        return hr;

    // Query for riid
    hr = pUnk->QueryInterface(riid, (void **)ppUnk);
    ReleaseObj(pUnk);
    Assert(SUCCEEDED(hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\olealloc.h ===
// --------------------------------------------------------------------------------
// Malloc.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __MALLOC_H
#define __MALLOC_H

// --------------------------------------------------------------------------------
// mimeole.h
// --------------------------------------------------------------------------------
#include "mimeole.h"

// --------------------------------------------------------------------------------
// CMimeAllocator
// --------------------------------------------------------------------------------
class CMimeAllocator : public IMimeAllocator
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeAllocator(void);
    ~CMimeAllocator(void);

    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ---------------------------------------------------------------------------
    // IMalloc members
    // ---------------------------------------------------------------------------
    STDMETHODIMP_(LPVOID) Alloc(SIZE_T cb); 
    STDMETHODIMP_(LPVOID) Realloc(void *pv, SIZE_T cb);
    STDMETHODIMP_(void)   Free(void * pv);
    STDMETHODIMP_(SIZE_T)  GetSize(void *pv);
    STDMETHODIMP_(int)    DidAlloc(void *pv);
    STDMETHODIMP_(void)   HeapMinimize();

    // ---------------------------------------------------------------------------
    // IMimeAllocator members
    // ---------------------------------------------------------------------------
    STDMETHODIMP ReleaseObjects(ULONG cObjects, IUnknown **prgpUnknown, boolean fFreeArray);
    STDMETHODIMP FreeAddressList(LPADDRESSLIST pList);
    STDMETHODIMP FreeAddressProps(LPADDRESSPROPS pAddress);
    STDMETHODIMP FreeParamInfoArray(ULONG cParams, LPMIMEPARAMINFO prgParam, boolean fFreeArray);
    STDMETHODIMP FreeEnumHeaderRowArray(ULONG cRows, LPENUMHEADERROW prgRow, boolean fFreeArray);
    STDMETHODIMP FreeEnumPropertyArray(ULONG cProps, LPENUMPROPERTY prgProp, boolean fFreeArray);
    STDMETHODIMP FreeThumbprint(THUMBBLOB *pthumbprint);
    STDMETHODIMP PropVariantClear(LPPROPVARIANT pProp);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    LONG m_cRef;     // Reference Counting
};


#endif // __MALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\partial.h ===
// --------------------------------------------------------------------------------
// Partial.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __PARTIAL_H
#define __PARTIAL_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "mimeole.h"

// --------------------------------------------------------------------------------
// PARTINFO
// --------------------------------------------------------------------------------
typedef struct tagPARTINFO {
    BYTE                fRejected;      // Rejected in CombineParts
    IMimeMessage       *pMessage;       // The message object...
} PARTINFO, *LPPARTINFO;

// --------------------------------------------------------------------------------
// CMimeMessageParts
// --------------------------------------------------------------------------------
class CMimeMessageParts : public IMimeMessageParts
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeMessageParts(void);
    ~CMimeMessageParts(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeMessageParts
    // ----------------------------------------------------------------------------
    STDMETHODIMP CombineParts(IMimeMessage **ppMessage);
    STDMETHODIMP AddPart(IMimeMessage *pMessage);
    STDMETHODIMP SetMaxParts(ULONG cParts);
    STDMETHODIMP CountParts(ULONG *pcParts);
    STDMETHODIMP EnumParts(IMimeEnumMessageParts **ppEnum);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
	LONG				m_cRef;			// Reference count
    ULONG               m_cParts;       // Valid elements in m_prgpPart
    ULONG               m_cAlloc;       // Size of m_prgPart
    LPPARTINFO          m_prgPart;      // Array of partinfo structures;
	CRITICAL_SECTION	m_cs;			// Thread safety
};

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts
// --------------------------------------------------------------------------------
class CMimeEnumMessageParts : public IMimeEnumMessageParts
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeEnumMessageParts(void);
    ~CMimeEnumMessageParts(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeEnumMessageParts
    // ----------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cParts, IMimeMessage **prgpMessage, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cParts);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumMessageParts **ppEnum);
    STDMETHODIMP Count(ULONG *pcParts);

    // ----------------------------------------------------------------------------
    // CMimeEnumMessageParts
    // ----------------------------------------------------------------------------
    HRESULT HrInit(ULONG iPart, ULONG cParts, LPPARTINFO prgPart);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference count
    ULONG               m_iPart;        // Current Part
    ULONG               m_cParts;       // Total number of parts
    LPPARTINFO          m_prgPart;      // Array of parts to enumerate
	CRITICAL_SECTION	m_cs;			// Thread safety
};

#endif // __PARTIAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\rfc1522.cpp ===
// --------------------------------------------------------------------------------
// rfc1522.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "internat.h"
#include "dllmain.h"
#include "inetconv.h"
#include "strconst.h"
#include "variantx.h"
#include "mimeapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// ISQPESCAPE(_ch)
// --------------------------------------------------------------------------------
#define ISQPESCAPE(_ch) \
    (IS_EXTENDED(_ch) || _ch == '?' || _ch == '=' || \
                        _ch == '_' || _ch == '"' || \
                        _ch == '<' || _ch == '>' || \
                        _ch == '(' || _ch == ')' || \
                        _ch == '[' || _ch == ']' || \
                        _ch == ',')

// --------------------------------------------------------------------------------
// RFC1522OUT
// --------------------------------------------------------------------------------
typedef struct tagRFC1522OUT {
    BOOL            fWrite;
    CHAR            szBuffer[512];
    ULONG           iBuffer;
    LPSTREAM        pstm;
} RFC1522OUT, *LPRFC1522OUT;

// --------------------------------------------------------------------------------
// HrRfc1522WriteDone
// --------------------------------------------------------------------------------
HRESULT HrRfc1522WriteDone(LPRFC1522OUT pOut, LPSTR *ppszRfc1522)
{
    // We better be writing
    Assert(pOut->fWrite && ppszRfc1522);

    // Init
    *ppszRfc1522 = NULL;

    // If we haven't created the stream yet, just use the buffer...
    if (NULL == pOut->pstm)
    {
        // No data
        if (0 == pOut->iBuffer)
            return S_OK;

        // Allocate
        *ppszRfc1522 = PszAllocA(pOut->iBuffer + 1);
        if (NULL == *ppszRfc1522)
            return TrapError(E_OUTOFMEMORY); 

        // Copy data
        CopyMemory(*ppszRfc1522, pOut->szBuffer, pOut->iBuffer);

        // Null term
        *((*ppszRfc1522) + pOut->iBuffer) = '\0';
    }

    // Otherwise, do stream
    else
    {
        // Commit final data to stream...
        if (0 != pOut->iBuffer)
        {
            if (FAILED(pOut->pstm->Write(pOut->szBuffer, pOut->iBuffer, NULL)))
                return TrapError(E_OUTOFMEMORY); 
        }

        // Commit the stream
        if (FAILED(pOut->pstm->Commit(STGC_DEFAULT)))
            return TrapError(E_OUTOFMEMORY); 

        // Convert the stream to an ANSI string
        *ppszRfc1522 = PszFromANSIStreamA(pOut->pstm);
        Assert(NULL != *ppszRfc1522);

        // Release the stream
        SafeRelease(pOut->pstm);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// HrRfc1522Write
// --------------------------------------------------------------------------------
HRESULT HrRfc1522Write(LPRFC1522OUT pOut, UCHAR ch)
{
    // If not saving data..
    if (!pOut->fWrite)
        return S_OK;

    // If buffer + 1 is full, dump to stream
    if (pOut->iBuffer + 1 > sizeof(pOut->szBuffer))
    {
        // Do I have a stream yet...
        if (NULL == pOut->pstm)
        {
            // Create stream
            if (FAILED(MimeOleCreateVirtualStream(&pOut->pstm)))
                return TrapError(E_OUTOFMEMORY);
        }

        // Write buffer to the stream
        if (FAILED(pOut->pstm->Write(pOut->szBuffer, pOut->iBuffer, NULL)))
            return TrapError(E_OUTOFMEMORY); 

        // Reset buffers
        pOut->iBuffer = 0;
    }

    // Add character to the buffer
    pOut->szBuffer[pOut->iBuffer++] = ch;

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// HrRfc1522WriteStr
// --------------------------------------------------------------------------------
HRESULT HrRfc1522WriteStr(LPRFC1522OUT pOut, LPSTR psz, LONG cb)
{
    HRESULT hr;
    while(cb)
    {
        hr = HrRfc1522Write(pOut, *psz);
        if (FAILED(hr))
            return hr;
        psz++;
        cb--;
    }

    return S_OK;
}

inline BOOL IsRfc1522Token(UCHAR ch)
{
                        //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    static UINT abToken[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	// 000-031
                             1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,	// 032-063
                             0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,	// 064-095
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 096-127
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 128-159
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 160-191
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,	// 192-223
                             1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};	// 224-255

    Assert(sizeof(abToken)/sizeof(abToken[1])==256);
    Assert(abToken['(']==FALSE);
    Assert(abToken[')']==FALSE);
    Assert(abToken['<']==FALSE);
    Assert(abToken['>']==FALSE);
    Assert(abToken['@']==FALSE);
    Assert(abToken[',']==FALSE);
    Assert(abToken[';']==FALSE);
    Assert(abToken[':']==FALSE);
    Assert(abToken['/']==FALSE);
    Assert(abToken['[']==FALSE);
    Assert(abToken[']']==FALSE);
    Assert(abToken['?']==FALSE);
    Assert(abToken['.']==FALSE);
    Assert(abToken['=']==FALSE);

    return (BOOL) abToken[ch];
}


// --------------------------------------------------------------------------------
// PszRfc1522Find
//
// Find an RFC1522 word.  If the string pointer passed in is NULL, then NULL is
// returned.  If a word is not found, then a pointer to the terminatng NULL is
// returned.  If a word is found, then a pointer to the word is returned, and
// an output parameter for whether the word was preceeded by non-blank characters
// is set.
//
// If a word is not found, then the output parameter is undefined.
//
// The output parameter is optional - it may be NULL, in which case the value
// will not be stored.
//
// --------------------------------------------------------------------------------
LPSTR PszRfc1522Find(LPSTR psz,
                     BOOL *pbNonBlankLeading)
{
    LPSTR pszCharset;

    if (!psz || !*psz)
    {
        goto exit;
    }

    if (pbNonBlankLeading)
    {
        *pbNonBlankLeading = FALSE;
    }

    // Skip over any leading blanks.
    while (*psz && (*psz == ' ' || *psz == '\t' || *psz == '\r' || *psz == '\n'))
    {
        psz++;
    }

    if (*psz && (psz[0] != '=' || psz[1] != '?'))
    {
again:
        // If we end up here (either through the if above or by a goto from below),
        // it means that we have some number of non-blank characters before the
        // RFC1522 word.
        if (pbNonBlankLeading)
        {
            *pbNonBlankLeading = TRUE;
        }
    }
    // Skip until we find an =?.
    while (*psz && (psz[0] != '=' || psz[1] != '?'))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    Assert(psz[0] == '=' && psz[1] == '?');

    // Parse out the charset.
    pszCharset = psz;
    psz += 2;
    while (IsRfc1522Token(*psz))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    if (*psz != '?')
    {
        // Malformed.
        goto again;
    }
    Assert(*psz == '?');

    // Parse out the encoding.
    psz++;
    while (IsRfc1522Token(*psz))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    if (*psz != '?')
    {
        // Malformed.
        goto again;
    }
    Assert(*psz == '?');

    // Parse out the data.
    psz++;
    while (*psz && (psz[0] != '?' || psz[1] != '='))
    {
        psz++;
    }
    if (!*psz)
    {
        // End of the string.
        goto exit;
    }
    Assert(psz[0] == '?' && psz[1] == '=');

    psz = pszCharset;

exit:
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522Decode - *(*ppsz) -> '?'
// --------------------------------------------------------------------------------
LPSTR PszRfc1522Decode(LPSTR psz, CHAR chEncoding, LPRFC1522OUT pOut)
{
    // Check params
    Assert(pOut && psz && *psz == '?');
    Assert(chEncoding == 'B' || chEncoding == 'b' || chEncoding == 'Q' || chEncoding == 'q');

    // Step over '?'
    psz++;

    // Done...
    if ('\0' == *psz)
        return psz;

    // Q encoding
    if ('Q' == chEncoding || 'q' == chEncoding)
    {
        // Locals
        UCHAR   uch;
        CHAR    ch,
                ch1,
                ch2;
        LPSTR   pszMark;

        // While we have characters and '?=' is not found...
        while(*psz && (psz[0] != '?' || psz[1] != '='))
        {
            // Get next char
            uch = *psz++;

            // Encoded hex pair i.e. '=1d'
            if (uch == '=')
            {
                // Mark position
                pszMark = psz;

                // Hex char 1 - If no null...
                if (*psz != '\0') ch1 = ChConvertFromHex (*psz++);
                else ch1 = (char)255;

                // Hex char 2 - if no null
                if (*psz != '\0') ch2 = ChConvertFromHex (*psz++);
                else ch2 = (char)255;
                
                //////////////////////////////////////////////////////////////////
                // raid x5-69640 - Incomplete QP encoded letter causes 
                // This is a sign-extension bug - we need to compare against
                // (char)255 instead of 255...
                //
                // If both are = 255, its an equal sign
                if (ch1 == (char)255 || ch2 == (char)255)
                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                {
                    if (FAILED(HrRfc1522Write(pOut, '=')))
                        return NULL;
                    psz = pszMark;
                }

                // Otherwise, build character
                else
                {
                    ch = ( ch1 << 4 ) | ch2;
                    if (FAILED(HrRfc1522Write(pOut, ch)))
                        return NULL;
                }
            }

            // _ equals space...
            else if( uch == '_' )
            {
                if (FAILED(HrRfc1522Write(pOut, ' ')))
                    return NULL;
            }

            // Otherwise, just append the character
            else
            {
                if (FAILED(HrRfc1522Write(pOut, uch)))
                    return NULL;
            }
        }
    }

    // B encoding
    else
    {
        // Locals
        ULONG  cbIn=0,
               cbPad=0;
        UCHAR  ucIn[4], 
               uch;

        // While we have characters and '?=' is not found...
        while(*psz && (psz[0] != '?' || psz[1] != '='))
        {
            // Gets 4 legal Base64 characters, ignores if illegal
            uch = *psz++;

            // Decode base64 character
            ucIn[cbIn] = DECODE64(uch) ;

            // Inc count
            if (ucIn[cbIn] < 64 || (uch == '=' && cbIn > 1))
                cbIn++;

            // Pad it
            if (uch == '=' && cbIn > 1)
                cbPad++;

            // Outputs when 4 legal Base64 characters are in the buffer
            if (cbIn == 4)
            {
                if (cbPad < 3) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[0] << 2) | (ucIn[1] >> 4))))
                        return NULL;
                }
                if (cbPad < 2) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[1] << 4) | (ucIn[2] >> 2))))
                        return NULL;
                }
                if (cbPad < 1) 
                {
                    if (FAILED(HrRfc1522Write(pOut, (ucIn[2] << 6) | (ucIn[3]))))
                        return NULL;
                }
                cbIn = 0;
            }
        }
    }

    // Finish stepping
    if ('?' == *psz)
        psz++;
    if ('=' == *psz)
        psz++;

    // Done
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522GetEncoding - *(*ppsz) -> '?'
//
// Returns NULL if '?X?' is not found... or B b Q q is not found
// --------------------------------------------------------------------------------
LPSTR PszRfc1522GetEncoding(LPSTR psz, CHAR *pchEncoding)
{
    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('?' != *psz)
        return NULL;

    // Next character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save encoding...
    *pchEncoding = *psz;

    // Step over encoding character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('?' != *psz)
        return NULL;

    // Invalid encoding
    if ('B' != *pchEncoding && 'b' != *pchEncoding && 'Q' != *pchEncoding && 'q' != *pchEncoding)
        return NULL;

    // Continue
    return psz;
}

// --------------------------------------------------------------------------------
// PszRfc1522GetCset - *(*ppsz) -> '='
//
// Returns NULL if '=?CHARSET?' is not found
// --------------------------------------------------------------------------------
LPSTR PszRfc1522GetCset(LPSTR psz, LPSTR pszCharset, ULONG cchmax)
{
    // Locals
    LPSTR   pszStart, pszEnd;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '='
    if ('=' != *psz)
        return NULL;

    // Next character
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Should be pointing to '?'
    if ('?' != *psz)
        return NULL;

    // Step over '?'
    psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save Start
    pszStart = psz;

    // Seek to next '?'
    while(*psz && *psz != '?')
        psz++;

    // Done
    if ('\0' == *psz)
        return NULL;

    // Save end
    pszEnd = psz;
    Assert(*pszEnd == '?');

    // Charset name is too large...
    if ((ULONG)(pszEnd - pszStart) > cchmax)
        return NULL;

    // Copy charset
    *pszEnd = '\0';
#ifndef WIN16
    lstrcpynA(pszCharset, pszStart, cchmax);
#else
    lstrcpyn(pszCharset, pszStart, cchmax);
#endif
    *pszEnd = '?';

    // Continue
    return psz;
}

// --------------------------------------------------------------------------------
// HrRfc1522EncodeBase64
// --------------------------------------------------------------------------------
HRESULT HrRfc1522EncodeBase64(UCHAR *pb, ULONG cb, LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BYTE            rgbEncoded[1024];
    ULONG           cbEncoded=0;
    ULONG           i;
    UCHAR           uch[3];

    // Encodes 3 characters at a time
    for (i=0; i<cb; i+=3)
    {
        // Setup Buffer
        uch[0] = pb[i];
        uch[1] = (i + 1 < cb) ? pb[i + 1] : '\0';
        uch[2] = (i + 2 < cb) ? pb[i + 2] : '\0';

        // Encode first tow
        rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[0] >> 2) & 0x3F];
        rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[0] << 4 | uch[1] >> 4) & 0x3F];

        // Encode Next
        if (i + 1 < cb)
            rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[1] << 2 | uch[2] >> 6) & 0x3F];
        else
            rgbEncoded[cbEncoded++] = '=';

        // Encode Net
        if (i + 2 < cb)
            rgbEncoded[cbEncoded++] = g_rgchEncodeBase64[(uch[2]) & 0x3F];
        else
            rgbEncoded[cbEncoded++] = '=';
    }

    // Write rgbEncoded
    CHECKHR(hr = pStream->Write(rgbEncoded, cbEncoded, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrRfc1522EncodeQP
// --------------------------------------------------------------------------------
HRESULT HrRfc1522EncodeQP(UCHAR *pb, ULONG cb, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    BYTE        rgbEncoded[1024];
    ULONG       cbEncoded=0;
    ULONG       i;

    // Loop through buffer
    for (i=0; i<cb; i++)
    {
        // Replace spaces with underscore - this is a more portable character
        if (pb[i] == ' ')
            rgbEncoded[cbEncoded++] = '_';

        // Otherwise, if this is an escapeable character
        else if (ISQPESCAPE(pb[i]))
        {
            // Write equal sign (start of an encodedn QP character
            rgbEncoded[cbEncoded++] = '=';
            rgbEncoded[cbEncoded++] = g_rgchHex[pb[i] >> 4];
            rgbEncoded[cbEncoded++] = g_rgchHex[pb[i] & 0x0F];
        }

        // Otherwise, just write the char as is
        else
            rgbEncoded[cbEncoded++] = pb[i];
    }

    // Write rgbEncoded
    CHECKHR(hr = pStream->Write(rgbEncoded, cbEncoded, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// FContainsExtended
// --------------------------------------------------------------------------------
BOOL FContainsExtended(LPPROPSTRINGA pStringA, ULONG *pcExtended)
{
    // Invalid Arg
    Assert(ISVALIDSTRINGA(pStringA) && pcExtended);

    // Init
    *pcExtended = 0;

    // Look for an extended character
    for (ULONG cch=0; cch<pStringA->cchVal; cch++)
    {
        // Is this an extended char
        if (IS_EXTENDED(pStringA->pszVal[cch]))
        {
            // Count
            (*pcExtended)++;
        }
    }

    // Done
    return ((*pcExtended) > 0) ? TRUE : FALSE;
}

#define IS_EXTENDED_W(wch) \
    ((wch > 126 || wch < 32) && wch != L'\t' && wch != L'\n' && wch != L'\r')

// --------------------------------------------------------------------------------
// FContainsExtendedW
// --------------------------------------------------------------------------------
BOOL FContainsExtendedW(LPPROPSTRINGW pStringW, ULONG *pcExtended)
{
    // Invalid Arg
    Assert(ISVALIDSTRINGW(pStringW) && pcExtended);

    // Init
    *pcExtended = 0;

    // Look for an extended character
    for (ULONG cch=0; cch<pStringW->cchVal; cch++)
    {
        // Is this an extended char
        if (IS_EXTENDED_W(pStringW->pszVal[cch]))
        {
            // Count
            (*pcExtended)++;
        }
    }

    // Done
    return ((*pcExtended) > 0) ? TRUE : FALSE;
}

// --------------------------------------------------------------------------------
// HrRfc1522Encode
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleRfc1522Encode(
            /* in */        LPCSTR              pszValue,
            /* in */        HCHARSET            hCharset,
            /* out */       LPSTR               *ppszEncoded)
{
    // Locals
    HRESULT             hr=S_OK;
    LPINETCSETINFO      pCharset;
    MIMEVARIANT         rSource;
    MIMEVARIANT         rDest;
    CODEPAGEID          cpiSource;
    CODEPAGEID          cpiDest;

    // Invalid Arg
    if (NULL == pszValue || NULL == hCharset || NULL == ppszEncoded)
        return TrapError(E_INVALIDARG);

    // Init rDest
    ZeroMemory(&rDest, sizeof(MIMEVARIANT));

    // Setup rSource
    rSource.type = MVT_STRINGA;
    rSource.rStringA.pszVal = (LPSTR)pszValue;
    rSource.rStringA.cchVal = lstrlen(pszValue);

    // Open the Character Set
    CHECKHR(hr = g_pInternat->HrOpenCharset(hCharset, &pCharset));

    // Setup rDest
    rDest.type = MVT_STRINGA;

    // Convert the String
    CHECKHR(hr = g_pInternat->HrConvertString(pCharset->cpiWindows, pCharset->cpiInternet, &rSource, &rDest));

    // Setup Source and Dest Charset
    cpiSource = pCharset->cpiWindows;
    cpiDest = pCharset->cpiInternet;

    // Adjust the Codepages
    CHECKHR(hr = g_pInternat->HrValidateCodepages(&rSource, &rDest, NULL, NULL, &cpiSource, &cpiDest));

    // 1522 Encode this dude
    CHECKHR(hr = HrRfc1522Encode(&rSource, &rDest, cpiSource, cpiDest, pCharset->szName, ppszEncoded));

exit:
    // Cleanup
    MimeVariantFree(&rDest);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrRfc1522Encode
// --------------------------------------------------------------------------------
HRESULT HrRfc1522Encode(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, CODEPAGEID cpiSource,
    CODEPAGEID cpiDest, LPCSTR pszCharset, LPSTR *ppszEncoded)
{
    // Locals
    HRESULT         hr=S_OK;
    CByteStream     cStream;
    CHAR            chEncoding;
    ULONG           cExtended=0;
    LPBYTE          pb;
    ULONG           cb;
    ULONG           i=0;
    ULONG           cbFirstTry;
    ULONG           cbRead;
    BLOB            rBlobSource;
    BLOB            rBlobCset;
    ULONG           cTrys;
    CHAR            szEncoding[1];
    ULONG           iBefore;
    ULONG           iAfter;
    ULONG           cbExtra;
    ULARGE_INTEGER  uli;
    LARGE_INTEGER   li;
    //IStream        *pStream=NULL;

    // Invalid Arg
    Assert(pSource && pDest && pszCharset && ppszEncoded);
    Assert(MVT_STRINGW == pSource->type ? CP_UNICODE == cpiSource : CP_UNICODE != cpiSource);
    Assert(cpiDest != CP_UNICODE && MVT_STRINGA == pDest->type);

    // Init
    *ppszEncoded = NULL;
    uli.HighPart = 0;
    li.HighPart = 0;
    rBlobCset.pBlobData = NULL;

    // Raid-50014: Will will always rfc1522 encode utf encodings
    // Raid-50788: Cannot post UTF news messages
    if (MVT_STRINGW != pSource->type)
    {
        // If it does not contain 8bit, then no rfc1522 encoding is needed
        if (FALSE == FContainsExtended(&pSource->rStringA, &cExtended))
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // We should be converting to UTF...
    else
    {
        // Must be encoding into utf
        Assert(65000 == cpiDest || 65001 == cpiDest);

        // If it does not contain 8bit, then no rfc1522 encoding is needed
        if (FALSE == FContainsExtendedW(&pSource->rStringW, &cExtended))
        {
            hr = E_FAIL;
            goto exit;
        }
    }

    // Create a Stream
    // CHECKHR(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream));

    // Compute Encoding...
    chEncoding = (((cExtended * 100) / pSource->rStringA.cchVal) >= 17) ? 'B' : 'Q';

    // RAID-21673: If DBCS source codepage, then, encode the entire string so that I don't fragment the character set encoding.
    if (IsDBCSCodePage(cpiSource))
        chEncoding = 'B';

    // Set szEncoding
    szEncoding[0] = chEncoding;

    // Setup Encoding Loop
    pb = (MVT_STRINGW == pSource->type) ? (LPBYTE)pSource->rStringW.pszVal : (LPBYTE)pSource->rStringA.pszVal;
    cb = (MVT_STRINGW == pSource->type) ? (pSource->rStringW.cchVal * sizeof(WCHAR)) : pSource->rStringA.cchVal;

    // Adjust pszCharset
    if (CP_JAUTODETECT == cpiDest || 50222 == cpiDest || 50221 == cpiDest)
        pszCharset = (LPSTR)c_szISO2022JP;

    // Compute cbExtra - =?cchCharset?1?<cbFirstTry>?=
    cbExtra = 2 + lstrlen(pszCharset) + 3 + 2;

    // Compute cbFirstTry
    cbFirstTry = 76 - cbExtra;

    // cbFirstTry needs to be even if we are encoding unicode
    cbFirstTry -= (cbFirstTry % 2);    

    // Adjust cbFirstTry if its greater than cb
    cbFirstTry = min(cb, cbFirstTry);

    // Make sure cbFirstTry is even ... That's a good starting point,
    // but we need to make sure that we're not breaking on a leading byte
    // On Korean (and other DBCS locales) we can have a mix of
    // SBCs and MBCs, so just being even isn't enough
    if(pb && (MVT_STRINGW != pSource->type))
    {
        LPCSTR pszEnd = (LPCSTR)&pb[cbFirstTry],
               pszNewEnd = NULL;

        pszNewEnd = CharPrevExA((WORD)cpiSource, (LPCSTR)pb, pszEnd, 0);
        if(pszNewEnd && (pszNewEnd == (pszEnd - 1)) && IsDBCSLeadByteEx(cpiSource, *pszNewEnd))
            cbFirstTry-= (ULONG)(pszEnd - pszNewEnd);
    }

    // Loop until we have encoded the entire string
    while (i < cb)
    {
        // Write Prefix
        CHECKHR(hr = cStream.Write("=?", 2, NULL));
        CHECKHR(hr = cStream.Write(pszCharset, lstrlen(pszCharset), NULL));
        CHECKHR(hr = cStream.Write("?", 1, NULL));
        CHECKHR(hr = cStream.Write(szEncoding, 1, NULL));
        CHECKHR(hr = cStream.Write("?", 1, NULL));

        // Compute Try Amount
        rBlobSource.cbSize = min(cb - i, cbFirstTry);
        rBlobSource.pBlobData = (LPBYTE)(pb + i);

        // Get Index
        CHECKHR(hr = HrGetStreamPos(&cStream, &iBefore));

        // Encoded blocks until we get one at a good length
        for (cTrys=0;;cTrys++)
        {
            // Too many Trys ?
            if (cTrys > 100)
            {
                AssertSz(FALSE, "Too many rfc1522 encode buffer reduction attemps, failing (No rfc1522 encoding will be applied).");
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Memory Leak
            Assert(NULL == rBlobCset.pBlobData);

            // Convert Block
            CHECKHR(hr = g_pInternat->ConvertBuffer(cpiSource, cpiDest, &rBlobSource, &rBlobCset, &cbRead));

            // Problem
            if (cbRead == 0)
            {
                AssertSz(FALSE, "Bad buffer conversion");
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Validate
            Assert(cbRead <= rBlobSource.cbSize);

            // 'B' Encoding
            if ('B' == chEncoding)
            {
                // ApplyBase64
                CHECKHR(hr = HrRfc1522EncodeBase64(rBlobCset.pBlobData, rBlobCset.cbSize, &cStream));
            }
            else
            {
                // ApplyQP
                CHECKHR(hr = HrRfc1522EncodeQP(rBlobCset.pBlobData, rBlobCset.cbSize, &cStream));
            }

            // Get Index
            CHECKHR(hr = HrGetStreamPos(&cStream, &iAfter));

            // Validate
            Assert(iAfter > iBefore);

            // Too big ?
            if ((iAfter - iBefore) + cbExtra <= 76)
                break;

            // Problem
            if (rBlobSource.cbSize <= 5)
            {
                Assert(FALSE);
                hr = TrapError(E_FAIL);
                goto exit;
            }

            // Cleanup
            SafeMemFree(rBlobCset.pBlobData);

            // Seek Back to iBefore
            uli.LowPart = iBefore;
            cStream.SetSize(uli);

            // Seek Backwards
            li.LowPart = iBefore;
            cStream.Seek(li, STREAM_SEEK_SET, NULL);

            // Compute Inflation Rate
            if (0 == cTrys)
                rBlobSource.cbSize = (((76 - cbExtra) * rBlobSource.cbSize) / (iAfter - iBefore));

            // Otherwise, start taking off 5 bytes
            else
                rBlobSource.cbSize -= 5;

            // Make sure it is even ... That's a good starting point,
            // but we need to make sure that we're not breaking on a leading byte
            // On Korean (and other DBCS locales) we can have a mix of
            // SBCs and MBCs, so just being even isn't enough
            rBlobSource.cbSize -= (rBlobSource.cbSize % 2);
            if(rBlobSource.pBlobData && (MVT_STRINGW != pSource->type))
            {
                LPCSTR pszEnd = (LPCSTR)&rBlobSource.pBlobData[rBlobSource.cbSize],
                       pszNewEnd = NULL;

                pszNewEnd = CharPrevExA((WORD)cpiSource, (LPCSTR)rBlobSource.pBlobData, pszEnd, 0);
                if(pszNewEnd && (pszNewEnd == (pszEnd - 1)) && IsDBCSLeadByteEx(cpiSource, *pszNewEnd))
                    rBlobSource.cbSize-= (ULONG)(pszEnd - pszNewEnd);
            }

            // Should be less than cb
            Assert(rBlobSource.cbSize < cb);
        }

        // Write termination
        CHECKHR(hr = cStream.Write("?=", 2, NULL));

        // Increment i
        i += cbRead;

        // Cleanup
        SafeMemFree(rBlobCset.pBlobData);

        // Write folding
        if (i < cb)
        {
            // Write Fold
            CHECKHR(hr = cStream.Write(c_szCRLFTab, lstrlen(c_szCRLFTab), NULL));
        }
    }

    // Return the encoded string
    CHECKHR(hr = cStream.HrAcquireStringA(&cb, ppszEncoded, ACQ_DISPLACE));
    //cStream.Commit(STGC_DEFAULT);
    //CHECKALLOC(*ppszEncoded = PszFromANSIStreamA(pStream));

exit:
    // Cleanup
    //ReleaseObj(pStream);
    g_pMalloc->Free(rBlobCset.pBlobData);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeOleRfc1522Decode
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleRfc1522Decode(LPCSTR pszValue, LPSTR pszCharset, ULONG cchmax, LPSTR *ppszDecoded)
{
    // Locals
    HRESULT             hrEncoded=E_FAIL,
                        hrCsetFound=E_FAIL;
    RFC1522OUT          rOut;
    LPSTR               psz=(LPSTR)pszValue,
                        pszNew;
    CHAR                szCset[CCHMAX_CSET_NAME],
                        chEncoding;
    BOOL                bNonBlankLeading;

    // check params
    if (NULL == pszValue)
        return TrapError(E_INVALIDARG);

    // Init out structure
    ZeroMemory(&rOut, sizeof(RFC1522OUT));

    // Save data..
    if (ppszDecoded)
        rOut.fWrite = TRUE;

    // Start decoding loop...
    while(psz && *psz)
    {
        // Seek to start of 1522 encoding...
        pszNew = PszRfc1522Find(psz, &bNonBlankLeading);
        Assert(pszNew!=NULL);

        if (bNonBlankLeading || psz == pszValue || !*psz)
        {
            // Either we found non-blank characters before the word,
            // or this is the first word on the line, or we didn't
            // find a word.  Whatever, we need to write all of the
            // data before the word.
            if (FAILED(HrRfc1522WriteStr(&rOut, psz, (LONG) (pszNew-psz))))
            {
                break;
            }
        }
        // If didn't find start.. were done
        if (!*pszNew)
            break;

        // Set psz to new position
        psz = pszNew;

        // Get charset
        pszNew = PszRfc1522GetCset(psz, szCset, ARRAYSIZE(szCset));

        // If didn't parse charset correctly, continue
        if (NULL == pszNew)
        {
            psz++;
            continue;
        }

        // Character set was found
        hrCsetFound = S_OK;
        
        // Was caller just looking for the charset...
        if (NULL == ppszDecoded)
            break;

        // Otherwise, parse encoding
        pszNew = PszRfc1522GetEncoding(pszNew, &chEncoding);

        // If didn't parse charset correctly, continue
        if (NULL == pszNew)
        {
            psz++;
            continue;
        }

        // Decode the text to the end - THIS SHOULD NEVER FAIL...
        psz = PszRfc1522Decode(pszNew, chEncoding, &rOut);

        // It is a valid encoded string
        if (psz)
            hrEncoded = S_OK;
    }

    // Were we actually decoding...
    if (ppszDecoded && hrEncoded == S_OK)
    {
        // Commit the stream
        if (FAILED(HrRfc1522WriteDone(&rOut, ppszDecoded)))
        {
            *ppszDecoded = NULL;
            hrEncoded = S_FALSE;
        }
    }

    // Otherwise, return charset...
    if (pszCharset && hrCsetFound == S_OK)
        lstrcpyn(pszCharset, szCset, cchmax);

    // Cleanup
    SafeRelease(rOut.pstm);

    // Done
    return ppszDecoded ? hrEncoded : hrCsetFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\partial.cpp ===
// --------------------------------------------------------------------------------
// Partial.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "partial.h"
#include "vstream.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Releases an array of IMimeMessage objects
// --------------------------------------------------------------------------------
void ReleaseParts(ULONG cParts, LPPARTINFO prgPart)
{
    // Loop
    for (ULONG i=0; i<cParts; i++)
    {
        SafeRelease(prgPart[i].pMessage);
    }
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CMimeMessageParts
// --------------------------------------------------------------------------------
CMimeMessageParts::CMimeMessageParts(void)
{
	m_cRef = 1;
    m_cParts = 0;
    m_cAlloc =0;
    m_prgPart = NULL;
	InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CMimeMessageParts
// --------------------------------------------------------------------------------
CMimeMessageParts::~CMimeMessageParts(void)
{
    ReleaseParts(m_cParts, m_prgPart);
    SafeMemFree(m_prgPart);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeMessageParts == riid)
        *ppv = (IMimeMessageParts *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeMessageParts::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeMessageParts::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::AddPart
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::AddPart(IMimeMessage *pMessage)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid ARg
    if (NULL == pMessage)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Grow my internal array
    if (m_cParts + 1 >= m_cAlloc)
    {
        // Grow my array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * (m_cAlloc + 10)));

        // Set alloc size
        m_cAlloc += 10;
    }

    // Set new
    ZeroMemory(&m_prgPart[m_cParts], sizeof(PARTINFO));
    m_prgPart[m_cParts].pMessage = pMessage;
    m_prgPart[m_cParts].pMessage->AddRef();
    m_cParts++;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::SetMaxParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::SetMaxParts(ULONG cParts)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Less than number alloced?
    if (cParts <= m_cAlloc)
        goto exit;

    // Grow my array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * (cParts + 10)));

    // Set alloc size
    m_cAlloc = cParts + 10;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CountParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::CountParts(ULONG *pcParts)
{
    // Invalid ARg
    if (NULL == pcParts)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set count
    *pcParts = m_cParts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::EnumParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::EnumParts(IMimeEnumMessageParts **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumMessageParts *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    pEnum = new CMimeEnumMessageParts;
    if (NULL == pEnum)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Init
    CHECKHR(hr = pEnum->HrInit(0, m_cParts, m_prgPart));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeMessageParts::CombineParts
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeMessageParts::CombineParts(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTREAM            pstmMsg=NULL,
                        pstmSource=NULL;
    ULONG               i,
                        cMimePartials=0,
                        iPart,
                        cRejected=0;
    IMimeMessage       *pMessage;
    IMimeMessage       *pCombine=NULL;
    IMimeBody          *pRootBody=NULL;
    BOOL                fTreatAsMime;
    BODYOFFSETS         rOffsets;
    LPSTR               pszSubject=NULL;
    PROPVARIANT         rData;

    // Invalid ARg
    if (NULL == ppMessage)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppMessage = NULL;

    // Create Temp Stream...
    CHECKALLOC(pstmMsg = new CVirtualStream);

    // Set all rejected flags to FALSE...
    for (i=0; i<m_cParts; i++)
        m_prgPart[i].fRejected = FALSE;

    // Enumerate parts
    for (i=0; i<m_cParts; i++)
    {
        // Reability
        pMessage = m_prgPart[i].pMessage;
        Assert(pMessage);

        // Get Message Source
        CHECKHR(hr = pMessage->GetMessageSource(&pstmSource, COMMIT_ONLYIFDIRTY));

        // Get Tree Object
        CHECKHR(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody));

        // Get Root Body Offset
        CHECKHR(hr = pRootBody->GetOffsets(&rOffsets));

        // Un-init iPart
        iPart = 0;

        // Mime Message ?
        rData.vt = VT_UI4;
        if (pRootBody->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK && SUCCEEDED(pRootBody->GetProp(STR_PAR_NUMBER, 0, &rData)))
        {
            // Count MimePartials
            cMimePartials++;

            // Treat this part as mime...
            fTreatAsMime = TRUE;

            // Get Part Number
            iPart = rData.ulVal;
        }

        // Otherwise
        else
        {
            // Don't treat as mime
            fTreatAsMime = FALSE;

            // If There have been legal mime partials, this part is rejected
            m_prgPart[i].fRejected = BOOL(cMimePartials > 0);
        }

        // If Rejected, continue...
        if (m_prgPart[i].fRejected)
        {
            cRejected++;
            continue;
        }

        // If MIME - and part one
        if (i == 0)
        {
            // Treat as mime
            if (fTreatAsMime && 1 == iPart)
            {
                // Merge the headers of part one
                CHECKHR(hr = MimeOleMergePartialHeaders(pstmSource, pstmMsg));

                // CRLF
                CHECKHR(hr = pstmMsg->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));

                // Append message body onto lpstmOut
                CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
            }

            else
            {
                // Seek to body start
                CHECKHR(hr = HrStreamSeekSet(pstmSource, 0));

                // Append message body onto lpstmOut
                CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
            }
        }

        else
        {
            // Seek to body start
            CHECKHR(hr = HrStreamSeekSet(pstmSource, rOffsets.cbBodyStart));

            // Append message body onto lpstmOut
            CHECKHR(hr = HrCopyStream(pstmSource, pstmMsg, NULL));
        }

        // Raid 67648 - Need to append a CRLF to the end of the last message...
        if (i < m_cParts - 1)
        {
            // Locals
            DWORD cbMsg;

            // Read the last 2 bytes...
            CHECKHR(hr = HrGetStreamSize(pstmMsg, &cbMsg));

            // If greater than 2...
            if (cbMsg > 2)
            {
                // Locals
                BYTE rgCRLF[2];

                // Seek...
                CHECKHR(hr = HrStreamSeekSet(pstmMsg, cbMsg - 2));

                // Read the last two bytes
                CHECKHR(hr = pstmMsg->Read(rgCRLF, 2, NULL));

                // If not a crlf, then write a crlf
                if (rgCRLF[0] != chCR && rgCRLF[1] != chLF)
                {
                    // Write CRLF
                    CHECKHR(hr = pstmMsg->Write(c_szCRLF, 2, NULL));
                }
            }
        }
        
        // Release
        SafeRelease(pstmSource);
        SafeRelease(pRootBody);
    }

    // Rewind message stream..
    CHECKHR(hr = HrRewindStream(pstmMsg));

    // Create a message
    CHECKHR(hr = MimeOleCreateMessage(NULL, &pCombine));

    // Init New
    CHECKHR(hr = pCombine->InitNew());

    // Load the message
    CHECKHR(hr = pCombine->Load(pstmMsg));

    // Any Rejected ?
    if (cRejected)
    {
        // Attach rejected messages
        for (i=0; i<m_cParts; i++)
        {
            // Rejected...
            if (m_prgPart[i].fRejected)
            {
                // Attach body to combined message
                CHECKHR(hr = pCombine->AttachObject(IID_IMimeMessage, m_prgPart[i].pMessage, NULL));
            }
        }
    }

    // Return the new message
    *ppMessage = pCombine;
    (*ppMessage)->AddRef();

    // Debug to temp file...
#ifdef DEBUG
    LPSTREAM pstmFile;
    if (SUCCEEDED(OpenFileStream("d:\\lastcom.txt", CREATE_ALWAYS, GENERIC_WRITE, &pstmFile)))
    {
        HrRewindStream(pstmMsg);
        HrCopyStream(pstmMsg, pstmFile, NULL);
        pstmFile->Commit(STGC_DEFAULT);
        pstmFile->Release();
    }
#endif

exit:
    // Cleanup
    SafeRelease(pstmMsg);
    SafeRelease(pstmSource);
    SafeRelease(pRootBody);
    SafeRelease(pCombine);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::CMimeEnumMessageParts
// --------------------------------------------------------------------------------
CMimeEnumMessageParts::CMimeEnumMessageParts(void)
{
    m_cRef = 1;
    m_iPart = 0;
    m_cParts = 0;
    m_prgPart = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::~CMimeEnumMessageParts
// --------------------------------------------------------------------------------
CMimeEnumMessageParts::~CMimeEnumMessageParts(void)
{
    ReleaseParts(m_cParts, m_prgPart);
    SafeMemFree(m_prgPart);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeEnumMessageParts == riid)
        *ppv = (IMimeEnumMessageParts *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumMessageParts::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumMessageParts::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Next
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Next(ULONG cWanted, IMimeMessage **prgpMessage, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cFetch=1, iPart=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_prgPart || NULL == prgpMessage)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cParts - m_iPart);
    if (0 == cFetch)
        goto exit;

    // Copy cWanted
    for (iPart=0; iPart<cFetch; iPart++)
    {
        prgpMessage[iPart] = m_prgPart[m_iPart].pMessage;
        prgpMessage[iPart]->AddRef();
        m_iPart++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Skip
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_iPart + cSkip) >= m_cParts) || NULL == m_prgPart)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_iPart += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Reset
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_iPart = 0;
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Count
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Count(ULONG *pcCount)
{
    // Invalid Arg
    if (NULL == pcCount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Count
    *pcCount = m_cParts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumMessageParts::Clone(IMimeEnumMessageParts **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumMessageParts *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    pEnum = new CMimeEnumMessageParts;
    if (NULL == pEnum)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Init
    CHECKHR(hr = pEnum->HrInit(m_iPart, m_cParts, m_prgPart));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumMessageParts::HrInit
// --------------------------------------------------------------------------------
HRESULT CMimeEnumMessageParts::HrInit(ULONG iPart, ULONG cParts, LPPARTINFO prgPart)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check param
    Assert(m_prgPart == NULL);

    // Empty Enumerator ?
    if (0 == cParts)
    {
        Assert(prgPart == NULL);
        m_cParts = m_iPart = 0;
        goto exit;
    }

    // Allocat an internal array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_prgPart, sizeof(PARTINFO) * cParts));

    // Copy prgPart
    for (i=0; i<cParts; i++)
    {
        CopyMemory(&m_prgPart[i], &prgPart[i], sizeof(PARTINFO));
        Assert(m_prgPart[i].pMessage);
        m_prgPart[i].pMessage->AddRef();
    }

    // Save Size and State
    m_cParts = cParts;
    m_iPart = iPart;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smime.cpp ===
/*
**  s m i m e . c p p
**
**  Purpose:
**      Implementation of a class to wrap around CAPI functionality
**
**  History
**      1/26/98  (brucek)   Allow multiple security layers (triple-wrapping)
**      6/15/97: (t-erikne) CAPI streaming
**      5/18/97: (t-erikne) new IMimeSecurity interface
**      2/07/97: (t-erikne) multipart/signed
**      1/06/97: (t-erikne) Moved into MimeOLE
**     11/14/96: (t-erikne) CAPI Post-SDR work
**      8/27/96: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1996-1998.
*/

///////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include "smime.h"
#include "vstream.h"
#include "olealloc.h"
#include "capistm.h"
#include "bookbody.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include <demand.h>

// from dllmain.h
extern CMimeAllocator * g_pMoleAlloc;
extern CRITICAL_SECTION g_csDllMain;
extern ULONG DllAddRef(void);
extern ULONG DllRelease(void);

extern HCERTSTORE WINAPI OpenCachedMyStore();
extern HCERTSTORE WINAPI OpenCachedAddressBookStore();

#define MST_THIS_SIGN_ENCRYPT           (MST_THIS_SIGN | MST_THIS_ENCRYPT)

///////////////////////////////////////////////////////////////////////////
//
// Static Prototypes
//

static void     _FreeCertArray(PCCERT_CONTEXT *rgpCert, const UINT cCerts);
static HRESULT  _HrConvertHrFromGetCertToEncode(HRESULT hr, const BOOL fEncrypt);
#ifndef SMIME_V3
static HRESULT ConstructAuthAttributes(BLOB * pblEncoded, BLOB * pblAuthAttr, FILETIME * pftSigntime, BLOB * pblSymcaps);
#endif // SMIME_V3
extern HRESULT HrCopyBlob(LPCBLOB pIn, LPBLOB pOut);
static LPBYTE DuplicateMemory(LPBYTE lpvIn, ULONG cbIn);

///////////////////////////////////////////////////////////////////////////
//
// Macros
//

#define CHECKSMIMEINITDW { if (FAILED(CheckInit())) return (DWORD)-1; }
#define CHECKSMIMEINITV  { if (FAILED(CheckInit())) return; }
#define CHECKSMIMEINITB  { if (FAILED(CheckInit())) return FALSE; }
#define CHECKSMIMEINIT   { if (FAILED(CheckInit())) return MIME_E_SECURITY_NOTINIT; }
#define SCHECKSMIMEINITP { if (FAILED(StaticCheckInit())) return NULL; }
#define SCHECKSMIMEINITV { if (FAILED(StaticCheckInit())) return; }
#define SCHECKSMIMEINIT  { if (FAILED(StaticCheckInit())) return MIME_E_SECURITY_NOTINIT; }
#define ALLOCED(_pv) \
        (0 != g_pMalloc->DidAlloc(_pv))

#define THIS_AS_UNK ((IUnknown *)(IStream *)this)

///////////////////////////////////////////////////////////////////////////
//
// Globals
//

ASSERTDATA

static const char s_szSMIMEP7s[] = "smime.p7s";
static const char s_szSMIMEP7m[] = "smime.p7m";

#ifdef DEBUG

static LPCSTR s_lpszCertStore = "c:\\ttfn\\debug.sto";

// emit signatures, encryption that should be broken
static BOOL s_fDebugEmitBroken      = 0;

// show the certificate found by HrGetUsableCert
static BOOL s_fDebugShowFoundCert   = 0;

// copy the message source to a BYTE *
static BOOL s_fDebugDumpWholeMsg    = 1;

// show/select certs w/o email oids
static BOOL s_fDebugAllowNoEmail    = 1;

#endif // DEBUG

static const char s_cszMy[]             = "My";
static const char s_cszWABCertStore[]   = "AddressBook";

CRYPT_ENCODE_PARA       CryptEncodeAlloc = {
    sizeof(CRYPT_ENCODE_PARA), CryptAllocFunc, CryptFreeFunc
};

CRYPT_DECODE_PARA       CryptDecodeAlloc = {
    sizeof(CRYPT_DECODE_PARA), CryptAllocFunc, CryptFreeFunc
};

///////////////////////////////////////////////////////////////////////////
//
// Initialization of statics to class
//

#ifdef MAC
EXTERN_C WINCRYPT32API HCERTSTORE WINAPI MacCertOpenStore(LPCSTR lpszStoreProvider,
                                                 DWORD dwEncodingType,
                                                 HCRYPTPROV hCryptProv,
                                                 DWORD dwFlags,
                                                 const void *pvPara);
#define CertOpenStore   MacCertOpenStore

// We don't have DLL's on the Mac, so let's just hardcode the vtable.
CAPIfuncs CSMime::ms_CAPI = {   CertEnumCertificatesInStore,
                                CertNameToStrA
                            };
#endif  // MAC

///////////////////////////////////////////////////////////////////////////
//
// inlines
//

INLINE void ReleaseCert(PCCERT_CONTEXT pc)
    { if (pc) CertFreeCertificateContext(pc); }

INLINE void ReleaseCertStore(HCERTSTORE hc)
    { if (hc) CertCloseStore(hc, 0); }

INLINE void FreeCert(PCCERT_CONTEXT pc)
    { CertFreeCertificateContext(pc); }

INLINE PCCERT_CONTEXT DupCert(const PCCERT_CONTEXT pc)
    { return CertDuplicateCertificateContext(pc); }

///////////////////////////////////////////////////////////////////////////
//
// ctor, dtor
//

CSMime::CSMime(void)
{
    DllAddRef();
    m_cRef  = 1;
    InitializeCriticalSection(&m_cs);
    DOUT("CSMIME::constructor() %#x -> %d", this, m_cRef);
}

CSMime::~CSMime()
{
    DOUT("CSMIME::destructor() %#x -> %d", this, m_cRef);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CSMime::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeSecurity *)this;
    else if (IID_IMimeSecurity == riid)
        *ppv = (IMimeSecurity *)this;
    else
        {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
        }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


STDMETHODIMP_(ULONG) CSMime::AddRef(void)
{
    DOUT("CSMime::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSMime::Release(void)
{
    DOUT("CSMime::Release() %#x -> %d", this, m_cRef-1);
    if (0 == InterlockedDecrement((LPLONG)&m_cRef))
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////
//
// Initialization functions
//

STDMETHODIMP CSMime::CheckInit(void)
{
    register BOOL f;

    EnterCriticalSection(&m_cs);
#ifdef MAC
    f = TRUE;
#else   // !MAC
    f = !!DemandLoadCrypt32();
#endif  // MAC
#ifdef DEBUG
    if(!f) {
        DebugStrf("CSMime not initialized ! ! !\n");
    }
#endif

    LeaveCriticalSection(&m_cs);
    return f ? S_OK : MIME_E_SECURITY_NOTINIT;
}

inline HRESULT CSMime::StaticCheckInit(void)
{
#ifdef MAC
    return S_OK;
#else   // !MAC
    HRESULT hr;

    if(DemandLoadCrypt32()) {
        hr = S_OK;
    }
    else {
#ifdef DEBUG
        DebugStrf("CSMime not initialized ! ! !\n");
#endif
        hr = MIME_E_SECURITY_NOTINIT;
    }
    return hr;
#endif  // MAC
}

/*  InitNew:
**
**  Purpose:
**      Called after the ctor by clients.  Initializes CSMime.
*/
STDMETHODIMP CSMime::InitNew(void)
{
    register HRESULT hr;

    EnterCriticalSection(&m_cs);
    hr = HrInitCAPI();

#ifdef DEBUG
    if (SUCCEEDED(hr))
#ifdef MAC
        InitDebugHelpers((HINSTANCE) 1);
#else   // !MAC
        InitDebugHelpers(/*g_hCryptoDll*/ (HINSTANCE) 1);
#endif  // MAC
    if (0) {
        DumpAlgorithms();
    }
    TrapError(hr);
#endif

    LeaveCriticalSection(&m_cs);
    if (E_FAIL == hr) {
        hr = MIME_E_SECURITY_NOTINIT;
    }
    return hr;
}

/*  InitCAPI:
**
**  Purpose:
**      Loads the required dll and inits the function table.
**  Returns:
**      MIME_E_SECURITY_LOADCRYPT32 if LoadLibrary fails
**      MIME_E_SECURITY_BADPROCADDR if any of the GetProcAddress calls fail
*/
HRESULT CSMime::HrInitCAPI()
{
#ifdef MAC
    return S_OK;
#else   // !MAC
    HRESULT     hr = S_OK;
    UINT        u = 0;
    FARPROC     *pVTable;

    EnterCriticalSection(&g_csDllMain);

    if (!DemandLoadCrypt32()) {
        hr = TrapError(MIME_E_SECURITY_LOADCRYPT32);
        goto ErrorReturn;
    }

exit:
    LeaveCriticalSection(&g_csDllMain);
    return hr;
ErrorReturn:
    {
    DWORD dwErr = GetLastError();
    UnloadCAPI();
    SetLastError(dwErr);
    Assert(S_OK != hr);
    }
    goto exit;
#endif  // MAC
}

/*  UnloadAll:
**
**  Purpose:
**      Called during deinit of our DLL to unload S/MIME
*/
void CSMime::UnloadAll(void)
{
    UnloadCAPI();
    return;
}

/*  UnloadCAPI:
**
**  Purpose:
**      Frees the crypt32 library.  Note that this will
**      cause subsequent CheckInit calls to fail
*/
void CSMime::UnloadCAPI()
{
}

///////////////////////////////////////////////////////////////////////////
//
// Encode/Decode stuff . . .
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//
// Message crackers
//

#ifndef WIN16
HRESULT CSMime::GetMessageType(
    HWND                    hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
#else
HRESULT CSMime::GetMessageType(
    const HWND              hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
#endif // !WIN16
{
    return StaticGetMessageType(hwndParent, pBody, pdwSecType);
}

/*  StaticGetMessageType:
**
**  Purpose:
**      Used to figure out if a message is signed/encrypted/none/both
**      without doing any cryptographic operations.
**  Takes:
**      IN      hwndParent  - all modal UI to this
**      IN      pBody       - body to decode
**         OUT  dwSecType   - which, if any, S/MIME types have been applied
**  Notes:
**      if MIME_E_SECURITY_BADSECURETYPE is returned, pdwSecType is set
**      to the actual CMSG_ return from CAPI.
**      (7/10/97) MIME_E_SECURITY_BADSECURETYPE now comes from CAPISTM.
*/

HRESULT CSMime::StaticGetMessageType(
    HWND                    hwndParent,
    IMimeBody *const        pBody,
    DWORD *const            pdwSecType)
{
    HRESULT     hr;

//    SCHECKSMIMEINIT

    if (!(pBody && pdwSecType))
        return TrapError(E_INVALIDARG);

    CCAPIStm    capistmMsg(NULL);

    hr = capistmMsg.HrInitialize(0, hwndParent, FALSE, NULL, CSTM_TYPE_ONLY, NULL, NULL);
    if (SUCCEEDED(hr)) {
        IStream *       pstmCapi;
        PSECURITY_LAYER_DATA psld;

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);

#ifdef N_BAD1
        // This is what would happen if I were passed a stream
        // instead of a body

        LPSTREAM pstmBody;
        ULARGE_INTEGER  uliCopy;

        hr = pBody->GetData(IET_BINARY, &pstmBody);

        uliCopy.HighPart = (ULONG)-1;
        uliCopy.LowPart = (ULONG)-1;

        pstmBody->CopyTo(pstmCapi, uliCopy, NULL, NULL);
#else
        hr = pBody->GetDataHere(IET_BINARY, pstmCapi);
#endif

        // We expect CAPISTM_E_GOTTYPE because the streamer
        // fails its Write() as soon as it gets the type
        Assert(FAILED(hr));
        // However, try to get the data even if we succeeded.  That
        // would surprise me.

        // BUGBUG: Does this make sense?  We're only dealing with the outer layer here.
        if (psld = capistmMsg.GetSecurityLayerData()) {
            if (CAPISTM_E_GOTTYPE == hr) {
                hr = S_OK;
            }
            *pdwSecType = psld->m_dwMsgEnhancement;
            psld->Release();
        } else {
            hr = E_FAIL;
        }

        pstmCapi->Release();
        hr = capistmMsg.EndStreaming();
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// Encode methods
//


/*  EncodeMessage:
**
**  Purpose:
**      call EncodeBody for lazy developers
**  Takes:
**      IN pTree            - the tree of the message
**      IN dwFlags          - SEF_*
*/
STDMETHODIMP CSMime::EncodeMessage(
    IMimeMessageTree *const pTree,
    DWORD                   dwFlags)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        hr = TrapError(E_INVALIDARG);
    }
    else if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(EncodeBody(pTree, hRoot, dwFlags|EBF_RECURSE|EBF_COMMITIFDIRTY));
    }

    return hr;
}

HRESULT CSMime::EncodeMessage2(IMimeMessageTree *const pTree, DWORD dwFlags,
                               HWND hwnd)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        hr = TrapError(E_INVALIDARG);
    }
    else if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(EncodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE|
                                  EBF_COMMITIFDIRTY, hwnd));
    }

    return hr;
}

/*  EncodeBody:
**
**  Purpose:
**      Do the entirety of the S/MIME encode operation.  This includes converting bodyoptions
**      to SMIMEINFO and calling the appropriate encoding subfunctions.
**
**  Takes:
**      IN pTree        - the tree of the body to encode
**      IN hEncodeRoot  - body from which to encode downward
**      IN dwFlags      - set of EBF_ or SEF_
*/

STDMETHODIMP CSMime::EncodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hEncodeRoot,
    DWORD                   dwFlags)
{
    HRESULT             hr;
    HWND                hwnd = NULL;
    IMimeBody *         pEncodeRoot = NULL;
    PROPVARIANT         var;

    if (! pTree || ! hEncodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody, (void**)&pEncodeRoot));

#ifdef _WIN64
    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) && (NULL != (HWND)(var.pulVal))) {
        Assert(VT_UI8 == var.vt);
        hwnd = *(HWND *)(&(var.uhVal));
    }
#else
    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) && (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        hwnd = (HWND)var.ulVal;
    }
#endif // _WIN64
    
    hr = EncodeBody2(pTree, hEncodeRoot, dwFlags, hwnd);

exit:
    ReleaseObj(pEncodeRoot);

    return hr;
}

HRESULT CSMime::EncodeBody2(IMimeMessageTree *const pTree, HBODY hEncodeRoot,
                            DWORD dwFlags, HWND hwnd)
{
    IMimeAddressTable *     pAdrTable = NULL;
    IMimeEnumAddressTypes * pAdrEnum = NULL;
    CVirtualStream *        pvstmEncoded = NULL;
    IMimeBody *             pEncodeRoot = NULL;
    HRESULT                 hr;
    SMIMEINFO               si;
    CERTARRAY               caCerts;
    BOOL                    fIgnoreSenderCertProbs;
    PSECURITY_LAYER_DATA    psldLoop;
    PROPVARIANT             var;

    memset(&si, 0, sizeof(si));
    memset(&caCerts, 0, sizeof(caCerts));

    if (! pTree || ! hEncodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody, (void**)&pEncodeRoot));

    //  We are going to set the state to don't encode this body
    //  We we are called this should never be set to TRUE as we are getting explicity called.
    //  If it is true, then ignore it.
#ifdef DEBUG
    hr = pEncodeRoot->GetOption(OID_NOSECURITY_ONSAVE, &var);
    Assert((hr == S_OK) && (var.boolVal == FALSE));
#endif // DEBUG
    var.boolVal = TRUE;
    CHECKHR(hr = pEncodeRoot->SetOption(OID_NOSECURITY_ONSAVE, &var));
    hr = OptionsToSMIMEINFO(TRUE, pTree, pEncodeRoot, &si);
    if (S_OK != hr) {
        goto exit;
    }

    if (MIME_S_SECURITY_NOOP == hr) {
        SMDOUT("Encode body called on plain set.");
        goto exit;
    }
    if (EBF_RECURSE & dwFlags) {
        if (MST_DESCENDENT_MASK & si.dwMsgEnhancement) {
            AssertSz(0, "nyi: recursion.");
        }
    }
    if (MIME_S_SECURITY_RECURSEONLY == hr) {
        hr = MIME_S_SECURITY_NOOP;
        SMDOUT("Encode body called on plain body.");
        goto exit;
    }

    fIgnoreSenderCertProbs = (SEF_ENCRYPTWITHNOSENDERCERT|SEF_SENDERSCERTPROVIDED) & dwFlags;


    psldLoop = si.psldLayers;
    while (psldLoop) {
        //  Can only apply one of signing or encryption
        Assert(!!(psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN) +
               !!(psldLoop->m_dwMsgEnhancement & MST_THIS_ENCRYPT) == 1);

        if (psldLoop->m_dwMsgEnhancement & MST_SIGN_MASK) {
            // 2nd attempt at finding a signing cert
            Assert(psldLoop->m_rgSigners != NULL);
            if (psldLoop->m_rgSigners[0].pccert == NULL) {
                CHECKHR(hr = HrGetNeededAddresses(IAT_FROM, pTree, &pAdrTable,
                                                  &pAdrEnum));

                hr = HrGetCertificates(pAdrTable, pAdrEnum, ITT_SIGNING, 
                                       fIgnoreSenderCertProbs, &caCerts);
                if (S_OK != hr) {
                    hr = _HrConvertHrFromGetCertToEncode(hr, FALSE);
                    Assert(FAILED(hr));
                    goto exit;
                }
                Assert(caCerts.rgpCerts);
                Assert(1 == caCerts.cCerts);

                // need the sender's cert listed a second time
                if (caCerts.rgpCerts[0]) {
                    psldLoop->m_rgSigners[0].pccert = DupCert(caCerts.rgpCerts[0]);
                }
            }
        }

        if (psldLoop->m_dwMsgEnhancement & MST_THIS_ENCRYPT) {
            Assert(! caCerts.rgpCerts);

            // 2nd place to look for encryption certs
            ReleaseObj(pAdrTable);
            ReleaseObj(pAdrEnum);
            // NOTE: Do NOT include IAT_REPLYTO in the needed addresses!

#ifdef SMIME_V3
            if (psldLoop->m_rgRecipientInfo == NULL) {
                hr = E_FAIL;
                Assert(FAILED(hr));
                goto exit;
            }
#else  // !SMIME_V3
            if (psldLoop->m_rgEncryptItems == NULL) {
                hr = HrGetNeededAddresses(IAT_FROM | IAT_TO | IAT_CC | IAT_BCC | IAT_SENDER, pTree, &pAdrTable, &pAdrEnum);

                if (SUCCEEDED(hr)) {
                    DWORD i;
                    DWORD dexBogus; // the index into certResults of the NULL sender's cert
                    
                    hr = HrGetCertificates(pAdrTable, pAdrEnum, ITT_ENCRYPTION, 
                                           fIgnoreSenderCertProbs, &caCerts);
                
                    //
                    // Outlook98 doesn't pass us an address table, all of the certs 
                    // are already in the SMIMEINFO struct.  So if we're told that the
                    // sender certs are provided, and we don't have any certificates 
                    // from the table, we just continue.  We'll fail properly
                    // in the zero certificate case down below.
                    //
                
                    if ((S_OK != hr) &&
                        !((MIME_S_SECURITY_NOOP == hr) &&
                          ((fIgnoreSenderCertProbs & SEF_SENDERSCERTPROVIDED) != 0))) {
                        hr = _HrConvertHrFromGetCertToEncode(hr, TRUE);
                        Assert(FAILED(hr));
                        goto exit;
                    }

                    if (caCerts.cCerts == 0) {
                        hr = TrapError(MIME_E_SECURITY_NOCERT);
                        goto exit;
                    }
                        
                    // just reference the certResults as the encryption array
                    Assert(0 == psldLoop->m_cEncryptItems);
                    if (!MemAlloc((LPVOID *) &psldLoop->m_rgEncryptItems,
                                  sizeof(EncryptItem))) {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    psldLoop->m_cEncryptItems = 1;
                    psldLoop->m_rgEncryptItems[0].dwTagType = ENCRYPT_ITEM_TRANSPORT;
                    psldLoop->m_rgEncryptItems[0].Transport.cCert = caCerts.cCerts;
                    psldLoop->m_rgEncryptItems[0].Transport.rgpccert = caCerts.rgpCerts;
                    psldLoop->m_rgEncryptItems[0].Transport.blobAlg.pBlobData = NULL;
                    psldLoop->m_rgEncryptItems[0].Transport.blobAlg.cbSize = 0;
                    caCerts.rgpCerts = NULL;            // we're holding it in the layer now
                    // Encryption algorithm
                    if (SUCCEEDED(pEncodeRoot->GetOption(OID_SECURITY_ALG_BULK, &var)) &&
                        (0 != var.blob.cbSize)) {
                        Assert(VT_BLOB == var.vt);
                        psldLoop->m_rgEncryptItems[0].Transport.blobAlg.pBlobData = var.blob.pBlobData;
                        psldLoop->m_rgEncryptItems[0].Transport.blobAlg.cbSize = var.blob.cbSize;
                    }
                }
            }
            else {
                if (!fIgnoreSenderCertProbs) {
                    hr = TrapError(MIME_E_SECURITY_ENCRYPTNOSENDERCERT);
                    goto exit;
                }
            }
#endif // SMIME_V3
        }   // encryption

        // Clean up cert array for next round
        if (caCerts.rgpCerts) {
            _FreeCertArray(caCerts.rgpCerts, caCerts.cCerts);
            caCerts.rgpCerts = NULL;
        }

        psldLoop = psldLoop->m_psldInner;
    }


    if (!(pvstmEncoded = new CVirtualStream)) {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (FClearSign(si.dwMsgEnhancement)) {
        if (FEncrypt(si.dwMsgEnhancement)) {
            si.dwMsgEnhancement |= MST_BLOB_FLAG;
            CHECKHR(hr = HrEncodeOpaque(&si, pTree, hEncodeRoot, pEncodeRoot, pvstmEncoded, hwnd));
        }
        else {
            CHECKHR(hr = HrEncodeClearSigned(&si, pTree, hEncodeRoot, pEncodeRoot,
                pvstmEncoded, (dwFlags & EBF_COMMITIFDIRTY), hwnd));
            //  Since this went multi-part, the root body changed on us and we need to get
            //  it back
            pEncodeRoot->Release();
            CHECKHR(hr = pTree->BindToObject(hEncodeRoot, IID_IMimeBody,
                                             (void**)&pEncodeRoot));
        }
    }
    else {
        // encryption and/or signedData signature
        CHECKHR(hr = HrEncodeOpaque(&si, pTree, hEncodeRoot, pEncodeRoot, pvstmEncoded, hwnd));
    }

CommonReturn:
    if (pEncodeRoot != NULL)
        {
            var.boolVal = FALSE;
            pEncodeRoot->SetOption(OID_NOSECURITY_ONSAVE, &var);
        }

    ReleaseObj(pAdrTable);
    ReleaseObj(pAdrEnum);
    ReleaseObj(pvstmEncoded);
    ReleaseObj(pEncodeRoot);
    FreeSMIMEINFO(&si);
    return hr;
exit:
    // these objects are only need attention on error
    _FreeCertArray(caCerts.rgpCerts, caCerts.cCerts);
    goto CommonReturn;
}

/*  HrEncodeClearSigned:
**
**  Purpose:
**      Builds the multipart message needed for clear signing and
**      retrieves the data stream to pass to the stream wrapepr.
**  Takes:
**      IN      psi         - needs the certificate array, signing
**                          certificate, etc.
**      IN      pTree       - tree containing body to convert to m/s
**      IN      pEncodeRoot - body that will become 1st child of the m/s
**          OUT lpstmOut    - contains the signature bits (PKCS#7 nodata)
**  Returns:
**      hresult.  no function-specific return values.
*/

HRESULT CSMime::HrEncodeClearSigned(
    SMIMEINFO *const        psi,
    IMimeMessageTree *const pTree,
    const HBODY             hEncodeRoot,
    IMimeBody *const        pEncodeRoot,
    LPSTREAM                lpstmOut,
    BOOL                    fCommit,
    HWND                    hwnd)
{
    HBODY           hNew, hSignature, hData;
    HRESULT         hr;
    HRESULT         hr_smime = S_OK;
    DWORD           i;
    IMimeBody *     pSig = NULL;
    IMimeBody *     pMS = NULL;
    IMimeBody *     pData = NULL;
    IMimeBody *     pRoot = NULL;
    IStream *       pstmMsg = NULL;
    BODYOFFSETS     boData;
    LARGE_INTEGER   liPos;
    PROPVARIANT     var;
#ifdef DEBUG
    BLOB            blobMsg = {NULL,0};
#endif
    ULARGE_INTEGER  uliCopy;
    ALG_ID          aid;
    const char *    lpszProtocol;
    CCAPIStm        capistmMsg(lpstmOut);

    // We need lpstmOut because it is the media of transmission for
    // the signature.  The sig body gets it through SetData

    Assert(psi && hEncodeRoot && pEncodeRoot && pTree && lpstmOut);

    CHECKHR(hr = pTree->ToMultipart(hEncodeRoot, STR_SUB_SIGNED, &hNew));

    if (fCommit) {
        BOOL fCleanup;

        // Need to commit the tree, but if Tonja cleans it, I'll lose my
        // multipart.  So, turn off cleaning and save the value to set back.
        CHECKHR(hr = pTree->GetOption(OID_CLEANUP_TREE_ON_SAVE, &var));
        fCleanup    = var.boolVal ? TRUE : FALSE;
        var.boolVal = FALSE;
        CHECKHR(hr = pTree->SetOption(OID_CLEANUP_TREE_ON_SAVE, &var));
        CHECKHR(hr = pTree->Commit(COMMIT_SMIMETRANSFERENCODE));
        var.boolVal = (VARIANT_BOOL) !!fCleanup;
        pTree->SetOption(OID_CLEANUP_TREE_ON_SAVE, &var);
    }

    CHECKHR(hr = pTree->GetBody(IBL_FIRST, hNew, &hData));
    CHECKHR(hr = pTree->BindToObject(hData, IID_IMimeBody, (LPVOID *)&pData));
    CHECKHR(hr = pData->GetOffsets(&boData));

    // BUG 38411:  I need a clean pristine virginal-white stream
    // so we have to go straight to the horse's smelly mouth.
    CHECKHR(hr = pTree->GetMessageSource(&pstmMsg, 0));

#if defined(DEBUG) && !defined(MAC)
    if (s_fDebugDumpWholeMsg) {
        hr = HrStreamToByte(pstmMsg, &blobMsg.pBlobData, &blobMsg.cbSize);
        HrRewindStream(pstmMsg);
    }
#endif

    // Now slice out the part we actually want
    liPos.HighPart = 0;
    liPos.LowPart = boData.cbHeaderStart;
    CHECKHR(hr = pstmMsg->Seek(liPos, STREAM_SEEK_SET, NULL));

    CHECKHR(hr = capistmMsg.HrInitialize(0, hwnd, TRUE, psi, CSTM_DETACHED, NULL, psi->psldInner));
    if (SUCCEEDED(hr)) {
        IStream *pstmCapi;

        uliCopy.HighPart = 0;
        uliCopy.LowPart = boData.cbBodyEnd-boData.cbHeaderStart;
        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
        hr = pstmMsg->CopyTo(pstmCapi, uliCopy, NULL, NULL);
        pstmCapi->Release();
        CHECKHR(hr = capistmMsg.EndStreaming());
    }

    CHECKHR(hr = pTree->InsertBody(IBL_LAST, hNew, &hSignature));
    CHECKHR(hr = pTree->BindToObject(hSignature, IID_IMimeBody, (void**)&pSig));
    CHECKHR(hr = pSig->SetData(IET_BINARY, STR_CNT_APPLICATION,
      STR_SUB_XPKCS7SIG, IID_IStream, (void*)lpstmOut));
    if (-1 != psi->ietRequested) {
        var.vt = VT_UI4;
        var.ulVal = psi->ietRequested;
        pSig->SetOption(OID_TRANSMIT_BODY_ENCODING, &var);
    }

    // Set the properties for the signature blob as in S/MIGv2 3.3
    var.vt = VT_LPSTR;
    var.pszVal = (LPSTR)STR_DIS_ATTACHMENT;
    CHECKHR(hr = pSig->SetProp(PIDTOSTR(PID_HDR_CNTDISP), 0, &var));

    var.pszVal = (char *)s_szSMIMEP7s;
    pSig->SetProp(PIDTOSTR(PID_PAR_FILENAME), 0, &var);
    pSig->SetProp(PIDTOSTR(PID_PAR_NAME), 0, &var);

    // Set the parameters on the m/s root as in rfc1847 2.1
    CHECKHR(hr = pTree->BindToObject(hNew, IID_IMimeBody, (void**)&pMS));

    var.pszVal = (char *)STR_MIME_APPL_PKCS7SIG;
    CHECKHR(hr = pMS->SetProp(STR_PAR_PROTOCOL, 0, &var));

    // Get the HASH algorithm.  Note that we should NOT get a multi-layer
    // message with Multipart/Signed so we should not have to worry about
    // what layer this is for.
    Assert(psi->psldLayers);
    Assert(psi->psldLayers->m_psldInner == NULL);
    Assert(psi->psldLayers->m_cSigners > 0);
    Assert(psi->psldLayers->m_rgSigners != NULL);
    if (psi->psldLayers->m_cSigners == 0) {
        hr = E_INVALIDARG;
        goto exit;
    }

    lpszProtocol = "unknown";
    // M00BUG -- should add these together and remove duplicates
    for (i=0; i<psi->psldLayers->m_cSigners; i++) {
        hr = MimeOleAlgNameFromSMimeCap(psi->psldLayers->m_rgSigners[i].blobHashAlg.pBlobData,
                                        psi->psldLayers->m_rgSigners[i].blobHashAlg.cbSize,
                                        &lpszProtocol);
    }
    
    var.pszVal = (LPSTR)lpszProtocol;
    CHECKHR(hr = pMS->SetProp(STR_PAR_MICALG, 0, &var));

    var.ulVal = 0;
    CHECKHR(hr = pTree->BindToObject(HBODY_ROOT, IID_IMimeBody, (void**)&pRoot));
    SideAssert(SUCCEEDED(pRoot->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var)));
    SideAssert(SUCCEEDED(pRoot->SetOption(OID_SECURITY_TYPE, &var)));

exit:
#ifdef DEBUG
    if (blobMsg.pBlobData) {
        MemFree(blobMsg.pBlobData);
    }
#endif
    ReleaseObj(pRoot);
    ReleaseObj(pSig);
    ReleaseObj(pData);
    ReleaseObj(pMS);
    ReleaseObj(pstmMsg);
    if (FAILED(hr) && hNew) {
        // need to undo the multipartization and delete the sig body
        // errors are not as important as the one that has already occured
        if (hSignature) {
            pTree->DeleteBody(hSignature, 0);
        }
        pTree->DeleteBody(hNew, DELETE_PROMOTE_CHILDREN);
    }
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = hr_smime;
    }
    return hr;
}

/*  HrEncodeOpaque:
**
**  Purpose:
**
**  Takes:
**      IN      psi         - needs signing cert,
**                            certificate array (opt)
**      IN      pTree       - the normal tree baggage
**      IN      hEncodeRoot - the tree likes handles
**      IN      pEncodeRoot - body to begin encoding at
**         OUT  lpstmOut    - contains the PKCS#7 message
*/
HRESULT CSMime::HrEncodeOpaque(
    SMIMEINFO *const    psi,
    IMimeMessageTree *  pTree,
    HBODY               hEncodeRoot,
    IMimeBody *         pEncodeRoot,
    LPSTREAM            lpstmOut,
    HWND                hwnd)
{
    HRESULT             hr;
    HRESULT             hrCAPI = S_OK;
    CCAPIStm            capistmMsg(lpstmOut);
    IMimePropertySet   *pFullProp = NULL, *pBodyProp = NULL;

    hr = capistmMsg.HrInitialize(0, hwnd, TRUE, psi, 0, NULL, psi->psldInner);
#ifdef INTEROP2
    //N8 This is one half of the fix to do headers correctly
    // In the inner, no 822 headers, just MIME
    // See another N8 comment for the other half, which is to
    // have the outer 822's merged with the inner's MIME headers
    // on decode
    if (SUCCEEDED(hr)) {
        hr = pEncodeRoot->BindToObject(IID_IMimePropertySet, (LPVOID *)&pBodyProp);
    }
    if (SUCCEEDED(hr)) {
        hr = pBodyProp->Clone(&pFullProp);
    }
    if (SUCCEEDED(hr)) {
        LPCSTR  rgszHdrKeep[] = {
            PIDTOSTR(PID_HDR_CNTTYPE),
            PIDTOSTR(PID_HDR_CNTXFER),
            PIDTOSTR(PID_HDR_CNTID),
            PIDTOSTR(PID_HDR_CNTDESC),
            PIDTOSTR(PID_HDR_CNTDISP),
            PIDTOSTR(PID_HDR_CNTBASE),
            PIDTOSTR(PID_HDR_CNTLOC),
            };

        hr = pBodyProp->DeleteExcept(ARRAYSIZE(rgszHdrKeep), rgszHdrKeep);
#endif
        if (SUCCEEDED(hr)) {
            IStream *pstmCapi;

            capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
            hr = pTree->SaveBody(hEncodeRoot, 0, pstmCapi);

#if defined(DEBUG) && !defined(MAC)
            if (s_fDebugDumpWholeMsg) {
                BYTE *pb;
                DWORD cb;

                if (SUCCEEDED(HrStreamToByte(lpstmOut, &pb, &cb))) {
                    MemFree(pb);
                }
            }
#endif
            pstmCapi->Release();
            hrCAPI = capistmMsg.EndStreaming();
            if (SUCCEEDED(hr)) {    // hr from the SaveBody takes precedence
                hr = hrCAPI;
            }
        }
#ifdef INTEROP2
    }
#endif

    if (SUCCEEDED(hr)) {
        PROPVARIANT     var;
        
        pTree->DeleteBody(hEncodeRoot, DELETE_CHILDREN_ONLY);
        pEncodeRoot->EmptyData();

        var.ulVal = 0;
        SideAssert(SUCCEEDED(pEncodeRoot->SetOption(OID_SECURITY_TYPE, &var)));
        SideAssert(SUCCEEDED(pEncodeRoot->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var)));

#ifdef INTEROP2
        // reset the propset
        pFullProp->CopyProps(0, NULL, pBodyProp);
#endif

        //QPTEST DebugDumpStreamToFile(lpstmOut, "c:\\hexin.bin");

        hr = pEncodeRoot->SetData(IET_BINARY, STR_CNT_APPLICATION,
          STR_SUB_XPKCS7MIME, IID_IStream, (void*)lpstmOut);

        if (SUCCEEDED(hr)) {
            PROPVARIANT var;

            var.vt = VT_UI4;
            if (-1 != psi->ietRequested) {
                var.ulVal = psi->ietRequested;
            }
            else {
                var.ulVal = IET_BASE64;
            }
            pEncodeRoot->SetOption(OID_TRANSMIT_BODY_ENCODING, &var);

            // Set the properties for the opaque blob as in S/MIGv2 3.3
            var.vt = VT_LPSTR;
            var.pszVal = (LPSTR)STR_DIS_ATTACHMENT;
            pEncodeRoot->SetProp(PIDTOSTR(PID_HDR_CNTDISP), 0, &var);

            var.pszVal = (LPSTR)s_szSMIMEP7m;
            pEncodeRoot->SetProp(PIDTOSTR(PID_PAR_FILENAME), 0, &var);
            pEncodeRoot->SetProp(PIDTOSTR(PID_PAR_NAME), 0, &var);

            if (FEncrypt(psi->dwMsgEnhancement))
                {
                var.pszVal = (LPSTR) STR_SMT_ENVELOPEDDATA;
                }
            else
                {
#ifdef SMIME_V3
                if ((psi->pszInnerContent != NULL) &&
                    (strcmp(psi->pszInnerContent, szOID_SMIME_ContentType_Receipt) == 0))
                    {
                    var.pszVal = (LPSTR) STR_SMT_SIGNEDRECEIPT;
                    }
                else 
                    {
                    var.pszVal = (LPSTR) STR_SMT_SIGNEDDATA;
                    }
#else  // !SMIME_V3
                var.pszVal = (LPSTR) STR_SMT_SIGNEDDATA;
#endif // SMIME_V3
                }
            pEncodeRoot->SetProp(STR_PAR_SMIMETYPE, 0, &var);
        }
    }

    ReleaseObj(pFullProp);
    ReleaseObj(pBodyProp);
    return hr;
}


///////////////////////////////////////////////////////////////////////////
//
// Decode methods
//

/*  DecodeMessage:
**
**  Purpose:
**      To rip the shroud of secrecy from a message, leaving it naked in the
**      harsh light of dawning comprehension.  However, this function hides
**      the unsightly goings-on that accomplish this task, simply returning
**      a radically different tree
**  Takes:
**      IN pTree            - the message's tree
**      IN dwFlags          - expansion.  must be 0
**  Returns:
**      a variety of good and bad responses
*/
HRESULT CSMime::DecodeMessage(
    IMimeMessageTree *const pTree,
    DWORD                   dwFlags)
{
    HRESULT             hr;
    HBODY               hRoot;
    HWND                hwnd = NULL;
    IMimeBody *         pDecodeRoot = NULL;
    PROPVARIANT         var;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        return TrapError(E_INVALIDARG);
    }

    if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {

        CHECKHR(hr = pTree->BindToObject(hRoot, IID_IMimeBody, (void**)&pDecodeRoot));
        
#ifdef _WIN64
        if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) &&
            (NULL != (HWND)(var.pulVal)))
            {
            Assert(VT_UI8 == var.vt);
            hwnd = *(HWND *)(&(var.uhVal));
            }
#else
        if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) &&
            (NULL != var.ulVal)) 
            {
                Assert(VT_UI4 == var.vt);
                hwnd = (HWND)var.ulVal;
            }
#endif // _WIN64
    
        hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, NULL,
                                   hwnd, NULL));
    }

exit:
    ReleaseObj(pDecodeRoot);

    return hr;
}

HRESULT CSMime::DecodeMessage2(IMimeMessageTree *const pTree, DWORD dwFlags,
                               HWND hwnd, IMimeSecurityCallback * pCallback)
{
    HRESULT hr;
    HBODY   hRoot;

    if (!pTree || (dwFlags & ~SEF_MASK)) {
        return TrapError(E_INVALIDARG);
    }

    if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
        hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, NULL,
                                   hwnd, pCallback));
    }

    return hr;
}

/*  DecodeBody:
**
**  Purpose:
**      Do the entirety of the S/MIME decode operation.
**
**  Takes:
**      IN pTree        - the tree of the body to decode
**      IN hEncodeRoot  - body from which to decode downward
**      IN dwFlags      - set of DBF_ or SDF_
*/
HRESULT CSMime::DecodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags)
{
    return DecodeBody(pTree, hDecodeRoot, dwFlags, NULL);
}

/*  DecodeBody:
**
**  Purpose:
**      The X-rated version of the released (interface) copy.  This
**      one can tell if it has been recursed and merge the data.
**
**  Takes:
**      all the scenes of the original film plus:
**      IN psiOuterOp   - SMIMEINFO from the outer operation
**                      Note that this doesn't really mean
**                      subbodys or messages, but nested S/MIME.
**                      Simplest case is clearsigned in encryption.
*/
HRESULT CSMime::DecodeBody(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags,
    SMIMEINFO *             psiOuterOp)
{
    HRESULT             hr;
    HWND                hwnd = NULL;
    IMimeBody *         pDecodeRoot = NULL;
    PROPVARIANT         var;

    if (! pTree || ! hDecodeRoot) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //  Get the body we are suppose to be encoding
    CHECKHR(hr = pTree->BindToObject(hDecodeRoot, IID_IMimeBody, (void**)&pDecodeRoot));

#ifdef _WIN64
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER_64, &var)) && (NULL != (HWND)(var.pulVal))) {
        Assert(VT_UI8 == var.vt);
        hwnd = *(HWND *)(&(var.uhVal));
    }
#else
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HWND_OWNER, &var)) && (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        hwnd = (HWND)var.ulVal;
    }
#endif // _WIN6
    
    hr = DecodeBody2(pTree, hDecodeRoot, dwFlags, psiOuterOp, hwnd, NULL);

exit:
    ReleaseObj(pDecodeRoot);

    return hr;
}

HRESULT CSMime::DecodeBody2(
    IMimeMessageTree *const pTree,
    HBODY                   hDecodeRoot,
    DWORD                   dwFlags,
    SMIMEINFO *             psiOuterOp,
    HWND                    hwnd,
    IMimeSecurityCallback * pCallback)
{
    PROPVARIANT         var;
    IMimeBody *         pData;
    IMimeBody *         pDecodeRoot = NULL;
    HRESULT             hr, hr_smime = S_OK;
    HBODY               hSignature, hData;
    SMIMEINFO           si;
    CVirtualStream *    pvstmDecoded = NULL;
    IStream *           pstmMsg = NULL;

    if (!(pTree && hDecodeRoot)) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    //
    //  Get the body we are going to decode
    //
    
    CHECKHR(hr = pTree->BindToObject(hDecodeRoot, IID_IMimeBody, (void**)&pDecodeRoot));

    memset(&si, 0, sizeof(SMIMEINFO));
    OptionsToSMIMEINFO(FALSE, pTree, pDecodeRoot, &si);

    //
    //  If we know what crypt provider to use, then grab it
    //

#ifndef _WIN64    
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HCRYPTPROV, &var)) &&
            (NULL != var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        si.hProv = var.ulVal;
    }
#else // _WIN64
    if (SUCCEEDED(pDecodeRoot->GetOption(OID_SECURITY_HCRYPTPROV_64, &var)) &&
            (NULL != var.pulVal)) 
    {
        Assert(VT_UI8 == var.vt);
        si.hProv = (HCRYPTPROV) var.pulVal;
    }

#endif //_WIN64
    //
    //  Determine if this is a multi-part signed message, if so then do the appropriate
    //  decoding.  Determined by "content-type: multipart/signed; protocol=pkcs7-signature"
    //
    
    if (S_OK == pDecodeRoot->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) &&
        IsSMimeProtocol(pDecodeRoot)) {
        
        CHECKHR(hr = pTree->GetBody(IBL_FIRST, hDecodeRoot, &hData));
        CHECKHR(hr = pTree->GetBody(IBL_LAST, hDecodeRoot, &hSignature));
        if FAILED(hr_smime = HrDecodeClearSigned(dwFlags, &si, pTree, hData,
                                                 hSignature, hwnd, pCallback)) {
            goto exit;
        }

        // now we need to make the message readable.  get rid of the signature
        // blob.  this will leave the m/s with one child, the message data.
        // delete the parent with DELETE_PROMOTE_CHILDREN and this will
        // kick the data body up as the only remaining body.
        pTree->DeleteBody(hSignature, 0);
        pTree->DeleteBody(hDecodeRoot, DELETE_PROMOTE_CHILDREN);
        pTree->Commit(0);
    }
    //
    //  Determine if this is a blob signed or encrypted message.  If it is then
    //  do the appropriate decoding.
    //
    
    else if (S_OK == pDecodeRoot->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
             S_OK == pDecodeRoot->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME)) {
        
        //
        //  Create the stream to hold the decoded mime body
        //
    
        if (!(pvstmDecoded = new CVirtualStream)) {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        //
        //  Do the actual decode of the message.  This produces the decode stream in
        //      pvstmDecode.
        //

        if (FAILED(hr_smime = HrDecodeOpaque(dwFlags, &si, pDecodeRoot,
                                             pvstmDecoded, hwnd, pCallback))) {
            goto exit;
        }

        // Header bug fix:
        // we need to blow away the subtree below this body
        // however, we have to keep the 822 headers around. This option
        // change does this, mostly.  the EmptyData call removes
        // some of the body's properties, most notably the content-*
        // ones.  when I use RELOAD_HEADER_REPLACE, the inner body
        // will blow away any of the overlapping outer headers, but
        // keep the ones that don't exist.
        //
        // Why did I do this?
        // Deming doesn't put a from: line in the #7 signedData.  We
        // shoudln't either.  Now we don't.  Without this fix, this
        // would prevent us from being able to add to WAB because
        // the address table would be empty.

        CHECKHR(hr = pTree->DeleteBody(hDecodeRoot, DELETE_CHILDREN_ONLY));
        CHECKHR(hr = pDecodeRoot->EmptyData());

        ULONG ulOldval;
        pTree->GetOption(OID_HEADER_RELOAD_TYPE, &var);
        Assert(VT_UI4 == var.vt);
        ulOldval = var.ulVal;
        var.ulVal = RELOAD_HEADER_REPLACE;
        pTree->SetOption(OID_HEADER_RELOAD_TYPE, &var);

        //
        //  Load the decoded message back into the message so that we can have the
        //      decrypted message.
        //
        
        CHECKHR(hr = pTree->Load(pvstmDecoded));

        var.ulVal = ulOldval;
        pTree->SetOption(OID_HEADER_RELOAD_TYPE, &var);

        //
        //  Grab the root node -- this is where we are going to put the info relative
        //      to the decryption/decoding we just did.
        //
        
        CHECKHR(hr = pTree->GetBody(IBL_ROOT, NULL, &hData));
    }
    else {
        hr = MIME_S_SECURITY_NOOP;
        goto exit;
    }

    // now, this could be way cool and actually have another S/MIME part inside
    // The most common case is a clear signed message inside of encryption, but
    // others could occur.
    // Recurse!

    {
        HBODY   hRoot;

        if (SUCCEEDED(hr = pTree->GetBody(IBL_ROOT, NULL, &hRoot))) {
            hr = TrapError(DecodeBody2(pTree, hRoot, dwFlags|EBF_RECURSE, &si,
                                       hwnd, pCallback));
        }

        CHECKHR(hr);
    }

    if (hr == MIME_S_SECURITY_NOOP) {
        hr = S_OK;
    }
    else {
        hData = HBODY_ROOT;
    }

    //
    //  If this is the root of the decode, then we move the decryption information back
    //  into the message we are dealing with.  If this is not the root then merge together
    //  the S/MIME info structure from the caller.
    //
    
    if (psiOuterOp == NULL) {
        hr = SMIMEINFOToOptions(pTree, &si, hData);
    }
    else {
        hr = MergeSMIMEINFO(psiOuterOp, &si);
    }
    Assert(SUCCEEDED(hr));

exit:
    ReleaseObj(pDecodeRoot);
    ReleaseObj(pstmMsg);
    ReleaseObj(pvstmDecoded);
    FreeSMIMEINFO(&si);
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = (MIME_E_SECURITY_NOOP == hr_smime) ? MIME_S_SECURITY_NOOP : hr_smime;
    }

    return TrapError(hr);
}

/*  HrDecodeOpaque:
**
**  Purpose:
**
**  Takes:
**
**
*/

HRESULT CSMime::HrDecodeOpaque(DWORD dwFlags,
    SMIMEINFO *const    psi,
    IMimeBody *const    pBody,
    IStream *const      pstmOut,
    HWND                hwnd,
                               IMimeSecurityCallback * pCallback)
{
    HRESULT     hr;
    CCAPIStm    capistmMsg(pstmOut);

    hr = capistmMsg.HrInitialize(dwFlags, hwnd, FALSE, psi, 0, pCallback, NULL);
    if (SUCCEEDED(hr)) {
        IStream *       pstmCapi;
        HCRYPTMSG       hMsg;

        //QPTEST hr = pBody->GetDataHere(IET_BINARY, pstmOut);
        //QPTEST DebugDumpStreamToFile(pstmOut, "c:\\stmout.bin");
        //QPTEST HrRewindStream(pstmOut);

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);
        hr = pBody->GetDataHere(IET_BINARY, pstmCapi);
        pstmCapi->Release();
        if (FAILED(hr)) goto exit;
        CHECKHR(hr = capistmMsg.EndStreaming());

#if defined(DEBUG) && !defined(MAC)
        if (s_fDebugDumpWholeMsg) {
            BYTE *pb;
            DWORD cb;

            if (SUCCEEDED(HrStreamToByte(pstmOut, &pb, &cb))) {
                MemFree(pb);
            }
        }
#endif

        hr = CAPISTMtoSMIMEINFO(&capistmMsg, psi);
    }
exit:
    return hr;
}

/*  HrDecodeClearSigned:
**
**  Purpose:
**      Reform the signed body to be hashed and extract the signature
**      data.  Pass these through to the interface stream method.
**  Takes:
**      IN      dwFlags     - Control Flags for the decode
**      IN OUT  psi         - passed to DecodeDetachedStream
**      IN      pTree       - tree to get message source from
**      IN      hData       - handle to body with signed data
**      IN      hSig        - handle to body with signature
**  Returns:
**      hresult.  no function-specific return values.
*/

HRESULT CSMime::HrDecodeClearSigned(DWORD dwFlags,
    SMIMEINFO *const        psi,
    IMimeMessageTree *const pTree,
    const HBODY             hData,
    const HBODY             hSig,
    HWND                    hwnd, IMimeSecurityCallback * pCallback)
{
    HRESULT         hr, hr_smime=S_OK;
    IMimeBody      *pData = NULL,
                   *pSig = NULL;
    IStream        *pstmSig,
                   *pstmMsg = NULL;
    BODYOFFSETS     boData;
    LARGE_INTEGER   liPos;
    ULARGE_INTEGER  uliToCopy;
    CVirtualStream *pvstmDecoded = NULL;
    CCAPIStm        capistmMsg(NULL);
#ifdef DEBUG
    BLOB            blobMsg = {NULL,0};
#endif

    CHECKHR(hr = pTree->BindToObject(hData, IID_IMimeBody, (void**)&pData));
    CHECKHR(hr = pData->GetOffsets(&boData));

    // BUG 38411:  I need a clean pristine virginal-white stream
    // so we have to go straight to the horse's smelly mouth.

    CHECKHR(hr = pTree->GetMessageSource(&pstmMsg, 0));
#if defined(DEBUG) && !defined(MAC)
    if (s_fDebugDumpWholeMsg) {
        CHECKHR (hr = HrStreamToByte(pstmMsg, &blobMsg.pBlobData, &blobMsg.cbSize));
        HrRewindStream(pstmMsg);
    }
#endif

    // Compute the portion we want of the mondo stream
    liPos.HighPart = 0;
    liPos.LowPart = boData.cbHeaderStart;
    CHECKHR(hr = pstmMsg->Seek(liPos, STREAM_SEEK_SET, NULL));

    hr = capistmMsg.HrInitialize(dwFlags, hwnd, FALSE, psi, CSTM_DETACHED, pCallback, NULL);
    if (SUCCEEDED(hr)) {
        IStream *pstmCapi;

        capistmMsg.QueryInterface(IID_IStream, (void**)&pstmCapi);

        // Get the signature data and feed it in
        hr = pTree->BindToObject(hSig, IID_IMimeBody, (void**)&pSig);
        if (SUCCEEDED(hr)) {
            hr = pSig->GetDataHere(IET_BINARY, pstmCapi);
            if (SUCCEEDED(hr)) {
                hr = capistmMsg.EndStreaming();
            }
        }

        uliToCopy.HighPart = 0;
        uliToCopy.LowPart = boData.cbBodyEnd-boData.cbHeaderStart;

        // Now feed in the actual data to hash
        if (SUCCEEDED(hr)) {
            hr = pstmMsg->CopyTo(pstmCapi, uliToCopy, NULL, NULL);
        }
        
        if (SUCCEEDED(hr)) {
            hr = capistmMsg.EndStreaming();
        }

        if (SUCCEEDED(hr)) {
            hr = CAPISTMtoSMIMEINFO(&capistmMsg, psi);
        }

        pstmCapi->Release();
    }

exit:
    ReleaseObj(pData);
    ReleaseObj(pSig);
    ReleaseObj(pstmMsg);
#ifdef DEBUG
    if (blobMsg.pBlobData) {
        MemFree(blobMsg.pBlobData);
    }
#endif
    if (S_OK != hr_smime && SUCCEEDED(hr)) {
        hr = hr_smime;
    }
    return hr;
}

HRESULT CSMime::CAPISTMtoSMIMEINFO(CCAPIStm *pcapistm, SMIMEINFO *psi)
{
    DWORD               i;
    PSECURITY_LAYER_DATA psldMessage = pcapistm->GetSecurityLayerData();

    psi->dwMsgEnhancement = MST_NONE;
    psi->ulMsgValidity = MSV_OK;

#ifdef DEBUG
    {
        DWORD dwLevel = 0;
        PSECURITY_LAYER_DATA psldLoop;

        psldLoop = psldMessage;
        if (psldLoop) {
            SMDOUT("Decode called on:");
        }
        else {
            SMDOUT("Decode called but the message data is NULL.");
        }

        dwLevel = 0;
        while (psldLoop) {
            for (DWORD i = 0; i <= dwLevel; i++) {
                DebugTrace("     ");
            }

            if (MST_BLOB_FLAG & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("CMSG_SIGNED");
            }
            else if ((MST_THIS_SIGN | MST_THIS_ENCRYPT) ==
              ((MST_THIS_SIGN | MST_THIS_ENCRYPT) & psldLoop->m_dwMsgEnhancement)) {
                SMDOUT("CMSG_SIGNED_AND_ENVELOPED, uhoh.");
            }
            else if (MST_THIS_SIGN & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("clear signed mail");
            }
            else if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
                SMDOUT("CMSG_ENVELOPED");
            }
            dwLevel++;
            psldLoop = psldLoop->m_psldInner;
        }
    }
#endif

    if (psldMessage) {
        PSECURITY_LAYER_DATA psldLoop;

        Assert(0 == psi->dwMsgEnhancement);
        Assert(0 == psi->ulMsgValidity);
        Assert(NULL == psi->psldLayers);
        Assert(NULL == psi->psldEncrypt);
        Assert(NULL == psi->psldInner);

        psi->psldLayers = psldMessage;
        psi->psldLayers->AddRef();

        for (psldLoop = psldMessage; psldLoop != NULL; 
             psldLoop = psldLoop->m_psldInner) {
            
            psi->dwMsgEnhancement |= psldLoop->m_dwMsgEnhancement;
            psi->fCertWithMsg |= psldLoop->m_fCertInLayer;
            if (MST_THIS_SIGN & psldLoop->m_dwMsgEnhancement) {
                for (i=0; i<psldLoop->m_cSigners; i++) {
                    psi->ulMsgValidity |= psldLoop->m_rgSigners[i].ulValidity;
                }
            }

            //
            //  We need to get the inner most encryption item here.
            //
            
            if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
                psi->ulMsgValidity |= psldLoop->m_ulDecValidity;

                // Keep track of the innermost encryption layer for easy access

                psi->psldEncrypt = psldLoop;
            }

            if (! psldLoop->m_psldInner) {
                psi->psldInner = psldLoop;
            }

        }
        CCAPIStm::FreeSecurityLayerData(psldMessage);
    }

    // need to handle this stuff again
    //hr = MIME_E_SECURITY_CANTDECRYPT;
    //case CMSG_SIGNED_AND_ENVELOPED:
    //case CMSG_DATA:
    //default:
    //hr = MIME_E_SECURITY_UNKMSGTYPE;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
//
// Crytographic transformations... functions that do the real work
//
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//
// Signature verification and decryption
//


///////////////////////////////////////////////////////////////////////////
//
// Other function sets
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
//

// Other certificate routines
//


/*  GetCertificateName:
**
**  Purpose:
**
**  Takes:
**      IN pX509Cert    - certificate from which to snarf name
**      IN cn           - style of name to return (SIMPLE|OID|X500)
**      OUT ppszName    - name gets stuffed here.  Caller frees.
**  Returns:
**      hresult
*/
STDMETHODIMP CSMime::GetCertificateName(
    const PCX509CERT    pX509Cert,
    const CERTNAMETYPE  cn,
    LPSTR *             ppszName)
{
    DWORD   flag, cch;
    HRESULT hr;

    CHECKSMIMEINIT
    if (!(pX509Cert && ppszName)) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // convert to CAPI flag
    switch (cn) {
        case SIMPLE:
            flag = CERT_SIMPLE_NAME_STR;
            break;
        case OID:
            flag = CERT_OID_NAME_STR;
            break;
        case X500:
            flag = CERT_X500_NAME_STR;
            break;
        default:
            hr = TrapError(E_INVALIDARG);
            goto exit;
    }

#define pCert ((PCCERT_CONTEXT)pX509Cert)
    cch = CertNameToStr(pCert->dwCertEncodingType, &pCert->pCertInfo->Subject,
        flag, NULL, 0);
    CHECKHR(hr = HrAlloc((void**)ppszName, cch*sizeof(TCHAR)));
    CertNameToStr(pCert->dwCertEncodingType, &pCert->pCertInfo->Subject,
      flag|CERT_NAME_STR_SEMICOLON_FLAG, *ppszName, cch);
#undef pCert

exit:
    return hr;
}

/*  HrGetCertsFromThumbprints:
**
**  Purpose:
**      This version of the function opens the "My" and "AddressBook" stores
**      and calls the exposed GetCertsFromThumbprints method.
**
*/
HRESULT CSMime::HrGetCertsFromThumbprints(
    THUMBBLOB *const        rgThumbprint,
    X509CERTRESULT *const   pResults)
{
    HRESULT     hr = E_FAIL;
    const DWORD cStores = 2;
    HCERTSTORE  rgCertStore[cStores];

    rgCertStore[0] = OpenCachedMyStore();
    if (rgCertStore[0]) {
        rgCertStore[1] = OpenCachedAddressBookStore();
        if (rgCertStore[1]) {
            hr = MimeOleGetCertsFromThumbprints(rgThumbprint, pResults, rgCertStore, cStores);
            CertCloseStore(rgCertStore[1], 0);
        }
        else {
            // No WAB store, so there are NO matching certs
            CRDOUT("No thumbprints in WAB");
            for (ULONG iEntry = 0; iEntry < pResults->cEntries; iEntry++) {
                pResults->rgpCert[iEntry] = NULL;
                pResults->rgcs[iEntry] = CERTIFICATE_NOPRINT;
            }
            hr = MIME_S_SECURITY_ERROROCCURED;
        }
        CertCloseStore(rgCertStore[0], 0);
    }

    return hr;
}

/*  EnumCertificates:
**
**  Purpose:
**      enumerate certificates from a store
**  Takes:
**      IN hc       - store to query
**      IN dwUsage  - ITT_* or 0
**                      maps to a CAPI dwKeyUsage (AT_*)
**      IN pPrev    - last certificate received from this function
**                      (NULL to get first cert)
**      OUT pCert   - certificate next in enumeration
**  Notes:
**      pPrev and pCert may reference the same variable
**      dwUsage may be 0 if caller just wants to check for existance of any certs
**  Returns:
**      CRYPT_E_NOT_FOUND if no more certs
**      S_FALSE if dwUsage is 0 and no certs exist
*/
STDMETHODIMP CSMime::EnumCertificates(
    HCAPICERTSTORE  hc,
    DWORD           dwUsage,
    PCX509CERT      pPrev,
    PCX509CERT *    ppCert)
{
    HRESULT         hr;
    PCCERT_CONTEXT  pNewCert = NULL;

    CHECKSMIMEINIT
    if (!(hc && (ppCert || !dwUsage))) {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    if (ITT_SIGNING == dwUsage || ITT_ENCRYPTION == dwUsage) {
        dwUsage = AT_KEYEXCHANGE;
        hr = HrFindUsableCert((HCERTSTORE)hc, (BYTE)dwUsage, (PCCERT_CONTEXT)pPrev, &pNewCert);
    }
    else if (0 == dwUsage) {
        pNewCert = CertEnumCertificatesInStore(hc, NULL);
        if (pNewCert) {
            hr = S_OK;
            FreeCert(pNewCert);
        }
        else {
            hr = S_FALSE;
        }
    }
    else {
        hr = TrapError(E_INVALIDARG);
    }

exit:
    if (ppCert) {
        *ppCert = (PCX509CERT)pNewCert;
    }
    return hr;
}

/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (!(error & 0x80000000)) {
        hr = error | 0x80070000;    // system error
    } else {
        hr = (HRESULT)error;
    }

    return(hr);
}

/*  HrFindUsableCert:
**
**  Purpose:
**      Get a cert out of a cert store that has the right keyspec
**  Takes:
**      IN hCertStore   - store to enumerate
**      IN dwKeySpec    - AT_SIGNATURE or AT_KEYEXCHANGE
**      IN pPrevCert    - last certificate received from this function
**                          (NULL to get first cert)
**      OUT ppCert      - the matching cert, NULL iff none
**  Returns:
**      SMIME_E_NOCERT if no cert can be found
*/
HRESULT CSMime::HrFindUsableCert(
    HCERTSTORE      hCertStore,
    BYTE            dwKeySpec,
    PCCERT_CONTEXT  pPrevCert,
    PCCERT_CONTEXT *ppCert)
{
    PCCERT_CONTEXT          pCert;
    PCRYPT_KEY_PROV_INFO    pKPI;
    HRESULT                 hr = S_OK;
    BOOL                    fFound = FALSE;
    PCERT_NAME_INFO         pNameInfo;
    PCERT_RDN_ATTR          pRDNAttr;
#ifdef DEBUG
    DWORD                   count=0;
#endif
    LPTSTR                  lpEmailAddress;

    CHECKSMIMEINIT
    Assert(hCertStore && ppCert);
    Assert(AT_SIGNATURE == dwKeySpec || AT_KEYEXCHANGE == dwKeySpec);

    *ppCert = NULL;
    pKPI = NULL;
    while (!fFound) {
        pCert = CertEnumCertificatesInStore(hCertStore, pPrevCert);
        if (pCert == NULL) { // no more certs?
            break;
        }

        // Need to find the key provider
        pKPI = (PCRYPT_KEY_PROV_INFO)PVGetCertificateParam(pCert, CERT_KEY_PROV_INFO_PROP_ID, NULL);
#ifdef DEBUG
        count++;

        // We want to be able to send broken mail so that the
        // verify/decrypt fails.
        if (s_fDebugEmitBroken) {
            if (pKPI && pKPI->dwKeySpec != dwKeySpec) fFound = TRUE;
        }
        else {
            if (pKPI && pKPI->dwKeySpec == dwKeySpec) fFound = TRUE;
        }
#else
        if (pKPI && pKPI->dwKeySpec == dwKeySpec)  {
            fFound = TRUE;
        }
#endif

        // Validate the email address
        if (fFound && (lpEmailAddress = SzGetCertificateEmailAddress(pCert))) {
            MemFree(lpEmailAddress);
        }
        else {
#ifdef DEBUG
            {
                SMDOUT("Certificate %d has no email address", count);
                if (fFound && !s_fDebugAllowNoEmail) {
                    fFound = FALSE;
                }
            }
#else
            fFound = FALSE;
#endif
        }


        if (pKPI) {
            MemFree(pKPI);
            pKPI = NULL;
        }
        pPrevCert = pCert;  // next enumeration round
    }  // enum

    if (pCert == NULL) {
        CRDOUT("Couldn't find a signature cert having a key provider");
        hr = HrGetLastError();
        if (hr == CRYPT_E_NOT_FOUND) {
            hr = S_FALSE;
        }
        else {
            hr = MIME_E_SECURITY_NOCERT;
        }
    }
#ifdef DEBUG
    else {
        CRDOUT("Usable cert #%d found with keyspec==%d", count, dwKeySpec);
        Assert(pCert);
        if (s_fDebugShowFoundCert) {
            DisplayCert(pCert);
        }
    }
#endif

    *ppCert = pCert;
    return TrapError(hr);
}

///////////////////////////////////////////////////////////////////////////
//
// Other functions
//
///////////////////////////////////////////////////////////////////////////


/*  HrGetNeededAddresses:
**
**  Purpose:
**      get the maximum set of addresses needed for S/MIME to work
**  Takes:
**      IN dwTypes      - class(es) of addresses to get
**      IN pTree        - source of addresses
**      OUT ppEnum      - enumerator for found addresses
*/
HRESULT CSMime::HrGetNeededAddresses(
    const DWORD             dwTypes,
    IMimeMessageTree *      pTree,
    IMimeAddressTable **    ppAdrTable,
    IMimeEnumAddressTypes **ppEnum)
{
    HRESULT         hr;

    Assert(ppEnum && ppAdrTable && pTree);

    if (SUCCEEDED(hr = pTree->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (void**)ppAdrTable))) {
        hr = (*ppAdrTable)->EnumTypes(dwTypes,
          IAP_HANDLE | IAP_ADRTYPE | IAP_SIGNING_PRINT | IAP_ENCRYPTION_PRINT | IAP_CERTSTATE, ppEnum);
    }
    return hr;
}

/*  HrGetThumbprints:
**
**  Purpose:
**
**  Takes:
**      IN pEnum            - enumerator walked for source addresses
**      IN dwType           - which SECURE-type certs are needed
**      OUT rgThumbprint    - array of found thumbprints
**  Returns:
**      S_OK, unless a GetProp call fails
**      E_FAIL if the loop doesn't run for Count times
*/
HRESULT CSMime::HrGetThumbprints(
    IMimeEnumAddressTypes * pEnum,
    const ITHUMBPRINTTYPE   ittType,
    THUMBBLOB *const        rgThumbprint)
{
    HRESULT             hr = S_OK;
    ADDRESSPROPS        apEntry;
    const ULONG         numToGet = 1;
    ULONG               cPrints = 0;

    Assert(pEnum && rgThumbprint);
    Assert((ITT_SIGNING == ittType) || (ITT_ENCRYPTION == ittType));
    Assert(!IsBadWritePtr(rgThumbprint, sizeof(THUMBBLOB)*cPrints));

    pEnum->Reset();
    while(S_OK == pEnum->Next(numToGet, &apEntry, NULL)) {
        // if the print isn't found, we deal with that elsewhere
        if (ITT_SIGNING == ittType) {
            Assert((apEntry.tbSigning.pBlobData && apEntry.tbSigning.cbSize) ||
                  (!apEntry.tbSigning.pBlobData && !apEntry.tbSigning.cbSize));
            if (apEntry.tbSigning.cbSize) {
                // we need to null out the thumbprint flag so print doesn't get
                // freed below
                rgThumbprint[cPrints].pBlobData = apEntry.tbSigning.pBlobData;
                rgThumbprint[cPrints].cbSize = apEntry.tbSigning.cbSize;
                apEntry.dwProps &= ~IAP_SIGNING_PRINT;
            }
        }
        else {
            Assert(ITT_ENCRYPTION == ittType);
            Assert((apEntry.tbEncryption.pBlobData && apEntry.tbEncryption.cbSize) ||
                  (!apEntry.tbEncryption.pBlobData && !apEntry.tbEncryption.cbSize));
            if (apEntry.tbEncryption.cbSize) {
                // we need to null out the thumbprint flag so print doesn't get
                // freed below
                rgThumbprint[cPrints].pBlobData = apEntry.tbEncryption.pBlobData;
                rgThumbprint[cPrints].cbSize = apEntry.tbEncryption.cbSize;
                apEntry.dwProps &= ~IAP_ENCRYPTION_PRINT;
            }
        }
        cPrints++;

        g_pMoleAlloc->FreeAddressProps(&apEntry);
    }

    return hr;
}

/*  HrGetCertificates:
**
**  Purpose:
**      Get certificates based from thumbprints, then update the address
**      table based on the return of that operation
**  Takes:
**      IN pEnum        - enumerator that provides the thumbprints
**      IN dwType       - which certs are needed
**      IN fAlreadyHaveSendersCert - if the sender's cert is already found
**      OUT pResults    - get an array of certs and the assoc certstates
**                        pResults->cEntries has the size measured in entries
**  Returns:
**      SMIME_E_CERTERROR if not all certs were retrieved
*/
HRESULT CSMime::HrGetCertificates(
    IMimeAddressTable *const    pAdrTable,
    IMimeEnumAddressTypes *     pEnum,
    const DWORD                 dwType,
    const BOOL                  fAlreadyHaveSendersCert,
    CERTARRAY *                 pcaCerts)
{
    HRESULT         hr;
    THUMBBLOB *     rgThumbprint;
    ULONG           cCerts;
    X509CERTRESULT  certResults;

    Assert(pAdrTable && pEnum && pcaCerts);

    pcaCerts->rgpCerts = NULL;
    pcaCerts->cCerts = 0;

    pEnum->Count(&cCerts);
    if (! cCerts) {
        return MIME_S_SECURITY_NOOP;
    }

    if (! MemAlloc((void**)&rgThumbprint, sizeof(THUMBBLOB)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(rgThumbprint, 0, sizeof(THUMBBLOB)*cCerts);
    if (! MemAlloc((void**)&certResults.rgpCert, sizeof(PCX509CERT)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(certResults.rgpCert, 0, sizeof(PCX509CERT)*cCerts);
    if (! MemAlloc((void**)&certResults.rgcs, sizeof(CERTSTATE)*cCerts)) {
        return E_OUTOFMEMORY;
    }
    memset(certResults.rgcs, 0, sizeof(CERTSTATE)*cCerts);
    certResults.cEntries = cCerts;

    HrGetThumbprints(pEnum, dwType, rgThumbprint);
    hr = HrGetCertsFromThumbprints(rgThumbprint, &certResults);
    if (SUCCEEDED(hr)) {
        hr = HrGenerateCertsStatus(&certResults, pAdrTable, pEnum, fAlreadyHaveSendersCert);
        if (SUCCEEDED(hr)) {
            pcaCerts->cCerts = certResults.cEntries;
            pcaCerts->rgpCerts = (PCCERT_CONTEXT*)certResults.rgpCert;
        }
    }

    if (FAILED(hr)) {
        _FreeCertArray((PCCERT_CONTEXT *)certResults.rgpCert, certResults.cEntries);
    }
    MemFree(certResults.rgcs);

    if (rgThumbprint) {
        for (DWORD i = 0; i < cCerts; i++) {
            if (rgThumbprint[i].pBlobData) {
                MemFree(rgThumbprint[i].pBlobData);
            }
        }
        MemFree(rgThumbprint);
    }

    return hr;
}

/*  HrGenerateCertsStatus:
**
**  Purpose:
**      No assumptions about the rghr in pResults, this function scans the
**      HRESULTs and sets the CERTSTATEs in pAdrTable (1:1 mapping) accordingly
**  Takes:
**      IN pResults     - results to use for CERTSTATEs
**      IN pAdrTable    - address table to set states on
**      IN pEnum        - list of address handles
**  Returns:
**
*/
HRESULT CSMime::HrGenerateCertsStatus(
    X509CERTRESULT *                pResults,
    IMimeAddressTable *const        pAdrTable,
    IMimeEnumAddressTypes *const    pEnum,
    const BOOL                      fIgnoreSenderError)
{
    ADDRESSPROPS        apEntry;
    ADDRESSPROPS        apModify;
    UINT                i;
    const ULONG         numToGet = 1;
    DWORD               dexBogus = (DWORD)-1;
    HRESULT             hr = S_OK;

    // Walk the entire Enumerator
    i=0;
    pEnum->Reset();
    apModify.dwProps = IAP_CERTSTATE;
    while(S_OK == pEnum->Next(numToGet, &apEntry, NULL)) {
        Assert(apEntry.hAddress);
        apModify.certstate = pResults->rgcs[i];

        // Why was this added, you ask?
        // if the client has set OID_SECURITY_CERT_INCLUDED then
        // we need to not return spurious errors about the sender's
        // certificate.  if we didn't find it but were given it
        // elsewhere, say things are cool.

        // make sure to run through the whole array because the
        // error MIME_S_SECURITY_CERTERROR is the most important
        // since the sender cert one is really just a warning.

        if (CERTIFICATE_OK != apModify.certstate) {
            if (FMissingCert(apModify.certstate)) {
                if (apEntry.dwAdrType == IAT_FROM) {
                    if (fIgnoreSenderError) {
                        apModify.certstate = CERTIFICATE_OK;
                    }
                    else {
                        // since this can be ignored with fIgnoreSenderError
                        // it should never override another warning
                        if (S_OK == hr) {
                            hr = MIME_S_SECURITY_NOSENDERCERT;
                        }
                    }
                    dexBogus = i;
                }
                else {
                    hr = MIME_S_SECURITY_NOCERT;
                }
            }
            else {
                hr = MIME_S_SECURITY_CERTERROR;
            }
        }

        SideAssert(SUCCEEDED(pAdrTable->SetProps(apEntry.hAddress, &apModify)));
        g_pMoleAlloc->FreeAddressProps(&apEntry);
        i++;
    }

    if (i == pResults->cEntries) {    // success
        if ((DWORD)-1 != dexBogus) {
            // we found the sender and the cert for this entry is NULL.
            // CAPI doesn't like null certificates, so replace it
            if (dexBogus != pResults->cEntries-1) {
                // don't need to dupe b/c the end will no
                // longer be included in the count
                pResults->rgpCert[dexBogus] = pResults->rgpCert[pResults->cEntries-1];
            }
            --pResults->cEntries;
        }
    }
    else {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// CAPI wrappers
//

/*  GetCertData:
**
**  Returns:
**      MIME_E_NOT_FOUND if the data is not in the cert
**
**  Note:
**      Currently only supports CDID_EMAIL
*/
STDMETHODIMP CSMime::GetCertData(
    const PCX509CERT    pX509Cert,
    const CERTDATAID    dataid,
    LPPROPVARIANT       pValue)
{
#define pCert ((PCCERT_CONTEXT)pX509Cert)
    PCERT_NAME_INFO         pNameInfo = NULL;
    PCERT_RDN_ATTR          pRDNAttr;
    HRESULT                 hr = MIME_E_NOT_FOUND;
    LPSTR                   szOID;

    CHECKSMIMEINIT
    if (!(pX509Cert && pCert->pCertInfo) || dataid >= CDID_MAX) {
        return TrapError(E_INVALIDARG);
    }

    switch (dataid) {
        case CDID_EMAIL:
            // Let msoert handle this request
            if (pValue->pszVal = SzGetCertificateEmailAddress(pCert)) {
                pValue->vt = VT_LPSTR;
                hr = S_OK;
            }
            break;
        // if you add any cases, rewrite the findRDN code below
        // I assume IA5 and PhilH's NULL's at the end, leaving me
        // a very clean copy
        default:
            hr = E_INVALIDARG;
            goto exit;
    }

exit:
    return TrapError(hr);
#undef pCert
}

///////////////////////////////////////////////////////////////////////////
//
// Static functions
//
///////////////////////////////////////////////////////////////////////////

/***************************************************************************

    Name      : _HrConvertHrFromGetCertToEncode

    Purpose   :

    Parameters: hr = input HRESULT
                fEncrypt = TRUE if we are encrypting

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT _HrConvertHrFromGetCertToEncode(HRESULT hr, const BOOL fEncrypt)
{
    if (MIME_S_SECURITY_NOSENDERCERT == hr)
        if (fEncrypt) {
            hr = MIME_E_SECURITY_ENCRYPTNOSENDERCERT;
        }
        else {
            hr = MIME_E_SECURITY_NOSIGNINGCERT;
        }
    else if (MIME_S_SECURITY_CERTERROR == hr) {
        hr = MIME_E_SECURITY_CERTERROR;
    }
    else if (MIME_S_SECURITY_NOCERT == hr) {
        hr = MIME_E_SECURITY_NOCERT;
    }
    return hr;
}

/***************************************************************************

    Name      : _FreeCertArray

    Purpose   : Free an array of certs

    Parameters: rgpCert = array of cert pointers
                cCerts = number of certs in rgpCert

    Returns   : void

    Comment   :

***************************************************************************/
void _FreeCertArray(PCCERT_CONTEXT *rgpCert, const UINT cCerts)
{
    if (rgpCert) {
        for (register DWORD i = 0; i < cCerts; i++) {
            ReleaseCert(rgpCert[i]);
        }
        Assert(ALLOCED(rgpCert));
        MemFree(rgpCert);
    }
}

#ifdef DEBUG
///////////////////////////////////////////////////////////////////////////
//
// Debugging functions
//
///////////////////////////////////////////////////////////////////////////


/***************************************************************************

    Name      : DumpAlgorithms

    Purpose   : Debug dump of algorithms

    Parameters: void

    Returns   : void

    Comment   :

***************************************************************************/
void CSMime::DumpAlgorithms()
{
    DWORD   dwAlgCount;
    char *ptr = NULL;
    DWORD i;
    ALG_ID  aiAlgid;
    DWORD dwBits;
    DWORD dwNameLen;
    char szName[100];
    BYTE pbData[1000];
    DWORD dwDataLen;
    DWORD dwFlags;
    CHAR *pszAlgType = NULL;
    HCRYPTPROV hProv;

    CryptAcquireContext(&hProv, NULL, NULL, 5, 0);
    Assert(hProv);
    for(i=0; ;i++) {
        if (0==i) {
            dwFlags = CRYPT_FIRST;
        }
        else {
            dwFlags = 0;
        }

        dwDataLen = 1000;
        if(!CryptGetProvParam(hProv, PP_ENUMALGS, pbData, &dwDataLen, 0)) {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                break;
            }
            else {
                Assert(0);
            }
        }

        ptr = (char *)pbData;

        aiAlgid = *(ALG_ID *)ptr;
        ptr += sizeof(ALG_ID);
        dwBits = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        dwNameLen = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
#ifndef WIN16
        StrCpyN(szName, ptr, dwNameLen);
#else
        lstrcpyn(szName, ptr, dwNameLen);
#endif // !WIN16

        switch(GET_ALG_CLASS(aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT:
                pszAlgType = "Encrypt  ";
                break;
            case ALG_CLASS_HASH:
                pszAlgType = "Hash     ";
                break;
            case ALG_CLASS_KEY_EXCHANGE:
                pszAlgType = "Exchange ";
                break;
            case ALG_CLASS_SIGNATURE:
                pszAlgType = "Signature";
                break;
            default:
                pszAlgType = "Unknown  ";
        }

        DOUTL(CRYPT_LEVEL, "Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            aiAlgid, dwBits, pszAlgType, dwNameLen, szName);
    }
    CryptReleaseContext(hProv, 0);
    return;
}

#endif // debug

BOOL FSameAgreeParameters(CMS_RECIPIENT_INFO * pRecipInfo1,
                          CMS_RECIPIENT_INFO * pRecipInfo2)
{
    if (pRecipInfo1->dwU1 != pRecipInfo2->dwU1)         return FALSE;
    if (pRecipInfo1->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
        if ((lstrcmp(pRecipInfo1->u1.u3.EphemeralAlgorithm.pszObjId,
                     pRecipInfo2->u1.u3.EphemeralAlgorithm.pszObjId) != 0) ||
            (pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.cbData !=
             pRecipInfo2->u1.u3.EphemeralAlgorithm.Parameters.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.pbData,
                    pRecipInfo2->u1.u3.EphemeralAlgorithm.Parameters.pbData,
                    pRecipInfo1->u1.u3.EphemeralAlgorithm.Parameters.cbData) != 0)){
            return FALSE;
        }
        if ((pRecipInfo1->u1.u3.UserKeyingMaterial.cbData !=
             pRecipInfo2->u1.u3.UserKeyingMaterial.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo2->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo1->u1.u3.UserKeyingMaterial.cbData) != 0)) {
            return FALSE;
        }
    }
    else if (pRecipInfo1->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE) {
        //
        //  We don't bother checking the sender cert id.  I don't know of
        //      any reason why the same key would be encoded with different
        //      identifiers (issuer and serial vs subject key id)
        //
        
        if (pRecipInfo1->u1.u4.hprov != pRecipInfo2->u1.u4.hprov) return FALSE;
        if (pRecipInfo1->u1.u4.dwKeySpec != pRecipInfo2->u1.u4.dwKeySpec) {
            return FALSE;
        }
        if ((pRecipInfo1->u1.u3.UserKeyingMaterial.cbData !=
             pRecipInfo2->u1.u3.UserKeyingMaterial.cbData) ||
            (memcmp(pRecipInfo1->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo2->u1.u3.UserKeyingMaterial.pbData,
                    pRecipInfo1->u1.u3.UserKeyingMaterial.cbData) != 0)) {
            return FALSE;
        }
    }
    else return FALSE;

    return TRUE;
}

HRESULT ConvertEncryptionLayer(IMimeBody * pBody, IMimeSecurity2 * psm, SMIMEINFO * psi)
{
    DWORD                                       cAgree;
    DWORD                                       cRecipients;
    HRESULT                                     hr;
    DWORD                                       i;
    DWORD                                       i2;
    DWORD                                       iAgree;
    DWORD                                       iRecip;
    CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO *      pAgree = NULL;
    CRYPT_ATTRIBUTE *                           pattr = NULL;
    CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO *      pMailList = NULL;
    PSECURITY_LAYER_DATA                        psld = NULL;
    CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO *      pTrans = NULL;
    CMS_RECIPIENT_INFO *                        rgRecipInfo = NULL;
    PROPVARIANT                                 var;
    
    PropVariantInit(&var);

    //
    //  Create a layer to hold the encryption information
    //
            
    if (! (psld = new CSECURITY_LAYER_DATA)) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Link together the different layers
    if (psi->psldLayers == NULL) {
        psi->psldLayers = psld;
    }

    psld->m_psldOuter = psi->psldInner;
    if (psld->m_psldOuter != NULL) {
        psld->m_psldOuter->m_psldInner = psld;
    }
    psi->psldInner = psld;

    //
    //  Encryption layers must be blobed -- so or it in.
    //
            
    psi->dwMsgEnhancement |= MST_BLOB_FLAG;
    psld->m_dwMsgEnhancement = psi->dwMsgEnhancement &
        (MST_ENCRYPT_MASK | MST_BLOB_FLAG);

    //
    // The encryption algorithm may not be encoded the way we need it
    //  to be.  The call will re-encode correctly for CMS.
    //
    //  If we are encrypting, it is an error to not have an encryption
    //  algorithm.
    //

    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_BULK, &var)) &&
        (0 != var.blob.cbSize)) {
        Assert(VT_BLOB == var.vt);

        hr = HrBuildContentEncryptionAlg(psld, &var.blob);
        if (hr != S_OK) {
            Assert(FALSE);
            // goto exit;
        }
    }
    else {
        hr = E_INVALIDARG;
        goto exit;
    }

    //  
    // The call may have provided a specific certificate to be used
    //  in decrypting the message.  This functionality is now obsolete but
    //  still supported.  If no certificate is provided then we will search
    //  for a valid decryption key.
    //
    PropVariantClear(&var);
#ifdef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_DECRYPTION_64, &var)) &&
        (NULL != (PCCERT_CONTEXT *) var.pulVal)) 
    {
        Assert(VT_UI8 == var.vt);
        // don't need to dupe the cert, been done in GetOption
        psld->m_pccertDecrypt = (PCCERT_CONTEXT) var.pulVal;
#else // !_WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_DECRYPTION, &var)) &&
        (NULL != (PCCERT_CONTEXT *) var.ulVal)) 
    {
        Assert(VT_UI4 == var.vt);
        // don't need to dupe the cert, been done in GetOption
        psld->m_pccertDecrypt = (PCCERT_CONTEXT) var.ulVal;
#endif // _WIN64

        // Included a cert in this layer
        psld->m_fCertInLayer = TRUE;
    }

    //
    //  Allocate the space to hold the Encryption structures we are going 
    //  to pass into the CMS structures.
    //
            
    CHECKHR(hr = psm->GetRecipientCount(0, &cRecipients));
    if (cRecipients == 0) {
        hr = MIME_E_SECURITY_ENCRYPTNOSENDERCERT;
        goto exit;
    }

    if (!MemAlloc((LPVOID *) &psld->m_rgRecipientInfo,
                  cRecipients * sizeof(CMSG_RECIPIENT_ENCODE_INFO))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memset(psld->m_rgRecipientInfo, 0,
           cRecipients*sizeof(CMSG_RECIPIENT_ENCODE_INFO));

    //
    //  Allocate the space to hold the values we currently are holding
    //

    if (!MemAlloc((LPVOID *) &rgRecipInfo,
                  cRecipients * sizeof(rgRecipInfo[0]))) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memset(rgRecipInfo, 0, cRecipients*sizeof(rgRecipInfo[0]));
    CHECKHR(hr = psm->GetRecipient(0, 0, cRecipients, rgRecipInfo));

    //
    //  Walk through and process all of the recipients by copying data
    //  from the current structure into the CMS version of the structure.
    //
    //  Note that we do no free any of the data allocated in the GetRecipient
    //  call.  The data will be freed as part of freeing the CMS data
    //  structure instead. Ownership of all data is transfered.
    //
            
    for (i=0, iRecip = 0; i<cRecipients; i++) {
        switch (rgRecipInfo[i].dwRecipientType) {
            //
            //  If this is set then we must have already processed this item
            //
        case CMS_RECIPIENT_INFO_TYPE_UNKNOWN:
            break;

            //
            //  Key Transport items copy over one-for-one.
            //
                    
        case CMS_RECIPIENT_INFO_TYPE_KEYTRANS:
            //  try and allocate the object to hold the data.
            if (!MemAlloc((LPVOID *) &pTrans, sizeof (*pTrans))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pTrans, 0, sizeof(*pTrans));

            //
            //  Copy the data over from the old to the new structure.
            //  Ownership of all data is transfered here.
            //

            pTrans->cbSize = sizeof(*pTrans);
            pTrans->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pTrans->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
                    
            Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS);
            pTrans->RecipientPublicKey = rgRecipInfo[i].u1.SubjectPublicKey;
                    
            Assert((rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) ||
                   (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL));
            if (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
                pTrans->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                pTrans->RecipientId.KeyId = rgRecipInfo[i].u3.KeyId;
            }
            else if (rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
                pTrans->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                pTrans->RecipientId.IssuerSerialNumber = rgRecipInfo[i].u3.IssuerSerial;
            }
            else {
                hr = E_INVALIDARG;
                goto exit;
            }

            //
            //  The copy has been sucessful so point to the new data.
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pKeyTrans = pTrans;
            pTrans = NULL;
            iRecip += 1;
            
            if(rgRecipInfo[i].pccert)
                CertFreeCertificateContext(rgRecipInfo[i].pccert); 
            break;

            //
            //  Mail List items can also just be copied over from the source
            //  to the destination structures
            //
                    
        case CMS_RECIPIENT_INFO_TYPE_MAIL_LIST:
            //  Allocate the CMS structure to hold this data
            if (!MemAlloc((LPVOID *) &pMailList, sizeof(*pMailList))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pMailList, 0, sizeof(pMailList));

            //
            //  Copy the data over from the old to the new structure.  
            //  Ownership of all data is transfered here.
            //

            pMailList->cbSize = sizeof(*pMailList);
            pMailList->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pMailList->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
            Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_PROVIDER);
            pMailList->hCryptProv = rgRecipInfo[i].u1.u2.hprov;
            pMailList->dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            pMailList->hKeyEncryptionKey = rgRecipInfo[i].u1.u2.hkey;
            Assert(rgRecipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID);
            pMailList->KeyId = rgRecipInfo[i].u3.KeyId;
            pMailList->Date = rgRecipInfo[i].filetime;
            pMailList->pOtherAttr = rgRecipInfo[i].pOtherAttr;

            //
            //  Copy is successful so point to the data
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_MAIL_LIST_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pMailList = pMailList;
            iRecip += 1;
            pMailList = NULL;
            break;

            //
            //  We need to do some magic with key agree structures. 
            //  Specifically we want to do the following:
            //  - Combine together all key agrees with the same parameters
            //          into a single record to pass into the CMS code.
            //  - 

        case CMS_RECIPIENT_INFO_TYPE_KEYAGREE:
            //  allocate the CMS structure to hold this data
            if (!MemAlloc((LPVOID *) &pAgree, sizeof(*pAgree))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            memset(pAgree, 0, sizeof(*pAgree));

            //
            //  Start by setting up the common parameters used by all of the
            //    recipients in the common key set.
            //  Setup the key agreement parameters for encoding and 
            //    so forth.

            pAgree->cbSize = sizeof(*pAgree);

            //  Key Encryption Algorithm - 

            pAgree->KeyEncryptionAlgorithm = rgRecipInfo[i].KeyEncryptionAlgorithm;
            pAgree->pvKeyEncryptionAuxInfo = rgRecipInfo[i].pvKeyEncryptionAuxInfo;
                    
            // Key Wrap Algorithm - Derive from the content algorithm
            //     if not already known.

            if (rgRecipInfo[i].KeyWrapAlgorithm.pszObjId != NULL) {
                pAgree->KeyWrapAlgorithm = rgRecipInfo[i].KeyWrapAlgorithm;
                pAgree->pvKeyWrapAuxInfo = rgRecipInfo[i].pvKeyWrapAuxInfo;
            }
            else {
                hr = HrDeriveKeyWrapAlg(psld, pAgree);
                if (FAILED(hr)) {
                    goto exit;
                }
            }

            //  Items which are specificly located accroding to static or
            //          ephemeral key agreement.

            if (rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
                pAgree->UserKeyingMaterial = rgRecipInfo[i].u1.u3.UserKeyingMaterial;

                if (!MemAlloc((LPVOID *) &pAgree->pEphemeralAlgorithm,
                              sizeof(CRYPT_ALGORITHM_IDENTIFIER))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memset(pAgree->pEphemeralAlgorithm, 0,
                       sizeof(CRYPT_ALGORITHM_IDENTIFIER));

                    
                pAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
                memcpy(pAgree->pEphemeralAlgorithm,
                       &rgRecipInfo[i].u1.u3.EphemeralAlgorithm,
                       sizeof(CRYPT_ALGORITHM_IDENTIFIER));
            }
            else {
                Assert(rgRecipInfo[i].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE);
                pAgree->dwKeyChoice = CMSG_KEY_AGREE_STATIC_KEY_CHOICE;
                pAgree->UserKeyingMaterial = rgRecipInfo[i].u1.u4.UserKeyingMaterial;

                if (!MemAlloc((LPVOID *) &pAgree->pSenderId, sizeof(CERT_ID))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memcpy(pAgree->pSenderId, &rgRecipInfo[i].u1.u4.senderCertId,
                       sizeof(CERT_ID));

                pAgree->hCryptProv = rgRecipInfo[i].u1.u4.hprov;
                pAgree->dwKeySpec = rgRecipInfo[i].u1.u4.dwKeySpec;
            }

            //
            //  We need to count of common items
            //

            for (i2=i+1, cAgree = 1; i2<cRecipients; i2++) {
                cAgree += FSameAgreeParameters(&rgRecipInfo[i],
                                               &rgRecipInfo[i2]);
            }

            //
            //

            //
            //  Allocate space to hold the set of common key agree recipients
            //

            if (!MemAlloc((LPVOID *) &pAgree->rgpRecipientEncryptedKeys,
                          cAgree * sizeof(LPVOID))) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            pAgree->cRecipientEncryptedKeys = cAgree;
            memset(pAgree->rgpRecipientEncryptedKeys, 0,
                   cAgree * sizeof(pAgree->rgpRecipientEncryptedKeys));

            for (i2=i, iAgree = 0; i2<cRecipients; i2++) {
                if ((i2 != i) && !FSameAgreeParameters(&rgRecipInfo[i],
                                                       &rgRecipInfo[i2])) {
                    continue;
                }
                        
                if (!MemAlloc((LPVOID *) &pAgree->rgpRecipientEncryptedKeys[iAgree],
                              sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO))) {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                memset(pAgree->rgpRecipientEncryptedKeys[iAgree], 0,
                       sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO));

                pAgree->rgpRecipientEncryptedKeys[iAgree]->cbSize = sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO);

                //
                //  Get the recipients Public Key value
                //
                        
                if (rgRecipInfo[i2].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientPublicKey = rgRecipInfo[i2].u1.u3.SubjectPublicKey;
                }
                else {
                    Assert(rgRecipInfo[i2].dwU1 == CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE);

                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientPublicKey = rgRecipInfo[i2].u1.u4.SubjectPublicKey;
                }

                //
                //  Get the recipients certificate ID
                //
                        
                Assert((rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) ||
                       (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL));
                if (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.KeyId = rgRecipInfo[i2].u3.KeyId;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->Date = rgRecipInfo[i2].filetime;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->pOtherAttr = rgRecipInfo[i2].pOtherAttr;
                }
                else if (rgRecipInfo[i2].dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                    pAgree->rgpRecipientEncryptedKeys[iAgree]->RecipientId.IssuerSerialNumber = rgRecipInfo[i2].u3.IssuerSerial;
                }
                else {
                    hr = E_INVALIDARG;
                    goto exit;
                }

                //
                //  Zero the data so it does not freed twice.  (pointers are now
                //      in the CMS structure)
                //

                if (i != i2) {
                    memset(&rgRecipInfo[i2], 0, sizeof(rgRecipInfo[i2]));
                }

                iAgree += 1;
            }
                    
            Assert(iAgree == cAgree);

            //
            //  The copy has been successfully completed.  We now move
            //  the data (and ownership) into new structure.
            //

            psld->m_rgRecipientInfo[iRecip].dwRecipientChoice = CMSG_KEY_AGREE_RECIPIENT;
            psld->m_rgRecipientInfo[iRecip].pKeyAgree = pAgree;
            iRecip += 1;
            pAgree = NULL;
            break;
        }

        //
        //  Zero the data so it does not freed twice.  (pointers are now
        //      in the CMS structure)
        //

        memset(&rgRecipInfo[i], 0, sizeof(rgRecipInfo[i]));
    }
    psld->m_cEncryptItems = iRecip;

    PropVariantClear(&var);
#ifndef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCRYPTPROV, &var))) 
    {
        psi->hProv = (HCRYPTPROV) var.ulVal;
    }
#else // _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCRYPTPROV_64, &var))) 
    {
        psi->hProv = (HCRYPTPROV) var.pulVal;
    }
#endif // _WIN64

    //
    //  Pickup the set of encryption certificate bag
    //

    PropVariantClear(&var);
#ifdef _WIN64
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ENCRYPT_CERT_BAG_64, &var))) {
        psld->m_hstoreEncrypt = (HCERTSTORE) var.pulVal;
#else
    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ENCRYPT_CERT_BAG, &var))) {
        psld->m_hstoreEncrypt = (HCERTSTORE) var.ulVal;
#endif // _WIN64
    }

    //
    //   Pick up the unprotected attributes
    //

    if (g_FSupportV3) {
        hr = psm->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, 0, NULL,
                               &pattr);
        if (FAILED(hr)) {
            goto exit;
        }
        else if (hr == S_OK) {
            Assert(pattr != NULL);
            CHECKHR(hr = HrCopyCryptDataBlob(&pattr->rgValue[0],
                                             &psld->m_blobUnprotectAttrs));
        }
    }
    
    hr = S_OK;
    
exit:
    PropVariantClear(&var);
    if (rgRecipInfo != NULL) {
        for (i=0; i<cRecipients; i++) {
            FreeRecipientInfoContent(&rgRecipInfo[i]);
        }
        SafeMemFree(rgRecipInfo);
    }
    SafeMemFree(pTrans);
    SafeMemFree(pMailList);
    if (pAgree != NULL) {
        for (i=0; pAgree->cRecipientEncryptedKeys; i++) {
            SafeMemFree(pAgree->rgpRecipientEncryptedKeys[i]);
        }
        SafeMemFree(pAgree->pEphemeralAlgorithm);
        SafeMemFree(pAgree->pSenderId);
        SafeMemFree(pAgree->rgpRecipientEncryptedKeys);
        SafeMemFree(pAgree);
    }
    SafeMemFree(pattr);
    return hr;
}

/***************************************************************************

    Name      : OptionsToSMIMEINFO

    Purpose   : Fill the SMIMEINFO from the body properties

    Parameters: fEncode = TRUE if encoding
                pBody -> Body object
                psi -> target SMIMEINFO

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CSMime::OptionsToSMIMEINFO(
    BOOL        fEncode,
    IMimeMessageTree *const pmm,
    IMimeBody * pBody,
    SMIMEINFO * psi)
{
    CRYPT_ATTRIBUTE                             attr;
    DWORD                                       cb;
    DWORD                                       cAgree;
    ULONG                                       cCertBag = 0;
    DWORD                                       dwSecurity;
    FILETIME                                    ftSignTime;
    HCERTSTORE                                  hCertStore = NULL;
    HRESULT                                     hr = S_OK;
    ULONG                                       i;
    DWORD                                       i2;
    DWORD                                       iAgree;
    ULONG                                       iLayer;
    DWORD                                       iSigner;
    PSECURITY_LAYER_DATA                        psld = NULL, psldTemp;
    BYTE                                        rgb[50];
    PCCERT_CONTEXT *                            rgpccCertSigning = NULL;
    PCCERT_CONTEXT *                            rgpcCertBag = NULL;
    PROPVARIANT *                               rgpvAlgHash = NULL;
    PROPVARIANT *                               rgpvAuthAttr = NULL;
    PROPVARIANT *                               rgpvUnauthAttr = NULL;
    IMimeSecurity2 *                            psm = NULL;
    ULONG                                       ulLayers = 0;
    CRYPT_ATTR_BLOB                             valTime;
    PROPVARIANT                                 var;

    Assert(pBody && psi);

    //
    //  Pick up the security interface on the body.  It makes life easier
    //

    hr = pBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psm);
    if (FAILED(hr)) {
        goto exit;
    }

    //
    //  If we are going to encode the body, then see if the content type is
    //  "OID/xxx".  In this case we encode the body specially and we need to
    //  get the size of the inner blob.
    //
    
    if (fEncode) {
        //  Must determine the body type to see if it needs special processing
        if (pBody->IsContentType("OID", NULL) == S_OK) {
            PROPVARIANT     var;
            var.vt = VT_LPSTR;
        
            if (FAILED(pBody->GetProp(STR_ATT_SUBTYPE, 0, &var))) {
                return TrapError(E_FAIL);
            }
            if (strcmp(var.pszVal, szOID_RSA_data) != 0) {
                psi->pszInnerContent = var.pszVal;
                if (FAILED(pBody->GetEstimatedSize(IET_BINARY, &psi->cbInnerContent))) {
                    return TrapError(E_FAIL);
                }
            }
        }
    }

    if (FAILED(pBody->GetOption(OID_SECURITY_KEY_PROMPT, &var))) {
        return TrapError(E_FAIL);
    }
    Assert(VT_LPWSTR == var.vt);
    if (var.pwszVal != NULL) {
        psi->pwszKeyPrompt = PszDupW(var.pwszVal);
        if (psi->pwszKeyPrompt == NULL) {
            return TrapError(E_OUTOFMEMORY);
        }
    }

    //
    //  Get the security to be applied and put it into the security info layer
    //          structure
    //
    
    if (FAILED(pBody->GetOption(OID_SECURITY_TYPE, &var))) {
        return TrapError(E_FAIL);
    }
    Assert(VT_UI4 == var.vt);
    psi->dwMsgEnhancement = var.ulVal;

    //
    //  Start doing the setup for encode operations.
    //

    if (fEncode) {
        //
        //  We must be doing some type of encoding operation, or we should fail.
        //

        if (MST_NONE == var.ulVal) {
            hr = TrapError(MIME_S_SECURITY_NOOP);
            goto exit;
        }
        else if (!(MST_THIS_MASK & var.ulVal)) {
            hr = TrapError(MIME_S_SECURITY_RECURSEONLY);
            goto exit;
        }
        else if (MST_CLASS_SMIME_V1 != (var.ulVal & MST_CLASS_MASK)) {
            hr = TrapError(MIME_E_SECURITY_CLASSNOTSUPPORTED);
            goto exit;
        }

        //
        //  If we are doing multiple layers of encrption, then we require that
        //      the inner level be blobed and not clear.
        //
        
        if ((psi->pszInnerContent != NULL) && !(var.ulVal & MST_BLOB_FLAG)) {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        //
        //  Are we encrypting
        //

        if (psi->dwMsgEnhancement & MST_ENCRYPT_MASK) {
            hr = ConvertEncryptionLayer(pBody, psm, psi);
            if (FAILED(hr)) {
                goto exit;
            }
        }

        //
        //  Are we signing?
        //
        if (psi->dwMsgEnhancement & MST_SIGN_MASK) {
            //
            // Force in a a signing time
            //

            GetSystemTimeAsFileTime(&ftSignTime);
            cb = sizeof(rgb);
            if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                    &ftSignTime, 0, NULL, rgb, &cb)) {
                attr.pszObjId = szOID_RSA_signingTime;
                attr.cValue = 1;
                attr.rgValue = &valTime;
                valTime.pbData = rgb;
                valTime.cbData = cb;

                hr = psm->SetAttribute(SMIME_ATTR_ADD_IF_NOT_EXISTS,
                                       (DWORD) -1, SMIME_ATTRIBUTE_SET_SIGNED,
                                       &attr);
                if (FAILED(hr)) {
                    goto exit;
                }
            }

            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var))) {
                Assert(VT_UI4 == var.vt);
                ulLayers = var.ulVal;
            }
#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var))) {
                Assert((VT_VECTOR | VT_UI8) == var.vt);
                Assert(var.cauh.cElems == ulLayers);
                rgpccCertSigning = (PCCERT_CONTEXT *) (var.cauh.pElems);
            }
            // These next two are optional
            // Furthermore, if we get the first, we don't check the second.  BJK - Huh?
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var))) 
            {
                Assert(VT_UI8 == var.vt);
                hCertStore = (HCERTSTORE) var.pulVal;
#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_CERT_SIGNING_RG, &var))) {
                Assert((VT_VECTOR | VT_UI4) == var.vt);
                Assert(var.caul.cElems == ulLayers);
                rgpccCertSigning = (PCCERT_CONTEXT *)var.caul.pElems;
            }
            // These next two are optional
            // Furthermore, if we get the first, we don't check the second.  BJK - Huh?
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var))) 
            {
                Assert(VT_UI4 == var.vt);
                hCertStore = (HCERTSTORE) var.ulVal;
#endif //_WIN64
            }

            // NOTE: OID_SECURITY_RG_CERT_BAG is not a per-layer array!  It
            // is an array of all the certs for the entire message.

#ifndef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RG_CERT_BAG, &var))) {
                Assert((VT_VECTOR | VT_UI4) == var.vt);
                cCertBag = var.caul.cElems;
                rgpcCertBag = (PCCERT_CONTEXT*)var.caul.pElems;

#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_RG_CERT_BAG_64, &var))) {
                Assert((VT_VECTOR | VT_UI8) == var.vt);
                cCertBag = var.cauh.cElems;
                rgpcCertBag = (PCCERT_CONTEXT*)(var.cauh.pElems);
#endif //_WIN64
            }
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_ALG_HASH_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvAlgHash = var.capropvar.pElems;
            }

            //  Grab the unauthenicated attributes
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_UNAUTHATTR_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvUnauthAttr = var.capropvar.pElems;
            }

            //  Grab the initial authenicated attributes
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_AUTHATTR_RG, &var))) {
                Assert((VT_VECTOR | VT_VARIANT) == var.vt);
                Assert(var.capropvar.cElems == ulLayers);
                rgpvAuthAttr = var.capropvar.pElems;
            }

            //  Create a layer to hold the signing information
            
            if (! (psld = new CSECURITY_LAYER_DATA)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            // Link together the different layers

            if (psi->psldLayers == NULL) {
                psi->psldLayers = psld;
            }

            psld->m_psldOuter = psi->psldInner;
            if (psld->m_psldOuter != NULL) {
                psld->m_psldOuter->m_psldInner = psld;
            }
            psi->psldInner = psld;

            //

            psld->m_dwMsgEnhancement = psi->dwMsgEnhancement &
                (MST_SIGN_MASK | MST_BLOB_FLAG);

            //  Fill in the signing information

            if (!MemAlloc((LPVOID *) &psld->m_rgSigners,
                          sizeof(SignerData)*ulLayers)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            
            memset(psld->m_rgSigners, 0, sizeof(SignerData)*ulLayers);
            psld->m_cSigners = ulLayers;

            for (iSigner=0; iSigner < ulLayers; iSigner++) {
                psld->m_rgSigners[iSigner].pccert = DupCert(rgpccCertSigning[iSigner]);
                HrCopyBlob(&rgpvAlgHash[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobHashAlg);
                HrCopyBlob(&rgpvUnauthAttr[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobUnauth);
                HrCopyBlob(&rgpvAuthAttr[iSigner].blob,
                           &psld->m_rgSigners[iSigner].blobAuth);
            }

#ifdef _WIN64
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var))) 
                {
                    //  Don't addref as we are just giving it to the sld object
                    psld->m_hcertstor = (HCERTSTORE) var.pulVal;
#else
            if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var))) 
                {
                    //  Don't addref as we are just giving it to the sld object
                    psld->m_hcertstor = (HCERTSTORE) var.ulVal;
#endif // _WIN64
                }

        }

        //
        // read these for both signing and encryption
        //

        if (SUCCEEDED(pBody->GetOption(OID_SECURITY_REQUESTED_CTE, &var))) {
            Assert(VT_I4 == var.vt);
            psi->ietRequested = ENCODINGTYPE(var.lVal);
        }
        else {
            psi->ietRequested = ENCODINGTYPE(-1);
        }
    }

    //
    // read these for both encoding and decoding
    //

    if (SUCCEEDED(pBody->GetOption(OID_SECURITY_SEARCHSTORES, &var)) &&
#ifdef _WIN64
        (NULL != var.cauh.pElems)
#else
        (NULL != var.caul.pElems)
#endif // _WIN64
     ) {
#ifdef _WIN64
        CAUH& caul = var.cauh;  // On Win64, it's really a cauh
#else
        CAUL& caul = var.caul;
#endif // _WIN64

        psi->rgStores = (HCERTSTORE*)g_pMoleAlloc->Alloc(caul.cElems * sizeof(HCERTSTORE));
        if (psi->rgStores) {
            for (DWORD i = 0; i < caul.cElems; i++) {
                // Shouldn't have to duplicate since we're not freeing them here
#ifdef _WIN64
                psi->rgStores[i] = (HCERTSTORE)caul.pElems[i].QuadPart;
#else
                psi->rgStores[i] = (HCERTSTORE)caul.pElems[i];
#endif // _WIN64
            }
            psi->cStores = caul.cElems;
        }
        SafeMemFree(caul.pElems);
    }
    else {
        // if we were given no stores, open "My"
        psi->rgStores = (HCERTSTORE*)g_pMoleAlloc->Alloc(sizeof(HCERTSTORE));
        if (psi->rgStores) {
            psi->rgStores[0] = OpenCachedMyStore();
            if (psi->rgStores[0]) {
                psi->cStores = 1;
            } else {
                g_pMoleAlloc->Free(psi->rgStores);
            }
        }
    }

exit:
#ifdef SMIME_V3
    if (psm != NULL)            psm->Release();
#endif // SMIME_V3

#ifndef SMIME_V3    
    SafeMemFree(rgftSigningTime);
#endif  // SMIME_V3

    if (rgpccCertSigning) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            if (rgpccCertSigning[iLayer]) {
                CertFreeCertificateContext(rgpccCertSigning[iLayer]);
            }
        }
    }
    SafeMemFree(rgpccCertSigning);

    if (hCertStore) {
        CertCloseStore(hCertStore, 0);
    }

    if (rgpcCertBag) {
        // NOTE: rgpcCertBag isn't indexed by layer!
        for (i = 0; i < cCertBag; i++) {
            if (rgpcCertBag[i]) {
                CertFreeCertificateContext(rgpcCertBag[i]);
            }
        }
    }
    SafeMemFree(rgpcCertBag);

    if (rgpvAlgHash) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvAlgHash[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvAlgHash);

    if (rgpvUnauthAttr) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvUnauthAttr[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvUnauthAttr);

    if (rgpvAuthAttr) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvAuthAttr[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvAuthAttr);

#ifndef SMIME_V3
    if (rgpvSymcaps) {
        for (iLayer = 0; iLayer < ulLayers; iLayer++) {
            SafeMemFree(rgpvSymcaps[iLayer].blob.pBlobData);
        }
    }
    SafeMemFree(rgpvSymcaps);
#endif // !SMIME_V3

    return(hr);
}

/***************************************************************************

    Name      : SMIMEINFOToOptions

    Purpose   : set the body properties based on contents of the SMIMEINFO

    Parameters: psi -> source SMIMEINFO
                pBody -> target body object

    Returns   : void

    Comment   :

***************************************************************************/
HRESULT CSMime::SMIMEINFOToOptions(
    IMimeMessageTree * const pTree,
    const SMIMEINFO *   psi,
    HBODY               hBody)
{
    DWORD               dwSecurityType = 0;
    HBODY               hBody2;
    HRESULT             hr;
    ULONG               iLayer;
    PCRYPT_ATTRIBUTES   pattrsUnprot = NULL;
    CMessageBody *      pPrivBody = NULL;
    PSECURITY_LAYER_DATA psldLoop;
    IMimeSecurity2 *     psm = NULL;                
    PROPVARIANT         var;
#ifdef _WIN64
    UNALIGNED CRYPT_ATTR_BLOB *pVal = NULL;
#endif

    Assert(psi && hBody);
    CHECKHR(hr = pTree->BindToObject(hBody, IID_CMessageBody, (void**)&pPrivBody));
    Assert(pPrivBody);

    pPrivBody->GetOption(OID_SECURITY_CERT_INCLUDED, &var);
    Assert(VT_BOOL == var.vt);
    if (!var.boolVal && psi->fCertWithMsg) {
        var.boolVal = (VARIANT_BOOL) !!psi->fCertWithMsg;
        pPrivBody->InternalSetOption(OID_SECURITY_CERT_INCLUDED, &var,
                                     TRUE, TRUE);
    }

    pPrivBody->GetOption(OID_SECURITY_TYPE, &var);
    dwSecurityType = var.ulVal;

    //  We could have been passed something like ROOT, move to a real handle
    pPrivBody->GetHandle(&hBody2);

    for (iLayer = 0, psldLoop = psi->psldLayers; psldLoop != NULL;
        psldLoop = psldLoop->m_psldInner, iLayer++) {

        //  The rule here is:  Always insert a new layer UNLESS:
        //      1.  this is an encrpytion layer and
        //      2.  the previous layer was a signing layer

        if ((dwSecurityType != 0) &&
            (!(dwSecurityType & MST_THIS_ENCRYPT) ||
             !(psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN))) {
            /*            ((dwSecurityType & MST_THIS_SIGN_ENCRYPT) != MST_THIS_SIGN) &&
            ((psldLoop->m_dwMsgEnhancement & MST_THIS_SIGN_ENCRYPT) != MST_THIS_ENCRYPT)) {
            */
            if (psm != NULL) {
                psm->Release();
                psm = NULL;
            }
            pPrivBody->Release();
            CHECKHR(hr = pTree->ToMultipart(hBody2, "y-security", NULL));
            CHECKHR(hr = pTree->BindToObject(hBody2, IID_CMessageBody,
                                             (void**)&pPrivBody));
        }

        //  This must be after the above check for inserting a layer
        dwSecurityType |= psldLoop->m_dwMsgEnhancement | MST_CLASS_SMIME_V1;

        if (MST_SIGN_MASK & psldLoop->m_dwMsgEnhancement) {
            DWORD               cSigners = psldLoop->m_cSigners;
            DWORD               iSigner;
            SignerData *        pSigner;

            // Allocate enough space in the option arrays for this layer
            // OID_SECURITY_TYPE_RG             // DWORD
            // OID_SECURITY_ALG_HASH_RG         // BLOB
            // OID_SECURITY_CERT_SIGNING_RG     // DWORD
            // OID_SECURITY_HCERTSTORE_RG       // DWORD
            // OID_SECURITY_SYMCAPS_RG          // BLOB
            // OID_SECURITY_AUTHATTR_RG         // BLOB
            // OID_SECURITY_UNAUTHATTR_RG       // BLOB
            // OID_SECURITY_SIGNTIME_RG         // FILETIME
            // OID_SECURITY_USER_VALIDITY_RG    // DWORD
            // OID_SECURITY_RO_MSG_VALIDITY_RG  // DWORD

#ifdef _WIN64
            ULONG cbrgullCertSigning = cSigners * sizeof(ULONGLONG);
            ULONGLONG * rgullCertSigning;
#else   // !_WIN64
            ULONG cbrgdwCertSigning = cSigners * sizeof(DWORD);
            DWORD * rgdwCertSigning;
#endif  // _WIN64

            ULONG cbrgdwUserValidity = cSigners * sizeof(DWORD);
            ULONG cbrgdwROMsgValidity = cSigners * sizeof(DWORD);
            ULONG cbrgftSigntime = cSigners * sizeof(FILETIME);
            ULONG cbrgpvAlgHash = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvSymcaps = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvAuthattr = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvUnauthattr = cSigners * sizeof(PROPVARIANT);
#ifdef SMIME_V3            
            ULONG cbrgpvReceipt = cSigners * sizeof(PROPVARIANT);
            ULONG cbrgpvHash = cSigners * sizeof(PROPVARIANT);
#endif // SMIME_V3            
#ifdef _WIN64
            ULONG cbArrays = cbrgullCertSigning + 
#else
            ULONG cbArrays = cbrgdwCertSigning + 
#endif 
                cbrgdwUserValidity + cbrgdwROMsgValidity +
                cbrgftSigntime + cbrgpvAlgHash + cbrgpvSymcaps + cbrgpvAuthattr +
#ifdef SMIME_V3            
                cbrgpvReceipt +  cbrgpvHash +
#endif // SMIME_V3            
                cbrgpvUnauthattr;

            LPBYTE lpbArrays = NULL;

            LPDWORD rgdwUserValidity;
            LPDWORD rgdwROMsgValidity;
            FILETIME * rgftSigntime;
            PROPVARIANT * rgpvAlgHash;
            PROPVARIANT * rgpvSymcaps;
            PROPVARIANT * rgpvAuthattr;
            PROPVARIANT * rgpvUnauthattr;
#ifdef SMIME_V3            
            PROPVARIANT * rgpvReceipt;
            PROPVARIANT * rgpvHash;
#endif // SMIME_V3            
            
            // Allocate them all at once.
            if (! MemAlloc((LPVOID *)&lpbArrays, cbArrays)) {
                return E_OUTOFMEMORY;
            }
            ZeroMemory(lpbArrays, cbArrays);

            // Set up the pointers
#ifdef _WIN64
            rgullCertSigning = (ULONGLONG *) lpbArrays;
            rgdwUserValidity = (LPDWORD)((LPBYTE)rgullCertSigning + cbrgullCertSigning);
#else  // !_WIN64
            rgdwCertSigning = (DWORD *) lpbArrays;
            rgdwUserValidity = (LPDWORD)((LPBYTE)rgdwCertSigning + cbrgdwCertSigning);
#endif // _WIN64
            rgdwROMsgValidity = (LPDWORD)((LPBYTE)rgdwUserValidity + cbrgdwUserValidity);
            rgftSigntime = (FILETIME *)((LPBYTE)rgdwROMsgValidity + cbrgdwROMsgValidity);
            rgpvAlgHash = (PROPVARIANT *)((LPBYTE)rgftSigntime + cbrgftSigntime);
            rgpvSymcaps = (PROPVARIANT *)((LPBYTE)rgpvAlgHash + cbrgpvAlgHash);
            rgpvAuthattr = (PROPVARIANT *)((LPBYTE)rgpvSymcaps + cbrgpvSymcaps);
            rgpvUnauthattr = (PROPVARIANT *)((LPBYTE)rgpvAuthattr + cbrgpvAuthattr);
#ifdef SMIME_V3            
            rgpvReceipt = (PROPVARIANT *)((LPBYTE)rgpvUnauthattr + cbrgpvUnauthattr);
            rgpvHash = (PROPVARIANT *)((LPBYTE)rgpvReceipt + cbrgpvReceipt);
#endif // SMIME_V3            

            for (iSigner=0, pSigner = psldLoop->m_rgSigners; iSigner<cSigners;
                 iSigner++, pSigner++) {
#ifdef _WIN64
                rgullCertSigning[iSigner] = (ULONGLONG) pSigner->pccert;
#else  // !_WIN64
                rgdwCertSigning[iSigner] = (DWORD) pSigner->pccert;
#endif // _WIN64
                if (pSigner->blobHashAlg.cbSize) {
                    rgpvAlgHash[iSigner].vt = VT_BLOB;
                    rgpvAlgHash[iSigner].blob.cbSize = pSigner->blobHashAlg.cbSize;
                    // Don't need to duplicate
                    rgpvAlgHash[iSigner].blob.pBlobData = pSigner->blobHashAlg.pBlobData;
                }

                if (pSigner->blobAuth.cbSize) {
                    rgpvAuthattr[iSigner].vt = VT_BLOB;
                    rgpvAuthattr[iSigner].blob.cbSize = pSigner->blobAuth.cbSize;
                    // Don't need to duplicate
                    rgpvAuthattr[iSigner].blob.pBlobData = pSigner->blobAuth.pBlobData;

                    //  We want to break out two values from the authenticated blobs and put
                    //  them into someplace easy to access

                    DWORD               cbData = 0;
                    BOOL                f;
                    DWORD               i;
                    PCRYPT_ATTRIBUTES   pattrs = NULL;

                    if ((! HrDecodeObject(pSigner->blobAuth.pBlobData, 
                                          pSigner->blobAuth.cbSize,
                                          szOID_Microsoft_Attribute_Sequence, 0, &cbData,
                                          (LPVOID *)&pattrs)) && pattrs) {

                        FILETIME * pSigningTime = NULL;

                        Assert(pattrs);

                        for (i = 0; i < pattrs->cAttr; i++) {
                            Assert(pattrs->rgAttr[i].cValue == 1);
                            if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0) {
#ifndef _WIN64
                                if ((! HrDecodeObject(pattrs->rgAttr[i].rgValue[0].pbData,
                                                      pattrs->rgAttr[i].rgValue[0].cbData,
                                                      X509_CHOICE_OF_TIME, 0, &cbData, (LPVOID *)&pSigningTime)) && pSigningTime) 
#else // _WIN64
                                pVal = &(pattrs->rgAttr[i].rgValue[0]);
                                if ((! HrDecodeObject(pVal->pbData,
                                                      pVal->cbData,
                                                      X509_CHOICE_OF_TIME, 0, &cbData, (LPVOID *)&pSigningTime)) && pSigningTime)        
#endif //_WIN64
                                {
                                    Assert(cbData == sizeof(FILETIME));
                                    memcpy(&rgftSigntime[iSigner], pSigningTime, sizeof(FILETIME));
                                    SafeMemFree(pSigningTime);
                                }
                            }
                            else if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
                                rgpvSymcaps[iSigner].vt = VT_BLOB;
#ifndef _WIN64

                                rgpvSymcaps[iSigner].blob.cbSize = pattrs->rgAttr[i].rgValue[0].cbData;
                                // Duplicate the blob data since the MemFree(pattrs) will nuke this pointer.
                                rgpvSymcaps[iSigner].blob.pBlobData =
                                    DuplicateMemory(pattrs->rgAttr[i].rgValue[0].pbData, rgpvSymcaps[iSigner].blob.cbSize);
#else // _WIN64
                                pVal = &(pattrs->rgAttr[i].rgValue[0]);
                                rgpvSymcaps[iSigner].blob.cbSize = pVal->cbData;
                                // Duplicate the blob data since the MemFree(pattrs) will nuke this pointer.
                                rgpvSymcaps[iSigner].blob.pBlobData =
                                    DuplicateMemory(pVal->pbData, rgpvSymcaps[iSigner].blob.cbSize);
#endif //_WIN64
                            }
                        }
                        MemFree(pattrs);
                    }
                }

                if (pSigner->blobUnauth.cbSize) {
                    rgpvUnauthattr[iSigner].vt = VT_BLOB;
                    rgpvUnauthattr[iSigner].blob.cbSize = pSigner->blobUnauth.cbSize;
                    // Don't need to duplicate
                    rgpvUnauthattr[iSigner].blob.pBlobData = pSigner->blobUnauth.pBlobData;
                }

#ifdef SMIME_V3
                if (pSigner->blobReceipt.cbSize) {
                    rgpvReceipt[iSigner].vt = VT_BLOB;
                    rgpvReceipt[iSigner].blob.cbSize = pSigner->blobReceipt.cbSize;
                    // Don't need to duplicate
                    rgpvReceipt[iSigner].blob.pBlobData = pSigner->blobReceipt.pBlobData;
                    dwSecurityType |= MST_RECEIPT_REQUEST;
                }

                if (pSigner->blobHash.cbSize) {
                    rgpvHash[iSigner].vt = VT_BLOB;
                    rgpvHash[iSigner].blob.cbSize = pSigner->blobHash.cbSize;
                    // Don't need to duplicate
                    rgpvHash[iSigner].blob.pBlobData = pSigner->blobHash.pBlobData;
                }

#endif // SMIME_V3

                // Signature validity
                rgdwROMsgValidity[iSigner] = pSigner->ulValidity;
            }
            
#ifdef SMIME_V3
            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvReceipt;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_RECEIPT_RG, &var, TRUE, TRUE);
            
            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvHash;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_MESSAGE_HASH_RG, &var, TRUE, TRUE);
#endif // SMIME_V3


            // Set the array options
#ifdef _WIN64
            var.vt = VT_VECTOR | VT_UI8;
            var.cauh.pElems = (ULARGE_INTEGER *)(rgullCertSigning);
            var.cauh.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var, TRUE, TRUE);
#else
            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwCertSigning;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_CERT_SIGNING_RG, &var, TRUE, TRUE);
#endif // _WIN64

            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwUserValidity;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_USER_VALIDITY_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_UI4;
            var.caul.pElems = rgdwROMsgValidity;
            var.caul.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_RO_MSG_VALIDITY_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_FILETIME;
            var.cafiletime.pElems = rgftSigntime;
            var.cafiletime.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_SIGNTIME_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvAlgHash;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_ALG_HASH_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvSymcaps;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_SYMCAPS_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvAuthattr;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_AUTHATTR_RG, &var, TRUE, TRUE);

            var.vt = VT_VECTOR | VT_VARIANT;
            var.capropvar.pElems = rgpvUnauthattr;
            var.capropvar.cElems = cSigners;
            pPrivBody->InternalSetOption(OID_SECURITY_UNAUTHATTR_RG, &var, TRUE, TRUE);

            // clean up the duplicated rgpvSymcaps
            if (rgpvSymcaps) {
                for (iSigner = 0; iSigner < cSigners; iSigner++) {
                    SafeMemFree(rgpvSymcaps[iSigner].blob.pBlobData);
                }
            }

            // Free the arrays
            SafeMemFree(lpbArrays);
        }

        if (MST_THIS_ENCRYPT & psldLoop->m_dwMsgEnhancement) {
            Assert(psldLoop->m_pccertDecrypt != NULL);
            if (psldLoop->m_pccertDecrypt != NULL) {
#ifdef _WIN64
                var.vt = VT_UI8;
                var.pulVal = (ULONG *) (psldLoop->m_pccertDecrypt);
                pPrivBody->InternalSetOption(OID_SECURITY_CERT_DECRYPTION_64, &var,
                                             TRUE, TRUE);
#else   // !_WIN64
                var.vt = VT_UI4;
                var.ulVal = (ULONG) psldLoop->m_pccertDecrypt;
                pPrivBody->InternalSetOption(OID_SECURITY_CERT_DECRYPTION, &var,
                                             TRUE, TRUE);
#endif  // _WIN64
            }

            //N TODO: convert oids to symcaps
            //BruceK: Why?  Does this make sense on an encrypted layer?  Maybe Erik is
            //  suggesting that we put can gather a little bit of information about
            //  the sender's capabilities from the encryption method he used.  At any
            //  rate, it isn't nearly as important as the signed message case.
            Assert(psldLoop->m_blobDecAlg.cbSize != 0);
            if (psldLoop->m_blobDecAlg.cbSize) {
                var.vt = VT_BLOB;
                var.blob.cbSize = psldLoop->m_blobDecAlg.cbSize;
                var.blob.pBlobData = psldLoop->m_blobDecAlg.pBlobData;
                pPrivBody->InternalSetOption(OID_SECURITY_ALG_BULK, &var,
                                             TRUE, TRUE);
            }
            if (g_FSupportV3 && (psldLoop->m_blobUnprotectAttrs.cbData > 0)) {
                DWORD   iAttr; 
                DWORD   cbData = 0;

                if (psm == NULL) {
                    CHECKHR(hr = pPrivBody->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psm));
                }
                CHECKHR(hr = HrDecodeObject(psldLoop->m_blobUnprotectAttrs.pbData,
                                            psldLoop->m_blobUnprotectAttrs.cbData,
                                            szOID_Microsoft_Attribute_Sequence, 0,
                                            &cbData, (LPVOID *) &pattrsUnprot));
                for (iAttr = 0; iAttr < pattrsUnprot->cAttr; iAttr++) {
                    CHECKHR(hr = psm->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED,  
                                                   &pattrsUnprot->rgAttr[iAttr]));
                }
            }
        }

        var.vt = VT_UI4;
        var.ulVal = dwSecurityType;
        pPrivBody->InternalSetOption(OID_SECURITY_TYPE, &var, TRUE, TRUE);

        // M00BUG -- must deal with two?
#ifdef _WIN64
        if (psldLoop->m_hcertstor != NULL) {
            var.vt = VT_UI8;
            var.pulVal = (ULONG *) (psldLoop->m_hcertstor);
            pPrivBody->InternalSetOption(OID_SECURITY_HCERTSTORE_64, &var, TRUE, TRUE);
        }
#else
        if (psldLoop->m_hcertstor != NULL) 
        {
            var.vt = VT_UI4;
            var.ulVal = (ULONG)psldLoop->m_hcertstor;
            pPrivBody->InternalSetOption(OID_SECURITY_HCERTSTORE, &var, TRUE, TRUE);
        }
#endif // _WIN64
    }
    
    hr = S_OK;
exit:
    if (psm != NULL)            psm->Release();
    SafeMemFree(pattrsUnprot);
    if (pPrivBody != NULL)      pPrivBody->Release();
    return hr;
}

/***************************************************************************

    Name      : MergeSMIMEINFO

    Purpose   : 

    Parameters: psiOuter -> Object to be merged into
                psiInner -> Object to merge from

    Returns   : HRESULT of errors

    Comment   :

***************************************************************************/
HRESULT CSMime::MergeSMIMEINFO(SMIMEINFO *psiOuter, SMIMEINFO * psiInner)
{
    PSECURITY_LAYER_DATA        psld;
    
    psiOuter->fCertWithMsg |= psiInner->fCertWithMsg;

    //  Just stick the inner data at the inner most point in the outer data
    //  and the clear out the inner data structure.

    if (psiInner->psldLayers != NULL) {
        for (psld = psiOuter->psldLayers; psld->m_psldInner != NULL;
             psld = psld->m_psldInner);
        psld->m_psldInner = psiInner->psldLayers;
        psiInner->psldLayers = NULL;
    }
    return S_OK;
}

/***************************************************************************

    Name      : FreeSMIMEINFO

    Purpose   : Free and Release the memory and objects stored in the
                SMIMEINFO.

    Parameters: psi -> SMIMEINFO

    Returns   : none

    Comment   :

***************************************************************************/
void CSMime::FreeSMIMEINFO(SMIMEINFO *psi)
{
    register DWORD i;

    if (psi->psldLayers) {
        psi->psldLayers->Release();
    }

    for (i = 0; i < psi->cStores; i++) {
        CertCloseStore(psi->rgStores[i], 0);
    }
    if (psi->rgStores) {
        g_pMoleAlloc->Free(psi->rgStores);
    }

    if (psi->hProv) {
        CryptReleaseContext(psi->hProv, 0);
    }

#ifdef SMIME_V3
    MemFree(psi->pszInnerContent);
    SafeMemFree(psi->pwszKeyPrompt);
#endif // SMIME_V3

    return;
}

#ifdef KILL_THIS
/***************************************************************************

    Name      : MergeSMIMEINFOs

    Purpose   : Merge two SMIMEINFO structures into one

    Parameters: psiOuter -> Source structure
                psiInner -> Destination structure

    Returns   : void

    Comment   :

***************************************************************************/
void CSMime::MergeSMIMEINFOs(const SMIMEINFO *const psiOuter, SMIMEINFO *const psiInner)
{
    PSECURITY_LAYER_DATA psldLoopOuter;
    PSECURITY_LAYER_DATA psldLoopInner;

    psiInner->fCertWithMsg |= psiOuter->fCertWithMsg;

    Assert(0 == (psiOuter->ulMsgValidity & psiInner->ulMsgValidity));
    psiInner->ulMsgValidity |= psiOuter->ulMsgValidity;

    if (psiOuter->dwMsgEnhancement & MST_SIGN_MASK) {
        // Duplicate the stores
        if (psiOuter->cStores) {
            psiInner->rgStores = (HCERTSTORE*)
              g_pMoleAlloc->Alloc(psiOuter->cStores * sizeof(HCERTSTORE));
            if (psiOuter->rgStores) {
                for (DWORD i = 0; i < psiOuter->cStores; i++) {
                    psiInner->rgStores[i] = CertDuplicateStore(psiOuter->rgStores[i]);
                }
                psiInner->cStores = psiOuter->cStores;
            }
        }
    }

    psiInner->dwMsgEnhancement |= psiOuter->dwMsgEnhancement;

    // Before I link in this new list, I'd like to do some error checking.  In particular, I
    // want to aviod loops and duplicates in my linked list.
    psldLoopOuter = psiOuter->psldLayers;
    while (psldLoopOuter) {
        psldLoopInner = psiInner->psldLayers;
        while (psldLoopInner) {
            if (psldLoopInner == psldLoopOuter) {
                AssertSz(FALSE, "MergeSMIMEINFOs found duplicate layer data");
                // OK, we'll just ignore the outer layer data.
                goto exit;
            }
            psldLoopInner = psldLoopInner->m_psldInner;
        }
        psldLoopOuter = psldLoopOuter->m_psldInner;
    }

    // Insert the outer layer data list at the head of the inner list.
    psldLoopInner = psiInner->psldLayers;
    psldLoopOuter = psiOuter->psldLayers;

    psiInner->psldLayers = psldLoopOuter;
    if (psldLoopOuter) {
        // We've linked it into another SMIMEINFO, AddRef.
        psldLoopOuter->AddRef();

        // Walk the Outer list to find the end.
        while (psldLoopOuter) {
            if (! psldLoopOuter->m_psldInner) {
                // Found end of list.  Tack on original inner list here.
                psldLoopOuter->m_psldInner = psldLoopInner;

                // Hook up the Outer link
                Assert(! psldLoopInner->m_psldOuter);
                psldLoopInner->m_psldOuter = psldLoopOuter;
                break;
            }
            psldLoopOuter = psldLoopOuter->m_psldInner;
        }
    }

    // Make sure we bring the encryption layer with us.
    if (psiOuter->psldEncrypt) {
        Assert(! psiInner->psldEncrypt);
        if (! psiInner->psldEncrypt) {
            psiInner->psldEncrypt = psiOuter->psldEncrypt;
        }
    }

    // Update the inner layer pointer (in case there was none before)
    if (! psiInner->psldInner) {
        psiInner->psldInner = psiOuter->psldInner;
    }
    psiInner->ulLayers += psiOuter->ulLayers;

exit:
    return;
}
#endif // KILL_THIS?

#ifndef SMIME_V3
// Bitfield for dw below
#define CAA_SIGNING_TIME        1
#define CAA_SMIME_CAPABILITIES  2
#define CAA_ALL                 (CAA_SIGNING_TIME | CAA_SMIME_CAPABILITIES)

/***************************************************************************

    Name      : ConstructAuthAttributes

    Purpose   : crack open the authenticated attributes blobs and check
                if there is a signing time specified.  If not, we must
                add one.  Ditto with the S/Mime Capabilities.

    Parameters: pblEncoded -> return blob of encoded Authenticated Attributes
                pblAuthAttr -> authenticated attribute blob
                                data pointer may be replaced
                pftSigntime -> signing time
                pblSymcaps -> symcaps blob

    Returns   : HRESULT

    Comment   : The caller should be careful not to cache the
                data pointer within the authenticated attributes blob since
                it may be freed in here and replaced with a different one.

***************************************************************************/
static HRESULT ConstructAuthAttributes(BLOB * pblEncoded, BLOB * pblAuthAttr, FILETIME * pftSigntime,  BLOB * pblSymcaps)
{
    HRESULT             hr = S_OK;
    ULONG               cbData;
    ULONG               i;
    DWORD               dw;     // bitfield: CAA_SIGNING_TIME, CAA_SMIME_CAPABILITIES
    PCRYPT_ATTRIBUTES   pattrs = NULL;
    BOOL                fpattrs = FALSE;
    PCRYPT_ATTRIBUTE    pattr = NULL;
    LPBYTE              pbSignTime = NULL;
    LPBYTE              pbAttr = NULL;
    CRYPT_ATTRIBUTES    attrs;
    CRYPT_ATTR_BLOB     valCaps;
    CRYPT_ATTR_BLOB     valTime;

    Assert(pblAuthAttr);
    Assert(pftSigntime);
    Assert(pblSymcaps);
    Assert(pblEncoded);

    if ((pblAuthAttr->cbSize > 0) &&
        ((! HrDecodeObject(pblAuthAttr->pBlobData, pblAuthAttr->cbSize,
                           szOID_Microsoft_Attribute_Sequence,
                           0, &cbData, (LPVOID *)&pattrs)) && pattrs)) {
        fpattrs = TRUE; // don't forget to free pattrs!
        for (i = 0, dw = CAA_ALL; i < pattrs->cAttr; i++) {
            if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_signingTime) == 0) {
                dw &= ~CAA_SIGNING_TIME;
            }
            else if (lstrcmp(pattrs->rgAttr[i].pszObjId, szOID_RSA_SMIMECapabilities) == 0) {
                dw &= ~CAA_SMIME_CAPABILITIES;
            }
        }
    } else {
        // BUGBUG: Should probably report the error if MemAlloc failed.  As it sits, there is no
        // real harm except that the message will go out without a signing time and symcaps.
        dw = CAA_ALL;
        pattrs = &attrs;
        attrs.cAttr = 0;
        attrs.rgAttr = NULL;
    }

    if (MemAlloc((LPVOID *)&pattr, (pattrs->cAttr + 2) * sizeof(CRYPT_ATTRIBUTE))) {
        memcpy(pattr, pattrs->rgAttr, pattrs->cAttr * sizeof(CRYPT_ATTRIBUTE));
        pattrs->rgAttr = pattr;

        //
        //  The default answer does not have a signing time in it.  We are going
        //      to create and add a signing time.  This may come from either
        //      a passed in parameter, or from the system.
        if (dw & CAA_SIGNING_TIME) {
            if ((pftSigntime->dwLowDateTime == 0) &&
                (pftSigntime->dwHighDateTime == 0)) {
                GetSystemTimeAsFileTime(pftSigntime);   // caller sees it now!
            }

            cbData = 0;
            if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                    pftSigntime, CRYPT_ENCODE_ALLOC_FLAG,
                                    &CryptEncodeAlloc, &pbSignTime, &cbData)) {
                // BUGBUG: Should probably report the error if MemAlloc failed.  As it sits, there is no
                // real harm except that the message will go out without a signing time and symcaps.

                pattr[pattrs->cAttr].pszObjId = szOID_RSA_signingTime;
                pattr[pattrs->cAttr].cValue = 1;
                pattr[pattrs->cAttr].rgValue = &valTime;
                pattr[pattrs->cAttr].rgValue[0].pbData = pbSignTime;
                pattr[pattrs->cAttr].rgValue[0].cbData = cbData;
                pattrs->cAttr += 1;
            }
        }
        if (dw & CAA_SMIME_CAPABILITIES) {
            if (pblSymcaps->cbSize > 0) {
                pattr[pattrs->cAttr].pszObjId = szOID_RSA_SMIMECapabilities;
                pattr[pattrs->cAttr].cValue = 1;
                pattr[pattrs->cAttr].rgValue = &valCaps;
                pattr[pattrs->cAttr].rgValue[0].pbData = pblSymcaps->pBlobData;
                pattr[pattrs->cAttr].rgValue[0].cbData = pblSymcaps->cbSize;
                pattrs->cAttr += 1;
            }
        }

        cbData = 0;
        if (CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                 pattrs, CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptEncodeAlloc, &pbAttr, &cbData)) {
            hr = HrGetLastError();
            goto exit;
        }
        pblEncoded->cbSize = cbData;
        pblEncoded->pBlobData = pbAttr;
        pbAttr = NULL;      // Drop this pointer so that it won't be freed below
    } else {
        hr = E_OUTOFMEMORY;
    }

  exit:
    SafeMemFree(pattr);
    if (fpattrs) {
        SafeMemFree(pattrs);
    }
    SafeMemFree(pbSignTime);

    return(hr);
}
#endif // !SMIME_V3


/***************************************************************************

    Name      : IsSMimeProtocol

    Purpose   : Test if the protocol type of this root message body is
                application/x-pkcs7-signature

    Parameters: lpPropSet -> Property set of message

    Returns   : TRUE if this is an S/MIME protocol message

    Comment   : Used to differentiate between S/MIME and PGP signatures.

***************************************************************************/
BOOL IsSMimeProtocol(LPMIMEPROPERTYSET lpPropSet) {
    PROPVARIANT var;
    BOOL        fReturn = FALSE;

    var.vt = VT_LPSTR;

    if (SUCCEEDED(lpPropSet->GetProp(
      STR_PAR_PROTOCOL,
      0,                  // [in] DWORD dwFlags,
      &var))) {
        if (var.pszVal) {
            fReturn = (! lstrcmpi(var.pszVal, STR_MIME_APPL_PKCS7SIG)) ||
              (! lstrcmpi(var.pszVal, STR_MIME_APPL_PKCS7SIG_1));
            SafeMemFree(var.pszVal);
        }
    }
    return(fReturn);
}


/***************************************************************************

    Name      : DuplicateMemory

    Purpose   : Allocate a new buffer and copy the old one into it.

    Parameters: lpbIn -> Existing buffer
                cbIn = size of lpvIn

    Returns   : new MemAlloc'ed buffer

    Comment   : Caller is responsible for MemFree'ing the returned buffer.

***************************************************************************/
LPBYTE DuplicateMemory(LPBYTE lpvIn, ULONG cbIn) {
    LPBYTE lpbReturn = NULL;

    if (MemAlloc((void**)&lpbReturn, cbIn)) {
        memcpy(lpbReturn, lpvIn, cbIn);
    }

    return(lpbReturn);
}


//*************************************************************************
//                  CSECURITY_LAYER_DATA
//*************************************************************************

///////////////////////////////////////////////////////////////////////////
//
// ctor/dtor
//


CSECURITY_LAYER_DATA::CSECURITY_LAYER_DATA(void)
{
    m_cRef = 1;
    DOUT("CSECURITY_LAYER_DATA::constructor() %#x -> %d", this, m_cRef);

    m_dwMsgEnhancement = MST_NONE;
    m_fCertInLayer = FALSE;

    m_cSigners = 0;
    m_rgSigners = NULL;

    m_cEncryptItems = 0;
#ifdef SMIME_V3
    m_rgRecipientInfo = NULL;
    m_ContentEncryptAlgorithm.pszObjId = NULL;
    m_ContentEncryptAlgorithm.Parameters.cbData = 0;
    m_ContentEncryptAlgorithm.Parameters.pbData = NULL;
    m_pvEncryptAuxInfo = NULL;
    m_blobUnprotectAttrs.pbData = NULL;
    m_blobUnprotectAttrs.cbData = 0;
    m_hstoreEncrypt = NULL;
#else  // !SMIME_V3
    m_rgEncryptItems = NULL;
#endif // SMIME_V3

    m_ulDecValidity = 0;
    m_blobDecAlg.cbSize = 0;
    m_blobDecAlg.pBlobData = NULL;
    m_pccertDecrypt = NULL;

    m_hcertstor = NULL;

    m_psldInner = NULL;
    m_psldOuter = NULL;
}

CSECURITY_LAYER_DATA::~CSECURITY_LAYER_DATA(void)
{
    DWORD       i;
    DWORD       i1;
    DWORD       iSigner;
    DOUT("CSECURITY_LAYER_DATA::destructor() %#x -> %d", this, m_cRef);

    if (m_psldInner != NULL) {
        m_psldInner->Release();
    }
    
    if (m_hcertstor != NULL)            CertCloseStore(m_hcertstor, 0);

    if (m_pccertDecrypt != NULL)        CertFreeCertificateContext(m_pccertDecrypt);
    SafeMemFree(m_blobDecAlg.pBlobData);

    for (iSigner=0; iSigner<m_cSigners; iSigner++) {
        if (m_rgSigners[iSigner].pccert != NULL) 
            CertFreeCertificateContext(m_rgSigners[iSigner].pccert);
        SafeMemFree(m_rgSigners[iSigner].blobHashAlg.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobAuth.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobUnauth.pBlobData);
#ifdef SMIME_V3
        SafeMemFree(m_rgSigners[iSigner].blobReceipt.pBlobData);
        SafeMemFree(m_rgSigners[iSigner].blobHash.pBlobData);
#endif // SMIME_V3
    }
    SafeMemFree(m_rgSigners);

    for (i=0; i<m_cEncryptItems; i++) {
#ifdef SMIME_V3
        switch (m_rgRecipientInfo[i].dwRecipientChoice) {
        case CMSG_KEY_TRANS_RECIPIENT:
            if (m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pKeyTrans->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->pvKeyEncryptionAuxInfo);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey.cbData != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientPublicKey.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_KEY_IDENTIFIER)
            {
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.KeyId.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.KeyId.pbData);
                }
            }
            else if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.dwIdChoice == CERT_ID_ISSUER_SERIAL_NUMBER)
            {
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData);
                }
                if (m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.cbData != 0) {
                    MemFree(m_rgRecipientInfo[i].pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.pbData);
                }
            }

            SafeMemFree(m_rgRecipientInfo[i].pKeyTrans);
            break;

        case CMSG_MAIL_LIST_RECIPIENT:
            if (m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pMailList->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pMailList->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pMailList->pvKeyEncryptionAuxInfo);
            }

            if (m_rgRecipientInfo[i].pMailList->pOtherAttr != NULL) {
                MemFree(m_rgRecipientInfo[i].pMailList->pOtherAttr->pszObjId);
                MemFree(m_rgRecipientInfo[i].pMailList->pOtherAttr->Value.pbData);
            }

            SafeMemFree(m_rgRecipientInfo[i].pMailList);
            break;

        case CMSG_KEY_AGREE_RECIPIENT:
            if (m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.pszObjId != 0) {
                MemFree(m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.pszObjId);
                MemFree(m_rgRecipientInfo[i].pKeyAgree->KeyEncryptionAlgorithm.Parameters.pbData);
            }

            if (m_rgRecipientInfo[i].pKeyAgree->pvKeyEncryptionAuxInfo != NULL) {
                MemFree(m_rgRecipientInfo[i].pKeyAgree->pvKeyEncryptionAuxInfo);
            }

            SafeMemFree(m_rgRecipientInfo[i].pKeyAgree);
            break;

        default:
            Assert(FALSE);
            break;
        }
#else  // SMIME_V3
        SafeMemFree(m_rgEncryptItems[i].Transport.blobAlg.pBlobData);
        switch (m_rgEncryptItems[i].dwTagType) {
        case ENCRYPT_ITEM_TRANSPORT:
            for (i1=0; i1<m_rgEncryptItems[i].Transport.cCert; i1++) {
                CertFreeCertificateContext(m_rgEncryptItems[i].Transport.rgpccert[i1]);
            }
            SafeMemFree(m_rgEncryptItems[i].Transport.rgpccert);
            break;
            
        default:
            Assert(FALSE);
            break;
        }
#endif // SMIME_V3
    }
#ifdef SMIME_V3
    SafeMemFree(m_rgRecipientInfo);
    SafeMemFree(m_pvEncryptAuxInfo);
    SafeMemFree(m_ContentEncryptAlgorithm.pszObjId);
    SafeMemFree(m_ContentEncryptAlgorithm.Parameters.pbData);
    SafeMemFree(m_blobUnprotectAttrs.pbData);
    CertCloseStore(m_hstoreEncrypt, 0);
#else  // SMIME_V3
    SafeMemFree(m_rgEncryptItems);
#endif // SMIME_V3
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//

STDMETHODIMP CSECURITY_LAYER_DATA::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid) {
        *ppv = THIS_AS_UNK;
    }
    else if (IID_IStream == riid) {
        *ppv = (IStream *)this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CSECURITY_LAYER_DATA::AddRef(void)
{
    DOUT("CSECURITY_LAYER_DATA::AddRef() %#x -> %d", this, m_cRef+1);
    InterlockedIncrement((LPLONG)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CSECURITY_LAYER_DATA::Release(void)
{
    DOUT("CSECURITY_LAYER_DATA::Release() %#x -> %d", this, m_cRef-1);

    if (0 == InterlockedDecrement((LPLONG)&m_cRef)) {
        delete this;
        return 0;
    }
    return m_cRef;
}

#ifdef SMIME_V3
/***    HrCopyOID
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyOID(LPCSTR psz, LPSTR * ppsz)
{
    DWORD       cb;
    HRESULT     hr = S_OK;

    cb = strlen(psz) + 1;
    CHECKHR(hr = HrAlloc((void **) ppsz, cb));
    memcpy(*ppsz, psz, cb);

exit:
    return hr;
}

/***    HrCopyCryptDataBlob
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyCryptDataBlob(const CRYPT_DATA_BLOB * pblobSrc, PCRYPT_DATA_BLOB pblobDst)
{
    HRESULT     hr = S_OK;
    
    if (pblobSrc->cbData == 0) {
        Assert(pblobDst->pbData == NULL);
        Assert(pblobDst->cbData == 0);
        goto exit;
    }
    
    CHECKHR(hr = HrAlloc((void **) &pblobDst->pbData, pblobSrc->cbData));
    memcpy(pblobDst->pbData, pblobSrc->pbData, pblobSrc->cbData);
    pblobDst->cbData = pblobSrc->cbData;

exit:
    return hr;
}

/***    HrCopyCryptDataBlob
 *
 * Description:
 *      General utility function to make copying of recipient info objects much easier
 */

HRESULT HrCopyCryptBitBlob(const CRYPT_BIT_BLOB * pblobSrc, PCRYPT_BIT_BLOB pblobDst)
{
    HRESULT     hr = S_OK;
    
    if (pblobSrc->cbData == 0) {
        Assert(pblobDst->pbData == NULL);
        Assert(pblobDst->cbData == 0);
        goto exit;
    }
    
    CHECKHR(hr = HrAlloc((void **) &pblobDst->pbData, pblobSrc->cbData));
    memcpy(pblobDst->pbData, pblobSrc->pbData, pblobSrc->cbData);
    pblobDst->cbData = pblobSrc->cbData;
    pblobDst->cUnusedBits = pblobSrc->cUnusedBits;

exit:
    return hr;
}

HRESULT HrCopyCryptAlgorithm(const CRYPT_ALGORITHM_IDENTIFIER * pAlgSrc,
                             PCRYPT_ALGORITHM_IDENTIFIER pAlgDst)
{
    HRESULT     hr = S_OK;
    
    CHECKHR(hr = HrCopyOID(pAlgSrc->pszObjId, &pAlgDst->pszObjId));

    if (pAlgSrc->Parameters.cbData != 0) {
        CHECKHR(hr = HrCopyCryptDataBlob(&pAlgSrc->Parameters, &pAlgDst->Parameters));
    }

exit:
    return hr;
}

HRESULT HrCopyCertId(const CERT_ID * pcertidSrc, PCERT_ID pcertidDst)
{
    HRESULT     hr = S_OK;

    pcertidDst->dwIdChoice = pcertidSrc->dwIdChoice;
    switch (pcertidSrc->dwIdChoice) {
    case CERT_ID_ISSUER_SERIAL_NUMBER:
        hr = HrCopyCryptDataBlob(&pcertidSrc->IssuerSerialNumber.Issuer,
                                 &pcertidDst->IssuerSerialNumber.Issuer);
        hr = HrCopyCryptDataBlob(&pcertidSrc->IssuerSerialNumber.SerialNumber,
                                 &pcertidDst->IssuerSerialNumber.SerialNumber);
        break;
        
    case CERT_ID_KEY_IDENTIFIER:
        hr = HrCopyCryptDataBlob(&pcertidSrc->HashId, &pcertidDst->HashId);
        break;
        
    case CERT_ID_SHA1_HASH:
        hr = HrCopyCryptDataBlob(&pcertidSrc->HashId, &pcertidDst->HashId);
        break;
        
    default:
        return E_FAIL;
    }

    return hr;
}

/***    FreeRecipientInfo
 *
 * Description:
 *      Free all of the data pointed to by the recipient info as well as the recipient
 *      info object itself.
 */

void FreeRecipientInfoContent(PCMS_RECIPIENT_INFO pRecipInfo)
{
    if (pRecipInfo->pccert != NULL) {
        CertFreeCertificateContext(pRecipInfo->pccert);
    }

    if (pRecipInfo->KeyEncryptionAlgorithm.pszObjId != 0) {
        MemFree(pRecipInfo->KeyEncryptionAlgorithm.pszObjId);
        MemFree(pRecipInfo->KeyEncryptionAlgorithm.Parameters.pbData);
    }

    if (pRecipInfo->pvKeyEncryptionAuxInfo != NULL) {
        MemFree(pRecipInfo->pvKeyEncryptionAuxInfo);
    }

    if ((pRecipInfo->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS) &&
        (pRecipInfo->u1.SubjectPublicKey.cbData != 0)) {
        MemFree(pRecipInfo->u1.SubjectPublicKey.pbData);
    }

    if (pRecipInfo->dwU1 == CMS_RECIPIENT_INFO_PUBKEY_PROVIDER) {
        Assert(FALSE);
    }

    if (pRecipInfo->dwU3 == CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL) {
        if (pRecipInfo->u3.IssuerSerial.Issuer.cbData != 0) {
            MemFree(pRecipInfo->u3.IssuerSerial.Issuer.pbData);
        }
        if (pRecipInfo->u3.IssuerSerial.SerialNumber.cbData != 0) {
            MemFree(pRecipInfo->u3.IssuerSerial.SerialNumber.pbData);
        }
    }

    if (pRecipInfo->dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
        if (pRecipInfo->u3.KeyId.cbData != 0) {
            MemFree(pRecipInfo->u3.KeyId.pbData);
        }
    }

    if (pRecipInfo->pOtherAttr != NULL) {
        MemFree(pRecipInfo->pOtherAttr->pszObjId);
        MemFree(pRecipInfo->pOtherAttr->Value.pbData);
    }

    return;
}
#endif // SMIME_V3

/* * * END --- SMIME.CPP --- END * * */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\olealloc.cpp ===
// --------------------------------------------------------------------------------
// Olealloc.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "olealloc.h"
#include "smime.h"

// --------------------------------------------------------------------------------
// CMimeAllocator::CMimeAllocator
// --------------------------------------------------------------------------------
CMimeAllocator::CMimeAllocator(void)
{
    if (NULL != g_pMoleAlloc)
        DllAddRef();
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::~CMimeAllocator
// --------------------------------------------------------------------------------
CMimeAllocator::~CMimeAllocator(void)
{
    if (this != g_pMoleAlloc)
        DllRelease();
}

// --------------------------------------------------------------------------------
// CMimeAllocator::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IMimeAllocator *)this;
    else if (IID_IMimeAllocator == riid)
        *ppv = (IMimeAllocator *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeAllocator::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeAllocator::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Alloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMimeAllocator::Alloc(SIZE_T cb)
{
    // Locals
    LPVOID pv;

    // Do I have a global Allocator
    Assert(g_pMalloc);

    // Allocate it
    pv = g_pMalloc->Alloc(cb);
    if (NULL == pv)
    {
        TrapError(E_OUTOFMEMORY);
        return NULL;
    }

    // Done
    return pv;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Realloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMimeAllocator::Realloc(void *pv, SIZE_T cb)
{
    // Locals
    LPVOID pvNew;

    // Do I have a global Allocator
    Assert(g_pMalloc);

    // Realloc
    pvNew = g_pMalloc->Realloc(pv, cb);
    if (NULL == pvNew)
    {
        TrapError(E_OUTOFMEMORY);
        return NULL;
    }

    // Done
    return pvNew;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::Free
// --------------------------------------------------------------------------------
STDMETHODIMP_(void) CMimeAllocator::Free(void * pv)
{
    // Better have pv
    Assert(pv && g_pMalloc);

    // If Not NULL
    if (pv)
    {
        // Free It
        g_pMalloc->Free(pv);
    }
}

// --------------------------------------------------------------------------------
// CMimeAllocator::GetSize
// --------------------------------------------------------------------------------
STDMETHODIMP_(SIZE_T) CMimeAllocator::GetSize(void *pv)
{
    return g_pMalloc->GetSize(pv);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::DidAlloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(int) CMimeAllocator::DidAlloc(void *pv)
{
    return g_pMalloc->DidAlloc(pv);
}

// --------------------------------------------------------------------------------
// CMimeAllocator::HeapMinimize
// --------------------------------------------------------------------------------
STDMETHODIMP_(void) CMimeAllocator::HeapMinimize(void)
{
    g_pMalloc->HeapMinimize();
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeParamInfoArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeParamInfoArray(ULONG cParams, LPMIMEPARAMINFO prgParam, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cParams || NULL == prgParam)
        return S_OK;

    // Loop
    for (ULONG i=0; i<cParams; i++)
    {
        SafeMemFree(prgParam[i].pszName);
        SafeMemFree(prgParam[i].pszData);
    }

    // Free the Array
    if (fFreeArray)
    {
        SafeMemFree(prgParam);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::ReleaseObjects
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::ReleaseObjects(ULONG cObjects, IUnknown **prgpUnknown, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cObjects || NULL == prgpUnknown)
        return S_OK;

    // Loop
    for (ULONG i=0; i<cObjects; i++)
    {
        SafeRelease(prgpUnknown[i]);
    }

    // Free Array
    if (fFreeArray)
    {
        SafeMemFree(prgpUnknown);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeHeaderLineArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeEnumHeaderRowArray(ULONG cRows, LPENUMHEADERROW prgRow, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cRows || NULL == prgRow)
        return S_OK;

    // Loop the cells
    for (ULONG i=0; i<cRows; i++)
    {
        SafeMemFree(prgRow[i].pszHeader);
        SafeMemFree(prgRow[i].pszData);
    }

    // Free Array
    if (fFreeArray)
        SafeMemFree(prgRow);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeEnumPropertyArray
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeEnumPropertyArray(ULONG cProps, LPENUMPROPERTY prgProp, boolean fFreeArray)
{
    // Nothing to Free
    if (0 == cProps || NULL == prgProp)
        return S_OK;

    // Loop the cells
    for (ULONG i=0; i<cProps; i++)
        SafeMemFree(prgProp[i].pszName);

    // Free Array
    if (fFreeArray)
        SafeMemFree(prgProp);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeAddressProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeAddressProps(LPADDRESSPROPS pAddress)
{
    // Invalid Arg
    if (NULL == pAddress)
        return TrapError(E_INVALIDARG);

    // IAP_FRIENDLY
    if (ISFLAGSET(pAddress->dwProps, IAP_FRIENDLY) && pAddress->pszFriendly)
        g_pMalloc->Free(pAddress->pszFriendly);

    // IAP_FRIENDLYW
    if (ISFLAGSET(pAddress->dwProps, IAP_FRIENDLYW) && pAddress->pszFriendlyW)
        g_pMalloc->Free(pAddress->pszFriendlyW);

    // IAP_EMAIL
    if (ISFLAGSET(pAddress->dwProps, IAP_EMAIL) && pAddress->pszEmail)
        g_pMalloc->Free(pAddress->pszEmail);

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pAddress->dwProps, IAP_SIGNING_PRINT) && pAddress->tbSigning.pBlobData)
        g_pMalloc->Free(pAddress->tbSigning.pBlobData);

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pAddress->dwProps, IAP_ENCRYPTION_PRINT) && pAddress->tbEncryption.pBlobData)
        g_pMalloc->Free(pAddress->tbEncryption.pBlobData);

    // No legal props
    ZeroMemory(pAddress, sizeof(ADDRESSPROPS));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::FreeAddressList
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeAddressList(LPADDRESSLIST pList)
{
    // Invalid Arg
    if (NULL == pList || (pList->cAdrs > 0 && NULL == pList->prgAdr))
        return TrapError(E_INVALIDARG);

    // Free Each Item
    for (ULONG i=0; i<pList->cAdrs; i++)
        FreeAddressProps(&pList->prgAdr[i]);

    // Free the list
    SafeMemFree(pList->prgAdr);

    // Zero It
    ZeroMemory(pList, sizeof(ADDRESSLIST));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeAllocator::PropVariantClear
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::PropVariantClear(LPPROPVARIANT pProp)
{
    return MimeOleVariantFree(pProp);
}

// ---------------------------------------------------------------------------
// CMimeAllocator::FreeThumbprint
// ---------------------------------------------------------------------------
STDMETHODIMP CMimeAllocator::FreeThumbprint(THUMBBLOB *pthumbprint)
{
    if (pthumbprint->pBlobData)
        {
        Assert(0 != g_pMalloc->DidAlloc(pthumbprint->pBlobData));
        MemFree(pthumbprint->pBlobData);
        }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\stackstr.h ===
// --------------------------------------------------------------------------------
// Stackstr.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __STACKSTR_H
#define __STACKSTR_H

// --------------------------------------------------------------------------------
// Use this macro to define a stack string within a function
// --------------------------------------------------------------------------------
#define STACKSTRING_DEFINE(_name, _size) \
    struct { \
        CHAR szScratch[_size]; \
        LPSTR pszVal; \
        } _name = { '0', NULL };

// --------------------------------------------------------------------------------
// Use this macro to insure that _name::pszVal can hold _cchVal. This macro 
// depends on the local variable 'hr', and that there is a label named 'exit' at
// the end of your function.
// --------------------------------------------------------------------------------
#define STACKSTRING_SETSIZE(_name, _cchVal) \
    if (NULL != _name.pszVal && _name.pszVal != _name.szScratch) { \
        LPSTR psz = (LPSTR)g_pMalloc->Realloc(_name.pszVal, _cchVal); \
        if (NULL == psz) { \
            hr = TrapError(E_OUTOFMEMORY); \
            goto exit; \
        } \
        _name.pszVal = psz; \
    } \
    else if (_cchVal <= sizeof(_name.szScratch)) { \
        _name.pszVal = _name.szScratch; \
    }  \
    else { \
        _name.pszVal = (LPSTR)g_pMalloc->Alloc(_cchVal); \
    }

// --------------------------------------------------------------------------------
// Use this macro to free a stack string
// --------------------------------------------------------------------------------
#define STACKSTRING_FREE(_name) \
    if (NULL != _name.pszVal && _name.pszVal != _name.szScratch) { \
        g_pMalloc->Free(_name.pszVal); \
        _name.pszVal = NULL; \
    }

#endif // __STACKSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimecap.cpp ===
#include        "pch.hxx"
#include        "demand.h"
#include        <shlwapi.h>
#include        "resource.h"
#include        "dllmain.h"


#ifdef WIN16
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextA
#else
#define CRYPT_ACQUIRE_CONTEXT   CryptAcquireContextW
#endif


////////////////////////////////////////////////////////////////////////////////

const BYTE      RgbRc2_40bit[] = {0x2, 0x01, 40};
const BYTE      RgbRc2_64bit[] = {0x2, 0x01, 64};
const BYTE      RgbRc2_128bit[] = {0x2, 0x02, 0, 128};
const char      SzRc2_128[] = "RC2 (128-bit)";
const char      SzRc2_64[] = "RC2 (64-bit)";
const char      SzRc2_40[] = "RC2 (40-bit)";
const char      SzRc2[] = "RC2";
const char      SzDES[] = "DES";
const char      Sz3DES[] = "3DES";
const char      SzSHA1[] = "SHA1";
const char      SzSHA_1[] = "SHA-1";
const char      SzMD5[] = "MD5";
const char      SzSkipjack[] = "SKIPJACK";
static char     RgchUnknown[256];
static char     Rgch[256];

// encryption bits
const DWORD     cdwBits_3DES =          3 * 56;
const DWORD     cdwBits_RC2_128bit =    128;
const DWORD     cdwBits_RC2_64bit =     64;
const DWORD     cdwBits_DES =           56;
const DWORD     cdwBits_RC2_40bit =     40;
// signing
const DWORD     cdwBits_SHA1RSA =       160;
const DWORD     cdwBits_OIWSEC_sha1 =   160;
const DWORD     cdwBits_MD5 =           128;

#define         flEncryption   1
#define         flSigning   2
#define         flOther     3

struct {
    DWORD       dwFlags;
    char *      pszObjId;       // OID for the alg
    DWORD       cbData;         // size of parameters
    const BYTE * pbData;
    DWORD       dwBits;         // size in bits
    const char * szCSPAlgName;
    const char * szAlgName;      // Name of algorithm
} const RgAlgsDesc[] = {
    {flEncryption,  szOID_RSA_DES_EDE3_CBC,     0,                      NULL,
        cdwBits_3DES,       Sz3DES,     Sz3DES},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_128bit),  RgbRc2_128bit,
        cdwBits_RC2_128bit, SzRc2,      SzRc2_128},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_64bit),   RgbRc2_64bit,
        cdwBits_RC2_64bit,  SzRc2,      SzRc2_64},
    {flEncryption,  szOID_OIWSEC_desCBC,        0,                      NULL,
        cdwBits_DES,        SzDES,      SzDES},
    {flEncryption,  szOID_RSA_RC2CBC,           sizeof(RgbRc2_40bit),   RgbRc2_40bit,
        cdwBits_RC2_40bit,  SzRc2,      SzRc2_40},
    {flEncryption,  szOID_INFOSEC_mosaicConfidentiality, 0,             NULL,
        80,                 SzSkipjack, SzSkipjack},
    {flSigning,     szOID_OIWSEC_sha1,          0,                      NULL,
        cdwBits_OIWSEC_sha1,SzSHA_1,    SzSHA1},
    {flSigning,     szOID_RSA_MD5,              0,                      NULL,
        cdwBits_MD5,    SzMD5,          SzMD5},
    {flOther,       szOID_RSA_preferSignedData, 0,                      NULL,
        0,              NULL,           NULL}
};
const DWORD CEncAlgs = sizeof(RgAlgsDesc)/sizeof(RgAlgsDesc[0]);
const int   ISignDef = 5;            // Must be updated whend RgAlgsDesc modified
const int   IRC240 = 4;


HRESULT GetAlgorithmsFromCert(PCCERT_CONTEXT pcCert, BOOL * rgfShow, ULONG CEncAlgs) {
    HCRYPTPROV              hprov;
    PCRYPT_KEY_PROV_INFO    pkeyinfo = NULL;
    LPWSTR                  pwszContainer = NULL;
    LPWSTR                  pwszProvName = NULL;    // use default provider
    DWORD                   dwProvType = PROV_RSA_FULL;
    HRESULT                 hr = S_OK;
    ULONG                   f;
    BOOL                    fRetried = FALSE;
    ULONG                   i2;
    ULONG                   cb;

    if (pcCert) {
        cb = 0;
        f = CertGetCertificateContextProperty(pcCert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cb);
        if (cb) {
            if (!MemAlloc((LPVOID *) &pkeyinfo, cb)) {
                hr = E_OUTOFMEMORY;
                goto err;
            }

            f = CertGetCertificateContextProperty(pcCert, CERT_KEY_PROV_INFO_PROP_ID, pkeyinfo, &cb);
            Assert(f);
            pwszProvName = pkeyinfo->pwszProvName;
            dwProvType = pkeyinfo->dwProvType;
            pwszContainer = pkeyinfo->pwszContainerName;
        } // else cert doesn't specify provider.  Use default provider.
    } // else use default provider

TryEnhanced:
    f = CRYPT_ACQUIRE_CONTEXT(&hprov, pwszContainer, pwszProvName, dwProvType, 0);
#ifdef DEBUG
    {
        DWORD       dw = GetLastError();
    }
#endif // DEBUG
    if (f) {
        DWORD               cbMax;
        PROV_ENUMALGS *     pbData = NULL;

        cbMax = 0;
        CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

        if ((cbMax == 0) || !MemAlloc((LPVOID *) &pbData, cbMax)) {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cb = cbMax;
        f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
        Assert(f);

        do {
            for (i2 = 0; i2 < CEncAlgs - 1; i2++) {
                if ((strcmp(pbData->szName, RgAlgsDesc[i2].szCSPAlgName) == 0) &&
                    (pbData->dwBitLen == RgAlgsDesc[i2].dwBits)) {
                    rgfShow[i2] = TRUE;
                    break;
                }
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE) pbData, &cb, 0);
        } while (f);

        CryptReleaseContext(hprov, 0);

        SafeMemFree(pbData);

        //
        //  Some providers are really crazy, they have a base and an enhanced provider
        //      and these providers do not do the same set of algorithms.  THis means
        //      that we need to enumerate all of the different algorithms when we
        //      are looking at these providers.  We have the "exhaustive" set of
        //      providers at this point in time.
        //
        
        if (!fRetried) {
            fRetried = TRUE;
#ifndef WIN16
            if (! pwszProvName || (StrCmpW(pwszProvName, MS_DEF_PROV_W) == NULL)) {
                pwszProvName = MS_ENHANCED_PROV_W;
                goto TryEnhanced;
            }
        
            if (StrCmpW(pwszProvName, MS_DEF_DSS_DH_PROV_W) == 0) {
                pwszProvName = MS_ENH_DSS_DH_PROV_W;
                goto TryEnhanced;
            }

            if (StrCmpW(pwszProvName, MS_ENHANCED_PROV_W) == NULL) {
                pwszProvName = MS_DEF_PROV_W;
                goto TryEnhanced;
            }

            if (StrCmpW(pwszProvName, MS_ENH_DSS_DH_PROV_W) == NULL) {
                pwszProvName = MS_DEF_DSS_DH_PROV_W;
                goto TryEnhanced;
            }
#else
            if (! pwszProvName || (wcscmp(pwszProvName, MS_DEF_PROV_A) == NULL)) {
                pwszProvName = MS_ENHANCED_PROV_A;
                goto TryEnhanced;
            }

#endif
        }
    }

    SafeMemFree(pkeyinfo);

    //
    //  If we are looking at diffie-hellman certificates, then we must remove DES
    //  from the list as there is no support in the core code.
    //
    
    if (dwProvType == PROV_DSS_DH) {
        for (i2=0; i2<CEncAlgs; i2++) {
            if (RgAlgsDesc[i2].pszObjId == SzDES) {
                rgfShow[i2] = FALSE;
                break;
            }
        }
    }

err:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapsToDlg(LPBYTE pbSymCaps, DWORD cbSymCaps, DWORD cCerts,
                                 PCCERT_CONTEXT * rgCerts, HWND hwnd, DWORD idEncAlgs,
                                 DWORD idSignAlgs, DWORD idBlob)
{
    DWORD                       cb;
    BOOL                        f;
    HRESULT                     hr = E_FAIL;
    DWORD                       i;
    WPARAM                      j;
    int                         iSignDef = -1;
    int                         iEncDef = -1;
    DWORD                       i2;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;
    CHAR                        rgch[100];
    BOOL                        rgfShow[CEncAlgs] = {0};

    if (cbSymCaps != 0) {

        if ((hr = HrDecodeObject(pbSymCaps, cbSymCaps, PKCS_SMIME_CAPABILITIES,
          CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
            goto err;
        }

        Assert(pcaps);

        //
        //  Filter the list of capabilities passed in by the list of items that
        //  we already know about.  We don't display algorithms that we don't
        //  recognize.
        //

        for (i=0; i<pcaps->cCapability; i++) {
            for (i2=0; i2<CEncAlgs; i2++) {
                if ((strcmp(pcaps->rgCapability[i].pszObjId,
                            RgAlgsDesc[i2].pszObjId) == 0) &&
                    (pcaps->rgCapability[i].Parameters.cbData ==
                     RgAlgsDesc[i2].cbData) &&
                    (memcmp(pcaps->rgCapability[i].Parameters.pbData,
                            RgAlgsDesc[i2].pbData, RgAlgsDesc[i2].cbData) == 0)) {
                    rgfShow[i2] = TRUE;
                    if ((RgAlgsDesc[i2].dwFlags == flEncryption) && (iEncDef == -1)) {
                        iEncDef = i2;
                    }
                    else if ((RgAlgsDesc[i2].dwFlags == flSigning) && (iSignDef == -1)) {
                        iSignDef = i2;
                    }
                    break;
                }
            }
            if (i2 == CEncAlgs) {
                pcaps->rgCapability[i].pszObjId = NULL;
            }
        }
    }

    //
    //  For each certificate, we now want to find the list of capabilities
    //  provided by each of the CSP providers
    //

    for (i = 0; i < cCerts; i++) {
        hr = GetAlgorithmsFromCert(rgCerts[i], rgfShow, CEncAlgs);
    }

    // If there were no cert, get the algorithms from the default provider.
    if (! cCerts) {
        hr = GetAlgorithmsFromCert(NULL, rgfShow, CEncAlgs);
    }

    //
    //  Now populate the combo box with the encryption algrithms if we have
    //  a possiblity todo this.
    //

    if (idEncAlgs != 0) {
        SendDlgItemMessageA(hwnd, idEncAlgs, CB_RESETCONTENT, 0, 0);
        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flEncryption)) {
                j = SendDlgItemMessageA(hwnd, idEncAlgs, CB_ADDSTRING,
                                        0, (LPARAM) RgAlgsDesc[i].szAlgName);
                SendDlgItemMessageA(hwnd, idEncAlgs, CB_SETITEMDATA, j, i);
                if (iEncDef == -1) {
                    iEncDef = i;
                }
            }
        }

        if (iEncDef != (DWORD)-1) {
            SendDlgItemMessageA(hwnd, idEncAlgs, CB_SELECTSTRING,
                                (WPARAM) -1, (LPARAM) RgAlgsDesc[iEncDef].szAlgName);
        }
    }

    //
    //  Now populate the Signature Alg combo box
    //

    if (idSignAlgs != 0) {
        SendDlgItemMessageA(hwnd, idSignAlgs, CB_RESETCONTENT, 0, 0);
        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flSigning)) {
                j = SendDlgItemMessageA(hwnd, idSignAlgs, CB_ADDSTRING,
                                        0, (LPARAM) RgAlgsDesc[i].szAlgName);
                SendDlgItemMessageA(hwnd, idSignAlgs, CB_SETITEMDATA, j, i);
                if (iSignDef == -1) {
                    iSignDef = i;
                }
            }
        }

        if (iSignDef != (DWORD)-1) {
            SendDlgItemMessageA(hwnd, idSignAlgs, CB_SELECTSTRING,
                                (WPARAM) -1, (LPARAM) RgAlgsDesc[iSignDef].szAlgName);
        }
    }

    //
    //  Finally, lets play with the question of perference for signed blob data
    //

    if (idBlob != 0) {
        SendDlgItemMessageA(hwnd, idBlob, BM_SETCHECK, rgfShow[CEncAlgs-1], 0);
    }

    hr = S_OK;
err:
    SafeMemFree(pcaps);
    return hr;
}



MIMEOLEAPI MimeOleSMimeCapsFromDlg(HWND hwnd, DWORD idEncAlgs, DWORD idSignAlgs,
                                   DWORD idBlob, LPBYTE pbSymCaps, DWORD * pcbSymCaps)
{
    DWORD       c;
    CRYPT_SMIME_CAPABILITIES     caps;
    BOOL        f;
    int         fBlob = FALSE;
    DWORD       i;
    DWORD       i1;
    DWORD       j;
    DWORD       iEncDef = (DWORD) -1;
    DWORD       iSignDef = (DWORD) -1;
    CRYPT_SMIME_CAPABILITY      rgcaps[CEncAlgs];
    BOOL        rgfShow[CEncAlgs] = {0};

    //
    //  If we were passed a combo box for the encryption alg, then we pull
    //  the default information out of it.
    //
    //  Additionally we are going to pull out information about which algs
    //  are currently supported by the CSPs involved in the process.  This
    //  will have been populated from a previous call to SymCapsToDlg
    //

    if (idEncAlgs != 0) {
        i = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETCURSEL, 0, 0);
        iEncDef = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETITEMDATA, i, 0);

        c = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            i1 = (DWORD) SendDlgItemMessageA(hwnd, idEncAlgs, CB_GETITEMDATA, i, 0);
            if (i1 < CEncAlgs) {
                rgfShow[i1] = TRUE;
            }
        }
    }

    //
    //  If we were passed a combo box for the signing algs, then we pull the
    //  default information out of it.
    //
    //  Additionally, we are going to pull out information about which algs
    //  are currently supported by the CSPs involved in the in process.  This
    //  will have been populated from a previous call to  SymCapsToDlg.
    //

    if (idSignAlgs != 0) {
        i = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETCURSEL, 0, 0);
        iSignDef = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETITEMDATA, i, 0);

        c = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETCOUNT, 0, 0);
        for (i=0; i<c; i++) {
            i1 = (DWORD) SendDlgItemMessageA(hwnd, idSignAlgs, CB_GETITEMDATA, i, 0);
            if (i1 < CEncAlgs) {
                rgfShow[i1] = TRUE;
            }
        }
    }

    j = 0;
    if (idEncAlgs != 0) {
        //
        //  If we have a default encryuption alg, then put it first
        //

        if (iEncDef != -1) {
            rgcaps[j].pszObjId = RgAlgsDesc[iEncDef].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[iEncDef].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[iEncDef].pbData;
            j += 1;
        }

        //
        //  We need to build the list of encryption algs supported, if we have
        //  a dialog box item, then use that to build the list.
        //

        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flEncryption) && (iEncDef != i)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    }
    else {
        //
        //  No dialog, so we are just going to assume that only 40-bit RC2 is
        //      supported
        //

        rgcaps[j].pszObjId = szOID_RSA_RC2CBC;
        rgcaps[j].Parameters.cbData = sizeof(RgbRc2_40bit);
        rgcaps[j].Parameters.pbData = (LPBYTE) RgbRc2_40bit;
        j += 1;
    }

    if (idSignAlgs != 0) {
        if (iSignDef != -1) {
            rgcaps[j].pszObjId = RgAlgsDesc[iSignDef].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[iSignDef].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[iSignDef].pbData;
            j += 1;
        }

        for (i=0; i<CEncAlgs; i++) {
            if (rgfShow[i] && (RgAlgsDesc[i].dwFlags == flSigning) && (iSignDef != i)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    }
    else {
        //
        //  No dialog, so we are just going to assume that only SHA-1 is
        //      supported
        //

        rgcaps[j].pszObjId = szOID_OIWSEC_sha1RSASign;
        rgcaps[j].Parameters.cbData = 0;
        rgcaps[j].Parameters.pbData = NULL;
        j += 1;
    }

    //
    // If we were passed in an ID blob item, then we should see if we are
    //  going to force a send in blob format
    //

    if (idBlob != 0) {
        if (SendDlgItemMessageA(hwnd, idBlob, BM_GETCHECK, 0, 0) == 1) {
            rgcaps[j].pszObjId = RgAlgsDesc[CEncAlgs-1].pszObjId;
            rgcaps[j].Parameters.cbData = RgAlgsDesc[CEncAlgs-1].cbData;
            rgcaps[j].Parameters.pbData = (LPBYTE) RgAlgsDesc[CEncAlgs-1].pbData;
            j += 1;
        }
    }

    //
    //  Now actually encrypt the data and return the result.  Note that we
    //  don't allocate space but use the space allocated by our caller
    //

    caps.cCapability = j;
    caps.rgCapability = rgcaps;

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                          &caps, pbSymCaps, pcbSymCaps);
    return f ? S_OK : E_FAIL;
}



static HRESULT SymCapAdd(LPBYTE pbSymCaps, DWORD cbSymCaps, BYTE * rgbFilter)
{
    DWORD               cb;
    BOOL                f;
    HRESULT             hr;
    DWORD               i;
    DWORD               i2;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    //
    //  Take the sym caps and decode it
    //

    if ((hr = HrDecodeObject(pbSymCaps, cbSymCaps, PKCS_SMIME_CAPABILITIES,
      CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
        goto err;
    }

    Assert(pcaps);

    //
    //  Filter the list of capabilities passed in by the list of items that
    //  are on the list.
    //

    for (i2=0, f = TRUE; i2<CEncAlgs; i2++) {
        if (rgbFilter[i2] == FALSE) {
            f = FALSE;
            continue;
        }

        for (i=0; i<pcaps->cCapability; i++) {
            if ((strcmp(pcaps->rgCapability[i].pszObjId,
                        RgAlgsDesc[i2].pszObjId) == 0) &&
                (pcaps->rgCapability[i].Parameters.cbData ==
                 RgAlgsDesc[i2].cbData) &&
                (memcmp(pcaps->rgCapability[i].Parameters.pbData,
                        RgAlgsDesc[i2].pbData, RgAlgsDesc[i2].cbData) == 0)) {
                break;
            }
        }
        if (i == pcaps->cCapability) {
            rgbFilter[i2] = FALSE;
            f = FALSE;
        }
    }

    hr =  f ? S_OK : S_FALSE;

err:
    SafeMemFree(pcaps);
    return hr;
}


////    SymCapInit
//

MIMEOLEAPI MimeOleSMimeCapInit(LPBYTE pbSymCapSender, DWORD cbSymCapSender, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    DWORD       i;
    LPBYTE      pb = NULL;

    if (!MemAlloc((LPVOID *) &pb, CEncAlgs * sizeof(BYTE))) {
        return E_OUTOFMEMORY;
    }

    if (pbSymCapSender && cbSymCapSender) {
        for (i=0; i<CEncAlgs; i++) pb[i] = TRUE;

        hr = SymCapAdd(pbSymCapSender, cbSymCapSender, pb);
        if (FAILED(hr)) {
            MemFree(pb);
            goto exit;
        }
        // Assert(hr == S_OK);
    } else {
        HCRYPTPROV              hprov = NULL;
        LPTSTR                  pszProvName = NULL;    // use default provider
        DWORD                   dwProvType = PROV_RSA_FULL;
        BOOL                    f;
        ULONG                   cb;

        // No sender symcap specified.  Init it to the highest available.
        for (i = 0; i < CEncAlgs; i++) {        // init to all false
            pb[i] = FALSE;
        }

TryEnhanced:
        // Open the provider
        hr = E_OUTOFMEMORY;
        f = CryptAcquireContext(&hprov, NULL, pszProvName, dwProvType, CRYPT_VERIFYCONTEXT);
        if (f) {
            DWORD               cbMax;
            PROV_ENUMALGS *     pbData = NULL;

            hr = S_OK;
            cbMax = 0;
            CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

            if ((cbMax == 0) || ! MemAlloc((LPVOID *)&pbData, cbMax)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
            Assert(f);

            do {
                //  Walk through the list of all known S/MIME caps looking to see if we
                //  have a match.
                for (i = 0; i < CEncAlgs; i++) {
                    // Assume if we get the correct algorithm name, that the CAPI
                    // bitLen parameter is a max value and we will support all smaller ones
                    // as well.
                    if (lstrcmpi(pbData->szName, RgAlgsDesc[i].szCSPAlgName) == 0) {
                        if (pbData->dwBitLen >= RgAlgsDesc[i].dwBits) {
                            pb[i] = TRUE;   // We support this one
                        }
                    }
                }

                cb = cbMax;
                f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, 0);
            } while (f);

            CryptReleaseContext(hprov, 0);

            SafeMemFree(pbData);

            // Try the enhanced provider?
            if (! pszProvName || (lstrcmpi(pszProvName, MS_DEF_PROV) == NULL)) {
                pszProvName = MS_ENHANCED_PROV;
                goto TryEnhanced;
            }
        }
    }

    *ppv = pb;

exit:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapAddSMimeCap(LPBYTE pbSymCap, DWORD cbSymCap, LPVOID pv)
{
    if ((pbSymCap != NULL) && (cbSymCap > 0)) {
        return SymCapAdd(pbSymCap, cbSymCap, (LPBYTE) pv);
    }
    return E_INVALIDARG;
}

MIMEOLEAPI MimeOleSMimeCapAddCert(LPBYTE /*pbCert*/, DWORD /*cbCert*/,
                               BOOL fParanoid, LPVOID pv)
{
    BOOL        f;
    DWORD       i;
    DWORD       iSkip;
    LPBYTE      pb = (LPBYTE) pv;

    //
    //  If we are paranoid, then we only allow 3-DES
    //  Otherwise we only allow RC2 40-bit
    //

    if (fParanoid) {
        iSkip = 0;
    }
    else {
        iSkip = IRC240;
    }

    for (i=0, f = TRUE; i<CEncAlgs; i++) {
        if ((i != iSkip) && (RgAlgsDesc[i].dwFlags == flEncryption)) {
            pb[i] &= 0;
            f = pb[i];
        }
    }

    return f ? S_OK : S_FALSE;
}

HRESULT GetResult(DWORD iTarget, LPBYTE pb, LPBYTE pbEncode, DWORD * pcbEncode,
                  DWORD * pdw)
{
    CRYPT_SMIME_CAPABILITY      cap;
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL        f = FALSE;
    int         i;

    //
    //  Look for the first possible answer to the question
    //

    for (i=0; i<CEncAlgs; i++) {
        if (RgAlgsDesc[i].dwFlags == iTarget) {
            break;
        }
    }

    Assert(i != CEncAlgs);

    //
    //  Look for the highest possible alg to send data with
    //

    for (; i<CEncAlgs; i++) {
        if ((RgAlgsDesc[i].dwFlags != iTarget) || pb[i]) {
            break;
        }
    }

    //
    //  We must not have run off the end of the array, all hash algs come after encryption
    //  algs
    //

    Assert( i < CEncAlgs );

    //
    //  If did not find an algorithm, return the appropriate error
    //

    if (RgAlgsDesc[i].dwFlags != iTarget) {
        *pcbEncode = 0;
        if (pdw != NULL) {
            *pdw = 0;
        }
        return S_FALSE;
    }

    //
    //  Build the S/MIME Capability string with just this one item in it
    //

    caps.cCapability = 1;
    caps.rgCapability = &cap;

    cap.pszObjId = RgAlgsDesc[i].pszObjId;
    cap.Parameters.cbData = RgAlgsDesc[i].cbData;
    cap.Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;

    //
    //  Determine the "extra" parameter.  For encryption it is the
    //  bit size of the algorithm.  For Signing it is weither we should be doing
    //  blob signed
    //

    if (pdw != NULL) {
        if (iTarget == 1) {
            *pdw = RgAlgsDesc[i].dwBits;
        }
        else {
            Assert(iTarget == 2);
            *pdw = pb[CEncAlgs-1];
        }
    }

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
                          &caps, pbEncode, pcbEncode);
#ifndef WIN16
    if (!f && (::GetLastError() != ERROR_MORE_DATA)) {
        return E_FAIL;
    }
#endif
    return f ? S_OK : S_FALSE;
}

MIMEOLEAPI MimeOleSMimeCapGetEncAlg(LPVOID pv, LPBYTE pbEncode, DWORD * pcbEncode,
                                    DWORD * pdwBits)
{
    return GetResult(1, (LPBYTE) pv, pbEncode, pcbEncode, pdwBits);
}

MIMEOLEAPI MimeOleSMimeCapGetHashAlg(LPVOID pv, LPBYTE pbEncode, DWORD * pcbEncode,
                                     DWORD * pfBlobSign)
{
    return GetResult(2, (LPBYTE) pv, pbEncode, pcbEncode, pfBlobSign);
}

MIMEOLEAPI MimeOleSMimeCapRelease(LPVOID pv)
{
    MemFree(pv);
    return S_OK;
}

MIMEOLEAPI MimeOleAlgNameFromSMimeCap(LPBYTE pbEncode, DWORD cbEncode,
                                      LPCSTR * ppszProtocol)
{
    DWORD                       cb = 0;
    BOOL                        f;
    HRESULT                     hr;
    DWORD                       i;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    //
    //  Decode the S/MIME caps which is passed in, allocate space to hold
    //  the resulting value
    //

    hr = HrDecodeObject(pbEncode, cbEncode, PKCS_SMIME_CAPABILITIES, CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps);
    if (FAILED(hr) || NULL == pcaps)
    {
        if (hr != E_OUTOFMEMORY) 
        {
            if (RgchUnknown[0] == 0) 
            {
                LoadStringA(g_hLocRes, IDS_UNKNOWN_ALG, RgchUnknown, sizeof(RgchUnknown));
            }
            *ppszProtocol = RgchUnknown;
            return S_FALSE;
        } 
        else 
        {
            return E_OUTOFMEMORY;
        }
    }

    Assert(pcaps);
    Assert(pcaps->cCapability == 1);

    //
    //  Walk through the list of all known S/MIME caps looking to see if we
    //  have a match.   If so then setup the return answer.
    //

    for (i=0; i<CEncAlgs; i++) {
        if ((strcmp(pcaps->rgCapability[0].pszObjId, RgAlgsDesc[i].pszObjId) == 0) &&
            (pcaps->rgCapability[0].Parameters.cbData == RgAlgsDesc[i].cbData) &&
            (memcmp(pcaps->rgCapability[0].Parameters.pbData,
                    RgAlgsDesc[i].pbData, RgAlgsDesc[i].cbData) == 0)) {
            *ppszProtocol = RgAlgsDesc[i].szAlgName;
            break;
        }
    }

    //
    //  We did not find a match.  So now we need to assume that we might have been
    //  passed a Parameter rather than an S/MIME cap.  So try decoding as a parameter
    //

    if (i== CEncAlgs) {
        if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
            PCRYPT_RC2_CBC_PARAMETERS   prc2;
            prc2 = (PCRYPT_RC2_CBC_PARAMETERS)
                PVDecodeObject(pcaps->rgCapability[0].Parameters.pbData,
                                pcaps->rgCapability[0].Parameters.cbData,
                                PKCS_RC2_CBC_PARAMETERS, NULL);
            if (prc2 != NULL) {
                if (prc2->dwVersion == CRYPT_RC2_40BIT_VERSION) {
                    *ppszProtocol = SzRc2_40;
                }
                else if (prc2->dwVersion == CRYPT_RC2_64BIT_VERSION) {
                    *ppszProtocol = SzRc2_64;
                }
                else if (prc2->dwVersion == CRYPT_RC2_128BIT_VERSION) {
                    *ppszProtocol = SzRc2_128;
                }
                else {
                    *ppszProtocol = SzRc2;
                }
                SafeMemFree(prc2);  // Must be freed prior to pcaps
            }
            else {
                *ppszProtocol = SzRc2;
            }
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
            *ppszProtocol = Sz3DES;
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_OIWSEC_desCBC) == 0) {
            *ppszProtocol = SzDES;
        }
        else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
            *ppszProtocol = SzSkipjack;
        }
        else {
            strcpy(Rgch, pcaps->rgCapability[0].pszObjId);
            *ppszProtocol = Rgch;
        }
        MemFree(pcaps);
        return S_FALSE;
    }

    MemFree(pcaps);
    return S_OK;
}


MIMEOLEAPI MimeOleAlgStrengthFromSMimeCap(LPBYTE pbEncode, DWORD cbEncode, BOOL fEncryption,
  DWORD * pdwStrength)
{
    DWORD                       cb = 0;
    BOOL                        f;
    HRESULT                     hr = S_OK;
    DWORD                       i;
    PCRYPT_SMIME_CAPABILITIES   pcaps = NULL;

    // Init return value
    *pdwStrength = 0;

    if (pbEncode && cbEncode) {
        //
        //  Decode the S/MIME caps which is passed in, allocate space to hold
        //  the resulting value
        //

        if ((hr = HrDecodeObject(pbEncode, cbEncode, PKCS_SMIME_CAPABILITIES,
          CRYPT_DECODE_NOCOPY_FLAG, &cb, (LPVOID *)&pcaps)) || ! pcaps) {
             goto exit;;
        }

        Assert(pcaps);
        Assert(pcaps->cCapability == 1);

        //
        //  Walk through the list of all known S/MIME caps looking to see if we
        //  have a match.   If so then setup the return answer.
        //

        for (i=0; i<CEncAlgs; i++) {
            if ((strcmp(pcaps->rgCapability[0].pszObjId, RgAlgsDesc[i].pszObjId) == 0) &&
                (pcaps->rgCapability[0].Parameters.cbData == RgAlgsDesc[i].cbData) &&
                (memcmp(pcaps->rgCapability[0].Parameters.pbData,
                        RgAlgsDesc[i].pbData, RgAlgsDesc[i].cbData) == 0)) {
                *pdwStrength = RgAlgsDesc[i].dwBits;
                break;
            }
        }

        //
        //  We did not find a match.  So now we need to assume that we might have been
        //  passed a Parameter rather than an S/MIME cap.  So try decoding as a parameter
        //

        if (i== CEncAlgs) {
            if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_RC2CBC) == 0) {
                PCRYPT_RC2_CBC_PARAMETERS   prc2;
                prc2 = (PCRYPT_RC2_CBC_PARAMETERS)
                    PVDecodeObject(pcaps->rgCapability[0].Parameters.pbData,
                                    pcaps->rgCapability[0].Parameters.cbData,
                                    PKCS_RC2_CBC_PARAMETERS, NULL);
                if (prc2 != NULL) {
                    if (prc2->dwVersion == CRYPT_RC2_40BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_40bit;
                    }
                    else if (prc2->dwVersion == CRYPT_RC2_64BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_64bit;
                    }
                    else if (prc2->dwVersion == CRYPT_RC2_128BIT_VERSION) {
                        *pdwStrength = cdwBits_RC2_128bit;
                    }
                    else {
                        *pdwStrength = cdwBits_RC2_40bit;
                    }
                    SafeMemFree(prc2);  // Must be freed prior to pcaps
                }
                else {
                    *pdwStrength = cdwBits_RC2_40bit;
                }
            }

            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_RSA_DES_EDE3_CBC) == 0) {
                *pdwStrength = cdwBits_3DES;
            }
            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_OIWSEC_desCBC) == 0) {
                *pdwStrength = cdwBits_DES;
            }
            else if (strcmp(pcaps->rgCapability[0].pszObjId, szOID_INFOSEC_mosaicConfidentiality) == 0) {
                *pdwStrength = 80;
            }
            else {
                *pdwStrength = 0;
            }
            MemFree(pcaps);
            return S_FALSE;
        }

        MemFree(pcaps);
    } else {
        // No SMimeCap passed in, find the maximum supported by this configuration
        HCRYPTPROV              hprov = NULL;
        LPTSTR                  pszProvName = NULL;    // use default provider
        DWORD                   dwProvType = PROV_RSA_FULL;

TryEnhanced:
        f = CryptAcquireContext(&hprov, NULL, pszProvName, dwProvType, CRYPT_VERIFYCONTEXT);
        if (f) {
            DWORD               cbMax;
            PROV_ENUMALGS *     pbData = NULL;

            cbMax = 0;
            CryptGetProvParam(hprov, PP_ENUMALGS, NULL, &cbMax, CRYPT_FIRST);

            if ((cbMax == 0) || ! MemAlloc((LPVOID *)&pbData, cbMax)) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            cb = cbMax;
            f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, CRYPT_FIRST);
            Assert(f);

            do {
                //  Walk through the list of all known S/MIME caps looking to see if we
                //  have a match.
                for (i = 0; i < CEncAlgs; i++) {
                    if ((RgAlgsDesc[i].dwFlags == (DWORD)(fEncryption ? flEncryption : flSigning)) && lstrcmpi(pbData->szName, RgAlgsDesc[i].szCSPAlgName) == 0) {
                        if (pbData->dwBitLen > *pdwStrength) {
                            *pdwStrength = pbData->dwBitLen;
                        }
                    }
                }

                cb = cbMax;
                f = CryptGetProvParam(hprov, PP_ENUMALGS, (LPBYTE)pbData, &cb, 0);
            } while (f);

            CryptReleaseContext(hprov, 0);

            SafeMemFree(pbData);

            // Try the enhanced provider?
            if (! pszProvName || (lstrcmpi(pszProvName, MS_DEF_PROV) == NULL)) {
                pszProvName = MS_ENHANCED_PROV;
                goto TryEnhanced;
            }
        }
    }

exit:
    return(hr);
}


MIMEOLEAPI MimeOleSMimeCapsFull(LPVOID pv, BOOL fFullEncryption, BOOL fFullSigning, LPBYTE pbSymCaps, DWORD * pcbSymCaps)
{
    CRYPT_SMIME_CAPABILITIES    caps;
    BOOL                        f;
    DWORD                       i;
    DWORD                       j = 0;
    CRYPT_SMIME_CAPABILITY      rgcaps[CEncAlgs];
    LPBYTE                      rgfUse = (LPBYTE)pv;


    //
    //  We need to build the list of encryption algs supported, if we have
    //  a dialog box item, then use that to build the list.
    //
    if (fFullEncryption) {
        for (i = 0; i < CEncAlgs; i++) {
            if (rgfUse[i] && (RgAlgsDesc[i].dwFlags == flEncryption)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    } else {
        //
        //  Just assume that only 40-bit RC2 is supported
        //
        rgcaps[j].pszObjId = szOID_RSA_RC2CBC;
        rgcaps[j].Parameters.cbData = sizeof(RgbRc2_40bit);
        rgcaps[j].Parameters.pbData = (LPBYTE) RgbRc2_40bit;
        j += 1;
    }

    //
    // Now, put in the signing algorithms
    //
    if (fFullSigning) {
        for (i = 0; i < CEncAlgs; i++) {
            if (rgfUse[i] && (RgAlgsDesc[i].dwFlags == flSigning)) {
                rgcaps[j].pszObjId = RgAlgsDesc[i].pszObjId;
                rgcaps[j].Parameters.cbData = RgAlgsDesc[i].cbData;
                rgcaps[j].Parameters.pbData = (LPBYTE)RgAlgsDesc[i].pbData;
                j += 1;
            }
        }
    } else {
        //
        //  Just assume that only SHA-1 is supported
        //
        rgcaps[j].pszObjId = szOID_OIWSEC_sha1RSASign;
        rgcaps[j].Parameters.cbData = 0;
        rgcaps[j].Parameters.pbData = NULL;
        j += 1;
    }

    //
    //  Now actually encrypt the data and return the result.  Note that we
    //  don't allocate space but use the space allocated by our caller
    //

    caps.cCapability = j;
    caps.rgCapability = rgcaps;

    f = CryptEncodeObject(X509_ASN_ENCODING, PKCS_SMIME_CAPABILITIES,
      &caps, pbSymCaps, pcbSymCaps);
    return(f ? S_OK : E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smime.h ===
/*
**	s m i m e . h
**	
**	Purpose: class for cryptographically enhanced mail.
**
**  Owner:   t-erikne
**  Created: 8/27/96
**	
**	Copyright (C) Microsoft Corp. 1996-1998
*/

#ifndef __SMIME_H
#define __SMIME_H

#include <mimeole.h>

#ifndef __WINCRYPT_H__
#include "wincrypt.h"
#endif

#ifdef SMIME_V3
// #include "..\ess\essout.h"
#endif // SMIME_V3

#define szOID_INFOSEC_keyExchangeAlgorithm "2.16.840.1.101.2.1.1.22"

#include "capitype.h"
#include "cryptdbg.h"

//  WinCrypt.h helper 

#define DOUTL_SMIME     CRYPT_LEVEL

class CCAPIStm;

extern CRYPT_ENCODE_PARA       CryptEncodeAlloc;
extern CRYPT_DECODE_PARA       CryptDecodeAlloc;


#ifdef MAC
/*
**  An array of function pointers, needed because we dynalink to
**  CRYPT32.DLL.  Note that not all of the crypto functions come
**  from this DLL.  I also use functions from ADVAPI32: the CAPI 1
**  functions.  These are not represented in this table and do not
**  need to use GetProcAddress.
**  Typedefs come from capitype.h, local to our project.
*/

typedef struct tagCAPIfuncs {
    CERTENUMCERTIFICATESINSTORE             *EnumCerts;
    CERTNAMETOSTRA                          *CertNameToStr;
} CAPIfuncs, *PCAPIfuncs;
#endif // MAC


/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//

typedef enum {
    ENCRYPT_ITEM_TRANSPORT = 1,
    ENCRYPT_ITEM_AGREEMENT = 2,
    ENCRYPT_ITEM_MAILLIST = 3
} ENCRYPT_ITEM_TYPE;

typedef struct tagEncryptItem {
    DWORD       dwTagType;
    union {
        struct {
            BLOB                blobAlg;
            DWORD               cCert;
            PCCERT_CONTEXT *    rgpccert;
        } Transport;
        struct {
            BLOB                blobAlg;
            DWORD               cCert;
            PCCERT_CONTEXT *    rgpccert;
            PCCERT_CONTEXT      pccertSender;
        } Agreement;
        struct {
            BLOB                blobAlg;        // AlgId + AuxInfo
            BLOB                blobKeyId;      // Data_Blob KeyID
            FILETIME            date;           // Date
            BLOB                blobOctet;      // Other attribute (oid, any)
#ifdef SMIME_V3
            HCRYPTPROV          hprov;          // hprov
            HCRYPTKEY           hkey;           // hkey
#else // !SMIME_V3
            BLOB                blobKeyMaterial;
#endif // SMIME_V3
        } MailList;
    };
} EncryptItem;

typedef struct tagEncryptItems {
    DWORD               cItems;
    EncryptItem *       rgItems;
} EncryptItems;

//
// Notes about the [directions]
// [sgn] - signing -- in for sign ops
// [ver] - verification -- out for sign ops
// [enc] - encryption -- in for encrypt ops
// [dec] - decryption -- out for encrypt ops
// [in] = [sgn,enc]
// [out] = [ver,dec]
//

typedef struct {
    DWORD             ulValidity;         // Validity bits for each signature
    PCCERT_CONTEXT    pccert;             // Signer certificate
    BLOB              blobHashAlg;        // Hash algorithm for signer
    BLOB              blobAuth;           // authenticated attributes
    BLOB              blobUnauth;         // unauthenticated attributes
#ifdef SMIME_V3
    BLOB              blobReceipt;        // Receipt to be returned
    BLOB              blobHash;           // Hash of message 
#endif // SMIME_V3
} SignerData;

class CSECURITY_LAYER_DATA : public IUnknown
{
friend class CSMime;        // Allow CSMime access to our private data
friend class CCAPIStm;      // Allow CCAPIStm access to our private data
public:
    CSECURITY_LAYER_DATA(void);
    ~CSECURITY_LAYER_DATA(void);

    // --------------------------------------------------------------------
    // IUnknown
    // --------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //private:     // private data
    DWORD               m_cRef;
    DWORD               m_dwMsgEnhancement;     // sign?  encrypt?
    BOOL                m_fCertInLayer;         // TRUE if there is a cert included in this layer

    //  The following elements exist one for each signer on the current layer
    DWORD               m_cSigners;             // Count of signers
    SignerData *        m_rgSigners;            // Signer Data

    //  The following items exist to encrypt the current layer
    DWORD               m_cEncryptItems;        // Encrypt Item count
#ifdef SMIME_V3
    CRYPT_ALGORITHM_IDENTIFIER m_ContentEncryptAlgorithm; // Content AlgId
    void *              m_pvEncryptAuxInfo;     // Aux info
    CMSG_RECIPIENT_ENCODE_INFO * m_rgRecipientInfo; // Array of Recpient Infos
    CRYPT_DATA_BLOB     m_blobUnprotectAttrs;   // Unprotected attributes
    HCERTSTORE          m_hstoreEncrypt;        // Encrypt cert store
#else // !SMIME_V3
    EncryptItem *       m_rgEncryptItems;       // count of Encrypt Items
#endif // SMIME_V3

    //  The following items exists for a decrypted message
    DWORD               m_ulDecValidity;
    BLOB                m_blobDecAlg;           // Decryption Algorithm
    PCCERT_CONTEXT      m_pccertDecrypt;        // Decryption Certificate

    //  These are items common to both encryption and signing
    HCERTSTORE          m_hcertstor;            // message cert store
                                                // Cert Bag for signing
                                                // Originator Info for encryption
    //

    CSECURITY_LAYER_DATA * m_psldInner;         // down link
    CSECURITY_LAYER_DATA * m_psldOuter;         // up link
};
typedef class CSECURITY_LAYER_DATA SECURITY_LAYER_DATA;
typedef SECURITY_LAYER_DATA * PSECURITY_LAYER_DATA;


// -------------------------------------------------------------------
// SMIMEINFO:
//  bidirectional communication struct for passing parameter
//  info to/from the en/decode functions
//
//  dwMsgEnhancement    [inout]
//  fCertWithMsg        [ver]
//  ulMsgValidity       [out]
//  ietRequested        [in]
// -------------------------------------------------------------------
struct SMIMEINFOtag {       // si
    DWORD           dwMsgEnhancement;
    PSECURITY_LAYER_DATA psldLayers;        // outermost layer
    PSECURITY_LAYER_DATA psldEncrypt;       // encryption layer
    PSECURITY_LAYER_DATA psldInner;         // innermost layer
    ULONG           cStores;                // size of rgStores
    HCERTSTORE *    rgStores;               // array of cert stores
    BOOL            fCertWithMsg;
    ULONG           ulMsgValidity;
    ENCODINGTYPE    ietRequested;
    HCRYPTPROV      hProv;
#ifdef SMIME_V3
    LPSTR           pszInnerContent;        // Inner content (NULL ->> id-data)
    DWORD           cbInnerContent;         // Inner content size if != id-data
    LPWSTR          pwszKeyPrompt;          // Key password prompt
#endif // SMIME_V3
};
typedef struct SMIMEINFOtag SMIMEINFO;
typedef SMIMEINFO *PSMIMEINFO;
typedef const SMIMEINFO *PCSMIMEINFO;


/////////////////////////////////////////////////////////////////////////////
//
// Class begins
//

class CSMime :
    public IMimeSecurity
{
public:
    //
    // ctor and dtor
    //
    CSMime(void);
    ~CSMime();

    //
    // IUnknown methods
    //
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IMimeSecurity methods
    //
    STDMETHODIMP InitNew();
    STDMETHODIMP CheckInit();

    STDMETHODIMP EncodeMessage(IMimeMessageTree *const pTree, DWORD dwFlags);
    STDMETHODIMP DecodeMessage(IMimeMessageTree *const pTree, DWORD dwFlags);
    STDMETHODIMP EncodeBody(IMimeMessageTree *const pTree, HBODY hEncodeRoot, DWORD dwFlags);
    STDMETHODIMP DecodeBody(IMimeMessageTree *const pTree, HBODY hDecodeRoot, DWORD dwFlags);

    STDMETHODIMP EnumCertificates(HCAPICERTSTORE hc, DWORD dwUsage, PCX509CERT pPrev, PCX509CERT *pCert);
    STDMETHODIMP GetCertificateName(const PCX509CERT pX509Cert, const CERTNAMETYPE cn, LPSTR *ppszName);
    STDMETHODIMP GetMessageType(const HWND hwndParent, IMimeBody *const pBody, DWORD *const pdwSecType);

    STDMETHODIMP GetCertData(const PCX509CERT pX509Cert, const CERTDATAID dataid, LPPROPVARIANT pValue);

    //  Other methods
    HRESULT     EncodeMessage2(IMimeMessageTree * const pTree, DWORD dwFlags,
                               HWND hwnd);
    HRESULT     DecodeMessage2(IMimeMessageTree * const pTree, DWORD dwFlags,
                               HWND hwnd, IMimeSecurityCallback * pCallback);
    HRESULT     EncodeBody2(IMimeMessageTree *const pTree, HBODY hEncodeRoot,
                            DWORD dwFlags, HWND hwnd);
    HRESULT     DecodeBody2(IMimeMessageTree *const pTree, HBODY hDecodeRoot,
                            DWORD dwFlags, SMIMEINFO * psiOuterOp, HWND hwnd,
                            IMimeSecurityCallback * pCallback);

    //
    // Implementation methods
    //
    static  void    UnloadAll(void);
    static  HRESULT HrGetCertsFromThumbprints(THUMBBLOB *const rgThumbprint, X509CERTRESULT *const pResults);
    static  HRESULT StaticGetMessageType(HWND hwndParent, IMimeBody *const pBody, DWORD *const pdwSecType);

protected:
    static  HRESULT StaticCheckInit();

    struct CERTARRAY {
        DWORD           cCerts;
        PCCERT_CONTEXT *rgpCerts;
        };
    typedef CERTARRAY *PCERTARRAY;
    typedef const CERTARRAY *PCCERTARRAY;

    HRESULT DecodeBody      (IMimeMessageTree *const pTree, HBODY hDecodeRoot, DWORD dwFlags, SMIMEINFO * psiOuterOp);

    HRESULT HrEncodeOpaque      (SMIMEINFO *const psi, IMimeMessageTree *pTree, HBODY hEncodeRoot, IMimeBody *pEncodeRoot, LPSTREAM lpstmOut, HWND hwnd);
    HRESULT HrDecodeOpaque      (DWORD dwFlags, SMIMEINFO *const psi, IMimeBody *const pBody, IStream *const pstmOut, HWND hwnd, IMimeSecurityCallback * pCallback);
    HRESULT HrEncodeClearSigned (SMIMEINFO *const psi, IMimeMessageTree *const pTree, const HBODY hEncodeRoot, IMimeBody *const pEncodeRoot, LPSTREAM lpstmOut, BOOL fCommit, HWND hwnd);
    HRESULT HrDecodeClearSigned (DWORD dwFlags, SMIMEINFO *const psi, IMimeMessageTree *const pTree, const HBODY hData, const HBODY hSig, HWND hwnd, IMimeSecurityCallback * pCallback);

    static  BOOL    FSign(const DWORD dwAction)
                        { return BOOL(dwAction & MST_SIGN_MASK); }
    static  BOOL    FClearSign(const DWORD dwAction)
                        { return (FSign(dwAction) && !(dwAction & MST_BLOB_FLAG)); }
    static  BOOL    FEncrypt(const DWORD dwAction)
                        { return BOOL(dwAction & MST_ENCRYPT_MASK); }

    static  HRESULT HrGetNeededAddresses(const DWORD dwTypes, IMimeMessageTree *pTree, IMimeAddressTable **ppAdrTable, IMimeEnumAddressTypes **ppEnum);
    static  HRESULT HrGetCertificates(IMimeAddressTable *const pAdrTable, IMimeEnumAddressTypes *pEnum, const DWORD dwType, const BOOL fAlreadyHaveSendersCert, CERTARRAY *rgCerts);
    static  HRESULT HrGetThumbprints(IMimeEnumAddressTypes *pEnum, const ITHUMBPRINTTYPE ittType, THUMBBLOB *const rgThumbprint);
    static  HRESULT HrGenerateCertsStatus(X509CERTRESULT *pResults, IMimeAddressTable *const pAdrTable, IMimeEnumAddressTypes *const pEnum, const BOOL fIgnoreSenderError);

    HRESULT HrFindUsableCert(HCERTSTORE hCertStore, BYTE dwKeySpec, PCCERT_CONTEXT pPrevCert, PCCERT_CONTEXT *ppCert);

    static  HRESULT OptionsToSMIMEINFO(BOOL fEncode, IMimeMessageTree *const pmm, IMimeBody *pBody, SMIMEINFO *psi);
    static  HRESULT     SMIMEINFOToOptions(IMimeMessageTree *const pTree, const SMIMEINFO *psi, HBODY hBody);
    static  HRESULT     MergeSMIMEINFO( SMIMEINFO * psiOut, SMIMEINFO * psiInner);
    static  void    FreeSMIMEINFO(SMIMEINFO *psi);

#ifdef DEBUG
    void    DumpAlgorithms();
#endif

private:
    static HRESULT  HrInitCAPI();
    static void     UnloadCAPI();

    static HRESULT      CAPISTMtoSMIMEINFO(CCAPIStm *pcapistm, SMIMEINFO *psi);
    static void MergeSMIMEINFOs(const SMIMEINFO *const psiOuter, SMIMEINFO *const psiInner);

    UINT                m_cRef;
    CRITICAL_SECTION    m_cs;
#ifdef MAC
    static CAPIfuncs    ms_CAPI;
    static LPCSTR       ms_rgszFuncNames[];
#endif // MAC
};

inline BOOL IsOpaqueSecureContentType(IMimePropertySet *pSet)
{
    return (
        S_OK == pSet->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
        S_OK == pSet->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME));
}

inline BOOL IsSecureContentType(IMimePropertySet *pSet)
{
    return (
        S_OK == pSet->IsContentType(STR_CNT_MULTIPART, STR_SUB_SIGNED) ||
        IsOpaqueSecureContentType(pSet));
}

BOOL IsSMimeProtocol(LPMIMEPROPERTYSET lpPropSet);

#ifdef SMIME_V3
void    FreeRecipientInfoContent(PCMS_RECIPIENT_INFO pRecipInfo);
HRESULT HrCopyOID(LPCSTR psz, LPSTR * ppsz);
HRESULT HrCopyCryptDataBlob(const CRYPT_DATA_BLOB * pblobSrc, PCRYPT_DATA_BLOB pblobDst);
HRESULT HrCopyCryptBitBlob(const CRYPT_BIT_BLOB * pblobSrc, PCRYPT_BIT_BLOB pblobDst);
HRESULT HrCopyCryptAlgorithm(const CRYPT_ALGORITHM_IDENTIFIER * pAlgSrc,
                             PCRYPT_ALGORITHM_IDENTIFIER pAlgDst);
HRESULT HrCopyCertId(const CERT_ID * pcertidSrc, PCERT_ID pcertidDst);
#endif // SMIME_V3

#endif // _SMIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\stmlock.h ===
// --------------------------------------------------------------------------------
// Stmlock.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __STMLOCK_H
#define __STMLOCK_H

// -----------------------------------------------------------------------------
// IID_CStreamLockBytes - {62A83701-52A2-11d0-8205-00C04FD85AB4}
// -----------------------------------------------------------------------------
DEFINE_GUID(IID_CStreamLockBytes, 0x62a83701, 0x52a2, 0x11d0, 0x82, 0x5, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// -----------------------------------------------------------------------------
// CStreamLockBytes
// -----------------------------------------------------------------------------
class CStreamLockBytes : public ILockBytes
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CStreamLockBytes(IStream *pStream);
    ~CStreamLockBytes(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // ILockBytes methods
    // -------------------------------------------------------------------------
    STDMETHODIMP Flush(void); 
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
#ifndef WIN16
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead); 
#else
    STDMETHODIMP ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead);
#endif // !WIN16
    STDMETHODIMP SetSize(ULARGE_INTEGER cb); 
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType); 
#ifndef WIN16
    STDMETHODIMP WriteAt(ULARGE_INTEGER ulOffset, void const *pv, ULONG cb, ULONG *pcbWritten); 
#else
    STDMETHODIMP WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP *pv, ULONG cb, ULONG *pcbWritten);
#endif // !WIN16

    // -------------------------------------------------------------------------
    // CStreamLockBytes
    // -------------------------------------------------------------------------
    void ReplaceInternalStream(IStream *pStream);
    HRESULT HrHandsOffStorage(void);
    HRESULT HrSetPosition(ULARGE_INTEGER uliOffset);
    void GetCurrentStream(IStream **ppStream);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                m_cRef;       // Ref count
    IStream            *m_pStream;    // Protected stream
    CRITICAL_SECTION    m_cs;         // Critical Section for m_pStream
};

// -----------------------------------------------------------------------------
// CLockedStream
// -----------------------------------------------------------------------------
class CLockedStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CLockedStream(ILockBytes *pLockBytes, ULONG cbSize);
    ~CLockedStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read(VOID HUGEP *, ULONG, ULONG *);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *) {
#else
    STDMETHODIMP Write(const void HUGEP *, ULONG, ULONG *) {
#endif // !WIN16
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG             m_cRef;            // Reference count
    ILockBytes      *m_pLockBytes;      // Protected data stream
    ULARGE_INTEGER   m_uliOffset;       // 64bit Addressable internal lockbyte space
    ULARGE_INTEGER   m_uliSize;         // Size of internal lockbytes
    CRITICAL_SECTION m_cs;              // Critical Section for m_pStream
};

#endif // __STMLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\stmlock.cpp ===
// --------------------------------------------------------------------------------
// Stmlock.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "stmlock.h"
#include "vstream.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
CStreamLockBytes::CStreamLockBytes(IStream *pStream)
{
    Assert(pStream);
    m_cRef = 1;
    m_pStream = pStream;
    m_pStream->AddRef();
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
CStreamLockBytes::~CStreamLockBytes(void)
{
    SafeRelease(m_pStream);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_ILockBytes == riid)
        *ppv = (ILockBytes *)this;
    else if (IID_CStreamLockBytes == riid)
        *ppv = (CStreamLockBytes *)this;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStreamLockBytes::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::CStreamLockBytes
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStreamLockBytes::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::HrSetPosition
// --------------------------------------------------------------------------------
HRESULT CStreamLockBytes::HrSetPosition(ULARGE_INTEGER uliOffset)
{
    EnterCriticalSection(&m_cs);
    LARGE_INTEGER liOrigin;
    liOrigin.QuadPart = (DWORDLONG)uliOffset.QuadPart;
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::HrHandsOffStorage
// --------------------------------------------------------------------------------
HRESULT CStreamLockBytes::HrHandsOffStorage(void)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmNew=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Reference Count Isn't 1 (i.e. owned by IMimeMessageTree), dup the internal data
    if (1 != m_cRef)
    {
        // Copy m_pStream to a local place...
        CHECKALLOC(pstmNew = new CVirtualStream);

        // Rewind Internal
        CHECKHR(hr = HrRewindStream(m_pStream));

        // Copy the stream
        CHECKHR(hr = HrCopyStream(m_pStream, pstmNew, NULL));

        // Rewind and commit
        CHECKHR(hr = pstmNew->Commit(STGC_DEFAULT));

        // Rewind
        CHECKHR(hr = HrRewindStream(pstmNew));

        // Replace Internal Stream
        ReplaceInternalStream(pstmNew);
    }
    
exit:
    // Cleanup
    SafeRelease(pstmNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CStreamLockBytes::GetCurrentStream
// -------------------------------------------------------------------------
void CStreamLockBytes::GetCurrentStream(IStream **ppStream) 
{
    EnterCriticalSection(&m_cs);
    Assert(ppStream && m_pStream);
    *ppStream = m_pStream;
    (*ppStream)->AddRef();
    LeaveCriticalSection(&m_cs);
}


// --------------------------------------------------------------------------------
// CStreamLockBytes::ReplaceInternalStream
// --------------------------------------------------------------------------------
void CStreamLockBytes::ReplaceInternalStream(IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Internal Strea ?
    if (NULL == m_pStream)
    {
        Assert(FALSE);
        goto exit;
    }

    // DEBUG: Make sure stream are EXACTLY the same size
#ifdef DEBUG
    ULONG cbInternal, cbExternal;
    HrGetStreamSize(m_pStream, &cbInternal);
    HrGetStreamSize(pStream, &cbExternal);
    Assert(cbInternal == cbExternal);
#endif

    // Release Internal
    m_pStream->Release();
    m_pStream = pStream;
    m_pStream->AddRef();
    
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::Flush
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::Flush(void)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Commit(STGC_DEFAULT);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::LockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->LockRegion(libOffset, cb, dwLockType);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::UnlockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->LockRegion(libOffset, cb, dwLockType);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::ReadAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CStreamLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CStreamLockBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    LARGE_INTEGER liOrigin={ulOffset.LowPart, ulOffset.HighPart};
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (SUCCEEDED(hr))
        hr = m_pStream->Read(pv, cb, pcbRead);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::WriteAt
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CStreamLockBytes::WriteAt(ULARGE_INTEGER ulOffset, void const *pv, ULONG cb, ULONG *pcbWritten)
#else
STDMETHODIMP CStreamLockBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP *pv, ULONG cb, ULONG *pcbWritten)
#endif // !WIN16
{
    LARGE_INTEGER liOrigin={ulOffset.LowPart, ulOffset.HighPart};
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (SUCCEEDED(hr))
        hr = m_pStream->Write(pv, cb, pcbWritten);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::SetSize
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::SetSize(ULARGE_INTEGER cb)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = m_pStream->SetSize(cb);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CStreamLockBytes::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CStreamLockBytes::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Locals
    HRESULT hr=S_OK;

    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Zero Init
    ZeroMemory(pstatstg, sizeof(STATSTG));

    // Stat
    if (FAILED(m_pStream->Stat(pstatstg, grfStatFlag)))
    {
        // Locals
        ULARGE_INTEGER uliPos;
        LARGE_INTEGER  liOrigin;

        // Initialize
        uliPos.QuadPart = 0;
        liOrigin.QuadPart = 0;

        // If that failed, lets generate our own information (mainly, fill in size
        pstatstg->type = STGTY_LOCKBYTES;

        // Seek
        if (FAILED(m_pStream->Seek(liOrigin, STREAM_SEEK_END, &uliPos)))
            hr = E_FAIL;
        else
            pstatstg->cbSize.QuadPart = uliPos.QuadPart;
    }

    // URLMON Streams return a filled pwcsName event though this flag is set
    else if (ISFLAGSET(grfStatFlag, STATFLAG_NONAME))
    {
        // Free it
        SafeMemFree(pstatstg->pwcsName);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CLockedStream::CLockedStream
// -------------------------------------------------------------------------
CLockedStream::CLockedStream(ILockBytes *pLockBytes, ULONG cbSize)
{
    Assert(pLockBytes);
    m_cRef = 1;
    m_pLockBytes = pLockBytes;
    m_pLockBytes->AddRef();
    m_uliOffset.QuadPart = 0;
    m_uliSize.QuadPart = cbSize;
    InitializeCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CLockedStream::CLockedStream
// -------------------------------------------------------------------------
CLockedStream::~CLockedStream(void)
{
    SafeRelease(m_pLockBytes);
    DeleteCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CLockedStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CLockedStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CLockedStream::AddRef
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLockedStream::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// -------------------------------------------------------------------------
// CLockedStream::Release
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLockedStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// -------------------------------------------------------------------------
// CLockedStream::Read
// -------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CLockedStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CLockedStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT hr=S_OK;
    ULONG cbRead;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Read Buffer
    CHECKHR(hr = m_pLockBytes->ReadAt(m_uliOffset, pv, cb, &cbRead));

    // Done
    m_uliOffset.QuadPart += cbRead;

    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CLockedStream::Seek
// -------------------------------------------------------------------------
STDMETHODIMP CLockedStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliNew;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Seek the file pointer
    switch (dwOrigin)
    {
    // --------------------------------------------------------
   	case STREAM_SEEK_SET:
        uliNew.QuadPart = (DWORDLONG)dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    case STREAM_SEEK_CUR:
        if (dlibMove.QuadPart < 0)
        {
            if ((DWORDLONG)(0 - dlibMove.QuadPart) > m_uliOffset.QuadPart)
            {
                hr = TrapError(E_FAIL);
                goto exit;
            }
        }
        uliNew.QuadPart = m_uliOffset.QuadPart + dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    case STREAM_SEEK_END:
        if (dlibMove.QuadPart < 0 || (DWORDLONG)dlibMove.QuadPart > m_uliSize.QuadPart)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        uliNew.QuadPart = m_uliSize.QuadPart - dlibMove.QuadPart;
        break;

    // --------------------------------------------------------
    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // New offset greater than size...
    m_uliOffset.QuadPart = min(uliNew.QuadPart, m_uliSize.QuadPart);

    // Return Position
    if (plibNew)
        plibNew->QuadPart = (LONGLONG)m_uliOffset.QuadPart;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CLockedStream::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CLockedStream::CopyTo(LPSTREAM pstmDest, ULARGE_INTEGER cb, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten)
{
    return HrCopyStreamCB((IStream *)this, pstmDest, cb, puliRead, puliWritten);
}

// --------------------------------------------------------------------------------
// CLockedStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CLockedStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // Parameters
    if (NULL == pstatstg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If that failed, lets generate our own information (mainly, fill in size
    ZeroMemory(pstatstg, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = m_uliSize.QuadPart;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\symcache.cpp ===
// --------------------------------------------------------------------------------
// Symcache.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "symcache.h"
#include "containx.h"
#include "stackstr.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"
#include "qstrcmpi.h"

// --------------------------------------------------------------------------------
// Array of Pointers to known property symbols. This array's order defines the
// header row order in which headers will be saved.
// --------------------------------------------------------------------------------
static const LPPROPSYMBOL g_prgKnownSymbol[] = {
    { SYM_HDR_RECEIVED      },
    { SYM_HDR_RETURNPATH    },
    { SYM_HDR_RETRCPTTO     },
    { SYM_HDR_RR            },
    { SYM_HDR_REPLYTO       },
    { SYM_HDR_APPARTO       },
    { SYM_HDR_FROM          },
    { SYM_HDR_SENDER        },
    { SYM_HDR_TO            },
    { SYM_HDR_CC            },
    { SYM_HDR_BCC           },
    { SYM_HDR_NEWSGROUPS    },
    { SYM_HDR_PATH          },
    { SYM_HDR_FOLLOWUPTO    },
    { SYM_HDR_REFS          },
    { SYM_HDR_SUBJECT       },
    { SYM_HDR_DATE          },
    { SYM_HDR_EXPIRES       },
    { SYM_HDR_CONTROL       },
    { SYM_HDR_DISTRIB       },
    { SYM_HDR_KEYWORDS      },
    { SYM_HDR_SUMMARY       },
    { SYM_HDR_APPROVED      },
    { SYM_HDR_LINES         },
    { SYM_HDR_XREF          },
    { SYM_HDR_ORG           },
    { SYM_HDR_COMMENT       },
    { SYM_HDR_ENCODING      },
    { SYM_HDR_ENCRYPTED     },
    { SYM_HDR_OFFSETS       },
    { SYM_ATT_FILENAME      },
    { SYM_ATT_GENFNAME      },
    { SYM_PAR_BOUNDARY      },
    { SYM_PAR_CHARSET       },
    { SYM_PAR_NAME          },
    { SYM_PAR_FILENAME      },
    { SYM_ATT_PRITYPE       },
    { SYM_ATT_SUBTYPE       },
    { SYM_ATT_NORMSUBJ      },
    { SYM_ATT_ILLEGAL       },
    { SYM_HDR_MESSAGEID     },
    { SYM_HDR_MIMEVER       },
    { SYM_HDR_CNTTYPE       },
    { SYM_HDR_CNTXFER       },
    { SYM_HDR_CNTID         },
    { SYM_HDR_CNTDESC       },
    { SYM_HDR_CNTDISP       },
    { SYM_HDR_CNTBASE       },
    { SYM_HDR_CNTLOC        },
    { SYM_ATT_RENDERED      },
    { SYM_ATT_SENTTIME      },
    { SYM_ATT_RECVTIME      },
    { SYM_ATT_PRIORITY      },
    { SYM_HDR_ARTICLEID     },
    { SYM_HDR_NEWSGROUP     },
    { SYM_HDR_XPRI          },
    { SYM_HDR_XMSPRI        },
    { SYM_HDR_XMAILER       },
    { SYM_HDR_XNEWSRDR      },
    { SYM_HDR_XUNSENT       },
    { SYM_ATT_SERVER        },
    { SYM_ATT_ACCOUNTID     },
    { SYM_ATT_UIDL          },
    { SYM_ATT_STOREMSGID    },
    { SYM_ATT_USERNAME      },
    { SYM_ATT_FORWARDTO     },
    { SYM_ATT_STOREFOLDERID },
    { SYM_ATT_GHOSTED       },
    { SYM_ATT_UNCACHEDSIZE  },
    { SYM_ATT_COMBINED      },
    { SYM_ATT_AUTOINLINED   },
    { SYM_HDR_DISP_NOTIFICATION_TO }
};                                     

// --------------------------------------------------------------------------------
// Address Types To Property Symbol Mapping Table (Clients can register types)
// --------------------------------------------------------------------------------
static ADDRSYMBOL g_prgAddrSymbol[32] = {
    { IAT_FROM,         SYM_HDR_FROM        },
    { IAT_SENDER,       SYM_HDR_SENDER      },
    { IAT_TO,           SYM_HDR_TO          },
    { IAT_CC,           SYM_HDR_CC          },
    { IAT_BCC,          SYM_HDR_BCC         },
    { IAT_REPLYTO,      SYM_HDR_REPLYTO     },
    { IAT_RETURNPATH,   SYM_HDR_RETURNPATH  },
    { IAT_RETRCPTTO,    SYM_HDR_RETRCPTTO   },
    { IAT_RR,           SYM_HDR_RR          },
    { IAT_APPARTO,      SYM_HDR_APPARTO     },
    { IAT_DISP_NOTIFICATION_TO, SYM_HDR_DISP_NOTIFICATION_TO},
    { FLAG12,           NULL                },
    { FLAG13,           NULL                },
    { FLAG14,           NULL                },
    { FLAG15,           NULL                },
    { FLAG16,           NULL                },
    { FLAG17,           NULL                },
    { FLAG18,           NULL                },
    { FLAG19,           NULL                },
    { FLAG20,           NULL                },
    { FLAG21,           NULL                },
    { FLAG22,           NULL                },
    { FLAG23,           NULL                },
    { FLAG24,           NULL                },
    { FLAG25,           NULL                },
    { FLAG26,           NULL                },
    { FLAG27,           NULL                },
    { FLAG28,           NULL                },
    { FLAG29,           NULL                },
    { FLAG30,           NULL                },
    { FLAG31,           NULL                },
    { FLAG32,           NULL                }
};

// --------------------------------------------------------------------------------
// CPropertySymbolCache::CPropertySymbolCache
// --------------------------------------------------------------------------------
CPropertySymbolCache::CPropertySymbolCache(void)
{
    m_cRef = 1;
    m_dwNextPropId = PID_LAST;
    m_cSymbolsInit = 0;
    ZeroMemory(&m_rTable, sizeof(m_rTable));
    ZeroMemory(m_prgIndex, sizeof(m_prgIndex));
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::CPropertySymbolCache
// --------------------------------------------------------------------------------
CPropertySymbolCache::~CPropertySymbolCache(void)
{
    DebugTrace("MimeOLE - CPropertySymbolCache %d Symbols in Cache.\n", m_rTable.cSymbols);
    _FreeTableElements();
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimePropertySchema == riid)
        *ppv = (IMimePropertySchema *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertySymbolCache::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertySymbolCache::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::GetPropertyId
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::GetPropertyId(LPCSTR pszName, LPDWORD pdwPropId)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName || NULL == pdwPropId)
        return TrapError(E_INVALIDARG);

    // Find the Property By Name
    CHECKHR(hr = HrOpenSymbol(pszName, FALSE, &pSymbol));

    // Return the Id
    *pdwPropId = pSymbol->dwPropId;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::GetPropertyName
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::GetPropertyName(DWORD dwPropId, LPSTR *ppszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == ppszName)
        return TrapError(E_INVALIDARG);

    // Find the Property By Name
    CHECKHR(hr = HrOpenSymbol(PIDTOSTR(dwPropId), FALSE, &pSymbol));

    // Return the Id
    CHECKALLOC(*ppszName = PszDupA(pSymbol->pszName));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::RegisterProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::RegisterProperty(LPCSTR pszName, DWORD dwFlags, 
    DWORD dwRowNumber, VARTYPE vtDefault, LPDWORD pdwPropId)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Is Supported VARTYPE
    if (ISSUPPORTEDVT(vtDefault) == FALSE)
        return TrapError(MIME_E_UNSUPPORTED_VARTYPE);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Validate the dwFlags
    CHECKHR(hr = HrIsValidPropFlags(dwFlags));

    // Already Exist ?
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, TRUE, &pSymbol,FALSE));

    // If MPF_ADDRESS flag is not equal to what the symbol already has, this is an error
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) != ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Change the Flags
    pSymbol->dwFlags = dwFlags;

    // Change the row number
    pSymbol->dwRowNumber = ((dwRowNumber == 0) ? 1 : dwRowNumber);

    // Save the Default Data Type
    pSymbol->vtDefault = vtDefault;

    // Return the Property Id
    if (pdwPropId)
        *pdwPropId = pSymbol->dwPropId;

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::ModifyProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::ModifyProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber,
    VARTYPE vtDefault)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName)
        return TrapError(E_INVALIDARG);

    // Is Supported VARTYPE
    if (ISSUPPORTEDVT(vtDefault) == FALSE)
        return TrapError(MIME_E_UNSUPPORTED_VARTYPE);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Validate the dwFlags
    CHECKHR(hr = HrIsValidPropFlags(dwFlags));

    // Find the Property By Name
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, FALSE, &pSymbol,FALSE));

    // If MPF_ADDRESS flag is not equal to what the symbol already has, this is an error
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) != ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Change the Flags
    pSymbol->dwFlags = dwFlags;

    // Change the row number
    pSymbol->dwRowNumber = ((dwRowNumber == 0) ? 1 : dwRowNumber);

    // Save the Default Data Type
    pSymbol->vtDefault = vtDefault;

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::RegisterAddressType
// --------------------------------------------------------------------------------
STDMETHODIMP CPropertySymbolCache::RegisterAddressType(LPCSTR pszName, LPDWORD pdwAdrType)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol;

    // Invalid Args
    if (NULL == pszName || NULL == pdwAdrType)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Already Exist ?
    CHECKHR(hr = _HrOpenSymbolWithLockOption(pszName, TRUE, &pSymbol,FALSE));

    // If pSymbol already has an address type ?
    if (ISFLAGSET(pSymbol->dwFlags, MPF_ADDRESS))
    {
        // Better have a known address type
        Assert(IAT_UNKNOWN != pSymbol->dwAdrType);

        // Return the Address Type
        *pdwAdrType = pSymbol->dwAdrType;
    }
    
    // Otherwise
    else
    {
        // Better have an unknown address type
        Assert(IAT_UNKNOWN == pSymbol->dwAdrType);

        // Find the first empty cell in the address type table
        for (ULONG i=0; i<ARRAYSIZE(g_prgAddrSymbol); i++)
        {
            // Empty ?
            if (NULL == g_prgAddrSymbol[i].pSymbol)
            {
                // Put the symbol into the address table
                g_prgAddrSymbol[i].pSymbol = pSymbol;

                // Put the address type into the symbol
                pSymbol->dwAdrType = g_prgAddrSymbol[i].dwAdrType;

                // Add the MPF_ADDRESS flag onto the symbol
                FLAGSET(pSymbol->dwFlags, MPF_ADDRESS);

                // Return the Address Type
                *pdwAdrType = pSymbol->dwAdrType;

                // Done
                goto exit;
            }
        }

        // Error
        hr = TrapError(MIME_E_NO_MORE_ADDRESS_TYPES);
        goto exit;
    }

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_FreeTableElements
// --------------------------------------------------------------------------------
void CPropertySymbolCache::_FreeTableElements(void)
{
    // Thread Safety
    m_lock.ExclusiveLock();
    
    // May not actually exist yet...
    if (m_rTable.prgpSymbol)
    {
        // Loop through the items...
        for (ULONG i=0; i<m_rTable.cSymbols; i++)
            _FreeSymbol(m_rTable.prgpSymbol[i]);

        // Free the array
        SafeMemFree(m_rTable.prgpSymbol);

        // Zero It
        ZeroMemory(&m_rTable, sizeof(SYMBOLTABLE));
    }

    // Thread Safety
    m_lock.ExclusiveUnlock();
}

// ---------------------------------------------------------------------------
// CPropertySymbolCache::_FreeSymbol
// ---------------------------------------------------------------------------
void CPropertySymbolCache::_FreeSymbol(LPPROPSYMBOL pSymbol)
{
    // If Not a Known Property, free the pTag Structure...
    if (pSymbol && ISFLAGSET(pSymbol->dwFlags, MPF_KNOWN) == FALSE)
    {
        // Free Property Name
        SafeMemFree(pSymbol->pszName);

        // Free Global Prop
        SafeMemFree(pSymbol);
    }
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::HrOpenSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::HrOpenSymbol(DWORD dwAdrType, LPPROPSYMBOL *ppSymbol)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw=dwAdrType;
    ULONG       iAddress=0;

    // Invalid Arg
    Assert(dwAdrType && dwAdrType <= FLAG32);
    if (0 == dwAdrType || dwAdrType > FLAG32 || NULL == ppSymbol)
        return TrapError(E_INVALIDARG);

    // Init
    *ppSymbol = NULL;

    // Thread Safety
    m_lock.ShareLock();

    // Initialized Yet
    Assert(m_rTable.prgpSymbol);

    // Compute index into g_prgAddrSymbol
    while(dw)
    {
        dw = dw >> 1;
        iAddress++;
    }

    // Decrement one
    iAddress--;

    // iAddress Out of Range
    if (iAddress >= 32)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Get the Symbol
    if (NULL == g_prgAddrSymbol[iAddress].pSymbol)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Return it
    *ppSymbol = g_prgAddrSymbol[iAddress].pSymbol;
    Assert((*ppSymbol)->dwAdrType == dwAdrType);

exit:
    // Thread Safety
    m_lock.ShareUnlock();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::HrOpenSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::HrOpenSymbol(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol)
{
    return(_HrOpenSymbolWithLockOption(pszName,fCreate,ppSymbol,TRUE)); //call with lockOption=TRUE
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrOpenSymbolWithLockOption
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrOpenSymbolWithLockOption(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol,BOOL fLockOption)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwFlags;
    ULONG               cchName;
    LPPROPSYMBOL        pSymbol=NULL;
    LPPROPSYMBOL        pLink=NULL;
    BOOL                fExcLock; //flag used to define which unlock to use
    
    
    fExcLock = FALSE;

    // Invalid Arg
    if (NULL == pszName || NULL == ppSymbol)
        return TrapError(E_INVALIDARG);

    // Init
    *ppSymbol = NULL;

    if(TRUE == fLockOption)
        // Thread Safety
        m_lock.ShareLock();

    // Initialized Yet
    Assert(m_rTable.prgpSymbol);

    // If property tag exist, return it
    if (SUCCEEDED(_HrFindSymbol(pszName, ppSymbol)))
        goto exit;

    // Don't Create...
    if (FALSE == fCreate || ISPIDSTR(pszName))
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    //This part is added to convert the lock to Exclusive
    //if the symbol is not found in the cache
    
    if(TRUE == fLockOption)
    {
        fExcLock = TRUE; 
        if(FALSE == m_lock.SharedToExclusive())
        {
            //if the attempt at conversion does not
            //succeed tryu to do it by explicitly

            m_lock.ShareUnlock();       //Release the Sharelock before
            m_lock.ExclusiveLock();     //getting the exclusive lock

            //during the change of lock the cache might have changed
            //check it again

            if (SUCCEEDED(_HrFindSymbol(pszName, ppSymbol)))
                goto exit;
        }
    }      

    // Get the length of the name
    cchName = lstrlen(pszName);

    // MPF_PARAMETER
    if (StrCmpNI(pszName, "par:", 4) == 0)
    {
        // Its a parameter
        dwFlags = MPF_PARAMETER;

        // I need to locate pLink (the root header of this parameter)
        CHECKHR(hr = _HrGetParameterLinkSymbolWithLockOption(pszName, cchName, &pLink,FALSE));
    }

    // MPF_ATTRIBUTE
    else if (StrCmpNI(pszName, "att:", 4) == 0)
        dwFlags = MPF_ATTRIBUTE;

    // MPF_HEADER
    else
    {
        dwFlags = MPF_HEADER;

        // validate each character in the name against rfc (no :, or spaces)
        LPSTR psz = (LPSTR)pszName;
        while(*psz)
        {
            // Invalid Chars
            if ('.'  == *psz || ' '  == *psz || '\t' == *psz || chCR == *psz || chLF == *psz || ':' == *psz)
            {
                hr = MIME_E_INVALID_HEADER_NAME;
                goto exit;
            }

            // Next
            psz++;
        }
    }

    // Do I need to replace an item...
    if (m_rTable.cSymbols + 1 > m_rTable.cAlloc)
    {
        // Reallocate the array
        CHECKHR(hr = HrRealloc((LPVOID *)&m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * (m_rTable.cAlloc +  10)));

        // Increment
        m_rTable.cAlloc += 10;
    }

    // Allocate a new propinfo struct
    CHECKALLOC(pSymbol = (LPPROPSYMBOL)g_pMalloc->Alloc(sizeof(PROPSYMBOL)));

    // Zero
    ZeroMemory(pSymbol, sizeof(PROPSYMBOL));

    // Copy Name
    CHECKALLOC(pSymbol->pszName = (LPSTR)g_pMalloc->Alloc(cchName + 1));

    // Copy
    CopyMemory(pSymbol->pszName, pszName, cchName + 1);

    // Copy Other Data
    pSymbol->cchName = cchName;
    pSymbol->dwFlags = dwFlags;
    pSymbol->dwSort = m_rTable.cSymbols;
    pSymbol->dwRowNumber = m_rTable.cSymbols + 1;
    pSymbol->vtDefault = VT_LPSTR;
    pSymbol->dwAdrType = IAT_UNKNOWN;
    pSymbol->pLink = pLink;

    // Compute the property Id
    pSymbol->dwPropId = m_dwNextPropId++;

    // Compute Hash Value
    pSymbol->wHashIndex = (WORD)(pSymbol->dwPropId % CBUCKETS);

    // Save item into array
    m_rTable.prgpSymbol[m_rTable.cSymbols] = pSymbol;

    // Increment count
    m_rTable.cSymbols++;

    // Resort the array
    _SortTableElements(0, m_rTable.cSymbols - 1);

    // Set Handle
    *ppSymbol = pSymbol;

    // Make sure we can still actually find it by property id
#ifdef DEBUG
    LPPROPSYMBOL pDebug;
    Assert(SUCCEEDED(_HrOpenSymbolWithLockOption(PIDTOSTR(pSymbol->dwPropId), FALSE, &pDebug,FALSE)));
#endif

exit:
    // Failure
    if (FAILED(hr) && pSymbol)
        _FreeSymbol(pSymbol);
     
    if(TRUE == fLockOption)
    {
        // Thread Safety
        if(TRUE==fExcLock)
            m_lock.ExclusiveUnlock();
        else
            m_lock.ShareUnlock();
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrGetParameterLinkSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrGetParameterLinkSymbol(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol)
{
    return(_HrGetParameterLinkSymbolWithLockOption(pszName,cchName,ppSymbol,TRUE)); //call with LockOption=TRUE
}


// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrGetParameterLinkSymbolWithLockOption
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrGetParameterLinkSymbolWithLockOption(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol,BOOL fLockOption)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszStart;
    LPSTR           pszEnd;
    ULONG           cchHeader=0;

    // Invalid Arg
    Assert(pszName && ':' == pszName[3] && ppSymbol);

    // Stack String
    STACKSTRING_DEFINE(rHeader, 255);

    // Find first semicolon
    pszEnd = (LPSTR)(pszName + 4);
    while (*pszEnd && ':' != *pszEnd)
    {
        pszEnd++;
        cchHeader++;
    }

    // Set the name
    STACKSTRING_SETSIZE(rHeader, cchHeader);

    // Copy It
    CopyMemory(rHeader.pszVal, (LPBYTE)(pszName + 4), cchHeader);
    *(rHeader.pszVal + cchName) = '\0';

    // Find the Symbol
    CHECKHR(hr = _HrOpenSymbolWithLockOption(rHeader.pszVal, TRUE, ppSymbol,fLockOption));

exit:
    // Cleanup
    STACKSTRING_FREE(rHeader);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropertySymbolCache::_HrFindSymbol
// --------------------------------------------------------------------------------
HRESULT CPropertySymbolCache::_HrFindSymbol(LPCSTR pszName, LPPROPSYMBOL *ppSymbol)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPROPSYMBOL    pSymbol=NULL;
    DWORD           dwPropId;

    // Invalid Arg
    Assert(ppSymbol);

    // If this is a known property tag...
    if (ISPIDSTR(pszName))
    {
        // Cast the dwPropId
        dwPropId = STRTOPID(pszName);

        // Set Symbol
        if (ISKNOWNPID(dwPropId))
        {
            // De-ref into known property index (ordered differently than g_prgKnownProps)
            pSymbol = m_prgIndex[dwPropId];
        }

        // Otherwise, must be an unknown pid index
        else
        {
            // I need to re-align dwPropId because it starts at PID_LAST and my not be a direct index
            // into the symbol table since the symbol table is not initialized with PID_LAST properties
            dwPropId -= (PID_LAST - ARRAYSIZE(g_prgKnownSymbol));

            // Must be >= PID_LAST and < m_rTable.cSymbols
            if (dwPropId >= m_cSymbolsInit && dwPropId < m_rTable.cSymbols)
            {
                // dwPropId is an index into the symbol table
                pSymbol = m_rTable.prgpSymbol[dwPropId];
                Assert(pSymbol);
            }

            // Else
            else
                AssertSz(FALSE, "How did you get an invalid unknown property id?");
        }
    }

    // Otherwise, look for it by name
    else
    {
        // Locals
        LONG   lUpper, lLower, lMiddle, nCompare;
        ULONG  i;

        // Set lLower and lUpper
        lLower = 0;
        lUpper = m_rTable.cSymbols - 1;

        // Do binary search / insert
        while (lLower <= lUpper)
        {
            // Compute middle record to compare against
            lMiddle = (LONG)((lLower + lUpper) / 2);

            // Get string to compare against
            i = m_rTable.prgpSymbol[lMiddle]->dwSort;

            // Do compare
            nCompare = OEMstrcmpi(pszName, m_rTable.prgpSymbol[i]->pszName);

            // If Equal, then were done
            if (nCompare == 0)
            {
                // Set Symbol
                pSymbol = m_rTable.prgpSymbol[i];

                // Done
                break;
            }

            // Compute upper and lower 
            if (nCompare > 0)
                lLower = lMiddle + 1;
            else 
                lUpper = lMiddle - 1;
        }       
    }

    // Not Found
    if (NULL == pSymbol)
    {
        hr = MIME_E_NOT_FOUND;
        goto exit;
    }

    // Validate PropSymbol
    Assert(SUCCEEDED(HrIsValidSymbol(pSymbol)));

    // Otherwise...
    *ppSymbol = pSymbol;

exit:
    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CPropertySymbolCache::Init
// ---------------------------------------------------------------------------
HRESULT CPropertySymbolCache::Init(void)
{
    // Locals 
    HRESULT     hr=S_OK;
    ULONG       i;

    // We should not be initialized yet
    Assert(NULL == m_rTable.prgpSymbol);

    // Thread Safety
    m_lock.ExclusiveLock();

    // Set Sizes
    m_rTable.cSymbols = ARRAYSIZE(g_prgKnownSymbol);
    m_rTable.cAlloc = m_rTable.cSymbols + 30;

    // Allocate the global item table
    CHECKHR(hr = HrAlloc((LPVOID *)&m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * m_rTable.cAlloc));

    // Zero Init
    ZeroMemory(m_rTable.prgpSymbol, sizeof(LPPROPSYMBOL) * m_rTable.cAlloc);

    // Loop through known items
    for(i=0; i<m_rTable.cSymbols; i++)
    {
        // Just assume the global data pointer
        m_rTable.prgpSymbol[i] = g_prgKnownSymbol[i];

        // Set the sort position
        m_rTable.prgpSymbol[i]->dwSort = i;

        // Compute Hash Index
        m_rTable.prgpSymbol[i]->wHashIndex = (WORD)(m_rTable.prgpSymbol[i]->dwPropId % CBUCKETS);

        // Set the sort position
        m_rTable.prgpSymbol[i]->dwRowNumber = i + 1;

        // Put it into my index
        Assert(ISKNOWNPID(m_rTable.prgpSymbol[i]->dwPropId) == TRUE);

        // Put into symbol index
        m_prgIndex[m_rTable.prgpSymbol[i]->dwPropId] = m_rTable.prgpSymbol[i];
    }

    // Sort the item table...
    _SortTableElements(0, m_rTable.cSymbols - 1);

    // Save Number of Symbols initialised in the table
    m_cSymbolsInit = m_rTable.cSymbols;

    // Table Validation
#ifdef DEBUG
    LPPROPSYMBOL pDebug;

    // Lets validate the table
    for(i=0; i<m_rTable.cSymbols; i++)
    {
        // Validate pLink
        if (ISFLAGSET(m_rTable.prgpSymbol[i]->dwFlags, MPF_PARAMETER))
        {
            // Locals
            LPPROPSYMBOL pLink;

            // Look for the link symbol
            Assert(SUCCEEDED(_HrGetParameterLinkSymbolWithLockOption(m_rTable.prgpSymbol[i]->pszName, m_rTable.prgpSymbol[i]->cchName, &pLink,FALSE)));

            // Validate the the computed link with the const link
            Assert(pLink == m_rTable.prgpSymbol[i]->pLink);
        }

        // If this has an address flag
        if (ISFLAGSET(m_rTable.prgpSymbol[i]->dwFlags, MPF_ADDRESS))
        {
            // Locals
            ULONG       j;
            BOOL        f=FALSE;

            // Make sure it is in the address type table
            for (j=0; j<ARRAYSIZE(g_prgAddrSymbol); j++)
            {
                // Found It
                if (m_rTable.prgpSymbol[i] == g_prgAddrSymbol[j].pSymbol)
                {
                    f=TRUE;
                    break;
                }
            }

            // We better have found it
            AssertSz(f, "A symbol has the MPF_ADDRESS flag, but is not in the address table.");
        }

        // Make sure we can still actually find it by property id
        Assert(SUCCEEDED(_HrOpenSymbolWithLockOption(PIDTOSTR(m_rTable.prgpSymbol[i]->dwPropId), FALSE, &pDebug,FALSE)));
    }
#endif

exit:
    // Thread Safety
    m_lock.ExclusiveUnlock();
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySymbolCache::_SortTableElements
// -----------------------------------------------------------------------------
void CPropertySymbolCache::_SortTableElements(LONG left, LONG right)
{
    // Locals
    register    long i, j;
    DWORD       k, temp;

    i = left;
    j = right;
    k = m_rTable.prgpSymbol[(i + j) / 2]->dwSort;

    do  
    {
        while(OEMstrcmpi(m_rTable.prgpSymbol[m_rTable.prgpSymbol[i]->dwSort]->pszName, m_rTable.prgpSymbol[k]->pszName) < 0 && i < right)
            i++;
        while (OEMstrcmpi(m_rTable.prgpSymbol[m_rTable.prgpSymbol[j]->dwSort]->pszName, m_rTable.prgpSymbol[k]->pszName) > 0 && j > left)
            j--;

        if (i <= j)
        {
            temp = m_rTable.prgpSymbol[i]->dwSort;
            m_rTable.prgpSymbol[i]->dwSort = m_rTable.prgpSymbol[j]->dwSort;
            m_rTable.prgpSymbol[j]->dwSort = temp;
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        _SortTableElements(left, j);
    if (i < right)
        _SortTableElements(i, right);
}

// --------------------------------------------------------------------------------
// WGetHashTableIndex
// --------------------------------------------------------------------------------
WORD WGetHashTableIndex(LPCSTR pszName, ULONG cchName)
{
    // Locals
    ULONG   nHash=0;
    LONG    c, j=0;
    ULONG   i;
    CHAR    ch;

    // Invalid Arg
    Assert(pszName && pszName[cchName] =='\0');

    // Compute Number of characters to hash
    i = cchName - 1;
    c = min(3, cchName);

    // Loop
    for (; j<c; j++)
    {
        ch = (CHAR)CharLower((LPSTR)(DWORD_PTR)MAKELONG(pszName[i - j], 0));
        nHash += (ULONG)(ch);
    }

    // Done
    return (WORD)(nHash % CBUCKETS);
}

// --------------------------------------------------------------------------------
// HrIsValidSymbol
// --------------------------------------------------------------------------------
HRESULT HrIsValidSymbol(LPCPROPSYMBOL pSymbol)
{
    // Validate the symbol
    if (NULL == pSymbol || NULL == pSymbol->pszName || '\0' != pSymbol->pszName[pSymbol->cchName])
        return TrapError(E_FAIL);

    // Validate the flags
    return HrIsValidPropFlags(pSymbol->dwFlags);
}

// --------------------------------------------------------------------------------
// HrIsValidPropFlags
// --------------------------------------------------------------------------------
HRESULT HrIsValidPropFlags(DWORD dwFlags)
{
    // If has parameters, it can only be a mime header property
    if (ISFLAGSET(dwFlags, MPF_HASPARAMS) && (!ISFLAGSET(dwFlags, MPF_MIME) || !ISFLAGSET(dwFlags, MPF_HEADER)))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // If not inetcset, then rfc1522 better not be set either
    if (!ISFLAGSET(dwFlags, MPF_INETCSET) && ISFLAGSET(dwFlags, MPF_RFC1522))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // If rfc1522 is set, inetset better be set
    if (ISFLAGSET(dwFlags, MPF_RFC1522) && !ISFLAGSET(dwFlags, MPF_INETCSET))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // Is either MDF_ADDRESS or MDF_HASPARAMS    
    if (ISFLAGSET(dwFlags, MPF_ADDRESS) && ISFLAGSET(dwFlags, MPF_HASPARAMS))
        return TrapError(MIME_E_INVALID_PROP_FLAGS);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\symcache.h ===
// --------------------------------------------------------------------------------
// Symcache.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __SYMCACHE_H
#define __SYMCACHE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "containx.h"
#include "exrwlck.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CPropertySymbolCache;
typedef class CPropertySymbolCache *LPSYMBOLCACHE;

// --------------------------------------------------------------------------------
// Don't let this flag overlap with MIMEPROPFLAGS
// --------------------------------------------------------------------------------
#define MPF_NODIRTY     FLAG28          // Property does not allow container to get dirty
#define MPF_HEADER      FLAG29          // Property is a header and should be persisted
#define MPF_PARAMETER   FLAG30          // Property is a header parameter
#define MPF_ATTRIBUTE   FLAG31          // Property is a non-persisting attribute
#define MPF_KNOWN       FLAG32          // Property is known by mimeole (it holds const data)

// --------------------------------------------------------------------------------
// Forward Typedefs
// --------------------------------------------------------------------------------
typedef struct tagPROPSYMBOL const *LPCPROPSYMBOL;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;

// --------------------------------------------------------------------------------
// PROPSYMBOL
// --------------------------------------------------------------------------------
typedef struct tagPROPSYMBOL {
    LPSTR               pszName;        // Property Name
    ULONG               cchName;        // Property Name Length
    DWORD               dwPropId;       // Property Id (PID_UNKNOWN if not known)
    DWORD               dwFlags;        // Property Flags
    DWORD               dwAdrType;      // Address Type
    WORD                wHashIndex;     // Symbol's Hash Index in the Property Container
    DWORD               dwSort;         // By Name Sort Position
    DWORD               dwRowNumber;    // Header Line Persist Postion
    VARTYPE             vtDefault;      // Default data type
    LPPROPSYMBOL        pLink;          // Link to property id for parameter properties
    LPSYMBOLTRIGGER     pTrigger;       // Proerty Notification Handler
} PROPSYMBOL;

// --------------------------------------------------------------------------------
// Macro used to define global property symbols
// --------------------------------------------------------------------------------
#ifdef DEFINE_PROPSYMBOLS

#define DEFINESYMBOL(_NAME, _vtDefault, _dwFlags, _dwAdrType, _pLink, _pfnDispatch) \
    PROPSYMBOL rSYM_##_NAME = \
    { \
        /* PROPSYMBOL::pszName     */ (LPSTR)(STR_##_NAME), \
        /* PROPSYMBOL::cchName     */ sizeof(STR_##_NAME) - 1, \
        /* PROPSYMBOL::dwPropId    */ PID_##_NAME, \
        /* PROPSYMBOL::dwFlags     */ (_dwFlags | MPF_KNOWN), \
        /* PROPSYMBOL::dwAdrType   */ _dwAdrType, \
        /* PROPSYMBOL::wHashIndex  */ 0, \
        /* PROPSYMBOL::dwSort      */ 0, \
        /* PROPSYMBOL::dwRowNumber */ 0, \
        /* PROPSYMBOL::vtDefault   */ _vtDefault, \
        /* PROPSYMBOL::pLink       */ _pLink, \
        /* PROPSYMBOL::pfnDispatch */ _pfnDispatch \
    }; \
    LPPROPSYMBOL SYM_##_NAME = &rSYM_##_NAME;
#else

#define DEFINESYMBOL(_NAME, _vtDefault, _dwFlags, _dwAdrType, _pLink, _pfnDispatch) \
    extern LPPROPSYMBOL SYM_##_NAME;

#endif

// --------------------------------------------------------------------------------
// Property Flags Groups
// --------------------------------------------------------------------------------
#define MPG_GROUP01 (MPF_HEADER)
#define MPG_GROUP02 (MPF_HEADER)
#define MPG_GROUP03 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522 | MPF_ADDRESS)
#define MPG_GROUP04 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP05 (MPF_HEADER | MPF_MIME)
#define MPG_GROUP06 (MPF_HEADER | MPF_MIME | MPF_HASPARAMS)
#define MPG_GROUP07 (MPF_HEADER | MPF_MIME)
#define MPG_GROUP08 (MPF_HEADER | MPF_MIME | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP09 (MPF_PARAMETER | MPF_MIME)
#define MPG_GROUP10 (MPF_PARAMETER | MPF_MIME | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP11 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP12 (MPF_ATTRIBUTE)
#define MPG_GROUP13 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP14 (MPF_HEADER | MPF_INETCSET | MPF_RFC1522)
#define MPG_GROUP15 (MPF_ATTRIBUTE | MPF_INETCSET | MPF_RFC1522 | MPF_READONLY)
#define MPG_GROUP16 (MPF_ATTRIBUTE | MPF_READONLY)
#define MPG_GROUP17 (MPF_ATTRIBUTE | MPF_NODIRTY)

// --------------------------------------------------------------------------------
// Header Property Tag Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(HDR_RECEIVED,   VT_LPSTR,    MPG_GROUP01, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XMAILER,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XUNSENT,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XNEWSRDR,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_RETURNPATH, VT_LPSTR,    MPG_GROUP03, IAT_RETURNPATH, NULL, NULL);
DEFINESYMBOL(HDR_RETRCPTTO,  VT_LPSTR,    MPG_GROUP03, IAT_RETRCPTTO,  NULL, NULL);
DEFINESYMBOL(HDR_RR,         VT_LPSTR,    MPG_GROUP03, IAT_RR,         NULL, NULL);
DEFINESYMBOL(HDR_REPLYTO,    VT_LPSTR,    MPG_GROUP03, IAT_REPLYTO,    NULL, NULL);
DEFINESYMBOL(HDR_APPARTO,    VT_LPSTR,    MPG_GROUP03, IAT_APPARTO,    NULL, NULL);
DEFINESYMBOL(HDR_FROM,       VT_LPSTR,    MPG_GROUP03, IAT_FROM,       NULL, NULL);
DEFINESYMBOL(HDR_SENDER,     VT_LPSTR,    MPG_GROUP03, IAT_SENDER,     NULL, NULL);
DEFINESYMBOL(HDR_TO,         VT_LPSTR,    MPG_GROUP03, IAT_TO,         NULL, NULL);
DEFINESYMBOL(HDR_CC,         VT_LPSTR,    MPG_GROUP03, IAT_CC,         NULL, NULL);
DEFINESYMBOL(HDR_BCC,        VT_LPSTR,    MPG_GROUP03, IAT_BCC,        NULL, NULL);
DEFINESYMBOL(HDR_NEWSGROUPS, VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_PATH,       VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_FOLLOWUPTO, VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_REFS,       VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_SUBJECT,    VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_SUBJECT);
DEFINESYMBOL(HDR_ORG,        VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DATE,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_EXPIRES,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CONTROL,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DISTRIB,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_KEYWORDS,   VT_LPSTR,    MPG_GROUP04, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_SUMMARY,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_APPROVED,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_LINES,      VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XREF,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XPRI,       VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_XMSPRI,     VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_MESSAGEID,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_MIMEVER,    VT_LPSTR,    MPG_GROUP05, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTTYPE,    VT_LPSTR,    MPG_GROUP06, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_CNTTYPE);
DEFINESYMBOL(HDR_CNTDISP,    VT_LPSTR,    MPG_GROUP06, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTXFER,    VT_LPSTR,    MPG_GROUP07, IAT_UNKNOWN,    NULL, LPTRIGGER_HDR_CNTXFER);
DEFINESYMBOL(HDR_CNTID,      VT_LPSTR,    MPG_GROUP07, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTDESC,    VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTBASE,    VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_CNTLOC,     VT_LPSTR,    MPG_GROUP08, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_COMMENT,    VT_LPSTR,    MPG_GROUP14, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ENCODING,   VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ENCRYPTED,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_OFFSETS,    VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_ARTICLEID,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_NEWSGROUP,  VT_LPSTR,    MPG_GROUP02, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(HDR_DISP_NOTIFICATION_TO,    VT_LPSTR,    MPG_GROUP03,    IAT_DISP_NOTIFICATION_TO, NULL, NULL);
                                                                                      
// --------------------------------------------------------------------------------
// Parameter Property Tags Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(PAR_BOUNDARY,   VT_LPSTR,    MPG_GROUP09, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  NULL);
DEFINESYMBOL(PAR_CHARSET,    VT_LPSTR,    MPG_GROUP09, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  NULL);
DEFINESYMBOL(PAR_FILENAME,   VT_LPSTR,    MPG_GROUP10, IAT_UNKNOWN,    SYM_HDR_CNTDISP,  LPTRIGGER_PAR_FILENAME);
DEFINESYMBOL(PAR_NAME,       VT_LPSTR,    MPG_GROUP10, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_PAR_NAME);
                                                                                      
// --------------------------------------------------------------------------------
// Attribute Property Tags Definitions
// --------------------------------------------------------------------------------
DEFINESYMBOL(ATT_FILENAME,   VT_LPSTR,    MPG_GROUP11, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_FILENAME);
DEFINESYMBOL(ATT_GENFNAME,   VT_LPSTR,    MPG_GROUP15, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_GENFNAME);
DEFINESYMBOL(ATT_NORMSUBJ,   VT_LPSTR,    MPG_GROUP15, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_NORMSUBJ);
DEFINESYMBOL(ATT_ILLEGAL,    VT_LPSTR,    MPG_GROUP13, IAT_UNKNOWN,    NULL,             NULL);
DEFINESYMBOL(ATT_PRITYPE,    VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_ATT_PRITYPE);
DEFINESYMBOL(ATT_SUBTYPE,    VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_CNTTYPE,  LPTRIGGER_ATT_SUBTYPE);
DEFINESYMBOL(ATT_RENDERED,   VT_UI4,      MPG_GROUP17, IAT_UNKNOWN,    NULL,             NULL);
DEFINESYMBOL(ATT_SENTTIME,   VT_FILETIME, MPG_GROUP12, IAT_UNKNOWN,    SYM_HDR_DATE,     LPTRIGGER_ATT_SENTTIME);
DEFINESYMBOL(ATT_RECVTIME,   VT_FILETIME, MPG_GROUP16, IAT_UNKNOWN,    SYM_HDR_RECEIVED, LPTRIGGER_ATT_RECVTIME);
DEFINESYMBOL(ATT_PRIORITY,   VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL,             LPTRIGGER_ATT_PRIORITY);
DEFINESYMBOL(ATT_SERVER,     VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_ACCOUNTID,  VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_UIDL,       VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_STOREMSGID, VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_USERNAME,   VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_FORWARDTO,  VT_LPSTR,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_STOREFOLDERID, VT_UI4,   MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_GHOSTED,    VT_I4,       MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);   
DEFINESYMBOL(ATT_UNCACHEDSIZE, VT_UI4,    MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);
DEFINESYMBOL(ATT_COMBINED,   VT_UI4,      MPG_GROUP12, IAT_UNKNOWN,    NULL, NULL);           
DEFINESYMBOL(ATT_AUTOINLINED, VT_UI4,      MPG_GROUP17, IAT_UNKNOWN,    NULL, NULL);

// --------------------------------------------------------------------------------
// ADDRSYMBOL
// --------------------------------------------------------------------------------
typedef struct tagADDRSYMBOL {
    DWORD               dwAdrType;      // Address Type (bitmask)
    LPPROPSYMBOL        pSymbol;        // Property Symbol
} ADDRSYMBOL, *LPADDRSYMBOL;        

// --------------------------------------------------------------------------------
// Internet Property Tag Table (Sorted by Name)
// --------------------------------------------------------------------------------
typedef struct tagSYMBOLTABLE {
    ULONG               cSymbols;       // Number of elements in prgTag
    ULONG               cAlloc;         // Number of elements allocated in prgTag
    LPPROPSYMBOL       *prgpSymbol;     // Array of pointers to inet properties
} SYMBOLTABLE, *LPSYMBOLTABLE;

// --------------------------------------------------------------------------------
// CPropertySymbolCache
// --------------------------------------------------------------------------------
class CPropertySymbolCache : public IMimePropertySchema
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPropertySymbolCache(void);
    ~CPropertySymbolCache(void);

    // -------------------------------------------------------------------
    // IUnknown Members
    // -------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------
    // IMimePropertySchema Members
    // -------------------------------------------------------------------
    STDMETHODIMP RegisterProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber, VARTYPE vtDefault, LPDWORD pdwPropId);
    STDMETHODIMP ModifyProperty(LPCSTR pszName, DWORD dwFlags, DWORD dwRowNumber, VARTYPE vtDefault);
    STDMETHODIMP RegisterAddressType(LPCSTR pszName, LPDWORD pdwAdrType);
    STDMETHODIMP GetPropertyId(LPCSTR pszName, LPDWORD pdwPropId);
    STDMETHODIMP GetPropertyName(DWORD dwPropId, LPSTR *ppszName);

    // -------------------------------------------------------------------
    // CPropertySymbolCache Members
    // -------------------------------------------------------------------
    HRESULT Init(void);
    HRESULT HrOpenSymbol(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol);
    HRESULT HrOpenSymbol(DWORD dwAdrType, LPPROPSYMBOL *ppSymbol);

    // -------------------------------------------------------------------
    // GetCount
    // -------------------------------------------------------------------
    ULONG GetCount(void) {
        
        m_lock.ShareLock();
        ULONG c = m_rTable.cSymbols;
        m_lock.ShareUnlock();
        return c;
    }
        
private:
    // -------------------------------------------------------------------
    // Private Utilities
    // -------------------------------------------------------------------
    HRESULT _HrOpenSymbolWithLockOption(LPCSTR pszName, BOOL fCreate, LPPROPSYMBOL *ppSymbol,BOOL fLockOption);
    void    _FreeTableElements(void);
    void    _FreeSymbol(LPPROPSYMBOL pSymbol);
    void    _SortTableElements(LONG left, LONG right);
    HRESULT _HrFindSymbol(LPCSTR pszName, LPPROPSYMBOL *ppSymbol);
    ULONG   _UlComputeHashIndex(LPCSTR pszName, ULONG cchName);
    HRESULT _HrGetParameterLinkSymbol(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol);
    HRESULT _HrGetParameterLinkSymbolWithLockOption(LPCSTR pszName, ULONG cchName, LPPROPSYMBOL *ppSymbol,BOOL fLockOption);
	
private:
    // -------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------
    LONG                m_cRef;               // Reference Count
    DWORD               m_dwNextPropId;       // NextProperty Id to be assigned
    DWORD               m_cSymbolsInit;       // Base symbol propert id for new props
    SYMBOLTABLE         m_rTable;             // Property Symbol Table
    LPPROPSYMBOL        m_prgIndex[PID_LAST]; // Index of Known Property Symbols
    CExShareLock        m_lock;               //Thread Safety
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT HrIsValidPropFlags(DWORD dwFlags);
HRESULT HrIsValidSymbol(LPCPROPSYMBOL pSymbol);
WORD    WGetHashTableIndex(LPCSTR pszName, ULONG cchName);

                                                                                     
#endif // __SYMCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\textstm.cpp ===
// --------------------------------------------------------------------------------
// Textstm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "textstm.h"
#include "stmlock.h"

// --------------------------------------------------------------------------------
// CTextStream::CTextStream
// --------------------------------------------------------------------------------
CTextStream::CTextStream(void)
{
    ZeroMemory(&m_rInfo, sizeof(TEXTSTREAMINFO));
}

// --------------------------------------------------------------------------------
// CTextStream::~CTextStream
// --------------------------------------------------------------------------------
CTextStream::~CTextStream(void)
{
    Free();
}

// --------------------------------------------------------------------------------
// CTextStream::Free
// --------------------------------------------------------------------------------
void CTextStream::Free(void)
{
    // Do i need to free the line
    if (m_rInfo.pszLine && m_rInfo.pszLine != m_rInfo.szLine)
        MemFree(m_rInfo.pszLine);

    // Release the stream
    if (m_rInfo.pStream)
    {
        // Return to original position
        HrStreamSeekSet(m_rInfo.pStream, m_rInfo.iPos);

        // Release it
        m_rInfo.pStream->Release();
    }

    // Release CStreamLockBytes
    SafeRelease(m_rInfo.pStmLock);

    // Clear
    ZeroMemory(&m_rInfo, sizeof(TEXTSTREAMINFO));
}

// --------------------------------------------------------------------------------
// CTextStream::HrInit
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrInit(IStream *pStream, CStreamLockBytes *pStmLock)
{
    // Locals
    HRESULT     hr=S_OK;

    // Better have a stream
	Assert(pStream);
	if (NULL == pStream)
		return TrapError(E_INVALIDARG);

    // Add Ref the Stream
    m_rInfo.pStream = pStream;
	m_rInfo.pStream->AddRef();

    // Save LockBytes...
    if (pStmLock)
    {
        m_rInfo.pStmLock = pStmLock;
        m_rInfo.pStmLock->AddRef();
    }

    // Get the streams current position
    CHECKHR(hr = HrGetStreamPos(m_rInfo.pStream, &m_rInfo.iPos));

    // This will be the same as iBufferStart...
    m_rInfo.iBufferStart = m_rInfo.iPos;

    // Allocate initial line buffer
    m_rInfo.cbLineAlloc = sizeof(m_rInfo.szLine);
    m_rInfo.pszLine = m_rInfo.szLine;

    // Init counters
    m_rInfo.iBuffer = 0;
    m_rInfo.cbBuffer = 0;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::HrGetNextBuffer
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrGetNextBuffer(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Do we need to read a line from the stream ?
    Assert(m_rInfo.iBuffer <= m_rInfo.cbBuffer);
    if (m_rInfo.iBuffer == m_rInfo.cbBuffer)
    {
        // Get Buffer Start Offset
        CHECKHR(hr = HrGetStreamPos(m_rInfo.pStream, &m_rInfo.iBufferStart));
        Assert(m_rInfo.iPos == m_rInfo.iBufferStart);

        // Read a block from the stream
        CHECKHR(hr = m_rInfo.pStream->Read(m_rInfo.szBuffer, 4096, &m_rInfo.cbBuffer));

        // Reset buffer index
        m_rInfo.iBuffer = 0;
    }
    else
        Assert(m_rInfo.iPos == m_rInfo.iBufferStart + m_rInfo.iBuffer);


exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::HrReadLine
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrReadLine(LPSTR *ppszLine, ULONG *pcbLine)
{
    // Locals
    HRESULT  hr=S_OK;
    CHAR     ch, chEndOfLine, chPrev='\0';
    ULONG    cbRead, iStart;
    BOOL     fEndOfLine=FALSE;

    // Init
    *ppszLine = NULL;
    *pcbLine = m_rInfo.cbLine = 0;

    // Do the loop
    while(!fEndOfLine)
    {
        // Get next buffer
        CHECKHR(hr = HrGetNextBuffer());

        // Nothing Read ?
        if (m_rInfo.cbBuffer == 0)
            break;

        // Seek to first '\n'
        iStart = m_rInfo.iBuffer;

        // While we have data
        while(m_rInfo.iBuffer < m_rInfo.cbBuffer)
        {
            // Get Character
            ch = *(m_rInfo.szBuffer + m_rInfo.iBuffer);

            // Convert NULL's to dots
            if ('\0' == ch)
                ch = '.';

            // Next Character
            m_rInfo.iBuffer++;

            // New Line
            if (chLF == ch)
            {
                chPrev = ch;
                chEndOfLine = ch;
                fEndOfLine = TRUE;
                break;
            }

            // Otherwise, if previous character was a '\r', this is an end of line
            else if (chCR == chPrev)
            {
                chPrev = chLF;
                m_rInfo.iBuffer--;
                chEndOfLine = chLF;
                fEndOfLine = TRUE;
                break;
            }

            // Save Previous Character
            chPrev = ch;
        }

        // Number of bytes Read
        cbRead = (m_rInfo.iBuffer - iStart);

        // Increment Position
        m_rInfo.iPos += cbRead;

        // Do we need to realloc the line buffer ?
        if (m_rInfo.cbLine + cbRead + 2 > m_rInfo.cbLineAlloc)
        {
            // Fixup pszLine
            if (m_rInfo.pszLine == m_rInfo.szLine)
            {
                // Null It
                m_rInfo.pszLine = NULL;

                // Allocate it to m_rInfo.cbLine
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.pszLine, m_rInfo.cbLine + 1));

                // Copy static buffer
                CopyMemory(m_rInfo.pszLine, m_rInfo.szLine, m_rInfo.cbLine);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rInfo.cbLineAlloc = m_rInfo.cbLine + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rInfo.pszLine, m_rInfo.cbLineAlloc));
        }

        // Copy the data
        CopyMemory(m_rInfo.pszLine + m_rInfo.cbLine, m_rInfo.szBuffer + iStart, cbRead);

        // Update Counters and indexes
        m_rInfo.cbLine += cbRead;

        // If End of line and last character was a '\r', append a '\n'
        if (TRUE == fEndOfLine)
        {
            // Better have something in the line
            Assert(m_rInfo.cbLine);

            // If line ended with a '\r'
            if (chCR == chEndOfLine)
            {
                // Better have room for one more char
                Assert(m_rInfo.cbLine + 1 < m_rInfo.cbLineAlloc);

                // Append a '\n'
                m_rInfo.pszLine[m_rInfo.cbLine] = chLF;

                // Increment Length
                m_rInfo.cbLine++;
            }

            // Otherwise...
            else
            {
                // Line better have ended with a \n
                Assert(chLF == chEndOfLine && chLF == m_rInfo.pszLine[m_rInfo.cbLine - 1]);

                // If Previous Character was not a \r 
                if (m_rInfo.cbLine < 2 || chCR != m_rInfo.pszLine[m_rInfo.cbLine - 2])
                {
                    // Convert last char from \n to a \r
                    m_rInfo.pszLine[m_rInfo.cbLine - 1] = chCR;

                    // Better have room for one more char
                    Assert(m_rInfo.cbLine + 1 < m_rInfo.cbLineAlloc);

                    // Append a '\n'
                    m_rInfo.pszLine[m_rInfo.cbLine] = chLF;

                    // Increment Length
                    m_rInfo.cbLine++;
                }
            }
        }
    }

    // A little check
    Assert(fEndOfLine ? m_rInfo.cbLine >= 2 && chLF == m_rInfo.pszLine[m_rInfo.cbLine-1] && chCR == m_rInfo.pszLine[m_rInfo.cbLine-2] : TRUE);

    // Null terminator
    m_rInfo.pszLine[m_rInfo.cbLine] = '\0';

    // Set return values
    *ppszLine = m_rInfo.pszLine;
    *pcbLine = m_rInfo.cbLine;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::HrReadHeaderLine
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrReadHeaderLine(LPSTR *ppszHeader, ULONG *pcbHeader, LONG *piColonPos)
{
    // Locals
    HRESULT   hr=S_OK;
    BOOL      fEndOfLine=FALSE;
    CHAR      ch, chPrev='\0';
    ULONG     cbRead=0, iStart, i;

    // Init
    *piColonPos = -1;
    *ppszHeader = NULL;
    *pcbHeader = m_rInfo.cbLine = 0;

    // Do the loop
    while(1)
    {
        // Get next buffer
        CHECKHR(hr = HrGetNextBuffer());

        // Nothing Read ?
        if (m_rInfo.cbBuffer == 0)
            break;

        // Reset fSeenN
        fEndOfLine = FALSE;

        // Initialize
        iStart = m_rInfo.iBuffer;

        // Seek to first '\n'
        while (m_rInfo.iBuffer < m_rInfo.cbBuffer)
        {
            // Get Character
            ch = *(m_rInfo.szBuffer + m_rInfo.iBuffer);

            // Convert Nulls to '.'
            if ('\0' == ch)
                ch = '.';

            // Goto next character
            m_rInfo.iBuffer++;

            // New Line
            if (chLF == ch)
            {
                chPrev = ch;
                fEndOfLine = TRUE;
                break;
            }

            // Otherwise, if previous character was a '\r', then end of line
            else if (chCR == chPrev)
            {
                m_rInfo.iBuffer--;
                chPrev = '\0';
                break;
            }

            // Save Previous Character
            chPrev = ch;
        }

        // Number of bytes Read
        cbRead = (m_rInfo.iBuffer - iStart);

        // Increment Position
        m_rInfo.iPos += cbRead;

        // Adjust cbRead to remove CRLF
        if (cbRead && chLF == m_rInfo.szBuffer[iStart + cbRead - 1])
            cbRead--;
        if (cbRead && chCR == m_rInfo.szBuffer[iStart + cbRead - 1])
            cbRead--;

        // Do we need to realloc the line buffer ?
        if (m_rInfo.cbLine + cbRead + 1 > m_rInfo.cbLineAlloc)
        {
            // Fixup pszLine
            if (m_rInfo.pszLine == m_rInfo.szLine)
            {
                // Null It
                m_rInfo.pszLine = NULL;

                // Allocate it to m_rInfo.cbLine
                CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.pszLine, m_rInfo.cbLine + 1));

                // Copy static buffer
                CopyMemory(m_rInfo.pszLine, m_rInfo.szLine, m_rInfo.cbLine);
            }

            // Always Add a little extra to reduce the number of allocs
            m_rInfo.cbLineAlloc = m_rInfo.cbLine + cbRead + 256;

            // Realloc or alloc new
            CHECKHR(hr = HrRealloc((LPVOID *)&m_rInfo.pszLine, m_rInfo.cbLineAlloc));
        }

        // Copy the data
        CopyMemory(m_rInfo.pszLine + m_rInfo.cbLine, m_rInfo.szBuffer + iStart, cbRead);

        // Increment line byte count
        m_rInfo.cbLine += cbRead;

        // If fSeenN, then check for continuation line (i.e. next character is ' ' or '\t'
        if (fEndOfLine)
        {
            // Get next buffer
            CHECKHR(hr = HrGetNextBuffer());

            // Compare for continuation
            ch = m_rInfo.szBuffer[m_rInfo.iBuffer];

            // If line starts with a TAB or a space, this is a continuation line, keep reading
            if ((ch != ' ' && ch != '\t') || (0 == cbRead && 0 == m_rInfo.cbLine))
                break;
            else
            {
                // Step Over the space or tab...
                m_rInfo.iBuffer++;
                m_rInfo.iPos++;

                // Get next buffer
                CHECKHR(hr = HrGetNextBuffer());

                // If Next character is a \r or \n, then stop, NETSCAPE bug
                ch = m_rInfo.szBuffer[m_rInfo.iBuffer];
                if (chCR == ch || chLF == ch)
                    break;
            }
        }
    }

    // A little check
    Assert(chLF != m_rInfo.pszLine[m_rInfo.cbLine-1] && chCR != m_rInfo.pszLine[m_rInfo.cbLine-1]);

    // Null terminator
    *(m_rInfo.pszLine + m_rInfo.cbLine) = '\0';

    // Lets locate the colon
    for (i=0; i<m_rInfo.cbLine; i++)
    {
        // Colon ?
        if (':' == m_rInfo.pszLine[i])
        {
            *piColonPos = i;
            break;
        }
    }

    // Set return values
    *ppszHeader = m_rInfo.pszLine;
    *pcbHeader = m_rInfo.cbLine;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::HrGetSize
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrGetSize(ULONG *pcb)
{
    // Locals
	HRESULT		hr;
    ULONG		iStmPos;

    // State Check
    Assert(m_rInfo.iPos == m_rInfo.iBufferStart + m_rInfo.iBuffer);

	// get current pos
    CHECKHR (hr = HrGetStreamPos (m_rInfo.pStream, &iStmPos));

	// Get stream size
    CHECKHR (hr = HrGetStreamSize (m_rInfo.pStream, pcb));

	// Re-seek to original position
    CHECKHR (hr = HrStreamSeekSet (m_rInfo.pStream, iStmPos));

exit:
	// Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::UlGetPos
// --------------------------------------------------------------------------------
ULONG   CTextStream::UlGetPos(void)
{
    // Return Pos
    return m_rInfo.iPos;
}

// --------------------------------------------------------------------------------
// CTextStream::HrGetStreamLockBytes
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrGetStreamLockBytes(CStreamLockBytes **ppStmLock)
{
    // Locals
    HRESULT     hr=S_OK;

    // Doesn't Exist...
    if (NULL == m_rInfo.pStmLock)
    {
        // Allocate It
        CHECKALLOC(m_rInfo.pStmLock = new CStreamLockBytes(m_rInfo.pStream));
    }

    // Return It
    *ppStmLock = m_rInfo.pStmLock;
    (*ppStmLock)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CTextStream::GetStream
// --------------------------------------------------------------------------------
void CTextStream::GetStream(IStream **ppStream)
{
    Assert(m_rInfo.pStream && ppStream);
    (*ppStream) = m_rInfo.pStream;
    (*ppStream)->AddRef();
}

// --------------------------------------------------------------------------------
// CTextStream::HrSeek
// --------------------------------------------------------------------------------
HRESULT CTextStream::HrSeek(ULONG iPos)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fResetCache=FALSE;
    ULONG       ulOffset;

    // State Check
    Assert(m_rInfo.iPos == m_rInfo.iBufferStart + m_rInfo.iBuffer);

    // Already at the requested position
    if (iPos == m_rInfo.iPos)
        goto exit;

    // Less than current position
    if (iPos < m_rInfo.iPos)
    {
        // Compute Offset from current location
        ulOffset = m_rInfo.iPos - iPos;

        // Less than beginning
        if (ulOffset > m_rInfo.iBuffer)
            fResetCache = TRUE;
        else
        {
            Assert(ulOffset <= m_rInfo.iBuffer);
            m_rInfo.iBuffer -= ulOffset;
        }
    }

    // Else iPos > m_rInfo.iPos
    else
    {
        // Compute Offset from current location
        ulOffset = iPos - m_rInfo.iPos;

        // Less than beginning
        if (m_rInfo.iBuffer + ulOffset > m_rInfo.cbBuffer)
            fResetCache = TRUE;
        else
        {
            m_rInfo.iBuffer += ulOffset;
            Assert(m_rInfo.iBuffer <= m_rInfo.cbBuffer);
        }
    }

    // Reset the cache
    if (fResetCache)
    {
        // Seek the stream...
        CHECKHR(hr = HrStreamSeekSet(m_rInfo.pStream, iPos));

        // Empty current line and buffer
        *m_rInfo.pszLine = *m_rInfo.szBuffer = '\0';

        // No buffer
        m_rInfo.iBufferStart = m_rInfo.cbLine = m_rInfo.iBuffer = m_rInfo.cbBuffer = 0;
    }

    // Save this position
    m_rInfo.iPos = iPos;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\textstm.h ===
// --------------------------------------------------------------------------------
// Textstm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __TEXTSTM_H
#define __TEXTSTM_H

// --------------------------------------------------------------------------------
// Depends On
// --------------------------------------------------------------------------------
#include "stmutil.h"

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CStreamLockBytes;

// --------------------------------------------------------------------------------
// TEXTSTREAMINFO
// --------------------------------------------------------------------------------
typedef struct tagTEXTSTREAMINFO {
    CStreamLockBytes   *pStmLock;
    LPSTREAM            pStream;
    ULONG               iPos;
    ULONG               cbLineAlloc;
    CHAR                szLine[1024];
    LPSTR               pszLine;
    ULONG               cbLine;
    ULONG               iLine;
    CHAR                szBuffer[4096];
    ULONG               iBuffer;
    ULONG               iBufferStart;
    ULONG               cbBuffer;
} TEXTSTREAMINFO;

// --------------------------------------------------------------------------------
// CTextStream
// --------------------------------------------------------------------------------
class CTextStream
{
private:
    // ----------------------------------------------------------------------------
    // Text Stream Info
    // ----------------------------------------------------------------------------
    TEXTSTREAMINFO m_rInfo;

    // ----------------------------------------------------------------------------
    // Fill next buffer
    // ----------------------------------------------------------------------------
    HRESULT HrGetNextBuffer(void);

public:
    // ----------------------------------------------------------------------------
    // CTextStream
    // ----------------------------------------------------------------------------
    CTextStream(void);
    ~CTextStream(void);

    // ----------------------------------------------------------------------------
    // Methods
    // ----------------------------------------------------------------------------
    HRESULT HrInit(IStream *pStream, CStreamLockBytes *pStmLock);
    void    Free(void);
    HRESULT HrReadLine(LPSTR *ppszLine, ULONG *pcbLine);
    HRESULT HrGetSize(ULONG *pcb);
    HRESULT HrSeek(ULONG iPos);
    HRESULT HrReadHeaderLine(LPSTR *ppszHeader, ULONG *pcbHeader, LONG *piColonPos);
    ULONG   UlGetPos(void);
    void    GetStream(IStream **ppStream);
    HRESULT HrGetStreamLockBytes(CStreamLockBytes **ppStmLock);
};

#endif // __TEXTSTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\trigger.cpp ===
// --------------------------------------------------------------------------------
// Trigger.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "containx.h"
#include "symcache.h"
#include "containx.h"
#include "stackstr.h"
#include "variantx.h"
#include "mimeapi.h"
#ifndef MAC
#include <shlwapi.h>
#endif  // !MAC
#include "demand.h"

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_FILENAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_FILENAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fUseProperty;
    LPWSTR          pszExt;
    LPWSTR          pszFileName=NULL;
    LPPROPSYMBOL    pSymbol;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        if (pContainer->_HrIsTriggerCaller(PID_PAR_FILENAME, IST_DELETEPROP) == S_FALSE)
        {
            pContainer->DeleteProp(SYM_PAR_FILENAME);
        }
        break;

    case IST_POSTSETPROP:
        // Update PID_PAR_NAME, if it didn't generate this
        if (pContainer->_HrIsTriggerCaller(PID_PAR_NAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_PAR_NAME, dwFlags, pValue);

        // Update PAR_FILENAME, if it didn't generate this
        if (pContainer->_HrIsTriggerCaller(PID_PAR_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_PAR_FILENAME, dwFlags, pValue);
        break;

    case IST_POSTGETPROP:
        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;

    case IST_GETDEFAULT:
        // Try to get PID_PAR_FILENAME first
        if (FAILED(pContainer->GetPropW(SYM_PAR_FILENAME, &pszFileName)))
        {
            // Try to get PID_PAR_NAME
            if (FAILED(pContainer->GetPropW(SYM_PAR_NAME, &pszFileName)))
            {
                hr = MIME_E_NO_DATA;
                goto exit;
            }
            else
                pSymbol = SYM_PAR_NAME;
        }
        else
            pSymbol = SYM_PAR_FILENAME;

        // Set Source
        fUseProperty = TRUE;

        // Locate the extension of the file
        pszExt = PathFindExtensionW(pszFileName);

        // If .com
        if (pszExt && StrCmpIW(pszExt, L".com") == 0)
        {
            // Locals
            LPWSTR pszCntType=NULL;
            LPWSTR pszSubType=NULL;

            // Get the file information
            if (SUCCEEDED(MimeOleGetFileInfoW(pszFileName, &pszCntType, &pszSubType, NULL, NULL, NULL)))
            {
                // Extension is .com and content types don't match what is in the body
                if (pContainer->IsContentTypeW(pszCntType, pszSubType) == S_FALSE)
                {
                    // Generate It
                    if (SUCCEEDED(pContainer->_HrGenerateFileName(NULL, dwFlags, pValue)))
                        fUseProperty = FALSE;
                }
            }

            // Cleanup
            SafeMemFree(pszCntType);
            SafeMemFree(pszSubType);
        }

        // Raid-63402: OE: cc: mail problems with OE
        // Empty file extension ?
        else if (NULL == pszExt || L'\0' == *pszExt)
        {
            // Generate a new filename
            CHECKHR(hr = pContainer->_HrGenerateFileName(pszFileName, dwFlags, pValue));

            // Done
            fUseProperty = FALSE;
        }

        // Return per user request
        if (fUseProperty)
        {
            // Use the property
            CHECKHR(hr = pContainer->GetProp(pSymbol, dwFlags, pValue));
        }

        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}
             
// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_GENFNAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_GENFNAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pProperty;
    LPSTR       pszDefExt=NULL,
                pszData=NULL,
                pszFree=NULL,
                pszSuggest=NULL;
    LPCSTR      pszCntType=NULL;
    MIMEVARIANT rSource;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTGETPROP:
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;

    case IST_GETDEFAULT:
        // Try to just get the normal filename
        if (SUCCEEDED(TRIGGER_ATT_FILENAME(pContainer, IST_GETDEFAULT, dwFlags, pValue, NULL)))
            goto exit;

        // Call back into the container
        CHECKHR(hr = pContainer->_HrGenerateFileName(NULL, dwFlags, pValue));

        // Cleanup the file name
        if (!ISFLAGSET(dwFlags, PDF_ENCODED))
            MimeVariantCleanupFileName(pContainer->GetWindowsCP(), pValue);
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszData);
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_NORMSUBJ
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_NORMSUBJ(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    MIMEVARIANT rSubject;
    MIMEVARIANT rNormal;
    LPSTR       pszNormal,
                pszFree=NULL;
    LPWSTR      pszNormalW,
                pszFreeW=NULL;
    ULONG       i=0,
                cch=0;
    LPPROPERTY  pSubject;

    // Handle Dispatch Type
    if (IST_GETDEFAULT == tyTrigger)
    {
        // Get Subject
        pSubject = pContainer->m_prgIndex[PID_HDR_SUBJECT];

        // No Data
        if (NULL == pSubject)
        {
            hr = MIME_E_NO_DATA;
            goto exit;
        }

        switch (pValue->type)
        {
            case MVT_STRINGA:
            {
                // Set Subject Type
                rSubject.type = MVT_STRINGA;

                // Return per user request
                CHECKHR(hr = pContainer->HrConvertVariant(pSubject, CVF_NOALLOC, &rSubject));

                // Set Normal subject
                pszFree = rSubject.fCopy ? NULL : rSubject.rStringA.pszVal;
                pszNormal = rSubject.rStringA.pszVal;

                // Less than 5 "xxx: "
                if (rSubject.rStringA.cchVal >= 4)
                {
                    // 1, 2, 3, 4 spaces followed by a ':' then a space
                    while (cch < 7 && i < rSubject.rStringA.cchVal)
                    {
                        // Skip Lead Bytes
                        if (IsDBCSLeadByte(rSubject.rStringA.pszVal[i]))
                        {
                            i++;
                            cch++;
                        }

                        // Colon
                        else if (':' == rSubject.rStringA.pszVal[i])
                        {
                            if (i+1 >= rSubject.rStringA.cchVal)
                            {
                                i++;
                                pszNormal = (LPSTR)(rSubject.rStringA.pszVal + i);
                                break;
                            }

                            else if (cch <= 4 && ' ' == rSubject.rStringA.pszVal[i+1])
                            {
                                i++;
                                pszNormal = PszSkipWhiteA((LPSTR)(rSubject.rStringA.pszVal + i));
                                break;
                            }
                            else
                                break;
                        }

                        // Next Character
                        i++;
                        cch++;
                    }    
                }

                // Reset Source
                if (pszNormal != rSubject.rStringA.pszVal)
                {
                    rSubject.rStringA.pszVal = pszNormal;
                    rSubject.rStringA.cchVal = lstrlen(pszNormal);
                }
                break;
            }

            case MVT_STRINGW:
            {
                // Set Subject Type
                rSubject.type = MVT_STRINGW;

                // Return per user request
                CHECKHR(hr = pContainer->HrConvertVariant(pSubject, CVF_NOALLOC, &rSubject));

                // Set Normal subject
                pszFreeW = rSubject.fCopy ? NULL : rSubject.rStringW.pszVal;
                pszNormalW = rSubject.rStringW.pszVal;

                // Less than 5 "xxx: "
                if (rSubject.rStringW.cchVal >= 4)
                {
                    // 1, 2, or 3 spaces followed by a ':' then a space
                    while (cch < 7 && i < rSubject.rStringW.cchVal)
                    {
                        // Colon
                        if (L':' == rSubject.rStringW.pszVal[i])
                        {
                            if (i+1 >= rSubject.rStringW.cchVal)
                            {
                                i++;
                                pszNormalW = (LPWSTR)(rSubject.rStringW.pszVal + i);
                                break;
                            }

                            else if (cch <= 4 && L' ' == rSubject.rStringW.pszVal[i+1])
                            {
                                i++;
                                pszNormalW = PszSkipWhiteW((LPWSTR)(rSubject.rStringW.pszVal + i));
                                break;
                            }
                            else
                                break;
                        }

                        // Next Character
                        i++;
                        cch++;
                    }    
                }

                // Reset Source
                if (pszNormalW != rSubject.rStringW.pszVal)
                {
                    rSubject.rStringW.pszVal = pszNormalW;
                    rSubject.rStringW.cchVal = lstrlenW(pszNormalW);
                }
                break;
            }
            default:
                AssertSz(FALSE, "Didn't prepare for this type!!!");
                break;
        }

        // Return per user request
        CHECKHR(hr = pContainer->HrConvertVariant(pSubject->pSymbol, pSubject->pCharset, IET_DECODED, dwFlags, 0, &rSubject, pValue));
    }

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszFreeW);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_SUBJECT
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_SUBJECT(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    if (IST_DELETEPROP == tyTrigger)
        pContainer->DeleteProp(SYM_ATT_NORMSUBJ);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_CNTTYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_CNTTYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    CStringParser   cString;
    CHAR            chToken;
    MIMEVARIANT     rValue;
    LPSTR           pszCntType=NULL;

    // Invalid Arg
    Assert(pContainer);

    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_ATT_PRITYPE);
        pContainer->DeleteProp(SYM_ATT_SUBTYPE);
        break;

    case IST_POSTSETPROP:
        // If not generated from corresponding atributes
        if (pContainer->_HrIsTriggerCaller(PID_ATT_PRITYPE, IST_POSTSETPROP) == S_OK || 
            pContainer->_HrIsTriggerCaller(PID_ATT_SUBTYPE, IST_POSTSETPROP) == S_OK)
            goto exit;

        // Validate the Variant
        if (ISSTRINGA(pValue))
        {
            // Locals
            CHAR szPriType[255];

            // Set the Members
            cString.Init(pValue->rStringA.pszVal, pValue->rStringA.cchVal, PSF_NOTRAILWS | PSF_NOCOMMENTS);

            // Set Parse Tokens
            chToken = cString.ChParse("/");
            if ('\0' == chToken && 0 == cString.CchValue())
                goto exit;

            // Setup the Variant
            rValue.type = MVT_STRINGA;
            rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
            rValue.rStringA.cchVal = cString.CchValue();

            // Save Primary Type
            lstrcpyn(szPriType, rValue.rStringA.pszVal, ARRAYSIZE(szPriType));

            // Add New attribute...
            CHECKHR(hr = pContainer->SetProp(SYM_ATT_PRITYPE, 0, &rValue));

            // Raid-52462: outlook express: mail with bad content type header comes in as an attachment
            // Seek end of sub content-type
            chToken = cString.ChParse(" ;");
            if (0 == cString.CchValue())
            {
                // Locals
                LPCSTR pszSubType = PszDefaultSubType(szPriType);
                ULONG cchCntType;

                // Set Default SubType
                CHECKHR(hr = pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

                // Build ContentType
                CHECKALLOC(pszCntType = PszAllocA(lstrlen(szPriType) + lstrlen(pszSubType) + 2));

                // Format the ContentType
                cchCntType = wsprintf(pszCntType, "%s/%s", szPriType, pszSubType);

                // Setup a variant
                rValue.type = MVT_STRINGA;
                rValue.rStringA.pszVal = (LPSTR)pszCntType;
                rValue.rStringA.cchVal = cchCntType;

                // Store the variant data
                Assert(pContainer->m_prgIndex[PID_HDR_CNTTYPE]);
                CHECKHR(hr = pContainer->_HrStoreVariantValue(pContainer->m_prgIndex[PID_HDR_CNTTYPE], 0, &rValue));

                // Done
                goto exit;
            }

            // Setup the Variant
            rValue.rStringA.pszVal = (LPSTR)cString.PszValue();
            rValue.rStringA.cchVal = cString.CchValue();

            // Add New attribute...
            CHECKHR(hr = pContainer->SetProp(SYM_ATT_SUBTYPE, 0, &rValue));

            // We should be done
            Assert(';' == chToken || '(' == chToken || '\0' == chToken || ' ' == chToken);
        }
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_MIME_TEXT_PLAIN);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pszCntType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_PRITYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_PRITYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pSubType;
    LPSTR       pszSubType;
    ULONG       cchSubType;
    MIMEVARIANT rValue;

    // Define a Stack String
    STACKSTRING_DEFINE(rContentType, 255);

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        // If inside content type dispatch setprop
        if (pContainer->_HrIsTriggerCaller(PID_HDR_CNTTYPE, IST_POSTSETPROP) == S_OK)
            goto exit;

        // Asser Type
        Assert(pValue && ISSTRINGA(pValue));

        // Get pCntType
        pSubType = pContainer->m_prgIndex[PID_ATT_SUBTYPE];

        // Is the subtype set yet
        if (pSubType)
        {
            Assert(ISSTRINGA(&pSubType->rValue));
            pszSubType = pSubType->rValue.rStringA.pszVal;
            cchSubType = pSubType->rValue.rStringA.cchVal;
        }
        else
        {
            pszSubType = (LPSTR)STR_SUB_PLAIN;
            cchSubType = lstrlen(STR_SUB_PLAIN);
        }

        // Make Sure the stack string can hold the data
        STACKSTRING_SETSIZE(rContentType, (cchSubType + pValue->rStringA.cchVal + 2));

        // Init rValue
        ZeroMemory(&rValue, sizeof(MIMEVARIANT));

        // Format the content type
        rValue.rStringA.cchVal = wsprintf(rContentType.pszVal, "%s/%s", pValue->rStringA.pszVal, pszSubType);

        // Setup the value
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = rContentType.pszVal;

        // SetProp
        CHECKHR(hr = pContainer->SetProp(SYM_HDR_CNTTYPE, 0, &rValue));
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_CNT_TEXT;
        rValue.rStringA.cchVal = lstrlen(STR_CNT_TEXT);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rContentType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_SUBTYPE
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_SUBTYPE(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    LPPROPERTY  pPriType;
    LPSTR       pszPriType;
    ULONG       cchPriType;
    MIMEVARIANT rValue;

    // Define a Stack String
    STACKSTRING_DEFINE(rContentType, 255);

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        // If inside content type dispatch setprop
        if (pContainer->_HrIsTriggerCaller(PID_HDR_CNTTYPE, IST_POSTSETPROP) == S_OK)
            goto exit;

        // Asser Type
        Assert(pValue && ISSTRINGA(pValue));

        // Get pCntType
        pPriType = pContainer->m_prgIndex[PID_ATT_PRITYPE];

        // Is the subtype set yet
        if (pPriType)
        {
            Assert(ISSTRINGA(&pPriType->rValue));
            pszPriType = pPriType->rValue.rStringA.pszVal;
            cchPriType = pPriType->rValue.rStringA.cchVal;
        }
        else
        {
            pszPriType = (LPSTR)STR_CNT_TEXT;
            cchPriType = lstrlen(STR_CNT_TEXT);
        }

        // Make Sure the stack string can hold the data
        STACKSTRING_SETSIZE(rContentType, cchPriType + pValue->rStringA.cchVal + 2);

        // Init rValue
        ZeroMemory(&rValue, sizeof(MIMEVARIANT));

        // Format the content type
        rValue.rStringA.cchVal = wsprintf(rContentType.pszVal, "%s/%s", pszPriType, pValue->rStringA.pszVal);

        // Setup the value
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = rContentType.pszVal;

        // SetProp
        CHECKHR(hr = pContainer->SetProp(SYM_HDR_CNTTYPE, 0, &rValue));
        break;

    case IST_GETDEFAULT:
        rValue.type = MVT_STRINGA;
        rValue.rStringA.pszVal = (LPSTR)STR_SUB_PLAIN;
        rValue.rStringA.cchVal = lstrlen(STR_SUB_PLAIN);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTTYPE, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
        break;
    }

exit:
    // Cleanup
    STACKSTRING_FREE(rContentType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_HDR_CNTXFER
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_HDR_CNTXFER(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_GETDEFAULT:
        rSource.type = MVT_STRINGA;
        rSource.rStringA.pszVal = (LPSTR)STR_ENC_7BIT;
        rSource.rStringA.cchVal = lstrlen(STR_ENC_7BIT);
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_HDR_CNTXFER, NULL, IET_DECODED, dwFlags, 0, &rSource, pValue));
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_PAR_NAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_PAR_NAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_POSTSETPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_ATT_FILENAME, dwFlags, pValue);
        break;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_PAR_FILENAME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_PAR_FILENAME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_DELETEPROP) == S_FALSE)
            pContainer->DeleteProp(SYM_ATT_FILENAME);
        break;

    case IST_POSTSETPROP:
        if (pContainer->_HrIsTriggerCaller(PID_ATT_FILENAME, IST_POSTSETPROP) == S_FALSE)
            pContainer->SetProp(SYM_ATT_FILENAME, dwFlags, pValue);
        break;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_SENTTIME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_SENTTIME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Handle Dispatch type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_DATE);
        break;

    case IST_POSTSETPROP:
        pContainer->SetProp(SYM_HDR_DATE, dwFlags, pValue);
        break;

    case IST_GETDEFAULT:
        // Raid-39471-Mail: Date showing as jan 01, 1601 in readnote for attached message
        if (FAILED(pContainer->GetProp(SYM_HDR_DATE, dwFlags, pValue)))
        {
            // Get Known Property
            LPPROPERTY pProperty = pContainer->m_prgIndex[PID_HDR_RECEIVED];
            if (pProperty && ISSTRINGA(&pProperty->rValue))
            {
                // Try Getting Sent Time
                CHECKHR(hr = pContainer->GetProp(SYM_ATT_RECVTIME, dwFlags, pValue));
            }
            else
            {
                // Locals
                SYSTEMTIME  st;
                MIMEVARIANT rValue;

                // Setup rValue
                rValue.type = MVT_VARIANT;
                rValue.rVariant.vt = VT_FILETIME;

                // Get current systemtime
                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &rValue.rVariant.filetime);

                // If the Conversion Fails, get the current time
                CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_SENTTIME, NULL, IET_DECODED, dwFlags, 0, &rValue, pValue));
            }
        }
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_RECVTIME
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_RECVTIME(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    LPMIMEVARIANT   pSource;
    LPPROPERTY      pProperty;

    // Handle Dispatch Type
    switch(tyTrigger)
    {
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_RECEIVED);
        break;

    case IST_GETDEFAULT:
        // Get Known Property
        pProperty = pContainer->m_prgIndex[PID_HDR_RECEIVED];
        if (NULL == pProperty || !ISSTRINGA(&pProperty->rValue))
        {
            // Try Getting Sent Time
            MimeOleGetSentTime(pContainer, dwFlags, pValue);
        }

        // Otherwise, try to convert it
        else
        {
            // If StringA
            if (MVT_STRINGA == pProperty->rValue.type)
            {
                // Find the first header which has a semi-colon in it
                while(1)
                {
                    // Seek to last colon
                    LPSTR psz = pProperty->rValue.rStringA.pszVal;
                    int i;
                    for (i = 0; psz[i] ; i++);
                    rSource.rStringA.pszVal = psz + i;  // set to end of string
                    for (; i >= 0 ; i--)
                    {
                        if (psz[i] == ';')
                        {
                            rSource.rStringA.pszVal = psz + i;
                            break;
                        }
                    }

                    if ('\0' == *rSource.rStringA.pszVal)
                    {
                        // No more values
                        if (NULL == pProperty->pNextValue)
                        {
                            // Try Getting Sent Time
                            MimeOleGetSentTime(pContainer, dwFlags, pValue);

                            // Done
                            goto exit;
                        }

                        // Goto next
                        pProperty = pProperty->pNextValue;
                    }

                    // Otherwise, we must have a good property
                    else
                        break;
                }

                // Step over ';
                rSource.rStringA.pszVal++;

                // Setup Source
                rSource.type = MVT_STRINGA;
                rSource.rStringA.cchVal = lstrlen(rSource.rStringA.pszVal);
                pSource = &rSource;
            }

            // Otherwise, just try to conver the current property data
            else
                pSource = &pProperty->rValue;

            // If the Conversion Fails, get the current time
            if (FAILED(pContainer->HrConvertVariant(SYM_ATT_RECVTIME, NULL, IET_DECODED, dwFlags, 0, pSource, pValue)))
            {
                // Try Getting Sent Time
                MimeOleGetSentTime(pContainer, dwFlags, pValue);
            }
        }
        break;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimePropertyContainer::TRIGGER_ATT_PRIORITY
// --------------------------------------------------------------------------------
HRESULT CMimePropertyContainer::TRIGGER_ATT_PRIORITY(LPCONTAINER pContainer, TRIGGERTYPE tyTrigger, 
    DWORD dwFlags, LPMIMEVARIANT pValue, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rSource;
    PROPVARIANT     rVariant;
    LPMIMEVARIANT   pSource;
    LPPROPERTY      pProperty;

    // Handle Dispatch type
    switch(tyTrigger)
    {
    // IST_VARIANT_TO_STRINGA
    case IST_VARIANT_TO_STRINGA:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_STRINGA == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        switch(pValue->rVariant.ulVal)
        {
        // IMSG_PRI_LOW
        case IMSG_PRI_LOW:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_LOW;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_LOW);
            break;

        // IMSG_PRI_HIGH
        case IMSG_PRI_HIGH:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_HIGH;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_HIGH);
            break;

        // IMSG_PRI_NORMAL
        default:
        case IMSG_PRI_NORMAL:
            pDest->rStringA.pszVal = (LPSTR)STR_PRI_MS_NORMAL;
            pDest->rStringA.cchVal = lstrlen(STR_PRI_MS_NORMAL);
            break;
        }
        break;

    // IST_VARIANT_TO_STRINGW
    case IST_VARIANT_TO_STRINGW:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_STRINGW == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        switch(pValue->rVariant.ulVal)
        {
        // IMSG_PRI_LOW
        case IMSG_PRI_LOW:
#ifndef WIN16
            pDest->rStringW.pszVal = L"Low";
#else
            pDest->rStringW.pszVal = "Low";
#endif // !WIN16
            pDest->rStringW.cchVal = 3;
            break;

        // IMSG_PRI_HIGH
        case IMSG_PRI_HIGH:
#ifndef WIN16
            pDest->rStringW.pszVal = L"High";
#else
            pDest->rStringW.pszVal = "High";
#endif // !WIN16
            pDest->rStringW.cchVal = 4;
            break;

        // IMSG_PRI_NORMAL
        default:
        case IMSG_PRI_NORMAL:
#ifndef WIN16
            pDest->rStringW.pszVal = L"Normal";
#else
            pDest->rStringW.pszVal = "Normal";
#endif // !WIN16
            pDest->rStringW.cchVal = 6;
            break;
        }
        break;

    // IST_VARIANT_TO_VARIANT
    case IST_VARIANT_TO_VARIANT:
        Assert(pValue && pDest && MVT_VARIANT == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pValue->rVariant.vt && VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Nice and Easy
        pDest->rVariant.ulVal = pValue->rVariant.ulVal;
        break;
    
    // IST_STRINGA_TO_VARIANT
    case IST_STRINGA_TO_VARIANT:
        Assert(pValue && pDest && MVT_STRINGA == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Priority From String
        pDest->rVariant.ulVal = PriorityFromStringA(pValue->rStringA.pszVal);
        break;

    // IST_STRINGW_TO_VARIANT
    case IST_STRINGW_TO_VARIANT:
        Assert(pValue && pDest && MVT_STRINGW == pValue->type && MVT_VARIANT == pDest->type);
        if (VT_UI4 != pDest->rVariant.vt)
        {
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Priority From String
        pDest->rVariant.ulVal = PriorityFromStringW(pValue->rStringW.pszVal);
        break;

    // IST_DELETEPROP
    case IST_DELETEPROP:
        pContainer->DeleteProp(SYM_HDR_XPRI);
        pContainer->DeleteProp(SYM_HDR_XMSPRI);
        break;

    // IST_POSTSETPROP
    case IST_POSTSETPROP:
        // Setup rSource
        rSource.type = MVT_VARIANT;
        rSource.rVariant.vt = VT_UI4;

        // Convert to User's Variant to a Integer Priority
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_PRIORITY, NULL, IET_DECODED, 0, 0, pValue, &rSource));

        // Setup rVariant
        rVariant.vt = VT_LPSTR;

        // Switch on priority
        switch(rSource.rVariant.ulVal)
        {
        case IMSG_PRI_LOW:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_LOW)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_LOW)); 
            break;

        case IMSG_PRI_NORMAL:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_NORMAL)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_NORMAL)); 
            break;

        case IMSG_PRI_HIGH:
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XMSPRI), STR_PRI_MS_HIGH)); 
            CHECKHR(hr = pContainer->SetProp(PIDTOSTR(PID_HDR_XPRI), STR_PRI_HIGH)); 
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }

        // Done
        break;

    // IST_GETDEFAULT
    case IST_GETDEFAULT:
        // Get the Priority Property
        pProperty = pContainer->m_prgIndex[PID_HDR_XPRI];
        if (NULL == pProperty)
            pProperty = pContainer->m_prgIndex[PID_HDR_XMSPRI];

        // No Data
        if (NULL == pProperty)
        {
            rSource.type = MVT_VARIANT;
            rSource.rVariant.vt = VT_UI4;
            rSource.rVariant.ulVal = IMSG_PRI_NORMAL;
            pSource = &rSource;
        }

        // Otherwise
        else
            pSource = &pProperty->rValue;

        // Convert to User's Variant
        CHECKHR(hr = pContainer->HrConvertVariant(SYM_ATT_PRIORITY, NULL, IET_DECODED, dwFlags, 0, pSource, pValue));

        // Done
        break;
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\variantx.cpp ===
// --------------------------------------------------------------------------------
// VariantX.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "variantx.h"
#include "wchar.h"
#include "internat.h"
#include "symcache.h"
#include "dllmain.h"
#include "containx.h"
#include <shlwapi.h>
#include "mimeapi.h"
#include "strconst.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Helper Prototypes
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteHeaderFormatW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteNameInDataA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT HrWriteNameInDataW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// International Conversion Prototypes
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPSTR *);
HRESULT Internat_StringA_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPWSTR *);
HRESULT Internat_StringW_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPWSTR *);
HRESULT Internat_StringW_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT, LPSTR *);

// --------------------------------------------------------------------------------
// Variant Conversion Function Prototype
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFNVARIANTCONVERT)(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// Converter Prototypes
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringA_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringA_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT StringW_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_StringA(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_StringW(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);
HRESULT Variant_To_Variant(LPVARIANTCONVERT, LPMIMEVARIANT, LPMIMEVARIANT);

// --------------------------------------------------------------------------------
// VCASSERTARGS - Common Invalid Arg Assert Macro
// --------------------------------------------------------------------------------
#define VCASSERTARGS(_typeSource, _typeDest) \
    Assert(pConvert && pSource && pDest && pSource->type == _typeSource); \
    if (MVT_STRINGA == _typeDest) \
        Assert(MVT_STRINGA == pDest->type || MVT_STREAM == pDest->type); \
    else if (MVT_STRINGW == _typeDest) \
        Assert(MVT_STRINGW == pDest->type || MVT_STREAM == pDest->type); \
    else \
        Assert(_typeDest == pDest->type);

// --------------------------------------------------------------------------------
// VARIANTCONVERTMAP
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERTMAP {
    PFNVARIANTCONVERT pfnConvertTo[MVT_LAST];
} VARIANTCONVERTMAP;

// --------------------------------------------------------------------------------
// PVC - Cast to PFNVARIANTCONVERT
// --------------------------------------------------------------------------------
#define PVC(_function) ((PFNVARIANTCONVERT)_function)

// --------------------------------------------------------------------------------
// Variant Conversion Map
// --------------------------------------------------------------------------------
static const VARIANTCONVERTMAP g_rgVariantX[MVT_LAST - 1] = {
    { NULL, NULL,                    NULL,                    NULL,                    NULL                    }, // MVT_EMPTY
    { NULL, PVC(StringA_To_StringA), PVC(StringA_To_StringW), PVC(StringA_To_Variant), PVC(StringA_To_StringA) }, // MVT_STRINGA / MVT_STREAM 
    { NULL, PVC(StringW_To_StringA), PVC(StringW_To_StringW), PVC(StringW_To_Variant), PVC(StringW_To_StringA) }, // MVT_STRINGW
    { NULL, PVC(Variant_To_StringA), PVC(Variant_To_StringW), PVC(Variant_To_Variant), PVC(Variant_To_StringA) }, // MVT_VARIANT
};

// --------------------------------------------------------------------------------
// _HrConvertVariant - Looks up the correct Variant Conversion function
// --------------------------------------------------------------------------------
#define _HrConvertVariant(_typeSource, _typeDest, _pConvert, _pSource, _pDest) \
    (*(g_rgVariantX[_typeSource].pfnConvertTo[_typeDest]))(_pConvert, _pSource, _pDest)

// --------------------------------------------------------------------------------
// HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT HrConvertVariant(
        /* in */        LPHEADOPTIONS       pOptions,
        /* in */        LPPROPSYMBOL        pSymbol,
        /* in */        LPINETCSETINFO      pCharset,
        /* in */        ENCODINGTYPE        ietSource,
        /* in */        DWORD               dwFlags, 
        /* in */        DWORD               dwState, 
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* out,opt */   BOOL               *pfRfc1522 /* = NULL */)
{
    // Locals
    HRESULT         hr=S_OK;
    VARIANTCONVERT  rConvert;

    // Invalid Arg
    Assert(pOptions && pSymbol && pSource && pDest && pOptions->pDefaultCharset);
    Assert(IET_ENCODED == ietSource || IET_DECODED == ietSource);

    // Init
    if (pfRfc1522)
        *pfRfc1522 = FALSE;

    // Failure
    if (!ISVALIDVARTYPE(pSource->type) || !ISVALIDVARTYPE(pDest->type))
    {
        AssertSz(FALSE, "An invalid VARTYPE was encountered!");
        hr = TraceResult(MIME_E_VARTYPE_NO_CONVERT);
        goto exit;
    }

    // Init pDest
    pDest->fCopy = FALSE;

    // Init rConvert
    ZeroMemory(&rConvert, sizeof(VARIANTCONVERT));
    rConvert.pOptions = pOptions;
    rConvert.pSymbol = pSymbol;
    rConvert.pCharset = pCharset ? pCharset : pOptions->pDefaultCharset;
    rConvert.ietSource = ietSource;
    rConvert.dwFlags = dwFlags;
    rConvert.dwState = dwState;

    // Remove PRSTATE_RFC1522
    FLAGCLEAR(rConvert.dwState, PRSTATE_RFC1522);

    // Valid Charset
    Assert(FALSE == IsBadReadPtr(rConvert.pCharset, sizeof(rConvert.pCharset)));
    Assert(g_rgVariantX[pSource->type].pfnConvertTo[pDest->type]);

    // Remove Comments and fixup the source...
    if (ISFLAGSET(dwFlags, PDF_NOCOMMENTS) && (MVT_STRINGA == pSource->type || MVT_STRINGW == pSource->type))
    {
        // Locals
        MIMEVARIANT     rVariant;
        BYTE            rgbScratch[256];

        // Init
        ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

        // Strip Comments
        if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
        {
            // Change the Source
            pSource = &rVariant;

            // Remove CF_NOALLOC
            FLAGCLEAR(dwFlags, CVF_NOALLOC);
        }

        // Do the Conversion
        hr = _HrConvertVariant(pSource->type, pDest->type, &rConvert, pSource, pDest);

        // Free the Variant
        MimeVariantFree(&rVariant);

        // Failure
        if (FAILED(hr))
        {
            TrapError(hr);
            goto exit;
        }
    }

    // Otherwise, normal Conversion
    else
    {
        // Do the Conversion
        CHECKHR(hr = _HrConvertVariant(pSource->type, pDest->type, &rConvert, pSource, pDest));
    }

    // 1522 Encoded ?
    if (pfRfc1522 && ISFLAGSET(rConvert.dwState, PRSTATE_RFC1522))
        *pfRfc1522 = TRUE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_StringA
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Invalid Arg
    if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGA;

    // Is International Property
    CHECKHR(hr = Internat_StringA_To_StringA(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatA
        CHECKHR(hr = HrWriteHeaderFormatA(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringA.pszVal, rVariant.rStringA.cchVal, NULL));
    }

    // MVT_STRINGA
    else if (MVT_STRINGA == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            // Write Name Into Data
            CHECKHR(hr = HrWriteNameInDataA(pConvert, &rVariant, pDest));
        }

        // No Conversion
        else if (rVariant.rStringA.pszVal == pSource->rStringA.pszVal)
        {
            // Copy
            CHECKHR(hr = HrMimeVariantCopy(pConvert->dwFlags, &rVariant, pDest));
        }

        // Is Equal to pszFree
        else if (rVariant.rStringA.pszVal == pszFree)
        {
            // Just Copy It
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a copy
            pDest->fCopy = FALSE;

            // Don't free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_StringW
// --------------------------------------------------------------------------------
HRESULT StringA_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGW);

    // Invalid Arg
    if (ISVALIDSTRINGA(&pSource->rStringA) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGW;

    // Internat Conversion
    CHECKHR(hr = Internat_StringA_To_StringW(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatW
        CHECKHR(hr = HrWriteHeaderFormatW(pConvert, &rVariant, pDest));
    }

    // MVT_STREAM
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringW.pszVal, rVariant.rStringW.cchVal, NULL));
    }
    
    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            CHECKHR(hr = HrWriteNameInDataW(pConvert, &rVariant, pDest));
        }

        // Equal to Data that we Allocated
        else if (rVariant.rStringW.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringA_To_Variant
// --------------------------------------------------------------------------------
HRESULT StringA_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           psz;
    MIMEVARIANT     rVariant;
    BYTE            rgbScratch[255];

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_VARIANT);
    Assert(!ISFLAGSET(pConvert->dwFlags, PDF_ENCODED) && !ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT));

    // Init
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_STRINGA_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_STRINGA_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pDest->rVariant.vt)
        {
        case VT_UI4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to ULONG
            pDest->rVariant.ulVal = strtoul(pSource->rStringA.pszVal, &psz, 10);
            break;

        case VT_I4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to Long
            pDest->rVariant.lVal = strtol(pSource->rStringA.pszVal, &psz, 10);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleInetDateToFileTime(pSource->rStringA.pszVal, &pDest->rVariant.filetime));
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Cleanup
    MimeVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_StringA
// --------------------------------------------------------------------------------
HRESULT StringW_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFree=NULL;
    MIMEVARIANT     rVariant;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGA);

    // Invalid Arg
    if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGA;

    // Internat Conversion
    CHECKHR(hr = Internat_StringW_To_StringA(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatA
        CHECKHR(hr = HrWriteHeaderFormatA(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringA.pszVal, rVariant.rStringA.cchVal, NULL));
    }

    // MVT_STRINGA
    else if (MVT_STRINGA == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            // Write Name Into Data
            CHECKHR(hr = HrWriteNameInDataA(pConvert, &rVariant, pDest));
        }

        // Is Equal to pszFree
        else if (rVariant.rStringA.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a Copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_StringW
// --------------------------------------------------------------------------------
HRESULT StringW_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    MIMEVARIANT     rVariant;
    LPWSTR          pszFree=NULL;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Invalid Arg
    if (ISVALIDSTRINGW(&pSource->rStringW) == FALSE)
        return TrapError(E_INVALIDARG);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));
    rVariant.type = MVT_STRINGW;

    // Internat Conversion
    CHECKHR(hr = Internat_StringW_To_StringW(pConvert, pSource, &rVariant, &pszFree));

    // If Transmit, setup wrapinfo
    if (ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT))
    {
        // WriteHeaderFormatW
        CHECKHR(hr = HrWriteHeaderFormatW(pConvert, &rVariant, pDest));
    }

    // Wanted in a stream
    else if (MVT_STREAM == pDest->type)
    {
        // No Stream...
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Write to the stream
        CHECKHR(hr = pDest->pStream->Write(rVariant.rStringW.pszVal, rVariant.rStringW.cchVal, NULL));
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pDest->type)
    {
        // If Writing Transmit (Write Header Name)
        if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
        {
            CHECKHR(hr = HrWriteNameInDataW(pConvert, &rVariant, pDest));
        }

        // No Change
        else if (rVariant.rStringW.pszVal == pSource->rStringW.pszVal)
        {
            // Copy
            CHECKHR(hr = HrMimeVariantCopy(pConvert->dwFlags, &rVariant, pDest));
        }

        // Is Decoded Data
        else if (rVariant.rStringW.pszVal == pszFree)
        {
            // Copy Memory
            CopyMemory(pDest, &rVariant, sizeof(MIMEVARIANT));

            // Not a Copy
            pDest->fCopy = FALSE;

            // Don't Free pszFree
            pszFree = NULL;
        }

        // Problem
        else
            Assert(FALSE);
    }

    // Problem
    else
        Assert(FALSE);

exit:
    // Cleanup 
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// StringW_To_Variant
// --------------------------------------------------------------------------------
HRESULT StringW_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwsz;
    LPSTR           pszANSI=NULL;
    MIMEVARIANT     rVariant;
    BYTE            rgbScratch[255];

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_VARIANT);
    Assert(!ISFLAGSET(pConvert->dwFlags, PDF_ENCODED) && !ISFLAGSET(pConvert->dwFlags, PDF_HEADERFORMAT));

    // Init
    ZeroMemory(&rVariant, sizeof(MIMEVARIANT));

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_STRINGW_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_STRINGW_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pDest->rVariant.vt)
        {
        case VT_UI4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to ulong
            pDest->rVariant.ulVal = StrToUintW(pSource->rStringW.pszVal);
            break;

        case VT_I4:
            // Strip Comments
            if (SUCCEEDED(MimeVariantStripComments(pSource, &rVariant, rgbScratch, sizeof(rgbScratch))))
                pSource = &rVariant;

            // Convert to Long
            pDest->rVariant.lVal = StrToIntW(pSource->rStringW.pszVal);
            break;

        case VT_FILETIME:
            // Convert Unicode to ANSI
            CHECKALLOC(pszANSI = PszToANSI(CP_ACP, pSource->rStringW.pszVal));

            // String to FileTime
            CHECKHR(hr = MimeOleInetDateToFileTime(pSource->rStringA.pszVal, &pDest->rVariant.filetime));
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszANSI);
    MimeVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_StringA
// --------------------------------------------------------------------------------
HRESULT Variant_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            sz[255];
    MIMEVARIANT     rValue;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_STRINGA);

    // Init pDest
    if (MVT_STRINGA == pDest->type)
    {
        pDest->rStringA.pszVal = NULL;
        pDest->rStringA.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));
    rValue.type = MVT_STRINGA;

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_STRINGA))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_STRINGA, pConvert->dwFlags, pSource, &rValue));
    }

    // Otherwise, default translator
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = wsprintf(rValue.rStringA.pszVal, "%d", pSource->rVariant.ulVal);
            break;

        case VT_I4:
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = wsprintf(rValue.rStringA.pszVal, "%d", pSource->rVariant.lVal);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleFileTimeToInetDate(&pSource->rVariant.filetime, sz, sizeof(sz)));
            rValue.rStringA.pszVal = sz;
            rValue.rStringA.cchVal = lstrlen(sz);
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

    // VX_StringA_To_StringA
    CHECKHR(hr = StringA_To_StringA(pConvert, &rValue, pDest));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_StringW
// --------------------------------------------------------------------------------
HRESULT Variant_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPWSTR          pwszVal=NULL;
    WCHAR           wsz[255];
    CHAR            szData[CCHMAX_INTERNET_DATE];
    MIMEVARIANT     rValue;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_STRINGW);

    // Init pDest
    if (MVT_STRINGW == pDest->type)
    {
        pDest->rStringW.pszVal = NULL;
        pDest->rStringW.cchVal = 0;
    }

    // Setup rVariant
    ZeroMemory(&rValue, sizeof(MIMEVARIANT));
    rValue.type = MVT_STRINGW;

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_STRINGW))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_STRINGW, pConvert->dwFlags, pSource, &rValue));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            rValue.rStringW.pszVal = wsz;
            rValue.rStringW.cchVal = AthwsprintfW(rValue.rStringW.pszVal, ARRAYSIZE(wsz), L"%d", pSource->rVariant.ulVal);
            break;

        case VT_I4:
            rValue.rStringW.pszVal = wsz;
            rValue.rStringW.cchVal = AthwsprintfW(rValue.rStringW.pszVal, ARRAYSIZE(wsz), L"%d", pSource->rVariant.lVal);
            break;

        case VT_FILETIME:
            CHECKHR(hr = MimeOleFileTimeToInetDate(&pSource->rVariant.filetime, szData, sizeof(szData)));
            CHECKALLOC(pwszVal = PszToUnicode(CP_ACP, szData));
            rValue.rStringW.pszVal = pwszVal;
            rValue.rStringW.cchVal = lstrlenW(pwszVal);
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

    // VX_StringA_To_StringA
    CHECKHR(hr = StringW_To_StringW(pConvert, &rValue, pDest));

exit:
    // Cleanup
    SafeMemFree(pwszVal);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Variant_To_Variant
// --------------------------------------------------------------------------------
HRESULT Variant_To_Variant(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_VARIANT, MVT_VARIANT);

    // See If Symbol has a custom Translator...
    if (ISTRIGGERED(pConvert->pSymbol, IST_VARIANT_TO_VARIANT))
    {
        // Call the Translator
        CHECKHR(hr = CALLTRIGGER(pConvert->pSymbol, NULL, IST_VARIANT_TO_VARIANT, pConvert->dwFlags, pSource, pDest));
    }

    // Otherwise, use default converter
    else
    {
        // Handle Variant Type
        switch(pSource->rVariant.vt)
        {
        case VT_UI4:
            switch(pDest->rVariant.vt)
            {
            case VT_UI4:
                pDest->rVariant.ulVal = pSource->rVariant.ulVal;
                break;

            case VT_I4:
                pDest->rVariant.lVal = (LONG)pSource->rVariant.ulVal;
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        case VT_I4:
            switch(pDest->rVariant.vt)
            {
            case VT_UI4:
                pDest->rVariant.ulVal = (ULONG)pSource->rVariant.lVal;
                break;

            case VT_I4:
                pDest->rVariant.lVal = pSource->rVariant.lVal;
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        case VT_FILETIME:
            switch(pDest->rVariant.vt)
            {
            case VT_FILETIME:
                CopyMemory(&pDest->rVariant.filetime, &pSource->rVariant.filetime, sizeof(FILETIME));
                break;

            default:
                hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
                goto exit;
            }
            break;

        default:
            hr = TrapError(MIME_E_VARTYPE_NO_CONVERT);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrMimeVariantCopy
// --------------------------------------------------------------------------------
HRESULT HrMimeVariantCopy(DWORD dwFlags, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    Assert(pSource && pDest);

    // CVF_NOALLOC
    if (ISFLAGSET(dwFlags, CVF_NOALLOC))
    {
        // Just Copy It
        CopyMemory(pDest, pSource, sizeof(MIMEVARIANT));

        // Set fCopy so we don't free it
        pDest->fCopy = TRUE;
    }

    // Allocate Memory
    else
    {
        // Not a Copy
        pDest->fCopy = FALSE;

        // MVT_STRINGA
        if (MVT_STRINGA == pSource->type)
        {
            // Validate
            Assert(ISVALIDSTRINGA(&pSource->rStringA));

            // Set Dest Type
            pDest->type = MVT_STRINGA;

            // Allocate Memory
            CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(pSource->rStringA.cchVal + 1));

            // Copy the memory
            CopyMemory(pDest->rStringA.pszVal, pSource->rStringA.pszVal, pSource->rStringA.cchVal + 1);

            // Return the Size
            pDest->rStringA.cchVal = pSource->rStringA.cchVal;
        }

        // MVT_STRINGW
        else if (MVT_STRINGW == pSource->type)
        {
            // Validate
            Assert(ISVALIDSTRINGW(&pSource->rStringW));

            // Set Dest Type
            pDest->type = MVT_STRINGW;

            // Compute CB
            ULONG cb = ((pSource->rStringW.cchVal + 1) * sizeof(WCHAR));

            // Allocate Memory
            CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cb));

            // Copy the memory
            CopyMemory(pDest->rStringW.pszVal, pSource->rStringW.pszVal, cb);

            // Return the Size
            pDest->rStringW.cchVal = pSource->rStringW.cchVal;
        }

        // MVT_VARIANT
        else if (MVT_VARIANT == pSource->type)
        {
            // Set Dest Type
            pDest->type = MVT_VARIANT;

            // Copy the Variant
            CopyMemory(&pDest->rVariant, &pSource->rVariant, sizeof(PROPVARIANT));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteNameInDataA
// --------------------------------------------------------------------------------
HRESULT HrWriteNameInDataA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Generic STuff
    pDest->fCopy = FALSE;

    // pszNamed
    CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(pSource->rStringA.cchVal + 2 + pConvert->pSymbol->cchName));

    // Write the named header
    pDest->rStringA.cchVal = wsprintf(pDest->rStringA.pszVal, "%s: %s", pConvert->pSymbol->pszName, pSource->rStringA.pszVal);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteNameInDataW
// --------------------------------------------------------------------------------
HRESULT HrWriteNameInDataW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;
    LPWSTR      pszName=NULL;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Generic STuff
    pDest->fCopy = FALSE;

    // Convert Name to Unicode
    CHECKALLOC(pszName = PszToUnicode(CP_ACP, pConvert->pSymbol->pszName));

    // Compute CB
    cb = ((pSource->rStringW.cchVal + 2 + lstrlenW(pszName)) * sizeof(WCHAR));

    // pszNamed
    CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc(cb));

    // Write the named header
    pDest->rStringW.cchVal = AthwsprintfW(pDest->rStringW.pszVal, (cb/sizeof(WCHAR)), L"%s: %s", pszName, pSource->rStringW.pszVal);

exit:
    // Cleanup
    SafeMemFree(pszName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteHeaderFormatA
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pStream;
    CByteStream     cByteStream;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Generic Stuff
    pDest->fCopy = FALSE;

    // I need a stream to write to...
    if (MVT_STREAM == pDest->type)
    {
        // Validate the stream
        if (NULL == pDest->pStream)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Save the Stream
        pStream = pDest->pStream;
    }

    // Otherwise, create my own stream
    else
        pStream = &cByteStream;

    // If Writing Transmit (Write Header Name)
    if (ISFLAGSET(pConvert->dwFlags, PDF_NAMEINDATA))
    {
        // Write the header name
        CHECKHR(hr = pStream->Write(pConvert->pSymbol->pszName, pConvert->pSymbol->cchName, NULL));

        // Write Colon
        CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));
    }

    // If not rfc1522 Encoded
    if (FALSE == ISFLAGSET(pConvert->dwState, PRSTATE_RFC1522))
    {
        // PID_HDR_CNTID
        if (PID_HDR_CNTID == pConvert->pSymbol->dwPropId)
        {
            // If not a < yet...
            if ('<' != pSource->rStringA.pszVal[0])
            {
                // Write it
                CHECKHR(hr = pStream->Write(c_szEmailStart, lstrlen(c_szEmailStart), NULL));
            }

            // Write the data
            CHECKHR(hr = pStream->Write(pSource->rStringA.pszVal, pSource->rStringA.cchVal, NULL));

            // >
            if ('>' != pSource->rStringA.pszVal[pSource->rStringA.cchVal - 1])
            {
                // Write it
                CHECKHR(hr = pStream->Write(c_szEmailEnd, lstrlen(c_szEmailEnd), NULL));
            }

            // Write CRLF
            CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));
        }

        // Do a wrap text
        else
        {
            // Wrap pszData to the stream
            CHECKHR(hr = MimeOleWrapHeaderText(CP_USASCII, pConvert->pOptions->cbMaxLine, pSource->rStringA.pszVal, pSource->rStringA.cchVal, pStream));
        }
    }

    // Otherwise
    else
    {
        // Write the data
        CHECKHR(hr = pStream->Write(pSource->rStringA.pszVal, pSource->rStringA.cchVal, NULL));

        // Write CRLF
        CHECKHR(hr = pStream->Write(c_szCRLF, lstrlen(c_szCRLF), NULL));
    }

    // MVT_STRINGA
    if (MVT_STRINGA == pDest->type)
    {
        // pStream better be the byte stream
        Assert(pStream == &cByteStream);

        // Get string from stream...
        CHECKHR(hr = cByteStream.HrAcquireStringA(&pDest->rStringA.cchVal, &pDest->rStringA.pszVal, ACQ_DISPLACE));
    }
    else
        Assert(MVT_STREAM == pDest->type);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrWriteHeaderFormatW
// --------------------------------------------------------------------------------
HRESULT HrWriteHeaderFormatW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, LPMIMEVARIANT pDest)
{
    return TrapError(MIME_E_VARTYPE_NO_CONVERT);
}

// --------------------------------------------------------------------------------
// Internat_StringA_To_StringA
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGA);

    // Init
    pDest->rStringA.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringA.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringA.pszVal;
        }
    }

    // Default
    if (NULL == pDest->rStringA.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // Copy It
        pDest->rStringA.pszVal = pSource->rStringA.pszVal;
        pDest->rStringA.cchVal = pSource->rStringA.cchVal;

        // pDest is a copy
        pDest->fCopy = TRUE;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringW_To_StringW
// --------------------------------------------------------------------------------
HRESULT Internat_StringW_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPWSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGW);

    // Init
    pDest->rStringW.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringW.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringW.pszVal;
        }
    }

    // Default
    if (NULL == pDest->rStringW.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // Copy It
        pDest->rStringW.pszVal = pSource->rStringW.pszVal;
        pDest->rStringW.cchVal = pSource->rStringW.cchVal;

        // Its a copy 
        pDest->fCopy = TRUE;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringA_To_StringW
// --------------------------------------------------------------------------------
HRESULT Internat_StringA_To_StringW(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPWSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGA, MVT_STRINGW);

    // Init
    pDest->rStringW.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringW.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringW.pszVal;
        }
    }

    // Simple Conversion to Unicode
    if (NULL == pDest->rStringW.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // HrMultiByteToWideChar
        CHECKHR(hr = g_pInternat->HrMultiByteToWideChar(pConvert->pCharset->cpiWindows, &pSource->rStringA, &pDest->rStringW));

        // Save Charset/Encoding
        pDest->fCopy = FALSE;

        // Save pwszWide
        *ppszFree = pDest->rStringW.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Internat_StringW_To_StringA
// --------------------------------------------------------------------------------
HRESULT Internat_StringW_To_StringA(LPVARIANTCONVERT pConvert, LPMIMEVARIANT pSource, 
    LPMIMEVARIANT pDest, LPSTR *ppszFree)
{
    // Locals
    HRESULT hr=S_OK;

    // Invalid Arg
    VCASSERTARGS(MVT_STRINGW, MVT_STRINGA);

    // Init
    pDest->rStringA.pszVal = NULL;
    *ppszFree = NULL;

    // Internat
    if (ISFLAGSET(pConvert->pSymbol->dwFlags, MPF_INETCSET))
    {
        // Encoded...
        if (ISFLAGSET(pConvert->dwFlags, PDF_ENCODED))
        {
            // Save no encode
            if (!ISFLAGSET(pConvert->dwState, PRSTATE_SAVENOENCODE))
            {
                // Decode the Property
                if (SUCCEEDED(g_pInternat->HrEncodeProperty(pConvert, pSource, pDest)))
                    *ppszFree = pDest->rStringA.pszVal;
            }
        }

        // Decoded
        else if (IET_ENCODED == pConvert->ietSource)
        {
            // Decode Property
            if (SUCCEEDED(g_pInternat->HrDecodeProperty(pConvert, pSource, pDest)))
                *ppszFree = pDest->rStringA.pszVal;
        }
    }

    // Simple Conversion to Unicode
    if (NULL == pDest->rStringA.pszVal)
    {
        // Check State
        Assert(NULL == *ppszFree);

        // HrMultiByteToWideChar
        CHECKHR(hr = g_pInternat->HrWideCharToMultiByte(pConvert->pCharset->cpiWindows, &pSource->rStringW, &pDest->rStringA));

        // Save Charset/Encoding
        pDest->fCopy = FALSE;

        // Save pwszWide
        *ppszFree = pDest->rStringA.pszVal;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeVariantFree
// --------------------------------------------------------------------------------
void MimeVariantFree(LPMIMEVARIANT pVariant)
{
    // Invalid Arg
    Assert(pVariant);

    // If not a copy
    if (FALSE == pVariant->fCopy)
    {
        // MVT_STRINGA
        if (MVT_STRINGA == pVariant->type && NULL != pVariant->rStringA.pszVal)
            g_pMalloc->Free(pVariant->rStringA.pszVal);

        // MVT_STRINGW
        else if (MVT_STRINGW == pVariant->type && NULL != pVariant->rStringW.pszVal)
            g_pMalloc->Free(pVariant->rStringW.pszVal);
    }

    // Zero Out the Structure
    ZeroMemory(pVariant, sizeof(MIMEVARIANT));
}

// ---------------------------------------------------------------------------------------
// MimeVariantCleanupFileName
// ---------------------------------------------------------------------------------------
void MimeVariantCleanupFileName(CODEPAGEID codepage, LPMIMEVARIANT pVariant)
{
    // Locals
    ULONG       i=0;

    // MVT_STRINGA
    if (MVT_STRINGA == pVariant->type && ISVALIDSTRINGA(&pVariant->rStringA))
    {
        // Cleanup
        pVariant->rStringA.cchVal = CleanupFileNameInPlaceA(codepage, pVariant->rStringA.pszVal);
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pVariant->type && ISVALIDSTRINGW(&pVariant->rStringW))
    {
        // Cleanup
        pVariant->rStringW.cchVal = CleanupFileNameInPlaceW(pVariant->rStringW.pszVal);
    }

    // Hmmm....
    else
        Assert(FALSE);

    // Done
    return;
}

// ---------------------------------------------------------------------------------------
// MimeVariantStripComments
// ---------------------------------------------------------------------------------------
HRESULT MimeVariantStripComments(LPMIMEVARIANT pSource, LPMIMEVARIANT pDest, LPBYTE pbScratch, ULONG cbScratch)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchVal=0;
    BOOL        fInQuoted=FALSE;
    ULONG       cNested=0;

    // Init
    ZeroMemory(pDest, sizeof(MIMEVARIANT));

    // MVT_STRINGA
    if (MVT_STRINGA == pSource->type && ISVALIDSTRINGA(&pSource->rStringA))
    {
        // Locals
        LPSTR psz;

        // Setup pDest
        pDest->type = MVT_STRINGA;

        // Dup It
        if (pSource->rStringA.cchVal + 1 <= cbScratch)
        {
            pDest->fCopy = TRUE;
            pDest->rStringA.pszVal = (LPSTR)pbScratch;
        }

        // Otherwise, allocate memory
        else
        {
            // Allocate
            CHECKALLOC(pDest->rStringA.pszVal = (LPSTR)g_pMalloc->Alloc(pSource->rStringA.cchVal + 1));
        }

        // Setup Loop
        psz = pSource->rStringA.pszVal;
        while(*psz)
        {
            // If lead byte, skip it, its leagal
            if (IsDBCSLeadByte(*psz))
            {
                pDest->rStringA.pszVal[cchVal++] = *psz++;
                pDest->rStringA.pszVal[cchVal++] = *psz++;
            }

            // Starting Comment
            else if ('(' == *psz && !fInQuoted)
            {
                cNested++;
                psz++;
            }

            // Ending Comment
            else if (')' == *psz && !fInQuoted)
            {
                cNested--;
                psz++;
            }

            // Otherwise, if not nested, append
            else if (!cNested)
            {
                // Copy the Char
                pDest->rStringA.pszVal[cchVal++] = *psz++;

                // Check for Quote
                if ('\"' == *psz)
                    fInQuoted = (fInQuoted) ? FALSE : TRUE;
            }

            // Skip Char
            else
                psz++;
        }

        // No Change
        if (cchVal == pSource->rStringA.cchVal)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Null It
        pDest->rStringA.pszVal[cchVal] = '\0';
    }

    // MVT_STRINGW
    else if (MVT_STRINGW == pSource->type && ISVALIDSTRINGW(&pSource->rStringW))
    {
        // Locals
        LPWSTR pwsz;

        // Setup pDest
        pDest->type = MVT_STRINGW;

        // Dup It
        if ((pSource->rStringW.cchVal + 1) * sizeof(WCHAR) <= cbScratch)
        {
            pDest->fCopy = TRUE;
            pDest->rStringW.pszVal = (LPWSTR)pbScratch;
        }

        // Otherwise, allocate memory
        else
        {
            // Dup It
            CHECKALLOC(pDest->rStringW.pszVal = (LPWSTR)g_pMalloc->Alloc((pSource->rStringW.cchVal + 1) * sizeof(WCHAR)));
        }

        // Setup Loop
        pwsz = pSource->rStringW.pszVal;
        while(*pwsz)
        {
            // Starting Comment
            if (L'(' == *pwsz && !fInQuoted)
            {
                cNested++;
                pwsz++;
            }

            // Ending Comment
            if (L')' == *pwsz && !fInQuoted)
            {
                cNested--;
                pwsz++;
            }

            // Otherwise, if not nested, append
            else if (!cNested)
            {
                // Copy the Character
                pDest->rStringW.pszVal[cchVal++] = *pwsz++;

                // Check for Quote
                if (L'\"' == *pwsz)
                    fInQuoted = (fInQuoted) ? FALSE : TRUE;
            }

            // Skip Char
            else
                pwsz++;
        }

        // No Change
        if (cchVal == pSource->rStringW.cchVal)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Null It
        pDest->rStringW.pszVal[cchVal] = L'\0';
    }

    // Hmmm....
    else
        Assert(FALSE);

exit:
    // Cleanup
    if (FAILED(hr))
        MimeVariantFree(pDest);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\variantx.h ===
// --------------------------------------------------------------------------------
// VariantX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __VARIANTX_H
#define __VARIANTX_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
typedef class CMimePropertyContainer *LPCONTAINER;
typedef struct tagMIMEVARIANT *LPMIMEVARIANT;
typedef struct tagPROPSYMBOL *LPPROPSYMBOL;
typedef struct tagHEADOPTIONS *LPHEADOPTIONS;

// --------------------------------------------------------------------------------
// MIMEVARTYPE
// --------------------------------------------------------------------------------
typedef enum tagMIMEVARTYPE {
    MVT_EMPTY,             // The Variant is Empty
    MVT_STRINGA,           // Ansi/multibyte string
    MVT_STRINGW,           // Unicode String
    MVT_VARIANT,           // PropVariant
    MVT_STREAM,            // Internal type used to when saving properties
    MVT_LAST               // Illegal, don't use
} MIMEVARTYPE;

// ---------------------------------------------------------------------------------------
// ISSUPPORTEDVT
// ---------------------------------------------------------------------------------------
#define ISSUPPORTEDVT(_vt) \
    (VT_LPSTR == _vt || VT_LPWSTR == _vt || VT_FILETIME == _vt || VT_UI4 == _vt || VT_I4 == _vt || VT_STREAM == _vt)

// ---------------------------------------------------------------------------------------
// ISVALIDVARTYPE
// ---------------------------------------------------------------------------------------
#define ISVALIDVARTYPE(_vartype) \
    (_vartype > MVT_EMPTY && _vartype < MVT_LAST)

// ---------------------------------------------------------------------------------------
// ISVALIDSTRINGA - Validates a PROPSTRINGA
// ---------------------------------------------------------------------------------------
#define ISVALIDSTRINGA(_pStringA) \
    (NULL != (_pStringA) && NULL != (_pStringA)->pszVal && '\0' == (_pStringA)->pszVal[(_pStringA)->cchVal])

// ---------------------------------------------------------------------------------------
// ISVALIDSTRINGW - Validates a PROPSTRINGW
// ---------------------------------------------------------------------------------------
#define ISVALIDSTRINGW(_pStringW) \
    (NULL != (_pStringW) && NULL != (_pStringW)->pszVal && L'\0' == (_pStringW)->pszVal[(_pStringW)->cchVal])

// ---------------------------------------------------------------------------------------
// ISSTRINGA - Determines if a MIMEVARIANT is a valid MVT_STRINGA
// ---------------------------------------------------------------------------------------
#define ISSTRINGA(_pVariant) \
    (NULL != (_pVariant) && MVT_STRINGA == (_pVariant)->type && ISVALIDSTRINGA(&((_pVariant)->rStringA)))

// ---------------------------------------------------------------------------------------
// ISSTRINGW - Determines if a MIMEVARIANT is a valid MVT_STRINGW
// ---------------------------------------------------------------------------------------
#define ISSTRINGW(_pVariant) \
    (NULL != (_pVariant) && MVT_STRINGW == (_pVariant)->type && ISVALIDSTRINGW(&((_pVariant)->rStringW)))

// ---------------------------------------------------------------------------------------
// PSZSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZSTRINGA(_pVariant) \
    (ISSTRINGA((_pVariant)) ? (_pVariant)->rStringA.pszVal : NULL)

// ---------------------------------------------------------------------------------------
// PSZDEFSTRINGA - Derefs rStringA.pszVal or uses _pszDefault if not a valid string
// ---------------------------------------------------------------------------------------
#define PSZDEFSTRINGA(_pVariant, _pszDefault) \
    (ISSTRINGA((_pVariant)) ? (_pVariant)->rStringA.pszVal : _pszDefault)

// --------------------------------------------------------------------------------
// PROPSTRINGA
// --------------------------------------------------------------------------------
typedef struct tagPROPSTRINGA {
    LPSTR               pszVal;             // Pointer to multibyte string    
    ULONG               cchVal;             // Number of characters in psz
} PROPSTRINGA, *LPPROPSTRINGA;
typedef const PROPSTRINGA *LPCPROPSTRINGA;

// --------------------------------------------------------------------------------
// PROPSTRINGW
// --------------------------------------------------------------------------------
typedef struct tagPROPSTRINGW {
    LPWSTR              pszVal;             // Pointer to multibyte string    
    ULONG               cchVal;             // Number of characters in psz
} PROPSTRINGW, *LPPROPSTRINGW;
typedef const PROPSTRINGW *LPCPROPSTRINGW;

// --------------------------------------------------------------------------------
// MIMEVARIANT
// --------------------------------------------------------------------------------
typedef struct tagMIMEVARIANT {
    MIMEVARTYPE         type;               // Property Data Type
    BYTE                fCopy;              // The data was copied, don't free it
    union {
        PROPSTRINGA     rStringA;           // MVT_STRINGA
        PROPSTRINGW     rStringW;           // MVT_STRINGW
        PROPVARIANT     rVariant;           // MVT_VARIANT
        LPSTREAM        pStream;            // MVT_STREAM
    };
} MIMEVARIANT, *LPMIMEVARIANT;
typedef const MIMEVARIANT *LPCMIMEVARIANT;

// --------------------------------------------------------------------------------
// Convert Variant Flags (WARNING: DO NOT OVERFLAG PROPDATAFLAGS WITH THESE)
// --------------------------------------------------------------------------------
#define CVF_NOALLOC     FLAG32              // Tells the converter to copy data if it can

// --------------------------------------------------------------------------------
// VARIANTCONVERT
// --------------------------------------------------------------------------------
typedef struct tagVARIANTCONVERT {
    LPHEADOPTIONS       pOptions;           // Header Options
    LPPROPSYMBOL        pSymbol;            // Property Symbol
    LPINETCSETINFO      pCharset;           // Charset to use in conversion
    ENCODINGTYPE        ietSource;          // Encoding of source item
    DWORD               dwFlags;            // Property Data Flags
    DWORD               dwState;            // PRSTATE_xxx Flags
} VARIANTCONVERT, *LPVARIANTCONVERT;

// --------------------------------------------------------------------------------
// HrMimeVariantCopy
// --------------------------------------------------------------------------------
HRESULT HrMimeVariantCopy(
        /* in */        DWORD               dwFlags,  // CVF_xxx Flags
        /* in */        LPMIMEVARIANT       pSource, 
        /* out */       LPMIMEVARIANT       pDest);

// --------------------------------------------------------------------------------
// HrConvertVariant
// --------------------------------------------------------------------------------
HRESULT HrConvertVariant(
        /* in */        LPHEADOPTIONS       pOptions,
        /* in */        LPPROPSYMBOL        pSymbol,
        /* in */        LPINETCSETINFO      pCharset,
        /* in */        ENCODINGTYPE        ietSource,
        /* in */        DWORD               dwFlags, 
        /* in */        DWORD               dwState,
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* out,opt */   BOOL               *pfRfc1522=NULL);

// --------------------------------------------------------------------------------
// MimeVariantFree
// --------------------------------------------------------------------------------
void MimeVariantFree(
        /* in */        LPMIMEVARIANT       pVariant);

// --------------------------------------------------------------------------------
// MimeVariantCleanupFileName
// --------------------------------------------------------------------------------
void MimeVariantCleanupFileName(
        /* in */        CODEPAGEID          codepage, 
        /* in,out */    LPMIMEVARIANT       pVariant);

// --------------------------------------------------------------------------------
// MimeVariantStripComments
// --------------------------------------------------------------------------------
HRESULT MimeVariantStripComments(
        /* in */        LPMIMEVARIANT       pSource, 
        /* in,out */    LPMIMEVARIANT       pDest,
        /* in,out */    LPBYTE              pbScratch, 
        /* in */        ULONG               cbScratch);


// ---------------------------------------------------------------------------------------
// MimeVT_To_PropVT
// ---------------------------------------------------------------------------------------
inline VARTYPE MimeVT_To_PropVT(LPMIMEVARIANT pVariant) {
    Assert(pVariant);
    if (MVT_STRINGA == pVariant->type)
        return(VT_LPSTR);
    else if (MVT_STRINGW == pVariant->type)
        return(VT_LPWSTR);
    else if (MVT_VARIANT == pVariant->type)
        return(pVariant->rVariant.vt);
    else
        return(VT_EMPTY);
}

#endif // __VARIANTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\webdocs.h ===
// --------------------------------------------------------------------------------
// WebDocs.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __WEBDOCS_H
#define __WEBDOCS_H

// --------------------------------------------------------------------------------
// CMimeWebDocument
// --------------------------------------------------------------------------------
class CMimeWebDocument : public IMimeWebDocument
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeWebDocument(void);
    ~CMimeWebDocument(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeWebDocument Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP GetURL(LPSTR *ppszURL);
    STDMETHODIMP BindToStorage(REFIID riid, LPVOID *ppvObject);

    // ----------------------------------------------------------------------------
    // CMimeWebDocument Members
    // ----------------------------------------------------------------------------
    HRESULT HrInitialize(LPCSTR pszBase, LPCSTR pszURL);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    LPSTR               m_pszBase;      // URL Base
    LPSTR               m_pszURL;       // URL
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

#endif // __WEBDOCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\webdocs.cpp ===
// --------------------------------------------------------------------------------
// WebDocs.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "webdocs.h"
#ifdef MAC
#include "urlhlink.h"
#else   // !MAC
#include "urlmon.h"
#endif  // !MAC
#include "stmlock.h"
#ifndef MAC
#include "wininet.h"
#include "winineti.h"
#endif  // !MAC
#include <demand.h>

#ifndef MAC
HRESULT HrOpenUrlViaCache(LPCSTR pszUrl, LPSTREAM *ppstm);
#endif  // !MAC

// --------------------------------------------------------------------------------
// CMimeWebDocument::CMimeWebDocument
// --------------------------------------------------------------------------------
CMimeWebDocument::CMimeWebDocument(void)
{
    m_cRef = 1;
    m_pszBase = NULL;
    m_pszURL = NULL;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::CMimeWebDocument
// --------------------------------------------------------------------------------
CMimeWebDocument::~CMimeWebDocument(void)
{
    EnterCriticalSection(&m_cs);
    SafeMemFree(m_pszBase);
    SafeMemFree(m_pszURL);
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeWebDocument == riid)
        *ppv = (IMimeWebDocument *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeWebDocument::AddRef(void)
{
    return (ULONG)InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeWebDocument::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::GetURL
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::GetURL(LPSTR *ppszURL)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == ppszURL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pszURL)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Combine the URL
    if (m_pszBase)
    {
        // Combine
        CHECKHR(hr = MimeOleCombineURL(m_pszBase, lstrlen(m_pszBase), m_pszURL, lstrlen(m_pszURL), FALSE, ppszURL));
    }

    // Otherwise, just dup m_pszURL
    else
    {
        // Dup It
        CHECKALLOC(*ppszURL = PszDupA(m_pszURL));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::BindToStorage
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeWebDocument::BindToStorage(REFIID riid, LPVOID *ppvObject)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszURL=NULL;
    IStream    *pStream=NULL;
    ILockBytes *pLockBytes=NULL;

    // Invalid Arg
    if (NULL == ppvObject || (IID_IStream != riid && IID_ILockBytes != riid))
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObject = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_pszURL)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

#ifndef MAC
    // Combine the URL
    if (m_pszBase)
    {
        // Combine
        CHECKHR(hr = MimeOleCombineURL(m_pszBase, lstrlen(m_pszBase), m_pszURL, lstrlen(m_pszURL), FALSE, &pszURL));

        // Get the Stream
        CHECKHR(hr = HrOpenUrlViaCache(pszURL, &pStream));
    }

    // Otherwise, just dup m_pszURL
    else
    {
        // Get the Stream
        CHECKHR(hr = HrOpenUrlViaCache(m_pszURL, &pStream));
    }
#endif  // !MAC

    // User wants ILockBytes
    if (IID_ILockBytes == riid)
    {
        // Create CStreamLockBytes
        CHECKALLOC(pLockBytes = new CStreamLockBytes(pStream));

        // Add Ref It
        pLockBytes->AddRef();

        // Return It
        *ppvObject = pLockBytes;
    }

    // IID_IStream
    else
    {
        // Add Ref It
        pStream->AddRef();

        // Return It
        *ppvObject = pStream;
    }

exit:
    // Cleanup
    SafeMemFree(pszURL);
    SafeRelease(pStream);
    SafeRelease(pLockBytes);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeWebDocument::HrInitialize
// --------------------------------------------------------------------------------
HRESULT CMimeWebDocument::HrInitialize(LPCSTR pszBase, LPCSTR pszURL)
{
    // Locals
    HRESULT     hr=S_OK;

    // Invalid Arg
    if (NULL == pszURL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free Current Data
    SafeMemFree(m_pszBase);
    SafeMemFree(m_pszURL);

    // pszURL
    CHECKALLOC(m_pszURL = PszDupA(pszURL));

    // pszBase
    if (pszBase)
    {
        // Dup the Base
        CHECKALLOC(m_pszBase = PszDupA(pszBase));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}


#ifndef MAC
HRESULT HrOpenUrlViaCache(LPCSTR pszUrl, LPSTREAM *ppstm)
{
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO  *pCacheInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
    DWORD                       cInfo = sizeof(buf);
    HRESULT                     hr;

    pCacheInfo->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);
    
    // try to get from the cache
    if (RetrieveUrlCacheEntryFileA(pszUrl, pCacheInfo, &cInfo, 0))
        {
        UnlockUrlCacheEntryFile(pszUrl, 0);
        if (OpenFileStream(pCacheInfo->lpszLocalFileName, OPEN_EXISTING, GENERIC_READ, ppstm)==S_OK)
            return S_OK;
        }

    // if failed to get a cache, get from the net
    hr = URLOpenBlockingStreamA(NULL, pszUrl, ppstm, 0, NULL);

    return hr == S_OK ? S_OK : MIME_E_URL_NOTFOUND;
   
};
#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\vstream.cpp ===
// --------------------------------------------------------------------------------
// Vstream.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Ronald E. Gray
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "vstream.h"
#include "dllmain.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// Utilities
// --------------------------------------------------------------------------------
inline ULONG ICeil(ULONG x, ULONG interval)
{
    return (x ? (((x-1)/interval) + 1) * interval : 0);
}

// --------------------------------------------------------------------------------
// CVirtualStream::CVirtualStream
// --------------------------------------------------------------------------------
CVirtualStream::CVirtualStream(void)
{
    m_cRef          = 1; 
    m_cbSize        = 0;
    m_cbCommitted   = 0;
    m_cbAlloc       = 0;
    m_dwOffset      = 0;
    m_pstm          = NULL;
    m_pb            = 0;
    m_fFileErr      = FALSE;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CVirtualStream::~CVirtualStream
// --------------------------------------------------------------------------------
CVirtualStream::~CVirtualStream(void)
{
    if (m_pb)
        VirtualFree(m_pb, 0, MEM_RELEASE);
    if (m_pstm)
        m_pstm->Release();

    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (    (IID_IUnknown == riid)
        ||  (IID_IStream == riid)
        ||  (IID_IVirtualStream == riid))
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    AddRef();

    // Done
    return (ResultFromScode(S_OK));
}

// --------------------------------------------------------------------------------
// CVirtualStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CVirtualStream::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_cRef);
}


// --------------------------------------------------------------------------------
// CVirtualStream::SyncFileStream
// --------------------------------------------------------------------------------
HRESULT CVirtualStream::SyncFileStream()
{
    LARGE_INTEGER   li;
    HRESULT         hr;

    // figure out where to set the file stream be subtracting the memory portion
    // of the stream from the offset
#ifdef MAC
    if (m_dwOffset < m_cbAlloc)
        LISet32(li, 0);
    else
    {
        LISet32(li, m_dwOffset);
        li.LowPart -= m_cbAlloc;
    }
#else   // !MAC
    if (m_dwOffset < m_cbAlloc)
        li.QuadPart = 0;
    else
        li.QuadPart = m_dwOffset - m_cbAlloc;
#endif  // MAC

    // seek in the stream
    hr = m_pstm->Seek(li, STREAM_SEEK_SET, NULL);

    // reset the file err member based on the current error
    m_fFileErr = !!hr;

    return hr;
}
// --------------------------------------------------------------------------------
// CVirtualStream::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CVirtualStream::Release(void)
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_cRef);
    if (0 != cRef)
    {
#ifdef	DEBUG
        return cRef;
#else
        return 0;
#endif
    }
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CVirtualStream::Read
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CVirtualStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CVirtualStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    HRESULT     hr      = ResultFromScode(S_OK);
    ULONG       cbGet   = 0;

        // Check
    AssertWritePtr(pv, cb);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // if the steam pointer is possibly out of sync
    // resync
    if (m_fFileErr)
    {
        hr = SyncFileStream();
        if (hr) goto err;
    }
    
    // make sure there's something to read
    if (m_dwOffset < m_cbSize)
    {
        // figure out what we're getting out of memory
        if (m_dwOffset < m_cbCommitted)
        {
            if (m_cbSize > m_cbCommitted)
                cbGet = min(cb, m_cbCommitted - m_dwOffset);
            else
                cbGet = min(cb, m_cbSize - m_dwOffset);
            // copy the memory stuff
            CopyMemory((LPBYTE)pv, m_pb + m_dwOffset, cbGet);

        }

        // if we still have stuff to read
        // and we've used all of the memory
        // and we do have a stream, try to get the rest of the data out of the stream
        if (    (cbGet != cb)
           &&   (m_cbCommitted == m_cbAlloc)
           &&   m_pstm)
        {
            ULONG           cbRead;

    #ifdef	DEBUG
            LARGE_INTEGER   li  = {0, 0};
            ULARGE_INTEGER  uli = {0, 0};

            if (!m_pstm->Seek(li, STREAM_SEEK_CUR, &uli))
#ifdef MAC
                Assert(((m_dwOffset + cbGet) - m_cbAlloc) == uli.LowPart);
#else   // !MAC
                Assert(((m_dwOffset + cbGet) - m_cbAlloc) == uli.QuadPart);
#endif  // MAC
    #endif
            hr = m_pstm->Read(((LPBYTE)pv) + cbGet, cb - cbGet, &cbRead);
            if (hr)
            {
                m_fFileErr = TRUE;
                goto err;
            }

            cbGet += cbRead;
        }

        m_dwOffset += cbGet;
    }
    
    if (pcbRead)
        *pcbRead = cbGet;
err:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CVirtualStream::SetSize
// --------------------------------------------------------------------------------
HRESULT CVirtualStream::SetSize(ULARGE_INTEGER uli)
{
    // Locals
    HRESULT     hr          = ResultFromScode(S_OK);
    ULONG       cbDemand    = uli.LowPart;
    ULONG       cbCommit    = ICeil(cbDemand, g_dwSysPageSize);
    
    if (uli.HighPart != 0)
		return(ResultFromScode(STG_E_MEDIUMFULL));
        
    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // if we haven't initialized memory, do it now
    if (!m_cbAlloc)
    {
        LPVOID  pv;
        ULONG   cb  = 32 * g_dwSysPageSize; // use 32 pages

        while ((!(pv = VirtualAlloc(NULL, cb, MEM_RESERVE, PAGE_READWRITE)))
               && (cb > g_dwSysPageSize))
        {
            cb /= 2;
        }
        if (!pv)
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto err;
        }
        m_cbAlloc   = cb;
        m_pb        = (LPBYTE)pv;
    }
        
    if (cbCommit  < m_cbCommitted)
    {
        // shrink the stream
        LPBYTE  pb  =m_pb;
        ULONG   cb;

        // figure out the begining of the last page in the range not used
        pb += cbCommit;

        // figure out the size of the range being decommitted
        cb = m_cbCommitted - cbCommit;
                  
#ifndef MAC
        VirtualFree(pb, cb, MEM_DECOMMIT);
#endif  // !MAC

        // figure out what we have left committed
        m_cbCommitted = cbCommit;
        
    }
    else if (cbCommit > m_cbCommitted)
    {
        LPBYTE  pb;

        // figure out how much memory to commit
        cbCommit = (cbDemand <= m_cbAlloc)
                   ?    ICeil(cbDemand,  g_dwSysPageSize)
                   :    m_cbAlloc;

        if (cbCommit > m_cbCommitted)
        {
#ifndef MAC
            if (!VirtualAlloc(m_pb, cbCommit, MEM_COMMIT, PAGE_READWRITE))
            {
                hr = ResultFromScode(E_OUTOFMEMORY);
                goto err;
            }
#endif  // !MAC
        }

        m_cbCommitted = cbCommit;

        // Wow, we've used all of memory, start up the disk
        if (cbDemand > m_cbAlloc)
        {
            ULARGE_INTEGER uliAlloc;

            // no stream? better create it now
            if (!m_pstm)
            {                
                hr = CreateTempFileStream(&m_pstm);
                if (hr) goto err;
            }
            uliAlloc.LowPart = cbDemand - m_cbAlloc;
            uliAlloc.HighPart = 0;
            
            hr = m_pstm->SetSize(uliAlloc);
            if (hr) goto err;
            
            // if the current offset beyond the end of the memory allocation,
            // initialize the stream pointer correctly
            if (m_dwOffset > m_cbAlloc)
            {
                hr = SyncFileStream();
                if (hr) goto err;
            }
        }
    }

    m_cbSize = cbDemand;
    
err:
    // Thread Safety
    LeaveCriticalSection(&m_cs);
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryStat
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::Stat(STATSTG *pStat, DWORD grfStatFlag)
{
    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // Fill pStat
    pStat->type = STGTY_STREAM;
    pStat->cbSize.HighPart = 0;
    pStat->cbSize.LowPart = m_cbSize;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CVirtualStream::QueryStat
// --------------------------------------------------------------------------------
void CVirtualStream::QueryStat(ULARGE_INTEGER *puliOffset, ULARGE_INTEGER *pulSize)
{
#ifdef MAC
    if (puliOffset)
        ULISet32(*puliOffset, m_dwOffset);
    if (pulSize)
        ULISet32(*pulSize, m_cbSize);
#else   // !MAC
    if (puliOffset)
        puliOffset->QuadPart = (LONGLONG)m_dwOffset;
    if (pulSize)
        pulSize->QuadPart = (LONGLONG)m_cbSize;
#endif  // MAC
}

// --------------------------------------------------------------------------------
// CVirtualStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CVirtualStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT     hr  = ResultFromScode(S_OK);
    BOOL    	fForward;
	ULONG       ulOffset;
#ifdef MAC
    ULONG       llCur;
#else   // !MAC
	LONGLONG    llCur;
#endif  // MAC

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // look for starting position
	if (dwOrigin == STREAM_SEEK_CUR)
		llCur = m_dwOffset;
	else if (dwOrigin == STREAM_SEEK_END)
		llCur = m_cbSize;
	else
		llCur = 0;

#ifdef MAC
    Assert(0 == dlibMove.HighPart);
    llCur += dlibMove.LowPart;
#else   // !MAC
    llCur += dlibMove.QuadPart;
#endif  // MAC

    // limit to 4 Gig
    if (llCur > 0xFFFFFFFF)
        goto seekerr;

    // if we have a stream and
    // we are currently in the file stream or the new seek seeks into the 
    // stream and the seek will not grow the stream, reseek in the stream
    if (    m_pstm
        &&  (   (m_dwOffset > m_cbAlloc)
            ||  (llCur > m_cbAlloc))
        &&  (llCur <= m_cbSize))
    {
        LARGE_INTEGER   li;
        
#ifdef MAC
        LISet32(li ,llCur < m_cbAlloc ? 0 : llCur - m_cbAlloc);
#else   // !MAC
        li.QuadPart = llCur < m_cbAlloc ? 0 : llCur - m_cbAlloc;
#endif  // MAC

        hr = m_pstm->Seek(li, STREAM_SEEK_SET, NULL);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
    }

    m_dwOffset = (ULONG)llCur;

	if (plibNewPosition)
#ifdef MAC
        LISet32(*plibNewPosition, llCur);
#else   // !MAC
        plibNewPosition->QuadPart = llCur;
#endif  // MAC

err:
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    return hr;
    
seekerr:
	hr = ResultFromScode(STG_E_MEDIUMFULL);
    goto err;
    // Done
}


// --------------------------------------------------------------------------------
// CVirtualStream::Write
// --------------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CVirtualStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
#else
STDMETHODIMP CVirtualStream::Write(const void HUGEP *pv, ULONG cb, ULONG *pcbWritten)
#endif // !WIN16
{
    // Locals
    HRESULT     hr      = ResultFromScode(S_OK);
    ULONG       cbNew;
    ULONG       cbWrite = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // figure out where we'll end up
    cbNew = cb + m_dwOffset;

    // make sure that we won't wrap
    if (cbNew < m_dwOffset)
        goto stmfull;

    // if that is past the end of the stream, make more stream
    if (cbNew > m_cbSize)
    {
        ULARGE_INTEGER uli = {cbNew, 0};
        hr = SetSize(uli);
        if (hr) goto err;
    }
        
    // figure out what we're putting into memory
    if (m_dwOffset < m_cbCommitted)
    {
        cbWrite = min(cb, m_cbCommitted - m_dwOffset);

        // copy the memory stuff
        CopyMemory(m_pb + m_dwOffset, (LPBYTE)pv, cbWrite);
    }

    // if we still have stuff to write, dump to the file
    if (cbWrite != cb)
    {
        ULONG   cbWritten;

        Assert(m_pstm);
        
#ifdef	DEBUG
        LARGE_INTEGER   li  = {0, 0};
        ULARGE_INTEGER  uli = {0, 0};

        if (!m_pstm->Seek(li, STREAM_SEEK_CUR, &uli))
#ifdef MAC
            Assert(0 == uli.HighPart);
            Assert(((m_dwOffset + cbWrite) - m_cbAlloc) == uli.LowPart);
#else   // !MAC
            Assert(((m_dwOffset + cbWrite) - m_cbAlloc) == uli.QuadPart);
#endif  // MAC
#endif
        
        hr = m_pstm->Write(((LPBYTE)pv) + cbWrite, cb - cbWrite, &cbWritten);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
        
        cbWrite += cbWritten;
    }

    m_dwOffset += cbWrite;
    
    if (pcbWritten)
        *pcbWritten = cbWrite;
err:
   
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;

stmfull:
	hr = ResultFromScode(STG_E_MEDIUMFULL);
    goto err;
}


STDMETHODIMP CVirtualStream::CopyTo(LPSTREAM pstmDst,
                                    ULARGE_INTEGER uli,
                                    ULARGE_INTEGER* puliRead,
                                    ULARGE_INTEGER* puliWritten)
{
    HRESULT         hr          = 0;
    UINT            cbBuf;
    ULONG           cbRemain;
    ULONG           cbReadMem   = 0;
    ULONG           cbWriteMem  = 0;
#ifdef MAC
    ULARGE_INTEGER  uliRead     = {0, 0};    
    ULARGE_INTEGER  uliWritten  = {0, 0};    
#else   // !MAC
    ULARGE_INTEGER  uliRead     = {0};    
    ULARGE_INTEGER  uliWritten  = {0};    
#endif  // MAC

    // Initialize the outgoing params
    if (puliRead)
    {
        ULISet32((*puliRead), 0);
    }

    if (puliWritten)
    {
        ULISet32((*puliWritten), 0);
    }
    
    if (!m_cbSize)
        goto err;

    // if the request is greater than the max ULONG, bring the request down to
    // the max ULONG
    if (uli.HighPart)
#ifdef MAC
        ULISet32(uli, ULONG_MAX);
#else   // !MAC
        uli.QuadPart = 0xFFFFFFFF;
#endif  // MAC

    if (m_dwOffset < m_cbCommitted)
    {
        if (m_cbSize < m_cbAlloc)
            cbReadMem = (ULONG)min(uli.LowPart, m_cbSize - m_dwOffset);
        else
            cbReadMem = (ULONG)min(uli.LowPart, m_cbAlloc - m_dwOffset);

        hr = pstmDst->Write(m_pb + m_dwOffset, cbReadMem, &cbWriteMem);
        if (!hr && (cbReadMem != cbWriteMem))
            hr = ResultFromScode(E_OUTOFMEMORY);
        if (hr) goto err;

        uli.LowPart -= cbReadMem;
    }

    // if we didn't get it all from memory and there is information in
    // the file stream, read from the file stream
    if (    uli.LowPart
        &&  (m_cbSize > m_cbAlloc)
        &&  m_pstm)
    {
        hr = m_pstm->CopyTo(pstmDst, uli, &uliRead, &uliWritten);
        if (hr)
        {
            m_fFileErr = TRUE;
            goto err;
        }
    }

    m_dwOffset += uliRead.LowPart + cbReadMem;
    
    // Total cbReadMem and ulRead because we have them both.
#ifdef MAC
    if (puliRead)
    {
        ULISet32(*puliRead, uliRead.LowPart);
        Assert(INT_MAX - cbReadMem >= puliRead->LowPart);
        puliRead->LowPart += cbReadMem;
    }

    if (puliWritten)
        puliWritten->LowPart = uliWritten.LowPart + cbWriteMem;
#else   // !MAC
    if (puliRead)
        puliRead->QuadPart = cbReadMem + uliRead.LowPart;

    // Add in cbWriteMem because any written from the file stream was
    // already set
    if (puliWritten)
        puliWritten->QuadPart = uliWritten.LowPart + cbWriteMem;
#endif  // MAC

err:
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\mimetest.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern UINT g_msgSMTP;

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\vstream.h ===
// --------------------------------------------------------------------------------
// Vstream.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Ronald E. Gray
// --------------------------------------------------------------------------------
#ifndef __VSTREAM_H
#define __VSTREAM_H

// --------------------------------------------------------------------------------
// CVirtualStream
// --------------------------------------------------------------------------------
class CVirtualStream : public IStream
{
private:
    ULONG       m_cRef;         // Reference count
    DWORD       m_cbSize;       // Current size of the stream
    DWORD       m_cbCommitted;  // Amount of virtual space committed
    DWORD       m_cbAlloc;      // Amount of virtual space reserved
    DWORD       m_dwOffset;     // Current location in stream
    IStream *   m_pstm;         // File backed stream for overflow
    LPBYTE      m_pb;           // pointer to memory part of stream
    BOOL        m_fFileErr;     // the pointer in the file stream may not
                                // be in sync with our pointer.  Try to sync
                                // before any other operation.
    CRITICAL_SECTION m_cs;      // Thread Safety

    // -------------------------------------------------------------------------
    // Utilities
    // -------------------------------------------------------------------------
    HRESULT SyncFileStream();

public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CVirtualStream(void);
    ~CVirtualStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
#ifndef WIN16
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
#else
    STDMETHODIMP Read (VOID HUGEP *, ULONG, ULONG*);
#endif // !WIN16
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
#ifndef WIN16
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
#else
    STDMETHODIMP Write (const void HUGEP *, ULONG, ULONG*);
#endif // !WIN16
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Commit(DWORD) {
        return S_OK; }
    STDMETHODIMP SetSize(ULARGE_INTEGER);
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *);
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CVirtualStream
    // -------------------------------------------------------------------------
    void QueryStat(ULARGE_INTEGER *puliOffset, ULARGE_INTEGER *pulSize);
};

#endif // __VSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\webpage.cpp ===
// --------------------------------------------------------------------------------
// WebPage.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "mhtmlurl.h"
#include "webpage.h"
#include "vstream.h"
#include "booktree.h"
#include "strconst.h"
#include "containx.h"
#include "bookbody.h"
#include "mimeapi.h"
#include "plainstm.h"
#include "mimeutil.h"
#include "symcache.h"
#include "dllmain.h"
#include "internat.h"
#include "shlwapi.h"
#include "enriched.h"
#include "resource.h"
//#include "util.h"
#include "demand.h"

// From Util.h
HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm);

// --------------------------------------------------------------------------------
// CMessageWebPage::CMessageWebPage
// --------------------------------------------------------------------------------
CMessageWebPage::CMessageWebPage(LPURLREQUEST pRequest) : m_pRequest(pRequest)
{
    TraceCall("CMessageWebPage::CMessageWebPage");
    Assert(m_pRequest);
    m_cRef = 1;
    m_pCallback = NULL;
    m_pRequest->AddRef();
    m_pHeadSegment = NULL;
    m_pTailSegment = NULL;
    m_pCurrSegment = NULL;
    m_fComplete = FALSE;
    m_cInline = 0;
    m_cbOffset = 0;
    m_cSlideShow = 0;
    ZeroMemory(&m_rOptions, sizeof(WEBPAGEOPTIONS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::~CMessageWebPage
// --------------------------------------------------------------------------------
CMessageWebPage::~CMessageWebPage(void)
{
    TraceCall("CMessageWebPage::~CMessageWebPage");
    Assert(m_pRequest == NULL);
    _VFreeSegmentList();
    if (m_pCallback && m_pCallback != this)
        m_pCallback->Release();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::QueryInterface");

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IStream *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else if (IID_IMimeMessageCallback == riid)
        *ppv = (IMimeMessageCallback *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageWebPage::AddRef(void)
{
    TraceCall("CMessageWebPage::AddRef");
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMessageWebPage::Release(void)
{
    TraceCall("CMessageWebPage::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::Read(LPVOID pvData, ULONG cbData, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbLeft=cbData;
    ULONG           cbRead=0;
    ULONG           cbSegmentRead;
    LPPAGESEGMENT   pSegment;

    // Tracing
    TraceCall("CMessageWebPage::Read");

    // Invalid Ags
    if (NULL == pvData)
        return TraceResult(E_INVALIDARG);

    // HrInitialize
    if (pcbRead)
        *pcbRead = 0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Only if there is a current segment
    if (m_pCurrSegment)
    {
        // HrInitialize Segment Loop
        while (cbLeft)
        {
            // Is there data left to read in this segment ?
            if (m_pCurrSegment->cbOffset == m_pCurrSegment->cbLength && TRUE == m_pCurrSegment->fLengthKnown)
            {
                // Are there no more segments ?
                if (NULL == m_pCurrSegment->pNext)
                    break;

                // Goto Next Segment
                m_pCurrSegment = m_pCurrSegment->pNext;
            }

            // We should have a stream for the current segment
            Assert(m_pCurrSegment->pStream);

            // Compute the current position of the stream
#ifdef DEBUG
            DWORD cbOffset;
            SideAssert(SUCCEEDED(HrGetStreamPos(m_pCurrSegment->pStream, &cbOffset)));
            Assert(cbOffset == m_pCurrSegment->cbOffset);
#endif
            // If I have computed the length of this item yet?
            IF_FAILEXIT(hr = m_pCurrSegment->pStream->Read((LPVOID)((LPBYTE)pvData + cbRead), cbLeft, &cbSegmentRead));

            // Increment offset
            m_pCurrSegment->cbOffset += cbSegmentRead;

            // Compute Global Offset
            m_cbOffset += cbSegmentRead;

            // Adjust the size of this segment ?
            if (m_pCurrSegment->cbOffset > m_pCurrSegment->cbLength)
            {
                Assert(FALSE == m_pCurrSegment->fLengthKnown);
                m_pCurrSegment->cbLength = m_pCurrSegment->cbOffset;
            }

            // Decrement amount left
            cbLeft -= cbSegmentRead;

            // Increment Amount Actually Read
            cbRead += cbSegmentRead;

            // If we read zero...we must have read all the data in this segment
            if (0 == cbSegmentRead)
            {
                Assert(m_pCurrSegment->cbLength == m_pCurrSegment->cbOffset);
                m_pCurrSegment->fLengthKnown = TRUE;
            }
        }
    }

    // Return Amount Read
    if (pcbRead)
        *pcbRead = cbRead;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbOffsetNew;
    DWORD           cbSize=0xffffffff;

    // Tracing
    TraceCall("CMessageWebPage::Seek");

    // Invalid Args
    Assert(dlibMove.HighPart == 0);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Relative to the beginning of the stream
    if (STREAM_SEEK_SET == dwOrigin)
    {
        // If less than zero, its an error
//        if (dlibMove.LowPart < 0)
//        {
//            hr = TraceResult(E_FAIL);
//            goto exit;
//        }
        // else

        // Otherwise, if past current offset...
        if (dlibMove.LowPart > m_cbOffset)
        {
            // If not finished binding, return E_PENDING 
            if (FALSE == m_fComplete)
            {
                hr = TraceResult(E_PENDING);
                goto exit;
            }

            // Compute Size of the Entire Stream
            IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

            // If past end of stream, error
            if (dlibMove.LowPart > cbSize)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Set new offset
        cbOffsetNew = (DWORD)dlibMove.LowPart;
    }

    // Relative to current offset
    else if (STREAM_SEEK_CUR == dwOrigin)
    {
        // If less than zero, and absolute is greater than its an error
        if ( (DWORD)(0 - dlibMove.LowPart) > m_cbOffset)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Otherwise, if past current offset...
        else if (m_cbOffset + dlibMove.LowPart > m_cbOffset)
        {
            // If not finished binding, return E_PENDING 
            if (FALSE == m_fComplete)
            {
                hr = TraceResult(E_PENDING);
                goto exit;
            }

            // Compute Size of the Entire Stream
            IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

            // If past end of stream, error
            if (dlibMove.LowPart > cbSize)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
        }

        // Set new offset
        cbOffsetNew = m_cbOffset + dlibMove.LowPart;
    }

    // Relative to the end of the stream
    else if (STREAM_SEEK_END == dwOrigin)
    {
        // If not finished binding, return E_PENDING 
        if (FALSE == m_fComplete)
        {
            hr = TraceResult(E_PENDING);
            goto exit;
        }

        // Compute Size of the Entire Stream
        IF_FAILEXIT(hr = _ComputeStreamSize(&cbSize));

        // If negative or greater than size, its an error
        if ( (DWORD)dlibMove.LowPart > cbSize)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Set new offset
        cbOffsetNew = cbSize - dlibMove.LowPart;
    }

    // Otherwise, its an error
    else
    {
        hr = TraceResult(STG_E_INVALIDFUNCTION);
        goto exit;
    }

    // Only if a change
    if (m_cbOffset != cbOffsetNew)
    {
        // New offset greater than size...
        m_cbOffset = cbOffsetNew;

        // Walk through the segments
        for (m_pCurrSegment=m_pHeadSegment; m_pCurrSegment!=NULL; m_pCurrSegment=m_pCurrSegment->pNext)
        {
            // Never Seeks beyond length
            Assert(FALSE == m_pCurrSegment->fLengthKnown ? cbOffsetNew <= m_pCurrSegment->cbLength : TRUE);

            // Offset falls into this segment ?
            if (cbOffsetNew <= m_pCurrSegment->cbLength)
            {
                // Set Offset within m_pCurrSegment->pStream
                m_pCurrSegment->cbOffset = cbOffsetNew;

                // Should have a stream
                Assert(m_pCurrSegment->pStream);

                // Seek the stream
                IF_FAILEXIT(hr = HrStreamSeekSet(m_pCurrSegment->pStream, m_pCurrSegment->cbOffset));

                // Reset the Offsets of the remaining segments
                for (LPPAGESEGMENT pSegment=m_pCurrSegment->pNext; pSegment!=NULL; pSegment=pSegment->pNext)
                {
                    // At 0
                    pSegment->cbOffset = 0;

                    // Seek the stream
                    IF_FAILEXIT(hr = HrStreamSeekSet(pSegment->pStream, 0));
                }
                
                // Done
                break;
            }

            // Otherwise, seek the stream to the end offset / length
            else
            {
                // Must know the length
                Assert(m_pCurrSegment->fLengthKnown);

                // Set Offset
                m_pCurrSegment->cbOffset = m_pCurrSegment->cbLength;

                // Seek the stream
                IF_FAILEXIT(hr = HrStreamSeekSet(m_pCurrSegment->pStream, m_pCurrSegment->cbOffset));
            }

            // Decrement cbOffsetNew
            cbOffsetNew -= m_pCurrSegment->cbLength;
        }
    }

    // Return Position
    if (plibNew)
    {
        plibNew->HighPart = 0;
        plibNew->LowPart = (LONG)m_cbOffset;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_ComputeStreamSize
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_ComputeStreamSize(LPDWORD pcbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPAGESEGMENT   pCurrSegment;

    // Tracing
    TraceCall("CMessageWebPage::_ComputeStreamSize");

    // Invalid Args
    Assert(pcbSize && m_fComplete);

    // Initialize
    *pcbSize = 0;

    // Walk through the segments
    for (pCurrSegment=m_pHeadSegment; pCurrSegment!=NULL; pCurrSegment=pCurrSegment->pNext)
    {
        // If length is not known, then get its size
        if (FALSE == pCurrSegment->fLengthKnown)
        {
            // There better be a stream
            Assert(pCurrSegment->pStream);

            // Get the size of the stream
            IF_FAILEXIT(hr = HrGetStreamSize(pCurrSegment->pStream, &pCurrSegment->cbLength));

            // Set Size is known
            pCurrSegment->fLengthKnown = TRUE;
        }

        // Increment Size
        (*pcbSize) += pCurrSegment->cbLength;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_AllocateSegment
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_AllocateSegment(LPPAGESEGMENT *ppSegment, BOOL fCreateStream)
{
    // Locals
    HRESULT         hr=S_OK;

    // Invalid Args
    Assert(ppSegment);

    // Tracing
    TraceCall("CMessageWebPage::_AllocateSegment");

    // Allocate It
    IF_NULLEXIT(*ppSegment = (LPPAGESEGMENT)g_pMalloc->Alloc(sizeof(PAGESEGMENT)));

    // Zero
    ZeroMemory(*ppSegment, sizeof(PAGESEGMENT));

    // Create a Stream ?
    if (fCreateStream)
    {
        // Allocate a Stream
        IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&(*ppSegment)->pStream));
    }

exit:
    // Failure ?
    if (FAILED(hr) && *ppSegment != NULL)
    {
        SafeRelease((*ppSegment)->pStream);
        SafeMemFree((*ppSegment));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VAppendSegment
// --------------------------------------------------------------------------------
void CMessageWebPage::_VAppendSegment(LPPAGESEGMENT pSegment)
{
    // Invalid Args
    Assert(pSegment);

    // Tracing
    TraceCall("CMessageWebPage::_VAppendSegment");

    // Head is Null
    if (NULL == m_pHeadSegment)
    {
        Assert(NULL == m_pTailSegment);
        m_pCurrSegment = m_pHeadSegment = m_pTailSegment = pSegment;
    }

    // Otherwise, append to tail
    else
    {
        Assert(m_pTailSegment);
        m_pTailSegment->pNext = pSegment;
        pSegment->pPrev = m_pTailSegment;
        m_pTailSegment = pSegment;
    }
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VFreeSegmentList
// --------------------------------------------------------------------------------
void CMessageWebPage::_VFreeSegmentList(void)
{
    // Locals
    LPPAGESEGMENT       pCurr;
    LPPAGESEGMENT       pNext;

    // Tracing
    TraceCall("CMessageWebPage::_VFreeSegmentList");

    // HrInitialize Curr
    pCurr = m_pHeadSegment;

    // Loop
    while(pCurr)
    {
        // Set pNext
        pNext = pCurr->pNext;

        // Free This One
        _VFreeSegment(pCurr);

        // Goto Next
        pCurr = pNext;
    }

    // Set Head and Tail
    m_pHeadSegment = m_pTailSegment = NULL;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VFreeSegment
// --------------------------------------------------------------------------------
void CMessageWebPage::_VFreeSegment(LPPAGESEGMENT pSegment)
{
    TraceCall("CMessageWebPage::_VFreeSegment");
    SafeRelease(pSegment->pStream);
    g_pMalloc->Free(pSegment);
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_VInitializeCharacterSet
// --------------------------------------------------------------------------------
void CMessageWebPage::_VInitializeCharacterSet(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    rCharset;
    DWORD           dwCodePage=0;
    HCHARSET        hCharset;

    // Tracing
    TraceCall("CMessageWebPage::_VInitializeCharacterSet");

    // Get the Character Set
    pTree->GetCharset(&m_hCharset);

    // Raid-47838: Nav4 message in iso-2022-jp causes initialization error
    if (NULL == m_hCharset)
    {
        // Get the default character set
        if (SUCCEEDED(g_pInternat->GetDefaultCharset(&hCharset)))
            m_hCharset = hCharset;
    }

#ifdef BROKEN
    // Raid-43580: Special case for codepage 50220 - iso-2022-jp and 50932 - JP auto use JP windows codepage instead to preserve half width Kana data
    MimeOleGetCharsetInfo(m_hCharset, &rCharset);

    // Map Character set
    if (rCharset.cpiInternet == 50220 || rCharset.cpiInternet == 50932)
    {
        // Raid-35230: hard-code to ISO-2022-JP-ESC or ISO-2022-JP-SIO
        hCharset = GetJP_ISOControlCharset();
        if (hCharset)
            m_hCharset = hCharset;
    }
#endif

    // We better have a charset
    Assert(m_hCharset);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::Initialize
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::Initialize(IMimeMessageCallback *pCallback, LPMESSAGETREE pTree, 
    LPWEBPAGEOPTIONS pOptions)
{
    // Locals
    HRESULT         hr=S_OK;
    INETCSETINFO    rCsetInfo;
    CODEPAGEINFO    rCodePage;
    LPSTR           pszCharset;
    LPPAGESEGMENT   pSegment=NULL;

    // Tracing
    TraceCall("CMessageWebPage::Initialize");

    // No Options ?
    Assert(pOptions);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better have a request
    Assert(m_pRequest);

    // No WebPage Callback
    if (pCallback)
    {
        m_pCallback = pCallback;
        m_pCallback->AddRef();
    }
    else
        m_pCallback = this;

    // Save the Options
    CopyMemory(&m_rOptions, pOptions, sizeof(WEBPAGEOPTIONS));

    // Remap the Character Set ?
    _VInitializeCharacterSet(pTree);

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // Client wants meta-tag?
    if (!ISFLAGSET(m_rOptions.dwFlags, WPF_NOMETACHARSET))
    {
        // Get the charset information
        IF_FAILEXIT(hr = MimeOleGetCharsetInfo(m_hCharset, &rCsetInfo));

        // Get the codepage information
        IF_FAILEXIT(hr = MimeOleGetCodePageInfo(rCsetInfo.cpiInternet, &rCodePage));

        // Set the charset to write into the meta tag
        pszCharset = FIsEmpty(rCodePage.szWebCset) ? rCodePage.szBodyCset : rCodePage.szWebCset;

        // If Still Empty, use iso-8859-1
        if (FIsEmpty(pszCharset))
            pszCharset = (LPSTR)STR_ISO88591;

        // Write STR_METATAG_PREFIX
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_METATAG_PREFIX, lstrlen(STR_METATAG_PREFIX), NULL));

        // Write the Charset
        IF_FAILEXIT(hr = pSegment->pStream->Write(pszCharset, lstrlen(pszCharset), NULL));

        // Write STR_METATAG_POSTFIX
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_METATAG_POSTFIX, lstrlen(STR_METATAG_POSTFIX), NULL));
    }

    // Only showing images ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_IMAGESONLY))
    {
        // Locals
        CHAR szRes[255];

        // Load the string
        LoadString(g_hLocRes, idsImagesOnly, szRes, ARRAYSIZE(szRes));

        // Write idsImagesOnly
        IF_FAILEXIT(hr = pSegment->pStream->Write(szRes, lstrlen(szRes), NULL));
    }

    // Rewind the segment
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    if (pSegment)
        _VFreeSegment(pSegment);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_GetInlineHtmlStream
// --------------------------------------------------------------------------------
#define CCHMAX_SNIFFER 64
HRESULT CMessageWebPage::_GetInlineHtmlStream(LPMESSAGETREE pTree, LPTREENODEINFO pNode,
                                              LPSTREAM *ppStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fQuote;
    IStream        *pStmHtml=NULL;
    IStream        *pStmHtmlW=NULL;
    IStream        *pStmPlainW=NULL;
    IStream        *pStmEnriched=NULL;
    ULONG           cbRead;
    LPWSTR          pwszType=NULL;
    WCHAR           wszHeader[CCHMAX_SNIFFER];
    CHAR            szHeader[CCHMAX_SNIFFER];
    
    // Tracing
    TraceCall("CMessageWebPage::_GetInlineHtmlStream");
    
    // Invalid Args
    Assert(pTree && pNode && ppStream);
    
    // HrInitialize
    *ppStream = NULL;
    
    // text/html ?
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
    {
        // Just get and return an HTML inetcset encoded stream
        IF_FAILEXIT(hr = pNode->pBody->GetData(IET_INETCSET, &pStmHtml));
    }
    
    // text/enriched
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED))
    {
        // Convert to HTML
        IF_FAILEXIT(hr = MimeOleConvertEnrichedToHTMLEx((IMimeBody *)pNode->pBody, IET_INETCSET, &pStmHtml));
    }
    
    // text/*
    else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, NULL))
    {
        // Get the data
        IF_FAILEXIT(hr = pNode->pBody->GetData(IET_UNICODE, &pStmPlainW));
        
        // Read Off the first 255 bytes
        IF_FAILEXIT(hr = pStmPlainW->Read(wszHeader, (CCHMAX_SNIFFER * sizeof(WCHAR)), &cbRead));
        
        // Did we read something
        if (cbRead > 0)
        {
            // Null It
            ULONG cchRead = (cbRead / sizeof(WCHAR)) - 1;
            
            // Null It Out
            wszHeader[cchRead] = L'\0';
            
            // Convert to ANSI
            szHeader[0] = L'\0';
            
            if(WideCharToMultiByte(CP_ACP, 0, wszHeader, -1, szHeader, ARRAYSIZE(szHeader) - 1, NULL, NULL) == 0)
            {
                IF_FAILEXIT(hr = HrRewindStream(pStmPlainW));
            }
            
            else
            {
                // Lets Read the first "<x-rich>" bytes and see if it might be text/enriched
                if (0 == StrCmpI(szHeader, "<x-rich>"))
                {
                    // Convert to HTML
                    IF_FAILEXIT(hr = MimeOleConvertEnrichedToHTMLEx((IMimeBody *)pNode->pBody, IET_INETCSET, &pStmHtml));
                }
                
                // Is this html ?
                else if (SUCCEEDED(FindMimeFromData(NULL, NULL, szHeader, cchRead, NULL, NULL, &pwszType, 0)) && pwszType && 0 == StrCmpIW(pwszType, L"text/html"))
                {
                    // Release pStmPlainW
                    SafeRelease(pStmPlainW);
                    
                    // Just get and return an HTML inetcset encoded stream
                    IF_FAILEXIT(hr = pNode->pBody->GetData(IET_INETCSET, &pStmHtml));
                }
                
                // Otherwise, rewind pStmPlainW
                else
                {
                    // Rewind
                    IF_FAILEXIT(hr = HrRewindStream(pStmPlainW));
                }
            }
        }
    }
    
    // Otheriwse
    else
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // We have HTML
    if (pStmHtml)
    {
        // Client wants HTML
        if (ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
        {
            // Return the Html Stream
            *ppStream = pStmHtml;
            pStmHtml = NULL;
            goto exit;
        }
        
        // Otherwise, client wants plain text
        else
        {
            // Convert to Plain text
            IF_FAILEXIT(hr = HrConvertHTMLToFormat(pStmHtml, &pStmPlainW, CF_UNICODETEXT));
        }
    }
    
    // Otherwise, if I have a plain stream
    if (NULL == pStmPlainW)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // Determine if we should quote (Can't quote QP)
    fQuote = (IET_QP == pNode->pContainer->GetEncodingType()) ? FALSE : TRUE;
    
    // Convert Unicode Plain stream to HTML
    IF_FAILEXIT(hr = HrConvertPlainStreamW(pStmPlainW, fQuote ? m_rOptions.wchQuote : NULL, &pStmHtmlW));
    
    // Convert from unicode back to int