ILE_HDR
        +------------------------+
        |                        |
        |    Block alloc map     | <--- Array of DWORDs.  Each bit represents the
        |                        |      allocation state of a record block.
        |                        |      0 = free, 1 = allocated.
        +------------------------+
        |                        |
        |                        |
        |                        | <--- Array of BLOCKs. (32-bytes each)
        |    Record blocks       |      Each data record consists of one or more
        |                        |      blocks.  The first block in each record
        |                        |      is of type RECORD_HDR.  The remaining
        |                        |      blocks contain the variable-length SID,
        |                        |      Domain name, User name and Full User
        |                        |      name.  Blocks are aligned on quadword
        |                        |      boundaries for the FILETIME structure
        |                        |      in RECORD_HDR.  The 3 name string fields
        |                        |      are UNICODE and are WORD-aligned.
        |                        |      Unused blocks are filled with 0xCC.
        |                        |      A BLOCK is the smallest allocation unit.
        +------------------------+


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/12/96    Initial creation.                                    BrianAu
    08/14/96    Added SidCacheQueueIterator.                         BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/20/96    Total redesign.  Old design loaded data from file    BrianAu
                into an in-memory hash table.  New design leaves
                everything on disk and merely maps the file into
                memory.  Much more efficient with respect to
                speed and size.
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
const DWORD BITS_IN_BYTE         = 8;
const DWORD BITS_IN_DWORD        = BITS_IN_BYTE * sizeof(DWORD);


//
// On-disk structure of a single index entry.
// There's an entry for each record in the cache.
// Length = 16 bytes.
//
typedef struct index_entry
{
    index_entry *pPrev;
    index_entry *pNext;
    DWORD        iBlock;
    DWORD        iBucket;

} INDEX_ENTRY, *PINDEX_ENTRY;

//
// On-disk structure of index file header.
// Length = 48 bytes
// Must be even multiple of 8 bytes (quadword-align).
//
typedef struct index_file_hdr
{
    DWORD dwSignature;       // ID's file as a quota cache index.
    DWORD dwVersion;         // SW version that created file.
    GUID  guid;              // Verifies validity of data.
    DWORD cBuckets;          // Number of hash buckets.
    DWORD cMaxEntries;       // Max number of entries.
    DWORD cEntries;          // Number of used entries.
    PINDEX_ENTRY *pBuckets;  // Address of first hash bucket.
    PINDEX_ENTRY pEntries;   // Offset to first entry.
    PINDEX_ENTRY pFirstFree; // Offset to first entry in free list.

} INDEX_FILE_HDR, *PINDEX_FILE_HDR;

//
// Define what a data file "block" is.
// Keep the block size a power of 2.
//
const DWORD BLOCK_SIZE = 32;    // Size is in bytes.

typedef BYTE BLOCK[BLOCK_SIZE];
typedef BLOCK *PBLOCK;

//
// On-disk structure of data file header.
// Length = 48 bytes.
//
typedef struct data_file_hdr
{
    DWORD dwSignature;  // ID's file as quota cache data.
    DWORD dwVersion;    // SW version that created file.
    GUID  guid;         // Verifies validity of data.
    DWORD cBlocks;      // Total number of allocation blocks.
    DWORD cBlocksUsed;  // Number of used allocation blocks.
    DWORD cMapElements; // Number of alloc map elements.
    DWORD iFirstFree;   // Index of first free block.
    LPDWORD pdwMap;     // Address of alloc map.
    PBLOCK pBlocks;     // Address of block pool.

} DATA_FILE_HDR, *PDATA_FILE_HDR;

//
// On-disk structure of the header info for each record.
// This fixed length structure precedes the variable-length part.
// Quad-word aligned.
// Length = 32 bytes (1 block).
// Strings are UNICODE, WORD-aligned.
//
typedef struct record_hdr
{
    DWORD dwSignature;       // Rec hdr signature. (0xAAAA5555)
    DWORD cBlocks;           // Blks in record.
    FILETIME Birthday;       // When was record added to cache?
    DWORD cbOfsSid;          // Ofs from start of record.
    DWORD cbOfsContainer;    // Ofs from start of record.
    DWORD cbOfsLogonName;    // Ofs from start of record.
    DWORD cbOfsDisplayName;  // Ofs from start of record.

} RECORD_HDR, *PRECORD_HDR;


class SidNameCache
{
    private:
        //
        // Private class encapsulating the functions of the cache index.
        //
        class IndexMgr
        {
            private:

                SidNameCache&    m_refCache;     // Ref to outer cache object.
                PINDEX_FILE_HDR  m_pFileHdr;     // Same as g_pbMappedIndexFile.
                HANDLE           m_hFile;        // Handle to index file.
                HANDLE           m_hFileMapping; // Mapped file.
                CString          m_strFileName;  // Full path\name of index file.


                LPBYTE CreateIndexFile(LPCTSTR pszFile,
                                       DWORD cbFileHigh,
                                       DWORD cbFileLow);

                LPBYTE OpenIndexFile(LPCTSTR pszFile);

                LPBYTE GrowIndexFile(DWORD cGrowEntries);

                VOID CloseIndexFile(VOID);

                VOID InitNewIndexFile(DWORD cBuckets, DWORD cMaxEntries);

                PINDEX_ENTRY AllocEntry(VOID);

                VOID FreeEntry(PINDEX_ENTRY pEntry);
                VOID AddEntryToFreeList(PINDEX_ENTRY pEntry);
                PINDEX_ENTRY DetachEntry(PINDEX_ENTRY pEntry);

                PINDEX_ENTRY Find(PSID pSid);
                PINDEX_ENTRY Find(PSID pSid, DWORD dwHashCode);
                PINDEX_ENTRY Find(LPCTSTR pszLogonName);

                DWORD Hash(PSID pSid);

                PINDEX_ENTRY GetHashBucketValue(DWORD iBucket);
                VOID SetHashBucketValue(DWORD iBucket, PINDEX_ENTRY pEntry);

                //
                // Prevent copy.
                //
                IndexMgr(const IndexMgr& rhs);
                IndexMgr& operator = (const IndexMgr& rhs);


            public:
                IndexMgr(SidNameCache& refCache);
                ~IndexMgr(VOID);

                LPBYTE Initialize(LPCTSTR pszFile,
                                  DWORD cBuckets = 0,
                                  DWORD cMaxEntries = 0);

                DWORD Lookup(PSID pSid);
                DWORD Lookup(LPCTSTR pszLogonName);

                PINDEX_ENTRY Add(PSID pSid, DWORD iBlock);

                static UINT64 FileSize(DWORD cMaxEntries, DWORD cBuckets)
                    {
                        return (UINT64)(sizeof(INDEX_FILE_HDR)) +
                               (UINT64)(sizeof(PINDEX_ENTRY) * cBuckets) +
                               (UINT64)(sizeof(INDEX_ENTRY) * cMaxEntries);
                    }

                VOID SetFileGUID(const GUID *pguid);
                VOID GetFileGUID(LPGUID pguid);
                VOID FreeEntry(PSID pSid);
                VOID Clear(VOID);
#ifdef DBG
                VOID Dump(VOID);
#endif
        };

        //
        // Private class that manages the cache's stored data records.
        //
        class RecordMgr
        {
            private:
                SidNameCache&   m_refCache;          // Ref to outer cache object.
                PDATA_FILE_HDR  m_pFileHdr;          // Same as g_pbMappedDataFile
                HANDLE          m_hFile;             // Handle to data file.
                HANDLE          m_hFileMapping;      // Mapped data file.
                DWORD           m_cDaysRecLifeMin;   // Min and range are used to
                DWORD           m_cDaysRecLifeRange; // calc lifetime of records.
                CString         m_strFileName;       // Full path\name of data file.

                BOOL ValidBlockNumber(DWORD iBlock);
                VOID FillBlocks(DWORD iBlock, DWORD cBlocks, BYTE b);
                BOOL IsBitSet(LPDWORD pdwBase, DWORD iBit);
                VOID SetBit(LPDWORD pdwBase, DWORD iBit);
                VOID ClrBit(LPDWORD pdwBase, DWORD iBit);
                BOOL IsBlockUsed(DWORD iBlock);
                VOID MarkBlockUsed(DWORD iBlock);
                VOID MarkBlockUnused(DWORD iBlock);
                DWORD BlocksRequired(DWORD cb);
                DWORD BytesRequiredForRecord(
                    PSID pSid,
                    LPDWORD pcbSid,
                    LPCTSTR pszContainer,
                    LPDWORD pcbContainer,
                    LPCTSTR pszLogonName,
                    LPDWORD pcbLogonName,
                    LPCTSTR pszDisplayName,
                    LPDWORD pcbDisplayName);

                VOID FreeBlock(DWORD iBlock);
                VOID FreeBlocks(DWORD iFirstBlock, DWORD cBlocks);
                BLOCK *BlockAddress(DWORD iBlock);
                DWORD AllocBlocks(DWORD cbRecord);
                LPBYTE CreateDataFile(LPCTSTR pszFile, DWORD cbFileHigh, DWORD cbFileLow);
                LPBYTE OpenDataFile(LPCTSTR pszFile);
                LPBYTE GrowDataFile(DWORD cGrowBlocks);
                VOID InitNewDataFile(DWORD cBlocks);
                VOID CloseDataFile(VOID);

                //
                // Prevent copy.
                //
                RecordMgr(const RecordMgr& rhs);
                RecordMgr& operator = (const RecordMgr& rhs);


            public:

                RecordMgr(SidNameCache& refCache);
                ~RecordMgr(VOID);

                LPBYTE Initialize(
                    LPCTSTR pszFile,
                    DWORD cBlocks = 0);

                static UINT64 FileSize(DWORD cBlocks);

                DWORD Store(
                    PSID pSid,
                    LPCTSTR pszContainer,
                    LPCTSTR pszLogonName,
                    LPCTSTR pszDisplayName);

                BOOL RecordExpired(DWORD iBlock);

                HRESULT Retrieve(
                    DWORD iBlock,
                    PSID *ppSid,
                    LPTSTR *ppszContainer,
                    LPTSTR *ppszLogonName,
                    LPTSTR *ppszDisplayName);

                VOID SetFileGUID(const GUID *pguid);
                VOID GetFileGUID(LPGUID pguid);
                VOID FreeRecord(DWORD iFirstBlock);
                VOID Clear(VOID);
#ifdef DBG
                VOID Dump(VOID);
#endif
        };

        //
        // Private class for handling locks on cache files that must
        // be automatically released when an exception is thrown.
        //
        class CacheAutoLock
        {
            public:
                explicit CacheAutoLock(SidNameCache& Cache)
                    : m_Cache(Cache) { };

                BOOL Lock(VOID)
                    { return m_Cache.Lock(); }

                ~CacheAutoLock(VOID)
                    {m_Cache.ReleaseLock(); }

            private:
                SidNameCache& m_Cache;
                //
                // Prevent copy.
                //
                CacheAutoLock(const CacheAutoLock& rhs);
                CacheAutoLock& operator = (const CacheAutoLock& rhs);
        };

        friend class CacheAutoLock;

        HANDLE        m_hMutex;        // For locking during updates.
        IndexMgr     *m_pIndexMgr;     // Manages index file.
        RecordMgr    *m_pRecordMgr;    // Manages data file.
        CString       m_strFilePath;   // Path to cache files.

        BOOL Lock(VOID);
        VOID ReleaseLock(VOID);
        BOOL FilesAreValid(VOID);
        VOID ValidateFiles(VOID);
        VOID InvalidateFiles(VOID);
        VOID SetCacheFilePath(VOID);
        BOOL CreateCacheFileDirectory(LPCTSTR pszPath);

        //
        // Private ctor prevents creation outside of singleton access
        // function.
        //
        SidNameCache(VOID);
        //
        // The singleton instance access function.
        //
        friend HRESULT SidNameCache_GetOrDestroy(SidNameCache **ppCache, bool bGet);

    public:
        ~SidNameCache(VOID);

        HRESULT Initialize(
            BOOL bOpenExisting);

        HRESULT Lookup(
            PSID pSid,
            LPTSTR *ppszContainer,
            LPTSTR *ppszLogonName,
            LPTSTR *ppszDisplayName);

        HRESULT Lookup(
            LPCTSTR pszLogonName,
            PSID *ppSid);

        HRESULT Add(
            PSID pSid,
            LPCTSTR pszContainer,
            LPCTSTR pszLogonName,
            LPCTSTR pszDisplayName);

//        HRESULT CheckConsistency(VOID);

        BOOL Clear(VOID);

        HRESULT BeginTransaction(VOID);
        VOID EndTransaction(VOID);

        static LPBYTE OpenMappedFile(
                        LPCTSTR pszDataFile,
                        LPCTSTR pszMapping,
                        DWORD dwCreation,
                        DWORD cbFileHigh,
                        DWORD cbFileLow,
                        PHANDLE phFile,
                        PHANDLE phFileMapping);

        static BOOL IsQuadAligned(LPVOID pv);
        static BOOL IsQuadAligned(DWORD_PTR dw);
        static VOID QuadAlign(LPDWORD lpdwValue);
        static VOID WordAlign(LPDWORD lpdwValue);

#if DBG
        VOID Dump(VOID)
            { m_pIndexMgr->Dump(); m_pRecordMgr->Dump(); }
#endif

        friend class IndexMgr;
        friend class RecordMgr;
};


HRESULT SidNameCache_Get(SidNameCache **ppCache);
HRESULT SidNameCache_Destroy(void);


#endif // _INC_DSKQUOTA_SIDCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\sidname.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: sidname.cpp

    Description: Implements the SID-to-NAME resolver.  It is anticipated that
        resolving a user's SID to it's corresponding name can be a lengthy
        process.  We don't want the quota controller's client to experience
        slow user enumerations just because it takes a long time to resolve
        a name.  Therefore, this object was created to perform the 
        SID-to-name resolutions on a background thread and notify the
        client whenever a name has been resolved.  That way, the client
        can display a list of users then fill in the names as names
        are resolved.  


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "control.h"
#include "guidsp.h"    // Private GUIDs.
#include "registry.h"
#include "sidname.h"
#include "sidcache.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


//
// SID/Name resolver messages (SNRM_XXXXXXXX).
//
#define SNRM_CLEAR_INPUT_QUEUE   (WM_USER + 1)
#define SNRM_EXIT_THREAD         (WM_USER + 2)

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::SidNameResolver

    Description: SidNameResolver constructor.

    Arguments:
        rQuotaController - Reference to quota controller that this resolver is
            working for.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameResolver::SidNameResolver(
    DiskQuotaControl& rQuotaController)
    : m_cRef(0),
      m_rQuotaController(rQuotaController),
      m_hsemQueueNotEmpty(NULL),
      m_hMutex(NULL),
      m_dwResolverThreadId(0),
      m_hResolverThread(NULL),
      m_heventResolverThreadReady(NULL)
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::SidNameResolver")));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::~SidNameResolver

    Description: SidNameResolver destructor.

    Arguments: None.

    Returns: Nothing.
 
    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameResolver::~SidNameResolver(void)
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::~SidNameResolver")));

    if (NULL != m_hsemQueueNotEmpty)
    {
        CloseHandle(m_hsemQueueNotEmpty);
    }
    if (NULL != m_hMutex)
    {
        CloseHandle(m_hMutex);
    }
    if (NULL != m_hResolverThread)
    {
        CloseHandle(m_hResolverThread);
    }
    if (NULL != m_heventResolverThreadReady)
    {
        CloseHandle(m_heventResolverThreadReady);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        ISidNameResolver interface.  
        Only IID_IUnknown, IID_ISidNameResolver are recognized.  
        The object referenced by the returned interface pointer is uninitialized.  
        The recipient of the pointer must call Initialize() before the object 
        is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/07/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
SidNameResolver::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::QueryInterface")));
    DBGPRINTIID(DM_RESOLVER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_ISidNameResolver == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
SidNameResolver::AddRef(
    VOID
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::AddRef")));
    DBGPRINT((DM_RESOLVER, DL_LOW, TEXT("\t0x%08X %d -> %d"),
             this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
SidNameResolver::Release(
    VOID
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::Release")));
    DBGPRINT((DM_RESOLVER, DL_LOW, TEXT("\t0x%08X %d -> %d"),
             this, m_cRef, m_cRef - 1));
    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Initialize

    Description: Initializes a SidNameResolver object.
        This function performs lot's of initialization steps so I chose to 
        use the "jump to label on failure" approach.  It avoids a lot of
        deeply nested "ifs".

    Arguments: None.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Initialization failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    08/14/96    Moved SID/Name cache initialization to               BrianAu
                FindCachedUserName() method.  Only initialize cache
                when it is truly needed.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::Initialize(
    VOID
    ) 
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::Initialize")));
    HRESULT hResult  = NO_ERROR;
    DWORD dwThreadId = 0;

    //
    // Configure the user queue so it grows in chunks of 100.
    //
    m_UserQueue.SetSize(100);
    m_UserQueue.SetGrow(100);

    //
    // IMPORTANT:  There is code in the QuotaControl object that
    //             counts on the thread being created LAST in this function.
    //             See DiskQuotaControl::CreateEnumUsers.  
    //             Thread creation must be the last thing performed in this
    //             function.  The caller assumes that if this function returns
    //             E_FAIL, no thread was created.
    //
    m_hMutex = CreateMutex(NULL, FALSE, NULL);
    if (NULL == m_hMutex)
        goto InitFailed;

    m_hsemQueueNotEmpty = CreateSemaphore(NULL,        // No security.
                                          0,           // Initially empty queue.
                                          0x7FFFFFFF,  // Max count (a lot).
                                          NULL);       // No name.
    if (NULL == m_hsemQueueNotEmpty)
        goto InitFailed;

    m_heventResolverThreadReady = CreateEvent(NULL,   // No security.
                                              TRUE,   // Manual reset.
                                              FALSE,  // Initially non-signaled.
                                              NULL);  // No name.
    if (NULL == m_heventResolverThreadReady)
        goto InitFailed;


    hResult = CreateResolverThread(&m_hResolverThread, &m_dwResolverThreadId);
    DBGPRINT((DM_RESOLVER, DL_MID, TEXT("Resolver thread. hThread = 0x%08X, idThread = %d"),
             m_hResolverThread, m_dwResolverThreadId));

    if (FAILED(hResult))
        goto InitFailed;
InitFailed:

    //
    // Failure only returns E_FAIL.
    //
    if (FAILED(hResult))
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::Shutdown

    Description: Commands the resolver to terminate its activities.
        When the resolver's client is through with the resolver's services,
        it should call Shutdown() followed by IUnknown::Release().  The function
        sends a WM_QUIT message to the resolver thread.

    Arguments: None.

    Returns:
        NO_ERROR    - Success
        E_FAIL      - Failed to send WM_QUIT message.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/29/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::Shutdown(
    BOOL bWait
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::Shutdown")));
    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("\tThread ID = %d"), m_dwResolverThreadId));

    BOOL bResult = FALSE;
    if (0 != m_dwResolverThreadId)
    {
        bResult = PostThreadMessage(m_dwResolverThreadId, WM_QUIT, 0, 0);
        if (bResult && bWait && NULL != m_hResolverThread)
        {
            //
            // Wait for thread to terminate normally.
            //
            DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("Resolver waiting for thread to exit...")));
            WaitForSingleObject(m_hResolverThread, INFINITE);
        }
    }

    return bResult ? NO_ERROR : E_FAIL;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::GetUserSid

    Description: Private method that allocates a SID buffer and retrieves
        the user's SID into that buffer.  The caller must free the returned
        buffer when done with it.

    Arguments:
        pUser - Pointer to user's IDiskQuotaUser interface.

        ppSid - Address of a PSID variable to receive the address of the
            allocated SID buffer.

    Returns:
        NO_ERROR        - Success.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::GetUserSid(
    PDISKQUOTA_USER pUser, 
    PSID *ppSid
    )
{
    HRESULT hResult   = NO_ERROR;
    DWORD cbSid = 0;

    DBGASSERT((NULL != pUser));
    hResult = pUser->GetSidLength(&cbSid);
    if (SUCCEEDED(hResult))
    {
        PSID pUserSid = NULL;

        pUserSid = (PSID) new BYTE[cbSid];

        hResult = pUser->GetSid((PBYTE)pUserSid, cbSid);
        if (SUCCEEDED(hResult))
        {
            DBGASSERT((IsValidSid(pUserSid)));
            DBGASSERT((NULL != ppSid));
            *ppSid = pUserSid; // Return address of buffer to caller.
                               // Caller must free it when done.
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - GetSid failed.")));
            delete[] pUserSid; // Failed to get SID.  Free buffer.
        }
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - GetUserSid failed.")));
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::AddUserToResolverQueue

    Description: Adds a user pointer to the resolver's input queue.

    Arguments:
        pUser - Address of IDiskQuotaUser ptr.

    Returns:
        NO_ERROR        - Success.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
    12/10/96    Removed interface marshaling. Using free-threading   BrianAu
                model.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::AddUserToResolverQueue(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::AddUserToResolverQueue")));
    DBGASSERT((NULL != pUser));
    HRESULT hResult = NO_ERROR;

    //
    // Add user object pointer to resolver input queue.
    // This can throw OutOfMemory.
    //
    pUser->AddRef();
    try
    {
        m_UserQueue.Add(pUser);
    }
    catch(CAllocException& e)
    {
        pUser->Release();
        hResult = E_OUTOFMEMORY;
    }

    //
    // Increment queue's semaphore count.
    // Means there's something in queue to process.
    //
    ReleaseSemaphore(m_hsemQueueNotEmpty, 1, NULL);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::RemoveUserFromResolverQueue

    Description: Removes a user pointer from the resolver's input queue.

    Arguments:
        ppUser - Address of pointer variable to receive IDiskQuotaUser ptr.

    Returns:
        NO_ERROR     - Success.
        E_UNEXPECTED - Resolver queue was empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
    12/10/96    Removed interface marshaling. Using free-threading   BrianAu
                model.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::RemoveUserFromResolverQueue(
    PDISKQUOTA_USER *ppUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::RemoveUserFromResolverQueue")));
    DBGASSERT((NULL != ppUser));
    HRESULT hResult = E_UNEXPECTED;

    *ppUser = NULL;

    if (!m_UserQueue.IsEmpty() && 
        m_UserQueue.Remove(*ppUser))
    {
        hResult = NO_ERROR;
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - Input queue unexpectedly empty.")));
    }


    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::PromoteUserToQueueHead

    Description: Promotes a user object to the head of the resolver queue
                 if the user object is in the queue.  This can be used to
                 give specific user objects higher priority if desired.
                 In particular, the initial requirement behind this feature
                 is so that user objects highlighted in the details list view
                 get higher name-resolution priority so that the user 
                 (app user) feels the UI is responsive to their inputs.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object.

    Returns:
        NO_ERROR      - Success.
        S_FALSE       - User record not in queue.
        E_OUTOFMEMORY - Insufficient memory adding item.
        E_UNEXPECTED  - Exception caught.  User record not promoted.
        E_INVALIDARG  - pUser argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::PromoteUserToQueueHead(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::PromoteUserToQueueHead")));
    HRESULT hResult = S_FALSE;

    if (NULL == pUser)
        return E_INVALIDARG;

    m_UserQueue.Lock();
    try
    {
        //
        // Find the user in the resolver's queue.
        //
        INT iUser = m_UserQueue.Find(pUser);
        if (-1 != iUser)
        {
            //
            // Note we don't mess with the ref count of the
            // user object.  We're merely deleting a user and re
            // inserting it into the queue.  The queue's original
            // AddRef() is retained.
            //
            m_UserQueue.Delete(iUser);
            m_UserQueue.Add(pUser);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    m_UserQueue.ReleaseLock();

    return hResult;            
}

 

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ResolveSidToName

    Description: Finds the name corresponding to a user's SID.
        Once the name is found, it is sent to the user object for storage.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Couldn't resolve SID to a name.
        ERROR_NONE_MAPPED (hr) - No SID-to-Name mapping available.
            No need to try again.


    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    08/09/96    Set hResult to E_FAIL when LookupAccountSid fails.   BrianAu
    09/05/96    Added user domain name string.                       BrianAu
    05/18/97    Changed to report deleted SIDs.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::ResolveSidToName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ResolveSidToName")));
    HRESULT hResult     = NO_ERROR;
    array_autoptr<BYTE> ptrUserSid;

    DBGASSERT((NULL != pUser));
    
    hResult = GetUserSid(pUser, (PSID *)(ptrUserSid.getaddr()));
    if (SUCCEEDED(hResult))
    {
        SID_NAME_USE SidNameUse = SidTypeUnknown;
        CString strContainer;
        CString strLogonName;
        CString strDisplayName;

        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Calling LookupAccountBySid.")));

        hResult = m_rQuotaController.m_NTDS.LookupAccountBySid(
                                                         NULL,
                                                         (PSID)(ptrUserSid.get()),
                                                         &strContainer,
                                                         &strLogonName,
                                                         &strDisplayName,
                                                         &SidNameUse);
        if (SUCCEEDED(hResult))
        {                                         
            switch(SidNameUse)
            {
                case SidTypeDeletedAccount:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_DELETED);
                    break;

                case SidTypeInvalid:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_INVALID);
                    break;

                case SidTypeUnknown:
                    static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_UNKNOWN);
                    break;

                default:
                {
                    //
                    // Valid account.
                    //
                    SidNameCache *pSidCache;
                    HRESULT hr = SidNameCache_Get(&pSidCache);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add SID/Name pair to cache.  
                        // Indicate failure only with a debug msg.  If cache
                        // addition fails, we'll still work OK, just slower.
                        // This can throw OutOfMemory.
                        //
                        hr = pSidCache->Add((PSID)(ptrUserSid.get()), 
                                             strContainer, 
                                             strLogonName, 
                                             strDisplayName);
                        if (FAILED(hr))
                        {
                            DBGERROR((TEXT("SIDNAME - Addition of %s\\%s failed."), strLogonName.Cstr()));
                        }
                    }

                    //
                    // Set the user object's account name strings.
                    //
                    hResult = static_cast<DiskQuotaUser *>(pUser)->SetName(
                                                                        strContainer,
                                                                        strLogonName, 
                                                                        strDisplayName);
                    if (SUCCEEDED(hResult))
                    {
                        static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_RESOLVED);
                    }
                    else
                    {
                        DBGERROR((TEXT("SIDNAME - SetName failed in ResolveSidToName. hResult = 0x%08X"),
                                 hResult));
                    }

                    break;
                }
            }
        }
        else
        {
            //
            // Failed asynch name resolution.
            //
            static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_UNAVAILABLE);
            if (ERROR_NONE_MAPPED == GetLastError())
                hResult = HRESULT_FROM_WIN32(ERROR_NONE_MAPPED);
            else
                hResult = E_FAIL; 
        }
    }
    else
    {
        DBGERROR((TEXT("SIDNAME - GetUserSid failed in ResolveSidToName, hResult = 0x%08X"),
                 hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindCachedUserName

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If found, the 
        name is set in the user object and the function returns NO_ERROR.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR             - Success.  User's SID found in cache.
        ERROR_FILE_NOT_FOUND (hr) - User's SID not in cache.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
    08/14/96    Moved initialization of SID/Name cache from          BrianAu
                SidNameResolver::Initialize().
    09/05/96    Added user domain name string.                       BrianAu
    09/21/96    New cache design.                                    BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::FindCachedUserName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindCachedUserName")));
    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); // Assume not found.

    PSID pUserSid = NULL;

    hResult = GetUserSid(pUser, &pUserSid);
    if (SUCCEEDED(hResult))
    {
        LPTSTR pszContainer   = NULL;
        LPTSTR pszLogonName   = NULL;
        LPTSTR pszDisplayName = NULL;

        try
        {
            //
            // Can throw OutOfMemory.
            //
            SidNameCache *pSidCache;
            hResult = SidNameCache_Get(&pSidCache);
            if (SUCCEEDED(hResult))
            {
                //
                // Check cache for SID/Name pair.
                // This can throw OutOfMemory.
                //
                DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Query cache for user 0x%08X."), pUser));
                hResult = pSidCache->Lookup(pUserSid, 
                                            &pszContainer,
                                            &pszLogonName,
                                            &pszDisplayName);

                if (SUCCEEDED(hResult))
                {
                    //
                    // Name was cached.  Set it in the user object and return NO_ERROR.
                    //
                    hResult = static_cast<DiskQuotaUser *>(pUser)->SetName(
                                                                        pszContainer, 
                                                                        pszLogonName, 
                                                                        pszDisplayName);
                    if (SUCCEEDED(hResult))
                    {
                        static_cast<DiskQuotaUser *>(pUser)->SetAccountStatus(DISKQUOTA_USER_ACCOUNT_RESOLVED);
                    }
                }
            }
            else
            {
                //
                // Set the return value so the caller knows to resolve
                // the user name.
                //
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                DBGERROR((TEXT("RESOLVER - SID/Name cache not available.")));
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }

        delete[] pszContainer;
        delete[] pszLogonName;
        delete[] pszDisplayName;
        delete[] pUserSid;  
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindUserName

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If the information
        is not cached, the function calls ResolveSidToName to synchronously
        determine the SID's account name.  The function blocks until the name
        is retrieved.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR             - Success.
        E_FAIL               - Couldn't resolve SID to name.
        ERROR_NONE_MAPPED (hr) - No SID-to-Name mapping found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::FindUserName(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindUserName")));
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != pUser));
    hResult = FindCachedUserName(pUser); // Can throw OutOfMemory.
    if (ERROR_FILE_NOT_FOUND == HRESULT_CODE(hResult))
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X not cached.  Resolving..."),
                 pUser));
        hResult = ResolveSidToName(pUser); // Can throw OutOfMemory.
    }
    else
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X found in cache."), pUser));
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::FindUserNameAsync

    Description: Accepts a user object's IDiskQuotaUser interface pointer and
        looks for it's SID/Name pair in the SID/Name cache.  If the information
        is not cached, the user object is submitted to the resolver for 
        background processing and asynchronous client notification when the 
        operation is complete.

    Arguments:
        pUser - Pointer to user objects's IDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Resolver thread not active.  Can't resolve Async.
        S_FALSE         - User name not in cache.  Submitted for background
                          processing.  Client will be notified when name is
                          found and set in user object.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    06/25/96    Added SID/Name caching.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
SidNameResolver::FindUserNameAsync(
    PDISKQUOTA_USER pUser
    )
{
    DBGTRACE((DM_RESOLVER, DL_MID, TEXT("SidNameResolver::FindUserNameAsync")));
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != pUser));

    hResult = FindCachedUserName(pUser);

    if (ERROR_FILE_NOT_FOUND == HRESULT_CODE(hResult))
    {
        if (0 != m_dwResolverThreadId)
        {
            DBGPRINT((DM_RESOLVER, DL_MID, 
                     TEXT("RESOLVER - User 0x%08X not cached.  Submitting to Resolver."),
                     pUser));

            //
            // Name was not cached.  Add the user object to the resolver's input queue
            // so that the name can be located by the resolver's background thread.
            //
            hResult = AddUserToResolverQueue(pUser);
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - Thread not active.  Can't resolve user 0x%08X async."),
                     pUser));
            hResult = E_FAIL;
        }
    }
    else
    {
        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - User 0x%08X found in cache."),
                 pUser));
    }

    return hResult;
}

    

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ClearInputQueue.

    Description: Called by a SidNameResolver thread after the thread receives
        a WM_QUIT message.  This function removes all user object pointers
        from the input queue before the thread exists.

    Arguments: None.

    Returns:
        NO_ERROR    - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
    12/10/96    Moved Semaphore reduction from method                BrianAu
                HandleShutdownMessages then deleted that method.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::ClearInputQueue(
    void
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ClearInputQueue")));
    PDISKQUOTA_USER pUser = NULL;

    //
    // Decrement the queue-not-empty semaphore to 0 so that the thread
    // doesn't try to remove any more queue entries.
    // Set the resolver's thread ID to 0 so that FindNameAsync will not
    // submit any more users to the resolver.
    //
    m_dwResolverThreadId = 0;
    while(WAIT_OBJECT_0 == WaitForSingleObject(m_hsemQueueNotEmpty, 0))
        NULL;
    //
    // Remove all remaining items from input queue
    // Remove will return E_FAIL if list is empty.
    //
    m_UserQueue.Lock();
    while(m_UserQueue.Count() > 0)
    {
        HRESULT hResult = RemoveUserFromResolverQueue(&pUser);
        if (SUCCEEDED(hResult) && NULL != pUser)
        {
            pUser->Release(); // Release user object.
        }
    }
    m_UserQueue.ReleaseLock();

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ThreadOnQueueNotEmpty

    Description: Called by a SidNameResolver thread when the resolver's input
        queue is not empty.  This function removes the next entry
        from the queue, resolves the user's SID to its name, sets the name
        in the user object and notifies the client of the name change.

    Arguments: None.

    Returns:
        NO_ERROR    - Always returns NO_ERROR.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
SidNameResolver::ThreadOnQueueNotEmpty(
    void
    )
{
    DBGTRACE((DM_RESOLVER, DL_LOW, TEXT("SidNameResolver::ThreadOnQueueNotEmpty")));
    HRESULT hResult       = NO_ERROR;
    PDISKQUOTA_USER pUser = NULL;
    LPSTREAM pstm         = NULL;

    //
    // Remove item from queue
    // RemoveFirst() will return E_FAIL if list is empty.
    //
    try
    {
        hResult = RemoveUserFromResolverQueue(&pUser);
        if (SUCCEEDED(hResult) && NULL != pUser)
        {
            ResolveSidToName(pUser);

            //
            // If successful or not, notify client event sink.
            // Even if we couldn't resolve the name, the object's account
            // status has changed.  The client will want to respond to this.
            // 
            // Don't bother with return value.  We don't care if it fails.
            // The client will but we don't.
            //
            m_rQuotaController.NotifyUserNameChanged(pUser);
            pUser->Release(); // Release pointer obtained from resolver queue.
        }
        else
        {
            DBGERROR((TEXT("RESOLVER - Error removing stream ptr from input queue.")));
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pUser)
            pUser->Release();

        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::ThreadProc

    Description: This thread procedure sits in a loop handling events and
        thread messages.

        Conditions that cause the thread to exit.

        1. OleInitalize() fails.
        2. Thread receives a WM_QUIT message.
        3. Wait function failure or timeout.

    Arguments:
        pvParam - "this" pointer for the SidNameResolver object.
            Required since ThreadProc must be static to be a THREADPROC.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    03/22/00    Changed dwParam for ia64 compat.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD 
SidNameResolver::ThreadProc(
    LPVOID pvParam
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::ThreadProc")));
    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("\tThreadID = %d"), GetCurrentThreadId()));
    SidNameResolver *pThis = (SidNameResolver *)pvParam;
    BOOL bExitThread       = FALSE;

    //
    // Make sure DLL stays loaded while this thread is active.
    //
    InterlockedIncrement(&g_cRefThisDll);

    //
    // Must call CoInitializeEx() for each thread.
    //
    if (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        BOOL bReadyToReceiveMsgs = FALSE;

        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d entering msg loop."), GetCurrentThreadId()));
        while(!bExitThread)
        {
            MSG msg;
            try
            {
                //
                // Allow blocked thread to respond to sent messages.
                //
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && !bExitThread)
                {
                    if ( WM_QUIT != msg.message )
                    {
                        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d dispatching msg %d"),
                                 GetCurrentThreadId(), msg.message));
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    else
                    {
                        //
                        // Rcvd WM_QUIT.  Clear the resolver's input queue and
                        // exit the msg loop.
                        //
                        DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER: Thread %d received WM_QUIT"),
                                 GetCurrentThreadId()));
                        pThis->ClearInputQueue();
                        bExitThread = TRUE;
                    }
                }

                if (!bExitThread)
                {
                    DWORD dwWaitResult = 0;

                    if (!bReadyToReceiveMsgs)
                    {
                        //
                        // Tell the thread creation function that it can
                        // now return.  The thread is ready to accept messages.
                        //
                        SetEvent(pThis->m_heventResolverThreadReady);
                        bReadyToReceiveMsgs = TRUE;
                    }

                    //
                    // Sleep if the queue is empty.
                    // Wake up on queue-not-empty or any thread messages.
                    //
                    DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Thread %d waiting for messages..."),
                              GetCurrentThreadId()));
                    dwWaitResult = MsgWaitForMultipleObjects(
                                           1,
                                           &(pThis->m_hsemQueueNotEmpty),
                                           FALSE,
                                           INFINITE,
                                           QS_ALLINPUT);

                    switch(dwWaitResult)
                    {
                        case WAIT_OBJECT_0:
                            //
                            // Have data in input queue. Process one user.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Something added to input queue.")));
                            pThis->ThreadOnQueueNotEmpty();
                            break;

                        case WAIT_OBJECT_0 + 1:
                            //
                            // Received input message(s).
                            // Loop back around and handle them.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER -  Thread %d rcvd message(s)."),
                                     GetCurrentThreadId()));
                            break;

                        case WAIT_FAILED:
                        case WAIT_TIMEOUT:
                        default:
                            //
                            // Something bad happened.
                            //
                            DBGPRINT((DM_RESOLVER, DL_MID, TEXT("RESOLVER - Thread %d wait failed."),
                                     GetCurrentThreadId()));

                            DBGASSERT((FALSE));
                            bExitThread = TRUE;
                            break;
                    }
                }
            }
            catch(CAllocException& e)
            {
                DBGERROR((TEXT("RESOLVER - Out of memory")));
                bExitThread = TRUE;
            }
        }
        CoUninitialize();
    }
    else
    {
        DBGERROR((TEXT("RESOLVER - OleInitialize failed for thread %d."),
                 GetCurrentThreadId()));
    }

    DBGPRINT((DM_RESOLVER, DL_HIGH, TEXT("RESOLVER - Exit thread %d"), GetCurrentThreadId()));

    pThis->m_dwResolverThreadId = 0;

    InterlockedDecrement(&g_cRefThisDll);
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameResolver::CreateResolverThread

    Description: Creates a thread that will process user objects and resolve
        their SIDs to account names.  

    Arguments:
        phThread [optional] - Address of handle variable to receive handle of 
            new thread.  Can be NULL.

        pdwThreadId [optional] - Address of DWORD to receive thread ID.
            Can be NULL.

    Returns:
        NO_ERROR    - Started thread.
        E_FAIL      - Couldn't start thread.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameResolver::CreateResolverThread(
    PHANDLE phThread,
    LPDWORD pdwThreadId
    )
{
    DBGTRACE((DM_RESOLVER, DL_HIGH, TEXT("SidNameResolver::CreateResolverThread")));
    HRESULT hResult  = NO_ERROR;
    DWORD dwThreadId = 0;
    HANDLE hThread   = NULL;

    //
    // Launch new thread.
    //
    hThread = CreateThread(NULL,        // No security attributes.
                           0,           // Default stack size.
                           &ThreadProc,
                           this,        // Static thread proc needs this.
                           0,           // Not suspended.
                           &dwThreadId);
    if (NULL != hThread)
    {
        if (NULL != phThread)
            *phThread = hThread;  // Caller want's handle value.
        else
            CloseHandle(hThread); // Caller doesn't want it.

        if (NULL != pdwThreadId)
            *pdwThreadId = dwThreadId; // Caller want's thread ID.

        //
        // Wait here until the thread is ready to receive thread messages.
        // This event is set in ThreadProc.
        //
        WaitForSingleObject(m_heventResolverThreadReady, INFINITE);
    }
    else
    {
        hResult = E_FAIL;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\sidcache.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: sidcache.cpp

    Description: This module provides the functionality for a cache of user
        SID/Name pairs.  See the file header in sidcache.h for details.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/12/96    Initial creation.                                    BrianAu
    08/14/96    Added SidCacheQueueIterator.                         BrianAu
    09/20/96    Total redesign.  Old design loaded data from file    BrianAu
                into an in-memory hash table.  New design leaves
                everything on disk and merely maps the file into
                memory.  Much more efficient with respect to
                speed and size.
    07/02/97    Added SidNameCache::GetFileNames.                    Brianau
                Changed logic for identifying cache file path.
                Removed index bucket count param from registry.
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dskquota.h"
#include "sidcache.h"
#include "registry.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

//
// How long (milliseconds) we'll wait to get a lock on the cache.
//
const DWORD MUTEX_WAIT_TIMEOUT      = 5000;
//
// Byte value used to fill in unused blocks in the data file.
//
const BYTE  RECORD_UNUSED_BYTE      = 0xCC;
//
// A value to signify the start of a record in the data file.
// The bit pattern is  1010101010101010 0101010101010101
// Highly unlikely that any data file data will produce this
// pattern.
//
const DWORD RECORD_SIGNATURE        = 0xAAAA5555;
//
// Signatures written into the header of the index and data files.
// For validating a file just in case someone's put another file
// in their place.  The numbers are arbitrary.
// 2600 means "MS building 26N (where I'm working now).
// 3209 is my office number.
// 3210 is BobDay's office number (across the hall).
// Hey, I had to pick something.
//
const DWORD INDEX_FILE_SIGNATURE    = 0x26003209;
const DWORD DATA_FILE_SIGNATURE     = 0x26003210;
//
// A version number so a future build of the software won't be confused
// by a change in file formats.  Bump this if the file format changes.
//
const DWORD FILE_VERSION            = 0x00000003;
//
// Average number of 32-byte blocks per cache entry.
// Entries are variable length (SID, Name etc).  This average is used
// in initially sizing the data file.  I've found that most entries (by far)
// require 4 blocks. Both the data file and index file grow independently
// as needed so it isn't a problem if this isn't always accurate.
//
const DWORD AVG_BLOCKS_PER_ENTRY    = 4;
//
// Create space for this many records in a new data file.
// Since the data and index files grow automatically as needed,
// this can change as you see fit.
//
#if DBG
    const DWORD NEW_CACHE_ENTRY_COUNT   = 4;   // Force frequent file growth.
#else
    const DWORD NEW_CACHE_ENTRY_COUNT   = 128;
#endif
//
// The index and data files automatically grow when needed.  These
// values control how much they grow by.
//
#if DBG
    const DWORD DATA_FILE_GROW_BLOCKS   = 4;  // Force frequent file growth.
#else
    const DWORD DATA_FILE_GROW_BLOCKS   = 512;
#endif

const DWORD INDEX_FILE_GROW_ENTRIES = (DATA_FILE_GROW_BLOCKS / AVG_BLOCKS_PER_ENTRY);
//
// The number of buckets in the cache index hash table.
// Number should be prime.  Remember, this index is on disk so we can afford to
// have a reasonably large hash table.  While it would be nice to fit the
// buckets within a single page of memory, that would be too small to be effective
// 512 / 4 == 64 buckets.  There's also no guarantee that all buckets would be
// mapped to a single physical page.
//
const DWORD INDEX_BUCKET_COUNT = 503;
//
// Convert between blocks and bytes.
// BLOCK_SIZE is a power of 2 so the multiply and division
// can be optimized to shifts.
//
#define BYTE_TO_BLOCK(b)  ((b) / BLOCK_SIZE)
#define BLOCK_TO_BYTE(b)  ((b) * BLOCK_SIZE)
//
// Base pointers for mapped data and index files.
// When the files are mapped into memory, these globals contain
// the address of the mapped memory.
//
LPBYTE g_pbMappedDataFile;
LPBYTE g_pbMappedIndexFile;

//
// Macros for working with based pointers.
// Pointer members in the file structures contain offsets relative
// to the start of the file.  When dereferencing these pointers,
// they must be converted to "based" pointers which add the file's
// base address to the pointer value.  This results in a true
// virtual address that can be accessed.
//
#if defined(_X86_)
#   define NDX_BASED(t)  t __based(g_pbMappedIndexFile)
#   define DAT_BASED(t)  t __based(g_pbMappedDataFile)
#   define NDX_BASED_CAST(t,e)  (NDX_BASED(t) *)((DWORD)(e))
#   define DAT_BASED_CAST(t,e)  (DAT_BASED(t) *)((DWORD)(e))
#else
//
// APPCOMPAT:
// I think there's a bug in the ALPHA compiler that is preventing __based pointers
// from working as I have used them.
// This is a workaround until the bug is fixed or I find out what I'm doing wrong.
//
#   define NDX_BASED(t)  t
#   define DAT_BASED(t)  t
#   define NDX_BASED_CAST(t,e)  ((NDX_BASED(t) *)(((BYTE *)g_pbMappedIndexFile) + ((DWORD_PTR)(e))))
#   define DAT_BASED_CAST(t,e)  ((DAT_BASED(t) *)(((BYTE *)g_pbMappedDataFile) + ((DWORD_PTR)(e))))
#endif

//
// Macros to verify that the files have been mapped.
// These are primarily used in assertions.
//
#define INDEX_FILE_MAPPED  (NULL != g_pbMappedIndexFile)
#define DATA_FILE_MAPPED   (NULL != g_pbMappedDataFile)
//
// Names for system objects.  Mutex and maps are named so they can
// be shared between processes.
//
const LPCTSTR g_szSidCacheMutex     = TEXT("DSKQUOTA_SIDCACHE_MUTEX");
const LPCTSTR g_pszIndexFileMapping = TEXT("DSKQUOTA_SIDCACHE_INDEX");
const LPCTSTR g_pszDataFileMapping  = TEXT("DSKQUOTA_SIDCACHE_DATA");
//
// Use to clear a file's GUID and to test for a NULL guid.
//
static const GUID GUID_Null =
{ 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

//
// Registry parameter value names.
//
const TCHAR g_szSidCacheRecLifeMin[]   = TEXT("SidCacheRecLifeMin");
const TCHAR g_szSidCacheRecLifeMax[]   = TEXT("SidCacheRecLifeMax");


//***********************************************************************************
//***********************************************************************************
//  C A C H E   M A N A G E R
//***********************************************************************************
//***********************************************************************************

//
// Called by both SidNameCache_Get and SidNameCache_Destroy to either retrieve
// the address (and create if necessary) of the singleton cache object or to
// destroy that object.  The reason to have this single function is so that
// the singleton pointer is a local variable, inaccessible outside of this
// function.  This way the only access to the cache object is through
// the SidNameCache_Get function.
//
HRESULT 
SidNameCache_GetOrDestroy(
    SidNameCache **ppCache, 
    bool bGet
    )
{
    DBGASSERT((NULL != ppCache));

    HRESULT hr = E_FAIL;

    //
    // This is the one-and-only pointer to the SID-Name cache object.
    // All code obtains this address through this function.
    // 
    static SidNameCache *pTheCache;

    *ppCache = NULL;

    HANDLE hMutex = CreateMutex(NULL, FALSE, g_szSidCacheMutex);
    if (NULL != hMutex)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hMutex, INFINITE))
        {
            if (!bGet)
            {
                //
                // Destroy the existing cache object.  NULL the static
                // ptr so next request will recreate the cache object.
                //
                delete pTheCache;
                pTheCache = NULL;
                hr = S_OK;
            }
            else
            {
                //
                // Retrieve existing or create new cache object.
                //
                SidNameCache *pCache = pTheCache;
                if (NULL != pCache)
                {
                    //
                    // Use the existing object.
                    //
                    hr = S_OK;
                }
                else
                {
                    try
                    {
                        //
                        // Doesn't yet exist.  Create new one.
                        //
                        autoptr<SidNameCache> ptrCache(new SidNameCache);

                        //
                        // Open/Create new cache data and index files.
                        // Will first try to open existing.  If either the index or
                        // data file doesn't exist or is invalid, new files are created.
                        //
                        hr = ptrCache->Initialize(TRUE);
                        if (SUCCEEDED(hr))
                        {
                            pCache = ptrCache.get();
                            ptrCache.disown();
                            //
                            // Save in our static variable for future use.
                            //
                            pTheCache = pCache;
                        }
                        else
                        {
                            DBGERROR((TEXT("SID cache initialization failed with error 0x%08X"), hr));
                        }
                    }
                    catch(CAllocException& e)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    catch(CSyncException& e)
                    {
                        hr = E_FAIL;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    //
                    // Return the pointer to the caller.
                    //
                    *ppCache = pCache;
                }
            }
            ReleaseMutex(hMutex);
        }
        CloseHandle(hMutex);
    }
    return hr;
}


//
// Retrieves the address of the singleton SidNameCache object.
// If the object doesn't exist it is created.
// Callers do not release or delete this pointer.
// On Process-Detach, the SidNameCache_Destroy() function is 
// called to delete the singleton object.
//
HRESULT SidNameCache_Get(SidNameCache **ppCache)
{
    const bool bGet = true;
    return SidNameCache_GetOrDestroy(ppCache, bGet);
}

//
// Called on Process-Detach to destroy the singleton cache
// object.
//
HRESULT SidNameCache_Destroy(void)
{
    const bool bGet = false;
    SidNameCache *pUnused;
    return SidNameCache_GetOrDestroy(&pUnused, bGet);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::SidNameCache

    Description: Constructor.  Creates an empty SID/Name cache object.
        Call one of the Initialize() methods to either create a new index and
        data file or to open existing ones.

    Arguments: None.

    Returns: Nothing.

    Exceptions: SyncObjErrorCreate.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::SidNameCache(
    VOID
    ) : m_hMutex(NULL),
        m_pIndexMgr(NULL),
        m_pRecordMgr(NULL)
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache")));
    if (NULL == (m_hMutex = CreateMutex(NULL,                    // No security
                                        FALSE,                   // Non-owned
                                        g_szSidCacheMutex)))
    {
        throw CSyncException(CSyncException::mutex, CSyncException::create);
    }

    SetCacheFilePath();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::~SidNameCache

    Description: Destructor.  Destroys the cache object by deleting the
        Index Manager and Record Manager objects.  The respective destructor's
        for each of the managers will handle closing their files and mapping
        objects.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::~SidNameCache(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::~SidNameCache")));
    if (NULL != m_hMutex)
        Lock();

    delete m_pIndexMgr;
    delete m_pRecordMgr;

    if (NULL != m_hMutex)
    {
        ReleaseLock();
        CloseHandle(m_hMutex);
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Initialize

    Description: Initializes a new cache object by creating the Index and
        Record manager objects then initializing each.  Initialization first
        tries to open existing index and data files.  If one (or both) of the
        files does not exist OR one (or both) of the files is considered
        "invalid", new files are created.  Need to take a "fail safe" approach
        to this.

    Arguments:
        bOpenExisting - TRUE = Try to open an existing cache index and data file.
            If it can't, it creates a new one.  FALSE = Just create a new one.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Could not open nor create required files.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Initialize(
    BOOL bOpenExisting
    )
{
    DBGTRACE((DM_CONTROL, DL_MID, TEXT("SidNameCache::Initialize")));
    DBGASSERT((NULL == m_pIndexMgr));
    DBGASSERT((NULL == m_pRecordMgr));

    HRESULT hResult = E_FAIL;
    CacheAutoLock lock(*this);

    if (lock.Lock())
    {
        try
        {
            if (m_strFilePath.IsEmpty())
            {
                //
                // If file path is empty, it means we couldn't get the
                // user's profile directory from the registry.
                //
                DBGERROR((TEXT("Error creating SID cache files.  No path.")));
            }
            else
            {
                //
                // Name for our cache data and index files.
                // Will append .DAT and .NDX respectively.
                // This is where you change the file name or extension(s)
                // if you want to do that.
                //
                const TCHAR szSidCacheFile[] = TEXT("NTDiskQuotaSidCache");

                //
                // Create a fully-qualified path for the cache data and index
                // files.  m_strFilePath was set in the cache object ctor.
                //
                CString strDataFile(m_strFilePath);
                CString strIndexFile(m_strFilePath);

                strDataFile.Format(TEXT("%1\\%2.dat"), (LPCTSTR)m_strFilePath, szSidCacheFile);
                strIndexFile.Format(TEXT("%1\\%2.ndx"),(LPCTSTR)m_strFilePath, szSidCacheFile);

                //
                // Create the record and index manager objects.
                //
                m_pRecordMgr = new RecordMgr(*this);
                m_pIndexMgr  = new IndexMgr(*this);

                DBGPRINT((DM_CONTROL, DL_MID, TEXT("Create SID cache DataFile = %s  IndexFile = %s"),
                         (LPCTSTR)strDataFile, (LPCTSTR)strIndexFile));

                if (bOpenExisting)
                {
                    //
                    // First try opening existing data and index files.
                    //
                    if (NULL != m_pRecordMgr->Initialize(strDataFile))
                    {
                        if (NULL != m_pIndexMgr->Initialize(strIndexFile))
                            hResult = NO_ERROR;
                    }
                }

                if (FAILED(hResult) || !FilesAreValid())
                {
                    hResult = E_FAIL;
                    //
                    // Couldn't open existing files, try creating new ones.
                    // Any open files/mappings will be closed.
                    //
                    if (NULL != m_pRecordMgr->Initialize(strDataFile,
                                          NEW_CACHE_ENTRY_COUNT * AVG_BLOCKS_PER_ENTRY))
                    {
                        if (NULL != m_pIndexMgr->Initialize(strIndexFile,
                                                            INDEX_BUCKET_COUNT,
                                                            NEW_CACHE_ENTRY_COUNT))
                        {
                            hResult = NO_ERROR;
                        }
                    }
                }
            }
        }
        catch(CAllocException& e)
        {
            delete m_pRecordMgr;
            m_pRecordMgr = NULL;
            delete m_pIndexMgr;
            m_pIndexMgr = NULL;
            hResult = E_OUTOFMEMORY;
        }
        //
        // Mark files as "valid".
        //
        if (SUCCEEDED(hResult))
            ValidateFiles();
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::OpenMappedFile

    Description: Opens or creates a file, maps the file into memory and
        returns the address of the mapping.

    Arguments:
        pszFile - Address of name of file to create/open.

        pszMapping - Name to give the mapping object.  This object is
            named so that if multiple processes map the same file (using
            the same mapping name), the file is only mapped once.

        dwCreation - Creation flag (CREATE_ALWAYS, OPEN_EXISTING);

        cbFileHigh/Low - If creating a new file or extending an existing
            these two arguments contain the desired size in bytes.

        phFile - Address of handle variable to receive the open file's
            handle value.  Call CloseHandle on this to close the file.

        phFileMapping - Address of handle variable to receive the open
            file mapping's handle value.  Call CloseFileMapping on this
            to close the mapping.

    Returns:
        Address of the mapped file in memory.  NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    07/21/97    Files are now created in user's profile under a      BrianAu
                "DiskQuota" subdirectory.
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::OpenMappedFile(
    LPCTSTR pszFile,
    LPCTSTR pszMapping,
    DWORD dwCreation,
    DWORD cbFileHigh,
    DWORD cbFileLow,
    PHANDLE phFile,
    PHANDLE phFileMapping
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::OpenMappedFile")));
    LPBYTE pbBase = NULL;

    DBGASSERT((NULL != pszFile));
    DBGASSERT((NULL != pszMapping));
    DBGASSERT((NULL != phFile));
    DBGASSERT((NULL != phFileMapping));

    *phFile = CreateFile(pszFile,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         dwCreation,
                         FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN,
                         NULL);

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        if ((*phFileMapping = CreateFileMapping(*phFile,
                                                NULL,
                                                PAGE_READWRITE,
                                                cbFileHigh,
                                                cbFileLow,
                                                pszMapping)) != NULL)
        {
            pbBase = (LPBYTE)MapViewOfFile(*phFileMapping,
                                           FILE_MAP_WRITE,
                                           0,
                                           0,
                                           0);
            if (NULL == pbBase)
                DBGERROR((TEXT("SIDCACHE - Failed to map view of file %s"),
                         pszFile));
        }
        else
        {
            DBGERROR((TEXT("SIDCACHE - Failed to create mapping %s for file %s"),
                     pszMapping, pszFile));
        }
        if (NULL == pbBase)
        {
            CloseHandle(*phFile);
            *phFile = NULL;
        }
    }
    else
        DBGERROR((TEXT("SIDCACHE - Failed to open file %s"), pszFile));


    return pbBase;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::SetCacheFilePath

    Description: Obtains the fully-qualified path for the cache's data
        and index files and stores the value in m_strFilePath.  The files
        are to be created under in the user's profile under the directory
        \AppData\Microsoft\Windows NT\DiskQuota.  We have to read the registry
        to find exactly where this subtree lives for this user.

    Arguments: None.

    Returns: Nothing.
             On return, m_strFilePath contains the path to the files.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/02/97    Initial creation.                                    BrianAu
    07/21/97    Removed default file path.                           BrianAu
                Files can only be stored in user's profile.
                Can't allow unsecure access to SID/Name pairs.
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::SetCacheFilePath(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::SetCacheFilePath")));
    //
    // Get the user's %UserProfile%\Application Data directory.
    // Normally, an app gets this through SHGetSpecialFolderLocation or
    // SHGetSpecialFolderPath.  However, I don't want to load shell32.dll
    // just for that purpose (I've tried to keep shell32 out of this dll).
    // Therefore, we read the registry values just like the shell does.
    // EricFlo suggested this so it's OK ZAW-wise.
    //
    LONG lResult        = ERROR_SUCCESS;
    HKEY hKey           = NULL;
    DWORD dwDisposition = 0;
    const TCHAR szKeyNameRoot[]      = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer");
    const TCHAR szMSWinNTDiskQuota[] = TEXT("Microsoft\\Windows NT\\DiskQuota");

    LPCTSTR rgpszKeys[] = {
                            TEXT("\\User Shell Folders"),
                            TEXT("\\Shell Folders"),
                          };

    //
    // Start with an empty path buffer.
    //
    m_strFilePath.Empty();

    for (INT i = 0; i < ARRAYSIZE(rgpszKeys) && m_strFilePath.IsEmpty(); i++)
    {
        //
        // Create the key name.
        //
        CString strKeyName(szKeyNameRoot);
        strKeyName += CString(rgpszKeys[i]);

        //
        // Open the reg key.
        //
        lResult = RegCreateKeyEx(HKEY_CURRENT_USER,
                                 strKeyName,
                                 0,
                                 NULL,
                                 0,
                                 KEY_READ,
                                 NULL,
                                 &hKey,
                                 &dwDisposition);

        if (ERROR_SUCCESS == lResult)
        {
            try
            {
                //
                // Get the path to the user's "Application Data" directory.
                //
                DBGASSERT((NULL != hKey));

                DWORD dwValueType = 0;
                DWORD cbValue     = MAX_PATH * sizeof(TCHAR);

                lResult = RegQueryValueEx(hKey,
                                          TEXT("AppData"),
                                          0,
                                          &dwValueType,
                                          (LPBYTE)m_strFilePath.GetBuffer(MAX_PATH),
                                          &cbValue);

                m_strFilePath.ReleaseBuffer();

                if (ERROR_SUCCESS == lResult)
                {
                    //
                    // Ensure the path has a trailing backslash.
                    //
                    INT cchPath = m_strFilePath.Length();
                    if (0 < cchPath && TEXT('\\') != m_strFilePath[cchPath-1])
                    {
                        m_strFilePath += CString(TEXT("\\"));
                    }
                    //
                    // Append "Microsoft\Windows NT\DiskQuota" to the path.
                    //
                    m_strFilePath += CString(szMSWinNTDiskQuota);
                }
                else
                {
                    //
                    // Something failed.  Ensure m_strFilePath is empty.
                    //
                    m_strFilePath.Empty();
                    if (ERROR_FILE_NOT_FOUND != lResult)
                    {
                        DBGERROR((TEXT("SIDCACHE - Error %d getting \"AppData\" reg value."), lResult));
                    }
                }
            }
            catch(CAllocException& e)
            {
                lResult = ERROR_OUTOFMEMORY;
            }
            RegCloseKey(hKey);
        }
        else if (ERROR_FILE_NOT_FOUND != lResult)
        {
            DBGERROR((TEXT("SIDCACHE - Error %d opening \"\\User Shell Folders\" or \"Shell Folders\" reg key"), lResult));
        }
    }

    if (!m_strFilePath.IsEmpty())
    {
        //
        // Expand any embedded environment strings.
        //
        m_strFilePath.ExpandEnvironmentStrings();

        //
        // Ensure the path DOES NOT have a trailing backslash.
        //
        INT cchPath = m_strFilePath.Length();
        if (0 < cchPath && TEXT('\\') == m_strFilePath[cchPath-1])
        {
            m_strFilePath[cchPath-1] = TEXT('\0');
        }

        if ((DWORD)-1 == ::GetFileAttributes(m_strFilePath))
        {
            //
            // If the directory doesn't exist, try to create it.
            //
            if (0 == CreateCacheFileDirectory(m_strFilePath))
            {
                //
                // Couldn't create the directory, make sure the path
                // is empty so we don't try to write to a non-existent
                // directory.
                //
                DBGERROR((TEXT("SIDCACHE - Error %d creating directory \"%s\""),
                         GetLastError(), (LPCTSTR)m_strFilePath));
                m_strFilePath.Empty();
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::CreateCacheFileDirectory

    Description: Creates the directory for the SID/Name cache files.  Since
        the directory lives several levels below "Application Data", we
        may need to create several directories before we get to DiskQuota.

    Arguments: pszPath - This is a fully-qualified directory path.

    Returns: TRUE  = Directory created.
             FALSE = Directory not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::CreateCacheFileDirectory(
    LPCTSTR pszPath
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::CreateCacheFileDirectory")));
    BOOL bResult = TRUE;
    CString s(pszPath);     // Local copy we can play with.
    LPTSTR psz = (LPTSTR)s; // Ptr to C string.

    while(TEXT('\0') != *psz && bResult)
    {
        //
        // Find the next backslash (or end-of-string).
        //
        while(TEXT('\0') != *psz && TEXT('\\') != *psz)
        {
            psz++;
        }
        //
        // Replace backslash with a temporary NUL.
        //
        TCHAR chSaved = *psz;
        *psz = TEXT('\0');
        //
        // See if the directory already exists.
        //
        if ((DWORD)-1 == ::GetFileAttributes(s))
        {
            //
            // It doesn't.  Try to create it.
            //
            if (0 == ::CreateDirectory(s, NULL))
            {
                DBGERROR((TEXT("SIDCACHE - Error %d creating directory \"%s\""),
                         GetLastError(), (LPCTSTR)s));
                bResult = FALSE;
            }
        }
        //
        // Replace temp NUL with original backslash and advance ptr
        // to next character in path (if we're not at the end of the string).
        //
        *psz = chSaved;
        if (TEXT('\0') != *psz)
        {
            psz++;
        }
    }

    if (bResult)
    {
        //
        // Created directory. Set SYSTEM & HIDDEN attribute bits on the final
        // subdirectory ("\DiskQuota").
        //
        SetFileAttributes(pszPath,
                          GetFileAttributes(pszPath) | (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN));
    }

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lock

    Description: Obtains an exclusive lock on the cache.  This lock is
        system-wide so that multiple processes can access the cache files.

    Arguments: None.

    Returns:
        TRUE  - Exclusive lock obtained or the lock was abandoned.
                No matter how the lock was obtained, the caller should always
                check the validity of the index and data files before trusting
                their contents.
        FALSE - Lock could not be obtained in the required timeout period.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::Lock(
    VOID
    )
{
    BOOL bResult = FALSE;
    DBGASSERT((NULL != m_hMutex));

    //
    // IMPORTANT:  Don't try handling thread messages with MsgWaitForMultipleObjects.
    //             This lock function can be called on the resolver's background
    //             thread.  If you pull up that thread's messages, it won't receive
    //             the WM_QUIT message commanding it to shutdown.
    //
    switch(WaitForSingleObject(m_hMutex, MUTEX_WAIT_TIMEOUT))
    {
        case WAIT_OBJECT_0:
        case WAIT_ABANDONED:
            bResult = TRUE;
            break;

        case WAIT_FAILED:
        case WAIT_TIMEOUT:
        default:
            break;
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::ReleaseLock

    Description: Releases the exclusive lock on the cache.  This function must
        always be paired with a call to Lock().  Be careful of conditions
        which may throw an exception and bypass releasing the lock.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::ReleaseLock(
    VOID
    )
{
    DBGASSERT((NULL != m_hMutex));
    ReleaseMutex(m_hMutex);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::BeginTransaction

    Description: Called at the beginning of any "transaction" to obtain
        exclusive access to the cache and verify the cache files are valid.
        Although this is of course not true transaction processing, it provides
        a simple approximation that is sufficient for this cache implementation.
        Note that before returning, the files are "invalidated".  After the
        transaction is completed, the caller must call EndTransaction to
        release the exclusive lock and mark the files as "valid".

    Arguments: None.

    Returns:
        NO_ERROR            - Success.  Transaction can be carried out.
        ERROR_INVALID_DATA (hr) - Index or data file is invalid.  Caller should
            re-initialize both index and data files.
        ERROR_LOCK_FAILED (hr) - Could not obtain exclusive access to the
            index and data files.  Caller can either repeat the call or
            simply fail the cache access.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::BeginTransaction(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    if (Lock())
    {
        if (FilesAreValid())
        {
            InvalidateFiles();
        }
        else
        {
            ReleaseLock();
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }
    else
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::EndTransaction

    Description: Called at the end of any "transaction" to release
        exclusive access to the cache and validate the cache files.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::EndTransaction(
    VOID
    )
{
    //
    // If you hit this assertion, probably didn't call BeginTransaction
    // first.
    //
    DBGASSERT((!FilesAreValid()));

    ValidateFiles();
    ReleaseLock();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Clear

    Description: Resets both the index and data files to an empty state.

    Arguments: None.

    Returns:
        TRUE  - Files reset.
        FALSE - Couldn't obtain lock to reset files or another process
                is also using the cache.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    08/07/00    Clear cache by clearing index and data files.  Not   BrianAu
                destroying and recreating.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::Clear")));
    BOOL bResult = FALSE;
    CacheAutoLock lock(*this);
    if (lock.Lock())
    {
        if (NULL != m_pIndexMgr && NULL != m_pRecordMgr)
        {
            m_pIndexMgr->Clear();
            m_pRecordMgr->Clear();
            ValidateFiles();
            bResult = TRUE;
        }
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::FilesAreValid

    Description: Examines the guid field in the index and data files.
        If the guids are non-zero and are equal, the files are considered
        "valid".  BeginTransaction sets each guid to all 0's while
        EndTransaction fills them with a new GUID.

    Arguments: None.

    Returns:
        TRUE/FALSE indicating file validity.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::FilesAreValid(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    GUID guidIndexFile;
    GUID guidDataFile;

    m_pIndexMgr->GetFileGUID(&guidIndexFile);
    if (GUID_Null != guidIndexFile)
    {
        m_pRecordMgr->GetFileGUID(&guidDataFile);
        return guidDataFile == guidIndexFile;
    }
    return FALSE; // At least one GUID was all 0's
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::ValidateFiles

    Description: Generates a new GUID and writes it to the header of the
        index and data files.  This should only be called when a transaction
        has been successfully completed.  EndTransaction calls this method
        to mark the files as "valid".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    05/18/00    Check return value from CoCreateGuid.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::ValidateFiles(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    //
    // If GUID creation fails, the cache will be considered invalid.
    // That's a reasonable system response.  Failure of GUID creation
    // is highly unlikely.
    //
    GUID guid;
    if (SUCCEEDED(CoCreateGuid(&guid)))
    {
        m_pRecordMgr->SetFileGUID(&guid);
        m_pIndexMgr->SetFileGUID(&guid);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::InvalidateFiles

    Description: Sets the guid field in each file to all 0's.   This marks
        a file as "invalid".  BeginTransaction calls this.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::InvalidateFiles(
    VOID
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pRecordMgr->SetFileGUID(&GUID_Null);
    m_pIndexMgr->SetFileGUID(&GUID_Null);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lookup

    Description: Given a user SID, this method locates the corresponding
        data record in the cache and returns the requested information.
        (i.e. container, name, full name).  Several conditions will cause
        the lookup to fail.
            1. SID not found in cache.
            2. Can't get exclusive lock on cache.
            3. Index or data file (or both) are invalid.
            4. Record found but expired.

    Arguments:
        pKeySid - Address of SID to use as lookup key.

        ppszContainer [optional] - Address of pointer variable to receive the
            address of buffer containing the "container" name string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if the container is not desired.

        ppszLogonName [optional] - Address of pointer variable to receive the
            address of buffer containing logon name string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if logon name is not desired.

        ppszDisplayName [optional] - Address of pointer variable to receive the
            address of buffer containing account display string. Caller is
            responsible for freeing the buffer with delete[].
            May be NULL if display name is not desired.

    Returns:
        NO_ERROR                  - Success.
        ERROR_FILE_NOT_FOUND (hr) - Sid not found in cache.
        ERROR_LOCK_FAILED (hr)    - Couldn't get exclusive lock on cache.
        ERROR_INVALID_DATA (hr)   - Index or data file is invalid.

    Exceptions: OutOfMemory


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Lookup(
    PSID pKeySid,
    LPTSTR *ppszContainer,
    LPTSTR *ppszLogonName,
    LPTSTR *ppszDisplayName
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Lookup [SID]")));
    DBGASSERT((NULL != pKeySid));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            DWORD iBlock = m_pIndexMgr->Lookup(pKeySid);

            if ((DWORD)-1 != iBlock)
            {
                if (!m_pRecordMgr->RecordExpired(iBlock))
                {
                    PSID pSid = NULL;
                    //
                    // This can throw OutOfMemory.
                    //
                    hResult = m_pRecordMgr->Retrieve(iBlock,
                                                     &pSid,
                                                     ppszContainer,
                                                     ppszLogonName,
                                                     ppszDisplayName);
                    if (SUCCEEDED(hResult))
                        DBGASSERT((EqualSid(pSid, pKeySid)));

                    if (NULL != pSid)
                        delete[] pSid;
                }
                else
                {
                    //
                    // Record is outdated.  Delete it from the cache.
                    // Returning "not found" will cause the caller to get
                    // a fresh one from the domain controller - which will
                    // then again be added to the cache.
                    //
                    DBGPRINT((DM_SIDCACHE, DL_HIGH,
                             TEXT("SIDCACHE - Record at block %d has expired."),
                             iBlock));

                    m_pIndexMgr->FreeEntry(pKeySid);
                    m_pRecordMgr->FreeRecord(iBlock);
                    hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // SID not in cache.
            }
        }
        catch(CAllocException &e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Lookup

    Description: Given a user's logon name name, this method locates
        the corresponding SID in the cache.  All comments in the previous
        (above) version of this method apply.

    Arguments:
        pszLogonName - Address of account logon name string.

        ppSid - Address of pointer variable to receive the address of buffer
            containing the SID. Caller is responsible for freeing the buffer
            with delete[].

    Returns:
        See list in previous method.

    Exception: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
    03/18/98    Replaced domain\name key arguments with single       BrianAu
                logon name key.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Lookup(
    LPCTSTR pszLogonName,
    PSID *ppSid
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Lookup [name]")));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != ppSid));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            //
            // Can throw OutOfMemory.
            //
            DWORD iBlock = m_pIndexMgr->Lookup(pszLogonName);

            if ((DWORD)-1 != iBlock)
            {
                //
                // Can throw OutOfMemory.
                //
                hResult = m_pRecordMgr->Retrieve(iBlock,
                                                 ppSid,
                                                 NULL,
                                                 NULL,
                                                 NULL);

                if (m_pRecordMgr->RecordExpired(iBlock))
                {
                    //
                    // Record is outdated.  Delete it from the cache.
                    // Returning "not found" will cause the caller to get
                    // a fresh one from the domain controller - which will
                    // then again be added to the cache.
                    //
                    DBGASSERT((NULL != *ppSid));
                    m_pIndexMgr->FreeEntry(*ppSid);
                    m_pRecordMgr->FreeRecord(iBlock);
                    delete[] *ppSid;
                    *ppSid = NULL;
                    hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
            }
            else
            {
                hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // SID not in cache.
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::Add

    Description: Add user's information to the cache.  Information consists
        of the SID (key), container name, account logon name and
        account display name.

    Arguments:
        pSid - Address of user's SID.

        pszContainer - Address of account container name string.
            i.e. "REDMOND" or "ntdev.microsoft.com\US-SOS ....."

        pszLogonName - Address of account logon name string.
            i.e. "REDMOND\brianau" or "brianau@microsoft.com"

        pszDisplayName - Address of display name string.
            i.e. "Brian Aust"

    Returns:
        NO_ERROR                  - Success.
        S_FALSE                   - Already exists in cache.  Not added.
        ERROR_LOCK_FAILED (hr)    - Couldn't get exclusive lock on cache.
        ERROR_INVALID_DATA (hr)   - Index or data file is invalid.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::Add(
    PSID pSid,
    LPCTSTR pszContainer,
    LPCTSTR pszLogonName,
    LPCTSTR pszDisplayName
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::Add")));

    DBGASSERT((NULL != pSid));
    DBGASSERT((NULL != pszContainer));
    DBGASSERT((NULL != pszLogonName));
    DBGASSERT((NULL != pszDisplayName));

    HRESULT hResult = BeginTransaction();

    if (SUCCEEDED(hResult))
    {
        try
        {
            //
            // Can throw OutOfMemory.
            //
            if ((DWORD)-1 == m_pIndexMgr->Lookup(pSid))
            {
                DWORD iBlock = m_pRecordMgr->Store(pSid,
                                                   pszContainer,
                                                   pszLogonName,
                                                   pszDisplayName);

                if ((DWORD)-1 != iBlock)
                {
                    m_pIndexMgr->Add(pSid, iBlock);
                    hResult = NO_ERROR;
                }
            }
            else
            {
                hResult = S_FALSE;  // Already exists. Not a failure.
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        EndTransaction();
    }

    return hResult;
}



//***********************************************************************************
//***********************************************************************************
//   I N D E X   F I L E   M A N A G E R
//***********************************************************************************
//***********************************************************************************


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::IndexMgr

    Description: Index manager constructor.

    Arguments:
        refCache - Reference to containing cache object.  Used to call
            record manager and cache manager public methods.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::IndexMgr::IndexMgr(
    SidNameCache& refCache
    ) : m_refCache(refCache),
        m_pFileHdr(NULL),
        m_hFile(NULL),
        m_hFileMapping(NULL)
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::IndexMgr")));
    //
    // Nothing to do.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::~IndexMgr

    Description: Index manager destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::IndexMgr::~IndexMgr(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::~IndexMgr")));
    CloseIndexFile();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Initialize

    Description: Initializes a new index manager object.  If both cBuckets
        and cMaxEntries are 0 (default), existing cache files are opened.
        Otherwise, new cache files are created.

    Arguments:
        pszFile - Address of full path for new file.

        cBuckets - Number of hash table buckets in index file.  Should be
            prime.

        cMaxEntries - Initial max number of entries for the index.  Note
            that the index file grows automatically as required.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::Initialize(
    LPCTSTR pszFile,
    DWORD cBuckets,
    DWORD cMaxEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::IndexMgr::Initialize")));
    DBGASSERT((NULL != pszFile));

    //
    // Store the file name in our CString object.
    //
    m_strFileName = pszFile;

    if (0 == cBuckets && 0 == cMaxEntries)
    {
        //
        // Initialize manager using existing cache files.
        //
        m_pFileHdr = (PINDEX_FILE_HDR)OpenIndexFile(pszFile);
        if (NULL != m_pFileHdr)
        {
            if (FILE_VERSION != m_pFileHdr->dwVersion ||
                INDEX_FILE_SIGNATURE != m_pFileHdr->dwSignature)
            {
                //
                // This version of the software doesn't understand this
                // version of the file or file has an invalid signature.
                // Don't take any chances.  We'll just create a new one.
                //
                DBGERROR((TEXT("SIDCACHE - Index file is invalid or incorrect version. A new index file will be created.")));

                CloseIndexFile();
                m_pFileHdr = NULL;
            }
        }
    }
    else
    {
        //
        // Initialize manager by creating new cache files.
        //
        ULARGE_INTEGER uliFileSize;
        uliFileSize.QuadPart = FileSize(cMaxEntries, cBuckets);

        m_pFileHdr = (PINDEX_FILE_HDR)CreateIndexFile(pszFile,
                                                      uliFileSize.HighPart,
                                                      uliFileSize.LowPart);
        if (NULL != m_pFileHdr)
        {
            InitNewIndexFile(cBuckets, cMaxEntries);
        }
    }
    return (LPBYTE)m_pFileHdr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::CreateIndexFile

    Description: Creates and initializes a new index file.

    Arguments:
        pszFile - Address of full path for new file.

        cbFileHigh/Low - Size of file in bytes.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::CreateIndexFile(
    LPCTSTR pszFile,
    DWORD cbFileHigh,
    DWORD cbFileLow
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::CreateIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tFile: \"%s\""), pszFile ? pszFile : TEXT("<null>")));

    DBGASSERT((NULL != pszFile));

    CloseIndexFile();  // Make sure any existing index file is closed.

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszIndexFileMapping,
                                CREATE_ALWAYS,
                                cbFileHigh,
                                cbFileLow,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::OpenIndexFile

    Description: Opens an existing index file.

    Arguments:
        pszFile - Address of full path for new file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::OpenIndexFile(
    LPCTSTR pszFile
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::OpenIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tFile: \"%s\""), pszFile ? pszFile : TEXT("<null>")));
    DBGASSERT((NULL != pszFile));

    CloseIndexFile();  // Make sure any existing index file is closed.

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszIndexFileMapping,
                                OPEN_EXISTING,
                                0,
                                0,
                                &m_hFile,
                                &m_hFileMapping);
    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::CloseIndexFile

    Description: Closes the current index mapping and file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::CloseIndexFile(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::CloseIndexFile")));
    if (NULL != g_pbMappedIndexFile)
    {
        UnmapViewOfFile(g_pbMappedIndexFile);
        g_pbMappedIndexFile = NULL;
        m_pFileHdr = NULL;
    }
    if (NULL != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }
    if (NULL != m_hFile && INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::GrowIndexFile

    Description: Increases the size of the current index file.

    Arguments:
        cGrowEntries - Make room for this many more entries.  Note that the
            size of the hash table is fixed.  If we were to allow this to
            change, it would invalidate any existing hash values in the
            table (hash code is a function of the SID and table size).

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::IndexMgr::GrowIndexFile(
    DWORD cGrowEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::GrowIndexFile")));
    DBGASSERT((INDEX_FILE_MAPPED));

    DWORD cOldMaxEntries = m_pFileHdr->cMaxEntries;
    DWORD cNewMaxEntries = cOldMaxEntries + cGrowEntries;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("Growing SID cache index %d -> %d entries."),
             cOldMaxEntries, cNewMaxEntries));

    //
    // Open the existing file and map with a new larger size.
    // Must calc new size BEFORE closing current index file so that m_pFileHdr
    // is still valid.
    //
    ULARGE_INTEGER uliFileSize;
    uliFileSize.QuadPart = FileSize(cNewMaxEntries, m_pFileHdr->cBuckets);

    CloseIndexFile();

    g_pbMappedIndexFile = SidNameCache::OpenMappedFile(
                                m_strFileName,
                                g_pszIndexFileMapping,
                                OPEN_EXISTING,
                                uliFileSize.HighPart,
                                uliFileSize.LowPart,
                                &m_hFile,
                                &m_hFileMapping);

    m_pFileHdr = (PINDEX_FILE_HDR)g_pbMappedIndexFile;

    if (NULL != g_pbMappedIndexFile)
    {
        m_pFileHdr->cMaxEntries = cNewMaxEntries;

        //
        // Growing the index only expands the number of index
        // pool entries. The index hash table is left alone.
        // Good reason to make it large to start with.  If we changed
        // the hash table size, existing hash codes would be
        // invalid.
        //
        PINDEX_ENTRY pEntry = m_pFileHdr->pEntries + cOldMaxEntries;
        for (UINT i = 0; i < cGrowEntries; i++)
        {
            AddEntryToFreeList(pEntry++);
        }
        DBGPRINT((DM_SIDCACHE, DL_HIGH, TEXT("SIDCACHE - Index growth complete.")));
    }

    return g_pbMappedIndexFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::InitNewIndexFile

    Description: Initializes a new index file filling in the header information
        and clearing the index entries.

    Arguments:
        cBuckets - Number of hash table buckets in index file.  Should be
            prime.

        cMaxEntries - Initial max number of entries for the index.  Note
            that the index file grows automatically as required.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::InitNewIndexFile(
    DWORD cBuckets,
    DWORD cMaxEntries
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::InitNewIndexFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tcBuckets = %d, cMaxEntries = %d"),
               cBuckets, cMaxEntries));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pFileHdr->dwSignature   = INDEX_FILE_SIGNATURE;
    m_pFileHdr->dwVersion     = FILE_VERSION;
    m_pFileHdr->cBuckets      = cBuckets;
    m_pFileHdr->cMaxEntries   = cMaxEntries;
    m_pFileHdr->pBuckets      = (PINDEX_ENTRY *)(sizeof(INDEX_FILE_HDR));
    m_pFileHdr->pEntries      = (PINDEX_ENTRY)(m_pFileHdr->pBuckets + cBuckets);

    //
    // Initialize the hash table and return all entries to the free list.
    //
    Clear();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Clear

    Description: Fills the hash table with NULL pointers and returns all
        entry nodes to the free list.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::IndexMgr::Clear")));
    DBGASSERT((INDEX_FILE_MAPPED));

    m_pFileHdr->cEntries = 0;
    SetFileGUID(&GUID_Null);

    //
    // Initialize all hash buckets to NULL.
    //
    DBGASSERT((0 < m_pFileHdr->cBuckets));
    ZeroMemory(NDX_BASED_CAST(BYTE, m_pFileHdr->pBuckets),
               m_pFileHdr->cBuckets * sizeof(PINDEX_ENTRY *));

    //
    // Return all index entry nodes to the free list.
    //
    PINDEX_ENTRY pEntry = m_pFileHdr->pEntries;
    DBGASSERT((0 < m_pFileHdr->cMaxEntries));
    for (UINT i = 0; i < m_pFileHdr->cMaxEntries; i++)
    {
        //
        // We're iterating through all entries.  No need to detach first.
        //
        AddEntryToFreeList(pEntry++);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::SetFileGUID
    Function: SidNameCache::IndexMgr::GetFileGUID

    Description: These functions manipulate the guid field in the index file's
        header.
        The GUID is used to ensure integrity between
        the data and index files.  Before any change to either file, the
        GUID's are both set to 0.  When the change operation is complete,
        a new GUID is generated and written to both files.  Therefore, before
        any transaction, we can validate the data and index files by reading
        and comparing GUIDs.  If the GUIDs are not 0 and are equal, the
        file can be assumed to be valid.

    Arguments:
        pguid - Address of source or destination GUID.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::SetFileGUID(
    const GUID *pguid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(&m_pFileHdr->guid, pguid, sizeof(GUID));
}

VOID
SidNameCache::IndexMgr::GetFileGUID(
    LPGUID pguid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(pguid, &m_pFileHdr->guid, sizeof(GUID));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::AllocEntry

    Description: Allocates an entry from the free list.

    Arguments: None.

    Returns:
        Address of new entry node or NULL if free list is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::AllocEntry(
    VOID
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    PINDEX_ENTRY pEntry = m_pFileHdr->pFirstFree;

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

        //
        // Unlink the entry from the free list.
        //
        m_pFileHdr->pFirstFree = pBasedEntry->pNext;

        //
        // Clear it's "prev" and "next" pointers.
        //
        pBasedEntry->pNext = pBasedEntry->pPrev = NULL;

        if (NULL != m_pFileHdr->pFirstFree)
        {
            //
            // If there is at least one entry in the free list, set the "prev"
            // pointer of the new "first" entry to NULL.
            //
            pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, m_pFileHdr->pFirstFree);
            pBasedEntry->pPrev = NULL;
        }

        m_pFileHdr->cEntries++;
    }
    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::FreeEntry

    Description: Removes an entry from it's current list and returns it to the
        free list.  Two versions are provided.  One accepts a SID as an entry
        identifier, the other accepts the address of the index entry.

    Arguments:
        pSid - Address of SID associated with entry to be free'd.

        pEntry - Address of index entry to be free'd

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::FreeEntry(
    PSID pSid
    )
{
    DBGASSERT((NULL != pSid));
    PINDEX_ENTRY pEntry = Find(pSid);
    if (NULL != pEntry)
    {
        FreeEntry(pEntry);
    }
}


VOID
SidNameCache::IndexMgr::FreeEntry(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((NULL != pEntry));
    DetachEntry(pEntry);
    AddEntryToFreeList(pEntry);

    m_pFileHdr->cEntries--;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::AddEntryToFreeList

    Description: Returns a detached index entry to the free list.

    Arguments:
        pEntry - Address of index entry to be added to free list.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::AddEntryToFreeList(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pEntry));

    NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

    //
    // Insert the node at the head of the free list.
    // Note that double-linking isn't necessary in the free list
    // (we always add and remove free list entries at the head)
    // therefore we don't need to set the next node's "prev" pointer.
    //
    pBased->iBucket        = (DWORD)-1;
    pBased->iBlock         = (DWORD)-1;
    pBased->pPrev          = NULL;
    pBased->pNext          = m_pFileHdr->pFirstFree;
    m_pFileHdr->pFirstFree = pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::DetachEntry

    Description: Detaches an index entry from its current list.
        Note that this function assumes that the node exists in a valid
        linked list of nodes.  Do not call this function on an uninitialized
        index entry.

    Arguments:
        pEntry - Address of index entry to be detached.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::DetachEntry(
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pEntry));

    NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
    NDX_BASED(INDEX_ENTRY) *pBasedNext;
    NDX_BASED(INDEX_ENTRY) *pBasedPrev;

    //
    // Unlink the entry from it's list.
    //
    if (NULL != pBased->pPrev)
    {
        pBasedPrev        = NDX_BASED_CAST(INDEX_ENTRY, pBased->pPrev);
        pBasedPrev->pNext = pBased->pNext;
    }
    if (NULL != pBased->pNext)
    {
        pBasedNext        = NDX_BASED_CAST(INDEX_ENTRY, pBased->pNext);
        pBasedNext->pPrev = pBased->pPrev;
    }
    //
    // If we're detaching the entry that's attached to the hash array element,
    // adjust the element's value.
    //
    if (GetHashBucketValue(pBased->iBucket) == pEntry)
        SetHashBucketValue(pBased->iBucket, pBased->pNext);

    pBased->pNext = pBased->pPrev = NULL;

    return pEntry;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::GetHashBucketValue

    Description: Returns the address of the first index entry in a hash bucket.

    Arguments:
        iBucket - Array index of bucket in hash table array.

    Returns:
        Address of first entry in bucket's entry list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::GetHashBucketValue(
    DWORD iBucket
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((iBucket < m_pFileHdr->cBuckets));

    NDX_BASED(PINDEX_ENTRY) *pBased = NDX_BASED_CAST(PINDEX_ENTRY, m_pFileHdr->pBuckets + iBucket);
    return *pBased;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::SetHashBucketValue

    Description: Sets the address of the first index entry in a hash bucket.
        OK to set it as NULL.

    Arguments:
        iBucket - Array index of bucket in hash table array.

        pEntry - Address of entry node.

    Returns:
        Address of first entry in bucket's entry list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::IndexMgr::SetHashBucketValue(
    DWORD iBucket,
    PINDEX_ENTRY pEntry
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((iBucket < m_pFileHdr->cBuckets));
    //
    // pEntry == NULL is OK.
    //

    NDX_BASED(PINDEX_ENTRY) *pBased = NDX_BASED_CAST(PINDEX_ENTRY,
                                                     m_pFileHdr->pBuckets + iBucket);
    *pBased = pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Find (3 overloaded methods)

    Description: Given either a SID, a SID and hash value, or a user logon name,
        this method returns the address of the index entry
        representing that cache entry.

    Arguments:
        pKeySid - Address of SID to use as a lookup key.

        dwHashCode - Result of calling Hash(pKeySid).

        pszKeyLogonName - Address of account logon name string.

    Returns:
        Address of index entry representing the user.
        NULL if not found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    PSID pKeySid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pKeySid));

    return Find(pKeySid, Hash(pKeySid));  // Can throw OutOfMemory.
}


PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    PSID pKeySid,
    DWORD dwHashCode
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pKeySid));

    BOOL bFound         = FALSE;
    PINDEX_ENTRY pEntry = GetHashBucketValue(dwHashCode);
    while(NULL != pEntry && !bFound)
    {
        PSID pSid = NULL;
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

        //
        // This can throw OutOfMemory.
        //
        if (SUCCEEDED(m_refCache.m_pRecordMgr->Retrieve(pBased->iBlock,
                                                        &pSid,
                                                        NULL,
                                                        NULL,
                                                        NULL)))
        {
            if (EqualSid(pKeySid, pSid))
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            pEntry = pBased->pNext;
        }

        delete[] pSid;
    }

    return pEntry;
}


//
// This version of Find() performs a linear search of the index to locate
// the specified logon name.  The cache is currently indexed only
// on user SID because this is the only key used for very rapid lookups.
// The cache implementation could be easily extended to include a
// logon name index.  All that's needed is a second hash bucket array,
// a hash-on-name function and some adjustments to the placement of
// file data.  I just don't think the benefit is worth the cost.
//
PINDEX_ENTRY
SidNameCache::IndexMgr::Find(
    LPCTSTR pszKeyLogonName
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DBGASSERT((NULL != pszKeyLogonName));

    BOOL bFound         = FALSE;
    PINDEX_ENTRY pEntry = NULL;

    for (UINT i = 0; !bFound && (i < m_pFileHdr->cBuckets); i++)
    {
        pEntry = GetHashBucketValue(i);
        while(NULL != pEntry && !bFound)
        {
            array_autoptr<TCHAR> ptrLogonName;

            NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);

            //
            // This can throw OutOfMemory.
            //
            if (SUCCEEDED(m_refCache.m_pRecordMgr->Retrieve(pBased->iBlock,
                                                            NULL,
                                                            NULL,  // no container.
                                                            ptrLogonName.getaddr(),
                                                            NULL))) // no display name
            {
                DBGASSERT((NULL != ptrLogonName.get()));

                if (0 == lstrcmpi(ptrLogonName.get(), pszKeyLogonName))
                {
                    bFound = TRUE;
                }
            }
            if (!bFound)
            {
                pEntry = pBased->pNext;
            }
        }
    }
    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Lookup (2 overloaded methods)

    Description: Given either a SID or an account logon name,
        this method returns the starting block index of the corresponding
        record in the data file.

    Arguments:
        pSid - Address of SID to use as a lookup key.

        pszLogonName - Address of account logon name string.

    Returns:
        Index of the starting block for the record in the data file.
        (DWORD)-1 if the record is not found.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::IndexMgr::Lookup(
    PSID pSid
    )
{
    DBGASSERT((NULL != pSid));

    //
    // This can throw OutOfMemory.
    //
    PINDEX_ENTRY pEntry = Find(pSid, Hash(pSid));

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        return pBased->iBlock;
    }

    return (DWORD)-1;
}



DWORD
SidNameCache::IndexMgr::Lookup(
    LPCTSTR pszLogonName
    )
{
    DBGASSERT((NULL != pszLogonName));

    //
    // This can throw OutOfMemory.
    //
    PINDEX_ENTRY pEntry = Find(pszLogonName);

    if (NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        return pBased->iBlock;
    }

    return (DWORD)-1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Add

    Description: Adds a SID/data-file-index pair to the index file.  This
        entry can later be used to locate the SID's record in the data file.

    Arguments:
        pSid - Address of SID to use as a lookup key.

        iBlock - Index of the starting block for the SID's record in the
            data file.

    Returns: Address of the item's new index entry.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PINDEX_ENTRY
SidNameCache::IndexMgr::Add(
    PSID pSid,
    DWORD iBlock
    )
{
    DWORD dwHashCode    = Hash(pSid);
    PINDEX_ENTRY pEntry = Find(pSid, dwHashCode); // Can throw OutOfMemory.

    //
    // Don't create duplicate entries.
    //
    if (NULL == pEntry)
    {
        //
        // Try to allocate an index entry from the free list.
        //
        pEntry = AllocEntry();
        if (NULL == pEntry)
        {
            //
            // Grow the index file and try again.
            //
            GrowIndexFile(INDEX_FILE_GROW_ENTRIES);
            pEntry = AllocEntry();
        }
        if (NULL != pEntry)
        {
            NDX_BASED(INDEX_ENTRY) *pBasedEntry = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
            NDX_BASED(INDEX_ENTRY) *pBasedNext;

            //
            // Fill in the members of the new entry.
            //
            pBasedEntry->iBucket = dwHashCode;
            pBasedEntry->iBlock  = iBlock;
            pBasedEntry->pNext   = GetHashBucketValue(dwHashCode);
            pBasedEntry->pPrev   = NULL;
            //
            // Now insert it at the head of the hash bucket's entry list.
            //
            if (NULL != pBasedEntry->pNext)
            {
                pBasedNext = NDX_BASED_CAST(INDEX_ENTRY, pBasedEntry->pNext);
                pBasedNext->pPrev = pEntry;
            }
            SetHashBucketValue(dwHashCode, pEntry);
        }
    }

    return pEntry;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Hash

    Description: Given a SID, this method calculates a hash value to be used
        as an offset into the index's hash table bucket array.  The
        algorithm simply sums the value of the SID's bytes.  The resulting
        hash code is this sum modulo the size of the hash table.  For this
        simple algorithm to be effective, it is important that the hash
        table size be a prime number.

        Here's some representative primes: 101, 503, 1009, 5003, 10007

    Arguments:
        pSid - Address of SID to use as an index lookup key.

    Returns: Hashed SID.  The value will be between 0 and m_pFileHdr->cBuckets.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::IndexMgr::Hash(
    PSID pSid
    )
{
    DBGASSERT((INDEX_FILE_MAPPED));
    DWORD dwCode   = 0;
    PBYTE pbSid    = (PBYTE)pSid;
    PBYTE pbEndSid = pbSid + GetLengthSid(pSid);

    for ( ;pbSid < pbEndSid; pbSid++)
        dwCode += *pbSid;

    return dwCode % m_pFileHdr->cBuckets;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IndexMgr::Dump [DEBUG only]

    Description: Dumps the contents of the index file to the debugger output.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
SidNameCache::IndexMgr::Dump(
    VOID
    )
{
    UINT i, j;
    DBGASSERT((INDEX_FILE_MAPPED));

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("Dumping SidNameCache IndexMgr at 0x%p"), this));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Base...............: 0x%p"), g_pbMappedIndexFile));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  m_pFileHdr.........: 0x%p"), m_pFileHdr));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwSignature......: 0x%08X"), (DWORD)m_pFileHdr->dwSignature));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwVersion........: 0x%08X"), (DWORD)m_pFileHdr->dwVersion));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBuckets.........: %d"),     (DWORD)m_pFileHdr->cBuckets));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cMaxEntries......: %d"),     (DWORD)m_pFileHdr->cMaxEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cEntries.........: %d"),     (DWORD)m_pFileHdr->cEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pBuckets.........: 0x%p"), m_pFileHdr->pBuckets));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pEntries.........: 0x%p"), m_pFileHdr->pEntries));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pFirstFree.......: 0x%p"), m_pFileHdr->pFirstFree));

    for (i = 0; i < m_pFileHdr->cBuckets; i++)
    {
        PINDEX_ENTRY pEntry = GetHashBucketValue(i);
        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Bucket[%03d] = 0x%p"), i, pEntry));

        while(NULL != pEntry)
        {
            NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
            DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("     Bkt = %3d  P = 0x%08X  N = 0x%08X  Blk = %d"),
                       pBased->iBucket,
                       pBased->pPrev,
                       pBased->pNext,
                       pBased->iBlock));

            pEntry = pBased->pNext;
        }
    }

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  FreeList")));
    PINDEX_ENTRY pEntry = m_pFileHdr->pFirstFree;
    while(NULL != pEntry)
    {
        NDX_BASED(INDEX_ENTRY) *pBased = NDX_BASED_CAST(INDEX_ENTRY, pEntry);
        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("     Bkt = %3d  P = 0x%08X  N = 0x%08X  Blk = %d"),
                   pBased->iBucket,
                   pBased->pPrev,
                   pBased->pNext,
                   pBased->iBlock));

        pEntry = pBased->pNext;
    }
}
#endif


//***********************************************************************************
//***********************************************************************************
//   D A T A    F I L E    M A N A G E R
//***********************************************************************************
//***********************************************************************************

//
// Default cache record life values in days.
//
const DWORD DEF_REC_LIFE_MIN = 30;
const DWORD DEF_REC_LIFE_MAX = 60;

///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::RecordMgr

    Description: Record manager constructor.

    Arguments:
        refCache - Reference to containing cache object.  Used to call
            index manager and cache manager public methods.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::RecordMgr::RecordMgr(
    SidNameCache& refCache
    ) : m_refCache(refCache),
        m_pFileHdr(NULL),
        m_hFile(NULL),
        m_hFileMapping(NULL),
        m_cDaysRecLifeMin(DEF_REC_LIFE_MIN),
        m_cDaysRecLifeRange(DEF_REC_LIFE_MAX - DEF_REC_LIFE_MIN)
{
    DWORD cDaysRecLifeMax = DEF_REC_LIFE_MAX;

    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::RecordMgr")));

    //
    // Retrieve the min/max record life (days) from the registry.
    // Note that we store record life min and range since those are
    // what's used in the record life calculation.  Seems more
    // self-explanatory to store min/max in the registry rather than
    // min/range.
    //
    RegKey key(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (key.Open(KEY_WRITE, true))
    {
        if (FAILED(key.GetValue(g_szSidCacheRecLifeMin, &m_cDaysRecLifeMin)) ||
            65536 <= m_cDaysRecLifeMin)
        {
            m_cDaysRecLifeMin = DEF_REC_LIFE_MIN; // Default;
            key.SetValue(g_szSidCacheRecLifeMin, m_cDaysRecLifeMin);
        }
        if (FAILED(key.GetValue(g_szSidCacheRecLifeMax, &cDaysRecLifeMax)) ||
            65536 <= cDaysRecLifeMax)
        {
            cDaysRecLifeMax = DEF_REC_LIFE_MAX; // Default;
            key.SetValue(g_szSidCacheRecLifeMax, cDaysRecLifeMax);
        }
    }

    if (cDaysRecLifeMax < m_cDaysRecLifeMin)
        cDaysRecLifeMax = m_cDaysRecLifeMin;

    m_cDaysRecLifeRange = cDaysRecLifeMax - m_cDaysRecLifeMin;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::~RecordMgr

    Description: Record manager destructor. Closes the data file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
SidNameCache::RecordMgr::~RecordMgr(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_MID, TEXT("SidNameCache::SidNameCache::~RecordMgr")));
    CloseDataFile();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Initialize

    Description: Initializes a new record manager object.

    Arguments:
        pszFile - Address of full path for new file.

        cBlocks - Number of storage blocks in data file. Each is 32 bytes.
            If this argument is 0, the function tries to open an existing
            cache data file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::Initialize(
    LPCTSTR pszFile,
    DWORD cBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_HIGH, TEXT("SidNameCache::RecordMgr::Initialize")));
    DBGPRINT((DM_SIDCACHE, DL_HIGH, TEXT("\tpszFile = \"%s\", cBlocks = %d"),
              pszFile ? pszFile : TEXT("<null>"), cBlocks));
    //
    // Store the file name in our CString object.
    //
    m_strFileName = pszFile;

    if (0 != cBlocks)
    {
        //
        // Create a new data file.
        //
        // cBlocks must be a multiple of 32.
        // This satisfies the quadword alignment and makes sizing the
        // allocation bitmap much easier.  We let the caller pass in any value
        // they want and we just adjust it upward as needed.
        //
        if (cBlocks & 0x0000001F)
            cBlocks = (cBlocks & 0xFFFFFFE0) + 32;

        ULARGE_INTEGER uliFileSize;
        uliFileSize.QuadPart = FileSize(cBlocks);

        m_pFileHdr = (PDATA_FILE_HDR)CreateDataFile(pszFile,
                                                    uliFileSize.HighPart,
                                                    uliFileSize.LowPart);
        if (NULL != m_pFileHdr)
        {
            InitNewDataFile(cBlocks);
        }
    }
    else
    {
        //
        // Open an existing data file.
        //
        m_pFileHdr = (PDATA_FILE_HDR)OpenDataFile(pszFile);
        if (NULL != m_pFileHdr)
        {
            if (FILE_VERSION != m_pFileHdr->dwVersion ||
                DATA_FILE_SIGNATURE != m_pFileHdr->dwSignature)
            {
                //
                // This version of the software doesn't understand this
                // version of the file or the signature is invalid.
                // Don't take any chances.  We'll just create a new one.
                //
                DBGERROR((TEXT("SIDCACHE - Data file is invalid or incorrect version. A new data file will be created.")));

                CloseDataFile();
                m_pFileHdr = NULL;
            }
        }
    }
    return (LPBYTE)m_pFileHdr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::CreateDataFile

    Description: Creates and initializes a new data file.

    Arguments:
        pszFile - Address of full path for new file.

        cbFileHigh/Low - Size of file in bytes.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::CreateDataFile(
    LPCTSTR pszFile,
    DWORD cbFileHigh,
    DWORD cbFileLow
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::CreateDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tpszFile = \"%s\""),
              pszFile ? pszFile : TEXT("<null>")));

    CloseDataFile();  // Make sure any existing data file is closed.

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszDataFileMapping,
                                CREATE_ALWAYS,
                                cbFileHigh,
                                cbFileLow,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedDataFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::OpenDataFile

    Description: Opens an existing data file.

    Arguments:
        pszFile - Address of full path of existing file.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::OpenDataFile(
    LPCTSTR pszFile
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::OpenDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tpszFile = \"%s\""),
              pszFile ? pszFile : TEXT("<null>")));

    CloseDataFile();  // Make sure any existing data file is closed.

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                pszFile,
                                g_pszDataFileMapping,
                                OPEN_EXISTING,
                                0,
                                0,
                                &m_hFile,
                                &m_hFileMapping);

    return g_pbMappedDataFile;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::CloseDataFile

    Description: Closes the current data mapping and file.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::CloseDataFile(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::CloseDataFile")));
    if (NULL != g_pbMappedDataFile)
    {
        UnmapViewOfFile(g_pbMappedDataFile);
        g_pbMappedDataFile = NULL;
        m_pFileHdr = NULL;
    }
    if (NULL != m_hFileMapping)
    {
        CloseHandle(m_hFileMapping);
        m_hFileMapping = NULL;
    }
    if (NULL != m_hFile && INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::GrowDataFile

    Description: Increases the size of the current data file.

    Arguments:
        cGrowBlocks - Add this many more blocks to the data file.  The
            block allocation bitmap is also extended to accomdate the new
            block count.

    Returns: Address of mapped file or NULL on failure.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPBYTE
SidNameCache::RecordMgr::GrowDataFile(
    DWORD cGrowBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::GrowDataFile")));

    DBGASSERT((DATA_FILE_MAPPED));

    DWORD cOldBlocks = m_pFileHdr->cBlocks;
    DWORD cNewBlocks = cOldBlocks + cGrowBlocks;
    DWORD cOldMapEle = m_pFileHdr->cMapElements;
    DWORD cNewMapEle = 0; // Will calc later.

    //
    // cBlocks must be a multiple of 32.
    // This satisfies the quadword alignment and makes sizing the
    // allocation bitmap much easier.
    //
    if (cNewBlocks & 0x0000001F)
        cNewBlocks = (cNewBlocks & 0xFFFFFFE0) + 32;
    DBGASSERT((cNewBlocks >= cOldBlocks));

    //
    // Adjust cGrowBlocks for any adjustments in cNewBlocks.
    //
    cGrowBlocks = cNewBlocks - cOldBlocks;

    //
    // How many alloc map elements (DWORDs) do we need now?
    //
    cNewMapEle = cNewBlocks / BITS_IN_DWORD;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("Growing SID cache data file\nMap Ele %d -> %d\nBlocks %d -> %d"),
             cOldMapEle, cNewMapEle, cOldBlocks, cNewBlocks));

    //
    // Open the mapped file with a new larger size.
    //
    ULARGE_INTEGER uliFileSize;
    uliFileSize.QuadPart = FileSize(cNewBlocks);

    CloseDataFile();

    g_pbMappedDataFile = SidNameCache::OpenMappedFile(
                                m_strFileName,
                                g_pszDataFileMapping,
                                OPEN_EXISTING,
                                uliFileSize.HighPart,
                                uliFileSize.LowPart,
                                &m_hFile,
                                &m_hFileMapping);

    m_pFileHdr = (PDATA_FILE_HDR)g_pbMappedDataFile;

    if (NULL != g_pbMappedDataFile)
    {
        UINT i = 0;

        //
        // Block count and map size both increase.
        // Since map size increases, blocks must be moved to accomodate new
        // map elements.  Since the index file tracks records by block index,
        // this movement doesn't affect existing index file entries.
        //
        m_pFileHdr->cBlocks       = cNewBlocks;
        m_pFileHdr->cMapElements  = cNewMapEle;
        //
        // Save current block base for when we move the blocks to make room for
        // the growth of the allocation bitmap.
        //
        PBLOCK pBlocksOld = m_pFileHdr->pBlocks;
        //
        // Calculate the new address of block 0.
        // We want all of the data blocks quadword aligned because they contain
        // a FILETIME structure (64-bits).
        //
        m_pFileHdr->pBlocks = (PBLOCK)(m_pFileHdr->pdwMap + m_pFileHdr->cMapElements);
        QuadAlign((LPDWORD)(&m_pFileHdr->pBlocks));

        //
        // Move all of the existing blocks to their new locations.
        //
        MoveMemory(DAT_BASED_CAST(BLOCK, m_pFileHdr->pBlocks),
                   DAT_BASED_CAST(BLOCK, pBlocksOld),
                   cOldBlocks * sizeof(BLOCK));
        //
        // Initialize the new map elements to 0 (un-allocated).
        //
        ZeroMemory(DAT_BASED_CAST(BYTE, m_pFileHdr->pdwMap + cOldMapEle),
                   (cNewMapEle - cOldMapEle) * sizeof(DWORD));
        //
        // Initialize the new data blocks to 0xCC pattern.
        //
        FillBlocks(cOldBlocks, cGrowBlocks, RECORD_UNUSED_BYTE);

        DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - Data file growth complete.")));
    }
    return g_pbMappedDataFile;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::SetFileGUID
    Function: SidNameCache::RecordMgr::GetFileGUID

    Description: These functions manipulate the guid field in the data file's
        header.
        The GUID is used to ensure integrity between
        the data and index files.  Before any change to either file, the
        GUID's are both set to 0.  When the change operation is complete,
        a new GUID is generated and written to both files.  Therefore, before
        any transaction, we can validate the data and index files by reading
        and comparing GUIDs.  If the GUIDs are not 0 and are equal, the
        file can be assumed to be valid.

    Arguments:
        pguid - Address of source or destination GUID.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::SetFileGUID(
    const GUID *pguid
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(&m_pFileHdr->guid, pguid, sizeof(GUID));
}


VOID
SidNameCache::RecordMgr::GetFileGUID(
    LPGUID pguid
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((NULL != pguid));
    CopyMemory(pguid, &m_pFileHdr->guid, sizeof(GUID));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::InitNewDataFile

    Description: Initializes a new data file filling in the header information
        and writing 0xCC in all the data block bytes.

    Arguments:
        cBlocks - Number of data blocks (32 bytes each) in data file.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::InitNewDataFile(
    DWORD cBlocks
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::InitNewDataFile")));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("\tcBlocks = %d"), cBlocks));
    UINT i = 0;

    DBGASSERT((DATA_FILE_MAPPED));

    //
    // Initialize file header.
    //
    m_pFileHdr->dwSignature   = DATA_FILE_SIGNATURE;
    m_pFileHdr->dwVersion     = FILE_VERSION;
    m_pFileHdr->cBlocks       = cBlocks;
    m_pFileHdr->cMapElements  = cBlocks / BITS_IN_DWORD;
    m_pFileHdr->pdwMap        = (LPDWORD)(sizeof(DATA_FILE_HDR));
    m_pFileHdr->pBlocks       = (PBLOCK)(m_pFileHdr->pdwMap + m_pFileHdr->cMapElements);

    //
    // We want all of the data blocks quadword aligned because they contain
    // a FILETIME structure (64-bits).
    //
    QuadAlign((LPDWORD)(&m_pFileHdr->pBlocks));

    //
    // Write 0xCC to all data block bytes.
    //
    Clear();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Clear

    Description: Zero's the file header guid, clears all bits in the
        block allocation bitmap and fills the data blocks with 0xCC.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::Clear(
    VOID
    )
{
    DBGTRACE((DM_SIDCACHE, DL_LOW, TEXT("SidNameCache::RecordMgr::Clear")));
    DBGASSERT((DATA_FILE_MAPPED));

    m_pFileHdr->cBlocksUsed   = 0;
    m_pFileHdr->iFirstFree    = 0;
    SetFileGUID(&GUID_Null);

    //
    // Initialize all block allocation map bits to 0 (un-allocated).
    //
    ZeroMemory(DAT_BASED_CAST(BYTE, m_pFileHdr->pdwMap),
               m_pFileHdr->cMapElements * sizeof(DWORD));
    //
    // Initialize all data blocks to 0xCC pattern.
    //
    FillBlocks(0, m_pFileHdr->cBlocks, RECORD_UNUSED_BYTE);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FillBlocks

    Description: Fills a range of blocks with a specified byte.

    Arguments:
        iBlock - Index of first block in range.

        cBlocks - Number of blocks to fill.

        b - Byte to write to blocks.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FillBlocks(
    DWORD iBlock,
    DWORD cBlocks,
    BYTE b
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, BlockAddress(iBlock));
    DBGASSERT((SidNameCache::IsQuadAligned(pb)));

    //
    // Just in case the fill request would extend over the
    // end of the file, truncate the requested block count.  The assertion
    // will catch it during development.
    //
    DWORD iLastBlock = iBlock + cBlocks - 1;
    DBGASSERT((ValidBlockNumber(iLastBlock)));
    if (iLastBlock >= m_pFileHdr->cBlocks)
        cBlocks = m_pFileHdr->cBlocks - iBlock;

    FillMemory(pb, sizeof(BLOCK) * cBlocks, b);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::IsBitSet
    Function: SidNameCache::RecordMgr::SetBit
    Function: SidNameCache::RecordMgr::ClrBit

    Description: Tests and sets bits in the block allocation bitmap.

    Arguments:
        pdwBase - Address of 1st DWORD in bitmap.

        iBit - 0-based index of bit in bitmap.

    Returns: IsBitSet returns TRUE/FALSE indicating the state of the bit.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::IsBitSet(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    return (*(pdwBase + i)) & (1 << b);
}


VOID
SidNameCache::RecordMgr::SetBit(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    (*(pdwBase + i)) |= (1 << b);
}

VOID
SidNameCache::RecordMgr::ClrBit(
    LPDWORD pdwBase,
    DWORD iBit
    )
{
    DBGASSERT((NULL != pdwBase));
    DWORD b = iBit & 0x0000001F;
    DWORD i = iBit >> 5;

    (*(pdwBase + i)) &= ~(1 << b);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::ValidBlockNumber

    Description: Determine if a given block number is valid for the
        current data file.  Primarily meant for use in assertions.

    Arguments:
        iBlock - 0-based index of block in data file.

    Returns: TRUE/FALSE indicating validity of block number.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::ValidBlockNumber(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    return (iBlock < m_pFileHdr->cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::IsBlockUsed
    Function: SidNameCache::RecordMgr::MarkBlockUsed
    Function: SidNameCache::RecordMgr::MarkBlockUnused

    Description: Examines and changes the allocation state of a block in the
        data file.

    Arguments:
        iBlock - 0-based index of block in data file.

    Returns: IsBlockUsed returns TRUE/FALSE indicating the allocation state.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::IsBlockUsed(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));
    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);

    return IsBitSet((LPDWORD)pdwBased, iBlock);
}


VOID
SidNameCache::RecordMgr::MarkBlockUsed(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);
    DBGASSERT((!IsBitSet((LPDWORD)pdwBased, iBlock)));
    SetBit((LPDWORD)pdwBased, iBlock);
}

VOID
SidNameCache::RecordMgr::MarkBlockUnused(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    DAT_BASED(DWORD) *pdwBased = DAT_BASED_CAST(DWORD, m_pFileHdr->pdwMap);
    DBGASSERT((IsBitSet((LPDWORD)pdwBased, iBlock)));
    ClrBit((LPDWORD)pdwBased, iBlock);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BlocksRequired

    Description: Calculate the number of blocks required to store a given
        number of bytes.

    Arguments:
        cb - Number of bytes requested.

    Returns: Number of 32-byte blocks required to store the bytes.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::BlocksRequired(
    DWORD cb
    )
{
    //
    // Round byte request up to nearest 32-byte block.
    //
    if (cb & 0x0000001F)
        cb = (cb & 0xFFFFFFE0) + 32;

    //
    // How many "blocks" are required?
    //
    return BYTE_TO_BLOCK(cb);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::IsQuadAligned
    Function: SidNameCache::QuadAlign
    Function: SidNameCache::WordAlign

    Description: Methods that determine if a value is quad aligned and for
        updating a value so that it is quad or word aligned.

    Arguments:
        See the individual methods.  It's pretty self-explanatory.

    Returns:
        See the individual methods.  It's pretty self-explanatory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::IsQuadAligned(
    LPVOID pv
    )
{
    return (IsQuadAligned((DWORD_PTR)pv));
}


BOOL
SidNameCache::IsQuadAligned(
    DWORD_PTR dw
    )
{
    return (0 == (dw & 0x00000007));
}


VOID
SidNameCache::QuadAlign(
    LPDWORD pdwValue
    )
{
    DBGASSERT((NULL != pdwValue));
    if (*pdwValue & 0x00000007)
    {
        //
        // Round up to next whole multiple of 8.
        //
        *pdwValue = (*pdwValue & 0xFFFFFFF8) + 8;
    }
}


VOID
SidNameCache::WordAlign(
    LPDWORD pdwValue
    )
{
    DBGASSERT((NULL != pdwValue));
    if (*pdwValue & 0x00000001)
    {
        //
        // Round up to next whole multiple of 2.
        //
        *pdwValue = (*pdwValue & 0xFFFFFFFE) + 2;
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BytesRequiredForRecord

    Description: Calculates the number of bytes required to store a given
        data file record.  Optionally returns the required size for each
        field in the record (SID, name, domain etc).  The function makes
        allowances for any required data type alignments in the file.

    Arguments:
        pSid - Address of user's SID.

        pcbSid [optional] - Address of variable to receive required SID length.

        pszContainer - Address of user's account container name string.

        pcbContainer [optional] - Address of variable to receive required length
            of container name string.

        pszLogonName - Address of user's logon name string.

        pcbLogonName [optional] - Address of variable to receive required length
            of logon name string.

        pszDisplayName - Address of user's display name string.

        pcbDisplayName [optional] - Address of variable to receive required
            length of display name string.

    Returns: Number of bytes required to store the record.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::BytesRequiredForRecord(
    PSID pSid,
    LPDWORD pcbSid,
    LPCTSTR pszContainer,
    LPDWORD pcbContainer,
    LPCTSTR pszLogonName,
    LPDWORD pcbLogonName,
    LPCTSTR pszDisplayName,
    LPDWORD pcbDisplayName
    )
{
    DWORD cb      = 0;
    DWORD cbTotal = sizeof(RECORD_HDR);

    //
    // SID follows the header so it IS quadword aligned.
    // It's a byte structure so it doesn't have to be; but it is anyway.
    //
    cb = GetLengthSid(pSid);
    cbTotal += cb;
    if (NULL != pcbSid)
        *pcbSid = cb;

    //
    // Strings are UNICODE and must be word-aligned.  Just align the first.
    // All subsequent are guaranteed to be properly aligned.
    //
    SidNameCache::WordAlign(&cbTotal);
    cb = (lstrlen(pszContainer) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbContainer)
        *pcbContainer = cb;

    cb = (lstrlen(pszLogonName) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbLogonName)
        *pcbLogonName = cb;

    cb = (lstrlen(pszDisplayName) + 1) * sizeof(TCHAR);
    cbTotal += cb;
    if (NULL != pcbDisplayName)
        *pcbDisplayName = cb;

    return cbTotal;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeBlock

    Description: Frees a single block in the data file.

    Arguments:
        iBlock - 0-based index of the block.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeBlock(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));
    DBGASSERT((IsBlockUsed(iBlock)));

    MarkBlockUnused(iBlock);
    DBGASSERT((!IsBlockUsed(iBlock)));

    FillBlocks(iBlock, 1, RECORD_UNUSED_BYTE);

    //
    // Update the "first free" index if needed.
    //
    if (iBlock < m_pFileHdr->iFirstFree)
        m_pFileHdr->iFirstFree = iBlock;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeBlocks

    Description: Frees a series of contiguous blocks in the data file.

    Arguments:
        iBlock - 0-based index of the first block in the series.

        cBlocks - Number of blocks in the series.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeBlocks(
    DWORD iFirstBlock,
    DWORD cBlocks
    )
{
    for (UINT i = 0; i < cBlocks; i++)
        FreeBlock(iFirstBlock + i);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FreeRecord

    Description: Frees all blocks in a data file record.

    Arguments:
        iFirstBlock - 0-based index of the first block in the record.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
SidNameCache::RecordMgr::FreeRecord(
    DWORD iFirstBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iFirstBlock)));
    DAT_BASED(RECORD_HDR) *pRecHdr = DAT_BASED_CAST(RECORD_HDR, BlockAddress(iFirstBlock));

    DBGASSERT((RECORD_SIGNATURE == pRecHdr->dwSignature));
    FreeBlocks(iFirstBlock, pRecHdr->cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::BlockAddress

    Description: Calculates the non-based address of a given block in the
        data file.

    Arguments:
        iBlock - 0-based index of the block.

    Returns: Address of the block in the data file.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PBLOCK
SidNameCache::RecordMgr::BlockAddress(
    DWORD iBlock
    )
{
    DBGASSERT((DATA_FILE_MAPPED));
    DBGASSERT((ValidBlockNumber(iBlock)));

    return m_pFileHdr->pBlocks + iBlock;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::FileSize

    Description: Calculate the data file size required for a given number of
        data blocks.  Accounts for data type alignment.

    Arguments:
        cBlocks - Number of blocks required in the data file.

    Returns: Bytes required.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT64
SidNameCache::RecordMgr::FileSize(
    DWORD cBlocks
    )

{
    DWORD dwTemp = sizeof(DATA_FILE_HDR) +
                  ((cBlocks / BITS_IN_DWORD) * sizeof(DWORD));

    //
    // Start of blocks must be quad-aligned.
    //
    SidNameCache::QuadAlign(&dwTemp);

    return (UINT64)(dwTemp) +
           (UINT64)(sizeof(BLOCK) * cBlocks);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::AllocBlocks

    Description: Allocates a specified number of contiguous blocks in the
        data file.

    Arguments:
        cBlocksReqd - Number of blocks required in the allocation.

    Returns: If successful, returns the index of the first block in the
        allocation.  Returns (DWORD)-1 if the block's can't be allocated.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::AllocBlocks(
    DWORD cBlocksReqd
    )
{
    DBGASSERT((DATA_FILE_MAPPED));

    DWORD iBlock = m_pFileHdr->iFirstFree;

    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("SIDCACHE - AllocBlocks: Allocate %d blocks"),
             cBlocksReqd));

    while(iBlock < m_pFileHdr->cBlocks)
    {
        DBGPRINT((DM_SIDCACHE, DL_MID,
                 TEXT("   Start scan at block %d"), iBlock));
        //
        // Look for cBlocksReqd consecutive free blocks.
        //
        for (UINT j = 0; j < cBlocksReqd && (iBlock + j) < m_pFileHdr->cBlocks ; j++)
        {
            DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("      Checking %d"), iBlock + j));
            if (IsBlockUsed(iBlock + j))
            {
                //
                // This one's used. Start searching again.
                //
                DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("      %d is used"), iBlock + j));
                break;
            }
#if DBG
            //
            // If a block is marked "unused", it should contain all 0xCC.
            //
            DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, BlockAddress(iBlock + j));
            for (UINT k = 0; k < sizeof(BLOCK); k++)
            {
                DBGASSERT((RECORD_UNUSED_BYTE == *(pb + k)));
            }
#endif
        }

        DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("   Scan complete.  %d blocks checked"), j));
        if (j == cBlocksReqd)
        {
            //
            // Found a sufficient range of free blocks.
            // Mark the blocks as allocated in the allocation bitmap.
            //
            for (UINT i = 0; i < cBlocksReqd; i++)
                MarkBlockUsed(iBlock + i);

            if (iBlock == m_pFileHdr->iFirstFree)
            {
                //
                // Now scan to find the next free block.
                // We'll save it's location to help with future free-block searches.
                //
                for (m_pFileHdr->iFirstFree = iBlock + cBlocksReqd;
                     m_pFileHdr->iFirstFree < m_pFileHdr->cBlocks && IsBlockUsed(m_pFileHdr->iFirstFree);
                     m_pFileHdr->iFirstFree++)
                {
                    DBGPRINT((DM_SIDCACHE, DL_MID,
                             TEXT("SIDCACHE - Advancing first free %d"),
                             m_pFileHdr->iFirstFree));
                    NULL;
                }
            }
            DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - Found free block range at %d"), iBlock));
            return iBlock;
        }

        iBlock += (j + 1);  // Continue search.
    }
    DBGPRINT((DM_SIDCACHE, DL_MID, TEXT("SIDCACHE - No blocks available")));

    return (DWORD)-1;  // No blocks available of sufficient size.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::RecordExpired

    Description: Determine if a given record has expired.  A record has
        "expired" if it's expiration date is prior to "today".

    Arguments:
        iBlock - 0-based index of first block in record.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
SidNameCache::RecordMgr::RecordExpired(
    DWORD iBlock
    )
{
    DBGASSERT((ValidBlockNumber(iBlock)));
    DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, BlockAddress(iBlock));
    DBGASSERT((SidNameCache::IsQuadAligned(pRec)));
    DBGASSERT((RECORD_SIGNATURE == pRec->dwSignature));

    SYSTEMTIME SysNow;
    FILETIME FileNow;
    ULARGE_INTEGER uliFileNow;
    ULARGE_INTEGER uliBirthday;

    uliBirthday.LowPart  = pRec->Birthday.dwLowDateTime;
    uliBirthday.HighPart = pRec->Birthday.dwHighDateTime;

    GetSystemTime(&SysNow);
    SystemTimeToFileTime(&SysNow, &FileNow);

    uliFileNow.LowPart  = FileNow.dwLowDateTime;
    uliFileNow.HighPart = FileNow.dwHighDateTime;

    DWORD cDaysVariation = 0;
    //
    // Avoid div-by-zero.
    //
    if (0 < m_cDaysRecLifeRange)
        cDaysVariation = SysNow.wMilliseconds % m_cDaysRecLifeRange;

    //
    // Add time specified in registry to the record's birthday.
    // 864,000,000,000L is the number of 100 nanosecond periods in a day
    // which is the unit the FILETIME structure is based on.
    //
    uliBirthday.QuadPart += ((UINT64)864000000000L *
                            (UINT64)(m_cDaysRecLifeMin + cDaysVariation));
    //
    // If it's still less than "now", the record is considered good.
    //
    return uliFileNow.QuadPart > uliBirthday.QuadPart;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Store

    Description: Stores a record in the data file.

    Arguments:
        pSid - Address of user's SID.

        pszContainer - Address of user's account container name string.

        pszLogonName - Address of user's logon name string.

        pszDisplayName - Address of user's display name string.

    Returns: Index of the first block used for the record.
        (DWORD)-1 if the block couldn't be stored.  Could mean out-of-disk
        space.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
SidNameCache::RecordMgr::Store(
    PSID pSid,
    LPCTSTR pszContainer,
    LPCTSTR pszLogonName,
    LPCTSTR pszDisplayName
    )
{
    DWORD cbSid         = 0;
    DWORD cbContainer   = 0;
    DWORD cbLogonName   = 0;
    DWORD cbDisplayName = 0;

    DWORD cbRequired = BytesRequiredForRecord(
                            pSid,
                            &cbSid,
                            pszContainer,
                            &cbContainer,
                            pszLogonName,
                            &cbLogonName,
                            pszDisplayName,
                            &cbDisplayName);

    DWORD cBlocksRequired = BlocksRequired(cbRequired);
    DBGPRINT((DM_SIDCACHE, DL_MID,
             TEXT("SIDCACHE - Store: %s (%s) in \"%s\"  %d bytes, %d blocks"),
             pszDisplayName, pszLogonName, pszContainer, cbRequired, cBlocksRequired));

    //
    // Try to allocate the required blocks.
    //
    DWORD iBlock = AllocBlocks(cBlocksRequired);
    if ((DWORD)-1 == iBlock)
    {
        //
        // Couldn't allocate blocks.  Extend the data file.
        //
        GrowDataFile(DATA_FILE_GROW_BLOCKS);
        iBlock = AllocBlocks(cBlocksRequired);
    }
    if ((DWORD)-1 != iBlock)
    {
        //
        // Got the required number of blocks.
        //
        DBGASSERT((ValidBlockNumber(iBlock)));
        PBLOCK pBlock               = BlockAddress(iBlock);
        DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, pBlock);
        DAT_BASED(BYTE) *pbRec      = DAT_BASED_CAST(BYTE, pBlock);

        //
        // Fill in the record header.
        // Includes storing the item offset values from the start of the record.
        // Storing these values in the record hdr will help with data retrieval.
        //
        pRec->dwSignature       = RECORD_SIGNATURE;
        pRec->cBlocks           = cBlocksRequired;
        pRec->cbOfsSid          = sizeof(RECORD_HDR);
        pRec->cbOfsContainer    = pRec->cbOfsSid    + cbSid;
        WordAlign(&pRec->cbOfsContainer);

        pRec->cbOfsLogonName   = pRec->cbOfsContainer + cbContainer;
        pRec->cbOfsDisplayName = pRec->cbOfsLogonName + cbLogonName;;

        //
        // Record the "birthday" so we can age the record.
        //
        SYSTEMTIME SysNow;
        GetSystemTime(&SysNow);
        SystemTimeToFileTime(&SysNow, &pRec->Birthday);

        //
        // Store the record's data.
        // Use ACTUAL length values for memory transfers.
        //
        CopySid(cbSid, (PSID)(pbRec + pRec->cbOfsSid), pSid);
        lstrcpy((LPTSTR)(pbRec + pRec->cbOfsContainer),   pszContainer);
        lstrcpy((LPTSTR)(pbRec + pRec->cbOfsLogonName),   pszLogonName);
        lstrcpy((LPTSTR)(pbRec + pRec->cbOfsDisplayName), pszDisplayName);

        //
        // Update the file's "blocks used" count.
        //
        m_pFileHdr->cBlocksUsed += pRec->cBlocks;
    }

    return iBlock;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Retrieve

    Description: Retrieves a record in the data file.

    Arguments:
        iBlock - 0-based index of the starting block in the record.

        ppSid [optional] - Address of SID pointer variable to receive the
            address of the SID buffer.  The caller is responsible for freeing
            the buffer.  May be NULL.

        ppszContainer [optional] - Address of pointer variable to receive the
            address of the container name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

        ppszLogonName [optional] - Address of pointer variable to receive the
            address of the logon name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

        ppszDisplayName [optional] - Address of pointer variable to receive the
            address of the display name string buffer.  The caller is
            responsible for freeing the buffer.  May be NULL.

    Returns:
        NO_ERROR          - Success.
        ERROR_INVALID_SID (hr) - The record contains an invalid SID.  Probably
            a corrupt record.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
SidNameCache::RecordMgr::Retrieve(
    DWORD iBlock,
    PSID *ppSid,
    LPTSTR *ppszContainer,
    LPTSTR *ppszLogonName,
    LPTSTR *ppszDisplayName
    )
{
    PBLOCK pBlock               = BlockAddress(iBlock);
    DAT_BASED(RECORD_HDR) *pRec = DAT_BASED_CAST(RECORD_HDR, pBlock);
    DAT_BASED(BYTE) *pbRec      = DAT_BASED_CAST(BYTE, pBlock);

    DBGASSERT((SidNameCache::IsQuadAligned(pRec)));
    DBGASSERT((RECORD_SIGNATURE == pRec->dwSignature));

    if (NULL != ppSid)
    {
        PSID pSid = (PSID)(pbRec + pRec->cbOfsSid);
        if (IsValidSid(pSid))
        {
            *ppSid = SidDup(pSid);
        }
        else
            return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }

    if (NULL != ppszContainer)
    {
        *ppszContainer = StringDup((LPTSTR)(pbRec + pRec->cbOfsContainer));
    }

    if (NULL != ppszLogonName)
    {
        *ppszLogonName = StringDup((LPTSTR)(pbRec + pRec->cbOfsLogonName));
    }

    if (NULL != ppszDisplayName)
    {
        *ppszDisplayName = StringDup((LPTSTR)(pbRec + pRec->cbOfsDisplayName));
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: SidNameCache::RecordMgr::Dump

    Description: Dumps the contents of the data file to the debugger output.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/21/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
SidNameCache::RecordMgr::Dump(
    VOID
    )
{
    UINT i, j;
    DBGASSERT((DATA_FILE_MAPPED));

    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("Dumping SidNameCache RecordMgr at 0x%p"), this));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  Base...............: 0x%p"), g_pbMappedDataFile));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("  m_pFileHdr.........: 0x%p"), m_pFileHdr));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwSignature......: 0x%08X"), (DWORD)m_pFileHdr->dwSignature));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    dwVersion........: 0x%08X"), (DWORD)m_pFileHdr->dwVersion));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBlocks..........: %d"),     (DWORD)m_pFileHdr->cBlocks));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cBlocksUsed......: %d"),     (DWORD)m_pFileHdr->cBlocksUsed));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    cMapElements.....: %d"),     (DWORD)m_pFileHdr->cMapElements));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    iFirstFree.......: %d"),     (DWORD)m_pFileHdr->iFirstFree));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pdwMap...........: 0x%p"), m_pFileHdr->pdwMap));
    DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("    pBlocks..........: 0x%p"), m_pFileHdr->pBlocks));

    PBLOCK pBlock = m_pFileHdr->pBlocks;

    for (i = 0; i < m_pFileHdr->cBlocks; i++)
    {
        DAT_BASED(BYTE) *pb = DAT_BASED_CAST(BYTE, pBlock);

        DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("BLOCK %d --------------------"), i));
        for (UINT row = 0; row < 2; row++)
        {
            TCHAR szHex[MAX_PATH];
            TCHAR szAscii[MAX_PATH];

            LPTSTR pszHex = szHex;
            pb = DAT_BASED_CAST(BYTE, pBlock) + (row * (sizeof(BLOCK)/2));
            for (j = 0; j < 16; j++)
            {
                wsprintf(pszHex, TEXT("%02X "), *pb);
                pb++;
                pszHex += 2;
            }

            LPTSTR pszAscii = szAscii;
            pb = DAT_BASED_CAST(BYTE, pBlock) + (row * (sizeof(BLOCK)/2));
            for (j = 0; j < 16; j++)
            {
                wsprintf(pszAscii, TEXT("%c"), *pb > 31 ? *pb : TEXT('.'));
                pb++;
                pszAscii++;
            }
            DBGPRINT((DM_SIDCACHE, DL_LOW, TEXT("%s %s"), szHex, szAscii));
        }
        pBlock++;
    }
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\userbat.h ===
#ifndef _INC_DSKQUOTA_USERBAT_H
#define _INC_DSKQUOTA_USERBAT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userbat.h

    Description: Provides declaration for class DiskQuotaUserBatch.
        This class is provided to allow batch updates of quota user information.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/07/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif

class DiskQuotaUserBatch : public IDiskQuotaUserBatch
{
    private:
        LONG              m_cRef;            // Ref counter.
        FSObject         *m_pFSObject;       // Ptr to file sys object.
        CArray<PDISKQUOTA_USER> m_UserList;  // List of users to batch process.
        
        HRESULT
        RemoveUser(
            PDISKQUOTA_USER pUser);

        STDMETHODIMP
        RemoveAllUsers(VOID);

        VOID
        Destroy(
            VOID);

        //
        // Prevent copying.
        //
        DiskQuotaUserBatch(const DiskQuotaUserBatch& );
        DiskQuotaUserBatch& operator = (const DiskQuotaUserBatch& );

    public:
//
// APPCOMPAT: Find out why compiler doesn't like this exception decl.
//
//        DiskQuotaUserBatch(FSObject *pFSObject) throw(OutOfMemory, SyncObjErrorCreate);
        DiskQuotaUserBatch(FSObject *pFSObject);
        ~DiskQuotaUserBatch(VOID);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDiskQuotaUserBatch interface.
        //
        STDMETHODIMP
        Add(
            PDISKQUOTA_USER);

        STDMETHODIMP
        Remove(
            PDISKQUOTA_USER);

        STDMETHODIMP
        RemoveAll(
            VOID);

        STDMETHODIMP
        FlushToDisk(
            VOID);
};

#endif // _INC_DSKQUOTA_USERBAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\user.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: user.cpp

    Description: Contains member function definitions for class DiskQuotaUser.
        The DiskQuotaUser object represents a user's record in a volume's
        quota information file.  The holder of a user object's IDiskQuotaUser
        interface can query and modify information for that user as security
        privileges permit.  A user object is obtained through a UserEnumerator
        object (IEnumDiskQuotaUsers) which is itself obtained through
        IDiskQuotaControl::CreateEnumUsers().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/20/96    Added m_dwID member to DiskQuotaUser.                BrianAu
    09/05/96    Added exception handling.                            BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in
                reponse to making the quota UI DS-aware.  The
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <comutil.h>
#include "user.h"
#include "resource.h"  // For IDS_NO_LIMIT.

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


//
// Only one of these for all users. (static member).
//
LONG            DiskQuotaUser::m_cUsersAlive        = 0;    // Cnt of users alive now.
ULONG           DiskQuotaUser::m_ulNextUniqueId     = 0;
HANDLE          DiskQuotaUser::m_hMutex             = NULL;
DWORD           DiskQuotaUser::m_dwMutexWaitTimeout = 5000; // 5 seconds.
CArray<CString> DiskQuotaUser::m_ContainerNameCache;



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::DiskQuotaUser

    Description: Constructor.

    Arguments:
         pFSObject - Pointer to "file system" object.  It is through this pointer
            that the object accesses the ntioapi functions.  Caller must call
            AddRef() for this pointer prior to calling Initialize().


    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUser::DiskQuotaUser(
    FSObject *pFSObject
    ) : m_cRef(0),
        m_ulUniqueId(InterlockedIncrement((LONG *)&m_ulNextUniqueId)),
        m_pSid(NULL),
        m_pszLogonName(NULL),
        m_pszDisplayName(NULL),
        m_pFSObject(pFSObject),
        m_bNeedCacheUpdate(TRUE),     // Data cache, not domain name cache.
        m_iContainerName(-1),
        m_dwAccountStatus(DISKQUOTA_USER_ACCOUNT_UNRESOLVED)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUser::DiskQuotaUser")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    DBGASSERT((NULL != m_pFSObject));

    m_llQuotaUsed      = 0;
    m_llQuotaThreshold = 0;
    m_llQuotaLimit     = 0;

    //
    // Initialize the domain name cache and class-wide locking mutex.
    // These members are static so we only do it once.
    //
    InterlockedIncrement(&m_cUsersAlive);
    if (NULL == DiskQuotaUser::m_hMutex)
    {
        DiskQuotaUser::m_hMutex = CreateMutex(NULL, FALSE, NULL);
        m_ContainerNameCache.SetSize(25);
        m_ContainerNameCache.SetGrow(25);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::~DiskQuotaUser

    Description: Destructor

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUser::~DiskQuotaUser(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUser::~DiskQuotaUser")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    Destroy();
    if (InterlockedDecrement(&m_cUsersAlive) == 0)
    {
        //
        // If active user count is 0, destroy the domain name cache and
        // class-wide mutex.
        //
        DestroyContainerNameCache();

        if (NULL != DiskQuotaUser::m_hMutex)
        {
            CloseHandle(DiskQuotaUser::m_hMutex);
            DiskQuotaUser::m_hMutex = NULL;
        }
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        IDiskQuotaUser interface.  Only IID_IUnknown and
        IID_IDiskQuotaUser are recognized.  The object referenced by the
        returned interface pointer is uninitialized.  The recipient of the
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR         - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_USER, DL_MID, TEXT("DiskQuotaUser::QueryInterface")));
    DBGPRINTIID(DM_USER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    try
    {
        *ppvOut = NULL;

        if (IID_IUnknown == riid ||
            IID_IDiskQuotaUser == riid)
        {
            *ppvOut = static_cast<IDiskQuotaUser *>(this);
        }
        else if (IID_IDispatch == riid ||
                 IID_DIDiskQuotaUser == riid)
        {
            //
            // Create a disk quota user "dispatch" object to handle all of
            // the automation duties. This object takes a pointer to the real
            // user object so that it can call the real object to do the real
            // work.  The reason we use a special "dispatch" object is so that
            // we can maintain identical names for dispatch and vtable methods
            // that perform the same function.  Otherwise, if the DiskQuotaUser
            // object implements both IDiskQuotaUser and DIDiskQuotaUser methods,
            // we could not have two methods named Invalidate (one for vtable
            // and one for dispatch.
            //
            DiskQuotaUserDisp *pUserDisp = new DiskQuotaUserDisp(static_cast<PDISKQUOTA_USER>(this));
            *ppvOut = static_cast<DIDiskQuotaUser *>(pUserDisp);
        }
        if (NULL != *ppvOut)
        {
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hResult = NOERROR;
        }
    }
    catch(CAllocException& e)
    {
        *ppvOut = NULL;
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DiskQuotaUser::AddRef(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUser::AddRef")));
    DBGPRINT((DM_USER, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
              this, m_cRef, m_cRef + 1));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DiskQuotaUser::Release(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUser::Release")));
    DBGPRINT((DM_USER, DL_LOW, TEXT("\t0x%08X  %d -> %d"),
              this, m_cRef, m_cRef - 1));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Initialize

    Description: Initializes a new DiskQuotaUser object from a quota information
        record read from a volume's quota information file.

    Arguments:
        pfqi [optional] - Pointer to a record of type FILE_QUOTA_INFORMATION.  If
            not NULL, the data from this record is used to initialize the new user
            object.

    Returns:
        NOERROR             - Success.
        E_UNEXPECTED        - SID buffer too small (shouldn't happen).
        ERROR_INVALID_SID (hr) - SID in quota information is invalid.
        ERROR_ACCESS_DENIED (hr) - Need READ access to quota device.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/11/96    Added access control.                                BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::Initialize(
    PFILE_QUOTA_INFORMATION pfqi
    )
{
    HRESULT hResult = NOERROR;

    DBGASSERT((NULL != m_pFSObject));

    //
    // Need READ access to create a user object.
    //
    if (m_pFSObject->GrantedAccess(GENERIC_READ))
    {
        if (NULL != pfqi)  // pfqi is optional.
        {
            if (0 < pfqi->SidLength && IsValidSid(&pfqi->Sid))
            {
                //
                // Allocate space for SID structure.
                //
                m_pSid = (PSID) new BYTE[pfqi->SidLength];

                //
                // Copy SID structure to object.
                //
                if (CopySid(pfqi->SidLength, m_pSid, &pfqi->Sid))
                {
                    //
                    // Initialize user's quota data values.
                    // If error copying SID, don't bother with these.
                    //
                    m_llQuotaUsed      = pfqi->QuotaUsed.QuadPart;
                    m_llQuotaThreshold = pfqi->QuotaThreshold.QuadPart;
                    m_llQuotaLimit     = pfqi->QuotaLimit.QuadPart;
                }
                else
                {
                    //
                    // The only reason CopySid can fail is
                    // STATUS_BUFFER_TOO_SMALL.  Since we allocated the buffer
                    // above, this should never fail.
                    //
                    DBGASSERT((FALSE));
                    hResult = E_UNEXPECTED; // Error copying SID.
                }
            }
            else
            {
                DBGERROR((TEXT("DiskQuotaUser::Initialize - Invalid SID or Bad Sid Length (%d)"), pfqi->SidLength));
                hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
            }
        }
    }
    else
        hResult = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Destroy

    Description: Destroys a user object by deleting its SID buffer and releasing
        its FSObject pointer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID DiskQuotaUser::Destroy(
    VOID
    )
{
    //
    // Delete the SID buffer.
    //
    delete [] m_pSid;
    m_pSid = NULL;

    //
    // Delete the logon name buffer.
    //
    delete[] m_pszLogonName;
    m_pszLogonName = NULL;

    //
    // Delete the display name buffer.
    //
    delete[] m_pszDisplayName;
    m_pszDisplayName = NULL;

    if (NULL != m_pFSObject)
    {
        //
        // Release hold on File System object.
        //
        m_pFSObject->Release();
        m_pFSObject = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::DestroyContainerNameCache

    Description: Destroys the container name cache.  Should only be called
        when there are not more active user objects.  The container name cache
        is a static member of DiskQuotaUser.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::DestroyContainerNameCache(
    VOID
    )
{
    //
    // Remove all container name strings from the cache.  No need to lock
    // the cache object before clearing it.  It will handle the locking
    // and unlocking.
    //
    m_ContainerNameCache.Clear();
}


//
// Return user object's unique ID.
//
STDMETHODIMP
DiskQuotaUser::GetID(
    ULONG *pulID
    )
{
    *pulID = m_ulUniqueId;
    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetAccountStatus

    Description: Retrieves the account name resolution status for the
        user object.

    Arguments:
        pdwAccountStatus - Address of variable to recieve status.  The following
            values (see dskquota.h) can be returned in this variable:

            DISKQUOTA_USER_ACCOUNT_RESOLVED
            DISKQUOTA_USER_ACCOUNT_UNAVAILABLE
            DISKQUOTA_USER_ACCOUNT_DELETED
            DISKQUOTA_USER_ACCOUNT_INVALID
            DISKQUOTA_USER_ACCOUNT_UNKNOWN
            DISKQUOTA_USER_ACCOUNT_UNRESOLVED

    Returns:
        NOERROR       - Success.
        E_INVALIDARG  - pdwAccountStatus arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetAccountStatus(
    LPDWORD pdwAccountStatus
    )
{
    if (NULL == pdwAccountStatus)
        return E_INVALIDARG;

    *pdwAccountStatus = m_dwAccountStatus;

    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetName

    Description: Sets the account names of the user object.
        It is intended that the SidNameResolver object will call this member
        when it has resolved a user's SID into an account name.  This function
        is not included in IDiskQuotaUser.  Therefore, it is not for public
        consumption.

    Arguments:
        pszContainer - Address of buffer containing container name string.

        pszLogonName - Address of buffer containing user's logon name string.

        pszDisplayName - Address of buffer containing user's display name string.

    Returns:
        NOERROR        - Success.
        E_INVALIDARG   - pszName or pszDomain arg is NULL.
        E_OUTOFMEMORY  - Insufficient memory.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/22/96    Added full name string.                              BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
    05/18/97    Removed access token.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::SetName(
    LPCWSTR pszContainer,
    LPCWSTR pszLogonName,
    LPCWSTR pszDisplayName
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pszContainer || NULL == pszLogonName || NULL == pszDisplayName)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        //
        // Delete existing name buffer.
        //
        delete[] m_pszLogonName;
        m_pszLogonName = NULL;
        delete[] m_pszDisplayName;
        m_pszDisplayName = NULL;

        try
        {
            //
            // Save name and full name in user object.
            // Cache container string in container name cache and
            // save cache index in user object.
            //
            INT index     = -1;
            m_pszLogonName   = StringDup(pszLogonName);
            m_pszDisplayName = StringDup(pszDisplayName);
            CacheContainerName(pszContainer, &m_iContainerName);
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetName

    Description: Retrieves the domain and account names from the user object.
        It is intended that the client of the user object will register
        a callback (event sink) with a DiskQuotaControl object.  When the
        resolver has resolved the SID to an account name, the resolver will
        set the user object's name string and the client will be notified.
        The client then calls this method to get the user's name.

    Arguments:
        pszContainerBuffer - Address of destination buffer for container name string.

        cchContainerBuffer - Size of container destination buffer in characters.

        pszLogonNameBuffer - Address of destination buffer for logon name string.

        cchLogonNameBuffer - Size of logon name destination buffer in characters.

        pszDisplayNameBuffer - Address of destination buffer for display name string.

        cchDisplayNameBuffer - Size of display name destination buffer in characters.

    Returns:
        NOERROR                - Success.
        ERROR_LOCK_FAILED (hr) - Failed to lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/11/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    09/22/96    Added full name string.                              BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetName(
    LPWSTR pszContainerBuffer,
    DWORD cchContainerBuffer,
    LPWSTR pszLogonNameBuffer,
    DWORD cchLogonNameBuffer,
    LPWSTR pszDisplayNameBuffer,
    DWORD cchDisplayNameBuffer
    )
{
    HRESULT hResult = NOERROR;
    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != pszContainerBuffer)
        {
            if (-1 != m_iContainerName)
            {
                GetCachedContainerName(m_iContainerName,
                                       pszContainerBuffer,
                                       cchContainerBuffer);
            }
            else
                lstrcpyn(pszContainerBuffer, TEXT(""), cchContainerBuffer);
        }

        if (NULL != pszLogonNameBuffer)
        {
            lstrcpyn(pszLogonNameBuffer,
                     (NULL != m_pszLogonName) ? m_pszLogonName : TEXT(""),
                     cchLogonNameBuffer);
        }

        if (NULL != pszDisplayNameBuffer)
        {
            lstrcpyn(pszDisplayNameBuffer,
                     (NULL != m_pszDisplayName) ? m_pszDisplayName : TEXT(""),
                     cchDisplayNameBuffer);
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetSidLength

    Description: Retrieves the length of the user's SID in bytes.

    Arguments:
        pcbSid - Address of DWORD to accept SID length value.

    Returns:
        NOERROR                - Success.
        E_INVALIDARG           - pcbSid argument is NULL.
        ERROR_INVALID_SID (hr) - Invalid SID.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetSidLength(
    LPDWORD pcbSid
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pcbSid)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != m_pSid && IsValidSid(m_pSid))
        {
            *pcbSid = GetLengthSid(m_pSid);
        }
        else
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);

        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetSid

    Description: Retrieves the user's SID to a caller-provided buffer.
        The caller should call GetSidLength() to obtain the required buffer
        size before calling GetSid().

    Arguments:
        pSid - Address of destination buffer for SID.  This argument type must
            be PBYTE to work with the MIDL compiler.  Since PSID is really just
            LPVOID and since MIDL doesn't like pointers to void, we have to
            use something other than PSID.

        cbSidBuf - Size of destination buffer in bytes.

    Returns:
        NOERROR                        - Success.
        E_INVALIDARG                   - pSID is NULL.
        ERROR_INVALID_SID (hr)         - User's SID is invalid.
        ERROR_INSUFFICIENT_BUFFER (hr) - Insufficient dest buffer size.
        ERROR_LOCK_FAILED (hr)         - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetSid(
    PBYTE pSid,
    DWORD cbSidBuf
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pSid)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (NULL != m_pSid && IsValidSid(m_pSid))
        {
            if (!CopySid(cbSidBuf, (PSID)pSid, m_pSid))
            {
                //
                // The only reason CopySid can fail is STATUS_BUFFER_TOO_SMALL.
                // Force status code to INSUFFICIENT_BUFFER.
                //
                DBGERROR((TEXT("ERROR in DiskQuotaUser::GetSid. CopySid() failed.  Result = 0x%08X."),
                          GetLastError()));
                hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
        {
            DBGERROR((TEXT("ERROR in DiskQuotaUser::GetSid. Invalid SID.")));
            hResult = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;

}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::RefreshCachedInfo

    Description: Refreshes a user object's cached quota information from the
        volume's quota information file.

    Arguments: None.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        E_FAIL                   - Unexpected NTIOAPI error.

        This function can propagate errors from the NTIOAPI system.  A few
        known ones are mapped to HResults in fsobject.cpp (see HResultFromNtStatus).
        All others are mapped to E_FAIL.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/05/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::RefreshCachedInfo(
    VOID
    )
{
    HRESULT hResult   = NOERROR;
    DWORD cbBuffer    = FILE_QUOTA_INFORMATION_MAX_LEN;
    PSIDLIST pSidList = NULL;
    DWORD cbSidList   = 0;
    PSID pSids[]      = { m_pSid, NULL };
    PBYTE pbBuffer    = NULL;

    try
    {
        pbBuffer = new BYTE[cbBuffer];

        //
        // This can throw OutOfMemory.
        //
        hResult = CreateSidList(pSids, 0, &pSidList, &cbSidList);
        if (SUCCEEDED(hResult))
        {
            hResult = m_pFSObject->QueryUserQuotaInformation(
                            pbBuffer,               // Buffer to receive data.
                            cbBuffer,               // Buffer size in bytes.
                            TRUE,                   // Single entry requested.
                            pSidList,               // Sid.
                            cbSidList,              // Length of Sid.
                            NULL,                   // Starting Sid
                            TRUE);                  // Start search at first user.

            if (SUCCEEDED(hResult) || ERROR_NO_MORE_ITEMS == HRESULT_CODE(hResult))
            {
                PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)pbBuffer;

                m_llQuotaUsed      = pfqi->QuotaUsed.QuadPart;
                m_llQuotaThreshold = pfqi->QuotaThreshold.QuadPart;
                m_llQuotaLimit     = pfqi->QuotaLimit.QuadPart;
                m_bNeedCacheUpdate = FALSE;

                //
                // Don't return ERROR_NO_MORE_ITEMS to caller.
                // They won't care.
                //
                hResult = NOERROR;
            }
            delete[] pSidList;
        }
        delete[] pbBuffer;
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
        delete[] pbBuffer;
        delete[] pSidList;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::WriteCachedInfo

    Description: Writes quota information cached in a user object to the
        volume's quota information file.

    Arguments: None.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL                   - Some other NTIOAPI error.
        E_UNEXPECTED             - CopySid failed.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/31/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::WriteCachedInfo(
    VOID
    )
{
    HRESULT hResult = NOERROR;
    BYTE Buffer[FILE_QUOTA_INFORMATION_MAX_LEN];

    PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)Buffer;

    pfqi->NextEntryOffset         = 0;
    pfqi->SidLength               = GetLengthSid(m_pSid);
    pfqi->QuotaUsed.QuadPart      = m_llQuotaUsed;
    pfqi->QuotaLimit.QuadPart     = m_llQuotaLimit;
    pfqi->QuotaThreshold.QuadPart = m_llQuotaThreshold;

    if (CopySid(pfqi->SidLength, &(pfqi->Sid), m_pSid))
        hResult = m_pFSObject->SetUserQuotaInformation(pfqi, sizeof(Buffer));
    else
        hResult = E_UNEXPECTED;

    if (FAILED(hResult))
    {
        //
        // Something failed.
        // Invalidate cached information so next request reads from disk.
        //
        Invalidate();
    }


    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetQuotaInformation

    Description: Retrieves a user's quota limit, threshold and used quota
        values in a single method.  Since the user interface is marshaled
        across thread boundaries, this can be a big performance improvement
        if you want all three values.

    Arguments:
        pbInfo - Address of destination buffer.  Should be sized for structure
            DISKQUOTA_USER_INFORMATION.

        cbInfo - Number of bytes in destination buffer.  Should be
            sizeof(DISKQUOTA_USER_INFORMATION).

    Returns:
        NOERROR                        - Success.
        E_INVALIDARG                   - pbInfo argument is NULL.
        E_OUTOFMEMORY                  - Insufficient memory.
        ERROR_INSUFFICIENT_BUFFER (hr) - Destination buffer is too small.
        ERROR_LOCK_FAILED (hr)         - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/31/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetQuotaInformation(
    LPVOID pbInfo,
    DWORD cbInfo
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pbInfo)
        return E_INVALIDARG;

    try
    {
        if (cbInfo < sizeof(DISKQUOTA_USER_INFORMATION))
        {
            hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if (!DiskQuotaUser::Lock())
            {
                hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
            }
            else
            {
                //
                // Refresh cached info from disk if needed.
                // Can throw OutOfMemory.
                //
                if (m_bNeedCacheUpdate)
                    hResult = RefreshCachedInfo();

                if (SUCCEEDED(hResult))
                {
                    PDISKQUOTA_USER_INFORMATION pui = (PDISKQUOTA_USER_INFORMATION)pbInfo;

                    pui->QuotaUsed      = m_llQuotaUsed;
                    pui->QuotaThreshold = m_llQuotaThreshold;
                    pui->QuotaLimit     = m_llQuotaLimit;
                }
                DiskQuotaUser::ReleaseLock();
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


STDMETHODIMP
DiskQuotaUser::GetQuotaUsedText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaUsed(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}

STDMETHODIMP
DiskQuotaUser::GetQuotaThresholdText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaThreshold(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUser::GetQuotaLimitText(
    LPWSTR pszText,
    DWORD cchText
    )
{
    if (NULL == pszText)
        return E_INVALIDARG;

    LONGLONG llValue;
    HRESULT hr = GetQuotaLimit(&llValue);
    if (SUCCEEDED(hr))
    {
        if (NOLIMIT == llValue)
        {
            LoadString(g_hInstDll, IDS_NO_LIMIT, pszText, cchText);
        }
        else
        {
            XBytes::FormatByteCountForDisplay(llValue, pszText, cchText);
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUser::SetQuotaThreshold(
    LONGLONG llThreshold,
    BOOL bWriteThrough
    )
{
    if (MARK4DEL > llThreshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return SetLargeIntegerQuotaItem(&m_llQuotaThreshold,
                                    llThreshold,
                                    bWriteThrough);
}


STDMETHODIMP
DiskQuotaUser::SetQuotaLimit(
    LONGLONG llLimit,
    BOOL bWriteThrough
    )
{
    if (MARK4DEL > llLimit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return SetLargeIntegerQuotaItem(&m_llQuotaLimit,
                                    llLimit,
                                    bWriteThrough);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetLargeIntegerQuotaItem

    Description: Retrieves a single quota information item (used, limit,
        threshold) for the user.  If the cached data is invalid, fresh data is
        read in from disk.

    Arguments:
        pllItem - Address of cached member item.

        pllValueOut - Address of LONGLONG to receive item's value.

    Returns:
        NOERROR                - Success.
        E_INVALIDARG           - Either pdwLowPart or pdwHighPart arg was NULL.
        E_OUTOFMEMORY          - Insufficient memory.
        E_UNEXPECTED           - Unexpected exception.
        ERROR_LOCK_FAILED (hr) - Couldn't lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/05/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::GetLargeIntegerQuotaItem(
    PLONGLONG pllItem,
    PLONGLONG pllValueOut
    )
{
    HRESULT hResult = NOERROR;

    DBGASSERT((NULL != pllItem));

    if (NULL == pllItem || NULL == pllValueOut)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        if (m_bNeedCacheUpdate)
        try
        {
            hResult = RefreshCachedInfo();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hResult))
        {
            *pllValueOut = *pllItem;
        }
        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetLargeIntegerQuotaItem

    Description: Sets the quota information for a given quota item (limit or
        threshold).  If the bWriteThrough argument is TRUE, the information is
        also written through to the volume's quota file.  Otherwise, it is
        just cached in the user object.

    Arguments:
        pllItem - Address of cached member item.

        llValue - LONGLONG value to assign to member item.

        bWriteThrough - TRUE  = Write data through to disk.
                        FALSE = Only cache data in user object.

    Returns:
        NOERROR                  - Success.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        ERROR_LOCK_FAILED (hr)   - Couldn't lock user object.
        E_FAIL                   - Some other NTIOAPI error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::SetLargeIntegerQuotaItem(
    PLONGLONG pllItem,
    LONGLONG llValue,
    BOOL bWriteThrough)
{
    DBGASSERT((NULL != pllItem));
    HRESULT hResult = NOERROR;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        *pllItem = llValue;
        if (bWriteThrough)
            hResult = WriteCachedInfo();

        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::CacheContainerName

    Description: Class DiskQuotaUser maintains a static member that is
        a cache of account container names.   It is likely that there will be
        few distinct container names in use on a volume.  Therefore, there's
        no need to store a container name for each user object.  We cache the
        names and store only an index into the cache in each user object.

        This method adds a name to the cache and returns the index of the
        name in the cache.  If the name already exists in the cache,
        it is not added.

    Arguments:
        pszContainer - Address of container name string to add to cache.

        pCacheIndex [optional] - Address of integer variable to receive the
            cache index of the container name string.  May be NULL.

    Returns:
        S_OK        - Success.
        S_FALSE     - Name already in cache.
        E_FAIL      - No cache object.

    Exceptions: OutOfMemory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/05/09    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::CacheContainerName(
    LPCTSTR pszContainer,
    INT *pCacheIndex
    )
{
    DBGASSERT((NULL != pszContainer));

    HRESULT hResult  = S_OK;
    INT iCacheIndex  = -1;
    UINT cItems      = 0;

    m_ContainerNameCache.Lock();

    cItems = m_ContainerNameCache.Count();

    for (UINT i = 0; i < cItems; i++)
    {
        //
        // See if the name is already in the cache.
        //
        if (0 == m_ContainerNameCache[i].Compare(pszContainer))
        {
            iCacheIndex = i;
            hResult     = S_FALSE; // Already cached.
            break;
        }
    }

    if (S_OK == hResult)
    {
        //
        // Not in the cache. Add it.
        //
        try
        {
            m_ContainerNameCache.Append(CString(pszContainer));
            iCacheIndex = m_ContainerNameCache.UpperBound();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_ContainerNameCache.ReleaseLock();

    if (NULL != pCacheIndex)
        *pCacheIndex = iCacheIndex;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetCachedContainerName

    Description: Retrieves an account container name string from the
        container name cache.

    Arguments:
        iCacheIndex - User's index in domain name cache.

        pszContainer - Destination buffer to receive container name string.

        cchContainer - Number of characters in destination buffer.

    Returns:
        NOERROR      - Success.
        E_UNEXPECTED - No name at index iCacheIndex.  Returns "" as name.
        E_FAIL       - No domain name cache object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/05/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUser::GetCachedContainerName(
    INT iCacheIndex,
    LPTSTR pszContainer,
    UINT cchContainer
    )
{
    DBGASSERT((NULL != pszContainer));
    DBGASSERT((-1 != iCacheIndex));

    HRESULT hResult  = NOERROR;

    m_ContainerNameCache.Lock();

    DBGASSERT((iCacheIndex < m_ContainerNameCache.Count()));

    lstrcpyn(pszContainer, m_ContainerNameCache[iCacheIndex], cchContainer);

    m_ContainerNameCache.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::Lock

    Description: Call this to obtain an exclusive lock to the user object.
        In actuality, there is only one lock for all user objects so you're
        really getting an exclusive lock to all users.  Since there can be
        a high number of users, it was decided to use a single class-wide
        lock instead of a unique lock for each user object.

    Arguments: None.

    Returns:
        TRUE    = Obtained exclusive lock.
        FALSE   = Couldn't get a lock.  Either mutex hasn't been created or
                  the mutex wait timeout expired, or the wait operation failed.
                  Either way, we couldn't get the lock.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DiskQuotaUser::Lock(
    VOID
    )
{
    BOOL bResult = FALSE;

    if (NULL != DiskQuotaUser::m_hMutex)
    {
        DWORD dwWaitResult = WaitForSingleObject(DiskQuotaUser::m_hMutex,
                                                 DiskQuotaUser::m_dwMutexWaitTimeout);
        bResult = (WAIT_OBJECT_0 == dwWaitResult);
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::ReleaseLock

    Description: Call this to release a lock obtained with DiskQuotaUser::Lock.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::ReleaseLock(
    VOID
    )
{
    if (NULL != DiskQuotaUser::m_hMutex)
    {
        ReleaseMutex(DiskQuotaUser::m_hMutex);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::SetAccountStatus

    Description: Stores the status of the user's account in the user object.
                 User accounts may be "unresolved", "unavailable", "resolved",
                 "deleted", "invalid" or "unknown".
                 These states correspond to the values obtained
                 through LookupAccountSid.

    Arguments:
        dwStatus - DISKQUOTA_USER_ACCOUNT_UNRESOLVED
                   DISKQUOTA_USER_ACCOUNT_UNAVAILABLE
                   DISKQUOTA_USER_ACCOUNT_RESOLVED
                   DISKQUOTA_USER_ACCOUNT_DELETED
                   DISKQUOTA_USER_ACCOUNT_UNKNOWN
                   DISKQUOTA_USER_ACCOUNT_INVALID

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUser::SetAccountStatus(
    DWORD dwStatus
    )
{
    DBGASSERT((DISKQUOTA_USER_ACCOUNT_UNRESOLVED  == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_UNAVAILABLE == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_RESOLVED    == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_DELETED     == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_INVALID     == dwStatus ||
           DISKQUOTA_USER_ACCOUNT_UNKNOWN     == dwStatus));

    m_dwAccountStatus = dwStatus;
}



//
// The following functions implement the DiskQuotaUser "dispatch" object that
// is created to handle OLE automation duties for the DiskQuotaUser object.
// The functions are all fairly basic and require little explanation.
// Therefore, I'll spare you the function headers.  In most cases,
// the property and method functions call directly through to their
// corresponding functions in class DiskQuotaUser.
//
DiskQuotaUserDisp::DiskQuotaUserDisp(
    PDISKQUOTA_USER pUser
    ) : m_cRef(0),
        m_pUser(pUser)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserDisp::DiskQuotaUserDisp")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
    {
        m_pUser->AddRef();
    }
    m_Dispatch.Initialize(static_cast<IDispatch *>(this),
                          LIBID_DiskQuotaTypeLibrary,
                          IID_DIDiskQuotaUser,
                          L"DSKQUOTA.DLL");
}

DiskQuotaUserDisp::~DiskQuotaUserDisp(
    VOID
    )
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserDisp::~DiskQuotaUserDisp")));
    DBGPRINT((DM_USER, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
    {
        m_pUser->Release();
    }
}


STDMETHODIMP
DiskQuotaUserDisp::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_USER, DL_MID, TEXT("DiskQuotaUserDisp::QueryInterface")));
    DBGPRINTIID(DM_USER, DL_MID, riid);

    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid)
    {
        *ppvOut = this;
    }
    else if (IID_IDispatch == riid)
    {
        *ppvOut = static_cast<IDispatch *>(this);
    }
    else if (IID_DIDiskQuotaUser == riid)
    {
        *ppvOut = static_cast<DIDiskQuotaUser *>(this);
    }
    else if (IID_IDiskQuotaUser == riid)
    {
        //
        // Return the quota user's vtable interface.
        // This allows code to "typecast" (COM-style) between
        // the dispatch interface and vtable interface.
        //
        return m_pUser->QueryInterface(riid, ppvOut);
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}

STDMETHODIMP_(ULONG)
DiskQuotaUserDisp::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserDisp::AddRef, 0x%08X  %d -> %d"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


STDMETHODIMP_(ULONG)
DiskQuotaUserDisp::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserDisp::Release, 0x%08X  %d -> %d"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



//
// IDispatch::GetIDsOfNames
//
STDMETHODIMP
DiskQuotaUserDisp::GetIDsOfNames(
    REFIID riid,
    OLECHAR **rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetIDsOfNames")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetIDsOfNames(riid,
                                    rgszNames,
                                    cNames,
                                    lcid,
                                    rgDispId);
}


//
// IDispatch::GetTypeInfo
//
STDMETHODIMP
DiskQuotaUserDisp::GetTypeInfo(
    UINT iTInfo,
    LCID lcid,
    ITypeInfo **ppTypeInfo
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetTypeInfo")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfo(iTInfo, lcid, ppTypeInfo);
}


//
// IDispatch::GetTypeInfoCount
//
STDMETHODIMP
DiskQuotaUserDisp::GetTypeInfoCount(
    UINT *pctinfo
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::GetTypeInfoCount")));
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.GetTypeInfoCount(pctinfo);
}


//
// IDispatch::Invoke
//
STDMETHODIMP
DiskQuotaUserDisp::Invoke(
    DISPID dispIdMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pVarResult,
    EXCEPINFO *pExcepInfo,
    UINT *puArgErr
    )
{
    DBGTRACE((DM_USER, DL_LOW, TEXT("DiskQuotaUserDisp::Invoke")));
    DBGPRINT((DM_USER, DL_LOW, TEXT("DispId = %d"), dispIdMember));
    DBGPRINTIID(DM_USER, DL_LOW, riid);
    //
    // Let our dispatch object handle this.
    //
    return m_Dispatch.Invoke(dispIdMember,
                             riid,
                             lcid,
                             wFlags,
                             pDispParams,
                             pVarResult,
                             pExcepInfo,
                             puArgErr);
}


//
// Return user object's unique ID.
//
STDMETHODIMP
DiskQuotaUserDisp::get_ID(
    long *pID
    )
{
    return m_pUser->GetID((ULONG *)pID);
}


STDMETHODIMP
DiskQuotaUserDisp::get_AccountContainerName(
    BSTR *pContainerName
    )
{
    TCHAR szName[MAX_DOMAIN] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(szName, ARRAYSIZE(szName),
                                  NULL,   0,
                                  NULL,   0);
    if (SUCCEEDED(hr))
    {
        *pContainerName = SysAllocString(szName);
        if (NULL == *pContainerName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_LogonName(
    BSTR *pLogonName
    )
{
    TCHAR szName[MAX_USERNAME] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(NULL,   0,
                                  szName, ARRAYSIZE(szName),
                                  NULL,   0);
    if (SUCCEEDED(hr))
    {
        *pLogonName = SysAllocString(szName);
        if (NULL == *pLogonName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_DisplayName(
    BSTR *pDisplayName
    )
{
    TCHAR szName[MAX_FULL_USERNAME] = { TEXT('\0') };
    HRESULT hr = m_pUser->GetName(NULL,   0,
                                  NULL,   0,
                                  szName, ARRAYSIZE(szName));

    if (SUCCEEDED(hr))
    {
        *pDisplayName = SysAllocString(szName);
        if (NULL == *pDisplayName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaThreshold(
    double *pThreshold
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaThreshold(&llValue);
    if (SUCCEEDED(hr))
        *pThreshold = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::put_QuotaThreshold(
    double Threshold
    )
{
    if (MAXLONGLONG < Threshold)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return m_pUser->SetQuotaThreshold((LONGLONG)Threshold, TRUE);
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaThresholdText(
    BSTR *pThresholdText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaThresholdText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pThresholdText = SysAllocString(szValue);
        if (NULL == *pThresholdText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaLimit(
    double *pQuotaLimit
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaLimit(&llValue);

    if (SUCCEEDED(hr))
        *pQuotaLimit = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::put_QuotaLimit(
    double Limit
    )
{
    if (MAXLONGLONG < Limit)
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return m_pUser->SetQuotaLimit((LONGLONG)Limit, TRUE);
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaLimitText(
    BSTR *pLimitText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaLimitText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pLimitText = SysAllocString(szValue);
        if (NULL == *pLimitText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaUsed(
    double *pUsed
    )
{
    LONGLONG llValue;
    HRESULT hr = m_pUser->GetQuotaUsed(&llValue);
    if (SUCCEEDED(hr))
        *pUsed = (double)llValue;

    return hr;
}


STDMETHODIMP
DiskQuotaUserDisp::get_QuotaUsedText(
    BSTR *pUsedText
    )
{
    TCHAR szValue[40];
    HRESULT hr = m_pUser->GetQuotaUsedText(szValue, ARRAYSIZE(szValue));
    if (SUCCEEDED(hr))
    {
        *pUsedText = SysAllocString(szValue);
        if (NULL == *pUsedText)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDMETHODIMP
DiskQuotaUserDisp::get_AccountStatus(
    AccountStatusConstants *pStatus
    )
{
    DWORD dwStatus;
    HRESULT hr = m_pUser->GetAccountStatus(&dwStatus);
    if (SUCCEEDED(hr))
    {
        *pStatus = (AccountStatusConstants)dwStatus;
    }
    return hr;
}


//
// Methods.
//
STDMETHODIMP
DiskQuotaUserDisp::Invalidate(
    void
    )
{
    return m_pUser->Invalidate();
}




#ifdef NEVER
// ----------------------------------------------------------------------------
// OBSOLETE CODE
// ----------------------------------------------------------------------------
//
// I originally provided the GetSidString code in the IDiskQuotaUser interface.
// It was useful during development but I decided that it would be
// relatively useless to most users of the interface.  If they want to
// format the SID as a string, they can learn about it on MSDN.  That's
// where I got the original code (See in dskquota\common\utils.cpp).
// I've left it here in case a need is ever identified.
//
// [brianau - 08/05/97]
//
///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUser::GetSidString

    Description: Retrieves the account SID from the user object in character
        format.

    Arguments:
        pszBuffer - Address of destination buffer for account SID string.

        cchBuffer - Size of destination buffer in characters.

    Returns:
        NOERROR                        - Success.
        E_INVALIDARG                   - pszBuffer arg is NULL.
        ERROR_INSUFFICIENT_BUFFER (hr) - Caller's buffer is too small.
        ERROR_LOCK_FAILED (hr)         - Failed to lock user object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/23/96    Initial creation.                                    BrianAu
    12/10/96    Added class-scope user lock.                         BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUser::GetSidString(
    LPWSTR pszBuffer,
    DWORD cchBuffer
    )
{
    HRESULT hResult = NOERROR;

    if (NULL == pszBuffer)
        return E_INVALIDARG;

    if (!DiskQuotaUser::Lock())
    {
        hResult = HRESULT_FROM_WIN32(ERROR_LOCK_FAILED);
    }
    else
    {
        DWORD cchSid = cchBuffer;
        if (!SidToString(m_pSid, pszBuffer, &cchSid))
            hResult = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        DiskQuotaUser::ReleaseLock();
    }

    return hResult;
}


#endif // NEVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\userbat.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: userbat.cpp

    Description: Contains member function definitions for class 
        DiskQuotaUserBatch.
        The DiskQuotaUserBatch object represents a batch update mechanism for
        rapid update of multiple-user-object quota information.  This class
        takes advantage of the batching capabilities built into the NTIOAPI.
        A user batch object is obtained through 
        IDiskQuotaControl::CreateUserBatch().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "userbat.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

//
// The NTFS quota write function can only handle a max of 64K of data
// in any one write operation.  IssacHe recommended 60K as a comfortable
// limit.
//
const INT MAX_BATCH_BUFFER_BYTES = (1 << 10) * 60;

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::DiskQuotaUserBatch

    Description: Constructor.

    Arguments: 
        pFSObject - Address of File System object to be utilized by the
            batching operations.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserBatch::DiskQuotaUserBatch(
    FSObject *pFSObject
    ) : m_cRef(0),
        m_pFSObject(pFSObject)
{      
    DBGASSERT((NULL != m_pFSObject));

    m_pFSObject->AddRef();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::~DiskQuotaUserBatch

    Description: Destructor.

    Arguments: Destroys the batch object.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/26/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserBatch::~DiskQuotaUserBatch(
    VOID
    )
{
    Destroy();
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IDiskQuotaUserBatch interface.  Only IID_IUnknown and 
        IID_IDiskQuotaUserBatch are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NOERROR         - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserBatch::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IDiskQuotaUserBatch == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserBatch::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserBatch::AddRef, 0x%08X  %d -> %d\n"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserBatch::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserBatch::Release, 0x%08X  %d -> %d\n"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Destroy

    Description: Destroys the contents of a user batch object and releases
        its FSObject pointer.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DiskQuotaUserBatch::Destroy(VOID)
{
    //
    // Remove and release all user object pointers from the batch list.
    //
    RemoveAll();

    if (NULL != m_pFSObject)
    {
        //
        // Release hold on File System object.
        //
        m_pFSObject->Release();
        m_pFSObject = NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Add

    Description: Adds an IDiskQuotaUser interface pointer to the batch list.

    Arguments:
        pUser - Address of IDiskQuotaUser interface.

    Returns:
        NOERROR         - Success.
        E_INVALIDARG    - pUser arg is NULL. 
        E_OUTOFMEMORY   - Couldn't create new node in batch list.
        E_UNEXPECTED    - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::Add(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = NOERROR;
        
    if (NULL == pUser)
        return E_INVALIDARG;

    try
    {
        m_UserList.Append(pUser);
        //
        // Success.  Increment ref count on object.
        //
        pUser->AddRef();
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::Remove

    Description: Removes a user pointer from the batch queue.  

    Arguments:
        pUser - Address of IDiskQuotaUser interface for the user object to
            be removed.

    Returns:
        S_OK         - Success.
        S_FALSE      - User not found in batch object.
        E_INVALIDARG - pUser argument is NULL.
        E_UNEXPECTED - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUserBatch::Remove(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = S_FALSE;  // Assume user not present.
    PDISKQUOTA_USER pRemoved = NULL;

    if (NULL == pUser)
        return E_INVALIDARG;

    m_UserList.Lock();
    INT iUser = m_UserList.Find(pUser);
    if (-1 != iUser)
    {
        try
        {
            DBGASSERT((NULL != m_UserList[iUser]));
            m_UserList[iUser]->Release();
            m_UserList.Delete(iUser);
            hResult = S_OK;
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_UserList.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::RemoveAll

    Description: Removes all user pointers from the batch
        list and calling Release() through the removed pointer.  

    Arguments: None.

    Returns:
        NOERROR      - Success.
        E_UNEXPECTED - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::RemoveAll(
    VOID
    )
{
    HRESULT hResult = NOERROR;

    m_UserList.Lock();
    INT cUsers = m_UserList.Count();
    for (INT i = 0; i < cUsers; i++)
    {
        try
        {
            DBGASSERT((NULL != m_UserList[i]));
            m_UserList[i]->Release();
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }
    m_UserList.Clear();
    m_UserList.ReleaseLock();

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserBatch::FlushToDisk

    Description: Writes data for all batched user objects to disk in a single
        NTIOAPI call.  This is the real worker function for the batch object.

    Arguments: None.

    Returns:
        NOERROR       - Success.
        E_OUTOFMEMORY - Insufficient memory.
        E_UNEXPECTED  - Unexpected exception.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/06/96    Initial creation.                                    BrianAu
    09/03/96    Add exception handling.                              BrianAu
    02/27/97    Divided NTFS writes into max 60KB pieces.            BrianAu
                The quota code in NTFS couldn't handle larger
                buffers.  It got into an infinite loop condition
                due to filling of the log.
    07/01/97    Replaced use of PointerList with CArray<>.           BrianAu
                Now use indexes instead of iterators.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaUserBatch::FlushToDisk(
    VOID
    )
{
    HRESULT hResult                   = NOERROR;
    PFILE_QUOTA_INFORMATION pUserInfo = NULL;
    PDISKQUOTA_USER pUser             = NULL;
    PBYTE pbBatchBuffer               = NULL;
    DWORD cbMinimumSid = FIELD_OFFSET(SID, SubAuthority) + sizeof(LONG);
    INT iOuter = 0;

    //
    // Do nothing if the batch object is empty.
    //
    if (0 == m_UserList.Count())
        return NOERROR;

    m_UserList.Lock();

    try
    {
        //
        // Process the data in 60K chunks using a nested loop.
        //
        while(iOuter < m_UserList.UpperBound())
        {
            //
            // Clone the outer iterator so we can process the next 60K of data.
            // Need two new iterators.  One for counting the bytes and
            // one for transferring data to the write buffer.  They're very small
            // objects and cheap to create.
            //
            INT iCount    = iOuter;
            INT iTransfer = iOuter;

            DWORD cbBatchBuffer = 0;
            DWORD cItemsThisBatch = 0;

            while(cbBatchBuffer < MAX_BATCH_BUFFER_BYTES &&
                  iCount <= m_UserList.UpperBound())

            {
                DWORD cbSid = 0;
                pUser = m_UserList[iCount++];
                pUser->GetSidLength(&cbSid);

                //
                // Total size required for user records.
                //
                cbBatchBuffer += FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) + cbSid;

                //
                // Ensure it's quad-word aligned.
                //
                if (cbBatchBuffer & 0x00000007)
                    cbBatchBuffer = (cbBatchBuffer & 0xFFFFFFF8) + 8;

                cItemsThisBatch++;
            }

            //
            // Allocate the buffer.
            //
            pbBatchBuffer = new BYTE[cbBatchBuffer];

            PBYTE pbBatchBufferItem = pbBatchBuffer;
            DWORD cbNextEntryOffset = 0;
            //
            // Now fill in the batch transaction buffer with data from 
            // all of the users in the batch list.
            //
            while(0 != cItemsThisBatch-- &&
                  iTransfer <= m_UserList.UpperBound())
            {
                pUser = m_UserList[iTransfer++];
                pUserInfo = (PFILE_QUOTA_INFORMATION)pbBatchBufferItem;

                pUser->GetSidLength(&pUserInfo->SidLength);

                cbNextEntryOffset = FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid) + pUserInfo->SidLength;
                //
                // Ensure quad-word alignment.
                //
                if (cbNextEntryOffset & 0x00000007)
                    cbNextEntryOffset = (cbNextEntryOffset & 0xFFFFFFF8) + 8;

                pUserInfo->NextEntryOffset = cbNextEntryOffset;

                pUser->GetQuotaThreshold(&pUserInfo->QuotaThreshold.QuadPart);
                pUser->GetQuotaLimit(&pUserInfo->QuotaLimit.QuadPart);
                pUser->GetSid((PBYTE)&pUserInfo->Sid, pUserInfo->SidLength);

                //
                // These two don't get set but let's provide a known value anyway.
                //
                pUserInfo->ChangeTime.QuadPart = 0;
                pUserInfo->QuotaUsed.QuadPart  = 0;

                pbBatchBufferItem += cbNextEntryOffset;
            }
            pUserInfo->NextEntryOffset = 0;  // Last entry needs a 0 here.
            //
            // Submit the batch to the NTIOAPI for update.
            //
            hResult = m_pFSObject->SetUserQuotaInformation(pbBatchBuffer, cbBatchBuffer);

            //
            // Delete the data buffer.
            //
            delete[] pbBatchBuffer;
            pbBatchBuffer = NULL;

            //
            // Advance the outer iterator to where the transfer iterator left off.
            //
            iOuter = iTransfer;
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    if (FAILED(hResult))
    {
        //
        // Something failed.  Invalid data cached in user objects.
        // Next request for user data will have to read from disk.
        //
        iOuter = 0;

        while(iOuter <= m_UserList.UpperBound())
        {
            pUser = m_UserList[iOuter++];
            pUser->Invalidate();
        }
    }

    m_UserList.ReleaseLock();

    delete[] pbBatchBuffer;

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\user.h ===
#ifndef _INC_DSKQUOTA_USER_H
#define _INC_DSKQUOTA_USER_H
///////////////////////////////////////////////////////////////////////////////
/*  File: user.h

    Description: Contains declarations for class DiskQuotaUser.  The
        DiskQuotaUser object represents a user's quota information on a
        particular volume.  Per-user quota information is managed through
        the IDiskQuotaUser interface.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/20/96    Added m_dwID member to DiskQuotaUser.                BrianAu
    09/05/96    Added domain name string and cache.                  BrianAu
    08/25/97    Added OLE automation support.                        BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"   // MIDL-generated header (automation).
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class (automation).
#endif


class DiskQuotaUser : public IDiskQuotaUser {
    private:
        LONGLONG      m_llQuotaUsed;
        LONGLONG      m_llQuotaThreshold;
        LONGLONG      m_llQuotaLimit;
        LONG          m_cRef;                 // Ref counter.
        ULONG         m_ulUniqueId;           // Unique object ID.
        PSID          m_pSid;                 // Ptr to user's SID structure.
        LPTSTR        m_pszLogonName;         // "brianau@microsoft.com"
        LPTSTR        m_pszDisplayName;       // "Brian Aust"
        FSObject     *m_pFSObject;            // Ptr to file sys object.
        BOOL          m_bNeedCacheUpdate;     // T = Cached data is invalid.
        INT           m_iContainerName;       // Index into acct container name cache.
        DWORD         m_dwAccountStatus;      // Status of user account.

        static HANDLE m_hMutex;               // For serializing access to users.
        static DWORD  m_dwMutexWaitTimeout;   // How long to wait for mutex.
        static LONG   m_cUsersAlive;          // Count of users currently alive.
        static ULONG  m_ulNextUniqueId;       // Unique ID generator.
        static CArray<CString> m_ContainerNameCache; // Cache container names as they
                                                  // are found.  Don't need to dup
                                                  // names in each user object.
        VOID Destroy(VOID);
        VOID DestroyContainerNameCache(VOID);

        BOOL Lock(VOID);
        VOID ReleaseLock(VOID);

        //
        // Prevent copy construction.
        //
        DiskQuotaUser(const DiskQuotaUser& user);
        void operator = (const DiskQuotaUser& user);

        HRESULT
        GetLargeIntegerQuotaItem(
            PLONGLONG pllItem,
            PLONGLONG pllValueOut);

        HRESULT
        SetLargeIntegerQuotaItem(
            PLONGLONG pllItem,
            LONGLONG llValue,
            BOOL bWriteThrough = TRUE);

        HRESULT
        RefreshCachedInfo(
            VOID);
            
        HRESULT
        WriteCachedInfo(
            VOID);

        HRESULT
        GetCachedContainerName(
            INT iCacheIndex,
            LPTSTR pszContainer,
            UINT cchContainer);

        HRESULT
        CacheContainerName(
            LPCTSTR pszContainer,
            INT *pCacheIndex);
        

    public:
        DiskQuotaUser(FSObject *pFSObject);
        ~DiskQuotaUser(VOID);

        HRESULT 
        Initialize(
            PFILE_QUOTA_INFORMATION pfqi = NULL);

        VOID
        SetAccountStatus(
            DWORD dwStatus);

        STDMETHODIMP
        SetName(
            LPCWSTR pszContainer,
            LPCWSTR pszLogonName,
            LPCWSTR pszDisplayName);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDiskQuotaUser methods.
        //
        STDMETHODIMP
        GetID(
            ULONG *pulID);

        STDMETHODIMP
        GetName(
            LPWSTR pszContainerBuffer,
            DWORD cchContainerBuffer,
            LPWSTR pszLogonNameBuffer,
            DWORD cchLogonNameBuffer,
            LPWSTR pszDisplayNameBuffer,
            DWORD cchDisplayNameBuffer);

        STDMETHODIMP 
        GetSidLength(
            LPDWORD pcbSid);

        STDMETHODIMP 
        GetSid(
            PBYTE pSid, 
            DWORD cbSidBuf);

        STDMETHODIMP 
        GetQuotaThreshold(
            PLONGLONG pllThreshold)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaThreshold, 
                                                pllThreshold);
            }

        STDMETHODIMP 
        GetQuotaThresholdText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        GetQuotaLimit(
            PLONGLONG pllLimit)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaLimit, 
                                                pllLimit);
            }

        STDMETHODIMP 
        GetQuotaLimitText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP 
        GetQuotaUsed(
            PLONGLONG pllUsed)
            {
                return GetLargeIntegerQuotaItem(&m_llQuotaUsed, 
                                                pllUsed);
            }

        STDMETHODIMP 
        GetQuotaUsedText(
            LPWSTR pszText,
            DWORD cchText);

        STDMETHODIMP
        GetQuotaInformation(
            LPVOID pbInfo,
            DWORD cbInfo);

        STDMETHODIMP 
        SetQuotaThreshold(
            LONGLONG llThreshold,
            BOOL bWriteThrough = TRUE);

        STDMETHODIMP 
        SetQuotaLimit(
            LONGLONG llLimit,
            BOOL bWriteThrough = TRUE);

        STDMETHODIMP
        Invalidate(
            VOID) { m_bNeedCacheUpdate = TRUE;
                    return NO_ERROR; }

        STDMETHODIMP
        GetAccountStatus(
            LPDWORD pdwAccountStatus);

};


//
// Proxy class to handle all automation interface duties.
// It implements IDispatch and DIDiskQuotaUser passing any actions
// for real disk quota activity onto a referenced DiskQuotaUser object.
// Instances are created in DiskQuotaUser::QueryInterface in response
// to requests for IDispatch and DIDiskQuotaUser.
//
class DiskQuotaUserDisp : public DIDiskQuotaUser 
{
    public:

        explicit DiskQuotaUserDisp(PDISKQUOTA_USER pUser);
        ~DiskQuotaUserDisp(VOID);

        //
        // IUnknown interface.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IDispatch methods.
        //
        STDMETHODIMP
        GetIDsOfNames(
            REFIID riid,  
            OLECHAR ** rgszNames,  
            UINT cNames,  
            LCID lcid,  
            DISPID *rgDispId);

        STDMETHODIMP
        GetTypeInfo(
            UINT iTInfo,  
            LCID lcid,  
            ITypeInfo **ppTInfo);

        STDMETHODIMP
        GetTypeInfoCount(
            UINT *pctinfo);

        STDMETHODIMP
        Invoke(
            DISPID dispIdMember,  
            REFIID riid,  
            LCID lcid,  
            WORD wFlags,  
            DISPPARAMS *pDispParams,  
            VARIANT *pVarResult,  
            EXCEPINFO *pExcepInfo,  
            UINT *puArgErr);

        STDMETHODIMP
        get_ID(
            long *pID);

        STDMETHODIMP
        get_AccountContainerName(
            BSTR *pContainerName);

        STDMETHODIMP 
        get_DisplayName(
            BSTR *pDisplayName);

        STDMETHODIMP 
        get_LogonName(
            BSTR *pLogonName);

        STDMETHODIMP 
        get_QuotaThreshold(
            double *pThreshold);

        STDMETHODIMP 
        put_QuotaThreshold(
            double Threshold);

        STDMETHODIMP 
        get_QuotaThresholdText(
            BSTR *pThresholdText);

        STDMETHODIMP 
        get_QuotaLimit(
            double *pLimit);

        STDMETHODIMP 
        put_QuotaLimit(
            double Limit);

        STDMETHODIMP 
        get_QuotaLimitText(
            BSTR *pLimitText);

        STDMETHODIMP 
        get_QuotaUsed(
            double *pUsed);

        STDMETHODIMP 
        get_AccountStatus(
            AccountStatusConstants *pStatus);

        STDMETHODIMP 
        get_QuotaUsedText(
            BSTR *pUsedText);

        //
        // Methods.
        //
        STDMETHODIMP 
        Invalidate(void);

    private:
        LONG            m_cRef;
        PDISKQUOTA_USER m_pUser;     // For delegation
        OleAutoDispatch m_Dispatch;  // Automation dispatch object.

        //
        // Prevent copy.
        //
        DiskQuotaUserDisp(const DiskQuotaUserDisp& rhs);
        DiskQuotaUserDisp& operator = (const DiskQuotaUserDisp& rhs);
};


#endif // _INC_DISKQUOTA_USER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\sidname.h ===
#ifndef _INC_DSKQUOTA_SIDNAME_H
#define _INC_DSKQUOTA_SIDNAME_H
///////////////////////////////////////////////////////////////////////////////
/*  File: sidname.h

    Description: Declarations for SID/Name resolver.  See sidname.cpp for
        details of operation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/12/96    Initial creation.                                    BrianAu
    03/18/98    Replaced "domain", "name" and "full name" with       BrianAu
                "container", "logon name" and "display name" to
                better match the actual contents.  This was in 
                reponse to making the quota UI DS-aware.  The 
                "logon name" is now a unique key as it contains
                both account name and domain-like information.
                i.e. "REDMOND\brianau" or "brianau@microsoft.com".
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_SIDCACHE_H
#   include "sidcache.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif

//
// This is a PRIVATE interface.  That's why it's here and not in dskquota.h
//
#undef  INTERFACE
#define INTERFACE ISidNameResolver

DECLARE_INTERFACE_(ISidNameResolver, IUnknown)
{
    //
    // ISidNameResolver methods.
    //
    STDMETHOD(Initialize)(THIS) PURE;
    STDMETHOD(FindUserName)(THIS_ PDISKQUOTA_USER) PURE;
    STDMETHOD(FindUserNameAsync)(THIS_ PDISKQUOTA_USER) PURE;
    STDMETHOD(Shutdown)(THIS_ BOOL) PURE;
    STDMETHOD(PromoteUserToQueueHead)(THIS_ PDISKQUOTA_USER) PURE;
};

typedef ISidNameResolver SID_NAME_RESOLVER, *PSID_NAME_RESOLVER;



class DiskQuotaControl;  // Fwd reference.

class SidNameResolver : public ISidNameResolver
{
    private:
        LONG                      m_cRef;
        DiskQuotaControl&         m_rQuotaController;
        HANDLE                    m_hsemQueueNotEmpty;
        HANDLE                    m_hMutex;
        HANDLE                    m_hResolverThread;
        HANDLE                    m_heventResolverThreadReady;
        DWORD                     m_dwResolverThreadId;
        CQueueAsArray<PDISKQUOTA_USER> m_UserQueue;

        //
        // Prevent copying.
        //
        SidNameResolver(const SidNameResolver& );
        operator = (const SidNameResolver& );

        HRESULT
        ResolveSidToName(PDISKQUOTA_USER pUser);

        static DWORD ThreadProc(LPVOID dwParam);

        HRESULT
        CreateResolverThread(
            PHANDLE phThread,
            LPDWORD pdwThreadId);

        HRESULT
        ThreadOnQueueNotEmpty(VOID);

        HRESULT
        ClearInputQueue(VOID);

        HRESULT
        FindCachedUserName(
            PDISKQUOTA_USER);

        HRESULT
        GetUserSid(PDISKQUOTA_USER pUser, PSID *ppSid);

        HRESULT
        RemoveUserFromResolverQueue(PDISKQUOTA_USER *ppUser);

        HRESULT
        AddUserToResolverQueue(PDISKQUOTA_USER pUser);

        void Lock(void)
            { WaitForSingleObject(m_hMutex, INFINITE); }

        void ReleaseLock(void)
            { ReleaseMutex(m_hMutex); }

    public:
        SidNameResolver(DiskQuotaControl& rQuotaController);
        ~SidNameResolver(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // ISidNameResolver methods.
        //
        STDMETHODIMP
        Initialize(
            VOID);

        STDMETHODIMP
        FindUserName(
            PDISKQUOTA_USER);

        STDMETHODIMP
        FindUserNameAsync(
            PDISKQUOTA_USER);

        STDMETHODIMP
        Shutdown(
            BOOL bWait);

        STDMETHODIMP
        PromoteUserToQueueHead(
            PDISKQUOTA_USER);
};


#endif // _INC_DSKQUOTA_SIDNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\alloc.cpp ===
#include "pch.h"
#pragma hdrstop

#include "alloc.h"
#include "except.h"


void * __cdecl operator new(
    size_t size
    )
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}

void* __cdecl operator new[] (size_t size)
{
    void *pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL == pv)
        throw CAllocException();

    return pv;
}


void __cdecl operator delete(
    void *ptr
    )
{
    if (NULL != ptr)
        LocalFree(ptr);
}


void __cdecl operator delete[] (void* ptr)
{
    if (NULL != ptr)
        LocalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\userenum.h ===
#ifndef _INC_DSKQUOTA_USERENUM_H
#define _INC_DSKQUOTA_USERENUM_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userenum.h

    Description: Contains declaration for class DiskQuotaUserEnum.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_FSOBJECT_H
#   include "fsobject.h"
#endif
#ifndef _INC_DSKQUOTA_SIDNAME_H
#   include "sidname.h"
#endif
#ifndef _INC_DSKQUOTA_DISPATCH_H
#   include "dispatch.h"   // MIDL-generated header.
#endif
#ifndef _INC_DSKQUOTA_OADISP_H
#   include "oadisp.h"     // OleAutoDispatch class.
#endif


class DiskQuotaUserEnum : public IEnumDiskQuotaUsers {

    private:
        LONG     m_cRef;            // Object Ref counter.
        LPBYTE   m_pbBuffer;        // For reading disk info.
        LPBYTE   m_pbCurrent;       // Pointer to "current" rec in cache.
        DWORD    m_cbBuffer;        // Size of buffer in bytes.
        PSIDLIST m_pSidList;        // Optional SidList filter.
        BOOL     m_bEOF;            // End of quota info file reached?
        DWORD    m_cbSidList;       // Sid list length in bytes.
        BOOL     m_bSingleUser;     // Single-user enumeration?
        BOOL     m_bInitialized;    // Initialize() already called?
        BOOL     m_bRestartScan;    // Restart NTFS quota file scan?
        DWORD    m_fNameResolution; // None, sync, async
        FSObject *m_pFSObject;      // Pointer to file system object.
        PDISKQUOTA_CONTROL m_pQuotaController; // Ptr to quota controller.
        PSID_NAME_RESOLVER m_pSidNameResolver; // For getting SID account names.

        HRESULT 
        QueryQuotaInformation(
            BOOL bReturnSingleEntry = FALSE,
            PVOID pSidList = NULL,
            ULONG cbSidList = 0,
            PSID pStartSid = NULL,
            BOOL bRestartScan = FALSE);

        HRESULT 
        CreateUserObject(
            PFILE_QUOTA_INFORMATION pfqi, 
            PDISKQUOTA_USER *ppOut);

        HRESULT 
        GetNextUser(
            PDISKQUOTA_USER *ppOut);

        HRESULT
        InitializeSidList(
            PSIDLIST pSidList,
            DWORD cbSidList);

        HRESULT
        InitializeSidList(
            PSID *rgpSids,
            DWORD cpSids);

        //
        // Prevent copy construction.
        //
        DiskQuotaUserEnum(const DiskQuotaUserEnum& UserEnum);
        void operator = (const DiskQuotaUserEnum& UserEnum);

    public:
        DiskQuotaUserEnum(
            PDISKQUOTA_CONTROL pQuotaController,
            PSID_NAME_RESOLVER pSidNameResolver,
            FSObject *pFSObject);

        ~DiskQuotaUserEnum(VOID);

        HRESULT 
        Initialize(
            DWORD fNameResolution, 
            DWORD cbBuffer = 2048, 
            PSID *rgpSids = NULL,
            DWORD cpSids = 0);

        HRESULT 
        Initialize(
            const DiskQuotaUserEnum& UserEnum);

        STDMETHODIMP
        SetNameResolution(
            DWORD fNameResolution);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumDiskQuotaUsers methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            PDISKQUOTA_USER *, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            PENUM_DISKQUOTA_USERS *);
};

//
// Enumerator for VB's "for each" construct.
//
class DiskQuotaUserCollection : public IEnumVARIANT
{
    public:
        DiskQuotaUserCollection(PDISKQUOTA_CONTROL pController,
                                DWORD fNameResolution);

        ~DiskQuotaUserCollection(VOID);

        HRESULT Initialize(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumVARIANT Methods.
        //
        STDMETHODIMP
        Next(
            DWORD cUsers,
            VARIANT *rgvar,
            DWORD *pcUsersFetched);

        STDMETHODIMP
        Skip(
            DWORD cUsers);

        STDMETHODIMP
        Reset(
            void);

        STDMETHODIMP
        Clone(
            IEnumVARIANT **ppEnum);

    private:
        LONG                  m_cRef;
        PDISKQUOTA_CONTROL    m_pController;
        PENUM_DISKQUOTA_USERS m_pEnum;
        DWORD                 m_fNameResolution;
};


#endif // _INC_DSKQUOTA_USERENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\details.h ===
#ifndef _INC_DSKQUOTA_DETAILS_H
#define _INC_DSKQUOTA_DETAILS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: details.h

    Description: Declaration for class DetailsView.
        This is a complex class but don't be intimidated by it.
        Much of the functionality has been layered in private subclasses
        so that the scope of any individual piece is minimized.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/06/96    Removed INLINE from message handler methods.         BrianAu
                It's just too hard to debug when they're inline.
    05/28/97    Major changes.                                       BrianAu
                - Added "User Finder".
                - Added promotion of selected item to front of
                  name resolution queue.
                - Improved name resolution status reporting through
                  listview.
                - Moved drag/drop and report generation code
                  from dragdrop.cpp and reptgen.cpp into the
                  DetailsView class.  DetailsView now implements
                  IDataObject, IDropSource and IDropTarget instead
                  of deferring implementation to secondary objects.
                  dragdrop.cpp and reptgen.cpp have been dropped
                  from the project.
                - Added support for CF_HDROP and private import/
                  export clipboard formats.
                - Added import/export functionality.
    07/28/97    Removed export support for CF_HDROP.  Replaced       BrianAu
                with FileContents and FileGroupDescriptor.  Import
                from CF_HDROP is still supported.
                Added Import Source object hierarchy.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_CONTROL_H
#   include "control.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_FORMAT_H
#   include "format.h"
#endif
#ifndef _INC_DSKQUOTA_PROGRESS_H
#   include "progress.h"
#endif

//
// Custom messages for this implementation.
//
#define WM_MAINWINDOW_CREATED         (WM_USER + 1)
#define WM_ADD_USER_TO_DETAILS_VIEW   (WM_USER + 2)
#define WM_DEL_USER_FROM_DETAILS_VIEW (WM_USER + 3)


//
// Structure containing column definition data for the listview.
//
struct DV_COLDATA
{
    int fmt;
    int cx;
    DWORD idMsgText;
    int iColId;
};


//
// Listview report item structure.
// Used for obtaining text/numeric data for a given item in the listview
// for purposes of generating a drag-drop data source.
//
typedef struct
{
    DWORD  fType;
    LPTSTR pszText;
    UINT   cchMaxText;
    DWORD  dwValue;
    double dblValue;
} LV_REPORT_ITEM, *PLV_REPORT_ITEM;

//
// Listview Report Item (LVRI) type constants (fType)
// These indicate what type of data is requested for a LV_REPORT_ITEM and
// also what type of data is provided in LV_REPORT_ITEM.  A caller of
// DetailsView::GetReportItem provides an LV_REPORT_ITEM that acts as the
// communication mechanism between the caller and the DetailsView.  The
// caller fills in the fType member indicating what format of information
// is desired for that row/col item.  The request may be any one of the
// following constants:
//
//      LVRI_TEXT   = Would like data in text format if possible.
//      LVRI_INT    = Would like data in integer format if possible.
//      LVRI_REAL   = Would like data in floating point format if possible.
//      LVRI_NUMBER = Would like data in either INT or REAL format if possible.
//
// This value in fType is merely a hint.  If the data can't be provided in the
// requested format, the next best format is supplied.  Upon return, the fType
// flag may be modified to indicate the actual format of the data returned.
// This value may be either LVRI_TEXT, LVRI_INT or LVRI_REAL.  LVRI_NUMBER is
// only used for hinting by the caller.
//
const DWORD LVRI_TEXT   = 0x00000001;
const DWORD LVRI_INT    = 0x00000002;
const DWORD LVRI_REAL   = 0x00000004;
const DWORD LVRI_NUMBER = (LVRI_INT | LVRI_REAL);

//
// Structure of "ListViewState" information stored in registry per-user.
// Note that we include the structure size and the screen width/height
// to validate the information when we read it from the registry.  If the
// structure size has changed, we don't trust the data and use defaults.
// If the screen size has changed, we use defaults.
//
//
//
// WARNING: I really don't like this but...
//          The size of the rgcxCol[] member must be at least as large
//          as the value of DetailsView::idCol_Last.  Because of the
//          order dependencies of the LV_STATE_INFO and DetailsView
//          structures, I can't use idCol_Last in this declaration.
//          If you have to add a new column and change the value of
//          idCol_Last, make sure the size of rgcxCol[] is adjusted
//          appropriately.  Also adjust rgColIndices[].
//
typedef struct
{
    WORD cb;                   // Count of bytes in structure.
    WORD wVersion;             // Version of state info (for upgrades).
    LONG cxScreen;             // Screen width.
    LONG cyScreen;             // Screen height.
    LONG cx;                   // Width of window (pixels).
    LONG cy;                   // Height of window (pixels).
    WORD fToolBar       :  1;  // Toolbar visible?
    WORD fStatusBar     :  1;  // Status bar visible?
    WORD fShowFolder    :  1;  // Folder column visible?
    WORD iLastColSorted :  4;  // Current sort column.
    WORD fSortDirection :  1;  // 0 = Ascending, 1 = Descending.
    WORD fReserved      :  8;  // Unused bits.
    INT  rgcxCol[8];           // Width of each column (pixels).
    INT  rgColIndices[8];      // Order of subitems in listview.

} LV_STATE_INFO, *PLV_STATE_INFO;

//
// Increment this if you make a change that causes problems with
// state info saved for existing users.  It will cause us to invalidate
// any existing state information and to use defaults.  It may cancel
// any user's existing preferences but at least the view will look OK.
//
const WORD wLV_STATE_INFO_VERSION = 3;

//
// This class maps our column ids (idCol_XXXX) to a listview column
// index (SubItem).
//
class ColumnMap
{
    private:
        INT *m_pMap;
        UINT m_cMapSize;

        //
        // Prevent copying.
        //
        ColumnMap(const ColumnMap&);
        void operator = (const ColumnMap&);

    public:
        ColumnMap(UINT cMapSize);
        ~ColumnMap(VOID);

        INT SubItemToId(INT iSubItem) const;
        INT IdToSubItem(INT iColId) const;
        VOID RemoveId(INT iSubItem);
        VOID InsertId(INT iSubItem, INT iColId);
};


class DetailsView : public IDiskQuotaEvents,
                    public IDropSource,
                    public IDropTarget,
                    public IDataObject
{
    private:
        //
        // DetailsView::Finder ------------------------------------------------
        //
        //
        // This class implements the "find a user" feature.
        // 1. "Attaches" to the "find" combo box in the toolbar by subclassing
        //     that combo box window.
        // 2. Invokes the "Find User" dialog on command.
        // 3. Repositions the listview highlight bar on a user if found.
        // 4. Maintains an MRU list for populating the toolbar and dialog
        //    combo boxes.
        //
        class Finder
        {
            public:
                Finder(DetailsView& DetailsView, INT cMaxMru);
                VOID ConnectToolbarCombo(HWND hwndToolbarCombo);
                VOID InvokeFindDialog(HWND hwndParent);

                static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
                static LRESULT CALLBACK ToolbarComboSubClassWndProc(HWND, UINT, WPARAM, LPARAM);

            private:
                HWND m_hwndToolbarCombo;    // Combo box in toolbar.
                INT  m_cMaxComboEntries;    // Max entries allowed in combo MRU.
                DetailsView& m_DetailsView; // Reference to associated details view.
                WNDPROC m_pfnOldToolbarComboWndProc; // Saved wnd proc address.

                VOID AddNameToCombo(HWND hwndCombo, LPCTSTR pszName, INT cMaxEntries);
                BOOL UserNameEntered(HWND hwndCombo);
                VOID FillDialogCombo(HWND hwndComboSrc, HWND hwndComboDest);

                //
                // Prevent copy.
                //
                Finder(const Finder& rhs);
                Finder& operator = (const Finder& rhs);
        };

        //
        // DetailsView::Importer ----------------------------------------------
        //
        class Importer
        {
            public:
                Importer(DetailsView& DV);
                ~Importer(VOID);

                HRESULT Import(IDataObject *pIDataObject);
                HRESULT Import(const FORMATETC& fmt, const STGMEDIUM& medium);
                HRESULT Import(LPCTSTR pszFilePath);
                HRESULT Import(HDROP hDrop);

            private:
                //
                // DetailsView::Importer::AnySource ---------------------------
                //
                // This small hierarchy of "Source" classes is here to insulate
                // the import process from the import source.  There are two
                // basic forms of import source data; OLE stream and memory-
                // mapped file.  So that we only have one function that actually
                // contains the import logic, this layer of abstraction insulates
                // that import function from any differences between streams
                // and simple memory blocks.
                // Instead of calling Import(pStream) or Import(pbBlock), a
                // client uses Import(Source(pIStream)) or Import(Source(pbBlock)).
                // The Source object uses the virtual constructor technique to
                // create the correct object for the input source.  Each
                // descendant of AnySource implements the single Read() function
                // to read data from it's specific source.
                //
                class AnySource
                {
                    public:
                        AnySource(VOID) { }
                        virtual ~AnySource(VOID) { }
                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead) = 0;

                    private:
                        //
                        // Prevent copy.
                        //
                        AnySource(const AnySource& rhs);
                        AnySource& operator = (const AnySource& rhs);
                };

                //
                // DetailsView::Importer::StreamSource ------------------------
                //
                class StreamSource : public AnySource
                {
                    public:
                        StreamSource(IStream *pStm);
                        virtual ~StreamSource(VOID);

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        IStream *m_pStm;

                        //
                        // Prevent copy.
                        //
                        StreamSource(const StreamSource& rhs);
                        StreamSource& operator = (const StreamSource& rhs);
                };

                //
                // DetailsView::Importer::MemorySource ------------------------
                //
                class MemorySource : public AnySource
                {
                    public:
                        MemorySource(LPBYTE pb, ULONG cbMax);
                        virtual ~MemorySource(VOID) { };

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        LPBYTE m_pb;
                        ULONG  m_cbMax;

                        //
                        // Prevent copy.
                        //
                        MemorySource(const MemorySource& rhs);
                        MemorySource& operator = (const MemorySource& rhs);
                };

                //
                // DetailsView::Importer::Source ------------------------------
                //
                class Source
                {
                    public:
                        Source(IStream *pStm);
                        Source(LPBYTE pb, ULONG cbMax);

                        virtual ~Source(VOID);

                        virtual HRESULT Read(LPVOID pvOut, ULONG cb, ULONG *pcbRead);

                    private:
                        AnySource *m_pTheSource;

                        //
                        // Prevent copy.
                        //
                        Source(const Source& rhs);
                        Source& operator = (const Source& rhs);
                };


                //
                // These two import functions are the real workers.
                // All other import functions eventually end up at
                // Import(Source& ) which calls Import(pbSid, Threshold, Limit)
                // to import each user record.
                //
                HRESULT Import(Source& source);
                HRESULT Import(LPBYTE pbSid, LONGLONG llQuotaThreshold,
                                             LONGLONG llQuotaLimit);

                VOID Destroy(VOID);
                HWND GetTopmostWindow(VOID);

                DetailsView&   m_DV;
                BOOL           m_bUserCancelled;   // User cancelled import.
                BOOL           m_bPromptOnReplace; // Prompt user when replacing record?
                ProgressDialog m_dlgProgress;      // Progress dialog.
                HWND           m_hwndParent;       // Parent HWND for any UI elements.
                INT            m_cImported;        // Number of records imported.

                //
                // Prevent copy.
                //
                Importer(const Importer& rhs);
                Importer& operator = (const Importer& rhs);
        };

        //
        // DetailsView::DataObject --------------------------------------------
        //
        class DataObject
        {
            public:
                DataObject(DetailsView& DV);
                ~DataObject(VOID);

                HRESULT IsFormatSupported(FORMATETC *pFormatEtc);
                HRESULT RenderData(FORMATETC *pFormatEtc, STGMEDIUM *pMedium);

                static VOID SetFormatEtc(FORMATETC& fe,
                                         CLIPFORMAT cfFormat,
                                         DWORD tymed,
                                         DWORD dwAspect = DVASPECT_CONTENT,
                                         DVTARGETDEVICE *ptd = NULL,
                                         LONG lindex = -1);

                static LPSTR WideToAnsi(LPCWSTR pszTextW);

                static const INT   CF_FORMATS_SUPPORTED;
                static LPCWSTR     SZ_EXPORT_STREAM_NAME;
                static LPCTSTR     SZ_EXPORT_CF_NAME;
                static const DWORD EXPORT_STREAM_VERSION;

                LPFORMATETC  m_rgFormats;            // Array of supported formats.
                DWORD        m_cFormats;             // Number of supported formats.
                static CLIPFORMAT m_CF_Csv;                // Comma-separated fields format.
                static CLIPFORMAT m_CF_RichText;           // RTF format.
                static CLIPFORMAT m_CF_NtDiskQuotaExport;  // Internal fmt for import/export.
                static CLIPFORMAT m_CF_FileGroupDescriptor;// Used by shell for drop to folder.
                static CLIPFORMAT m_CF_FileContents;       // Used by shell for drop to folder.

            private:
                //
                // DetailsView::DataObject::Renderer --------------------------
                //
                class Renderer
                {
                    protected:
                        //
                        // DetailsView::DataObject::Renderer::Stream ----------
                        //
                        class Stream
                        {
                            private:
                                IStream *m_pStm;

#ifdef CLIPBOARD_DEBUG_OUTPUT

                                IStorage *m_pStgDbgOut; // For debugging clipboard output.
                                IStream  *m_pStmDbgOut; // For debugging clipboard output.

#endif  // CLIPBOARD_DEBUG_OUTPUT
                                //
                                // Prevent copy.
                                //
                                Stream(const Stream& rhs);
                                Stream& operator = (const Stream& rhs);

                            public:
                                Stream(IStream *pStm = NULL);
                                ~Stream(VOID);

                                VOID SetStream(IStream *pStm);
                                IStream *GetStream(VOID)
                                    { return m_pStm; }

                                VOID Write(LPBYTE pbData, UINT cbData);
                                VOID Write(LPCSTR pszTextA);
                                VOID Write(LPCWSTR pszTextW);
                                VOID Write(BYTE bData);
                                VOID Write(CHAR chDataA);
                                VOID Write(WCHAR chDataW);
                                VOID Write(DWORD dwData);
                                VOID Write(double dblData);
                        };


                        DetailsView& m_DV;   // Details view is source of data.
                        Stream       m_Stm;  // Stream on which report is writtn.

                        virtual VOID Begin(INT cRows, INT cCols) { }
                        virtual VOID AddTitle(LPCWSTR pszTitleW) { }
                        virtual VOID BeginHeaders(VOID) { }
                        virtual VOID AddHeader(LPCWSTR pszHeaderW) { }
                        virtual VOID AddHeaderSep(VOID) { }
                        virtual VOID EndHeaders(VOID) { }
                        virtual VOID BeginRow(VOID) { }
                        virtual VOID AddRowColData(INT iRow, INT idCol) { }
                        virtual VOID AddRowColSep(VOID) { }
                        virtual VOID EndRow(VOID) { }
                        virtual VOID End(VOID) { }

                        //
                        // Prevent copy.
                        //
                        Renderer(const Renderer& rhs);
                        Renderer& operator = (const Renderer& rhs);


                    public:
                        Renderer(DetailsView& DV)
                            : m_DV(DV) { }

                        virtual ~Renderer(VOID) { }

                        virtual VOID Render(IStream *pStm);
                };

                //
                // DetailsView::DataObject::Renderer_UNICODETEXT --------------
                //
                class Renderer_UNICODETEXT : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_UNICODETEXT(const Renderer_UNICODETEXT& rhs);
                        Renderer_UNICODETEXT& operator = (const Renderer_UNICODETEXT& rhs);

                    protected:
                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW)
                            { m_Stm.Write(pszHeaderW); }

                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write(L'\t'); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write(L'\r'); m_Stm.Write(L'\n'); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write(L'\t'); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write(L'\r'); m_Stm.Write(L'\n'); }

                    public:
                        Renderer_UNICODETEXT(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_UNICODETEXT(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_TEXT ---------------------
                //
                class Renderer_TEXT : public Renderer_UNICODETEXT
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_TEXT(const Renderer_TEXT& rhs);
                        Renderer_TEXT& operator = (const Renderer_TEXT& rhs);

                    protected:
                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW);

                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write('\t'); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write('\r'); m_Stm.Write('\n'); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write('\t'); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write('\r'); m_Stm.Write('\n'); }

                    public:
                        Renderer_TEXT(DetailsView& DV)
                            : Renderer_UNICODETEXT(DV) { }

                        virtual ~Renderer_TEXT(VOID) { }
                };


                //
                // DetailsView::DataObject::Renderer_Csv ----------------------
                //
                class Renderer_Csv : public Renderer_TEXT
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_Csv(const Renderer_Csv& rhs);
                        Renderer_Csv& operator = (const Renderer_Csv& rhs);

                    protected:
                        virtual VOID AddHeaderSep(VOID)
                            { m_Stm.Write(','); }

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write(','); }

                    public:
                        Renderer_Csv(DetailsView& DV)
                            : Renderer_TEXT(DV) { }

                        virtual ~Renderer_Csv(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_RTF ----------------------
                //
                class Renderer_RTF : public Renderer
                {
                    private:
                        INT m_cCols;

                        LPSTR DoubleBackslashes(LPSTR pszText);

                        //
                        // Prevent copy.
                        //
                        Renderer_RTF(const Renderer_RTF& rhs);
                        Renderer_RTF& operator = (const Renderer_RTF& rhs);

                    protected:
                        virtual VOID Begin(INT cRows, INT cCols);

                        virtual VOID AddTitle(LPCWSTR pszTitleW);

                        virtual VOID BeginHeaders(VOID);

                        virtual VOID AddHeader(LPCWSTR pszHeaderW);

                        virtual VOID AddHeaderSep(VOID)
                            { AddRowColSep(); }

                        virtual VOID EndHeaders(VOID)
                            { m_Stm.Write("\\row "); }

                        virtual VOID BeginRow(VOID)
                            { BeginHeaderOrRow();
                              AddCellDefs(); }

                        virtual VOID AddRowColData(INT iRow, INT idCol);

                        virtual VOID AddRowColSep(VOID)
                            { m_Stm.Write("\\cell "); }

                        virtual VOID EndRow(VOID)
                            { m_Stm.Write("\\row "); }

                        virtual VOID End(VOID)
                            { m_Stm.Write(" \\pard \\widctlpar \\par }"); }

                        virtual VOID BeginHeaderOrRow(VOID);

                        virtual VOID AddCellDefs(VOID);


                    public:
                        Renderer_RTF(DetailsView& DV)
                            : Renderer(DV),
                              m_cCols(0) { }

                        virtual ~Renderer_RTF(VOID) { }
                };


                //
                // DetailsView::DataObject::Renderer_Export -------------------
                //
                class Renderer_Export : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_Export(const Renderer_Export& rhs);
                        Renderer_Export& operator = (const Renderer_Export& rhs);

                    protected:
                        virtual VOID Render(IStream *pStm);

                        virtual VOID Begin(INT cRows, INT cCols);

                        virtual VOID AddBinaryRecord(INT iRow);

                        virtual VOID End(VOID) { }

                    public:
                        Renderer_Export(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_Export(VOID) { }
                };

                //
                // DetailsView::DataObject::Renderer_FileGroupDescriptor ------
                //
                class Renderer_FileGroupDescriptor : public Renderer
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_FileGroupDescriptor(const Renderer_FileGroupDescriptor& rhs);
                        Renderer_FileGroupDescriptor& operator = (const Renderer_FileGroupDescriptor& rhs);

                    protected:
                        virtual VOID Begin(INT cRows, INT cCols);

                    public:
                        Renderer_FileGroupDescriptor(DetailsView& DV)
                            : Renderer(DV) { }

                        virtual ~Renderer_FileGroupDescriptor(VOID) { };
                };


                //
                // DetailsView::DataObject::Renderer_FileContents -------------
                //
                class Renderer_FileContents : public Renderer_Export
                {
                    private:
                        //
                        // Prevent copy.
                        //
                        Renderer_FileContents(const Renderer_FileContents& rhs);
                        Renderer_FileContents& operator = (const Renderer_FileContents& rhs);

                    protected:

                    public:
                        Renderer_FileContents(DetailsView& DV)
                            : Renderer_Export(DV) { }

                        virtual ~Renderer_FileContents(VOID) { };
                };

                //
                // DetailsView::DataObject private member variables.
                //
                IStorage    *m_pStg;                 // Storage pointer.
                IStream     *m_pStm;                 // Stream pointer.
                DetailsView& m_DV;

                //
                // Private functions to help with the rendering process.
                //
                HRESULT CreateRenderStream(DWORD tymed, IStream **ppStm);
                HRESULT RenderData(IStream *pStm, CLIPFORMAT cf);

                //
                // Prevent copy.
                //
                DataObject(const DataObject& rhs);
                DataObject& operator = (const DataObject& rhs);
        };

        //
        // DetailsView::DropSource --------------------------------------------
        //
        class DropSource
        {
            public:
                DropSource(DWORD grfKeyState)
                    : m_grfKeyState(grfKeyState) { }

                ~DropSource(VOID) { }
                DWORD m_grfKeyState;  // "Key" used to start drag/drop.

            private:

                //
                // Prevent copying.
                //
                DropSource(const DropSource&);
                void operator = (const DropSource&);
        };

        //
        // DetailsView::DropTarget --------------------------------------------
        //
        class DropTarget
        {
            public:
                DropTarget(DWORD grfKeyState)
                    : m_grfKeyState(grfKeyState),
                      m_pIDataObject(NULL) { }

                ~DropTarget(VOID) { };

                DWORD m_grfKeyState;  // "Key" used to start drag/drop.
                IDataObject *m_pIDataObject; // Ptr received through DragEnter.

            private:
                //
                // Prevent copying.
                //
                DropTarget(const DropTarget&);
                void operator = (const DropTarget&);
        };


        LONG               m_cRef;
        PointerList        m_UserList;         // List of user objects.
        HWND               m_hwndMain;         // Main window.
        HWND               m_hwndListView;     // Listview window.
        HWND               m_hwndStatusBar;    // Status bar.
        HWND               m_hwndToolBar;      // Tool bar.
        HWND               m_hwndToolbarCombo; // "Find User" combo box.
        HWND               m_hwndListViewToolTip;   // Tool tip window.
        HWND               m_hwndHeader;       // Listview header control.
        HACCEL             m_hKbdAccel;        // Accelerator table.
        WNDPROC            m_lpfnLVWndProc;    // We subclass the LV control.
        PDISKQUOTA_CONTROL m_pQuotaControl;    // Ptr to quota controller.
        Finder            *m_pUserFinder;      // For locating users in listview.
        UndoList          *m_pUndoList;        // For "undoing" mods and deletes.
        ColumnMap          m_ColMap;           // ColId to iSubItem map.
        DropSource         m_DropSource;
        DropTarget         m_DropTarget;
        DataObject        *m_pDataObject;
        CVolumeID          m_idVolume;
        CString            m_strVolumeDisplayName;
        CString            m_strAccountUnresolved;
        CString            m_strAccountUnavailable;
        CString            m_strAccountDeleted;
        CString            m_strAccountUnknown;
        CString            m_strAccountInvalid;
        CString            m_strNoLimit;
        CString            m_strNotApplicable;
        CString            m_strStatusOK;
        CString            m_strStatusWarning;
        CString            m_strStatusOverlimit;
        CString            m_strDispText;
        LPDATAOBJECT       m_pIDataObjectOnClipboard;
        POINT              m_ptMouse;          // For hit-testing tooltips.
        DWORD              m_dwEventCookie;    // Event sink cookie.
        INT                m_iLastItemHit;     // Last item mouse was over.
        INT                m_iLastColSorted;
        DWORD              m_fSortDirection;   // 0 = Ascending, 1 = Descending
        CRITICAL_SECTION   m_csAsyncUpdate;
        LV_STATE_INFO      m_lvsi;             // Persistent lv state info.
        BOOL               m_bMenuActive;      // Is a menu active?
        BOOL               m_bWaitCursor;      // Show wait cursor?
        BOOL               m_bStopLoadingObjects;
        BOOL               m_bDestroyingView;
        static const INT   MAX_FINDMRU_ENTRIES;
        static const INT   CX_TOOLBAR_COMBO;
        static const INT   CY_TOOLBAR_COMBO;


        HRESULT InitializeStaticStrings(VOID);
        HRESULT CreateMainWindow(VOID);
        HRESULT CreateListView(VOID);
        HRESULT CreateStatusBar(VOID);
        HRESULT CreateToolBar(VOID);
        HRESULT CreateListViewToolTip(VOID);
        HRESULT AddColumn(INT iColumn, const DV_COLDATA& ColDes);
        HRESULT RemoveColumn(INT iColumn);
        HRESULT AddImages(VOID);
        HRESULT LoadObjects(VOID);
        HRESULT ReleaseObjects(VOID);
        LRESULT SortObjects(DWORD idColumn, DWORD dwDirection);
        LRESULT Refresh(bool bInvalidateCache = false);
        LRESULT SelectAllItems(VOID);
        LRESULT InvertSelectedItems(VOID);
        LRESULT ShowItemCountInStatusBar(VOID);
        LRESULT ShowMenuTextInStatusBar(DWORD idMenuOption);
        VOID SaveViewStateToRegistry(VOID);
        VOID EnableMenuItem_ArrangeByFolder(BOOL bEnable);
        VOID EnableMenuItem_Undo(BOOL bEnable);
        VOID SetWaitCursor(VOID);
        VOID ClearWaitCursor(VOID);
        VOID Redraw(VOID)
            {
                RedrawWindow(m_hwndMain, NULL, NULL,
                             RDW_ERASE |
                             RDW_FRAME |
                             RDW_INVALIDATE |
                             RDW_ALLCHILDREN |
                             RDW_UPDATENOW);
            }

        VOID RedrawItems(VOID)
        {
            ListView_RedrawItems(m_hwndListView, -1, -1);
            UpdateWindow(m_hwndListView);
        }

        BOOL AddUser(PDISKQUOTA_USER pUser);
        INT  GetUserQuotaState(PDISKQUOTA_USER pUser);
        VOID RegisterAsDropTarget(BOOL bActive);
        bool SingleSelectionIsAdmin(void);

        //
        // Message handlers.
        //
        LRESULT OnNotify(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSize(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSetCursor(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnSetFocus(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnDestroy(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnMainWindowCreated(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnCommand(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnCmdViewStatusBar(VOID);
        LRESULT OnCmdViewToolBar(VOID);
        LRESULT OnCmdViewShowFolder(VOID);
        LRESULT OnCmdProperties(VOID);
        LRESULT OnCmdNew(VOID);
        LRESULT OnCmdDelete(VOID);
        LRESULT OnCmdUndo(VOID);
        LRESULT OnCmdFind(VOID);
        LRESULT OnCmdEditCopy(VOID);
        LRESULT OnCmdImport(VOID);
        LRESULT OnCmdExport(VOID);
        LRESULT OnMenuSelect(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnContextMenu(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnHelpAbout(HWND);
        LRESULT OnHelpTopics(HWND);
        LRESULT OnSettingChange(HWND, UINT, WPARAM, LPARAM);
        LRESULT OnLVN_OwnerDataFindItem(NMLVFINDITEM *);
        LRESULT OnLVN_GetDispInfo(LV_DISPINFO *);
        LRESULT OnLVN_GetDispInfo_Text(LV_DISPINFO *, PDISKQUOTA_USER);
        LRESULT OnLVN_GetDispInfo_Image(LV_DISPINFO *, PDISKQUOTA_USER);
        LRESULT OnLVN_ColumnClick(NM_LISTVIEW *);
        LRESULT OnLVN_ItemChanged(NM_LISTVIEW *);
        LRESULT OnLVN_BeginDrag(NM_LISTVIEW *);
        LRESULT OnTTN_NeedText(TOOLTIPTEXT *);
        LRESULT LV_OnTTN_NeedText(TOOLTIPTEXT *);
        LRESULT LV_OnMouseMessages(HWND, UINT, WPARAM, LPARAM);
        BOOL HitTestHeader(int xPos, int yPos);

        INT_PTR ActivateListViewToolTip(BOOL bActivate)
            { return SendMessage(m_hwndListViewToolTip, TTM_ACTIVATE, (WPARAM)bActivate, 0); }

        VOID FocusOnSomething(VOID);
        VOID CleanupAfterAbnormalTermination(VOID);

        INT FindUserByName(LPCTSTR pszUserName, PDISKQUOTA_USER *ppIUser = NULL);
        INT FindUserBySid(LPBYTE pbUserSid, PDISKQUOTA_USER *ppIUser = NULL);
        INT FindUserByObjPtr(PDISKQUOTA_USER pIUser);
        BOOL GotoUserName(LPCTSTR pszUser);

        //
        // Connection point stuff.
        //
        HRESULT ConnectEventSink(VOID);
        HRESULT DisconnectEventSink(VOID);
        IConnectionPoint *GetConnectionPoint(VOID);

        static DWORD ThreadProc(LPVOID);
        static INT CompareItems(LPVOID, LPVOID, LPARAM);
        static HRESULT CalcPctQuotaUsed(PDISKQUOTA_USER, LPDWORD);
        static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
        static LRESULT CALLBACK LVSubClassWndProc(HWND, UINT, WPARAM, LPARAM);

        //
        // Prevent copying.
        //
        DetailsView(const DetailsView&);
        void operator = (const DetailsView&);


    public:
        DetailsView(VOID);
        ~DetailsView(VOID);

        BOOL Initialize(
            const CVolumeID& idVolume);

        CVolumeID GetVolumeID(void) const
            { return m_idVolume; }

        //
        // This is public so other UI elements can use it. (i.e. VolPropPage).
        //
        static HRESULT CreateVolumeDisplayName(
                const CVolumeID& idVolume, // [in] - "C:\" or "\\?\Volume{ <guid> }\"
                CString *pstrDisplayName); // [out] - "My Disk (C:)"
        //
        // If you change the value of idCol_Last, see the note with
        // the LV_STATE_INFO structure above regarding the rgcxCol[] member
        // of LV_STATE_INFO.
        //
        enum ColumnIDs { idCol_Status,
                         idCol_Folder,
                         idCol_Name,
                         idCol_LogonName,
                         idCol_AmtUsed,
                         idCol_Limit,
                         idCol_Threshold,
                         idCol_PctUsed,
                         idCol_Last };

        //
        // IUnknown methods.
        //
        STDMETHODIMP
        QueryInterface(
            REFIID riid,
            LPVOID *ppv);

        STDMETHODIMP_(ULONG)
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG)
        Release(
            VOID);

        //
        // IDiskQuotaEvents method.
        //
        STDMETHODIMP
        OnUserNameChanged(
            PDISKQUOTA_USER pUser);


        //
        // IDropSource methods.
        //
        STDMETHODIMP
        GiveFeedback(
            DWORD dwEffect);

        STDMETHODIMP
        QueryContinueDrag(
            BOOL fEscapePressed,
            DWORD grfKeyState);

        //
        // IDropTarget methods.
        //
        STDMETHODIMP DragEnter(
            IDataObject * pDataObject,
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);

        STDMETHODIMP DragOver(
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);

        STDMETHODIMP DragLeave(
            VOID);

        STDMETHODIMP Drop(
            IDataObject * pDataObject,
            DWORD grfKeyState,
            POINTL pt,
            DWORD * pdwEffect);


        //
        // IDataObject methods.
        //
        STDMETHODIMP
        GetData(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium);

        STDMETHODIMP
        GetDataHere(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium);

        STDMETHODIMP
        QueryGetData(
            FORMATETC *pFormatetc);

        STDMETHODIMP
        GetCanonicalFormatEtc(
            FORMATETC *pFormatetcIn,
            FORMATETC *pFormatetcOut);

        STDMETHODIMP
        SetData(
            FORMATETC *pFormatetc,
            STGMEDIUM *pmedium,
            BOOL fRelease);

        STDMETHODIMP
        EnumFormatEtc(
            DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatetc);

        STDMETHODIMP
        DAdvise(
            FORMATETC *pFormatetc,
            DWORD advf,
            IAdviseSink *pAdvSink,
            DWORD *pdwConnection);

        STDMETHODIMP
        DUnadvise(
            DWORD dwConnection);

        STDMETHODIMP
        EnumDAdvise(
            IEnumSTATDATA **ppenumAdvise);



        HWND GetHWndMain(VOID)
            { return m_hwndMain; }

        static VOID InitLVStateInfo(PLV_STATE_INFO plvsi);
        static BOOL IsValidLVStateInfo(PLV_STATE_INFO plvsi);

        void GetVolumeDisplayName(CString *pstrName)
            { *pstrName = m_strVolumeDisplayName; }

        UINT GetColumnIds(INT *prgColIds, INT cColIds);

        //
        // Methods for getting drag-drop report data from details view.
        //
        INT GetNextSelectedItemIndex(INT iRow);
        BOOL GetReportItem(UINT iRow, UINT iColId, PLV_REPORT_ITEM pItem);
        VOID GetReportTitle(LPTSTR pszDest, UINT cchDest);
        VOID GetReportColHeader(UINT iColId, LPTSTR pszDest, UINT cchDest);
        UINT GetReportColCount(VOID);
        UINT GetReportRowCount(VOID);
        //
        // These methods are for generating binary "reports" used in exporting
        // user quota information for transfer between volumes.
        //
        UINT GetReportBinaryRecordSize(UINT iRow);
        BOOL GetReportBinaryRecord(UINT iRow, LPBYTE pbRecord, UINT cbRecord);

        //
        // NOTE:  If the requirement for friendship between DetailsView and
        //        DetailsView::Finder exceeds only a few instances, we
        //        might as well grant total friendship to the Finder class.
        //        As long as the instance count is small, I like to keep
        //        the friendship restricted as much as possible.
        //
        // This Finder::DlgProc needs to call DetailsView::GotoUserName.
        //
        friend BOOL Finder::UserNameEntered(HWND);
        //
        // Finder::DlgProc needs access to Details::CY_TOOLBAR_COMBO.
        //
        friend INT_PTR CALLBACK Finder::DlgProc(HWND, UINT, WPARAM, LPARAM);

        friend class Importer;
};



//
// Represents a selection in the listview.
// Objects of this type are used for communicating a selection set to
// a function.  The recpient of the LVSelection object can query it
// to obtain information about the selection.
//
class LVSelection
{
    private:
        HWND m_hwndListView;
        struct ListEntry
        {
            PDISKQUOTA_USER pUser;
            INT iItem;
        };

        StructureList m_List;

        //
        // Prevent copying.
        //
        LVSelection(const LVSelection&);
        void operator = (const LVSelection&);

    public:
        LVSelection(HWND hwndListView)
            : m_hwndListView(hwndListView),
              m_List(sizeof(ListEntry), 10) { }

        LVSelection(VOID)
            : m_hwndListView(NULL),
              m_List(sizeof(ListEntry), 1) { }

        ~LVSelection(VOID) { }

        VOID Add(PDISKQUOTA_USER pUser, INT iItem);
        HWND GetListViewHwnd(VOID)
            { return m_hwndListView; }
        INT Count(VOID)
            { return m_List.Count(); }
        BOOL Retrieve(INT i, PDISKQUOTA_USER *ppUser, INT *piItem);
        BOOL Retrieve(INT i, PDISKQUOTA_USER *ppUser)
            { return Retrieve(i, ppUser, NULL); }
        BOOL Retrieve(INT i, INT *pItem)
            { return Retrieve(i, NULL, pItem); }
        VOID Clear(VOID)
            { m_List.Clear(); }
};




#endif // _INC_DSKQUOTA_DETAILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\adusrdlg.h ===
#ifndef __DSKQUOTA_ADDUSER_DIALOG_H
#define __DSKQUOTA_ADDUSER_DIALOG_H
///////////////////////////////////////////////////////////////////////////////
/*  File: adusrdlg.h

    Description: Provides declarations for the "Add User" dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/15/98    Initial creation.                                    BrianAu
                Separated code from userprop.h
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"    // For LVSelection
#endif
#ifndef __OBJSEL_H_
#   include <objsel.h>
#endif

#include "resource.h"

class AddUserDialog
{
    public:
        //
        // Prop sheet for editing users.
        //
        AddUserDialog(PDISKQUOTA_CONTROL pQuotaControl,
                      const CVolumeID& idVolume,
                      HINSTANCE hInstance,
                      HWND hwndParent,
                      HWND hwndDetailsLV,
                      UndoList& UndoList);

        virtual ~AddUserDialog(VOID);

        HRESULT Run(VOID);

    private:
        enum { iICON_USER_SINGLE, iICON_USER_MULTIPLE, cUSER_ICONS };

        LONGLONG           m_cVolumeMaxBytes;
        LONGLONG           m_llQuotaLimit;
        LONGLONG           m_llQuotaThreshold;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        UndoList&          m_UndoList;
        HINSTANCE          m_hInstance;
        HWND               m_hwndParent;
        HWND               m_hwndDetailsLV;
        DS_SELECTION_LIST *m_pSelectionList;
        CLIPFORMAT         m_cfSelectionList;
        CVolumeID          m_idVolume;
        HICON              m_hIconUser[cUSER_ICONS];     // 0=Single, 1=Multi-user.
        XBytes            *m_pxbQuotaLimit;
        XBytes            *m_pxbQuotaThreshold;

        INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnOk(HWND hDlg, WPARAM wParam, LPARAM lParam);
        HRESULT ApplySettings(HWND hDlg, bool bUndo = true);
        HRESULT BrowseForUsers(HWND hwndParent, IDataObject **ppdtobj);

        LPCWSTR GetDsSelUserName(const DS_SELECTION& sel);
        HRESULT GetDsSelUserSid(const DS_SELECTION& sel, LPBYTE pbSid, int cbSid);
        HRESULT HexCharsToByte(LPTSTR pszByte, LPBYTE pb);

        static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

        //
        // Prevent copy.
        //
        AddUserDialog(const AddUserDialog&);
        void operator = (const AddUserDialog&);
};


#endif // __DSKQUOTA_ADDUSER_DIALOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\dskquoui.cpp ===
#include "pch.h" // PCH
#pragma hdrstop

#define INITGUIDS
#include "dskquota.h"
#include <gpedit.h>    // Pick up IID_IGPEInformation
#include <shfusion.h>

#include "guidsp.h"    // Private GUIDs.
#include "factory.h"   // Class factory declarations.
#include "registry.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


HINSTANCE     g_hInstDll     = NULL;    // DLL instance handle.
LONG          g_cRefThisDll  = 0;       // DLL reference count.
LONG          g_cLockThisDll = 0;       // DLL lock count.


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllGetClassObject

    Description: Creates instance of DiskQuotaControlClassFactory.

    Arguments:
        rclsid - Reference to class ID that identifies the type of object that the
            class factory will be asked to create.

        riid - Reference to interface ID on the class factory object.

        ppvOut - Destination location for class factory object pointer after 
            instantiation.

    Returns:
        NOERROR                   - Success.
        E_OUTOFMEMORY             - Can't create class factory object.
        E_NOINTERFACE             - Interface not supported.
        E_INVALIDARG              - ppvOut arg is NULL.
        CLASS_E_CLASSNOTAVAILABLE - Class factory not available.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DllGetClassObject")));
    HRESULT hResult = CLASS_E_CLASSNOTAVAILABLE;
    
    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IsEqualIID(rclsid, CLSID_DiskQuotaUI))
        {
            DiskQuotaUIClassFactory *pClassFactory = NULL;

            pClassFactory = new DiskQuotaUIClassFactory;
            hResult = pClassFactory->QueryInterface(riid, ppvOut);
            if (FAILED(hResult))
            {
                delete pClassFactory;
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllCanUnloadNow

    Description: Called by OLE to determine if DLL can be unloaded.

    Arguments: None.

    Returns:
        S_FALSE     - Can't unload.  Ref count or lock count are > 0.
        S_OK        - OK to unload. Ref count and lock count are 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDAPI 
DllCanUnloadNow(
    VOID
    )
{
    DBGPRINT((DM_COM, DL_HIGH, TEXT("DllCanUnloadNow (dskquoui.dll) RefCnt = %d  LockCnt = %d"),
         g_cRefThisDll, g_cLockThisDll));

#ifdef DEBUG_PROCESS_DETACH
    //
    // This code will force the DLL to be unloaded so that we can 
    // test OnProcessDetach().  Otherwise, OLE will wait 10 minutes
    // after DllCanUnloadNow returns S_OK to call FreeLibrary.
    // Note however that the process will AV when OLE finally gets
    // around to freeing the library.  Therefore, we don't leave
    // this code active in free or check builds; only private debug
    // builds.  Must explicitly define DEBUG_PROCESS_DETACH.
    //
    if (0 == g_cRefThisDll && 0 == g_cLockThisDll)
    {
        HINSTANCE hMod;
        static INT iExeThisPath = 0;
        
        if (0 == iExeThisPath++)
        {
            hMod = LoadLibrary(TEXT("dskquota.dll"));
            if (NULL != hMod)
            {
                Assert(g_hInstDll == hMod);
                FreeLibrary(hMod);
                FreeLibrary(hMod);
            }
        }
    }
#endif // DEBUG_PROCESS_DETACH

    return (0 == g_cRefThisDll && 0 == g_cLockThisDll) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllRegisterServer

    Description: Create the necessary registry entries for dskquoui.dll
        to operate properly.  This is typically called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to create one of the registry entries.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllRegisterServer(
    VOID
    )
{
    HRESULT hResult = CallRegInstall(g_hInstDll, "RegDll");

    if (FAILED(hResult))
    {
        hResult = SELFREG_E_CLASS;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DllUnregisterServer

    Description: Remove the necessary registry entries for dskquoui.dll.
        This is typically called by REGSVR32.EXE.

    Arguments: None.

    Returns:
        S_OK            - Succeeded.
        SELFREG_E_CLASS - Failed to remove the CLSID entry.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DllUnregisterServer(
    VOID
    )
{
    HRESULT hResult = CallRegInstall(g_hInstDll, "UnregDll");

    if (FAILED(hResult))
    {
        hResult = SELFREG_E_CLASS;
    }
    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessAttach

    Description: Handles all tasks associated with a process attaching to 
        the DLL.

        Try to keep processing time to a minimum.

    Arguments:
        hInstDll - The DLL instance handle passed to DllMain.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessAttach(
    HINSTANCE hInstDll
    )
{
    HRESULT hResult = NOERROR;

    //
    // Be specific - you want to use this dll's manifest (in resources at ID 1.)
    //
    SHFusionInitializeFromModuleID(hInstDll, 1);

    //
    // Start IceCAP profiling.
    //
    ICAP_START_ALL;

#if DBG
    DBGMODULE(TEXT("DSKQUOUI"));  // Name of module displayed with messages.
    RegKey key(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (SUCCEEDED(key.Open(KEY_READ)))
    {
        DebugRegParams dp;
        if (SUCCEEDED(key.GetValue(REGSTR_VAL_DEBUGPARAMS, (LPBYTE)&dp, sizeof(dp))))
        {
            DBGPRINTMASK(dp.PrintMask);
            DBGPRINTLEVEL(dp.PrintLevel);
            DBGPRINTVERBOSE(dp.PrintVerbose);
            DBGTRACEMASK(dp.TraceMask);
            DBGTRACELEVEL(dp.TraceLevel);
            DBGTRACEVERBOSE(dp.TraceVerbose);
            DBGTRACEONEXIT(dp.TraceOnExit);
        }
    }
#endif // DBG


    g_hInstDll = hInstDll;
    DisableThreadLibraryCalls(hInstDll);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessDetach

    Description: Handles all tasks associated with a process detaching from 
        the DLL.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessDetach(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    SHFusionUninitialize();

#ifdef DEBUG_PROCESS_DETACH
    LoadLibrary(TEXT("dskquoui.dll"));
#endif

    //
    // Stop IceCAP profiling.
    //
    ICAP_STOP_ALL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllMain

    Description: Main entry point for OLE component server.

    Arguments:
        hInstDll - Instance handle of DLL

        fdwReason - Reason DllMain is being called.  Can be at Process attach/
            detach or Thread attach/detach.

        lpdwReserved - Reserved.

    Returns:
        TRUE    - Successful initialization.
        FALSE   - Failed initialization.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/09/96    Moved code associated with process attach and        BrianAu
                detach out to separate functions.
*/
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI 
DllMain(
    HINSTANCE hInstDll, 
    DWORD fdwReason, 
    LPVOID lpvReserved
    )
{
    BOOL bResult = FALSE;

    switch(fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DSKQUOUI - DLL_PROCESS_ATTACH")));
            bResult = SUCCEEDED(OnProcessAttach(hInstDll));
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bResult = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DBGPRINT((DM_COM, DL_HIGH, TEXT("DSKQUOUI - DLL_PROCESS_DETACH")));
            bResult = SUCCEEDED(OnProcessDetach());
            break;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\adusrdlg.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: adusrdlg.cpp

    Description: Provides implementations for the "Add User" dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <lm.h>
#include "undo.h"
#include "adusrdlg.h"
#include "uihelp.h"
#include "progress.h"
#include "uiutils.h"


//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgAddUserDialogHelpIDs[] =
{
    IDC_ICON_USER,               DWORD(-1),
    IDC_STATIC2,                 DWORD(-1),
    IDC_TXT_DEFAULTS,            DWORD(-1),
    IDC_TXT_USERNAME,            IDH_TXT_USERNAME,
    IDC_TXT_SPACEUSED,           IDH_TXT_SPACEUSED,
    IDC_TXT_SPACEREMAINING,      IDH_TXT_SPACEREMAINING,
    IDC_ICON_USERSTATUS,         IDH_ICON_USERSTATUS,
    IDC_RBN_USER_NOLIMIT,        IDH_RBN_USER_NOLIMIT,
    IDC_RBN_USER_LIMIT,          IDH_RBN_USER_LIMIT,
    IDC_TXT_WARN_LEVEL,          DWORD(-1),
    IDC_EDIT_USER_LIMIT,         IDH_EDIT_USER_LIMIT,
    IDC_EDIT_USER_THRESHOLD,     IDH_EDIT_USER_THRESHOLD,
    IDC_CMB_USER_LIMIT,          IDH_CMB_USER_LIMIT,
    IDC_CMB_USER_THRESHOLD,      IDH_CMB_USER_THRESHOLD,
    0,0
};

#pragma data_seg()


///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::AddUserDialog

    Description: Constructor for a user property sheet object.
        Initializes the members that hold user quota data.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
AddUserDialog::AddUserDialog(
    PDISKQUOTA_CONTROL pQuotaControl,
    const CVolumeID& idVolume,
    HINSTANCE hInstance,
    HWND hwndParent,
    HWND hwndDetailsLV,
    UndoList& UndoList
    ) : m_cVolumeMaxBytes(0),
        m_pQuotaControl(pQuotaControl),
        m_idVolume(idVolume),
        m_UndoList(UndoList),
        m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDetailsLV(hwndDetailsLV),
        m_pxbQuotaLimit(NULL),
        m_pxbQuotaThreshold(NULL),
        m_llQuotaLimit(0),
        m_llQuotaThreshold(0),
        m_pSelectionList(NULL),  // Object instance doesn't own this memory.
        m_cfSelectionList((CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST))
{
    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_hwndParent));
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("AddUserDialog::AddUserDialog")));

    DBGASSERT((0 == iICON_USER_SINGLE));
    DBGASSERT((1 == iICON_USER_MULTIPLE));
    m_hIconUser[0]     = LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_SINGLE_USER));
    m_hIconUser[1]     = LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_MULTI_USER));
}



AddUserDialog::~AddUserDialog(
    VOID
    )
{
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("AddUserDialog::~AddUserDialog")));
    INT i = 0;

    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();

    if (NULL != m_pxbQuotaLimit)
        delete m_pxbQuotaLimit;
    if (NULL != m_pxbQuotaThreshold)
        delete m_pxbQuotaThreshold;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::Run

    Description: Creates and runs the property sheet dialog.
        This is the only method a client needs to call once the object
        is created.

    Arguments: None.

    Returns:
        NO_ERROR
        E_FAIL      - Couldn't create property sheet.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
AddUserDialog::Run(
    VOID
    )
{
    //
    // Invoke the standard object picker dialog.
    //
    IDataObject *pdtobj = NULL;
    HRESULT hr = BrowseForUsers(m_hwndParent, &pdtobj);
    if (S_OK == hr)
    {
        //
        // Retrieve the data object representing the selected user objects.
        //
        FORMATETC fe = { m_cfSelectionList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM stg;
        hr = pdtobj->GetData(&fe, &stg);
        {
            //
            // Cache the data obj ptr so the dialog can have access.
            //
            m_pSelectionList = (DS_SELECTION_LIST *)GlobalLock(stg.hGlobal);

            if (NULL != m_pSelectionList)
            {
                hr = (HRESULT) DialogBoxParam(m_hInstance,
                                              MAKEINTRESOURCE(IDD_ADDUSER),
                                              m_hwndParent,
                                              DlgProc,
                                              (LPARAM)this);
                GlobalUnlock(stg.hGlobal);
                m_pSelectionList = NULL;
            }
            ReleaseStgMedium(&stg);
        }
        pdtobj->Release();
    }
    return hr;

}



///////////////////////////////////////////////////////////////////////////////
/*  Function: AddUserDialog::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
AddUserDialog::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    AddUserDialog *pThis = (AddUserDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                pThis = (AddUserDialog *)lParam;
                DBGASSERT((NULL != pThis));
                //
                // Save "this" in the window's userdata.
                //
                SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);
                bResult = pThis->OnInitDialog(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                break;

            default:
                break;
        }

    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}

INT_PTR
AddUserDialog::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;

    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    //
    // The "new user" dialog is initialized with the volume's default quota
    // limit and threshold for new users.
    //
    m_pQuotaControl->GetDefaultQuotaLimit(&m_llQuotaLimit);
    m_pQuotaControl->GetDefaultQuotaThreshold(&m_llQuotaThreshold);

    //
    // Configure the Limit/NoLimit radio buttons.
    //
    if (NOLIMIT == m_llQuotaThreshold)
    {
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   FALSE);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, TRUE);
    }
    else
    {
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   TRUE);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, FALSE);
    }

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        m_cVolumeMaxBytes = (LONGLONG)dwSectorsPerCluster *
                            (LONGLONG)dwBytesPerSector *
                            (LONGLONG)dwTotalClusters;
    }

    m_pxbQuotaLimit     = new XBytes(hDlg,
                                     IDC_EDIT_USER_LIMIT,
                                     IDC_CMB_USER_LIMIT,
                                     m_llQuotaLimit);

    m_pxbQuotaLimit->SetBytes(m_llQuotaLimit);

    m_pxbQuotaThreshold = new XBytes(hDlg,
                                     IDC_EDIT_USER_THRESHOLD,
                                     IDC_CMB_USER_THRESHOLD,
                                     m_llQuotaThreshold);

    m_pxbQuotaThreshold->SetBytes(m_llQuotaThreshold);

    DBGASSERT((0 < m_pSelectionList->cItems));
    if (1 == m_pSelectionList->cItems)
    {
        SetDlgItemText(hDlg,
                       IDC_TXT_USERNAME,
                       GetDsSelUserName(m_pSelectionList->aDsSelection[0]));
    }
    else
    {
        CString strMultiple(m_hInstance, IDS_MULTIPLE);
        SetDlgItemText(hDlg, IDC_TXT_USERNAME, strMultiple);
    }

    SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                STM_SETICON,
                (WPARAM)m_hIconUser[1 == m_pSelectionList->cItems ? iICON_USER_SINGLE :
                                                                    iICON_USER_MULTIPLE],
                0);


    return TRUE;  // Set focus to default control.
}

//
// The Object Picker scope definition structure looks like this
// JeffreyS created these helper macros for working with the object picker
// in the ACLEDIT security UI. Thanks Jeff!
//
#if 0
{   // DSOP_SCOPE_INIT_INFO
    cbSize,
    flType,
    flScope,
    {   // DSOP_FILTER_FLAGS
        {   // DSOP_UPLEVEL_FILTER_FLAGS
            flBothModes,
            flMixedModeOnly,
            flNativeModeOnly
        },
        flDownlevel
    },
    pwzDcName,
    pwzADsPath,
    hr // OUT
}
#endif

//
// macro for declaring one of the above
//
#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }


#define COMMON_SCOPE_FLAGS    (DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | DSOP_SCOPE_FLAG_WANT_SID_PATH)

#define TARGET_COMPUTER_SCOPE                             \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_TARGET_COMPUTER,                      \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define JOINED_UPLEVEL_DOMAIN_SCOPE                       \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,                \
    COMMON_SCOPE_FLAGS | DSOP_SCOPE_FLAG_STARTING_SCOPE,  \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define JOINED_DOWNLEVEL_DOMAIN_SCOPE                     \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,              \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define ENTERPRISE_DOMAIN_SCOPE                           \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,                    \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define EXTERNAL_UPLEVEL_DOMAIN_SCOPE                     \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,              \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define EXTERNAL_DOWNLEVEL_DOMAIN_SCOPE                   \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,            \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define GLOBAL_CATALOG_SCOPE                              \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_GLOBAL_CATALOG,                       \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

#define WORKGROUP_SCOPE                                   \
DECLARE_SCOPE(                                            \
    DSOP_SCOPE_TYPE_WORKGROUP,                            \
    COMMON_SCOPE_FLAGS,                                   \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_FILTER_USERS,                                    \
    DSOP_DOWNLEVEL_FILTER_USERS)

//
// Invokes the standard DS object picker dialog.
// Returns a list of DS_SELECTION structures in a data object
// representing the selected user objects.
//
HRESULT
AddUserDialog::BrowseForUsers(
    HWND hwndParent,
    IDataObject **ppdtobj
    )
{
    DBGASSERT((NULL != hwndParent));
    DBGASSERT((NULL != ppdtobj));

    *ppdtobj = NULL;

    IDsObjectPicker *pop = NULL;
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDsObjectPicker,
                                  (void **)&pop);
    if (SUCCEEDED(hr))
    {
        //
        // This array initializes the scopes of the DS object picker.
        // The first entry is the "default" scope.
        //
        DSOP_SCOPE_INIT_INFO rgdsii[] = {
                JOINED_UPLEVEL_DOMAIN_SCOPE,
                JOINED_DOWNLEVEL_DOMAIN_SCOPE,
                ENTERPRISE_DOMAIN_SCOPE,
                EXTERNAL_UPLEVEL_DOMAIN_SCOPE,
                EXTERNAL_DOWNLEVEL_DOMAIN_SCOPE,
                GLOBAL_CATALOG_SCOPE,
                WORKGROUP_SCOPE,
                TARGET_COMPUTER_SCOPE
                };

        DSOP_INIT_INFO dii;
        dii.cbSize             = sizeof(dii);
        dii.pwzTargetComputer  = NULL;
        dii.cDsScopeInfos      = ARRAYSIZE(rgdsii);
        dii.aDsScopeInfos      = rgdsii;
        dii.flOptions          = DSOP_FLAG_MULTISELECT;
        dii.cAttributesToFetch = 0;
        dii.apwzAttributeNames = NULL;
        //
        // Init and run the object picker dialog.
        //
        hr = pop->Initialize(&dii);
        if (SUCCEEDED(hr))
        {
            hr = pop->InvokeDialog(hwndParent, ppdtobj);
        }
        pop->Release();
    }

    return hr;
}


INT_PTR
AddUserDialog::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD dwCtlId      = LOWORD(wParam);
    HWND hWndCtl       = (HWND)lParam;
    DWORD dwNotifyCode = HIWORD(wParam);
    INT_PTR bResult    = FALSE;

    switch(dwCtlId)
    {
        case IDC_RBN_USER_NOLIMIT:
            if (m_pxbQuotaThreshold->IsEnabled())
            {
                //
                // This is simple.  Just set both the limit and threshold controls
                // to "no limit".
                //
                m_pxbQuotaThreshold->SetBytes(NOLIMIT);
                m_pxbQuotaLimit->SetBytes(NOLIMIT);
            }
            break;

        case IDC_RBN_USER_LIMIT:
            if (!m_pxbQuotaThreshold->IsEnabled())
            {
                LONGLONG llValue = 0;
                m_pQuotaControl->GetDefaultQuotaLimit(&llValue);
                m_pxbQuotaLimit->SetBytes(NOLIMIT == llValue ? 0 : llValue);

                llValue = 0;
                m_pQuotaControl->GetDefaultQuotaThreshold(&llValue);
                m_pxbQuotaThreshold->SetBytes(NOLIMIT == llValue ? 0 : llValue);
            }
            break;

        case IDC_EDIT_USER_LIMIT:
        case IDC_EDIT_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_USER_LIMIT:
        case IDC_CMB_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDOK:
            if (!OnOk(hDlg, wParam, lParam))
                return FALSE;
            //
            // Fall through...
            //
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        default:
            bResult = TRUE;  // Didn't handle message.
            break;
    }

    return bResult;
}




INT_PTR
AddUserDialog::OnOk(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult  = NO_ERROR;

    //
    // We need to do this because if you activate the OK button
    // with [Return] we receive the WM_COMMAND before EN_KILLFOCUS.
    //
    m_pxbQuotaThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
    m_pxbQuotaLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_LIMIT));

    //
    // Ensure warning threshold is not above limit.
    //
    INT64 iThreshold = m_pxbQuotaThreshold->GetBytes();
    INT64 iLimit     = m_pxbQuotaLimit->GetBytes();

    if (NOLIMIT != iLimit && iThreshold > iLimit)
    {
        TCHAR szLimit[40], szThreshold[40];
        XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
        XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

        CString s(m_hInstance, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
        switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
        {
            case IDYES:
                m_pxbQuotaThreshold->SetBytes(iLimit);
                break;

            case IDNO:
                //
                // Set focus to threshold edit box so user can correct
                // the entry.  Return early with FALSE value.
                //
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
                SendMessage(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD), EM_SETSEL, 0, -1);
                return FALSE;
        }
    }

    //
    // Only apply settings if the "Apply" button is enabled indicating
    // that something has been changed.  No need to apply unchanged
    // settings when the OK button is pressed.
    //
    hResult = ApplySettings(hDlg);
    if (FAILED(hResult))
    {
        INT idMsg   = IDS_UNKNOWN_ERROR;
        UINT uFlags = MB_OK;
        switch(hResult)
        {
            case E_FAIL:
                idMsg = IDS_WRITE_ERROR;
                uFlags |= MB_ICONERROR;
                break;

            default:
                switch(HRESULT_CODE(hResult))
                {

//                      case ERROR_USER_EXISTS:
//                          idMsg = IDS_NOADD_EXISTING_USER;
//                          uFlags |= MB_ICONWARNING;
//                          break;
//
// Still valid?  [brianau - 5/27/98]
//
                    case ERROR_NO_SUCH_USER:
                        idMsg = IDS_NOADD_UNKNOWN_USER;
                        uFlags |= MB_ICONWARNING;
                        break;

                    case ERROR_ACCESS_DENIED:
                        idMsg  = IDS_NO_WRITE_ACCESS;
                        uFlags |= MB_ICONWARNING;
                        break;

                    default:
                    uFlags |= MB_ICONERROR;
                    break;
                }
                break;
        }
        DiskQuotaMsgBox(GetDesktopWindow(),
                        idMsg,
                        IDS_TITLE_DISK_QUOTA,
                        uFlags);
    }
    return TRUE;
}



INT_PTR
AddUserDialog::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgAddUserDialogHelpIDs);
    return TRUE;
}


INT_PTR
AddUserDialog::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgAddUserDialogHelpIDs));

    return FALSE;
}



INT_PTR
AddUserDialog::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditNotifyUpdate(lParam);

    return FALSE;
}


INT_PTR
AddUserDialog::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_CMB_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_CMB_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }
    if (NULL != pxb)
       pxb->OnComboNotifySelChange(lParam);

    return FALSE;
}


//
// Retrieve from a DS_SELECTION structure the name to display for
// a user object.
//
LPCWSTR
AddUserDialog::GetDsSelUserName(
    const DS_SELECTION& sel
    )
{
    return sel.pwzUPN && *sel.pwzUPN ? sel.pwzUPN : sel.pwzName;
}


//
// Convert two hex chars into a single byte value.
// Assumes input string is in upper case.
//
HRESULT
AddUserDialog::HexCharsToByte(
    LPTSTR pszByteIn,
    LPBYTE pbOut
    )
{
    static const int iShift[] = { 4, 0 };

    *pbOut = (BYTE)0;
    for (int i = 0; i < 2; i++)
    {
        TCHAR ch = *(pszByteIn + i);
        BYTE b   = (BYTE)0;
        if (TEXT('0') <= ch && TEXT('9') >= ch)
        {
            b = ch - TEXT('0');
        }
        else if (TEXT('A') <= ch && TEXT('F') >= ch)
        {
            b = 10 + (ch - TEXT('A'));
        }
        else
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        *pbOut |= (b << iShift[i]);
    }
    return NOERROR;
}

//
// Returns:
//
//  NOERROR
//  ERROR_INSUFFICIENT_BUFFER (as hresult)
//  ERROR_INVALID_DATA (as hresult)
//
HRESULT
AddUserDialog::GetDsSelUserSid(
    const DS_SELECTION& sel,
    LPBYTE pbSid,
    int cbSid
    )
{
    static const WCHAR szPrefix[] = L"LDAP://<SID=";
    static const WCHAR chTerm     = L'>';

    HRESULT hr     = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    LPWSTR pszLDAP = CharUpper(sel.pwzADsPath);
    if (NULL != pszLDAP)
    {
        int cb = 0;

        //
        // First check for the required prefix.
        //
        if (0 == StrCmpNW(pszLDAP, szPrefix, ARRAYSIZE(szPrefix) - 1))
        {
            hr = NOERROR;
            //
            // Advance ptr beyond prefix and convert the hex string
            // into a SID.  Process chars until we hit a '>'.
            //
            pszLDAP += ARRAYSIZE(szPrefix) - 1;

            while(SUCCEEDED(hr) && *pszLDAP && chTerm != *pszLDAP)
            {
                if (0 < cbSid--)
                {
                    hr = HexCharsToByte(pszLDAP, pbSid++);
                    pszLDAP += 2;
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            if (SUCCEEDED(hr) && chTerm != *pszLDAP)
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }

    if (FAILED(hr))
    {
        //
        // FEATURE:  This can be removed once I'm comfortable that all
        //          ADs paths returned from the object picker contain
        //          a SID.
        //
        DBGERROR((TEXT("GetDsSelUserSid returning hr = 0x%08X for path \"%s\""),
                  hr, sel.pwzADsPath));
    }

    return hr;
}


HRESULT
AddUserDialog::ApplySettings(
    HWND hDlg,
    bool bUndo
    )
{
    HRESULT hResult = E_FAIL;
    int cUsers = m_pSelectionList->cItems;
    CAutoWaitCursor wait_cursor;

    //
    // Retrieve limit and threshold values from dialog controls.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        m_llQuotaThreshold = NOLIMIT;
        m_llQuotaLimit     = NOLIMIT;
    }
    else
    {
        m_llQuotaThreshold = m_pxbQuotaThreshold->GetBytes();
        m_llQuotaLimit     = m_pxbQuotaLimit->GetBytes();
    }


    if (bUndo)
        m_UndoList.Clear();

    ProgressDialog dlgProgress(IDD_PROGRESS,
                               IDC_PROGRESS_BAR,
                               IDC_TXT_PROGRESS_DESCRIPTION,
                               IDC_TXT_PROGRESS_FILENAME);
    if (2 < cUsers)
    {
        //
        // Create and display a progress dialog if we're adding more than 2
        // users.
        //
        HWND hwndParent = IsWindowVisible(hDlg) ? hDlg : GetParent(hDlg);
        if (dlgProgress.Create(m_hInstance, hwndParent))
        {
            dlgProgress.ProgressBarInit(0, cUsers, 1);
            dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_ADDUSER));
            dlgProgress.Show();
        }
    }

    bool bCancelled = false;
    for (int i = 0; i < cUsers && !bCancelled; i++)
    {
        DS_SELECTION *pdss = &(m_pSelectionList->aDsSelection[i]);
        LPCWSTR pwzName = GetDsSelUserName(*pdss);

        //
        // Add a user to the quota file.  This will add it using the defaults
        // for new users.  We get back an interface to the new user object.
        // Also specify async name resolution.
        //
        if (NULL == pwzName)
        {
            dlgProgress.ProgressBarAdvance();
            continue;
        }

        dlgProgress.SetFileName(pwzName);

        com_autoptr<DISKQUOTA_USER> ptrUser;
        DiskQuotaControl *pDQC = static_cast<DiskQuotaControl *>(m_pQuotaControl);

        BYTE sid[MAX_SID_LEN];
        hResult = GetDsSelUserSid(*pdss, sid, ARRAYSIZE(sid));
        if (SUCCEEDED(hResult))
        {
            hResult = pDQC->AddUserSid(sid,
                                       DISKQUOTA_USERNAME_RESOLVE_ASYNC,
                                       ptrUser.getaddr());

            if (SUCCEEDED(hResult))
            {
                if (S_FALSE == hResult)
                {
                    hResult = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
                }
                else
                {
                    if (SUCCEEDED(hResult = ptrUser->SetQuotaLimit(m_llQuotaLimit, TRUE)) &&
                        SUCCEEDED(hResult = ptrUser->SetQuotaThreshold(m_llQuotaThreshold, TRUE)))
                    {
                        if (bUndo)
                        {
                            //
                            // Create local autoptrs to ensure iface release if an
                            // exception is thrown.
                            //
                            com_autoptr<DISKQUOTA_CONTROL> ptrQuotaControl(m_pQuotaControl);
                            com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);

                            ptrQuotaUser->AddRef();
                            ptrQuotaControl->AddRef();

                            autoptr<UndoAdd> ptrUndoAdd = new UndoAdd(ptrUser, m_pQuotaControl);

                            m_UndoList.Add(ptrUndoAdd);
                            //
                            // Undo list now owns the action object.
                            //
                            ptrUndoAdd.disown();

                            //
                            // Successfully added to undo list.  Disown real ptrs so
                            // ref count stays with undo list.  If an exception was
                            // thrown, the local com_autoptr objects will automatically
                            // release the interfaces.
                            //
                            ptrQuotaUser.disown();
                            ptrQuotaControl.disown();
                        }

                        //
                        // Add the user to the listview.
                        //
                        SendMessage(m_hwndDetailsLV,
                                    WM_ADD_USER_TO_DETAILS_VIEW,
                                    0,
                                    (LPARAM)ptrUser.get());
                        //
                        // iface pointer added to listview.  autoptr disowns the real
                        // pointer so the autoptr's dtor doesn't release it.
                        //
                        ptrUser.disown();
                    }
                }
            }
        }
        if (FAILED(hResult))
        {
            INT idMsg   = IDS_UNKNOWN_ERROR;
            UINT uFlags = MB_OKCANCEL;
            switch(hResult)
            {
                case E_FAIL:
                    idMsg = IDS_WRITE_ERROR;
                    uFlags |= MB_ICONERROR;
                    break;

                default:
                    switch(HRESULT_CODE(hResult))
                    {
                        case ERROR_USER_EXISTS:
                            idMsg = IDS_NOADD_EXISTING_USER;
                            uFlags |= MB_ICONWARNING;
                            break;

                        case ERROR_NO_SUCH_USER:
                            idMsg = IDS_NOADD_UNKNOWN_USER;
                            uFlags |= MB_ICONWARNING;
                            break;

                        case ERROR_ACCESS_DENIED:
                            idMsg  = IDS_NO_WRITE_ACCESS;
                            uFlags |= MB_ICONWARNING;
                            break;

                        default:
                            uFlags |= MB_ICONERROR;
                            break;
                    }
                    break;
            }

            //
            // Display message box with msg formatted as:
            //
            //      The user already exists and could not be added.
            //
            //      User:  brianau
            //      In Folder: Domain/Folder: ntdev.microsoft.com/US SOS-...
            //
            CString strError(m_hInstance, idMsg);
            CString strMsg(m_hInstance, IDS_FMT_ERR_ADDUSER, strError.Cstr(), pwzName);

            HWND hwndMsgBoxParent = (NULL != dlgProgress.m_hWnd && IsWindowVisible(dlgProgress.m_hWnd)) ?
                                    dlgProgress.m_hWnd : hDlg;

            if (IDCANCEL == DiskQuotaMsgBox(hwndMsgBoxParent,
                                            strMsg.Cstr(),
                                            IDS_TITLE_DISK_QUOTA,
                                            uFlags))
            {
                bCancelled = true;
            }
        }
        dlgProgress.ProgressBarAdvance();
        bCancelled = bCancelled || dlgProgress.UserCancelled();
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\control\userenum.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: enumuser.cpp

    Description: Contains member function definitions for class DiskQuotaUserEnum.
        The DiskQuotaUserEnum object is provided to enumerate the users in a 
        volume's quota information file.  The caller instantiates an enumerator
        through IDiskQuotaControl::CreateDiskQuotaUserEnum().  The enumerator's
        interface IEnumDiskQuotaUsers supports the normal OLE 2 enumeration
        functions Next(), Skip(), Reset() and Clone().

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "user.h"
#include "userenum.h"

//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::DiskQuotaUserEnum

    Description: Constructor.

    Arguments:
        pFSObject - Pointer to an existing "file system" object.  
            It is through this object that the enumerator accesses the ntioapi 
            functions.  A pointer to this file system object is also passed 
            on to contained user objects so they may refresh their data when 
            required.  

        pQuotaController - Pointer to an IDiskQuotaControl interface that we'll
            AddRef().  The control object is who provides the "name changed"
            notification mechanism.  It needs to stay around as long as the
            enumerator is alive.

        pSidNameResolver - Pointer to an ISidNameResolver interface that will
            be used to resolve user SIDs to account names.  The resolver object
            is initially instantiated by the quota controller.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/97    Moved pQuotaControl, pSidNameResolver and pFSObject  BrianAu
                arguments from Initialize() to ctor.  Needed so
                that ref counting is correct.
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserEnum::DiskQuotaUserEnum(
    PDISKQUOTA_CONTROL pQuotaController,
    PSID_NAME_RESOLVER pSidNameResolver,
    FSObject *pFSObject
    ) : m_cRef(0),
        m_pbBuffer(NULL),
        m_pbCurrent(NULL),
        m_cbBuffer(0),
        m_pSidList(NULL),
        m_cbSidList(0),
        m_bEOF(FALSE),
        m_bSingleUser(FALSE),
        m_bInitialized(FALSE),
        m_bRestartScan(TRUE),
        m_fNameResolution(DISKQUOTA_USERNAME_RESOLVE_NONE),
        m_pFSObject(pFSObject),
        m_pQuotaController(pQuotaController),
        m_pSidNameResolver(pSidNameResolver)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserEnum::DiskQuotaUserEnum")));

    if (NULL != m_pQuotaController)
        m_pQuotaController->AddRef();

    if (NULL != m_pSidNameResolver)
        m_pSidNameResolver->AddRef();

    if (NULL != m_pFSObject)
        m_pFSObject->AddRef();

    InterlockedIncrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::~DiskQuotaUserEnum

    Description: Destructor.  Destroys the enumerator's internal buffers and
        releases any held interface pointers.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaUserEnum::~DiskQuotaUserEnum(void)
{
    DBGTRACE((DM_USER, DL_HIGH, TEXT("DiskQuotaUserEnum::~DiskQuotaUserEnum")));

    if (NULL != m_pFSObject)
        m_pFSObject->Release();

    //
    // Order is important here.  Release the resolver before the controller.
    //
    if (NULL != m_pSidNameResolver)
        m_pSidNameResolver->Release();

    if (NULL != m_pQuotaController)
        m_pQuotaController->Release();

    delete [] m_pbBuffer;
    delete [] m_pSidList;

    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::QueryInterface

    Description: Obtain pointer to IUnknown or IEnumDiskQuotaUser.  Note that
        referenced object is uninitialized.  Recipient of interface pointer
        must call Initialize() member function before object is usable.

    Arguments:
        riid - Reference to requested interface ID.  IID_IUnknown and 
            IID_IEnumDiskQuotaUser are recognized.

        ppvOut - Address of interface pointer variable to accept the
            returned interface pointer.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumDiskQuotaUsers == riid)
    {
        //
        // Interface supported.
        //
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserEnum::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserEnum::AddRef, 0x%08X  %d -> %d"),
                     this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserEnum::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserEnum::Release, 0x%08X  %d -> %d"),
                     this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Initialize

    Description: Initializes a new enumerator object.
        This member function is overloaded to provide two
        implementations.  The first accepts explicit arguments for
        initialization.  This member is intended for creating a new unique
        enumerator through IDiskQuotaControl::CreateEnumUsers.  The
        second implementation merely accepts a reference to an existing 
        EnumUsers object.  This member is intended to support the function
        IEnumDiskQuotaUser::Clone().

    Arguments:
        fNameResolution - Method of SID-to-name resolution. Can be one of the 
            following:
                    DISKQUOTA_USERNAME_RESOLVE_NONE
                    DISKQUOTA_USERNAME_RESOLVE_SYNC
                    DISKQUOTA_USERNAME_RESOLVE_ASYNC
 
        cbBuffer [optional] - Size in bytes of the internal buffer used in 
            calls to the NTIOAPI functions.  Default is ENUMUSER_BUF_LEN.

        rgpSids [optional] - Pointer to a list of SID pointers.  If 
            provided, only those users with SIDs included in the list are 
            returned.  This argument may be NULL in which case ALL users are
            included.  Any element containing a NULL pointer will terminate
            the list.

        cpSids [optional] - If pSidList is not NULL, this arg contains
            the count of entries in rgpSids.  If rgpSids is not NULL and this 
            argument contains 0, rgpSids is assumed to contain a terminating
            NULL pointer entry.

        UserEnum - Reference to an existing DiskQuotaUserEnum object.  The new
            object opens a connection to the same volume as the object being
            cloned.  The new object maintains a separate buffer for transfer
            of data from the NTIOAPI system.

    Returns:
        NO_ERROR          - Success.
        S_FALSE           - Already initialized.
        E_OUTOFMEMORY     - Insufficient memory.
        ERROR_INVALID_SID (hr) - A SID in rgpSids was invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Initialize(
    DWORD fNameResolution,
    DWORD cbBuffer,
    PSID *rgpSids,
    DWORD cpSids
    )
{
    HRESULT hResult = NO_ERROR;

    if (m_bInitialized)
    {
        hResult = S_FALSE;
    }
    else
    {
        try
        {
            //
            // Create an internal buffer for data transfer from the ntioapi.
            //
            m_pbBuffer = new BYTE [cbBuffer];

            m_cbBuffer = cbBuffer;

            if (NULL != rgpSids)
            {
                //
                // A list of SID pointers was provided.
                // Initialize the SID list structure.
                // Can throw OutOfMemory.
                //
                m_bSingleUser = (cpSids == 1);
                hResult = InitializeSidList(rgpSids, cpSids);
            }

            if (SUCCEEDED(hResult))
            {
                //
                // Must have an independent instance of the controller's file system 
                // object.  The NTIOAPI functions maintain an enumeration context
                // for each open handle.  Therefore, each user enumerator must have a 
                // unique file handle to the NTIOAPI object.
                // I say this because it appears tempting to just keep a copy of the 
                // controller's FSObject pointer and AddRef it.
                //
                // This create-n-swap is sort of slimy.  We originally got a 
                // ptr to the caller's FSObject in the ctor.  However, now we want
                // to create our own FSObject.  Create a copy and release the original.
                //
                FSObject *pFsoTemp = m_pFSObject;
                m_pFSObject        = NULL;
                hResult = FSObject::Create(*pFsoTemp, &m_pFSObject);
                pFsoTemp->Release();

                if (SUCCEEDED(hResult))
                {
                    m_fNameResolution  = fNameResolution;
                    m_bInitialized     = TRUE;
                }
            }
        }
        catch(CAllocException& e)
        {
            hResult = E_OUTOFMEMORY;
        }
    }

    return hResult;
}



HRESULT 
DiskQuotaUserEnum::Initialize(
    const DiskQuotaUserEnum& UserEnum
    )
{
    HRESULT hResult = NO_ERROR;

    try
    {
        //
        // Initialize the new enumerator without a SID list.
        // If the enumerator being copied has a SID list, we 
        // don't want to re-create a list of SID pointers for Initialize()
        // so we defer this for InitializeSidList.  InitializeSidList
        // has an overloaded version that accepts a pointer to an existing
        // SIDLIST structure and merely copies the bytes.
        //
        hResult = Initialize(UserEnum.m_fNameResolution,
                             UserEnum.m_cbBuffer,
                             NULL,
                             0);

        if (SUCCEEDED(hResult) && NULL != UserEnum.m_pSidList)
        {
            m_bSingleUser = UserEnum.m_bSingleUser;
            hResult = InitializeSidList(UserEnum.m_pSidList,
                                        UserEnum.m_cbSidList);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::InitializeSidList

    Description: Initializes the m_pSidList member of the enumerator.
        The method comes in two overloaded forms.  The first accepts a pointer
        to an existing SIDLIST structure and merely creates a new copy.
        The second form accepts the address of an array of SID pointers and
        generates a new SIDLIST structure.

    Arguments:
        pSidList - Address of an existing SIDLIST structure to be copied.

        cbSidList - Number of bytes in the SIDLIST structure.

        rgpSids  - Pointer to a list of SID pointers.  If provided, only those 
            users with SIDs included in the list are returned.  This argument 
            may be NULL in which case ALL users are included.  Any element 
            containing a NULL pointer will terminate the list.

        cpSids - If pSidList is not NULL, this arg contains the count of 
            entries in rgpSids.  If rgpSids is not NULL and this argument 
            contains 0, rgpSids is assumed to contain a terminating NULL 
            pointer entry.

    Returns:
        NO_ERROR            - Success.
        ERROR_INVALID_SID (hr) - A SID in rgpSids was invalid.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/13/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DiskQuotaUserEnum::InitializeSidList(
    PSIDLIST pSidList,
    DWORD cbSidList
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != pSidList));
    DBGASSERT((0 < cbSidList));

    //
    // Create a buffer for the SID list copy.
    //
    m_pSidList = (PSIDLIST)new BYTE[cbSidList];

    //
    // Copy the enumerator's SID list.
    //
    CopyMemory(m_pSidList, pSidList, cbSidList);
    m_cbSidList = cbSidList;

    return hResult;
}


HRESULT
DiskQuotaUserEnum::InitializeSidList(
    PSID *rgpSids,
    DWORD cpSids
    )
{
    HRESULT hResult = NO_ERROR;
    
    DBGASSERT((NULL != rgpSids));
    DBGASSERT((0 < cpSids));

    //
    // Create a SIDLIST structure from the array of SID pointers.
    // Can throw OutOfMemory.
    //
    hResult = CreateSidList(rgpSids, cpSids, &m_pSidList, &m_cbSidList);

    if (FAILED(hResult))
    {
        DBGASSERT((NULL == m_pSidList));
        DBGASSERT((0 == m_cbSidList));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::QueryQuotaInformation

    Description: Provides a simple wrapper around the NTIOAPI function
        QueryQuotaInformationFile. The function adds value by providing
        the address and size of the enumerator's data buffer.
        Note that the QueryQuotaInformationFile interface in NTIOAPI 
        functions as an enumerator itself.  Repeated calls enumerate
        user quota data much the same way the Next() function does in an OLE
        enumerator interface.  Data is returned in a byte buffer as a series
        of variable-length quota records.

    Arguments:
        bReturnSingleEntry [optional] - TRUE if only a single entry is
            desired.  FALSE if multiple records are desired.  Default is
            FALSE.

        pSidList [optional] - Pointer to a list of SIDs.  If provided, the
            data returned is only for those users included in the SID list.
            Default is NULL.

        cbSidList [optional] - If SidList is not NULL, contains length
            of SidList in bytes.  Default is 0.

        pStartSid [optional] - Pointer to SID in SID list where scan is to 
            start if bRestartScan is TRUE.  Default is NULL.

        bRestartScan [optional] - TRUE = restart enumeration at first user
            or user pointed to by StartSid in SidList (if provided).  
            FALSE = continue enumeration from current point.
            Default is FALSE.

    Returns:
        NO_ERROR             - Success.
        ERROR_NO_MORE_ITEMS  - No more user records.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::QueryQuotaInformation(
    BOOL bReturnSingleEntry, 
    PVOID pSidList,           
    ULONG cbSidList,     
    PSID pStartSid,           
    BOOL bRestartScan        
    )
{
    HRESULT hResult = NO_ERROR;
    
    if (bRestartScan)
    {
        //
        // Reset EOF flag if restarting enumerator scan.
        //
        m_bEOF = FALSE;
    }

    if (!m_bEOF)
    {
        ZeroMemory(m_pbBuffer, m_cbBuffer);
    
        hResult = m_pFSObject->QueryUserQuotaInformation(
                        m_pbBuffer,
                        m_cbBuffer,
                        bReturnSingleEntry,
                        pSidList,
                        cbSidList,
                        pStartSid,
                        bRestartScan);

        if (ERROR_SUCCESS == HRESULT_CODE(hResult) || ERROR_NO_MORE_ITEMS == HRESULT_CODE(hResult))
        {
            //
            // The enumeration logic changed between Win2000 and WinXP.
            // On Win2000, NTFS will return ERROR_NO_MORE_ITEMS on the last
            // buffer returned that contains data.  On WinXP, this error
            // code is returned on the first buffer that returns NO data.
            // To handle both cases, we zero out the buffer before reading data
            // and inspect the SidLength value in the first record to determine
            // if the buffer contains any data.  If the sid length is 0, we 
            // can assume the buffer is empty.
            //
            hResult = NO_ERROR;
        }
    }
    else
    {
        //
        // There REALLY are no more entries.
        //
        hResult = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::CreateUserObject

    Description: Creates a new DiskQuotaUser object from the quota information
        retrieved through QueryQuotaInformation.  The caller provides a pointer
        to the start of the desired quota info record to be used for 
        initialization.

    Arguments:
        pfqi - Pointer to the quota information record used for initialization.

        ppOut - Address of interface pointer variable to accept the user object's
            IDiskQuotaUser interface pointer.

    Returns:
        NO_ERROR                - Success.
        E_INVALIDARG            - pfqi or ppOut arg is NULL.
        E_UNEXPECTED            - Unexpected error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    09/05/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::CreateUserObject(
    PFILE_QUOTA_INFORMATION pfqi, 
    PDISKQUOTA_USER *ppOut
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL == pfqi || NULL == ppOut)
        return E_INVALIDARG;

    //
    // Create the user object and get the IDiskQuotaUser interface pointer.
    // This pointer is what is given to the caller.
    //
    m_pFSObject->AddRef();
    DiskQuotaUser *pUser = new DiskQuotaUser(m_pFSObject);

    //
    // Initialize the new user object using the buffered quota data pointed to
    // by pfqi.
    //
    hResult = pUser->Initialize(pfqi);

    if (SUCCEEDED(hResult))
    {
        hResult = pUser->QueryInterface(IID_IDiskQuotaUser, (LPVOID *)ppOut);
    }

    if (FAILED(hResult))
    {
        //
        // Either Initialize or QueryInterface failed.  Delete the object.
        //
        delete pUser;
        pUser = NULL;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::GetNextUser

    Description: Creates a new user object from the "current" record in the
        quota information buffer. A pointer to the object's IDiskQuotaUser
        interface is returned and the "current" record pointer in the 
        quota information buffer is advanced to the next user record.

    Arguments:
        ppOut [optional] - Address of interface pointer variable to receive 
            address of user object's IDiskQuotaUserInterface pointer.  If this
            argument is NULL, the new user object is not created.  This is 
            useful for skipping items in the enumeration.

    Returns:
        NO_ERROR                 - Success.
        E_DISKQUOTA_INVALID_SID  - User record's SID is invalid.
        ERROR_NO_MORE_ITEMS      - No more users.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::GetNextUser(
    PDISKQUOTA_USER *ppOut
    )
{
    PFILE_QUOTA_INFORMATION pfqi = (PFILE_QUOTA_INFORMATION)m_pbCurrent;
    HRESULT hResult              = NO_ERROR;

    //
    // If m_pbCurrent is NULL, this is the first request for data.
    // If pfqi->NextEntryOffset is 0, we need to read another buffer of data.
    //
    if (NULL == m_pbCurrent)
    {
        //
        // No more user entries in buffer.
        // Read quota information into m_pbBuffer.
        // Use SID list if we have one.
        //
        hResult = QueryQuotaInformation(m_bSingleUser,   // Single user?
                                        m_pSidList,      // SID list.
                                        m_cbSidList,     // SID list length.
                                        0,               // Start SID,
                                        m_bRestartScan); // Restart scan?
        if (SUCCEEDED(hResult))
        {
            //
            // New information in buffer. Reset record pointers.
            //
            m_pbCurrent    = m_pbBuffer;
            m_bRestartScan = FALSE;
            pfqi = (PFILE_QUOTA_INFORMATION)m_pbCurrent;
        }
    }

    if (SUCCEEDED(hResult))
    {
        //
        // We have a valid pointer into the buffer of user quota data.
        //
        if (NULL != ppOut)
        {
            if (0 != pfqi->SidLength)
            {
                // 
                // Caller provided a user interface pointer variable.
                // Create a new user record.  This can throw OutOfMemory.
                //
                hResult = CreateUserObject(pfqi, ppOut);
            }
            else
            {
                m_bEOF  = TRUE;
                hResult = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            }
        }

        if (0 != pfqi->NextEntryOffset)
            m_pbCurrent += pfqi->NextEntryOffset; // Advance to next user.
        else
            m_pbCurrent = NULL;  // Reset to trigger quota file read.

    }
    return hResult;
}    


    
///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Next

    Description: Retrieve the next cUsers records from the volume's quota
        information file.  If the enumerator was created with a SidList,
        only those users contained in the SidList are included in the 
        enumeration.  Repeated calls to Next() continue to enumerate
        successive quota users.   The Reset() function may be used to 
        reset the enumerator to the start of the enumeration.  

    Arguments:
        cUsers - Number of elements in paUsers array.

        pUser - Array of IDiskQuotaUser pointers.  Must provide space for 
            cUsers pointers. Upon return, each element of this array contains 
            an interface pointer to a DiskQuotaUser object.

        pcCreated [optional] - Address of DWORD to accept the count of user 
            object interface pointers returned in pUser.  Note that any 
            array locations equal to or beyond the value returned in 
            pcCreated are invalid and set to NULL.

    Returns:
        S_OK            - Success.  Enumerated number of requested users.
        S_FALSE         - End of enumeration encountered.  Returning less than
                          cUsers records.
        E_INVALIDARG    - pUser arg is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Next(
    DWORD cUsers,                        // Number of elements in array.
    PDISKQUOTA_USER *pUser,              // Dest array for quota user interface ptrs.
    DWORD *pcCreated                     // Return number created.
    )
{
    HRESULT hResult = S_OK;
    UINT i          = 0;                // Index into user caller's array.
    UINT cCreated   = 0;

    if (NULL == pUser)
        return E_INVALIDARG;

    if (NULL != pcCreated)
        *pcCreated = 0;

    try
    {
        IDiskQuotaUser *pNextUser = NULL;   // Ptr to new user.

        //
        // Enumerate user records until one of the following:
        // 1. Failure.
        // 2. No more users.
        // 3. Enumerated requested count.
        //
        while(SUCCEEDED(hResult) && cUsers > 0)
        {
            //
            // Create new user object.  This can throw OutOfMemory.
            //
            hResult = GetNextUser(&pNextUser);
            if (SUCCEEDED(hResult))
            {
                //
                // User records come from the quota file containing only a SID.
                // We must ask the SidNameResolver to locate the corresponding
                // account name.  If client wants names synchronously, we block
                // here until account name is found.  User object will contain
                // account name.
                // If client wants names asynchronously, the user object is handed
                // off to the resolver for background processing.  We continue on.
                // If the client implemented the IDiskQuotaEvents interface and
                // called IConnectionPoint::Advise, it will receive a 
                // OnUserNameChange notification when the name is finally resolved.
                // If user doesn't want user name resolved, don't do either. 
                // This would be the case if the client already has the SID/Name
                // pair and just wants user objects.
                //
                switch(m_fNameResolution)
                {
                    case DISKQUOTA_USERNAME_RESOLVE_ASYNC:
                        m_pSidNameResolver->FindUserNameAsync(pNextUser);
                        break;
                    case DISKQUOTA_USERNAME_RESOLVE_SYNC:
                        m_pSidNameResolver->FindUserName(pNextUser);
                        break;
                    case DISKQUOTA_USERNAME_RESOLVE_NONE:
                    default:
                        break;
                }

                //
                // Note: Ref count for pUser already incremented in 
                // DiskQuotaUser::QueryInterface.
                //
                *pUser = pNextUser;
                pUser++;
                cUsers--;
                cCreated++;
            }
        }

        if (NULL != pcCreated)
            *pcCreated = cCreated; // If requested, return number of users created.

        if (cUsers > 0)
        {
            //
            // Less than requested number of users were retrieved.
            // 
            hResult = S_FALSE;
            while(cUsers > 0)
            {
                //
                // Set any un-filled array elements to NULL.
                //
                *pUser = NULL;
                pUser++;
                cUsers--;
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    if (FAILED(hResult))
    {
        //
        // Release any user objects already created.
        //
        for (i = 0; i < cCreated; i++)
        {
            PDISKQUOTA_USER pu = *(pUser + i);
            if (NULL != pu)
            {
                pu->Release();
                *(pUser + i) = NULL;
            }
        }

        *pcCreated = 0;        
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Skip

    Description: Skips a specified number of users in the user enumeration.

    Arguments:
        cUsers - Number of users to skip.

    Returns:
        S_OK            - Success.  Skipped number of requested users.
        S_FALSE         - End of enumeration encountered.  Skipped less than
                          cUsers records.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaUserEnum::Skip(
    DWORD cUsers
    )
{
    while(cUsers > 0 && SUCCEEDED(GetNextUser(NULL)))
    {
        cUsers--;
    }

    return cUsers == 0 ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Reset

    Description: Resets the enumerator object so that the next call to Next()
        starts enumerating at the beginning of the enumeration.

    Arguments: None.

    Returns:
        Always returns S_OK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    02/09/99    Changed so we just reset m_pbCurrent and             BrianAu
                m_bRestartScan.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::Reset(
    VOID
    )
{
    m_pbCurrent    = NULL;
    m_bRestartScan = TRUE;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserEnum::Clone

    Description: Creates a duplicate of the enumerator object and returns
        a pointer to the new object's IEnumDiskQuotaUser interface.

    Arguments:
        ppOut - Address of interface pointer variable to accept the pointer
            to the new object's IEnumDiskQuotaUser interface.

    Returns:
        NO_ERROR        - Success.
        E_OUTOFMEMORY   - Insufficient memory to create new enumerator.
        E_INVALIDARG    - ppOut arg was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserEnum::Clone(
    PENUM_DISKQUOTA_USERS *ppOut
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL == ppOut)
        return E_INVALIDARG;

    try
    {
        DiskQuotaUserEnum *pUserEnum = new DiskQuotaUserEnum(
                                                m_pQuotaController,
                                                m_pSidNameResolver,
                                                m_pFSObject);

        hResult = pUserEnum->Initialize(*this);

        if (SUCCEEDED(hResult))
        {
            hResult = pUserEnum->QueryInterface(IID_IEnumDiskQuotaUsers, 
                                               (LPVOID *)ppOut);
        }

        if (FAILED(hResult))
        {
            //
            // Either Initialize or QueryInterface failed.
            //
            delete pUserEnum;
            pUserEnum = NULL;
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}

    

DiskQuotaUserCollection::DiskQuotaUserCollection(
    PDISKQUOTA_CONTROL pController,
    DWORD fNameResolution

    ) : m_cRef(0),
        m_pController(pController),
        m_pEnum(NULL),
        m_fNameResolution(fNameResolution)
{
    if (NULL != m_pController)
    {
        m_pController->AddRef();
    }
}

DiskQuotaUserCollection::~DiskQuotaUserCollection(
    VOID
    )
{
    if (NULL != m_pEnum)
    {
        m_pEnum->Release();
    }
    if (NULL != m_pController)
    {
        m_pController->Release();
    }
}


HRESULT
DiskQuotaUserCollection::Initialize(
    VOID
    )
{
    HRESULT hr = S_FALSE; // Assume already initialized.

    if (NULL == m_pEnum)
    {
        if (NULL == m_pController)
        {
            hr = E_UNEXPECTED;
        }
        else
        {
            hr = m_pController->CreateEnumUsers(NULL,
                                                0,
                                                m_fNameResolution,
                                                &m_pEnum);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::QueryInterface

    Description: Obtain pointer to IUnknown or IEnumDiskQuotaUserVARIANTs.  

    Arguments:
        riid - Reference to requested interface ID.  

        ppvOut - Address of interface pointer variable to accept the
            returned interface pointer.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument is NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUserCollection::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || 
        IID_IEnumVARIANT == riid)
    {
        //
        // Interface supported.
        //
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserCollection::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserCollection::AddRef, 0x%08X  %d -> %d"),
                     this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUserCollection::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUserCollection::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUserCollection::Release, 0x%08X  %d -> %d"),
                     this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


STDMETHODIMP
DiskQuotaUserCollection::Next(
    DWORD cUsers,
    VARIANT *rgvar,
    DWORD *pcUsersFetched
    )
{
    HRESULT hr = E_UNEXPECTED;
    try
    {
        if (NULL == pcUsersFetched && 1 < cUsers)
        {
            //
            // If pcUsersFetched is NULL, cUsers must be 1.
            //
            hr = E_INVALIDARG;
        }
        else
        {
            DWORD cEnumerated = 0;
            PDISKQUOTA_USER *prgUsers = new PDISKQUOTA_USER[cUsers];
            if (NULL != prgUsers)
            {
                hr = m_pEnum->Next(cUsers, prgUsers, &cEnumerated);
                if (SUCCEEDED(hr))
                {
                    for (INT i = 0; i < (INT)cEnumerated; i++)
                    {
                        VariantInit(&rgvar[i]);

                        IDispatch *pIDisp = NULL;
                        hr = prgUsers[i]->QueryInterface(IID_IDispatch, (LPVOID *)&pIDisp);
                        if (SUCCEEDED(hr))
                        {
                            V_VT(&rgvar[i])       = VT_DISPATCH;
                            V_DISPATCH(&rgvar[i]) = pIDisp;
                        }
                        prgUsers[i]->Release();
                    }
                }
                delete[] prgUsers;
            }
            if (NULL != pcUsersFetched)
            {
                *pcUsersFetched = cEnumerated;
            }
        }
    }
    catch(CAllocException& e)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


STDMETHODIMP
DiskQuotaUserCollection::Skip(
    DWORD cUsers
    )
{
    return m_pEnum->Skip(cUsers);
}

STDMETHODIMP
DiskQuotaUserCollection::Reset(
    void
    )
{
    return m_pEnum->Reset();
}


STDMETHODIMP
DiskQuotaUserCollection::Clone(
    IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = E_FAIL;
    try
    {
        DiskQuotaUserCollection *pEnum = new DiskQuotaUserCollection(m_pController,
                                                                     m_fNameResolution);
        if (NULL != pEnum)
        {
            hr = pEnum->Initialize();
            if (SUCCEEDED(hr))
            {
                hr = pEnum->QueryInterface(IID_IEnumVARIANT, (LPVOID *)ppEnum);
            }
            else
            {
                delete pEnum;
            }
        }
    }
    catch(CAllocException& me)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\dynarray.h ===
#ifndef _INC_DSKQUOTA_DYNARRAY_H
#define _INC_DSKQUOTA_DYNARRAY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: dynarray.h

    Description: Wrapper classes around the DPA_xxxxxxx and DSA_xxxxxx functions 
        provided by the common control's library.  The classes add value by 
        providing multi-threaded protection, iterators and automatic cleanup 
        semantics. 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif
#ifndef _INC_COMMCTRL
#   include <commctrl.h>
#endif
#ifndef _INC_COMCTRLP
#   include <comctrlp.h>
#endif
#ifndef _INC_DSKQUOTA_EXCEPT_H
#   include "except.h"
#endif


///////////////////////////////////////////////////////////////////////////////
// CONTAINER EXCEPTIONS
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// POINTER LIST
///////////////////////////////////////////////////////////////////////////////
class PointerList
{
    private:
        HDPA             m_hdpa;
        CRITICAL_SECTION m_cs;

    public:
        PointerList(INT cItemGrow = 0);

        virtual ~PointerList(void);

        UINT Count(void);

        VOID Insert(LPVOID pvItem, UINT index);
        VOID Insert(LPVOID pvItem)
            { Insert(pvItem, 0); }

        VOID Append(LPVOID pvItem, UINT index)
            { Insert(pvItem, index + 1); }
        VOID Append(LPVOID pvItem);

        BOOL Remove(LPVOID *ppvItem, UINT index);
        BOOL RemoveFirst(LPVOID *ppvItem)
            { return Remove(ppvItem, 0); }
        BOOL RemoveLast(LPVOID *ppvItem);

        BOOL Retrieve(LPVOID *ppvItem, UINT index);
        BOOL RetrieveFirst(LPVOID *ppvItem)
            { return Retrieve(ppvItem, 0); }
        BOOL RetrieveLast(LPVOID *ppvItem);

        BOOL Replace(LPVOID pvItem, UINT index);
        BOOL FindIndex(LPVOID pvItem, INT *pIndex);

        BOOL Sort(PFNDPACOMPARE pfnCompare, LPARAM lParam);
        BOOL Search(LPVOID pvKey,
                    PFNDPACOMPARE pfnCompare, 
                    UINT uOptions = 0, 
                    INT iStart = 0,
                    LPARAM lParam = 0);

        void Lock(void)
            { EnterCriticalSection(&m_cs); }
        void ReleaseLock(void)
            { LeaveCriticalSection(&m_cs); }

        friend class PointerListIterator;
        friend class AutoLock;
};



///////////////////////////////////////////////////////////////////////////////
// POINTER LIST ITERATOR
///////////////////////////////////////////////////////////////////////////////
class PointerListIterator {
    private:
        PointerList *m_pList;    // Pointer to list being iterated.
        INT          m_Index;    // "Current" signed index into list.
             
        HRESULT Advance(LPVOID *ppvOut, BOOL bForward);

    public:
        enum { EndOfList = -1 };

        PointerListIterator(PointerList& List)
            : m_pList(&List), 
              m_Index(0) { }

        PointerListIterator(const PointerListIterator& rhs)
            : m_pList(rhs.m_pList), 
              m_Index(rhs.m_Index) { }

        PointerListIterator& operator = (const PointerListIterator& rhs);

        HRESULT Next(LPVOID *ppvOut)  
            { return Advance(ppvOut, TRUE); }

        HRESULT Prev(LPVOID *ppvOut)  
            { return Advance(ppvOut, FALSE); }

        BOOL AtFirst(void)
            { return m_Index == 0; }

        BOOL AtLast(void)
            { return m_Index >= (INT)m_pList->Count() - 1; }
        
        void GotoFirst(void)
            { m_Index = 0; }

        void GotoLast(void)
            { m_Index = m_pList->Count() - 1; }

        void LockList(void)
            { m_pList->Lock(); }

        void ReleaseListLock(void)
            { m_pList->ReleaseLock(); }
};


///////////////////////////////////////////////////////////////////////////////
// POINTER QUEUE
///////////////////////////////////////////////////////////////////////////////
class PointerQueue : public PointerList
{
    public:
        virtual ~PointerQueue(void) { }

        VOID Add(LPVOID pvItem)
            { PointerList::Append(pvItem); }
        BOOL Remove(LPVOID *ppvItem)
            { return PointerList::RemoveFirst(ppvItem); }
};


///////////////////////////////////////////////////////////////////////////////
// STRUCTURE LIST
//
///////////////////////////////////////////////////////////////////////////////
class StructureList
{
    private:
        HDSA             m_hdsa;
        CRITICAL_SECTION m_cs;

    public:
        StructureList(INT cbItem, INT cItemGrow);

        virtual ~StructureList(void);

        UINT    Count(void);

        VOID Insert(LPVOID pvItem, UINT index);
        VOID Insert(LPVOID pvItem)
            { Insert(pvItem, 0); }

        VOID Append(LPVOID pvItem, UINT index)
            { Insert(pvItem, index + 1); }
        VOID Append(LPVOID pvItem);

        BOOL Remove(LPVOID pvItem, UINT index);
        BOOL RemoveFirst(LPVOID pvItem) 
            { return Remove(pvItem, 0); }
        BOOL RemoveLast(LPVOID pvItem); 

        BOOL Retrieve(LPVOID pvItem, UINT index);
        BOOL RetrieveFirst(LPVOID pvItem) 
            { return Retrieve(pvItem, 0); }
        BOOL RetrieveLast(LPVOID pvItem);

        BOOL Replace(LPVOID pvItem, UINT index);
        VOID Clear(VOID);

        void Lock(void)
            { EnterCriticalSection(&m_cs); }
        void ReleaseLock(void)
            { LeaveCriticalSection(&m_cs); }

        friend class StructureListIterator;
        friend class AutoLock;
};





///////////////////////////////////////////////////////////////////////////////
// STRUCTURE LIST ITERATOR
///////////////////////////////////////////////////////////////////////////////
class StructureListIterator {
    private:
        StructureList *m_pList;    // Pointer to list being iterated.
        INT            m_Index;    // "Current" signed index into list.
             
        HRESULT Advance(LPVOID *ppvOut, BOOL bForward);

    public:
        enum { EndOfList = -1 };

        StructureListIterator(StructureList& List)
            : m_pList(&List), 
              m_Index(0) { }

        StructureListIterator(const StructureListIterator& rhs)
            : m_pList(rhs.m_pList), 
              m_Index(rhs.m_Index) { }

        StructureListIterator& operator = (const StructureListIterator& rhs);

        HRESULT Next(LPVOID *ppvOut)  
            { return Advance(ppvOut, TRUE); }

        HRESULT Prev(LPVOID *ppvOut)  
            { return Advance(ppvOut, FALSE); }

        BOOL AtFirst(void)
            { return m_Index == 0; }

        BOOL AtLast(void)
            { return m_Index >= (INT)m_pList->Count() - 1; }
        
        void GotoFirst(void)
            { m_Index = 0; }

        void GotoLast(void)
            { m_Index = m_pList->Count() - 1; }

        void LockList(void)
            { m_pList->Lock(); }

        void ReleaseListLock(void)
            { m_pList->ReleaseLock(); }
};

///////////////////////////////////////////////////////////////////////////////
// STRUCTURE QUEUE
///////////////////////////////////////////////////////////////////////////////
class StructureQueue : public StructureList
{
    public:
        StructureQueue(INT cbItem, INT cItemGrow)
            : StructureList(cbItem, cItemGrow) { }

        virtual ~StructureQueue(void) { }

        VOID Add(LPVOID pvItem)
            { StructureList::Append(pvItem); }
        BOOL Remove(LPVOID pvItem)
            { return StructureList::RemoveFirst(pvItem); }
};

#endif // _INC_DSKQUOTA_DYNARRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\dynarray.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: dynarray.cpp

    Description: Wrapper classes around the DPA_xxxxx and DSA_xxxxx functions 
        provided by the common control's library.  The classes add value by 
        providing multi-threaded protection, iterators and automatic cleanup 
        semantics.  

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "dynarray.h"



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::PointerList

    Description: Constructor.  

    Arguments:
        cItemGrow - Number of items to grow list when expansion is required.
                    Default value is 0 which causes DPA to use 8.

    Returns: Nothing.
    
    Exception: Throws OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
    02/21/97    Added cItemGrow argument.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerList::PointerList(
    INT cItemGrow
    )
      : m_hdpa(NULL)
{
    InitializeCriticalSection(&m_cs);
    if (NULL == (m_hdpa = DPA_CreateEx(cItemGrow, NULL)))
    {
        DeleteCriticalSection(&m_cs);
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::~PointerList

    Description: Destructor.  Destroys the DPA and closes the mutex handle.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerList::~PointerList(
    VOID
    )
{
    Lock();
    if (NULL != m_hdpa)
        DPA_Destroy(m_hdpa);

    ReleaseLock();
    DeleteCriticalSection(&m_cs);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Count

    Description: Returns the number of elements in the list.

    Arguments: None.

    Returns: Count of elements in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT 
PointerList::Count(
    VOID
    )
{
    UINT n = 0;

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    n = DPA_GetPtrCount(m_hdpa);

    return n;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Insert

    Description: Inserts a pointer into the pointer list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Pointer value to add to list.

        index - List index where pointer is to be inserted.  All following
            items are shifted to one index higher.  The list automatically
            grows to accomodate as required.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID 
PointerList::Insert(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));

    if (DPA_InsertPtr(m_hdpa, index, pvItem) < 0)
    {
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Replace

    Description: Replaces a pointer in the pointer list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Pointer value to add to list.

        index - List index where pointer is to be replaced.
          
    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Replace(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));

    return DPA_SetPtr(m_hdpa, index, pvItem);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Append

    Description: Appends a pointer to the end of the list.

    Arguments:
        pvItem - Pointer value to add to list.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
PointerList::Append(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    //
    // Yes, this is correct.  We're "inserting" an item to append something
    // to the list.  This saves a ( count - 1 ) calculation.
    //
    DBGASSERT((NULL != m_hdpa));
    Insert(pvItem, DPA_GetPtrCount(m_hdpa));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Remove

    Description: Removes a pointer from the list at a given index.

    Arguments: 
        ppvItem - Address of variable to contain removed pointer value.

        index - List index where pointer is to be removed.  All following
            items are shifted to one index lower. 

    Returns:
        TRUE  - Success.
        FASLE - Index is invalid (or container is empty).

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Remove(
    LPVOID *ppvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != ppvItem));
    DBGASSERT((NULL != m_hdpa));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    *ppvItem = DPA_DeletePtr(m_hdpa, index);
    if (NULL == *ppvItem)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::RemoveLast

    Description: Removes the last pointer from the list.

    Arguments: 
        ppvItem - Address of variable to contain removed pointer value.
            All following items are shifted to one index lower. 

    Returns: 
        TRUE  - Success.
        FALSE - Container is emtpy.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL 
PointerList::RemoveLast(
    LPVOID *ppvItem
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    if (0 == Count())
        return FALSE;

    Remove(ppvItem, Count() - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Retrieve

    Description: Retrieve a pointer from the list at a given index.
        The pointer value is merely retrieved and not removed from the list.

    Arguments:
        ppvItem - Address of variable to contain retrieved pointer value.

        index - List index where pointer is to be retrieved.  

    Returns: 
        TRUE  - Success.
        FALSE - Invalid index or container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Retrieve(
    LPVOID *ppvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    *ppvItem = DPA_GetPtr(m_hdpa, index);

    if (NULL == *ppvItem)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::RetrieveLast

    Description: Retrieves the last pointer from the list.

    Arguments: 
        ppvItem - Address of variable to contain retrieved pointer value.

    Returns:
        TRUE  - Success.
        FALSE - Container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::RetrieveLast(
    LPVOID *ppvItem
    )
{
    DBGASSERT((NULL != ppvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    if (0 == Count())
        return FALSE;

    Retrieve(ppvItem, Count() - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::FindIndex

    Description: Returns the list index associated with a given pointer
        value.  If duplicates exist, the index of the first item is returned.

    Arguments: 
        pvItem - Pointer value of item to be found.

        pIndex - Address of index variable to hold resulting index.

    Returns:
        TRUE  = Success
        FALSE = Item not found in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
    09/03/96    Changed returned value to BOOL.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::FindIndex(
    LPVOID pvItem, 
    INT *pIndex
    )
{
    INT i = -1;

    DBGASSERT((NULL != pIndex));
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    i = *pIndex = DPA_GetPtrIndex(m_hdpa, pvItem);

    if (-1 == i)
        return FALSE;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Sort

    Description: Sorts the list given a comparison function.

    Arguments: 
        pfnCompare - Address of comparison callback.

        lParam - 32-bit parameter passed to the callback.

    Returns:
        TRUE  = Success
        FALSE = Item not found in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
PointerList::Sort(
    PFNDPACOMPARE pfnCompare, 
    LPARAM lParam
    )
{
    DBGASSERT((NULL != pfnCompare));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    DBGASSERT((NULL != pfnCompare));

    return DPA_Sort(m_hdpa, pfnCompare, lParam);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerList::Search

    Description: Searches the list for a given item.

    Arguments: 
        pvKey - Address of key item used for search.

        pfnCompare - Address of comparison callback.

        uOptions - Options controlling sort operation.
            DPAS_SORTED       = Array is already sorted.  
                                Will use binary search.
            DPAS_INSERTBEFORE = If no exact match is found, return index of
                                previous best match.
            DPAS_INSERTAFTER  = If no exact match is found, return index of
                                next best match.

        iStart - Index of where to start search.  0 for start of list.

        lParam - 32-bit parameter passed to the callback.

    Returns: Index of found item or -1 if none found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
PointerList::Search(
    LPVOID pvKey,
    PFNDPACOMPARE pfnCompare, 
    UINT uOptions,
    INT iStart,
    LPARAM lParam
    )
{
    DBGASSERT((NULL != pfnCompare));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will automatically release.

    DBGASSERT((NULL != m_hdpa));
    DBGASSERT((NULL != pvKey));
    DBGASSERT((NULL != pfnCompare));

    return DPA_Search(m_hdpa, pvKey, iStart, pfnCompare, lParam, uOptions);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerListIterator::operator = 

    Description: Assignment for PointerListIterator.

    Arguments:
        rhs - Reference to constant iterator that is the rhs of the assignment.

    Returns:
        Returns a reference to "this" iterator object following the assignment.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
PointerListIterator&
PointerListIterator::operator = (
    const PointerListIterator& rhs
    )
{
    if (this != &rhs)
    {
        m_pList = rhs.m_pList;
        m_Index = rhs.m_Index;
    }
    return *this;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: PointerListIterator::Advance

    Description: Both the Next() and Prev() iterator functions call this
        one function.  It handles the actual iteration.

    Arguments:
        ppvOut - Address of pointer variable to contain the value of the 
            pointer at the "current" iterator location.  The iterator is
            advance (or retreated) after the pointer value is copied to the
            destination.

        bForward - TRUE  = Advance toward end of list.
                   FALSE = Advance toward front of list.

    Returns:
        NO_ERROR      - Iterator advanced.  Returned pointer is valid.
        E_FAIL        - Iterator already at begining or end of list.  Returned
                        pointer will be NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
PointerListIterator::Advance(
    LPVOID *ppvOut, 
    BOOL bForward
    )
{
    LPVOID pv       = NULL;
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != ppvOut));

    m_pList->Lock();
    if (0 < m_pList->Count() && m_Index != EndOfList)
    {
        //
        // Get pointer value at index "m_Index".
        //
        DBGASSERT((NULL != m_pList->m_hdpa));
        pv = DPA_GetPtr(m_pList->m_hdpa, m_Index);

        if (bForward)
        {
            //
            // Advance iterator index.
            //
            if ((UINT)(++m_Index) == m_pList->Count())
                m_Index = EndOfList;
        }
        else
        {
            //
            // Retreat iterator index.
            //
            m_Index--;  // Will be -1 (EndOfList) if currently 0.
        }
    }
    else
        hResult = E_FAIL;

    m_pList->ReleaseLock();

    *ppvOut = pv;  // Return pointer value.

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::StructureList

    Description: Constructor.

    Arguments:
        cbItem - Size of each item in bytes.

        cItemGrow - Number of items to grow array at each expansion.


    Returns: Nothing.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureList::StructureList(
    INT cbItem, 
    INT cItemGrow
    )
{
    InitializeCriticalSection(&m_cs);

    if (NULL == (m_hdsa = DSA_Create(cbItem, cItemGrow)))
    {
        DeleteCriticalSection(&m_cs);
        throw CAllocException();
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::~StructureList

    Description: Destructor.  Destroys the DSA and closes the mutex handle.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureList::~StructureList(void)
{
    Lock();

    if (NULL != m_hdsa)
        DSA_Destroy(m_hdsa);

    ReleaseLock();
    DeleteCriticalSection(&m_cs);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureListIterator::operator = 

    Description: Assignment for StructureListIterator.

    Arguments:
        rhs - Reference to constant iterator that is the rhs of the assignment.

    Returns:
        Returns a reference to "this" iterator object following the assignment.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
StructureListIterator&
StructureListIterator::operator = (
    const StructureListIterator& rhs
    )
{
    if (this != &rhs)
    {
        m_pList = rhs.m_pList;
        m_Index = rhs.m_Index;
    }
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Count

    Description: Returns the number of elements in the list.

    Arguments: None.

    Returns: Count of elements in list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT StructureList::Count(VOID)
{
    UINT n = 0;

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));
    n = DSA_GetItemCount(m_hdsa);

    return n;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Insert

    Description: Insert an item into the Structure list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Address of item to add to list.

        index - List index where item is to be inserted.  All following
            items are shifted to one index higher.  The list automatically
            grows to accomodate as required.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Insert(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);   // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    if (DSA_InsertItem(m_hdsa, index, pvItem) < 0)
    {
        throw CAllocException();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Replace

    Description: Replaces an item in the Structure list at a given index.
        If the index is beyond the upper bounds of the array, the array
        is extended by one and the item is appended to the list.

    Arguments:
        pvItem - Address of item to replace existing item.

        index - List index where item is to be replaced.  

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Replace(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    return DSA_SetItem(m_hdsa, index, pvItem);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Append

    Description: Appends an item to the end of the list.

    Arguments:
        pvItem - Address of item to add to list.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
    09/06/96    Added exception handling.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Append(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container. Will auto-release.
    //
    // Yes, this is correct.  We're "inserting" an item to append something
    // to the list.  This saves a ( count - 1 ) calculation.
    //
    DBGASSERT((NULL != m_hdsa));
    Insert(pvItem, DSA_GetItemCount(m_hdsa));
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Remove

    Description: Removes an item from the list at a given index.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

        index - List index where item is to be removed.  All following
            items are shifted to one index lower. 

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or container is empty.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Remove(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (!DSA_GetItem(m_hdsa, index, pvItem) ||
        !DSA_DeleteItem(m_hdsa, index))
    {
        return FALSE;
    }
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Retrieve

    Description: Retrieve an item from the list at a given index.
        The item value is merely copied and not removed from the list.

    Arguments:
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

        index - List index where item is to be retrieved.  

    Returns:
        TRUE  - Success.
        FALSE - Invalid index or empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::Retrieve(
    LPVOID pvItem, 
    UINT index
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (!DSA_GetItem(m_hdsa, index, pvItem))
    {
        return FALSE;
    }
    return TRUE;
}

    
///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::RemoveLast

    Description: Removes the last item from the list.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

    Returns:
        TRUE  - Success.
        FALSE - Empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::RemoveLast(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));

    if (0 == DSA_GetItemCount(m_hdsa))
        return FALSE;

    Remove(pvItem, DSA_GetItemCount(m_hdsa) - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::RetrieveLast

    Description: Retrieves the last pointer from the list.

    Arguments: 
        pvItem - Address of buffer to receive removed item.  Assumes buffer
            is sized properly.

    Returns:
        TRUE  - Success.
        FALSE - Empty container.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
StructureList::RetrieveLast(
    LPVOID pvItem
    )
{
    DBGASSERT((NULL != pvItem));

    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.
    DBGASSERT((NULL != m_hdsa));

    if (0 == DSA_GetItemCount(m_hdsa))
        return FALSE;

    Retrieve(pvItem, DSA_GetItemCount(m_hdsa) - 1);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureList::Clear

    Description: Removes all items from the list.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/26/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
StructureList::Clear(
    VOID
    )
{
    AutoLockCs lock(m_cs);  // Get lock on container.  Will auto-release.

    DBGASSERT((NULL != m_hdsa));
    DSA_DeleteAllItems(m_hdsa);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: StructureListIterator::Advance

    Description: Both the Next() and Prev() iterator functions call this
        one function.  It handles the actual iteration.

    Arguments:
        ppvOut - Address of pointer variable to receive the address of the 
            item at the "current" iterator location.  The iterator is
            advance (or retreated) after the pointer value is copied to the
            destination.

        bForward - TRUE  = Advance toward end of list.
                   FALSE = Advance toward front of list.

    Returns:
        NO_ERROR      - Iterator advanced.  Returned pointer is valid.
        E_FAIL        - Iterator already at begining or end of list.  Returned
                        pointer will be NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/24/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
StructureListIterator::Advance(
    LPVOID *ppvOut, 
    BOOL bForward
    )
{
    LPVOID pv       = NULL;
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != ppvOut));

    m_pList->Lock();
    if (0 < m_pList->Count() && m_Index != EndOfList)
    {
        //
        // Get address of item at index "m_Index".
        //
        DBGASSERT((NULL != m_pList->m_hdsa));
        pv = DSA_GetItemPtr(m_pList->m_hdsa, m_Index);

        if (bForward)
        {
            //
            // Advance iterator index.
            //
            if ((UINT)(++m_Index) == m_pList->Count())
                m_Index = EndOfList;
        }
        else
        {
            //
            // Retreat iterator index.
            //
            m_Index--;  // Will be -1 (EndOfList) if currently 0.
        }
    }
    else
        hResult = E_FAIL;

    m_pList->ReleaseLock();
    *ppvOut = pv;  // Return pointer value.

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\extinit.h ===
#ifndef _INC_DSKQUOTA_EXTINIT_H
#define _INC_DSKQUOTA_EXTINIT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: extinit.h

    Description: Contains declarations for disk quota shell extensions.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _INC_DSKQUOTA_UTILS_H
#   include "utils.h"
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

class ShellExtInit : public IShellExtInit
{
    private:
        LONG      m_cRef;
        CVolumeID m_idVolume; // Contains strings for parsing and display.

        HRESULT Create_IShellPropSheetExt(REFIID riid, LPVOID *ppvOut);
        HRESULT Create_ISnapInPropSheetExt(REFIID riid, LPVOID *ppvOut);

    public:
        ShellExtInit(VOID)
            : m_cRef(0) { }

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IShellExtInit methods.
        //
        STDMETHODIMP
        Initialize(
            LPCITEMIDLIST pidlFolder,
            IDataObject *pDataObj,
            HKEY hkeyProgID);
};



#endif // _INC_DSKQUOTA_EXTINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\details.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: details.cpp

    Description: Contains definition for class DetailsView.
        This class implements a list view containing quota information about
        the various accounts in a volume's quota information file.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/28/97    Major changes.                                       BrianAu
                - Added "User Finder".
                - Added promotion of selected item to front of
                  name resolution queue.
                - Improved name resolution status reporting through
                  listview.
                - Moved drag/drop and report generation code
                  from dragdrop.cpp and reptgen.cpp into the
                  DetailsView class.  DetailsView now implements
                  IDataObject, IDropSource and IDropTarget instead
                  of deferring implementation to secondary objects.
                  dragdrop.cpp and reptgen.cpp have been dropped
                  from the project.
                - Added support for CF_HDROP and private import/
                  export clipboard formats.
                - Added import/export functionality.
    07/28/97    Removed export support for CF_HDROP.  Replaced       BrianAu
                with FileContents and FileGroupDescriptor.  Import
                from CF_HDROP is still supported.
                Added Import Source object hierarchy.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include <htmlhelp.h>
#include <commctrl.h>
#include <commdlg.h>

#include "uihelp.h"
#include "uiutils.h"
#include "dskquota.h"
#include "registry.h"
#include "resource.h"
#include "shellinc.h"
#include "userprop.h"
#include "details.h"
#include "guidsp.h"
#include "mapfile.h"
#include "progress.h"
#include "yntoall.h"
#include "ownerlst.h"
#include "ownerdlg.h"
#include "adusrdlg.h"
//
// Constant text strings.
//
TCHAR c_szWndClassDetailsView[]   = TEXT("DetailsView");

//
// Bitmap dimension constants.
//
const UINT BITMAP_WIDTH     = 16;
const UINT BITMAP_HEIGHT    = 16;
const UINT LG_BITMAP_WIDTH  = 32;
const UINT LG_BITMAP_HEIGHT = 32;

//
// How much to grow the user object list whenever expansion is required.
//
const INT USER_LIST_GROW_AMT = 100;

//
// This structure is used to pass the DetailsView object's "this" pointer
// in WM_CREATE.
//
typedef struct WndCreationData {
    SHORT   cbExtra;
    LPVOID  pThis;
} WNDCREATE_DATA;

typedef UNALIGNED WNDCREATE_DATA *PWNDCREATE_DATA;

//
// Structure passed to CompareItems callback.
//
typedef struct comparestruct
{
    DWORD idColumn;
    DWORD dwDirection;
    DetailsView *pThis;
} COMPARESTRUCT, *PCOMPARESTRUCT;


//
// Define some names for indexes into the listview's image list.
//
#define iIMAGELIST_ICON_NOIMAGE       (-1)
#define iIMAGELIST_ICON_OK              0
#define iIMAGELIST_ICON_WARNING         1
#define iIMAGELIST_ICON_LIMIT           2

//
// The 0-based index of the "View" item in the main menu and of the
// "Arrange" item in the view menu.
// WARNING:  If you change menu items, these may need updating.
//
#define iMENUITEM_VIEW                  2
#define iMENUITEM_VIEW_ARRANGE          4
//
// Same thing for the "Edit" menu.
//
#define iMENUITEM_EDIT                  1

//
// Add/remove from this array to change the columns in the list view.
// IMPORTANT:
//     The ordering of these items is very important (sort of).
//     Because of a bug in commctrl.h, they don't paint under the bitmap
//     if it's the only thing in the column (or if it's the bitmap of the primary
//     item).  Also, the behavior of the listview is such that the text in
//     subitem 0 is always shifted right the width of a small bitmap.  When
//     I had the status column NOT as item 0, there were two display problems.
//     1) First, the text in column 0 was always shifted right to allow for the
//        bitmap we weren't using.  This looked funny.
//     2) The full-row-select highlight didn't properly paint the background
//        of the status bitmap.
//
//     By placing the status column as subitem 0, we eliminate problem 1 since
//     we're using a bitmap in subitem 0 (listview's default behavior).
//     If we drag the status column out of the leftmost position, they still don't
//     paint under the bitmap but at least it will work like any other explorer
//     view.  When/if they fix listview, we'll be fixed automatically.
//
const DV_COLDATA g_rgColumns[] = {
    { LVCFMT_LEFT |
      LVCFMT_COL_HAS_IMAGES,
                     0, IDS_TITLE_COL_STATUS,    DetailsView::idCol_Status      },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_FOLDER,    DetailsView::idCol_Folder      },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_USERNAME,  DetailsView::idCol_Name        },
    { LVCFMT_LEFT,   0, IDS_TITLE_COL_LOGONNAME, DetailsView::idCol_LogonName   },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_AMTUSED,   DetailsView::idCol_AmtUsed     },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_LIMIT,     DetailsView::idCol_Limit       },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_THRESHOLD, DetailsView::idCol_Threshold   },
    { LVCFMT_RIGHT,  0, IDS_TITLE_COL_PCTUSED,   DetailsView::idCol_PctUsed     },
    };

//
// User quota state constants.
// used for identifying which icon to display in "Status" column.
//
const INT iUSERSTATE_OK        = 0;
const INT iUSERSTATE_WARNING   = 1;
const INT iUSERSTATE_OVERLIMIT = 2;

//
// Maximum number of entries allowed in the "Find User" MRU list.
//
const INT DetailsView::MAX_FINDMRU_ENTRIES = 10;

//
// Dimensions for the "Find User" combo box in the toolbar.
//
const INT DetailsView::CX_TOOLBAR_COMBO    = 200;
const INT DetailsView::CY_TOOLBAR_COMBO    = 200;


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DetailsView

    Description: Class constructor.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DetailsView(
    VOID
    ) : m_cRef(0),
        m_UserList(USER_LIST_GROW_AMT),
        m_hwndMain(NULL),
        m_hwndListView(NULL),
        m_hwndStatusBar(NULL),
        m_hwndToolBar(NULL),
        m_hwndListViewToolTip(NULL),
        m_hwndHeader(NULL),
        m_hKbdAccel(NULL),
        m_lpfnLVWndProc(NULL),
        m_pQuotaControl(NULL),
        m_pUserFinder(NULL),
        m_DropSource(MK_LBUTTON),
        m_DropTarget(MK_LBUTTON),
        m_pDataObject(NULL),
        m_pUndoList(NULL),
        m_ColMap(ARRAYSIZE(g_rgColumns)),
        m_strAccountUnresolved(g_hInstDll, IDS_USER_ACCOUNT_UNRESOLVED),
        m_strAccountUnavailable(g_hInstDll, IDS_USER_ACCOUNT_UNAVAILABLE),
        m_strAccountUnknown(g_hInstDll, IDS_USER_ACCOUNT_UNKNOWN),
        m_strAccountDeleted(g_hInstDll, IDS_USER_ACCOUNT_DELETED),
        m_strAccountInvalid(g_hInstDll, IDS_USER_ACCOUNT_INVALID),
        m_strNoLimit(g_hInstDll, IDS_NO_LIMIT),
        m_strNotApplicable(g_hInstDll, IDS_NOT_APPLICABLE),
        m_strStatusOK(g_hInstDll, IDS_STATUS_OK),
        m_strStatusWarning(g_hInstDll, IDS_STATUS_WARNING),
        m_strStatusOverlimit(g_hInstDll, IDS_STATUS_OVERLIMIT),
        m_pIDataObjectOnClipboard(NULL),
        m_dwEventCookie(0),
        m_iLastItemHit(-1),
        m_iLastColSorted(-1),
        m_fSortDirection(0),
        m_bMenuActive(FALSE),
        m_bWaitCursor(FALSE),
        m_bStopLoadingObjects(FALSE),
        m_bDestroyingView(FALSE)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DetailsView")));

    //
    // Make sure the idCol_XXX constants agree
    // with the size of g_rgColumns.
    //
    DBGASSERT((ARRAYSIZE(g_rgColumns) == DetailsView::idCol_Last));

    ZeroMemory(&m_lvsi, sizeof(m_lvsi));
    m_ptMouse.x     = 0;
    m_ptMouse.y     = 0;

    InitializeCriticalSection(&m_csAsyncUpdate);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Initialize

    Description: Initializes a new details view object.

    Arguments:
        idVolume - Ref to a const CVolumeID object containing both the
            parsable and displayable names for the volume.

    Returns: TRUE  = Success.
             FALSE = Out of memory or couldn't create thread.
                     Either way, we can't run the view.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/06/96    Initial creation.  Moved this code out of the ctor.  BrianAu
    02/25/97    Removed m_hwndPropPage from DetailsView.             BrianAu
    05/20/97    Added user finder object.                            BrianAu
    06/28/98    Added support for mounted volumes.                   BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::Initialize(
    const CVolumeID& idVolume
    )
{
    BOOL bResult   = FALSE;
    HANDLE hThread = NULL;

    try
    {
        //
        // Create the reg parameter objects we'll be using in the UI.
        // The RegParamTable functions will not add a duplicate entry.
        //
        //
        // Parameter: Preferences
        //
        LV_STATE_INFO lvsi;
        InitLVStateInfo(&lvsi);

        //
        // Create a private copy of the file sys object name string.
        // This can throw OutOfMemory.
        //
        m_idVolume = idVolume;
        if (FAILED(CreateVolumeDisplayName(m_idVolume, &m_strVolumeDisplayName)))
        {
            m_strVolumeDisplayName = m_idVolume.ForDisplay();
        }

        //
        // Read saved state of listview from registry.
        // Saved info includes window ht/wd, column widths and
        // toolbar/status bar visibility.  Need this info before we start thread.
        //
        RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
        if (FAILED(keyPref.Open(KEY_READ)) ||
            FAILED(keyPref.GetValue(REGSTR_VAL_PREFERENCES, (LPBYTE)&m_lvsi, sizeof(m_lvsi))) ||
            !DetailsView::IsValidLVStateInfo(&m_lvsi))
        {
            //
            // Protect us from truly bogus data.  If it's bad, or obsolete,
            // just re-initialize it.
            //
            DBGERROR((TEXT("Listview persist state info invalid.  Re-initializing.")));
            DetailsView::InitLVStateInfo(&m_lvsi);
        }

        //
        // Transfer sorting information to member variables.
        // These can be changed by user-initiated events.
        //
        m_iLastColSorted  = m_lvsi.iLastColSorted;
        m_fSortDirection  = m_lvsi.fSortDirection;

        //
        // Create the user finder object.
        // This is used to locate users through the toolbar combo box and
        // the "Find User" dialog.  The finder object maintains a MRU list for
        // both the toolbar and dialog combos.
        //
        m_pUserFinder = new Finder(*this, MAX_FINDMRU_ENTRIES);

        //
        // Create the data object we use to control data transfers.
        //
        m_pDataObject = new DataObject(*this);

        //
        // Create a new thread on which to run the details view window.
        // This is so that the details view will remain alive if the
        // property page is destroyed.  This must be done last in this method
        // so that if we return FALSE, the caller is assured there is no thread
        // running loose.  If we return FALSE, they'll have to call "delete"
        // to release any string allocations done above.  If we return TRUE,
        // the caller must not call delete on the object.  The object will
        // destroy itself when the user closes the view window.
        //
        hThread = CreateThread(NULL,        // No security attributes.
                               0,           // Default stack size.
                               &ThreadProc,
                               this,        // Static thread proc needs this.
                               0,           // Not suspended.
                               NULL);
        if (NULL != hThread)
        {
            CloseHandle(hThread);
            //
            // Everything succeeded.
            //
            bResult = TRUE;
        }
    }
    catch(CAllocException& e)
    {
        //
        // Catch an allocation exception here.
        // We'll return FALSE indicating initialization failure.
        //
    }
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::~DetailsView

    Description: Class destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
    05/20/97    Added user finder object.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::~DetailsView(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::~DetailsView")));

    //
    // Destroy the user object list if it still has some objects.
    //
    ReleaseObjects();

    delete m_pUserFinder;
    delete m_pUndoList;
    delete m_pDataObject;

    DeleteCriticalSection(&m_csAsyncUpdate);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryInterface

    Description: Returns an interface pointer to the object's supported
        interfaces.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hResult = NO_ERROR;

    if (NULL != ppv)
    {
        *ppv = NULL;

        if (IID_IUnknown == riid || IID_IDiskQuotaEvents == riid)
        {
            *ppv = static_cast<IDiskQuotaEvents *>(this);
        }
        else if (IID_IDataObject == riid)
        {
            *ppv = static_cast<IDataObject *>(this);
        }
        else if (IID_IDropSource == riid)
        {
            *ppv = static_cast<IDropSource *>(this);
        }
        else if (IID_IDropTarget == riid)
        {
            *ppv = static_cast<IDropTarget *>(this);
        }
        else
            hResult = E_NOINTERFACE;

        if (NULL != *ppv)
        {
            ((LPUNKNOWN)*ppv)->AddRef();
        }
    }
    else
        hResult = E_INVALIDARG;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DetailsView::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DetailsView::AddRef, 0x%08X  %d -> %d\n"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
DetailsView::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DetailsView::Release, 0x%08X  %d -> %d\n"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ThreadProc

    Description: Thread procedure for the details view window.  Creates the
        quota control object and the main window.  Then it just sits
        processing messages until it receives a WM_QUIT message.

    Arguments:
        pvParam - Address of DetailsView instance.

    Returns:
        Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    03/22/00    Fixed proc param for ia64.                           BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DWORD
DetailsView::ThreadProc(
    LPVOID pvParam
    )
{
    HRESULT hResult = NO_ERROR;
    DetailsView *pThis = (DetailsView *)pvParam;

    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("LISTVIEW - New thread %d"), GetCurrentThreadId()));

    DBGASSERT((NULL != pThis));

    //
    // Need to ensure DLL stays loaded while this thread is active.
    //
    InterlockedIncrement(&g_cRefThisDll);
    //
    // This will keep the view object alive while the thread is alive.
    // We call Release when the thread terminates.
    //
    pThis->AddRef();

    //
    // Must call OleInitialize() for new thread.
    //
    try
    {
        if (SUCCEEDED(OleInitialize(NULL)))
        {
            //
            // Create the quota control object.
            // Why don't we just use the same quota controller as the
            // volume property page?  Good question.
            // Since we're on a separate thread, we either need a new
            // object or marshal the IDiskQuotaControl interface.
            // I chose to create a new object rather than take the
            // performance hit of the additional marshaling.  The quota
            // controller object is used heavily by the details view.
            //
            hResult = CoCreateInstance(CLSID_DiskQuotaControl,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IDiskQuotaControl,
                                       (LPVOID *)&(pThis->m_pQuotaControl));

            if (SUCCEEDED(hResult))
            {
                hResult = pThis->m_pQuotaControl->Initialize(pThis->m_idVolume.ForParsing(),
                                                             TRUE); // Read-write.

                if (SUCCEEDED(hResult))
                {
                    //
                    // Create the main window.
                    //
                    hResult = pThis->CreateMainWindow();
                    if (SUCCEEDED(hResult))
                    {
                        MSG msg;
                        DBGASSERT((NULL != pThis->m_hwndMain));
                        //
                        // Place a message in the queue that the window has been
                        // created.  Now creation of the other controls can procede.
                        //
                        // It is VERY important that once we receive a WM_QUIT message,
                        // no members of the DetailsView instance are referenced.
                        // Posting WM_QUIT is the last thing done by the WM_DESTROY handler.
                        //
                        PostMessage(pThis->m_hwndMain, WM_MAINWINDOW_CREATED, 0, 0);

                        while (0 != GetMessage(&msg, NULL, 0, 0))
                        {
                            if (NULL == pThis->m_hKbdAccel ||
                               !TranslateAccelerator(pThis->m_hwndMain,
                                                     pThis->m_hKbdAccel,
                                                     &msg))
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }
                }
            }
            else
            {
                DBGERROR((TEXT("LISTVIEW - OleInitialize failed for thread %d."),
                         GetCurrentThreadId()));
            }
            OleUninitialize();
        }
    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

        pThis->CleanupAfterAbnormalTermination();
    }

    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("LISTVIEW - Exit thread %d"), GetCurrentThreadId()));

    //
    // Release the view object since it's no longer required.
    // This will call the destructor.
    //
    pThis->Release();
    InterlockedDecrement(&g_cRefThisDll);

    return 0;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CleanupAfterAbnormalTermination

    Description: Perform operations required after the thread has terminated
        abnormally.  This function assumes that the thread's message pump is
        no longer active.  Any operations performed must not generate messages
        that require processing by the thread.

        This method does almost the same things as OnDestroy().

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::CleanupAfterAbnormalTermination(
    VOID
    )
{
    //
    // Cancel subclassing of the listview control.
    //
    if (NULL != m_lpfnLVWndProc)
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)m_lpfnLVWndProc);

    DisconnectEventSink();
    //
    // NOTE:  We can't call ReleaseObjects() because that method
    //        requires an active listview.  Our thread is finished and the
    //        window is gone.
    //
    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // If we have a data object on the clipboard, clear the clipboard.
    // Note that the clipboard holds the reference to the data object.
    // When we clear the clipboard, the data object will be released.
    //
    if (NULL != m_pIDataObjectOnClipboard &&
       S_OK == OleIsCurrentClipboard(m_pIDataObjectOnClipboard))
    {
        OleFlushClipboard();
    }
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnUserNameChanged

    Description: Called by the event source (SidNameResolver) whenever a disk
        quota user object's name has changed.  The user object's folder and
        account name strings are updated in the list view.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object that has
            a new name.

    Returns:
        NO_ERROR     - Success.
        E_INVALIDARG - User object pointer received from event source was invalid.
        E_FAIL       - User not found in listview list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/10/96    Use free-threading OLE apartment model.              BrianAu
    02/05/98    Changed ListView_RedrawItems to use                  BrianAu
                SendMessageTimeout().

*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::OnUserNameChanged(
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = E_FAIL;

    //
    // Ensure the DetailsView object stay's alive while the view is updated.
    // Remember, this code is being run on the SID/Name resolver's thread.
    //
    AddRef();

    //
    // We don't want to perform a user-name-changed update if the
    // view is being or has been destroyed.  Likewise, we don't want to
    // destroy the view window while a user-name-changed update is in
    // progress.  The crit sec m_csAsyncUpdate and the flag m_bDestroyingView
    // work together to ensure this.
    //
    EnterCriticalSection(&m_csAsyncUpdate);
    if (!m_bDestroyingView)
    {
        try
        {
            if (NULL != pUser)
            {
                INT iItem = -1;

                if (m_UserList.FindIndex((LPVOID)pUser, &iItem))
                {
                    //
                    // Send message to listview to redraw the item
                    // that changed.  Use the "timeout" version of
                    // SendMessage because the main window thread
                    // could be blocked waiting for m_csAsyncUpdate
                    // which is now owned by the resolver thread.
                    // If the main thread is blocked (waiting to
                    // process WM_DESTROY), this call will return 0
                    // after 5 seconds.  If this happens, we leave the
                    // CS without generating a window update, releasing
                    // the CS and letting the main window thread continue
                    // with WM_DESTROY processing.
                    //
                    DWORD_PTR dwResult;
                    LRESULT lResult = SendMessageTimeout(m_hwndListView,
                                                         LVM_REDRAWITEMS,
                                                         (WPARAM)iItem,
                                                         (LPARAM)iItem,
                                                         SMTO_BLOCK,
                                                         5000,
                                                         &dwResult);
                    if (lResult)
                        UpdateWindow(m_hwndListView);
                    else
                        DBGERROR((TEXT("ListView update timed out after 5 seconds")));

                    hResult = NO_ERROR;
                }
            }
            else
                hResult = E_INVALIDARG;
        }
        catch(CAllocException& e)
        {
            //
            // Catch allocation exceptions and do nothing.
            // Resolver doesn't care about return value.
            // Want to ensure that Release() is called no matter what.
            //
            hResult = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&m_csAsyncUpdate);

    Release();

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateMainWindow

    Description: Creates the main window for the details view.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Couldn't create window.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateMainWindow(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    WNDCLASSEX wc;
    DWORD dwExStyle;
    LANGID LangID;

    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_PARENTDC;
    wc.lpfnWndProc      = WndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hInstDll;
    wc.hIcon            = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_QUOTA));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = NULL;
    wc.lpszMenuName     = MAKEINTRESOURCE(IDM_LISTVIEW_MENU);
    wc.lpszClassName    = c_szWndClassDetailsView;
    wc.hIconSm          = NULL;

    RegisterClassEx(&wc);

    //
    // Need to pass "this" pointer in WM_CREATE.  We'll store "this"
    // in the window's USERDATA.
    //
    WNDCREATE_DATA wcd;
    wcd.cbExtra = sizeof(WNDCREATE_DATA);
    wcd.pThis   = this;

    //
    // Create the window title string.
    // "Quota Details for My Disk (X:)"
    //
    CString strWndTitle(g_hInstDll, IDS_TITLE_MAINWINDOW, (LPCTSTR)m_strVolumeDisplayName);

    HWND hwndDesktop   = GetDesktopWindow();
    HDC hdc            = GetDC(hwndDesktop);

    //
    // Get current screen resolution.
    //
    if ((m_lvsi.cxScreen != (WORD)GetDeviceCaps(hdc, HORZRES)) ||
        (m_lvsi.cyScreen != (WORD)GetDeviceCaps(hdc, VERTRES)))
    {
        //
        // Screen resolution has changed since listview state data was
        // last saved to registry.  Use the default window ht/wd.
        //
        m_lvsi.cx = 0;
        m_lvsi.cy = 0;
    }
    ReleaseDC(hwndDesktop, hdc);


    // Check if we are running on BiDi Localized build. we need to create the Main Window 
    // mirrored (WS_EX_LAYOUTRTL).
    dwExStyle = 0;
    LangID = GetUserDefaultUILanguage();
    if( LangID )
    {
       LCID   iLCID;
       WCHAR wchLCIDFontSignature[16];
       iLCID = MAKELCID( LangID , SORT_DEFAULT );

        if( GetLocaleInfoW( iLCID ,
                           LOCALE_FONTSIGNATURE ,
                           (WCHAR *) &wchLCIDFontSignature[0] ,
                           (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
           if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
           {
              dwExStyle = WS_EX_LAYOUTRTL;
           }
        }
    }


    m_hwndMain = CreateWindowEx(dwExStyle,
                              c_szWndClassDetailsView,
                              strWndTitle,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              m_lvsi.cx ? m_lvsi.cx : CW_USEDEFAULT,
                              m_lvsi.cy ? m_lvsi.cy : CW_USEDEFAULT,
                              hwndDesktop,
                              NULL,
                              g_hInstDll,
                              &wcd);
    if (NULL != m_hwndMain)
    {
        //
        // Register the main window as an OLE drop target.
        //
        RegisterAsDropTarget(TRUE);
    }
    else
    {
        hResult = E_FAIL;
    }

#if DBG
    if (FAILED(hResult))
        DBGERROR((TEXT("LISTVIEW - Failed creating main window."), hResult));
#endif

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateListView

    Description: Create the list view control.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create listview or load icons.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Modified to use virtual listview (LVS_OWNERDATA)     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateListView(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    RECT rc;

    DBGASSERT((NULL != m_hwndMain));

    GetClientRect(m_hwndMain, &rc);

    m_hwndListView = CreateWindowEx(WS_EX_CLIENTEDGE,
                                    WC_LISTVIEW,
                                    TEXT(""),
                                    WS_CHILD | WS_CLIPCHILDREN |
                                    WS_VISIBLE | WS_CLIPSIBLINGS |
                                    WS_TABSTOP | LVS_REPORT | LVS_SHOWSELALWAYS |
                                    LVS_OWNERDATA,
                                    0, 0,
                                    rc.right - rc.left,
                                    rc.bottom - rc.top,
                                    m_hwndMain,
                                    (HMENU)NULL,
                                    g_hInstDll,
                                    NULL);
    if (NULL != m_hwndListView)
    {
        //
        // Store "this" ptr so subclass WndProc can access members.
        //
        SetWindowLongPtr(m_hwndListView, GWLP_USERDATA, (INT_PTR)this);

        //
        // We talk to the header control so save it's handle.
        //
        m_hwndHeader = ListView_GetHeader(m_hwndListView);

        //
        // Subclass the listview control so we can monitor mouse position.
        // This is used for listview tooltip management.
        //
        m_lpfnLVWndProc = (WNDPROC)GetWindowLongPtr(m_hwndListView, GWLP_WNDPROC);
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)LVSubClassWndProc);

        //
        // Enable listview for images in sub-item columns and full-row select.
        //
        ListView_SetExtendedListViewStyle(m_hwndListView,
                                          LVS_EX_SUBITEMIMAGES |
                                          LVS_EX_FULLROWSELECT |
                                          LVS_EX_HEADERDRAGDROP);

        //
        // Add all columns to the listview.
        // Adjust for showing/hiding the Folder column.
        //
        INT iColId = 0; // Start with 1st col.
        for (INT iSubItem = 0;
             iSubItem < (m_lvsi.fShowFolder ? DetailsView::idCol_Last : DetailsView::idCol_Last - 1);
             iSubItem++)
        {
            AddColumn(iSubItem, g_rgColumns[iColId]);
            iColId++;

            //
            // Skip over the Folder column if it's hidden.
            //
            if (!m_lvsi.fShowFolder && DetailsView::idCol_Folder == iColId)
                iColId++;
        }

        //
        // Restore column widths to where the user left them last time
        // the details view was used.
        //
        if (m_lvsi.cb == sizeof(LV_STATE_INFO))
        {
            for (UINT i = 0; i < DetailsView::idCol_Last; i++)
            {
                if (0 != m_lvsi.rgcxCol[i])
                {
                    ListView_SetColumnWidth(m_hwndListView, i, m_lvsi.rgcxCol[i]);
                }
            }
        }

        //
        // Restore the user's last column ordering.
        //
        DBGASSERT((Header_GetItemCount(m_hwndHeader) <= ARRAYSIZE(m_lvsi.rgColIndices)));

        Header_SetOrderArray(m_hwndHeader, Header_GetItemCount(m_hwndHeader),
                             m_lvsi.rgColIndices);

        //
        // Check the "Show Folder" menu item to indicate the current visibility state
        // of the Folder column.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_SHOWFOLDER,
                      MF_BYCOMMAND | (m_lvsi.fShowFolder ? MF_CHECKED : MF_UNCHECKED));

        //
        // Set the sensitivity of the "by Folder" item arrangement menu option.
        //
        EnableMenuItem_ArrangeByFolder(m_lvsi.fShowFolder);

        //
        // Create and activate the listview tooltip window.
        // Even though the standard listview has a tooltip window, we need more
        // control that it provides.  i.e.:  We need to be able to enable/disable
        // the tooltip as well as notify the control when a new listview item
        // has been hit.  Therefore, we need our own tooltip window.
        //
        if (SUCCEEDED(CreateListViewToolTip()))
            ActivateListViewToolTip(!m_lvsi.fShowFolder);
        else
            DBGERROR((TEXT("LISTVIEW, Failed creating tooltip window.")));

        //
        // Add WARNING and ERROR images to the listview's image list.
        // These are used for the "Status" column.
        //
        if (FAILED(hResult = AddImages()))
            DBGERROR((TEXT("LISTVIEW, Failed adding images to image list.")));
    }
    else
        hResult = E_FAIL;

#if DBG
    if (FAILED(hResult))
        DBGERROR((TEXT("LISTVIEW - Failed creating list view with result 0x%08X"),
                 hResult));
#endif

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::RemoveColumn

    Description: Removes a specified column from the list view.

    Arguments:
        iColId - 0-based index of the column in the list view.
            i.e. idCol_Folder, idCol_Name etc.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Column could not be removed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::RemoveColumn(
    INT iColId
    )
{
    INT iSubItem = m_ColMap.IdToSubItem(iColId);
    if (-1 != iSubItem && ListView_DeleteColumn(m_hwndListView, iSubItem))
    {
        m_ColMap.RemoveId(iSubItem);
        return NO_ERROR;
    }

    return E_FAIL;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddColumn

    Description: Adds a column to the list view.  The caller specifies which
        0-based position the column is to occupy and a reference to a column
        descriptor record containing information that defines the column.

    Arguments:
        iSubItem - 0-based index of the column in the list view.

        ColDesc - Reference to column descriptor record.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - One or more columns could not be inserted.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::AddColumn(
    INT iSubItem,
    const DV_COLDATA& ColDesc
    )
{
    LV_COLUMN col;
    HRESULT hResult = NO_ERROR;

    CString strColText(g_hInstDll, ColDesc.idMsgText);
    col.pszText = strColText;

    if (0 == ColDesc.cx)
    {
        //
        // No width specified in col desc record.  Size column to the title.
        //
        HDC hdc = NULL;
        TEXTMETRIC tm;

        hdc = GetDC(m_hwndListView);
        GetTextMetrics(hdc, &tm);
        ReleaseDC(m_hwndListView, hdc);
        //
        // Nothing special about the +2.  Without it, we get trailing ellipsis.
        //
        col.cx = tm.tmAveCharWidth * (lstrlen(col.pszText) + 2);
    }
    else
        col.cx = ColDesc.cx;  // Use width from col descriptor.


    col.iSubItem = iSubItem;
    col.fmt      = ColDesc.fmt;
    col.mask     = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;

    if (-1 != ListView_InsertColumn(m_hwndListView, iSubItem, &col))
        m_ColMap.InsertId(iSubItem, ColDesc.iColId);
    else
        hResult = E_FAIL;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddImages

    Description: Adds icon images to the list view's image lists.  These
        icons are used in the status column to indicate overrun of the
        quota threshold and limit.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - One or more icons could not be loaded.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::AddImages(
    VOID
    )
{
    HRESULT hResult         = NO_ERROR;
    HIMAGELIST hSmallImages = NULL;

    //
    // Create the image lists for the listview.
    //
    hSmallImages = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_MASK, 3, 0);

    //
    // Note:  The order of these icon ID's in this array must match with the
    //        iIMAGELIST_ICON_XXXXX macros defined at the top of this file.
    //        The macro values represent the image indices in the image list.
    //
    struct IconDef
    {
        LPTSTR szName;
        HINSTANCE hInstDll;
    } rgIcons[] = {
                    { MAKEINTRESOURCE(IDI_OKBUBBLE), g_hInstDll },
                    { IDI_WARNING,                   NULL       },
                    { MAKEINTRESOURCE(IDI_WARNERR),  g_hInstDll }
                  };

    for (UINT i = 0; i < ARRAYSIZE(rgIcons) && SUCCEEDED(hResult); i++)
    {
        HICON hIcon = LoadIcon(rgIcons[i].hInstDll, rgIcons[i].szName);

        if (NULL != hIcon)
        {
            ImageList_AddIcon(hSmallImages, hIcon);
            DestroyIcon(hIcon);
        }
        else
        {
            DBGERROR((TEXT("LISTVIEW - Error loading icon")));
            hResult = E_FAIL;
        }
    }
    ImageList_SetBkColor(hSmallImages, CLR_NONE);  // Transparent background.

    ListView_SetImageList(m_hwndListView, hSmallImages, LVSIL_SMALL);

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateListViewToolTip

    Description: Creates a tooltip window for displaying the user's folder
        name when the Folder column is hidden.  The entire listview
        is defined as a single tool.  We make the tooltip control think
        each listview item is a separate tool by intercepting WM_MOUSEMOVE,
        and performing a hit test to determine which listview item is hit.
        If the cursor has moved over a new item, the tooltip control is sent
        a WM_MOUSEMOVE(0,0).  The next real WM_MOUSEMOVE that we relay to the
        tooltip makes it think that it is on a new tool.  This is required
        so that tooltips popup and hide appropriately.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create tooltip window.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateListViewToolTip(
    VOID
    )
{
    HRESULT hResult = E_FAIL;

    m_hwndListViewToolTip = CreateWindowEx(0,
                                           TOOLTIPS_CLASS,
                                           (LPTSTR)NULL,
                                           TTS_ALWAYSTIP,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           CW_USEDEFAULT,
                                           m_hwndListView,
                                           (HMENU)NULL,
                                           g_hInstDll,
                                           NULL);
    if (NULL != m_hwndListViewToolTip)
    {
        TOOLINFO ti;

        //
        // Set tooltip timing parameter so that it pops up after
        // 1/2 second of no-mouse-movement.
        //
        SendMessage(m_hwndListViewToolTip,
                    TTM_SETDELAYTIME,
                    TTDT_INITIAL,
                    (LPARAM)500);

        ti.cbSize      = sizeof(TOOLINFO);
        ti.uFlags      = TTF_IDISHWND;
        ti.hwnd        = m_hwndListView;
        ti.hinst       = g_hInstDll;
        ti.uId         = (UINT_PTR)m_hwndListView;  // Treat entire LV as a tool.
        ti.lpszText    = LPSTR_TEXTCALLBACK;

        if (SendMessage(m_hwndListViewToolTip,
                        TTM_ADDTOOL,
                        0,
                        (LPARAM)&ti))
        {
            hResult = NO_ERROR;
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateStatusBar

    Description: Creates the status bar.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create status bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateStatusBar(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != m_hwndMain));
    m_hwndStatusBar = CreateWindow(STATUSCLASSNAME,
                                   TEXT(""),
                                   WS_VISIBLE | WS_CHILD | WS_BORDER | SBS_SIZEGRIP,
                                   0, 0, 0, 0,
                                   m_hwndMain,
                                   (HMENU)NULL,
                                   g_hInstDll,
                                   NULL);
    if (NULL != m_hwndStatusBar)
    {
        //
        // Show/hide status bar according to registry setting.
        //
        if (!m_lvsi.fStatusBar)
            ShowWindow(m_hwndStatusBar, SW_HIDE);

        //
        // Check the menu item to indicate the current status bar state.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_STATUSBAR,
                      MF_BYCOMMAND | (m_lvsi.fStatusBar ? MF_CHECKED : MF_UNCHECKED));
    }
    else
    {
        hResult = E_FAIL;
        DBGERROR((TEXT("LISTVIEW - Failed creating status bar."), hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateToolBar

    Description: Creates the tool bar.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed to create status bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/26/97    Changed to flat toolbar buttons.                     BrianAu
    05/20/97    Added "Find User" button and combo box.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateToolBar(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    //
    // Array describing each of the tool bar buttons.
    //
    TBBUTTON rgToolBarBtns[] = {
        { STD_FILENEW,     IDM_QUOTA_NEW,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_DELETE,      IDM_QUOTA_DELETE,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_PROPERTIES,  IDM_QUOTA_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_UNDO,        IDM_EDIT_UNDO,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0},
        { STD_FIND,        IDM_EDIT_FIND,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0L, 0}
        };

    DBGASSERT((NULL != m_hwndMain));

    m_hwndToolBar = CreateToolbarEx(m_hwndMain,
                                    WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT,
                                    IDC_TOOLBAR,
                                    15,
                                    (HINSTANCE)HINST_COMMCTRL,
                                    IDB_STD_SMALL_COLOR,
                                    (LPCTBBUTTON)rgToolBarBtns,
                                    ARRAYSIZE(rgToolBarBtns),
                                    0,
                                    0,
                                    100,
                                    30,
                                    sizeof(TBBUTTON));

    if (NULL != m_hwndToolBar)
    {
        //
        // FEATURE:  I'm creating this combo without the WS_VISIBLE
        //          attribute set.  I originally coded this to have a
        //          "find" dropdown combo in the toolbar similar to that
        //          found in MS Dev Studio.  Later we decided that this
        //          was unnecessarily redundant with the "find" dialog
        //          and it's dropdown combo.  I'm leaving the code for
        //          two reasons.
        //             1. I don't want to break the existing implementation.
        //             2. If we decide later to re-enable the feature it will
        //                be easy to reactivate.
        //
        //          [brianau - 1/20/98]
        //
        m_hwndToolbarCombo = CreateWindowEx(0,
                                            TEXT("COMBOBOX"),
                                            TEXT(""),
                                            WS_CHILD | WS_BORDER |
                                            CBS_HASSTRINGS | CBS_DROPDOWN |
                                            CBS_AUTOHSCROLL,
                                            0, 0,
                                            CX_TOOLBAR_COMBO,
                                            CY_TOOLBAR_COMBO,
                                            m_hwndToolBar,
                                            (HMENU)IDC_TOOLBAR_COMBO,
                                            g_hInstDll,
                                            NULL);
        if (NULL != m_hwndToolbarCombo)
        {
            //
            // Set the font in the toolbar combo to be the same as that
            // used in listview.  This assumes that the listview
            // has already been created.
            //
            DBGASSERT((NULL != m_hwndListView));
            HFONT hfontMain = (HFONT)SendMessage(m_hwndListView, WM_GETFONT, 0, 0);
            SendMessage(m_hwndToolbarCombo, WM_SETFONT, (WPARAM)hfontMain, 0);

            //
            // Initialize the "user finder" object so that it knows
            // how to communicate with the toolbar combo box.
            //
            m_pUserFinder->ConnectToolbarCombo(m_hwndToolbarCombo);

            //
            // Retrieve the finder's MRU list contents from the registry and
            // load the toolbar's combo box.
            // The check for cMruEntries < MAX_FINDMRU_ENTRIES is to prevent
            // this loop from running wild if someone trashes the registry entry.
            //
            RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
            if (SUCCEEDED(keyPref.Open(KEY_READ)))
            {
                CArray<CString> rgstrMRU;
                if (SUCCEEDED(keyPref.GetValue(REGSTR_VAL_FINDMRU, &rgstrMRU)))
                {
                    int n = rgstrMRU.Count();
                    for (int i = 0; i < n; i++)
                    {
                        SendMessage(m_hwndToolbarCombo,
                                    CB_ADDSTRING,
                                    0,
                                    (LPARAM)(rgstrMRU[i].Cstr()));
                    }
                }
            }
        }

        //
        // Show/hide tool bar according to registry setting.
        //
        if (!m_lvsi.fToolBar)
            ShowWindow(m_hwndToolBar, SW_HIDE);

        //
        // Check the menu item to indicate the current tool bar state.
        //
        CheckMenuItem(GetMenu(m_hwndMain),
                      IDM_VIEW_TOOLBAR,
                      MF_BYCOMMAND | (m_lvsi.fToolBar ? MF_CHECKED : MF_UNCHECKED));
        //
        // Initially, we have nothing in the undo list.
        //
        EnableMenuItem_Undo(FALSE);
    }
    else
    {
        hResult = E_FAIL;
        DBGERROR((TEXT("LISTVIEW - Failed creating tool bar."), hResult));
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LoadObjects

    Description: Loads the user object list with quota record objects.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed enumerating users or adding objects to listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::LoadObjects(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != m_pQuotaControl));


    //
    // Use a user enumerator object for obtaining all of the quota users.
    //
    IEnumDiskQuotaUsers *pEnumUsers = NULL;

    hResult = m_pQuotaControl->CreateEnumUsers(
                            NULL,                             // All entries.
                            0,                                // All entries.
                            DISKQUOTA_USERNAME_RESOLVE_ASYNC, // Asynchronous operation.
                            &pEnumUsers);
    if (SUCCEEDED(hResult))
    {
        IDiskQuotaUser *pUser = NULL;
        hResult = S_OK;

        //
        // m_bStopLoadingObjects is sort of a hack so that we can interrupt
        // object loading if the user closes the view while loading is in progress.
        //
        // This is probably the most speed-critical loop in the disk quota UI.
        // The faster it is, the less time the user must wait for the listview
        // to be populated with user objects.
        //
        try
        {
            //
            // Go ahead and take a lock on the user list during the entire loading
            // process.  This will let the list locking code in m_UserList.Append
            // proceded without having to obtain the lock each time.
            //
            m_UserList.Lock();
            while(!m_bStopLoadingObjects)
            {
                DWORD cUsers = 1;

                hResult = pEnumUsers->Next(cUsers, &pUser, &cUsers);
                if (S_OK == hResult)
                {
                    m_UserList.Append(pUser);
                }
                else
                {
                    break;
                }

                pUser = NULL;
            }
            pEnumUsers->Release();  // Release the enumerator.
            pEnumUsers = NULL;
            m_UserList.ReleaseLock();
        }
        catch(CAllocException& e)
        {
            //
            // Clean up before re-throwing exception.
            // Leave m_UserList in the pre-exception state.
            //
            if (NULL != pUser)
                pUser->Release();
            if (NULL != pEnumUsers)
                pEnumUsers->Release();
            m_UserList.ReleaseLock();

            m_bStopLoadingObjects = FALSE;
            hResult = E_OUTOFMEMORY;
        }
    }

    if (S_FALSE == hResult)     // Means no-more-users.
        hResult = NO_ERROR;

#if DBG
    if (FAILED(hResult))
    {
        DBGERROR((TEXT("LISTVIEW - Failed loading objects.  Result = 0x%08X"),
                 hResult));
    }
#endif

    m_bStopLoadingObjects = FALSE;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ReleaseObjects

    Description: Releases all objects from the user object list (listview).

    Arguments: None.

    Returns: Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview. Added m_UserList.                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::ReleaseObjects(
    VOID
    )
{
    //
    // Destroy the user objects in the list.
    //
    PDISKQUOTA_USER pUser = NULL;
    m_UserList.Lock();
    while(m_UserList.RemoveLast((LPVOID *)&pUser))
    {
        if (NULL != pUser)
            pUser->Release();
    }
    m_UserList.ReleaseLock();

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SortObjects

    Description: Sort objects in the list view using a given column as the key.

    Arguments:
        idColumn - Number of the column (0-based) to use as the key.

        dwDirection - 0 = Ascending sort, 1 = Descending sort.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/24/97    Added m_UserList.  Ownerdata listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::SortObjects(
    DWORD idColumn,
    DWORD dwDirection
    )
{
    DBGASSERT((idColumn < DetailsView::idCol_Last));

    CAutoWaitCursor waitcursor;
    COMPARESTRUCT cs;

    cs.idColumn    = idColumn;
    cs.dwDirection = dwDirection;
    cs.pThis       = this;

    m_UserList.Lock();
    m_UserList.Sort(CompareItems, (LPARAM)&cs);
    InvalidateRect(m_hwndListView, NULL, TRUE);
    UpdateWindow(m_hwndListView);
    m_UserList.ReleaseLock();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CompareItems [static]

    Description: Compares two items from the details view.
        Note that it's a static method so there's no "this" pointer.

    Arguments:
        lParam1 - Address of first user object.

        lParam2 - Address of second user object.

        lParam3 - Address of a COMPARESTRUCT structure.

    Returns:
        < 0 = User 1 is "less than" user 2.
          0 = Users are "equivalent".
        > 0 = User 1 is "greater than" user 2.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/05/96    Added domain name string.                            BrianAu
    05/19/97    Fixed overflow in difference calculations.           BrianAu
                Changed type of "diff" from INT to __int64.
    07/18/97    Use CompareString for name comparisons.              BrianAu
                Need to be locale-sensitive.
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::CompareItems(
    LPVOID lParam1,
    LPVOID lParam2,
    LPARAM lParam3
    )
{
    INT i[2];
    __int64 diff = 0;
    PDISKQUOTA_USER pUser[2];
    LONGLONG llValue[2];
    PCOMPARESTRUCT pcs = (PCOMPARESTRUCT)lParam3;
    DBGASSERT((NULL != pcs));
    DetailsView *pThis = pcs->pThis;
    pUser[0] = (PDISKQUOTA_USER)lParam1;
    pUser[1] = (PDISKQUOTA_USER)lParam2;

    i[0] = pcs->dwDirection; // Sort direction (0 = ascending, 1 = descending)
    i[1] = i[0] ^ 1;         // Opposite of i[0].

    DBGASSERT((NULL != pUser[0]));
    DBGASSERT((NULL != pUser[1]));

    switch(pcs->idColumn)
    {
        case DetailsView::idCol_Name:
        case DetailsView::idCol_LogonName:
        case DetailsView::idCol_Folder:
        {
            DWORD dwAccountStatus[2];
            pUser[0]->GetAccountStatus(&dwAccountStatus[0]);
            pUser[1]->GetAccountStatus(&dwAccountStatus[1]);

            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus[0] &&
                DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus[1])
            {
                //
                // Both users have valid logon name  strings.
                //
                INT iCompareResult;         // For CompareString.
                TCHAR szContainer[2][MAX_DOMAIN];
                TCHAR szName[2][MAX_USERNAME];
                TCHAR szLogonName[2][MAX_USERNAME];
                pUser[0]->GetName(szContainer[0], ARRAYSIZE(szContainer[0]),
                                  szLogonName[0], ARRAYSIZE(szLogonName[0]),
                                  szName[0],      ARRAYSIZE(szName[0]));

                pUser[1]->GetName(szContainer[1], ARRAYSIZE(szContainer[1]),
                                  szLogonName[1], ARRAYSIZE(szLogonName[1]),
                                  szName[1],      ARRAYSIZE(szName[1]));

                if (DetailsView::idCol_Folder == pcs->idColumn)
                {
                    //
                    // Sort by container + logon name.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szContainer[ i[0] ], -1,
                                                   szContainer[ i[1] ], -1);
                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szLogonName[ i[0] ], -1,
                                                       szLogonName[ i[1] ], -1);
                    }
                }
                else if (DetailsView::idCol_Name == pcs->idColumn)
                {
                    //
                    // Sort by display name + container.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szName[ i[0] ], -1,
                                                   szName[ i[1] ], -1);

                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szContainer[ i[0] ], -1,
                                                       szContainer[ i[1] ], -1);
                    }
                }
                else if (DetailsView::idCol_LogonName == pcs->idColumn)
                {
                    //
                    // Sort by logon name + container.
                    // Use CompareString so we're locale-sensitive.
                    //
                    iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                   NORM_IGNORECASE,
                                                   szLogonName[ i[0] ], -1,
                                                   szLogonName[ i[1] ], -1);

                    if (CSTR_EQUAL == iCompareResult)
                    {
                        iCompareResult = CompareString(LOCALE_USER_DEFAULT,
                                                       NORM_IGNORECASE,
                                                       szContainer[ i[0] ], -1,
                                                       szContainer[ i[1] ], -1);
                    }
                }
                //
                // Convert iCompareResult [1,2,3] to [-1,0,1].
                //
                diff = iCompareResult - 2;
            }
            else
            {
                //
                // At least one of the users hasn't been or can't be resolved.
                // Compare by account status alone.  Status values are such
                // that a resolved name will sort before an unresolved name.
                // Cast to (INT) is required for proper ordering.
                //
                diff = (INT)dwAccountStatus[ i[0] ] - (INT)dwAccountStatus[ i[1] ];
            }
            break;
        }
        case DetailsView::idCol_Status:
        {
            //
            // The status image is based on the quota "state" of the user.
            // This expression effectively compares user records by status image.
            //
            diff = (pThis->GetUserQuotaState(pUser[ i[0] ]) - pThis->GetUserQuotaState(pUser[ i[1] ]));
            break;
        }
        case DetailsView::idCol_AmtUsed:
        {
            pUser[0]->GetQuotaUsed(&llValue[0]);
            pUser[1]->GetQuotaUsed(&llValue[1]);
            diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_Limit:
        {
            pUser[0]->GetQuotaLimit(&llValue[0]);
            pUser[1]->GetQuotaLimit(&llValue[1]);

            if (NOLIMIT == llValue[ i[0] ])
                diff = 1;
            else if (NOLIMIT == llValue[ i[1] ])
                diff = -1;
            else
                diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_Threshold:
        {
            pUser[0]->GetQuotaThreshold(&llValue[0]);
            pUser[1]->GetQuotaThreshold(&llValue[1]);

            if (NOLIMIT == llValue[ i[0] ])
                diff = 1;
            else if (NOLIMIT == llValue[ i[1] ])
                diff = -1;
            else
                diff = llValue[ i[0] ] - llValue[ i[1] ];
            break;
        }
        case DetailsView::idCol_PctUsed:
        {
            DWORD dwPct[2];
            CalcPctQuotaUsed(pUser[0], &dwPct[0]);
            CalcPctQuotaUsed(pUser[1], &dwPct[1]);
            diff = (INT)dwPct[ i[0] ] - (INT)dwPct[ i[1] ];
            break;
        }

        default:
            break;
    }

    //
    // Translate return value to -1, 0 or 1.
    //
    INT iReturn = 0;
    if (0 != diff)
    {
        if (0 < diff)
            iReturn = 1;
        else
            iReturn = -1;
    }

    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::WndProc

    Description: Window procedure for the details view main window.  This
        method merely dispatches the messages to other methods that do the
        actual work.  These work methods should be declared "inline".

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::WndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    // Retrieve the DetailsView object's "this" pointer from the window's
    // USERDATA.
    //
    DetailsView *pThis = (DetailsView *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    try
    {
        switch(message)
        {
            case WM_CREATE:
            {
                CREATESTRUCT *pcs = (CREATESTRUCT *)lParam;
                PWNDCREATE_DATA pCreateData = (PWNDCREATE_DATA)(pcs->lpCreateParams);
                DBGASSERT((NULL != pCreateData));

                pThis = (DetailsView *)(pCreateData->pThis);
                DBGASSERT((NULL != pThis));
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (INT_PTR)pThis);

                InitCommonControls();
                return 0;
            }

            case WM_COMMAND:
                DBGASSERT((NULL != pThis));
                pThis->OnCommand(hWnd, message, wParam, lParam);
                //
                // Enable the "Undo" menu if the undo list is not empty.
                //
                pThis->EnableMenuItem_Undo(0 != pThis->m_pUndoList->Count());
                return 0;

            case WM_CONTEXTMENU:
                DBGASSERT((NULL != pThis));
                pThis->OnContextMenu(hWnd, message, wParam, lParam);
                return 0;

            case WM_CLOSE:
            case WM_ENDSESSION:
                DestroyWindow(hWnd);
                return 0;

            case WM_DESTROY:
                DBGASSERT((NULL != pThis));
                pThis->OnDestroy(hWnd, message, wParam, lParam);
                return 0;

            case WM_ADD_USER_TO_DETAILS_VIEW:  // This is DSKQUOTA-specific.
                DBGASSERT((NULL != pThis));
                pThis->AddUser((PDISKQUOTA_USER)lParam);
                return 0;

            case WM_MAINWINDOW_CREATED:  // This is DSKQUOTA-specific.
                DBGASSERT((NULL != pThis));
                pThis->OnMainWindowCreated(hWnd, message, wParam, lParam);
                return 0;

            case WM_MENUSELECT:
                DBGASSERT((NULL != pThis));
                pThis->OnMenuSelect(hWnd, message, wParam, lParam);
                return 0;

            case WM_NOTIFY:
                DBGASSERT((NULL != pThis));
                pThis->OnNotify(hWnd, message, wParam, lParam);
                return 0;

            case WM_SETFOCUS:
                DBGASSERT((NULL != pThis));
                pThis->OnSetFocus(hWnd, message, wParam, lParam);
                return 0;

            case WM_SIZE:
                DBGASSERT((NULL != pThis));
                pThis->OnSize(hWnd, message, wParam, lParam);
                return 0;

            case WM_SYSCOLORCHANGE:
            case WM_SETTINGCHANGE:
                DBGASSERT((NULL != pThis));
                pThis->OnSettingChange(hWnd, message, wParam, lParam);
                return 0;

            default:
                break;
        }
    }
    catch(CAllocException& e)
    {
        //
        // Handle out-of-memory errors here.  Any other exceptions
        // can be thrown to caller.  Let ThreadProc handle them.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LVSubClassWndProc

    Description: Window proc for the sub-classed listview control.
        This is required so that we can intecept mouse messages and respond
        to the request for tooltip text.

    Arguments: Std windows WndProc args.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::LVSubClassWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DetailsView *pThis = (DetailsView *)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(message)
    {
        case WM_NOTIFY:
            {
                //
                // Only return ToolTip text if TTN_NEEDTEXT is being
                // sent from our tooltip.  Don't respond to the listview's
                // internal tooltip's request for text.
                //
                LV_DISPINFO *pDispInfo  = (LV_DISPINFO *)lParam;
                if (pDispInfo->hdr.hwndFrom == pThis->m_hwndListViewToolTip)
                {
                    switch(pDispInfo->hdr.code)
                    {
                        case TTN_NEEDTEXT:
//
// FEATURE:  With the removal of the "domain" term from the UI, I
//          decided we don't need this tooltip any more.
//          However, I'm making this change in the last hour before
//          "code complete" and I don't want to break something else.
//          Therefore I'm just commenting this out and leaving the
//          subclassing in place.  If there's time later, this subclassing
//          of the listview should be removed. [brianau - 03/19/98]
//
//                            pThis->LV_OnTTN_NeedText((TOOLTIPTEXT *)lParam);
                            return 0;

                        default:
                            break;
                    }
                }
            }
            break;

        case WM_MOUSEMOVE:
            DBGASSERT((NULL != pThis));
            pThis->LV_OnMouseMessages(hWnd, message, wParam, lParam);
            break;

        case WM_ADD_USER_TO_DETAILS_VIEW:  // This is DSKQUOTA-specific.
            DBGASSERT((NULL != pThis));
            pThis->AddUser((PDISKQUOTA_USER)lParam);
            break;

        default:
            break;
    }
    DBGASSERT((NULL != pThis->m_lpfnLVWndProc));
    return CallWindowProc(pThis->m_lpfnLVWndProc, hWnd, message, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/06/96    Added "Show Domain" menu option.                     BrianAu
    05/20/97    Added IDM_EDIT_FIND and IDM_EDIT_FIND_LIST.          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCommand(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(LOWORD(wParam))
    {
        case IDM_EDIT_INVERTSELECTION:
            InvertSelectedItems();
            break;

        case IDM_EDIT_UNDO:
            OnCmdUndo();
            break;

        case IDM_EDIT_FIND:
            OnCmdFind();
            break;

        case IDM_EDIT_FIND_LIST:
            SetFocus(m_hwndToolbarCombo);
            break;

        case IDM_EDIT_SELECTALL:
            SelectAllItems();
            break;

        case IDM_EDIT_COPY:
            OnCmdEditCopy();
            break;

        case IDM_HELP_ABOUT:
            OnHelpAbout(hWnd);
            break;

        case IDM_HELP_TOPICS:
            OnHelpTopics(hWnd);
            break;

        case IDM_QUOTA_CLOSE:
            DestroyWindow(m_hwndMain);
            break;

        case IDM_QUOTA_DELETE:
            OnCmdDelete();
            FocusOnSomething();      // Needed if DEL key pressed.
            break;

        case IDM_QUOTA_NEW:
            OnCmdNew();
            break;

        case IDM_QUOTA_PROPERTIES:
            OnCmdProperties();
            break;

        case IDM_QUOTA_IMPORT:
            OnCmdImport();
            break;

        case IDM_QUOTA_EXPORT:
            OnCmdExport();
            break;

        case IDM_VIEW_ARRANGE_BYFOLDER:
            SortObjects(DetailsView::idCol_Folder, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYLIMIT:
            SortObjects(DetailsView::idCol_Limit, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYNAME:
            SortObjects(DetailsView::idCol_Name, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYLOGONNAME:
            SortObjects(DetailsView::idCol_LogonName, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYPERCENT:
            SortObjects(DetailsView::idCol_PctUsed, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYTHRESHOLD:
            SortObjects(DetailsView::idCol_Threshold, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYSTATUS:
            SortObjects(DetailsView::idCol_Status, m_fSortDirection);
            break;

        case IDM_VIEW_ARRANGE_BYUSED:
            SortObjects(DetailsView::idCol_AmtUsed, m_fSortDirection);
            break;

        case IDM_VIEW_REFRESH:
            Refresh(true);
            break;

        case IDM_VIEW_STATUSBAR:
            OnCmdViewStatusBar();
            break;

        case IDM_VIEW_TOOLBAR:
            OnCmdViewToolBar();
            break;
        case IDM_VIEW_SHOWFOLDER:
            OnCmdViewShowFolder();
            break;
//
// These are just for development.
//
//      case IDM_CLEAR_CACHE:
//          m_pQuotaControl->InvalidateSidNameCache();
//          break;

        default:
            break;
    }
    return 0;
}


LRESULT
DetailsView::OnSettingChange(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND rghwnd[] = { m_hwndListView,
                      m_hwndStatusBar,
                      m_hwndToolBar,
                      m_hwndToolbarCombo,
                      m_hwndListViewToolTip,
                      m_hwndHeader };

    for (int i = 0; i < ARRAYSIZE(rghwnd); i++)
    {
        SendMessage(rghwnd[i], uMsg, wParam, lParam);
    }
    return 0;
}


//
// Is an x,y screen position in the LV header control?
//
BOOL
DetailsView::HitTestHeader(
    int xPos,
    int yPos
    )
{
    RECT rcHdr;
    POINT pt = { xPos, yPos };

    GetWindowRect(m_hwndHeader, &rcHdr);
    return PtInRect(&rcHdr, pt);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnContextMenu

    Description: Handler for WM_CONTEXTMENU.
        Creates and tracks a popup context menu for deleting
        selected object(s) and showing their properties.


    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnContextMenu(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Only display menu if the message is from the list view and there's
    // one or more objects selected in the list view.
    //
    if ((HWND)wParam == m_hwndListView &&
        !HitTestHeader(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)) &&
        ListView_GetSelectedCount(m_hwndListView) > 0)
    {
        HMENU hMenu = LoadMenu(g_hInstDll, MAKEINTRESOURCE(IDM_CONTEXT_MENU));
        if (NULL != hMenu)
        {
            HMENU hMenuTrackPopup = GetSubMenu(hMenu, 0);

            SetMenuDefaultItem(hMenuTrackPopup, IDM_QUOTA_PROPERTIES, MF_BYCOMMAND);

            if (LPARAM(-1) == lParam)
            {
                //
                // Invoked from keyboard.  Place menu at focused item.
                //
                POINT pt = { -1, -1 };
                int i = ListView_GetNextItem(m_hwndListView, -1, LVNI_FOCUSED);
                if (i != -1)
                {
                    ListView_GetItemPosition(m_hwndListView, i, &pt);
                    ClientToScreen(m_hwndListView, &pt);
                }

                lParam = MAKELPARAM(pt.x, pt.y);
            }
            if (LPARAM(-1) != lParam)
            {
                TrackPopupMenu(hMenuTrackPopup,
                               TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                               GET_X_LPARAM(lParam),
                               GET_Y_LPARAM(lParam),
                               0,
                               hWnd,
                               NULL);
            }
            DestroyMenu(hMenu);
        }
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnDestroy

    Description: Handler for WM_DESTROY.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnDestroy(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // We don't want to destroy the view window while a user-name-changed
    // update is in progress.  Likewise, we don't want to perform a name
    // update if the view is being (or has been) destroyed.  The crit sec
    // m_csAsyncUpdate and the flag m_bDestroyingView work together to
    // ensure this.
    //
    EnterCriticalSection(&m_csAsyncUpdate);

    m_bDestroyingView     = TRUE;  // Destruction of DetailsView in progress.
    m_bStopLoadingObjects = TRUE;  // Will terminate in-progress loading.

    //
    // Unregister the main window as an OLE drop target.
    //
    if (NULL != hWnd)
    {
        RegisterAsDropTarget(FALSE);
    }

    //
    // Cancel subclassing of the listview control.
    //
    if (NULL != m_lpfnLVWndProc)
        SetWindowLongPtr(m_hwndListView, GWLP_WNDPROC, (INT_PTR)m_lpfnLVWndProc);

    DisconnectEventSink();

    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // Save the view dimensions and column widths to the registry.
    // We want the user to be able to configure the view and leave it.
    //
    SaveViewStateToRegistry();

    //
    // If we have a data object on the clipboard, clear the clipboard.
    // Note that the clipboard holds the reference to the data object.
    // When we clear the clipboard, the data object will be released.
    //
    if (NULL != m_pIDataObjectOnClipboard &&
       S_OK == OleIsCurrentClipboard(m_pIDataObjectOnClipboard))
    {
        OleFlushClipboard();
    }

    //
    // All done now.  Post a WM_QUIT message to the thread to tell
    // it to exit.  On termination, the thread proc will release
    // the view object, calling the destructor.
    //
    PostMessage(hWnd, WM_QUIT, 0, 0);

    LeaveCriticalSection(&m_csAsyncUpdate);
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::RegisterAsDropTarget

    Description: Registers or De-Registers the details view window as
        an OLE drop target.

    Arguments:
        bActive - If TRUE, registers as a drop target.
                  If FALSE, un-registers as a drop target.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::RegisterAsDropTarget(
    BOOL bActive
    )
{
    if (bActive)
    {
        //
        // Register as a drop target.
        //
        CoLockObjectExternal(static_cast<IDropTarget *>(this), TRUE, FALSE);
        RegisterDragDrop(m_hwndMain, static_cast<IDropTarget *>(this));
    }
    else
    {
        //
        // Un-register as a drop target.
        //
        RevokeDragDrop(m_hwndMain);
        CoLockObjectExternal(static_cast<IDropTarget *>(this), FALSE, TRUE);
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SaveViewStateToRegistry

    Description: Saves the listview height/width and the column widths to
        the registry.  When the listview is created, these values are used
        to size it so that the user doesn't always have to re-configure the
        view every time they open it.  Also saves the visibility state of the
        toolbar, statusbar and folder column.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
    05/20/97    Added FindMRU list to persistent reg data.           BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::SaveViewStateToRegistry(
    VOID
    )
{
    RECT rc;
    HDC hdc = GetDC(m_hwndMain);

    RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (FAILED(keyPref.Open(KEY_WRITE, true)))
    {
        DBGERROR((TEXT("Error opening reg key \"%s\""), REGSTR_KEY_DISKQUOTA));
        return;
    }

    m_lvsi.cb = sizeof(LV_STATE_INFO);

    //
    // Save current screen resolution.
    //
    m_lvsi.cxScreen = (WORD)GetDeviceCaps(hdc, HORZRES);
    m_lvsi.cyScreen = (WORD)GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(m_hwndMain, hdc);

    //
    // Save current listview window size.
    //
    GetWindowRect(m_hwndMain, &rc);
    m_lvsi.cx = rc.right - rc.left;
    m_lvsi.cy = rc.bottom - rc.top;

    //
    // Save listview column widths.
    //
    UINT cColumns = Header_GetItemCount(m_hwndHeader);
    for (UINT i = 0; i < cColumns; i++)
    {
        m_lvsi.rgcxCol[i] = ListView_GetColumnWidth(m_hwndListView, i);
    }

    //
    // Save the current order of the columns in the listview.
    //
    DBGASSERT(cColumns <=  ARRAYSIZE(m_lvsi.rgColIndices));

    Header_GetOrderArray(m_hwndHeader, cColumns, m_lvsi.rgColIndices);

    //
    // Save column sorting state.
    // Casts are because we use a WORD bit field in the LVSI structure.
    //
    m_lvsi.iLastColSorted = (WORD)(m_iLastColSorted & 0xF);  // Uses only lower 4 bits.
    m_lvsi.fSortDirection = (WORD)m_fSortDirection;

    //
    // Write preference data to registry.
    //
    keyPref.SetValue(REGSTR_VAL_PREFERENCES, (LPBYTE)&m_lvsi, m_lvsi.cb);

    //
    // Save the contents of the Find MRU list.
    //
    UINT cNames = (UINT)SendMessage(m_hwndToolbarCombo, CB_GETCOUNT, 0, 0);
    if (CB_ERR != cNames && 0 < cNames)
    {
        CArray<CString> rgstrNames(cNames);
        for (i = 0; i < cNames; i++)
        {
            INT cchName = (INT)SendMessage(m_hwndToolbarCombo, CB_GETLBTEXTLEN, i, 0);
            if (CB_ERR != cchName && 0 < cchName)
            {
                CString s;
                cchName = (INT)SendMessage(m_hwndToolbarCombo, CB_GETLBTEXT, i, (LPARAM)s.GetBuffer(cchName + 1));
                s.ReleaseBuffer();
                if (CB_ERR != cchName)
                {
                    rgstrNames[i] = s;
                }
            }
        }
        keyPref.SetValue(REGSTR_VAL_FINDMRU, rgstrNames);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnMainWindowCreated

    Description: Handles WM_MAIN_WINDOW_CREATED.
        This message is posted by ThreadProc after main window creation is
        complete.  It does all the stuff to get the window up and running.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnMainWindowCreated(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGASSERT((NULL != m_hwndMain));

    //
    // The accelerator table is automatically freed by Windows
    // when the app terminates.
    //
    m_hKbdAccel = LoadAccelerators(g_hInstDll,
                                   MAKEINTRESOURCE(IDR_KBDACCEL));

    CreateListView();
    CreateStatusBar();
    CreateToolBar();
    ConnectEventSink();
    ShowWindow(m_hwndMain, SW_SHOWNORMAL);
    UpdateWindow(m_hwndMain);
    //
    // Create the UNDO object.
    //
    m_pUndoList = new UndoList(&m_UserList, m_hwndListView);

    ShowItemCountInStatusBar();
    Refresh();
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnMenuSelect

    Description: Handles WM_MENUSELECT.
        If a menu item is currently selected AND the status bar is visible,
        the menu item's description is displayed in the status bar.  When
        the menu is closed, the status bar reverts back to an item count.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnMenuSelect(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (0xFFFF == HIWORD(wParam) && NULL == (HMENU)lParam)
    {
        //
        // Menu closed.
        //
        m_bMenuActive = FALSE;
        ShowItemCountInStatusBar();
    }
    else
    {
        //
        // Item selected.
        //
        m_bMenuActive = TRUE;
        ShowMenuTextInStatusBar(LOWORD(wParam));
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnNotify

    Description: Handles all LVN_XXXXXX list view control notifications.
        Dispatches specific notifications to other handlers.

    Arguments: Standard WndProc arguments.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnNotify(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NMHDR *pnmhdr = (NMHDR *)lParam;

    switch(pnmhdr->code)
    {
        case NM_DBLCLK:
        case NM_RETURN:
            OnCmdProperties( );
            //
            // Enable/disable Undo menu item.
            //
            EnableMenuItem_Undo(0 != m_pUndoList->Count());
            break;

        case NM_SETFOCUS:
            FocusOnSomething(); // Something should always be highlighted.
            break;

        case LVN_ODFINDITEM:
            OnLVN_OwnerDataFindItem((NMLVFINDITEM *)lParam);
            break;

        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)lParam);
            break;

        case LVN_BEGINDRAG:
            OnLVN_BeginDrag((NM_LISTVIEW *)lParam);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)lParam);
            break;

        case LVN_ITEMCHANGED:
            OnLVN_ItemChanged((NM_LISTVIEW *)lParam);
            break;

        case TTN_NEEDTEXT:
            OnTTN_NeedText((TOOLTIPTEXT *)lParam);
            //
            // Fall through.
            //

        default:
            break;
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LV_OnMouseMessages

    Description: Handles mouse messages for the subclassed listview control.
        These must be intercepted so that we can...

        a) Tell the tooltip when we've hit another listview item.
    and b) Forward all mouse messages to the tooltip window.

    Arguments: Standard WndProc args.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::LV_OnMouseMessages(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch(message)
    {
        case WM_MOUSEMOVE:
            {
                //
                // If we've moved the mouse to another listview item,
                // make the tooltip window think we're over another tool.
                // The tooltip window thinks the entire listview is a single
                // tool but we want to treat each item as a separate tool.
                // Note that m_ptMouse.x and .y are recorded when the main
                // window receives WM_MOUSEMOVE.
                //
                LV_HITTESTINFO hti;
                INT iItem = 0;

                hti.pt.x = m_ptMouse.x = GET_X_LPARAM(lParam);
                hti.pt.y = m_ptMouse.y = GET_Y_LPARAM(lParam);

                if (-1 != (iItem = ListView_HitTest(m_hwndListView, &hti)))
                {
                    if (iItem != m_iLastItemHit)
                    {
                        SendMessage(m_hwndListViewToolTip, WM_MOUSEMOVE, 0, 0);
                        m_iLastItemHit = iItem;
                    }
                }
                else
                {
                    ShowWindow(m_hwndListViewToolTip, SW_HIDE);
                    m_iLastItemHit = iItem;
                }
            }

            //
            // Fall through.
            //
        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_RBUTTONDOWN:
            {
                //
                // Relay all mouse messages to the listview's tooltip control.
                //
                MSG msg;
                msg.hwnd    = hWnd;
                msg.message = message;
                msg.wParam  = wParam;
                msg.lParam  = lParam;

                SendMessage(m_hwndListViewToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
            }
            break;

        default:
            break;
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdEditCopy

    Description: Handles WM_COMMAND, IDM_EDIT_COPY.  This is invoked whenever
        a user selects the Copy menu item or presses Ctrl + C.  The method
        creates a DataObject (same used in drag-drop) and places it on the
        OLE clipboard.  The data is rendered when OLE asks for it via
        IDataObject::GetData.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdEditCopy(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    hResult = QueryInterface(IID_IDataObject, (LPVOID *)&m_pIDataObjectOnClipboard);
    if (SUCCEEDED(hResult))
    {
        OleSetClipboard(m_pIDataObjectOnClipboard);
        //
        // OLE calls AddRef() so we can release the count added in QI.
        //
        m_pIDataObjectOnClipboard->Release();
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_BeginDrag

    Description: Called when the user has selected one or more items in the
        listview and begins a drag operation.  Creates a DropSource object
        and a DataObject then calls DoDragDrop() to execute the drag-drop
        operation.

        Note that we don't store the IDataObject pointer in
        m_IDataObjectOnClipboard.  That member is only for clipboard copy
        operations, not drag/drop.

    Arguments:
        pNm - Address of notification message structure.

    Returns: TRUE  = Succeeded.
             FALSE = Failed.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_BeginDrag(
    NM_LISTVIEW *pNm
    )
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("DetailsView::OnLVN_BeginDragDrop")));
    HRESULT hResult           = NO_ERROR;
    IDataObject *pIDataObject = NULL;
    IDropSource *pIDropSource = NULL;

    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("DRAGDROP - Beginning Drag/Drop")));
    try
    {
        hResult = QueryInterface(IID_IDataObject, (LPVOID *)&pIDataObject);
        if (SUCCEEDED(hResult))
        {
            hResult = QueryInterface(IID_IDropSource, (LPVOID *)&pIDropSource);
            if (SUCCEEDED(hResult))
            {
                DWORD dwEffect = 0;

                //
                // Unregister our window as a drop target while we're acting as a drop
                // source.  Don't want to drop our own data onto our own window.
                //
                RegisterAsDropTarget(FALSE);

                hResult = DoDragDrop(pIDataObject,
                                     pIDropSource,
                                     DROPEFFECT_COPY | DROPEFFECT_MOVE,
                                     &dwEffect);

                //
                // FEATURE:  Should probably display some error UI here.
                //          The shell doesn't indicate any error if the
                //          destination volume is full or if there's a write
                //          error.  The only indication of a failure is that
                //          dwEffect will contain 0.  We could display something
                //          like "An error occured while transferring the selected
                //          items."  The big problem is that only the shell knows
                //          where the data was stored so only it could delete
                //          the created file.  Displaying a message but leaving
                //          the file is also confusing. [brianau 7/29/97]
                //          NT Bug 96282 will fix the shell not deleting the file.
                //
                RegisterAsDropTarget(TRUE);

                DBGPRINT((TEXT("DRAGDROP - Drag/Drop complete.\n\t hResult = 0x%08X  Effect = 0x%08X"),
                         hResult, dwEffect));

                pIDropSource->Release();
                pIDropSource = NULL;
            }
            pIDataObject->Release();
            pIDataObject = NULL;
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pIDropSource)
            pIDropSource->Release();
        if (NULL != pIDataObject)
            pIDataObject->Release();
        RegisterAsDropTarget(TRUE);
        throw;
    }
    return SUCCEEDED(hResult);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnTTN_NeedText

    Description: Handles requests for tooltip text for the main window's tool
        bar buttons.

    Arguments:
        pToolTipText - Address of tooltip text notification information.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
    07/09/97    Added cmd/TT cross reference.                        BrianAu
                Previously used the tool status text in tooltip.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnTTN_NeedText(
    TOOLTIPTEXT *pToolTipText
    )
{
    //
    // Cross-reference tool command IDs with tooltip text IDs.
    //
    const struct
    {
        UINT idCmd;  // Tool cmd ID.
        UINT idTT;   // Tooltip text ID.

    } CmdTTXRef[] = {
                        { IDM_QUOTA_NEW,        IDS_TT_QUOTA_NEW        },
                        { IDM_QUOTA_DELETE,     IDS_TT_QUOTA_DELETE     },
                        { IDM_QUOTA_PROPERTIES, IDS_TT_QUOTA_PROPERTIES },
                        { IDM_EDIT_UNDO,        IDS_TT_EDIT_UNDO        },
                        { IDM_EDIT_FIND,        IDS_TT_EDIT_FIND        }
                    };
    INT idTT = -1;
    for (INT i = 0; i < ARRAYSIZE(CmdTTXRef) && -1 == idTT; i++)
    {
        if (CmdTTXRef[i].idCmd == pToolTipText->hdr.idFrom)
            idTT = CmdTTXRef[i].idTT;
    }

    if (-1 != idTT)
    {
        m_strDispText.Format(g_hInstDll, idTT);
        pToolTipText->lpszText = (LPTSTR)m_strDispText;
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::LV_OnTTN_NeedText

    Description: Handles requests for tooltip text for the listview tooltip
        window.  This is where we get the foldername DOMAIN/USERNAME text for when the
        "domain name" column is hidden.

    Arguments:
        pToolTipText - Address of tooltip text notification information.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
    10/11/96    Added support for draggable columns.                 BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::LV_OnTTN_NeedText(
    TOOLTIPTEXT *pToolTipText
    )
{
    //
    // Only provide text when the mouse is over the "User Name" column.
    //
    if (-1 != m_iLastItemHit)
    {
        INT cxMin    = 0;
        INT cxMax    = 0;
        INT cHdrs    = Header_GetItemCount(m_hwndHeader);

        for (INT i = 0; i < cHdrs; i++)
        {
            //
            // Find the left and right X coordinate for the "Name" column.
            //
            INT iCol  = Header_OrderToIndex(m_hwndHeader, i);
            INT cxCol = ListView_GetColumnWidth(m_hwndListView, iCol);
            if (DetailsView::idCol_Name == m_ColMap.SubItemToId(iCol))
            {
                cxMax = cxMin + cxCol;
                break;
            }
            else
            {
                cxMin += cxCol;
            }
        }
        //
        // cxMin now contains left edge of Name column.
        // cxMax now contains right edge of Name column.
        //
        if (m_ptMouse.x >= cxMin && m_ptMouse.x <= cxMax)
        {
            PDISKQUOTA_USER pUser = NULL;

            if (m_UserList.Retrieve((LPVOID *)&pUser, m_iLastItemHit))
            {
                TCHAR szContainer[MAX_DOMAIN]          = { TEXT('\0') };
                TCHAR szLogonName[MAX_USERNAME]        = { TEXT('\0') };
                TCHAR szDisplayName[MAX_FULL_USERNAME] = { TEXT('\0') };

                pUser->GetName(szContainer,   ARRAYSIZE(szContainer),
                               szLogonName, ARRAYSIZE(szLogonName),
                               szDisplayName, ARRAYSIZE(szDisplayName));

                if (TEXT('\0') != szContainer[0] && TEXT('\0') != szLogonName[0])
                {
                    if (TEXT('\0') != szDisplayName[0])
                        m_strDispText.Format(g_hInstDll,
                                      IDS_FMT_DISPLAY_LOGON_CONTAINER,
                                      szDisplayName,
                                      szLogonName,
                                      szContainer);
                    else
                        m_strDispText.Format(g_hInstDll,
                                      IDS_FMT_LOGON_CONTAINER,
                                      szLogonName,
                                      szContainer);

                    pToolTipText->lpszText = (LPTSTR)m_strDispText;
                }
                else
                {
                    pToolTipText->lpszText = NULL;
                    pToolTipText->szText[0] = TEXT('\0');
                }
            }
        }
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_OwnerDataFindItem

    Description: Handles LVN_ODFINDITEM for the listview control.

    Arguments:
        pFindInfo - Address of NMLVFINDITEM structure associated with the
            notification.

    Returns: 0-based index of found item.  -1 if not found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.  Ownerdraw listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_OwnerDataFindItem(
    NMLVFINDITEM *pFindInfo
    )
{
    INT iItem = -1;
    switch(pFindInfo->lvfi.flags)
    {
        case LVFI_PARAM:
        {
            LPVOID pvUser = NULL;

            m_UserList.Lock();
            INT cUsers = m_UserList.Count();
            for (INT i = 0; i < cUsers; i++)
            {
                if (m_UserList.Retrieve(&pvUser, i) &&
                    pvUser == (LPVOID)pFindInfo->lvfi.lParam)
                {
                    iItem = i;
                    break;
                }
            }
            m_UserList.ReleaseLock();
            break;
        }

        default:
            //
            // This app only uses lParam for locating items.
            //
            break;
    }
    return iItem;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo

    Description: Handles LVN_GETDISPINFO for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/21/97    Initial creation.  Ownerdraw listview.               BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo(
    LV_DISPINFO * pDispInfo
    )
{
    PDISKQUOTA_USER pUser = NULL;

    m_UserList.Retrieve((LPVOID *)&pUser, pDispInfo->item.iItem);
    if (NULL != pUser)
    {
        if (LVIF_TEXT & pDispInfo->item.mask)
            OnLVN_GetDispInfo_Text(pDispInfo, pUser);

        if ((LVIF_IMAGE & pDispInfo->item.mask) &&
           (m_ColMap.SubItemToId(pDispInfo->item.iSubItem) == DetailsView::idCol_Status))

        {
            OnLVN_GetDispInfo_Image(pDispInfo, pUser);
        }
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo_Text

    Description: Handles LVN_GETDISPINFO - LVIF_TEXT for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

        pUser - Address of user object for listview item.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/22/96    Added user "full name" support.                      BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo_Text(
    LV_DISPINFO *pDispInfo,
    PDISKQUOTA_USER pUser
    )
{
    HRESULT hResult = NO_ERROR;
    LONGLONG llValue;
    NUMBERFMT NumFmt;

    DBGASSERT((NULL != pDispInfo));
    DBGASSERT((NULL != pUser));

    NumFmt.NumDigits = 0;
    m_strDispText.Empty();

    switch(m_ColMap.SubItemToId(pDispInfo->item.iSubItem))
    {
        case DetailsView::idCol_Status:
            DBGASSERT((NULL != pUser));
            switch(GetUserQuotaState(pUser))
            {
                case iUSERSTATE_OK:
                    m_strDispText = m_strStatusOK;
                    break;
                case iUSERSTATE_WARNING:
                    m_strDispText = m_strStatusWarning;
                    break;
                default:
                    DBGASSERT((0));
                    //
                    // Fall through.
                    //
                case iUSERSTATE_OVERLIMIT:
                    m_strDispText = m_strStatusOverlimit;
                    break;
            }
            break;

        case DetailsView::idCol_Folder:
        {
            DWORD dwAccountStatus = 0;
            DBGASSERT((NULL != pUser));
            pUser->GetAccountStatus(&dwAccountStatus);
            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
            {
                pUser->GetName(m_strDispText.GetBuffer(MAX_PATH),
                               MAX_PATH,
                               NULL,
                               0,
                               NULL,
                               0);
            }
            else
            {
                //
                // Non-normal account status.  Leave domain column
                // blank.  Account name column will contain status information.
                //
            }
            break;
        }

        case DetailsView::idCol_Name:
        {
            DWORD dwAccountStatus = 0;
            DBGASSERT((NULL != pUser));
            pUser->GetAccountStatus(&dwAccountStatus);
            switch(dwAccountStatus)
            {
                case DISKQUOTA_USER_ACCOUNT_RESOLVED:
                    pUser->GetName(NULL,       0,
                                   NULL,       0,
                                   m_strDispText.GetBuffer(MAX_USERNAME), MAX_USERNAME);

                    m_strDispText.ReleaseBuffer();
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                    m_strDispText = m_strAccountUnresolved;
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
                    m_strDispText = m_strAccountUnknown;
                    break;

                case DISKQUOTA_USER_ACCOUNT_INVALID:
                    m_strDispText = m_strAccountInvalid;
                    break;

                case DISKQUOTA_USER_ACCOUNT_DELETED:
                    m_strDispText = m_strAccountDeleted;
                    break;

                case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                    m_strDispText = m_strAccountUnavailable;
                    break;
            }
            break;
        }

        case DetailsView::idCol_LogonName:
        {
            DBGASSERT((NULL != pUser));

            DWORD dwAccountStatus = 0;
            pUser->GetAccountStatus(&dwAccountStatus);
            if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
            {
                //
                // If the account SID has been resolved to a name,
                // display the name.
                //
                pUser->GetName(NULL,       0,
                               m_strDispText.GetBuffer(MAX_USERNAME), MAX_USERNAME,
                               NULL,       0);
                m_strDispText.ReleaseBuffer();
            }
            else
            {
                //
                // If the account SID has NOT been resolved to a name, display
                // the SID as a string.
                //
                BYTE Sid[MAX_SID_LEN];
                DWORD cchSidStr = MAX_PATH;
                if (SUCCEEDED(pUser->GetSid(Sid, ARRAYSIZE(Sid))))
                {
                    SidToString(Sid, m_strDispText.GetBuffer(cchSidStr), &cchSidStr);
                    m_strDispText.ReleaseBuffer();
                }
            }
            break;
        }

        case DetailsView::idCol_AmtUsed:
            pUser->GetQuotaUsed(&llValue);
            XBytes::FormatByteCountForDisplay(llValue,
                                              m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_Limit:
            pUser->GetQuotaLimit(&llValue);

            if (NOLIMIT == llValue)
                m_strDispText = m_strNoLimit;
            else
                XBytes::FormatByteCountForDisplay(llValue,
                                                  m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_Threshold:
            pUser->GetQuotaThreshold(&llValue);

            if (NOLIMIT == llValue)
                m_strDispText = m_strNoLimit;
            else
                XBytes::FormatByteCountForDisplay(llValue,
                                      m_strDispText.GetBuffer(40), 40);
            break;

        case DetailsView::idCol_PctUsed:
        {
            DWORD dwPct = 0;
            hResult = CalcPctQuotaUsed(pUser, &dwPct);

            if (SUCCEEDED(hResult))
                m_strDispText.Format(TEXT("%1!d!"), dwPct);
            else
                m_strDispText = m_strNotApplicable; // Not a number.

            break;
        }

        default:
            break;
    }
    pDispInfo->item.pszText = (LPTSTR)m_strDispText;  // Used by all text callbacks.
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_GetDispInfo_Image

    Description: Handles LVN_GETDISPINFO - LVIF_IMAGE for the listview control.

    Arguments:
        pDispInfo - Address of LV_DISPINFO structure associated with the
            notification.

        pUser - Address of user object for listview item.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/12/96    Added CheckMark icon.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_GetDispInfo_Image(
    LV_DISPINFO *pDispInfo,
    PDISKQUOTA_USER pUser
    )
{
    switch(GetUserQuotaState(pUser))
    {
        case iUSERSTATE_OK:
            pDispInfo->item.iImage = iIMAGELIST_ICON_OK;
            break;
        case iUSERSTATE_WARNING:
            pDispInfo->item.iImage = iIMAGELIST_ICON_WARNING;
            break;
        default:
            DBGASSERT((0));
            //
            // Fall through.
            //
        case iUSERSTATE_OVERLIMIT:
            pDispInfo->item.iImage = iIMAGELIST_ICON_LIMIT;
            break;
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetUserQuotaState

    Description: Determines which of 3 states the user's quota values place
        the user in.  This is mainly used to determine what icon to display
        in the "Status" column.  It is also used to determine what text
        to display in the "Status" column in a drag-drop report.

    Arguments:
        pUser - Address of user object for listview item.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::GetUserQuotaState(
    PDISKQUOTA_USER pUser
    )
{
    LONGLONG llUsed;
    LONGLONG llLimit;
    INT iState = iUSERSTATE_OK;

    DBGASSERT((NULL != pUser));

    pUser->GetQuotaUsed(&llUsed);
    pUser->GetQuotaLimit(&llLimit);

    if (NOLIMIT != llLimit && llUsed > llLimit)
    {
        iState = iUSERSTATE_OVERLIMIT;
    }
    else
    {
        LONGLONG llThreshold;
        pUser->GetQuotaThreshold(&llThreshold);

        if (NOLIMIT != llThreshold && llUsed > llThreshold)
            iState = iUSERSTATE_WARNING;
    }

    return iState;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_ColumnClick

    Description: Handles LVN_COLUMNCLICK list view notifications.
        This is received when the user selects a column's label.

    Arguments:
        pNm - Address of listview notification message structure.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_ColumnClick(
    NM_LISTVIEW *pNm
    )
{
    INT idCol = m_ColMap.SubItemToId(pNm->iSubItem);

    if (idCol != m_iLastColSorted)
    {
        //
        // New column selected.  Reset to ascending sort order.
        //
        m_fSortDirection = 0;
    }
    else
    {
        //
        // Column selected more than once.  Toggle sort order.
        //
        m_fSortDirection ^= 1;
    }

    SortObjects(idCol, m_fSortDirection);

    //
    // Remember what column was selected.
    //
    m_iLastColSorted = idCol;

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnLVN_ItemChanged

    Description: Handles LVN_ITEMCHANGED listview notifications.
        Updates the selected-item-count in the status bar.

    Arguments:
        pNm - Address of listview notification structure.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/18/97    Added promotion of user object in name resolution    BrianAu
                queue.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnLVN_ItemChanged(
    NM_LISTVIEW *pNm
    )
{
    if (LVIS_FOCUSED & pNm->uNewState)
    {
        if (!m_bMenuActive)
        {
            //
            // Only update the item count if a menu item is not active.
            // This method is called WHENEVER an item is updated.  This includes
            // asynchronous notifications following name resolution.  Without
            // this check, a menu's descriptive text can be overwritten while
            // the user is walking through menu items.
            //
            ShowItemCountInStatusBar();
        }

        PDISKQUOTA_USER pUser = NULL;
        m_UserList.Lock();
        m_UserList.Retrieve((LPVOID *)&pUser, pNm->iItem);

        if (NULL != pUser &&
            NULL != m_pQuotaControl)
        {
            DWORD dwAccountStatus = 0;
            pUser->GetAccountStatus(&dwAccountStatus);

            if (DISKQUOTA_USER_ACCOUNT_UNRESOLVED == dwAccountStatus)
            {
                //
                // If the user object hasn't been resolved yet, promote it to the
                // head of the quota controller's SID-Name resolver queue.
                // This will speed up the name resolution for this user without
                // performing a blocking operation.
                //
                m_pQuotaControl->GiveUserNameResolutionPriority(pUser);
            }
        }
        m_UserList.ReleaseLock();
    }
    else if ((0 == pNm->uNewState) || (LVIS_SELECTED & pNm->uNewState))
    {
        ShowItemCountInStatusBar();
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SetFocus

    Description: Called whenever the main window receives focus.  Immediately
        transfers focus to the listview control.  The listview in turn
        ensures that one or more items are highlighted.

    Arguments: Std WndProc arguments.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnSetFocus(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (NULL != m_hwndListView)
        SetFocus(m_hwndListView);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnSize

    Description: Handles WM_SIZE message.

    Arguments: Standard WndProc arguments.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    05/20/97    Added positioning of "Find User" combo in toolbar.   BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnSize(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT rcMain;
    RECT rcListView;

    GetClientRect(hWnd, &rcMain);  // How big's the main window?

    rcListView = rcMain;

    if (m_lvsi.fToolBar)
    {
        //
        // Adjust toolbar if it's visible.
        //
        RECT rcToolBar;
        INT cyToolBar = 0;

        SendMessage(m_hwndToolBar, message, wParam, lParam);
        GetClientRect(m_hwndToolBar, &rcToolBar);

        cyToolBar = rcToolBar.bottom - rcToolBar.top;

        rcListView.top += (cyToolBar + 1);

        //
        // Position the "Find User" combo box to the immediate right of the
        // "Find" toolbar button.
        // This code assumes that the "Find" toolbar button is the right-most
        // button in the toolbar.
        //
        INT cButtons = (INT)SendMessage(m_hwndToolBar, TB_BUTTONCOUNT, 0, 0);
        if (0 < cButtons)
        {
            RECT rcButton;
            SendMessage(m_hwndToolBar, TB_GETITEMRECT, cButtons - 1, (LPARAM)&rcButton);

            RECT rcCombo;
            GetWindowRect(m_hwndToolbarCombo, &rcCombo);

            SetWindowPos(m_hwndToolbarCombo,
                         NULL,
                         rcButton.right + 1,
                         rcButton.top + 1,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

        }
    }


    if (m_lvsi.fStatusBar)
    {
        //
        // Adjust status bar if it's visible.
        //
        RECT rcStatusBar;
        INT cyStatusBar = 0;

        SendMessage(m_hwndStatusBar, message, wParam, lParam);
        GetClientRect(m_hwndStatusBar, &rcStatusBar);

        cyStatusBar = rcStatusBar.bottom - rcStatusBar.top;

        rcListView.bottom -= cyStatusBar;
    }

    //
    // Adjust the listview.  Accounts for toolbar and status bar.
    //
    MoveWindow(m_hwndListView,
               0,
               rcListView.top,
               rcListView.right - rcListView.left,
               rcListView.bottom - rcListView.top,
               TRUE);

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SelectAllItems

    Description: Highlights all items in the listview for selection.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::SelectAllItems(
    VOID
    )
{
    INT cItems    = ListView_GetItemCount(m_hwndListView);
    DWORD dwState = 0;

    CAutoWaitCursor waitcursor;
    SetFocus(m_hwndListView);
    //
    // This isn't documented but it's the way the shell does it for DefView.
    //
    ListView_SetItemState(m_hwndListView, -1, LVIS_SELECTED, LVIS_SELECTED);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::InvertSelection

    Description: Selects all items that are not selected and unselects all
        items that are.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::InvertSelectedItems(
    VOID
    )
{
    INT iItem = -1;

    CAutoWaitCursor waitcursor;
    SetFocus(m_hwndListView);
    while ((iItem = ListView_GetNextItem(m_hwndListView, iItem, 0)) != -1)
    {
        DWORD dwState;

        dwState = ListView_GetItemState(m_hwndListView, iItem, LVIS_SELECTED);
        dwState ^= LVNI_SELECTED;
        ListView_SetItemState(m_hwndListView, iItem, dwState, LVIS_SELECTED);
    }
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnHelpAbout

    Description: Handler for "About Windows NT" menu option.

    Arguments:
        hWnd - Handle of parent window for "about" dialog.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnHelpAbout(
    HWND hWnd
    )
{
    TCHAR szOpSysName[MAX_PATH];

    LoadString(g_hInstDll, IDS_WINDOWS, szOpSysName, ARRAYSIZE(szOpSysName));
    ShellAbout(hWnd, szOpSysName, NULL, NULL);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnHelpTopics

    Description: Handler for "Help Topics" menu option.

    Arguments:
        hWnd - Handle of parent window for the help UI.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnHelpTopics(
    HWND hWnd
    )
{
    const char szHtmlHelpFileA[]  = "DSKQUOUI.CHM > windefault";
    const char szHtmlHelpTopicA[] = "sag_DQtopnode.htm";

    HtmlHelpA(hWnd,
             szHtmlHelpFileA,
             HH_DISPLAY_TOPIC,
             (DWORD_PTR)szHtmlHelpTopicA);
    return 0;
}



bool
DetailsView::SingleSelectionIsAdmin(
    void
    )
{
    bool bResult = false;

    if (1 == ListView_GetSelectedCount(m_hwndListView))
    {
        INT iItem = ListView_GetNextItem(m_hwndListView, -1, LVNI_SELECTED);
        if (-1 != iItem)
        {
            PDISKQUOTA_USER pUser = NULL;
            if (m_UserList.Retrieve((LPVOID *)&pUser, iItem) && NULL != pUser)
            {
                bResult = !!UserIsAdministrator(pUser);
            }
        }
    }
    return bResult;
}


//
// NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
//
// This workaround was added for bug 157269.  However,
// the root cause is bug 24904.  Once 24904 is fixed, we should
// be able to remove this code.  Bug 157269 provides a detailed
// explanation of the issue.
//
// Since it's a temporary function and doesn't use any members
// of the DetailsView class I chose to not make it a member
// of DetailsView.  The logic used is taken from 
// DiskQuotaControl::AddUserSid.
//
// The Retry and sleep code is a total hack.  
//
bool 
UserWasReallyDeleted(
    IDiskQuotaControl *pQuotaControl, 
    IDiskQuotaUser *pIUser
    )
{
    bool bDeleted = true;
    BYTE rgbSid[MAX_SID_LEN];
    HRESULT hr = pIUser->GetSid(rgbSid, sizeof(rgbSid));
    if (SUCCEEDED(hr))
    {
        IDiskQuotaUser *pIUserTemp;
        hr = pQuotaControl->FindUserSid(rgbSid,
                                        DISKQUOTA_USERNAME_RESOLVE_NONE,
                                        &pIUserTemp);
        if (SUCCEEDED(hr))
        {
            const int MAX_RETRY_COUNT = 1;
            const DWORD RETRY_WAIT_MS = 100;

            for (int i = 0; i <= MAX_RETRY_COUNT && bDeleted; i++)
            {
                LONGLONG llLimit;
                LONGLONG llThreshold;
                LONGLONG llUsed;

                pIUserTemp->GetQuotaLimit(&llLimit);
                pIUserTemp->GetQuotaThreshold(&llThreshold);
                pIUserTemp->GetQuotaUsed(&llUsed);

                bDeleted = ((MARK4DEL == llLimit) ||
                            ( 0 == llLimit && 
                              0 == llThreshold && 
                              0 == llUsed));

                if (bDeleted && i < MAX_RETRY_COUNT)
                {
                    Sleep(RETRY_WAIT_MS);
                    //
                    // Invalidate cached data so next request fetches from
                    // volume, not memory.
                    //
                    pIUserTemp->Invalidate();
                }
            }
            pIUserTemp->Release();
        }
    }
    return bDeleted;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdDelete

    Description: Called whenever the user presses DEL or selects the "Delete"
        option from the main menu, context menu or toolbar.
        The method attempts to delete the selected records.  Any records that
        have 1+ bytes charged to them will not be deleted.  A message box
        is displayed informing the user if any selected records have 1+ bytes.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/11/96    Initial creation.                                    BrianAu
    03/11/98    Added code for resolving "owned" files.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdDelete(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    //
    // Make sure they really want to do this.
    // Early return if they don't.
    // Don't ask if it's a single selection and the selected user
    // is BUILTIN/Administrators.  This user can't be deleted anyway so
    // we don't want to ask for confirmation.  The deletion attempt will
    // fail later and we'll display a "can't be deleted" msgbox.
    //
    if (!SingleSelectionIsAdmin() && IDNO == DiskQuotaMsgBox(m_hwndListView,
                                                             IDS_CONFIRM_DELETE_USER,
                                                             IDS_TITLE_DISK_QUOTA,
                                                             MB_ICONWARNING | MB_YESNO))
    {
        return 0;
    }

    //
    // Clear any previous undo actions.
    // Only allow undo for a single delete (single or multi-user) operation.
    //
    m_pUndoList->Clear();

    CAutoWndEnable autoenable(m_hwndListView);
    PDISKQUOTA_USER pUser = NULL;
    INT iItem             = -1;
    INT cItemsToDelete    = ListView_GetSelectedCount(m_hwndListView);
    ProgressDialog dlgProgress(IDD_PROGRESS,
                               IDC_PROGRESS_BAR,
                               IDC_TXT_PROGRESS_DESCRIPTION,
                               IDC_TXT_PROGRESS_FILENAME);

    if (2 < cItemsToDelete)
    {
        //
        // Create and display a progress dialog if we're deleting more than 2
        // user quota records.
        //
        if (dlgProgress.Create(g_hInstDll,
                               m_hwndMain))
        {
            autoenable.Enable(false);
            dlgProgress.ProgressBarInit(0, cItemsToDelete, 1);
            dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_DELETING));
            dlgProgress.Show();
        }
    }

    //
    // Set each user's threshold and limit to -2 (MARK4DEL) and remove the
    // item from the listview.
    // A limit of -2 tells the quota system (NTFS) that the record should be
    // removed from the quota file.  However, if the user still has quota
    // charged, the record will be restored.
    //
    CAutoSetRedraw autoredraw(m_hwndListView, false);
    CArray<IDiskQuotaUser *> rgpUsersWithFiles;
    LONGLONG Threshold;
    LONGLONG Limit;


    while(-1 != (iItem = ListView_GetNextItem(m_hwndListView, iItem, LVNI_SELECTED)) &&
          !dlgProgress.UserCancelled())
    {
        if (m_UserList.Retrieve((LPVOID *)&pUser, iItem))
        {
            if (UserIsAdministrator(pUser))
            {
                //
                // Deletion of the BUILTINS\Administrators quota record is not
                // allowed.
                //
                CString strText(g_hInstDll, IDS_CANT_DELETE_ADMIN_RECORD);
                DiskQuotaMsgBox(dlgProgress.m_hWnd ? dlgProgress.m_hWnd : m_hwndListView,
                                strText,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONWARNING | MB_OK);
            }
            else
            {
                //
                // Get threshold and limit values for undo action.
                //
                pUser->GetQuotaThreshold(&Threshold);
                pUser->GetQuotaLimit(&Limit);

                //
                // Remove the user from the quota file.
                //
                hResult = m_pQuotaControl->DeleteUser(pUser);
                if (SUCCEEDED(hResult))
                {
                    if (!UserWasReallyDeleted(m_pQuotaControl, pUser))
                    {
                        //
                        // NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
                        //
                        // This workaround was added for bug 157269.  However,
                        // the root cause is bug 24904.  Once 24904 is fixed, we should
                        // be able to remove this code.  Bug 157269 provides a detailed
                        // explanation of the issue.
                        //
                        pUser->SetQuotaThreshold(Threshold, TRUE);
                        pUser->SetQuotaLimit(Limit, TRUE);
                    }
                    else
                    {
                        pUser->AddRef(); // Giving ptr to UNDO list.
                        try
                        {
                            autoptr<UndoDelete> ptrUndoDelete = new UndoDelete(pUser, Threshold, Limit);
                            m_pUndoList->Add(ptrUndoDelete);
                            ptrUndoDelete.disown();
                        }
                        catch(CAllocException& e)
                        {
                            pUser->Release(); // Release from Undo list.
                            EnableWindow(m_hwndMain, TRUE);
                            throw;
                        }

                        ListView_DeleteItem(m_hwndListView, iItem);
                        //
                        // Deletion is successful.  Now actually remove the user from
                        // the user list.
                        //
                        m_UserList.Remove((LPVOID *)&pUser, iItem);

                        pUser->Release();  // Release from listview.
                        //
                        // Decrement the search index by 1 since what was index + 1
                        // is now index.  ListView_GetNextItem ignores the item at "index".
                        //
                        iItem--;
                    }
                    dlgProgress.ProgressBarAdvance();
                }
                else if (ERROR_FILE_EXISTS == HRESULT_CODE(hResult))
                {
                    //
                    // One more we couldn't delete.
                    //
                    rgpUsersWithFiles.Append(pUser);
                }
            }
        }
    }

    if (0 < rgpUsersWithFiles.Count())
    {
        //
        // Display a dialog listing users selected for deletion and
        // and the files owned by those users on this volume.  From the dialog,
        // the admin can Delete, Move or Take Ownership of the files.
        //
        dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_SEARCHINGFORFILES));
        CFileOwnerDialog dlg(g_hInstDll,
                             dlgProgress.m_hWnd ? dlgProgress.m_hWnd : m_hwndListView,
                             m_idVolume.FSPath(),
                             rgpUsersWithFiles);
        dlg.Run();
        dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_DELETING));

        int cUsers = rgpUsersWithFiles.Count();
        int cCannotDelete = 0;
        for (int i = 0; i < cUsers; i++)
        {
            pUser = rgpUsersWithFiles[i];
            //
            // Get threshold and limit values for undo action.
            //
            pUser->GetQuotaThreshold(&Threshold);
            pUser->GetQuotaLimit(&Limit);

            //
            // Try to remove the user from the quota file.
            //
            hResult = m_pQuotaControl->DeleteUser(pUser);
            if (SUCCEEDED(hResult))
            {
                if (!UserWasReallyDeleted(m_pQuotaControl, pUser))
                {
                    //
                    // NTRAID#NTBUG9-157269-2000/08/08-BrianAu  Temporary workaround.
                    //
                    // This workaround was added for bug 157269.  However,
                    // the root cause is bug 24904.  Once 24904 is fixed, we should
                    // be able to remove this code.  Bug 157269 provides a detailed
                    // explanation of the issue.
                    //
                    pUser->SetQuotaThreshold(Threshold, TRUE);
                    pUser->SetQuotaLimit(Limit, TRUE);
                }
                else
                {
                    pUser->AddRef(); // Giving ptr to UNDO list.
                    try
                    {
                        autoptr<UndoDelete> ptrUndoDelete = new UndoDelete(pUser, Threshold, Limit); 
                        m_pUndoList->Add(ptrUndoDelete);
                        ptrUndoDelete.disown();
                    }
                    catch(CAllocException& e)
                    {
                        pUser->Release(); // Release from Undo list.
                        throw;
                    }

                    iItem = FindUserByObjPtr(pUser);
                    if (-1 != iItem)
                    {
                        ListView_DeleteItem(m_hwndListView, iItem);
                        //
                        // Deletion is successful.  Now actually remove the user from
                        // the user list.
                        //
                        m_UserList.Remove((LPVOID *)&pUser, iItem);
                        pUser->Release();  // Release from listview.
                    }
                }
                dlgProgress.ProgressBarAdvance();
            }
            else if (ERROR_FILE_EXISTS == HRESULT_CODE(hResult))
            {
                cCannotDelete++;
            }
        }
        if (0 < cCannotDelete)
        {
            //
            // One or more records could not be deleted because they have
            // disk space charged to them.
            //
            CString strText;

            if (1 == cCannotDelete)
                strText.Format(g_hInstDll, IDS_CANNOT_DELETE_USER);
            else
                strText.Format(g_hInstDll, IDS_CANNOT_DELETE_USERS, cCannotDelete);

            DiskQuotaMsgBox(m_hwndListView,
                            strText,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONINFORMATION | MB_OK);
        }
    }

    ShowItemCountInStatusBar();

    if (FAILED(hResult) && ERROR_FILE_EXISTS != HRESULT_CODE(hResult))
    {
        //
        // Something bad happened.
        // FEATURE: Do we need to discriminate between a general failure and
        //         a quota file write error?
        //
        DiskQuotaMsgBox(m_hwndListView,
                        IDS_ERROR_DELETE_USER,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return 0;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdUndo

    Description: Called whenever the user presses Ctrl + Z or selects
        the "Undo" option from the main menu, context menu or toolbar.
        The method invokes the current undo list to "undo" its actions.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/01/96    Initial creation.                                    BrianAu
    02/26/97    Added call to update status bar.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdUndo(
    VOID
    )
{
    if (NULL != m_pUndoList)
    {
        CAutoWaitCursor waitcursor;
        m_pUndoList->Undo();
        ShowItemCountInStatusBar();
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdFind

    Description: Called whenever the user presses Ctrl + F or selects
        the "Find" option from the main menu, context menu or toolbar.
        The method invokes the "Find User" dialog.

    Arguments: None.

    Returns: Always 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdFind(
    VOID
    )
{
    if (NULL != m_pUserFinder)
    {
        m_pUserFinder->InvokeFindDialog(m_hwndListView);
    }
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdProperties

    Description: Displays a properties dialog for one or more selected objects.
        Invoked when the user selects a "Properties" menu option, dbl clicks
        a selection or presses Return for a selection.

    Arguments: None.

    Returns: Always returns 0.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    09/10/96    Added passing of LVSelection to prop sheet ctor.     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdProperties(
    VOID
    )
{
    LVSelection lvs(m_hwndListView);

    INT iItem = -1;

    //
    // Fill in arrays of user pointers and item indices.
    //
    while(-1 != (iItem = ListView_GetNextItem(m_hwndListView, iItem, LVNI_SELECTED)))
    {
        LPVOID pvUser = 0;

        if (m_UserList.Retrieve(&pvUser, iItem))
        {
            //
            // Add user object pointer and item index to the selection object.
            // We'll use this container to communicate the selected items to the
            // property sheet object.
            // This can throw OutOfMemory.
            //
            lvs.Add((PDISKQUOTA_USER)pvUser, iItem);
        }
    }

    if (0 < lvs.Count())
    {
        //
        // Create and run the property sheet.  It's modal.
        // There's a condition where the user can select in the listview and
        // nothing is actually selected (i.e. select below the last item).
        // Therefore, we need the (0 < count) check.
        //
        m_pQuotaControl->AddRef();
        UserPropSheet ups(m_pQuotaControl,
                          m_idVolume,
                          m_hwndListView,
                          lvs,
                          *m_pUndoList);
        ups.Run();
    }

    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdNew

    Description: Displays a properties dialog for adding a new user to the
        quota information file.
        Invoked when the user selects the "New" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/27/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdNew(
    VOID
    )
{
    //
    // Create and run the AddUser dialog.
    // Note that it first launches the DS Object Picker dialog.
    //
    m_pQuotaControl->AddRef();
    AddUserDialog dlg(m_pQuotaControl,
                      m_idVolume,
                      g_hInstDll,
                      m_hwndListView,
                      m_hwndListView,
                      *m_pUndoList);
    dlg.Run();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CreateVolumeDisplayName [static]

    Description: Obtains the display name used by the shell for a given
        volume.

    Arguments:
        pszDrive - Address of string containing drive name (i.e. "C:\").

        pstrDisplayName - Address of CString object to receive the
            display name.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CreateVolumeDisplayName(
    const CVolumeID& idVolume, // [in] - "C:\" or "\\?\Volume{ <guid }\"
    CString *pstrDisplayName   // [out] - "My Disk (C:)"
    )
{
    HRESULT hr = E_FAIL;

    if (idVolume.IsMountedVolume())
    {
        //
        // If it's a mounted volume thingy "\\?\Volume{ <guid> }\", the shell won't
        // understand it.  Just use the default display name provided by the
        // CVolumeID object.
        //
        *pstrDisplayName = idVolume.ForDisplay();
    }
    else
    {
        //
        // It's a normal volume.  Get the display name the shell uses.
        //
        com_autoptr<IShellFolder> ptrDesktop;
        //
        // Bind to the desktop folder.
        //
        hr = SHGetDesktopFolder(ptrDesktop.getaddr());
        if (SUCCEEDED(hr))
        {
            sh_autoptr<ITEMIDLIST> ptrIdlDrives;
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, ptrIdlDrives.getaddr());
            if (SUCCEEDED(hr))
            {
                //
                // Bind to the "Drives" folder.
                //
                com_autoptr<IShellFolder> ptrDrives;
                hr = ptrDesktop->BindToObject(ptrIdlDrives, NULL, IID_IShellFolder, (LPVOID *)ptrDrives.getaddr());
                if (SUCCEEDED(hr))
                {
                    com_autoptr<IEnumIDList> ptrEnum;

                    //
                    // Enumerate all of the non-folder objects in the drives folder.
                    //
                    hr = ptrDrives->EnumObjects(NULL, SHCONTF_NONFOLDERS, ptrEnum.getaddr());
                    if (SUCCEEDED(hr))
                    {
                        sh_autoptr<ITEMIDLIST> ptrIdlItem;
                        ULONG ulFetched = 0;
                        LPCTSTR pszDrive = idVolume.ForParsing();
                        //
                        // For each item in the drives folder...
                        //
                        while(S_OK == ptrEnum->Next(1, ptrIdlItem.getaddr(), &ulFetched))
                        {
                            STRRET strretName;
                            //
                            // Get the non-display name form; i.e. "G:\"
                            //
                            hr = ptrDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_FORPARSING, &strretName);
                            if (SUCCEEDED(hr))
                            {
                                TCHAR szName[MAX_PATH];
                                StrRetToBuf(&strretName, ptrIdlItem, szName, ARRAYSIZE(szName));
                                if (TEXT(':') == szName[1] &&
                                    *pszDrive == szName[0])
                                {
                                    //
                                    // Get the display name form; i.e. "My Disk (G:)"
                                    //
                                    hr = ptrDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_NORMAL, &strretName);
                                    if (SUCCEEDED(hr))
                                    {
                                        StrRetToBuf(&strretName, ptrIdlItem, pstrDisplayName->GetBuffer(MAX_PATH), MAX_PATH);
                                        pstrDisplayName->ReleaseBuffer();
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdImport

    Description: Called when the user selects the "Import" option on the
        "Quota" menu.  Presents the "Open File" common dialog to get the
        name for the file containing the import information.  Then passes
        the path off to an Importer object to do the actual import.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdImport(
    VOID
    )
{
    HRESULT hResult            = NO_ERROR;
    TCHAR szFileName[MAX_PATH] = { TEXT('\0') };
    TCHAR szTitle[80] = { TEXT('\0') };
    LoadString(g_hInstDll, IDS_DLGTITLE_IMPORT, szTitle, ARRAYSIZE(szTitle));

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner   = m_hwndMain;
    ofn.hInstance   = g_hInstDll;
    ofn.lpstrFile   = szFileName;
    ofn.lpstrTitle  = szTitle;
    ofn.nMaxFile    = ARRAYSIZE(szFileName);
    ofn.Flags       = OFN_HIDEREADONLY | OFN_NOCHANGEDIR |
                      OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    //
    // Get name of import file from user and import the files.
    //
    if (GetOpenFileName(&ofn))
    {
        Importer importer(*this);
        hResult = importer.Import(ofn.lpstrFile);
    }

    return SUCCEEDED(hResult);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdExport

    Description: Called when the user selects the "Export" option on the
        "Quota" menu or listview context menu.  Presents the "Save File"
        common dialog to get the name for the output file. It then creates
        the doc file, the stream within the doc file and then calls the
        DetailsView's IDataObject implementation to render the data on the
        stream.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdExport(
    VOID
    )
{
    HRESULT hResult           = NO_ERROR;
    IDataObject *pIDataObject = NULL;

    try
    {
        hResult = QueryInterface(IID_IDataObject, (LPVOID *)&pIDataObject);
        if (SUCCEEDED(hResult))
        {
            FORMATETC fmt;
            DataObject::SetFormatEtc(fmt,
                                     DataObject::m_CF_NtDiskQuotaExport,
                                     TYMED_ISTREAM);

            hResult = pIDataObject->QueryGetData(&fmt);
            if (SUCCEEDED(hResult))
            {
                TCHAR szFileName[MAX_PATH] = { TEXT('\0') };
                TCHAR szTitle[80] = { TEXT('\0') };

                LoadString(g_hInstDll, IDS_DLGTITLE_EXPORT, szTitle, ARRAYSIZE(szTitle));

                OPENFILENAME ofn;
                ZeroMemory(&ofn, sizeof(ofn));
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner   = m_hwndMain;
                ofn.hInstance   = g_hInstDll;
                ofn.lpstrFile   = szFileName;
                ofn.lpstrTitle  = szTitle;
                ofn.nMaxFile    = ARRAYSIZE(szFileName);
                ofn.Flags       = OFN_HIDEREADONLY | OFN_NOCHANGEDIR |
                                  OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
                //
                // Get output file name from user.
                //
                if (GetSaveFileName(&ofn))
                {
                    DWORD grfMode = STGM_DIRECT | STGM_READWRITE |
                                    STGM_CREATE | STGM_SHARE_EXCLUSIVE;
                    IStorage *pStg;

                    //
                    // Create the output doc file.
                    //
                    hResult = StgCreateDocfile(ofn.lpstrFile,
                                               grfMode,
                                               0,
                                               &pStg);
                    if (SUCCEEDED(hResult))
                    {
                        //
                        // Create the stream in the doc file.
                        //
                        IStream *pStm;
                        hResult = pStg->CreateStream(DataObject::SZ_EXPORT_STREAM_NAME,
                                                     grfMode,
                                                     0, 0,
                                                     &pStm);
                        if (SUCCEEDED(hResult))
                        {
                            CStgMedium medium;

                            //
                            // Render the quota information onto the file stream.
                            //
                            hResult = pIDataObject->GetData(&fmt, &medium);
                            if (SUCCEEDED(hResult))
                            {
                                const LARGE_INTEGER ofsBegin = {0, 0};
                                ULARGE_INTEGER ofsOriginal   = {0, 0};
                                hResult = medium.pstm->Seek(ofsBegin, STREAM_SEEK_CUR, &ofsOriginal);
                                if (SUCCEEDED(hResult))
                                {
                                    hResult = medium.pstm->Seek(ofsBegin, STREAM_SEEK_SET, NULL);
                                    if (SUCCEEDED(hResult))
                                    {                                
                                        ULARGE_INTEGER cb = {0xFFFFFFFF, 0xFFFFFFFF};
                                        medium.pstm->CopyTo(pStm, cb, NULL, NULL);

                                        const LARGE_INTEGER ofs = { ofsOriginal.LowPart, (LONG)ofsOriginal.HighPart };
                                        medium.pstm->Seek(ofs, STREAM_SEEK_SET, NULL);
                                    }
                                }
                            }
                            pStm->Release();
                        }
                        pStg->Release();
                    }
                    if (FAILED(hResult))
                    {
                        UINT iMsg = IDS_EXPORT_STREAM_FAILED;

                        switch(hResult)
                        {
                            case STG_E_ACCESSDENIED:
                                iMsg = IDS_EXPORT_STREAM_NOACCESS;
                                break;

                            case E_OUTOFMEMORY:
                            case STG_E_INSUFFICIENTMEMORY:
                                iMsg = IDS_EXPORT_STREAM_OUTOFMEMORY;
                                break;

                            case STG_E_INVALIDNAME:
                                iMsg = IDS_EXPORT_STREAM_INVALIDNAME;
                                break;

                            case STG_E_TOOMANYOPENFILES:
                                iMsg = IDS_EXPORT_STREAM_TOOMANYFILES;
                                break;

                            default:
                                break;
                        }
                        DiskQuotaMsgBox(m_hwndMain,
                                        iMsg,
                                        IDS_TITLE_DISK_QUOTA,
                                        MB_ICONERROR | MB_OK);

                    }
                }
            }
            else
            {
                DBGERROR((TEXT("Export: Error 0x%08X returned from QueryGetData."), hResult));
            }
            pIDataObject->Release();
            pIDataObject = NULL;
        }
        else
        {
            DBGERROR((TEXT("Export: Error 0x%08X getting IDataObject."), hResult));
        }
    }
    catch(CAllocException& e)
    {
        if (NULL != pIDataObject)
            pIDataObject->Release();
        throw;
    }
    return SUCCEEDED(hResult);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewStatusBar

    Description:  Toggles the visibility of the status bar.  Invoked when the
        user selects the "Status Bar" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewStatusBar(
    VOID
    )
{
    RECT rc;

    m_lvsi.fStatusBar ^= TRUE;
    ShowWindow(m_hwndStatusBar, m_lvsi.fStatusBar ? SW_SHOW : SW_HIDE);

    //
    // Adjust the main window.
    //
    GetWindowRect(m_hwndMain, &rc);
    OnSize(m_hwndMain, WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right-rc.left,rc.bottom-rc.top));

    //
    // Check the menu item to indicate the current status bar state.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_STATUSBAR,
                  MF_BYCOMMAND | (m_lvsi.fStatusBar ? MF_CHECKED : MF_UNCHECKED));
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewToolBar

    Description:  Toggles the visibility of the tool bar.  Invoked when the
        user selects the "Tool Bar" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewToolBar(
    VOID
    )
{
    RECT rc;

    m_lvsi.fToolBar ^= TRUE;
    ShowWindow(m_hwndToolBar, m_lvsi.fToolBar ? SW_SHOW : SW_HIDE);

    //
    // Adjust the main window.
    //
    GetWindowRect(m_hwndMain, &rc);
    OnSize(m_hwndMain, WM_SIZE, SIZE_RESTORED, MAKELONG(rc.right-rc.left,rc.bottom-rc.top));

    //
    // Check the menu item to indicate the current tool bar state.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_TOOLBAR,
                  MF_BYCOMMAND | (m_lvsi.fToolBar ? MF_CHECKED : MF_UNCHECKED));
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::OnCmdViewShowFolder

    Description:  Toggles the visibility of the Domain Name column.  Invoked
        when the user selects the "Show Domain" menu option.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::OnCmdViewShowFolder(
    VOID
    )
{
    m_lvsi.fShowFolder ^= TRUE;

    if (m_lvsi.fShowFolder)
    {
        //
        // Insert the folder column and DEACTIVATE listview tooltip.
        // Always add at index 1 then shift it to position 0.
        // User can drag it elsewhere if they like.
        // Because of the listview's icon painting behavior, we only let the
        // "status" column be index 0.
        //
        AddColumn(1, g_rgColumns[DetailsView::idCol_Folder]);
        INT cCols = Header_GetItemCount(m_hwndHeader);
        INT rgColIndicies[DetailsView::idCol_Last];
        INT iTemp = 0;

        DBGASSERT((DetailsView::idCol_Last >= cCols));
        Header_GetOrderArray(m_hwndHeader, cCols, rgColIndicies);
        //
        // Swap the column we just added with column 0.
        //
        iTemp = rgColIndicies[0];
        rgColIndicies[0] = rgColIndicies[1];
        rgColIndicies[1] = iTemp;
        Header_SetOrderArray(m_hwndHeader, cCols, rgColIndicies);

        ActivateListViewToolTip(FALSE);
    }
    else
    {
        //
        // Remove the folder column and ACTIVATE listview tooltip.
        // With the column hidden, users can view a user's folder by hovering
        // over the user's name.
        //
        ActivateListViewToolTip(TRUE);
        RemoveColumn(DetailsView::idCol_Folder);
    }

    //
    // Check/Uncheck the "Show Folder" menu item.
    //
    CheckMenuItem(GetMenu(m_hwndMain),
                  IDM_VIEW_SHOWFOLDER,
                  MF_BYCOMMAND | (m_lvsi.fShowFolder ? MF_CHECKED : MF_UNCHECKED));

    //
    // If the folder column is hidden, the "Arrange by Folder" menu option
    // is disabled.
    //
    EnableMenuItem_ArrangeByFolder(m_lvsi.fShowFolder);

    //
    // I haven't found a way to do this without unloading and reloading the
    // objects following the new column configuration.
    //
    Refresh();

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnableMenuItem_ArrangeByFolder

    Description:  Sets the sensitivity of the "by Folder" menu item
        in the "Arrange Items" submenu.

    Arguments:
        bEnable - TRUE = Enable menu item, FALSE = Disable and gray item.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::EnableMenuItem_ArrangeByFolder(
    BOOL bEnable
    )
{
    HMENU hMainMenu        = GetMenu(m_hwndMain);
    HMENU hViewMenu        = GetSubMenu(hMainMenu, iMENUITEM_VIEW);
    HMENU hViewArrangeMenu = GetSubMenu(hViewMenu, iMENUITEM_VIEW_ARRANGE);

    //
    // If these assert, it probably means somebody's changed the
    // menus so that the iMENUITEM_XXXXX constants are no longer correct.
    //
    DBGASSERT((NULL != hViewMenu));
    DBGASSERT((NULL != hViewArrangeMenu));

    EnableMenuItem(hViewArrangeMenu,
                   IDM_VIEW_ARRANGE_BYFOLDER,
                   MF_BYCOMMAND | (bEnable ? MF_ENABLED : MF_GRAYED));
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnableMenuItem_Undo

    Description:  Sets the sensitivity of the "Undo" menu item
        in the "Edit" submenu.

    Arguments:
        bEnable - TRUE = Enable menu item, FALSE = Disable and gray item.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
    10/22/96    Replaced Assert() with nested if's.                  BrianAu
                Tester hit assert via WM_COMMAND when closing
                details view.
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::EnableMenuItem_Undo(
    BOOL bEnable
    )
{
    HMENU hMainMenu = GetMenu(m_hwndMain);

    if (NULL != hMainMenu)
    {
        HMENU hEditMenu  = GetSubMenu(hMainMenu, iMENUITEM_EDIT);
        if (NULL != hEditMenu)
        {
            EnableMenuItem(hEditMenu,
                           IDM_EDIT_UNDO,
                           MF_BYCOMMAND | (bEnable ? MF_ENABLED : MF_GRAYED));

            SendMessage(m_hwndToolBar, TB_ENABLEBUTTON, IDM_EDIT_UNDO, MAKELONG(bEnable, 0));
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ShowItemCountInStatusBar

    Description: Displays the current count of selected items in the status bar.
        This is what is displayed in the status bar when a menu item is not
        currently selected.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    12/16/96    Appended "incorrect data" warning to status bar      BrianAu
                text when quotas are disabled on system.
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::ShowItemCountInStatusBar(
    VOID
    )
{
    DWORD cTotalItems    = m_UserList.Count();
    DWORD cSelectedItems = ListView_GetSelectedCount(m_hwndListView);

    CString strText(g_hInstDll, IDS_STATUSBAR_ITEMCOUNT, cTotalItems, cSelectedItems);
    SendMessage(m_hwndStatusBar, SB_SETTEXT, 0, (LPARAM)((LPCTSTR)strText));

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ShowMenuTextInStatusBar

    Description: Displays the description of the currently-selected menu
        item in the status bar.

    Arguments: None.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::ShowMenuTextInStatusBar(
    DWORD idMenuOption
    )
{
    TCHAR szText[MAX_PATH];

    LoadString(g_hInstDll, idMenuOption, szText, ARRAYSIZE(szText));
    SendMessage(m_hwndStatusBar, SB_SETTEXT, 0, (LPARAM)szText);
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Refresh

    Description: Refreshes the view by re-loading the objects.

    Arguments: bInvalidateCache - true == invalidate all entries in the
                    SID-name cache.  Default is false.

    Returns: Always returns 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
    02/21/97    Ownerdata listview.                                  BrianAu
    10/10/98    Added bInvalidateCache argument.                     BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT
DetailsView::Refresh(
    bool bInvalidateCache    // optional.  default is false.
    )
{
    CAutoWaitCursor waitcursor;
    if (bInvalidateCache)
        m_pQuotaControl->InvalidateSidNameCache();

    InvalidateRect(m_hwndListView, NULL, TRUE);

    CAutoSetRedraw autoredraw(m_hwndListView, false);
    ReleaseObjects();
    autoredraw.Set(true);

    LoadObjects();
    ListView_SetItemCountEx(m_hwndListView,
                            m_UserList.Count(),
                            LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

    SortObjects(m_iLastColSorted, m_fSortDirection);
    ShowItemCountInStatusBar();
    FocusOnSomething();
    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FocusOnSomething

    Description: Ensures that one or more listview items have the focus
        highlighting.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::FocusOnSomething(
    VOID
    )
{
    INT iFocus;

    iFocus = ListView_GetNextItem(m_hwndListView, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(m_hwndListView, iFocus, LVIS_FOCUSED | LVIS_SELECTED,
                                                  LVIS_FOCUSED | LVIS_SELECTED)
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::CalcPctQuotaUsed

    Description: Calculates the percent quota used for a given user.  The
        value returned is an integer.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for user object.

        pdwPct - Address of DWORD to receive the percentage value.
            If the method returns div-by-zero, this value is set to ~0.
            This lets a caller sort erroneous values from valid values.
            The (~0 - 1) return value is used so that NOLIMIT users
            are grouped separate from 0 limit users when sorted on % used.
            Both are using 0% of their quota but it looks better if
            they are each grouped separately.

    Returns:
        NO_ERROR    - Success.
        STATUS_INTEGER_DIVIDE_BY_ZERO - The user's quota limit was 0.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::CalcPctQuotaUsed(
    PDISKQUOTA_USER pUser,
    LPDWORD pdwPct
    )
{
    LONGLONG llUsed;
    LONGLONG llLimit;
    HRESULT hResult = E_FAIL;

    DBGASSERT((NULL != pUser));
    DBGASSERT((NULL != pdwPct));

    pUser->GetQuotaUsed(&llUsed);
    pUser->GetQuotaLimit(&llLimit);

    if (NOLIMIT == llLimit)
    {
        *pdwPct = (DWORD)~0 - 1;  // No quota limit for user.
    }
    else if (0 < llLimit)
    {
        *pdwPct = (INT)((llUsed * 100) / llLimit);
        hResult = NO_ERROR;
    }
    else
    {
        //
        // Limit is 0.  Would produce div-by-zero.
        //
        *pdwPct = (DWORD)~0;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::AddUser

    Description: Adds a user object to the listview.  Note that this is used
        for adding a single user object such as in an "add user" operation.
        The method LoadObjects is used to load the whole listview.  It's
        more efficient than calling this for each user.

    Arguments:
        pUser - Address of user's IDiskQuotaUser interface.

    Returns:
        TRUE  - User was added.
        FALSE - User wasn't added.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::AddUser(
    PDISKQUOTA_USER pUser
    )
{
    BOOL bResult    = FALSE;
    LV_ITEM item;

    item.mask       = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
    item.state      = 0;
    item.stateMask  = 0;
    item.iSubItem   = 0;
    item.pszText    = LPSTR_TEXTCALLBACK;
    item.iImage     = I_IMAGECALLBACK;
    item.iItem      = 0;

    m_UserList.Insert((LPVOID)pUser);
    if (-1 != ListView_InsertItem(m_hwndListView, &item))
    {
        bResult = TRUE;
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FindUserByName

    Description: Locate a specified user in the listview by account name.
        Name comparison is case-insensitive.

    Arguments:
        pszUserName - Account name for user.

        ppIUser [optional] - Address of IDiskQuotaUser pointer variable to
            receive the address of the user object.

    Returns:
        -1 = account name not found.
        Otherwise, returns index of item in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::FindUserByName(
    LPCTSTR pszLogonName,
    PDISKQUOTA_USER *ppIUser // [optional]
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                //
                // Get name from listview item.
                //
                if (NULL != pUser)
                {
                    TCHAR szLogonName[MAX_USERNAME];
                    pUser->GetName(NULL, 0,
                                   szLogonName, ARRAYSIZE(szLogonName),
                                   NULL, 0);

                    if (CSTR_EQUAL == CompareString(LOCALE_USER_DEFAULT,
                                                    NORM_IGNORECASE,
                                                    szLogonName, -1,
                                                    pszLogonName, -1))
                    {
                        iItem = i;
                        if (NULL != ppIUser)
                            *ppIUser = pUser;
                    }
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::FindUserBySid

    Description: Locate a specified user in the listview by SID.

    Arguments:
        pSid - Address of buffer containing key SID.

        ppIUser [optional] - Address of IDiskQuotaUser pointer variable to
            receive the address of the user object.

    Returns:
        -1 = Record not found.
        Otherwise, returns index of item in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/23/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::FindUserBySid(
    LPBYTE pbSid,
    PDISKQUOTA_USER *ppIUser  // [optional]
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                //
                // Get SID from listview item.
                //
                if (NULL != pUser)
                {
                    BYTE Sid[MAX_SID_LEN];
                    pUser->GetSid((LPBYTE)&Sid, ARRAYSIZE(Sid));

                    if (EqualSid((LPBYTE)&Sid, pbSid))
                    {
                        iItem = i;
                        if (NULL != ppIUser)
                            *ppIUser = pUser;
                    }
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}

//
// Locate a user in the listview based on it's object pointer.
//
INT
DetailsView::FindUserByObjPtr(
    PDISKQUOTA_USER pUserKey
    )
{
    INT iItem = -1;

    m_UserList.Lock();
    try
    {
        INT cUsers = m_UserList.Count();
        PDISKQUOTA_USER pUser = NULL;
        //
        // Find the user that matches pszUserName.
        //
        for (INT i = 0; i < cUsers && -1 == iItem; i++)
        {
            if (m_UserList.Retrieve((LPVOID *)&pUser, i))
            {
                if (NULL != pUser && pUserKey == pUser)
                {
                    iItem = i;
                }
            }
        }
    }
    catch(CAllocException& e)
    {
        m_UserList.ReleaseLock();
        throw;
    }
    m_UserList.ReleaseLock();
    return iItem;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GotoUserName

    Description: Locate a specified user in the listview.  If found, highlight
        the row.  The search is case-insensitive.  This function was originally
        designed to work with the "Find User" feature so that when a record
        is located, it is made visible in the view and highlighted.

    Arguments:
        pszUserName - Account name for user.

    Returns:
        TRUE  = Record found.
        FALSE = Not found.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GotoUserName(
    LPCTSTR pszUserName
    )
{
    INT iUser = FindUserByName(pszUserName);
    if (-1 != iUser)
    {
        //
        // Found a match (case-insensitive).
        //
        // Select the item specified by the user.
        // Note that we leave any selected items selected.
        // Users may use the find feature to select a set of
        // non-contiguous quota records in the listview.
        //
        ListView_EnsureVisible(m_hwndListView, iUser, FALSE);
        ListView_SetItemState(m_hwndListView, iUser, LVIS_FOCUSED | LVIS_SELECTED,
                                                     LVIS_FOCUSED | LVIS_SELECTED);
    }
    return (-1 != iUser);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetConnectionPoint

    Description: Retrieves the IDiskQuotaEvents connection point from
        the quota control object.  This is the connection point through which
        the asynchronous user name change events are delivered as names
        are resolved by the network DC.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
IConnectionPoint *
DetailsView::GetConnectionPoint(
    VOID
    )
{
    HRESULT hResult       = NO_ERROR;
    IConnectionPoint *pCP = NULL;
    if (NULL != m_pQuotaControl)
    {
        IConnectionPointContainer *pCPC = NULL;
        hResult = m_pQuotaControl->QueryInterface(IID_IConnectionPointContainer,
                                                  (LPVOID *)&pCPC);
        if (SUCCEEDED(hResult))
        {
            hResult = pCPC->FindConnectionPoint(IID_IDiskQuotaEvents, &pCP);
            pCPC->Release();
            if (FAILED(hResult))
                pCP = NULL;
        }
    }
    return pCP;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::ConnectEventSink

    Description: Connects the event sink (DetailsView) from the quota
        controller's IDiskQuotaEvents connection point object.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::ConnectEventSink(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    IConnectionPoint *pConnPt = GetConnectionPoint();
    if (NULL != pConnPt)
    {
        hResult = pConnPt->Advise((LPUNKNOWN)static_cast<IDataObject *>(this), &m_dwEventCookie);
        pConnPt->Release();
        DBGPRINT((DM_VIEW, DL_MID, TEXT("LISTVIEW - Connected event sink.  Cookie = %d"), m_dwEventCookie));
    }
    else
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DisconnectEventSink

    Description: Disconnects the event sink (DetailsView) from the quota
        controller's IDiskQuotaEvents connection point object.

    Arguments: None.

    Returns:
        NO_ERROR    - Success.
        E_FAIL      - Failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/20/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DisconnectEventSink(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    DBGPRINT((DM_VIEW, DL_MID, TEXT("LISTVIEW - Disconnecting event sink.  Cookie = %d"), m_dwEventCookie));

    if (0 != m_dwEventCookie)
    {
        IConnectionPoint *pConnPt = GetConnectionPoint();
        if (NULL != pConnPt)
        {
            hResult = pConnPt->Unadvise(m_dwEventCookie);
            if (SUCCEEDED(hResult))
            {
                m_dwEventCookie = 0;
            }
            pConnPt->Release();
        }
        else
            hResult = E_FAIL;
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::InitLVStateInfo

    Description: Initializes an LV_STATE_INFO structure to default values.
        NOTE: This method is declared static so that it can be called
            without a DetailsView object (not needed).

            If you want to change any listview state defaults, this is the
            place to do it.

    Arguments:
        plvsi - Address of an LV_STATE_INFO structure to be initialized.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::InitLVStateInfo(
    PLV_STATE_INFO plvsi
    )
{
    ZeroMemory(plvsi, sizeof(*plvsi));

    plvsi->cb         = sizeof(*plvsi);

    plvsi->wVersion       = wLV_STATE_INFO_VERSION;
    plvsi->fToolBar       = 1;  // Default to toolbar visible.
    plvsi->fStatusBar     = 1;  // Default to statusbar visible.
    plvsi->iLastColSorted = 0;  // Default to sort first col.
    plvsi->fSortDirection = 1;  // Default to ascending sort.
    for (UINT i = 0; i < DetailsView::idCol_Last; i++)
        plvsi->rgColIndices[i] = i;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::IsValidLVStateInfo

    Description: Validates the contents of a LV_STATE_INFO structure.
        NOTE: This method is declared static so that it can be called
            without a DetailsView object (not needed).

    Arguments:
        plvsi - Address of an LV_STATE_INFO structure to be validated.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    12/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::IsValidLVStateInfo(
    PLV_STATE_INFO plvsi
    )
{
    BOOL bResult = FALSE;
    INT i = 0;

    //
    // Validate structure size member.
    //
    if (plvsi->cb != sizeof(LV_STATE_INFO))
        goto info_invalid;
    //
    // Validate version.
    //
    if (wLV_STATE_INFO_VERSION != plvsi->wVersion)
        goto info_invalid;
    //
    // Validate iLastSorted member.
    //
    if (!(plvsi->iLastColSorted >= 0 && plvsi->iLastColSorted < DetailsView::idCol_Last))
        goto info_invalid;
    //
    // Validate each of the column index members.  Used for ordering columns.
    //
    for (i = 0; i < DetailsView::idCol_Last; i++)
    {
        if (!(plvsi->rgColIndices[i] >= 0 && plvsi->rgColIndices[i] < DetailsView::idCol_Last))
            goto info_invalid;
    }

    bResult = TRUE;

info_invalid:

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetColumnIds

    Description: Retrieves a list of IDs for the visible columns in the list.
        A client can use this list to request report items from the
        GetReportXXXXX methods below.

    Arguments:
        prgColIds - Pointer to an array of INTs to receive the column IDs.

        cColIds - Size of the destination array.

    Returns: Number of IDs written to destination array.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetColumnIds(
    INT *prgColIds,
    INT cColIds
    )
{
    INT cHdrCols = Header_GetItemCount(m_hwndHeader);
    INT rgiSubItem[DetailsView::idCol_Last];
    INT i = 0;

    if (Header_GetOrderArray(m_hwndHeader, cHdrCols, rgiSubItem))
    {
        for (i = 0; i < cHdrCols && i < cColIds; i++)
        {
            *(prgColIds + i) = m_ColMap.SubItemToId(rgiSubItem[i]);
        }
    }
    return i;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetNextSelectedItemIndex

    Description: Retrieves the index of a selected item.  The search starts
        with the index supplied in the iRow argument.  Therefore, the following
        loop will find all selected items:

        INT iItem = -1;

        while(1)
        {
            iItem = GetNextSelectedItemIndex(iItem);
            if (-1 == iItem)
                break;

            //
            // Do something with item.
            //
        }


    Arguments:
        iRow - Row where to start search.  The row itself is exluded from
            the search.  -1 starts search from the head of the listview.

    Returns:
        0-based index of next selected item if found.
        -1 if no more selected items.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
DetailsView::GetNextSelectedItemIndex(INT iRow)
{
    return ListView_GetNextItem(m_hwndListView, iRow, LVNI_ALL | LVNI_SELECTED);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportItem

    Description: Retrieve a data item for a drag-drop/clipboard report.
        This method is patterned after the GetDispInfo_XXX methods but is
        taylored to placing data on a Stream object.

    Arguments:
        iRow - Row where to begin search for next selected item in listview.
            For the first call, specify -1 to begin the search with the
            first item.  Subsequent calls should specify the value returned
            from the previous call to GetReportItem.

        iColId - Item's column ID (idCol_Folder, idCol_Name etc).

        pItem - Address of an LV_REPORT_ITEM structure.  This structure
            is used to return the data to the caller and also to specify the
            desired format for numeric values.  Some report formats want
            all data in text format (i.e. CF_TEXT) while other binary formats
            want numeric data in numeric format (i.e. XlTable).

    Returns: TRUE  = Retrieved row/col data.
             FALSE = Invalid row or column index.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GetReportItem(
    UINT iRow,
    UINT iColId,
    PLV_REPORT_ITEM pItem
    )
{
    DBGASSERT((NULL != pItem));
    BOOL bResult          = FALSE;
    PDISKQUOTA_USER pUser = NULL;

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        LONGLONG llValue;
        DBGASSERT((NULL != pUser));
        bResult = TRUE;

        switch(iColId)
        {
            case DetailsView::idCol_Folder:
            {
                DWORD dwAccountStatus = 0;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    pUser->GetName(pItem->pszText, pItem->cchMaxText,
                                   NULL, 0,
                                   NULL, 0);
                }
                else
                {
                    //
                    // Folder name not resolved.  User name column will
                    // contain status text.
                    //
                    lstrcpyn(pItem->pszText, TEXT(""), pItem->cchMaxText);
                }
                pItem->fType = LVRI_TEXT;
                break;
            }

            case DetailsView::idCol_Name:
            {
                DWORD dwAccountStatus = 0;
                CString strNameText;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    //
                    // User's name has been resolved.
                    //
                    pItem->fType = LVRI_TEXT;
                    pUser->GetName(NULL, 0,
                                   NULL, 0,
                                   strNameText.GetBuffer(MAX_USERNAME), MAX_USERNAME);
                    strNameText.ReleaseBuffer();
                }
                else
                {
                    //
                    // User's name not resolved.  Use a status message.
                    //
                    switch(dwAccountStatus)
                    {
                        case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                            strNameText = m_strAccountUnresolved;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
                            strNameText = m_strAccountUnknown;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_INVALID:
                            strNameText = m_strAccountInvalid;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_DELETED:
                            strNameText = m_strAccountDeleted;
                            break;

                        case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                            strNameText = m_strAccountUnavailable;
                            break;
                    }
                }
                lstrcpyn(pItem->pszText, strNameText, pItem->cchMaxText);

                break;
            }

            case DetailsView::idCol_LogonName:
            {
                DBGASSERT((NULL != pUser));
                DWORD dwAccountStatus = 0;
                CString strNameText;
                pUser->GetAccountStatus(&dwAccountStatus);

                if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
                {
                    //
                    // User's name has been resolved.
                    //
                    pItem->fType = LVRI_TEXT;
                    pUser->GetName(NULL, 0,
                                   strNameText.GetBuffer(MAX_USERNAME), MAX_USERNAME,
                                   NULL, 0);
                    strNameText.ReleaseBuffer();
                }

                lstrcpyn(pItem->pszText, strNameText, pItem->cchMaxText);
                break;
            }

            case DetailsView::idCol_Status:
                //
                // Return a text string to represent the icon shown
                // in the "Status" column.
                //
                DBGASSERT((NULL != pUser));
                switch(GetUserQuotaState(pUser))
                {
                    case iUSERSTATE_OK:
                        lstrcpyn(pItem->pszText, m_strStatusOK, pItem->cchMaxText);
                        break;
                    case iUSERSTATE_WARNING:
                        lstrcpyn(pItem->pszText, m_strStatusWarning, pItem->cchMaxText);
                        break;
                    default:
                        DBGASSERT((0));
                        //
                        // Fall through.
                        //
                    case iUSERSTATE_OVERLIMIT:
                        lstrcpyn(pItem->pszText, m_strStatusOverlimit, pItem->cchMaxText);
                        break;
                }
                pItem->fType = LVRI_TEXT;
                break;

            //
            // For the following numeric columns, first get the data then
            // jump to fmt_byte_count to format it as requested.  Note that
            // all numeric values are expressed in megabytes.  This is so they
            // all have the same units to help with ordering in a spreadsheet.
            // Otherwise, sorting would not be possible.  This is also why we
            // include the "(MB)" in the report column titles.
            //
            case DetailsView::idCol_AmtUsed:
                pUser->GetQuotaUsed(&llValue);
                goto fmt_byte_count;

            case DetailsView::idCol_Threshold:
                pUser->GetQuotaThreshold(&llValue);
                goto fmt_byte_count;

            case DetailsView::idCol_Limit:
                pUser->GetQuotaLimit(&llValue);
fmt_byte_count:
                //
                // Format the byte count for the requested data type (text vs. numeric).
                //
                switch(pItem->fType)
                {
                    case LVRI_NUMBER:
                        pItem->fType = LVRI_REAL;
                        if (NOLIMIT == llValue)
                            pItem->dblValue = -1.0;        // Indicates to caller "No Limit".
                        else
                            pItem->dblValue = XBytes::ConvertFromBytes(llValue, XBytes::e_Mega);
                        break;
                    case LVRI_TEXT:
                        if (NOLIMIT == llValue)
                            lstrcpyn(pItem->pszText, m_strNoLimit, pItem->cchMaxText);
                        else
                            XBytes::FormatByteCountForDisplay(llValue,
                                                              pItem->pszText,
                                                              pItem->cchMaxText,
                                                              XBytes::e_Mega);
                        //
                        // Fall through.
                        //
                    default:
                        break;
                }
                break;

            case DetailsView::idCol_PctUsed:
            {
                HRESULT hResult = CalcPctQuotaUsed(pUser, &pItem->dwValue);
                //
                // Format the percent value for the requested data type (text vs. numeric).
                // If a percentage can't be calculated (0 denominator), return -2 as an
                // INT value or "N/A" as a text value.
                //
                switch(pItem->fType)
                {
                    case LVRI_NUMBER:
                        pItem->fType = LVRI_INT;
                        if (FAILED(hResult))
                            pItem->dwValue = (DWORD)-2; // Indicates to caller "N/A".
                        break;
                    case LVRI_TEXT:
                        if (FAILED(hResult))
                            lstrcpyn(pItem->pszText, m_strNotApplicable, pItem->cchMaxText);
                        else
                            wsprintf(pItem->pszText, TEXT("%d"), pItem->dwValue);

                    default:
                        break;
                }
                break;
            }

            default:
                bResult = FALSE;
                break;
        }
    }
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportTitle

    Description: Retrieves a title for a report.  Uses the listview window
        title.

    Arguments:
        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::GetReportTitle(
    LPTSTR pszDest,
    UINT cchDest
    )
{
    //
    // This is simple.  Just use the details view title.
    // FEATURE: Could be enhanced to include the date/time but that will
    //         require localization considerations.
    //
    GetWindowText(m_hwndMain, pszDest, cchDest);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportColHeader

    Description: Retrieves a title for a report column.  Note that the titles
        may differ from those used in the listview.  Specifically for the
        numeric columns.  In the listview, numeric column entries include
        units (bytes, KB, MB etc.).  In a report, these numeric values are
        all expressed in MB.  Therefore, the units must be included in the
        title string.

    Arguments:
        iColId - ID of column requested (idCol_Folder, idCol_Name etc.)

        pszDest - Address of destination character buffer.

        cchDest - Size of destination buffer in characters.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::GetReportColHeader(
    UINT iColId,
    LPTSTR pszDest,
    UINT cchDest
    )
{
    //
    // WARNING:  The order of these must match that of the idCol_XXX enumeration
    //           constants in DetailsView.
    //
    UINT rgTitles[] = { IDS_REPORT_HEADER_STATUS,
                        IDS_REPORT_HEADER_FOLDER,
                        IDS_REPORT_HEADER_USERNAME,
                        IDS_REPORT_HEADER_LOGONNAME,
                        IDS_REPORT_HEADER_AMTUSED,
                        IDS_REPORT_HEADER_LIMIT,
                        IDS_REPORT_HEADER_THRESHOLD,
                        IDS_REPORT_HEADER_PCTUSED };

    DBGASSERT((NULL != pszDest));
    DBGASSERT((1 < cchDest));
    CString strHeader(TEXT("..."));

    if (iColId < ARRAYSIZE(rgTitles))
    {
        strHeader.Format(g_hInstDll, rgTitles[iColId]);
    }
    else
    {
        DBGERROR((TEXT("LISTVIEW - Invalid idCol (%d) on header request"), iColId));
    }
    lstrcpyn(pszDest, strHeader, cchDest);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportRowCount

    Description: Retrieves the number of data rows in the listview.

    Arguments: None.

    Returns: Number of rows in the listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/08/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetReportRowCount(VOID)
{
    return ListView_GetSelectedCount(m_hwndListView);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportBinaryRecordSize

    Description: Retrieves the number of bytes in a record formatted as
        binary data.  This should be called before GetReportBinaryRecord to
        determine how to size the destination buffer.

    Arguments:
        iRow - 0-based index of the row in question.

    Returns: Number of bytes required to store the record.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
DetailsView::GetReportBinaryRecordSize(
    UINT iRow
    )
{
    INT cbRecord = 0;

    PDISKQUOTA_USER pUser = NULL;

    DBGASSERT((iRow < m_UserList.Count()));

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        if (NULL != pUser)
        {
            pUser->GetSidLength((LPDWORD)&cbRecord); // Length of SID field.

            cbRecord += sizeof(DWORD)    +     // Sid-Length field.
                        sizeof(LONGLONG) +     // Quota used field.
                        sizeof(LONGLONG) +     // Quota threshold field.
                        sizeof(LONGLONG);      // Quota limit field.
        }
    }
    return cbRecord;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetReportBinaryRecord

    Description: Retrieves the information for a single row in the
        details view formatted as binary data.
        The format of the returned record is as follows:

        +------------+---------------------------------------+
        | cbSid (32) |       SID (variable length)           |
        +------------+------------+-------------+------------+
        |    Quota Used (64)      |  Quota Threshold (64)    |
        +------------+------------+-------------+------------+
        |    Quota Limit (64)     |
        +------------+------------+

        (*) The size of each field (bits) is shown in parentheses.


    Arguments:
        iRow - 0-based index of the row in question.

        pbRecord - Address of destination buffer.

        cbRecord - Number of bytes in destination buffer.

    Returns:
        TRUE  = Destination buffer was sufficiently large.
        FALSE = Destination buffer too small or record was invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::GetReportBinaryRecord(
    UINT iRow,
    LPBYTE pbRecord,
    UINT cbRecord
    )
{
    //
    // Create "PMF" (pointer to member function) as a type of pointer
    // to the IDiskQuotaUser::GetQuotaXXXXXX functions.  This allows us
    // to build an array of function pointers and reduce the amount of
    // code required.
    //
    typedef HRESULT(_stdcall IDiskQuotaUser::*PMF)(PLONGLONG);

    PDISKQUOTA_USER pUser = NULL;
    BOOL bResult = FALSE;

    DBGASSERT((iRow < m_UserList.Count()));
    DBGASSERT((NULL != pbRecord));

    if (m_UserList.Retrieve((LPVOID *)&pUser, iRow))
    {
        DWORD cbSid = 0;
        if (NULL != pUser && cbRecord >= sizeof(cbSid))
        {
            //
            // Store the SID-length value first in the record.
            //
            pUser->GetSidLength((LPDWORD)&cbSid);
            *((LPDWORD)pbRecord) = cbSid;

            pbRecord += sizeof(cbSid);
            cbRecord -= sizeof(cbSid);

            //
            // Store the SID value next.
            //
            if (cbRecord >= cbSid && SUCCEEDED(pUser->GetSid(pbRecord, cbRecord)))
            {
                pbRecord += cbSid;
                cbRecord -= cbSid;
                //
                // An array of member function pointers.  Each function
                // retrieves a LONGLONG value from the quota user object.
                // This places the redundant code in a loop.
                //
                // The value order is Quota Used, Quota Threshold, Quota Limit.
                //
                PMF rgpfnQuotaValue[] = {
                    &IDiskQuotaUser::GetQuotaUsed,
                    &IDiskQuotaUser::GetQuotaThreshold,
                    &IDiskQuotaUser::GetQuotaLimit
                    };

                for (INT i = 0; i < ARRAYSIZE(rgpfnQuotaValue); i++)
                {
                    bResult = TRUE;
                    if (cbRecord >= sizeof(LONGLONG))
                    {
                        //
                        // First copy to a stack LONGLONG as it is guaranteed
                        // to be aligned.  Then byte-copy the value to the
                        // output buffer.
                        //        
                        LONGLONG llValue;
                        (pUser->*(rgpfnQuotaValue[i]))(&llValue);
                        CopyMemory(pbRecord, &llValue, sizeof(llValue));
                        pbRecord += sizeof(LONGLONG);
                        cbRecord -= sizeof(LONGLONG);
                    }
                    else
                    {
                        //
                        // Insufficient buffer.
                        //
                        bResult = FALSE;
                        break;
                    }
                }
            }
        }
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GiveFeedback

    Description: Implementation for IDropSource::GiveFeedback.

    Arguments: See IDropSource::GiveFeedback in SDK.

    Returns: Always returns DRAGDROP_S_USEDEFAULTS.
        We don't have any special cursors for drag/drop.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::GiveFeedback(
    DWORD dwEffect
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DropSource::GiveFeedback")));
    return DRAGDROP_S_USEDEFAULTCURSORS;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryContinueDrag

    Description: Implementation for IDropSource::QueryContinueDrag

    Arguments: See IDropSource::QueryContinueDrag in SDK.

    Returns:
        DRAGDROP_S_CANCEL = User pressed ESC during drag.
        DRAGDROP_S_DROP   = User releases left mouse button.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::QueryContinueDrag(
    BOOL fEscapePressed,
    DWORD grfKeyState
    )
{
    HRESULT hResult = S_OK;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DropSource::QueryContinueDrag")));
    if (fEscapePressed)
        hResult = DRAGDROP_S_CANCEL;
    else if (!(m_DropSource.m_grfKeyState & grfKeyState))
        hResult = DRAGDROP_S_DROP;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragEnter

    Description: Implementation for IDropTarget::DragEnter

    Arguments: See IDropTarget::DragEnter in SDK.

    Returns: See IDropTarget::DragEnter in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragEnter(
    IDataObject *pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    BOOL bWillAcceptDrop = FALSE;
    HRESULT hResult = NO_ERROR;
    IEnumFORMATETC *pEnum = NULL;

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Enumerate formats supported by our data object.
    //
    hResult = pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum);
    if (SUCCEEDED(hResult))
    {
        ULONG ulFetched = 0;
        FORMATETC fmt;

        //
        // Search the formats until we find an acceptable match.
        // We only accept our private export format along with
        // CF_HDROP in stream and HGLOBAL media types.
        //
        while(!bWillAcceptDrop && S_OK == pEnum->Next(1, &fmt, &ulFetched))
        {
            if (fmt.cfFormat == DataObject::m_CF_NtDiskQuotaExport || fmt.cfFormat == CF_HDROP)
            {
                if (fmt.tymed & (TYMED_HGLOBAL | TYMED_ISTREAM))
                {
                    bWillAcceptDrop = TRUE;
                }
            }
        }
        pEnum->Release();
    }
    if (SUCCEEDED(hResult))
    {
        hResult = NO_ERROR;
        if (bWillAcceptDrop)
        {
            *pdwEffect = (grfKeyState & MK_CONTROL ? DROPEFFECT_COPY :
                                                     DROPEFFECT_MOVE);
            m_DropTarget.m_pIDataObject = pDataObject;
            m_DropTarget.m_pIDataObject->AddRef();
        }
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragOver

    Description: Implementation for IDropTarget::DragOver

    Arguments: See IDropTarget::DragOver in SDK.

    Returns: See IDropTarget::DragOver in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    if (NULL != m_DropTarget.m_pIDataObject)
    {
        *pdwEffect = (grfKeyState & MK_CONTROL ? DROPEFFECT_COPY :
                                                 DROPEFFECT_MOVE);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DragLeave

    Description: Implementation for IDropTarget::DragLeave

    Arguments: See IDropTarget::DragLeave in SDK.

    Returns: See IDropTarget::DragLeave in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DragLeave(
    VOID
    )
{
    if (NULL != m_DropTarget.m_pIDataObject)
    {
        m_DropTarget.m_pIDataObject->Release();
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Drop

    Description: Implementation for IDropTarget::Drop

    Arguments: See IDropTarget::Drop in SDK.

    Returns: See IDropTarget::Drop in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Drop(
    IDataObject *pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect
    )
{
    HRESULT hResult = E_FAIL;

    *pdwEffect = DROPEFFECT_NONE;

    if (NULL != m_DropTarget.m_pIDataObject)
    {
        DragLeave();

        //
        // Import the quota data from the data object.
        //
        Importer importer(*this);
        hResult = importer.Import(pDataObject);

        if (SUCCEEDED(hResult))
        {
            if (grfKeyState & MK_CONTROL)
            {
                *pdwEffect = DROPEFFECT_COPY;
            }
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetData

    Description: Implementation of IDataObject::GetData

    Arguments: See IDataObject::GetData in SDK.

    Returns: See IDataObject::GetData in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    HRESULT hResult = E_INVALIDARG;

#if DBG

    TCHAR szCFName[MAX_PATH] = { TEXT('\0') };

    GetClipboardFormatName(pFormatEtc->cfFormat, szCFName, ARRAYSIZE(szCFName));
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetData\nDVA = %d  CF = %d (%s) tymed = %d"),
           pFormatEtc->dwAspect, pFormatEtc->cfFormat,
           szCFName,
           pFormatEtc->tymed));

#endif // DEBUG

    if (NULL != pFormatEtc && NULL != pMedium)
    {
        //
        // See if we support the requested format.
        //
        hResult = m_pDataObject->IsFormatSupported(pFormatEtc);
        if (SUCCEEDED(hResult))
        {
            //
            // Yep, we support it.  Render the data.
            //
            hResult = m_pDataObject->RenderData(pFormatEtc, pMedium);
        }
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetDataHere

    Description: Implementation of IDataObject::GetDataHere

    Arguments: See IDataObject::GetData in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetDataHere(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetDataHere")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::QueryGetData

    Description: Implementation of IDataObject::QueryGetData

    Arguments: See IDataObject::QueryGetData in SDK.

    Returns: See IDataObject::QueryGetData in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::QueryGetData(
    FORMATETC *pFormatEtc
    )
{
    HRESULT hResult = E_UNEXPECTED;

#if DBG

    TCHAR szCFName[MAX_PATH] = { TEXT('\0') };

    GetClipboardFormatName(pFormatEtc->cfFormat, szCFName, ARRAYSIZE(szCFName));
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::QueryGetData\nDVA = %d  CF = %d (%s) tymed = %d"),
           pFormatEtc->dwAspect, pFormatEtc->cfFormat,
           szCFName,
           pFormatEtc->tymed));

#endif // DEBUG

    if (NULL != pFormatEtc)
    {
        hResult = m_pDataObject->IsFormatSupported(pFormatEtc);
    }
    else
        hResult = E_INVALIDARG;

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::GetCanonicalFormatEtc

    Description: Implementation of IDataObject::GetCanonicalFormatEtc

    Arguments: See IDataObject::GetCanonicalFormatEtc in SDK.

    Returns: See IDataObject::GetCanonicalFormatEtc in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::GetCanonicalFormatEtc(
    FORMATETC *pFormatEtcIn,
    FORMATETC *pFormatEtcOut
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::GetCanonicalFormatEtc")));

    HRESULT hResult = E_INVALIDARG;

    if (NULL != pFormatEtcIn && NULL != pFormatEtcOut)
    {
        CopyMemory(pFormatEtcOut, pFormatEtcIn, sizeof(*pFormatEtcOut));
        pFormatEtcOut->ptd = NULL;
        hResult = DATA_S_SAMEFORMATETC;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::SetData

    Description: Implementation of IDataObject::SetData

    Arguments: See IDataObject::SetData in SDK.

    Returns: E_NOTIMPL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::SetData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium,
    BOOL fRelease
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::SetData")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnumFormatEtc

    Description: Implementation of IDataObject::EnumFormatEtc

    Arguments: See IDataObject::EnumFormatEtc in SDK.

    Returns: See IDataObject::GetCanonicalFormatEtc in SDK.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::EnumFormatEtc")));

    HRESULT hResult      = E_FAIL;
    EnumFORMATETC *pEnum = NULL;

    switch(dwDirection)
    {
        case DATADIR_GET:
            try
            {
                pEnum = new EnumFORMATETC(m_pDataObject->m_cFormats, m_pDataObject->m_rgFormats);
                hResult = pEnum->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppenumFormatEtc);
            }
            catch(CAllocException& e)
            {
                *ppenumFormatEtc = NULL;
                hResult = E_OUTOFMEMORY;
            }
            break;

        case DATADIR_SET:
            //
            // SetData not implemented.
            //
        default:
            *ppenumFormatEtc = NULL;
            break;
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DAdvise

    Description: Implementation of IDataObject::DAdvise

    Arguments: See IDataObject::DAdvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::DAdvise(
    FORMATETC *pFormatEtc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::DAdvise")));
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DUnadvise

    Description: Implementation of IDataObject::DUnadvise

    Arguments: See IDataObject::DUnadvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::DUnadvise(
    DWORD dwConnection
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::DUnadvise")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::EnumDAdvise

    Description: Implementation of IDataObject::EnumDAdvise

    Arguments: See IDataObject::EnumDAdvise in SDK.

    Returns: E_NOTIMPL

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DetailsView::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise
    )
{
    DBGTRACE((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - DataObject::EnumDAdvise")));
    return E_NOTIMPL;
}


//
// Number of clipboard formats supported by our data object.
// Change this if you add/remove clipboard formats.  There's an assert
// in the DataObject ctor to ensure this.
//
const INT DetailsView::DataObject::CF_FORMATS_SUPPORTED = 14;
//
// Name of data stream in import/export and dragdrop streams.
//
LPCWSTR DetailsView::DataObject::SZ_EXPORT_STREAM_NAME = L"NT DISKQUOTA IMPORTEXPORT";
LPCTSTR DetailsView::DataObject::SZ_EXPORT_CF_NAME     = TEXT("NT DISKQUTOA IMPORTEXPORT");

//
// The version of export data produced by this module.  This value
// is written into the stream immediately following the GUID.  If the
// format of the export stream is changed, this value should be incremented.
//
const DWORD DetailsView::DataObject::EXPORT_STREAM_VERSION = 1;

CLIPFORMAT DetailsView::DataObject::m_CF_Csv                 = 0; // Comma-separated fields format.
CLIPFORMAT DetailsView::DataObject::m_CF_RichText            = 0; // RTF format.
CLIPFORMAT DetailsView::DataObject::m_CF_NtDiskQuotaExport   = 0; // Internal fmt for import/export.
CLIPFORMAT DetailsView::DataObject::m_CF_FileGroupDescriptor = 0;
CLIPFORMAT DetailsView::DataObject::m_CF_FileContents        = 0;


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::DataObject

    Description: Constructor for implementation of IDataObject.

    Arguments:
        DV - Reference to details view object that contains the data object.

    Returns: Nothing

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::DataObject(
    DetailsView& DV
    ) : m_pStg(NULL),
        m_pStm(NULL),
        m_rgFormats(NULL),
        m_cFormats(CF_FORMATS_SUPPORTED),
        m_DV(DV)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DataObject::DataObject")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    //
    // Get additional clipboard formats we support.
    //
    if (0 == m_CF_Csv)
    {
        m_CF_Csv               = (CLIPFORMAT)RegisterClipboardFormat(TEXT("Csv"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - Csv CF            = %d"), m_CF_Csv));
    }

    if (0 == m_CF_RichText)
    {
        m_CF_RichText          = (CLIPFORMAT)RegisterClipboardFormat(TEXT("Rich Text Format"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - RTF CF            = %d"), m_CF_RichText));
    }

    if (0 == m_CF_NtDiskQuotaExport)
    {
        m_CF_NtDiskQuotaExport = (CLIPFORMAT)RegisterClipboardFormat(DataObject::SZ_EXPORT_CF_NAME);
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - NtDiskQuotaExport = %d"), m_CF_NtDiskQuotaExport));
    }

    if (0 == m_CF_FileGroupDescriptor)
    {
        m_CF_FileGroupDescriptor = (CLIPFORMAT)RegisterClipboardFormat(TEXT("FileGroupDescriptorW"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - FileGroupDescriptorW = %d"), m_CF_FileGroupDescriptor));
    }

    if (0 == m_CF_FileContents)
    {
        m_CF_FileContents = (CLIPFORMAT)RegisterClipboardFormat(TEXT("FileContents"));
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - FileContents = %d"), m_CF_FileContents));
    }

    //
    // Create the array to hold the FORMATETC structures that describe the
    // formats we support.
    //
    m_rgFormats = new FORMATETC[m_cFormats];

    //
    // Specify all formats and media we support.
    // Place the richest formats first in the array.
    // These are used to initialize the format enumerator when it
    // is requested.
    //
    UINT iFmt = 0;

    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileGroupDescriptor, TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileGroupDescriptor, TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileContents,        TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_FileContents,        TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_NtDiskQuotaExport,   TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_NtDiskQuotaExport,   TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_RichText,            TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_RichText,            TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_Csv,                 TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], m_CF_Csv,                 TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], CF_UNICODETEXT,           TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], CF_UNICODETEXT,           TYMED_HGLOBAL);
    SetFormatEtc(m_rgFormats[iFmt++], CF_TEXT,                  TYMED_ISTREAM);
    SetFormatEtc(m_rgFormats[iFmt++], CF_TEXT,                  TYMED_HGLOBAL);

    //
    // If you hit this, you need to adjust CF_FORMATS_SUPPORTED to match
    // the number of SetFormatEtc statements above.
    // Otherwise, you just overwrote the m_rgFormats[] allocation.
    //
    DBGASSERT((iFmt == m_cFormats));
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::~DataObject

    Description: Destructor for implementation of IDataObject.

    Arguments: None.

    Returns: Nothing

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::~DataObject(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("DetailsView::DataObject::~DataObject")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    delete[] m_rgFormats;
    if (NULL != m_pStg)
        m_pStg->Release();
    //
    // NOTE:  m_pStm is released by the data object's recipient
    //        through ReleaseStgMedium.
    //
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::IsFormatSupported

    Description: Determines if a given format is supported by our implementation.

    Arguments:
        pFormatEtc - Address of FORMATETC structure containing request info.

    Returns:
        NO_ERROR       - Supported.
        DV_E_TYMED     - Medium type not supported.
        DV_E_FORMATETC - Clipboard format not supported.
        DV_E_DVASPECT  - Device aspect not supported.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::IsFormatSupported(
    FORMATETC *pFormatEtc
    )
{
    DBGASSERT((NULL != pFormatEtc));
    HRESULT hResult = E_FAIL;

    if (DVASPECT_CONTENT == pFormatEtc->dwAspect)
    {
        if (CF_TEXT                  == pFormatEtc->cfFormat ||
            CF_UNICODETEXT           == pFormatEtc->cfFormat ||
            m_CF_RichText            == pFormatEtc->cfFormat ||
            m_CF_Csv                 == pFormatEtc->cfFormat ||
            m_CF_NtDiskQuotaExport   == pFormatEtc->cfFormat ||
            m_CF_FileGroupDescriptor == pFormatEtc->cfFormat ||
            m_CF_FileContents        == pFormatEtc->cfFormat)
        {
            if (pFormatEtc->tymed & (TYMED_ISTREAM | TYMED_HGLOBAL))
            {
                hResult = NO_ERROR;
            }
            else
            {
                hResult = DV_E_TYMED;
            }
        }
        else
            hResult = DV_E_FORMATETC;
    }
    else
        hResult = DV_E_DVASPECT;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::CreateRenderStream

    Description: Creates the OLE stream on which the data is to be rendered.

    Arguments:
        tymed - Desired medium type.

        ppStm - Address of IStream pointer variable to receive the stream ptr.

    Returns:
        NO_ERROR       - Success.
        E_INVALIDARG   - Invalid medium type.
        E_OUTOFMEMORY  - Insufficient memory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::CreateRenderStream(
    DWORD tymed,
    IStream **ppStm
    )
{
    HRESULT hResult = NOERROR;

    //
    // Create the Stream.
    //
    if (TYMED_ISTREAM & tymed)
    {
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - CreateRenderStream for ISTREAM")));
        hResult = CreateStreamOnHGlobal(NULL,       // Block of 0 bytes.
                                        TRUE,       // Delete on release.
                                        ppStm);
    }
    else if (TYMED_HGLOBAL & tymed)
    {
        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DRAGDROP - CreateRenderStream for HGLOBAL")));
        hResult = CreateStreamOnHGlobal(NULL,       // Block of 0 bytes.
                                        TRUE,       // Delete on release.
                                        ppStm);
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::RenderData [private]

    Description: Renders the data in the Details View onto the provided
        stream using the requested clipboard format.

    Arguments:
        pStm - Pointer to output stream.

        cf - Desired clipboard format.

    Returns:
        NO_ERROR         - Success.
        E_FAIL           - General failure.
        STG_E_WRITEFAULT - Media write error.
        STG_E_MEDIUMFULL - Insufficient space on medium.
        E_ACCESSDENIED   - Write access denied.
        E_OUTOFMEMORY    - Insufficient memory.
        E_UNEXPECTED     - Unexpected exception.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/30/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::RenderData(
    IStream *pStm,
    CLIPFORMAT cf
    )
{
    HRESULT hResult     = NOERROR;
    Renderer *pRenderer = NULL;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("DetailsView::DataObject::RenderData on stream")));
    try
    {
        //
        // Create the properly-typed rendering object for the requested format.
        //
        switch(cf)
        {
            case CF_TEXT:
                DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is CF_TEXT")));
                pRenderer = new Renderer_TEXT(m_DV);
                break;

            case CF_UNICODETEXT:
                DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is CF_UNICODETEXT")));
                pRenderer = new Renderer_UNICODETEXT(m_DV);
                break;

            default:
                if (m_CF_RichText == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is RTF")));
                    pRenderer = new Renderer_RTF(m_DV);
                }
                else if (m_CF_Csv == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is Csv")));
                    pRenderer = new Renderer_Csv(m_DV);
                }
                else if (m_CF_NtDiskQuotaExport == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is Windows NT Disk Quota ImportExport Format")));
                    pRenderer = new Renderer_Export(m_DV);
                }
                else if (m_CF_FileGroupDescriptor == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is FileGroupDescriptor")));
                    pRenderer = new Renderer_FileGroupDescriptor(m_DV);
                }
                else if (m_CF_FileContents == cf)
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Format is FileContents")));
                    pRenderer = new Renderer_FileContents(m_DV);
                }
                else
                {
                    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("Unknown CF format (%d) requested"), cf));
                }
                break;
        }

        if (NULL != pRenderer)
        {
            m_pStm->AddRef();      // Giving stream to renderer.
                                   // Will be released when renderer is destroyed.
            //
            // Render the information onto the stream.
            // This can throw FileError exceptions if we run out of disk
            // space or there's a disk write error.
            //
            pRenderer->Render(m_pStm);
        }
    }
    catch(CFileException& fe)
    {
        switch(fe.Reason())
        {
            case CFileException::write:
                DBGERROR((TEXT("FileWrite error")));
                hResult = E_FAIL;
                break;
            case CFileException::device:
                DBGERROR((TEXT("Disk error")));
                hResult = STG_E_WRITEFAULT;
                break;
            case CFileException::diskfull:
                DBGERROR((TEXT("Disk Full error")));
                hResult = STG_E_MEDIUMFULL;
                break;
            case CFileException::access:
                DBGERROR((TEXT("Access Denied error")));
                hResult = E_ACCESSDENIED;
                break;
            default:
                DBGERROR((TEXT("Other error")));
                hResult = E_FAIL;
                break;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hResult = E_OUTOFMEMORY;
    }

    delete pRenderer;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::RenderData [public]

    Description: Renders the data in the Details View onto the requested
        medium using the requested format.

    Arguments:
        pFormatEtc - Address of FORMATETC structure containing request info.

        pMedium - Address of STGMEDIUM structure containing requested
            medium info.

    Returns:
        NO_ERROR       - Success.
        Can return many other OLE drag/drop error codes.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/10/96    Initial creation.                                    BrianAu
    07/30/97    Reworked.  Moved some code into CreateRenderStream   BrianAu
                and CreateAndRunRenderer.  Makes the function
                more understandable.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::DataObject::RenderData(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pMedium
    )
{
    DBGASSERT((NULL != pFormatEtc));
    DBGASSERT((NULL != pMedium));
    DBGASSERT((SUCCEEDED(IsFormatSupported(pFormatEtc))));

    HRESULT hResult     = NOERROR;
    Renderer *pRenderer = NULL;

    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("DetailsView::DataObject::RenderData on medium")));

    //
    // Create the stream we'll render the data onto.
    //
    hResult = CreateRenderStream(pFormatEtc->tymed, &m_pStm);
    if (SUCCEEDED(hResult))
    {
        //
        // Render the data on the stream.
        //
        hResult = RenderData(m_pStm, pFormatEtc->cfFormat);

        if (SUCCEEDED(hResult))
        {
            //
            // If we've made it here, we have a valid drag-drop report on m_pStm.
            // Now set up the stg medium to transfer the rendering.
            //
            if (TYMED_ISTREAM & pFormatEtc->tymed)
            {
                pMedium->pstm           = m_pStm;
                pMedium->tymed          = TYMED_ISTREAM;
                pMedium->pUnkForRelease = NULL;          // Target will free the Stream.
            }
            else if (TYMED_HGLOBAL & pFormatEtc->tymed)
            {
                pMedium->tymed          = TYMED_HGLOBAL;
                pMedium->pUnkForRelease = NULL;          // Target will free the mem.
                hResult = GetHGlobalFromStream(m_pStm,
                                               &pMedium->hGlobal);
            }
            else
            {
                //
                // Call to CreateRenderStream() should have failed if we
                // hit this.
                //
                DBGASSERT((0));
            }
        }
        if (FAILED(hResult))
        {
            DBGERROR((TEXT("DRAGDROP - Error 0x%08X rendering data"), hResult));

            //
            // Something failed after the stream was created.
            // The DetailsView::DataObject dtor DOES NOT release it.
            // It assumes success and assumes the recipient will release it.
            // Release the stream.
            //
            m_pStm->Release();
            //
            // These two statements are redundant since pMedium contains a union.
            // I didn't want any more if(STREAM) else if (HGLOBAL) logic.  In case
            // there's ever a change in structure, this will ensure both possible
            // medium types are null'd out.
            //
            pMedium->pstm    = NULL;
            pMedium->hGlobal = NULL;
        }
    }
    else
    {
        DBGERROR((TEXT("DRAGDROP - Error 0x%08X creating stream"), hResult);)
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::SetFormatEtc [static]

    Description: Helper function to set the members of a FORMATETC
        structure.  Uses defaults for least used members.

    Arguments: See SDK description of FORMATETC.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::SetFormatEtc(
    FORMATETC& fe,
    CLIPFORMAT cfFormat,
    DWORD tymed,
    DWORD dwAspect,
    DVTARGETDEVICE *ptd,
    LONG lindex
    )
{
    fe.cfFormat = cfFormat;
    fe.dwAspect = dwAspect;
    fe.ptd      = ptd;
    fe.tymed    = tymed;
    fe.lindex   = lindex;
};


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::WideToAnsi

    Description: Helper function to convert a wide character string to ANSI.
        The caller must delete the return buffer.

    Arguments:
        pszTextW - UNICODE string to convert.

    Returns: Address of ANSI string.  Caller must delete this.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LPSTR
DetailsView::DataObject::WideToAnsi(
    LPCWSTR pszTextW
    )
{
    DBGASSERT((NULL != pszTextW));

    INT cchTextA = WideCharToMultiByte(CP_ACP,
                                       0,
                                       pszTextW,
                                       -1,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL);

    LPSTR pszTextA = new CHAR[cchTextA + 1];

    WideCharToMultiByte(CP_ACP,
                        0,
                        pszTextW,
                        -1,
                        pszTextA,
                        cchTextA + 1,
                        NULL,
                        NULL);
    return pszTextA;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Render

    Description: Render the selected items in the listview on a stream.
        Calls virtual functions defined by derived classes to produce the
        required format.

    Arguments:
        pStm - Address of IStream on which to write output.
            Assumes that this pointer has been AddRef'd by the caller.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Render(
    IStream *pStm
    )
{
    HRESULT hResult = NO_ERROR;
    WCHAR szText[MAX_PATH];
    INT rgColIds[DetailsView::idCol_Last];
    INT cCols = m_DV.GetColumnIds(rgColIds, ARRAYSIZE(rgColIds));
    INT cRows = m_DV.GetReportRowCount();
    INT i, j;
    INT iRow = -1;

    DBGASSERT((NULL != pStm));
    m_Stm.SetStream(pStm);

    //
    // Start the report.
    //
    Begin(cRows, cCols);

    //
    // Add the report title.
    //
    m_DV.GetReportTitle(szText, ARRAYSIZE(szText));
    AddTitle(szText);

    //
    // Add the report column headers.
    //
    BeginHeaders();
    for (i = 0; i < cCols; i++)
    {
        m_DV.GetReportColHeader(rgColIds[i], szText, ARRAYSIZE(szText));
        AddHeader(szText);
        AddHeaderSep();
    }
    EndHeaders();

    //
    // Add the report row/col data.
    //
    for (i = 0; i < cRows; i++)
    {
        iRow = m_DV.GetNextSelectedItemIndex(iRow);
        DBGASSERT((-1 != iRow));
        BeginRow();
        for (j = 0; j < cCols; j++)
        {
            AddRowColData(iRow, rgColIds[j]);
            AddRowColSep();
        }
        EndRow();
    }

    //
    // Terminate the report.
    //
    End();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::Stream

    Description: Constructor for the renderer's private stream object.
        The object is used to encapsulate stream write operations in overloaded
        type-sensitive member functions.

    Arguments:
        pStm - Address of IStream associated with the object.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::Renderer::Stream::Stream(
    IStream *pStm
    ) : m_pStm(pStm)
{

#ifdef CLIPBOARD_DEBUG_OUTPUT
    m_pStgDbgOut = NULL;
    m_pStmDbgOut = NULL;
    StgCreateDocfile(TEXT("\\DskquotaClipboard.Out"),
                     STGM_CREATE |
                     STGM_READWRITE |
                     STGM_SHARE_EXCLUSIVE,
                     0,
                     &m_pStgDbgOut);
    if (NULL != m_pStgDbgOut)
    {
        m_pStgDbgOut->CreateStream(TEXT("Clipboard Data"),
                                   STGM_CREATE |
                                   STGM_READWRITE |
                                   STGM_SHARE_EXCLUSIVE,
                                   0, 0,
                                   &m_pStmDbgOut);
    }
#endif // CLIPBOARD_DEBUG_OUTPUT
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::~Stream

    Description: Destructor for the renderer's private stream object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::DataObject::Renderer::Stream::~Stream(VOID)
{
    if (NULL != m_pStm)
        m_pStm->Release();

#ifdef CLIPBOARD_DEBUG_OUTPUT

    if (NULL != m_pStmDbgOut)
        m_pStmDbgOut->Release();
    if (NULL != m_pStgDbgOut)
        m_pStgDbgOut->Release();

#endif // CLIPBOARD_DEBUG_OUTPUT
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::SetStream

    Description: Associates an IStream pointer with the stream object.
        Releases an existing pointer if one was already assigned.

    Arguments:
        pStm - Address of new IStream to associate with stream object.
            Caller must AddRef IStream pointer before passing to this function.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Stream::SetStream(
    IStream *pStm
    )
{
    DBGASSERT((NULL != pStm));

    if (NULL != m_pStm)
        m_pStm->Release();
    m_pStm = pStm;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::DataObject::Renderer::Stream::Write

    Description: Set of overloaded functions to handle
        the writing of various types of data to the stream.

    Arguments:
        pbData - Address of BYTE buffer for source data.

        cbData - Number of bytes in pbData[]

        pszTextA - Ansi text string for source data.

        pszTextW - Wide character text string for source data.

        bData - Byte to write to stream.

        chDataW - Wide character to write to stream.

        chDataA - Ansi character to write to stream.

        dwData - DWORD-type data to write to stream.

        dblData - double-type data to write to stream.


    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPBYTE pbData,
    UINT cbData
    )
{
    DBGASSERT((NULL != pbData));

    ULONG cbWritten = 0;
    HRESULT hr;

    hr = m_pStm->Write(pbData, cbData, &cbWritten);
    if (S_OK != hr)
    {
        DBGERROR((TEXT("Error 0x%08X writing to output stream."), hr));
        CFileException::reason reason = CFileException::write;
        switch(hr)
        {
            case STG_E_ACCESSDENIED:
                reason = CFileException::access;
                break;
            case STG_E_MEDIUMFULL:
                reason = CFileException::diskfull;
                break;
            case STG_E_WRITEFAULT:
                reason = CFileException::device;
                break;
            default:
                //
                // Use default value.
                //
                break;
        }
        throw CFileException(reason, TEXT(""), 0);
    }

#ifdef CLIPBOARD_DEBUG_OUTPUT

    cbWritten = 0;
    if (S_OK != m_pStmDbgOut->Write(pbData, cbData, &cbWritten))
        throw CFileException(CFileException::write, TEXT(""), 0);

#endif  // CLIPBOARD_DEBUG_OUTPUT
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPCWSTR pszTextW
    )
{
    Write((LPBYTE)pszTextW, lstrlenW(pszTextW) * sizeof(WCHAR));
}

VOID
DetailsView::DataObject::Renderer::Stream::Write(
    LPCSTR pszTextA
    )
{
    Write((LPBYTE)pszTextA, lstrlenA(pszTextA) * sizeof(CHAR));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    BYTE bData
    )
{
    Write((LPBYTE)&bData, sizeof(bData));
}

VOID
DetailsView::DataObject::Renderer::Stream::Write(
    WCHAR chDataW
    )
{
    Write((LPBYTE)&chDataW, sizeof(chDataW));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    CHAR chDataA
    )
{
    Write((LPBYTE)&chDataA, sizeof(chDataA));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    DWORD dwData
    )
{
    Write((LPBYTE)&dwData, sizeof(dwData));
}


VOID
DetailsView::DataObject::Renderer::Stream::Write(
    double dblData
    )
{
    Write((LPBYTE)&dblData, sizeof(dblData));
}


///////////////////////////////////////////////////////////////////////////////
//
// The following section of code contains the different implementations of
// the virtual rendering functions that make each type of rendering object
// unique.  Since they're pretty self-explanatory, I haven't commented each
// function.  It should be obvious as to what they do.
// I have separated each rendering-type section with a banner comment for
// readability.  [brianau]
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// CF_UNICODETEXT
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer_UNICODETEXT::AddTitle(
    LPCTSTR pszTitle
    )
{
    m_Stm.Write(pszTitle);
    m_Stm.Write(L'\r');
    m_Stm.Write(L'\n');
    m_Stm.Write(L'\r');
    m_Stm.Write(L'\n');
}


VOID
DetailsView::DataObject::Renderer_UNICODETEXT::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szText[MAX_PATH];
    LV_REPORT_ITEM item;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szText;
    item.cchMaxText = ARRAYSIZE(szText);

    m_DV.GetReportItem(iRow, idCol, &item);
    m_Stm.Write(szText);
}


///////////////////////////////////////////////////////////////////////////////
// CF_TEXT
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::DataObject::Renderer_TEXT::AddTitle(
    LPCWSTR pszTitleW
    )
{
    array_autoptr<CHAR> ptrTitleA(DataObject::WideToAnsi(pszTitleW));
    m_Stm.Write(ptrTitleA);
    m_Stm.Write('\r');
    m_Stm.Write('\n');
    m_Stm.Write('\r');
    m_Stm.Write('\n');
}


VOID
DetailsView::DataObject::Renderer_TEXT::AddHeader(
    LPCWSTR pszHeaderW
    )
{
    array_autoptr<CHAR> ptrHeaderA(DataObject::WideToAnsi(pszHeaderW));
    m_Stm.Write(ptrHeaderA);
}


VOID
DetailsView::DataObject::Renderer_TEXT::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szTextW[MAX_PATH];
    LV_REPORT_ITEM item;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szTextW;
    item.cchMaxText = ARRAYSIZE(szTextW);

    m_DV.GetReportItem(iRow, idCol, &item);

    array_autoptr<CHAR> ptrTextA(DataObject::WideToAnsi(szTextW));
    m_Stm.Write(ptrTextA);
}


///////////////////////////////////////////////////////////////////////////////
// RTF (Rich Text)
///////////////////////////////////////////////////////////////////////////////
static const INT TWIPS_PER_PT    = 20;
static const INT PTS_PER_INCH    = 72;
static const INT TWIPS_PER_INCH  = PTS_PER_INCH * TWIPS_PER_PT;
static const INT COL_WIDTH_TWIPS = TWIPS_PER_INCH * 5 / 4;       // 1 1/4 inches.

//
// Converts all single backslashes to double backslashes.
// Literal backslashes in RTF must be "\\".
// Caller must delete[] the returned buffer.
//
LPSTR
DetailsView::DataObject::Renderer_RTF::DoubleBackslashes(
    LPSTR pszSrc
    )
{
    DBGASSERT((NULL != pszSrc));

    //
    // Create new string for output.  Size must be double.  Every char
    // could be '\'.
    //
    LPSTR pszFormatted = new CHAR[(lstrlenA(pszSrc) * 2) + 1];
    LPSTR pszDest      = pszFormatted;

    while('\0' != *pszSrc)
    {
        if ('\\' == *pszSrc)
            *pszDest++ = *pszSrc;
        *pszDest++ = *pszSrc++;
    }

    *pszDest = *pszSrc; // Pick up NUL terminator.
    return pszFormatted;
}


VOID
DetailsView::DataObject::Renderer_RTF::Begin(
    INT cRows,
    INT cCols
    )
{
    m_cCols = cCols;
    m_Stm.Write("{\\rtf1 \\sect\\sectd\\lndscpsxn \\par\\pard\\plain ");
}



VOID
DetailsView::DataObject::Renderer_RTF::AddTitle(
    LPCWSTR pszTitleW
    )
{
    array_autoptr<CHAR> ptrTempA(DataObject::WideToAnsi(pszTitleW));
    array_autoptr<CHAR> ptrTitleA(DoubleBackslashes(ptrTempA));      // cvt '\' to "\\"
    m_Stm.Write(ptrTitleA);
}



VOID DetailsView::DataObject::Renderer_RTF::BeginHeaders(
    VOID
    )
{
    m_Stm.Write(" \\par \\par ");   // Hdr preceded by empty row.
    BeginHeaderOrRow();             // Add stuff common to hdr and data rows.
    m_Stm.Write(" \\trhdr ");       // Hdr at top of each page.
    AddCellDefs();                  // Cell size definitions.
}



VOID DetailsView::DataObject::Renderer_RTF::AddCellDefs(
    VOID
    )
{
    char szText[80];
    INT cxTwips = 0;

    for (INT i = 0; i < m_cCols; i++)
    {
        cxTwips += COL_WIDTH_TWIPS;
        wsprintfA(szText, "\\cellx%d", cxTwips);
        m_Stm.Write(szText);
    }
    m_Stm.Write(' ');
}


//
// Stuff common to both header row and data rows.
//
VOID DetailsView::DataObject::Renderer_RTF::BeginHeaderOrRow(
    VOID
    )
{
    m_Stm.Write("\\trowd \\pard \\intbl ");
}



VOID
DetailsView::DataObject::Renderer_RTF::AddHeader(
    LPCWSTR pszHeaderW
    )
{
    array_autoptr<CHAR> ptrHeaderA(DataObject::WideToAnsi(pszHeaderW));
    //
    // No need to convert '\' to "\\".  No
    // backslashes in our header text.
    //
    m_Stm.Write(ptrHeaderA);
}


VOID
DetailsView::DataObject::Renderer_RTF::AddRowColData(
    INT iRow,
    INT idCol
    )
{
    WCHAR szTextW[MAX_PATH];
    LV_REPORT_ITEM item;
    item.fType      = LVRI_TEXT;  // Want text data.
    item.pszText    = szTextW;
    item.cchMaxText = ARRAYSIZE(szTextW);

    m_DV.GetReportItem(iRow, idCol, &item);

    array_autoptr<CHAR> ptrTempA(DataObject::WideToAnsi(szTextW));
    array_autoptr<CHAR> ptrTextA(DoubleBackslashes(ptrTempA));      // cvt '\' to "\\"
    m_Stm.Write(ptrTextA);
}


///////////////////////////////////////////////////////////////////////////////
// Private import/export format
///////////////////////////////////////////////////////////////////////////////
//
// Assumes that caller AddRef'd IStream pointer.
//
VOID
DetailsView::DataObject::Renderer_Export::Render(
    IStream *pStm
    )
{
    HRESULT hResult = NO_ERROR;
    INT cRows = m_DV.GetReportRowCount();
    INT iRow = -1;

    DBGASSERT((NULL != pStm));
    m_Stm.SetStream(pStm);

    Begin(cRows, 0);

    //
    // Add the export data records.
    //
    for (INT i = 0; i < cRows; i++)
    {
        iRow = m_DV.GetNextSelectedItemIndex(iRow);
        DBGASSERT((-1 != iRow));
        AddBinaryRecord(iRow);
    }

    //
    // Terminate the report.
    //
    End();
}

VOID
DetailsView::DataObject::Renderer_Export::Begin(
    INT cRows,
    INT cCols
    )
{
    //
    // The stream header contains a GUID as a unique identifier followed
    // by a version number.
    //
    m_Stm.Write((LPBYTE)&GUID_NtDiskQuotaStream, sizeof(GUID_NtDiskQuotaStream));
    m_Stm.Write(DataObject::EXPORT_STREAM_VERSION);
    m_Stm.Write((DWORD)cRows);
}


VOID
DetailsView::DataObject::Renderer_Export::AddBinaryRecord(
    INT iRow
    )
{
    INT cbRecord    = m_DV.GetReportBinaryRecordSize(iRow);
    array_autoptr<BYTE> ptrRecord(new BYTE[cbRecord]);
    if (NULL != ptrRecord.get())
    {
        if (m_DV.GetReportBinaryRecord(iRow, ptrRecord, cbRecord))
        {
            m_Stm.Write(ptrRecord, cbRecord);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// CF "FileGroupDescriptor"
//
//
///////////////////////////////////////////////////////////////////////////////

VOID
DetailsView::DataObject::Renderer_FileGroupDescriptor::Begin(
    INT cRows,
    INT cCols
    )
{
    //
    // Build a name for the file we'll create.
    //
    // Vol label?  Filename
    // ----------  -------------------------------------------------------
    //  Yes        "Disk Quota Settings for Volume 'VOL_LABEL'"
    //  No         "Disk Quota Settings for Unlabeled Volume SN 8AB1-DE23"
    //
    // The serial-number format is gross but without a label, we don't have
    // any other distinguishing feature for the volume.  I'd use the
    // display name from the CVolumeID object but in the mounted volume
    // case, it contains backslashes and a colon; both invalid buried in
    // a filename.
    //
    TCHAR szLabel[MAX_VOL_LABEL] = { TEXT('\0') };
    DWORD dwSerialNumber = 0;
    GetVolumeInformation(m_DV.GetVolumeID().ForParsing(),
                         szLabel,
                         ARRAYSIZE(szLabel),
                         &dwSerialNumber,
                         NULL,
                         NULL,
                         NULL,
                         0);

    CString strFileName;
    if (TEXT('\0') != szLabel[0])
    {
        //
        // Volume has a label.
        //
        strFileName.Format(g_hInstDll,
                           IDS_EXPORT_STREAM_FILENAME_TEMPLATE,
                           szLabel);
    }
    else
    {
        //
        // No volume label.
        //
        strFileName.Format(g_hInstDll,
                           IDS_EXPORT_STREAM_FILENAME_TEMPLATE_VOLSN,
                           HIWORD(dwSerialNumber),
                           LOWORD(dwSerialNumber));
    }

    //
    // Create a file group descriptor containing the name we want the
    // shell to use for the file.  The descriptor contains one file
    // description.  That description just contains the file name.
    // All other members are initialized to 0.
    //
    FILEGROUPDESCRIPTORW desc;

    ZeroMemory(&desc, sizeof(desc));
    desc.cItems = 1;
    lstrcpyn(desc.fgd[0].cFileName, strFileName, ARRAYSIZE(desc.fgd[0].cFileName));

    //
    // Write the file group descriptor to the renderer's stream.
    //
    m_Stm.Write((LPBYTE)&desc, sizeof(desc));
}





///////////////////////////////////////////////////////////////////////////////
/*  Function: LVSelection::Add

    Description: Add a user pointer and listview item index to a listview
        selection object.  This object is used to transfer the notion of a
        "selection" to some function.

    Arguments:
        pUser - Address of IDiskQuotaUser interface for a selected user object.

        iItem - Index of selected item in the listview.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
LVSelection::Add(
    PDISKQUOTA_USER pUser,
    INT iItem
    )
{
    DBGASSERT((NULL != pUser));

    ListEntry entry;
    entry.pUser = pUser;
    entry.iItem = iItem;

    m_List.Append((LPVOID)&entry);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: LVSelection::Retrieve

    Description: Retrieves a user pointer and listview item index from a
        listview selection object.

    Arguments:
        i - Index of item.  Use the Count() method to determine how many
            items are in the selection object.

        ppUser - Address of an interface pointer variable to receive the
            IDiskQuotaUser interface for the user object at index 'i'.

        piItem - Address of integer variable to receive the Listview item index
            of the object at index 'i'.

    Returns: TRUE  = Returned information is valid.
             FALSE = Couldn't retrieve entry 'i'.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
LVSelection::Retrieve(
    INT i,
    PDISKQUOTA_USER *ppUser,
    INT *piItem
    )
{
    ListEntry entry;
    if (m_List.Retrieve((LPVOID)&entry, i))
    {
        if (NULL != ppUser)
            *ppUser = entry.pUser;
        if (NULL != piItem)
            *piItem = entry.iItem;
        return TRUE;
    }
    return FALSE;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::ColumnMap
    Function: ColumnMap::~ColumnMap

    Description: Constructor and Destructor.
        Creates/Destroys a column map.  The column map is used
        to map column ID's (known to the Details View) to listview subitem
        indices.  It is needed to support the addition and deletion of the
        folder name column.

    Arguments:
        cMapSize - Number of entries in the map.  Should be the max number
            of columns possible in the listview.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ColumnMap::ColumnMap(
    UINT cMapSize
    ) : m_pMap(NULL),
        m_cMapSize(cMapSize)
{
    //
    // Can throw OutOfMemory.
    //
    m_pMap     = new INT[m_cMapSize];
    FillMemory(m_pMap, m_cMapSize * sizeof(m_pMap[0]), (BYTE)-1);
}

ColumnMap::~ColumnMap(
    VOID
    )
{
    if (NULL != m_pMap)
        delete[] m_pMap;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::SubItemToId

    Description: Returns a column ID given a listview subitem index.

    Arguments:
        iSubItem - 0-based subitem index of the item to be mapped.

    Returns: Column ID corresponding to subitem.  -1 if the subitem is invalid.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
ColumnMap::SubItemToId(
    INT iSubItem
    ) const
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    return *(m_pMap + iSubItem);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::IdToSubItem

    Description: Returns a listview subitem index given a column ID.

    Arguments:
        iColId - ID of column. i.e. idCol_Name, idCol_Folder etc.

    Returns: Listview subitem index.  -1 if the column is not currently
        visible.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
ColumnMap::IdToSubItem(
    INT iColId
    ) const
{
    for (INT i = 0; i < (INT)m_cMapSize; i++)
    {
        if (SubItemToId(i) == iColId)
            return i;
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::RemoveId

    Description: Removes a mapping for a given listview subitem index.

    Arguments:
        iSubItem - 0-based subitem index of the item to be removed.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
    11/30/96    Fixed off-by-one error.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ColumnMap::RemoveId(
    INT iSubItem
    )
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    for (INT i = iSubItem; i < (INT)m_cMapSize - 1; i++)
        *(m_pMap + i) = *(m_pMap + i + 1);
    *(m_pMap + m_cMapSize - 1) = -1;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: ColumnMap::InsertId

    Description: Adds a mapping for a given listview subitem index.
        The mapping is added at the iSubItem location in the map.  All subsequent
        item mappings are shifted down one place.  This is analogous to
        inserting a column into the listview.

    Arguments:
        iSubItem - 0-based subitem index of the item to be removed.

        iColId - ID of column. i.e. idCol_Name, idCol_Folder etc.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/09/96    Initial creation.                                    BrianAu
    11/30/96    Fixed off-by-one error.                              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ColumnMap::InsertId(
    INT iSubItem,
    INT iColId
    )
{
    DBGASSERT((iSubItem >= 0 && iSubItem < (INT)m_cMapSize));
    for (INT i = m_cMapSize-1; i > iSubItem; i--)
        *(m_pMap + i) = *(m_pMap + i - 1);
    *(m_pMap + iSubItem) = iColId;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::Finder

    Description: Constructs a user finder object.
        The user finder coordinates the activities of finding an item in
        the details listview.

    Arguments:
        DetailsView - Reference to the details view object.

        cMaxMru - Maximum entries allowed in the most-recently-used list.
            This list is maintained in the dropdown combo box in the
            view's toolbar.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DetailsView::Finder::Finder(
    DetailsView& DetailsView,
    INT cMaxMru
    ) : m_DetailsView(DetailsView),
        m_hwndToolbarCombo(NULL),
        m_cMaxComboEntries(cMaxMru),
        m_pfnOldToolbarComboWndProc(NULL)
{
    //
    // Nothing more to do.
    //
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::ConnectToolbarCombo

    Description: Connects the finder object to the combo box in the view's
        toolbar.  This is necessary because the finder object coordinates
        the contents of the toolbar combo box with the contents of the
        combo box in the "Find User" dialog.  When you enter a name in
        one of the boxes, it is automatically added to the other so they
        appear to be in sync.

        Also subclasses the edit control within the combo box.  This is
        required so that we can intercept VK_RETURN and find the record
        when the user presses [Return].

        Also adds the toolbar combo box as a "tool" to the toolbar.  This
        is so we can get a tooltip for the combo.

    Arguments:
        hwndToolbarCombo - Hwnd of combo box in view's toolbar.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::ConnectToolbarCombo(
    HWND hwndToolbarCombo
    )
{
    m_hwndToolbarCombo = hwndToolbarCombo;

    //
    // Add the combo box to the toolbar's list of "tools".
    // This will allow us to get a tooltip for the combo box.
    // This code assumes that the combo is a child of the toolbar.
    //
    HWND hwndToolbar = GetParent(hwndToolbarCombo);
    HWND hwndMain    = GetParent(hwndToolbar);
    HWND hwndTooltip = (HWND)SendMessage(hwndToolbar,
                                         TB_GETTOOLTIPS,
                                         0, 0);
    if (NULL != hwndTooltip)
    {
        TOOLINFO ti;

        ti.cbSize   = sizeof(ti);
        ti.uFlags   = TTF_IDISHWND | TTF_CENTERTIP | TTF_SUBCLASS;
        ti.lpszText = (LPTSTR)IDS_TOOLBAR_COMBO;
        ti.hwnd     = hwndMain;
        ti.uId      = (UINT_PTR)hwndToolbarCombo;
        ti.hinst    = g_hInstDll;

        SendMessage(hwndTooltip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    }

    //
    // Subclass the combo box so we can intercept VK_ENTER.
    // This is done so we can respond to VK_ENTER.  Normally combo boxes
    // don't respond to this keystroke.
    //
    HWND hwndComboEdit = NULL;

    //
    // The combo box has two children... an edit control and a listbox control.
    // Find the edit control.
    //
    for (HWND hwndChild =  GetTopWindow(m_hwndToolbarCombo);
         hwndChild      != NULL;
         hwndChild      =  GetNextWindow(hwndChild, GW_HWNDNEXT))
    {
        TCHAR szClassName[20] = { TEXT('\0') };
        GetClassName(hwndChild, szClassName, ARRAYSIZE(szClassName));

        if (0 == lstrcmpi(szClassName, TEXT("Edit")))
        {
            hwndComboEdit = hwndChild;
            break;
        }
    }

    if (NULL != hwndComboEdit)
    {
        //
        // Store the address of the Finder object in the combo box's
        // userdata.  This is so the subclass WndProc (a static function)
        // can access the finder object.
        //
        SetWindowLongPtr(hwndComboEdit, GWLP_USERDATA, (INT_PTR)this);

        //
        // Subclass the combo box's edit control.
        //
        m_pfnOldToolbarComboWndProc = (WNDPROC)GetWindowLongPtr(hwndComboEdit,
                                                                GWLP_WNDPROC);
        SetWindowLongPtr(hwndComboEdit,
                        GWLP_WNDPROC,
                        (INT_PTR)DetailsView::Finder::ToolbarComboSubClassWndProc);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::InvokeFindDialog

    Description: Display the "Find User" dialog.

    Arguments:
        hwndParent - Parent for the dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::InvokeFindDialog(
    HWND hwndParent
    )
{
    DialogBoxParam(g_hInstDll,
                   MAKEINTRESOURCE(IDD_FINDUSER),
                   hwndParent,
                   DetailsView::Finder::DlgProc,
                   (LPARAM)this);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::DlgProc

    Description: DlgProc for the "Find User" dialog.

    Arguments:
        Standard DlgProc arguments.

    Returns:
        Standard DlgProc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
DetailsView::Finder::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Get the finder object's "this" ptr from the window's userdata.
    //
    Finder *pThis = (Finder *)GetWindowLongPtr(hwnd, DWLP_USER);
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            //
            // Save the "this" ptr in the window's userdata.
            //
            pThis = (Finder *)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)pThis);

            //
            // Set the height of the combo in the dialog.
            // Not sure why, but DevStudio's dialog editor won't let me
            // do this.   Use the same height value we use for the combo
            // in the toolbar.  It's the same contents so the height
            // should be the same.
            //
            HWND hwndCombo = GetDlgItem(hwnd, IDC_CMB_FINDUSER);
            RECT rcCombo;

            GetClientRect(hwndCombo, &rcCombo);
            SetWindowPos(hwndCombo,
                         NULL,
                         0, 0,
                         rcCombo.right - rcCombo.left,
                         CY_TOOLBAR_COMBO,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);

            //
            // Fill the dialog's combo with entries from the toolbar
            // combo.  The toolbar's combo box contains the MRU for finding users.
            //
            pThis->FillDialogCombo(pThis->m_hwndToolbarCombo, GetDlgItem(hwnd, IDC_CMB_FINDUSER));

            return 1;
        }

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    //
                    // User pressed OK button or [Enter].
                    //
                    DBGASSERT((NULL != pThis));
                    if (!pThis->UserNameEntered(GetDlgItem(hwnd, IDC_CMB_FINDUSER)))
                    {
                        //
                        // Record not found so don't close dialog.
                        // UserNameEntered() will display UI to tell the user
                        // that the name wasn't found.  Leave the dialog open
                        // so user can retry with a new name.
                        //
                        break;
                    }

                    //
                    // Fall through...
                    //
                case IDCANCEL:
                    //
                    // User pressed Cancel button or [ESC].
                    //
                    EndDialog(hwnd, 0);
                    break;

                default:
                    break;
            }
            break;
    };
    return 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::FillDialogCombo

    Description: Fill the combo box in the dialog with the contents
        from a second combo box.

    Arguments:
        hwndComboSrc - Hwnd of source combo containing text strings.

        hwndComboDest - Hwnd of combo where strings will be copied to.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::FillDialogCombo(
    HWND hwndComboSrc,
    HWND hwndComboDest
    )
{
    //
    // Clear out the destination combo.
    //
    SendMessage(hwndComboDest, CB_RESETCONTENT, 0, 0);

    //
    // Copy all contents of the source combo to the destination combo.
    //
    INT cItems = (INT)SendMessage(hwndComboSrc, CB_GETCOUNT, 0, 0);
    if (CB_ERR != cItems)
    {
        for (INT i = 0; i < cItems; i++)
        {
            LPTSTR pszName = NULL;
            INT cchName = (INT)SendMessage(hwndComboSrc, CB_GETLBTEXTLEN, i, 0);
            pszName = new TCHAR[cchName + 1];

            if (NULL != pszName)
            {
                //
                // Remove item from the source combo at index [i] and append
                // it to the destination combo.
                //
                SendMessage(hwndComboSrc,  CB_GETLBTEXT, i, (LPARAM)pszName);
                SendMessage(hwndComboDest, CB_ADDSTRING, 0, (LPARAM)pszName);
                delete[] pszName;
            }
        }
    }
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::ToolbarComboSubclassWndProc

    Description: Subclass window procedure for the "Edit" control that is part
        of the combo contained in the view's toolbar.  We subclass this control
        so that we can intercept VK_RETURN and handle it.  The standard combo
        box just beeps when you press [Enter] in it's edit control.

    Arguments:
        Standard WndProc arguments.

    Returns:
        Standard WndProc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK
DetailsView::Finder::ToolbarComboSubClassWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Get finder object's "this" ptr from window's userdata.
    //
    Finder *pThis = (Finder *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
        case WM_CHAR:
            switch(wParam)
            {
                case VK_RETURN:
                {
                    //
                    // Tell the finder that a user name was entered in the
                    // combo box.  Pass the hwnd of the combo from which the
                    // name was entered.  Since this message is for the
                    // subclassed edit control (child of the combo), the
                    // parent is the combo box itself.
                    //
                    DBGASSERT((NULL != pThis));
                    HWND hwndCombo = GetParent(hwnd);
                    if (pThis->UserNameEntered(hwndCombo))
                    {
                        //
                        // Record found in view.
                        // Set focus to the main view.
                        // If not found, focus should just stay with the combo
                        // so user can enter another name.
                        //
                        HWND hwndToolbar = GetParent(hwndCombo);
                        SetFocus(GetParent(hwndToolbar));
                    }
                    else
                    {
                        //
                        // Not found in listview.  Focus remains in the combo box
                        // so user can try again with a new name.
                        //
                        SetFocus(hwndCombo);
                    }

                    //
                    // Swallow up the VK_RETURN.
                    // Otherwise, the combo box control beeps.
                    //
                    return 0;
                }

                case VK_ESCAPE:
                {
                    //
                    // Set focus to the main window which will set focus to the
                    // listview.  This gives the keyboard-only user a way to
                    // get back out of the combo box.
                    //
                    HWND hwndCombo = GetParent(hwnd);
                    HWND hwndToolbar = GetParent(hwndCombo);
                    SetFocus(GetParent(hwndToolbar));
                    //
                    // Swallow VK_ESCAPE so combo box doesn't beep.
                    //
                    return 0;
                }
            }
            break;

        default:
            break;
    }
    return CallWindowProc(pThis->m_pfnOldToolbarComboWndProc,
                          hwnd, uMsg, wParam, lParam);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::AddNameToCombo

    Description: Add a name string to one of the Find User combo boxes.
        If the item already exists in the list, it is moved to the top of the
        list.  If the item is not in the list, it is added at the top of the list.
        If the addition of the new item causes the list's entry count to exceed
        a specified maximum value, the last item in the list is removed.

    Arguments:
        hwndCombo - Hwnd for the combo box to which the name is added.

        pszName - Address of name string to add.

        cMaxEntries - Maximum number of entries allowed in combo box.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
DetailsView::Finder::AddNameToCombo(
    HWND hwndCombo,
    LPCTSTR pszName,
    INT cMaxEntries
    )
{
    if (NULL != pszName && TEXT('\0') != *pszName)
    {
        //
        // See if the item already exists in the list.
        //
        INT iItemToDelete = (INT)SendMessage(hwndCombo,
                                             CB_FINDSTRING,
                                             (WPARAM)-1,
                                             (LPARAM)pszName);

        if (CB_ERR == iItemToDelete)
        {
            //
            // Item is not already in the list.  Need to add it.
            // If the list is full, we'll have to drop one off of the end.
            //
            INT cItems = (INT)SendMessage(hwndCombo, CB_GETCOUNT, 0, 0);

            if (CB_ERR != cItems && 0 < cItems && cItems >= cMaxEntries)
            {
                iItemToDelete = cItems - 1;
            }
        }
        if (-1 != iItemToDelete)
        {
            //
            // Need to delete an existing item for one of these reasons:
            //
            //  1. Promoting an existing item to the head of the list.
            //     Delete it from it's previous location.
            //  2. Dropping last item from list.
            //
            SendMessage(hwndCombo, CB_DELETESTRING, iItemToDelete, 0);
        }
        //
        // Add the new item at the head of the list.
        //
        SendMessage(hwndCombo, CB_INSERTSTRING, 0, (LPARAM)pszName);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Finder::UserNameEntered

    Description: A name has been entered from one of the combo boxes.
        1. Retrieve the name from the combo.
        2. See if it's in the listview and if it is, the listview ensures the
           item is visible and selects it.
        3. Update the toobar combo's list with the new item.  This is our MRU
           list.

        Add a name string to one of the Find User combo boxes.
        If the item already exists in the list, it is moved to the top of the
        list.  If the item is not in the list, it is added at the top of the list.
        If the addition of the new item causes the list's entry count to exceed
        a specified maximum value, the last item in the list is removed.

    Arguments:
        hwndCombo - Hwnd for the combo box to which the name is added.

        pszName - Address of name string to add.

        cMaxEntries - Maximum number of entries allowed in combo box.

    Returns:
        TRUE  = User was found in listview.
        FALSE = User was not found in listview.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
DetailsView::Finder::UserNameEntered(
    HWND hwndCombo
    )
{
    TCHAR szName[MAX_PATH]    = { TEXT('\0') };
    BOOL bUserFoundInListView = FALSE;

    //
    // Get the name from the combo edit control.
    //
    if (0 < SendMessage(hwndCombo, WM_GETTEXT, (WPARAM)ARRAYSIZE(szName), (LPARAM)szName))
    {
        //
        // Tell the details view object to highlight this name.
        //
        bUserFoundInListView = m_DetailsView.GotoUserName(szName);

        if (bUserFoundInListView)
        {
            //
            // Add the name to the toolbar combo's listbox.  This becomes
            // our MRU list.  Also make sure the visible name in the combo's
            // edit control is the one last entered.  May have been entered
            // through the "Find User" dialog.
            //
            AddNameToCombo(m_hwndToolbarCombo, szName, m_cMaxComboEntries);
            SendMessage(m_hwndToolbarCombo, WM_SETTEXT, 0, (LPARAM)szName);
        }
        else
        {
            //
            // Display a message box to the user stating that the user couldn't
            // be found in the listview.
            //
            CString strMsg(g_hInstDll, IDS_USER_NOT_FOUND_IN_LISTVIEW, szName);

            DiskQuotaMsgBox(hwndCombo,
                            (LPCTSTR)strMsg,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONEXCLAMATION);
        }
    }
    return bUserFoundInListView;
}



DetailsView::Importer::Importer(
    DetailsView& DV
    ) : m_DV(DV),
        m_bUserCancelled(FALSE),
        m_bPromptOnReplace(TRUE),
        m_dlgProgress(IDD_PROGRESS,
                      IDC_PROGRESS_BAR,
                      IDC_TXT_PROGRESS_DESCRIPTION,
                      IDC_TXT_PROGRESS_FILENAME),
        m_hwndParent(m_DV.m_hwndMain),
        m_cImported(0)
{
    if (m_dlgProgress.Create(g_hInstDll, m_hwndParent))
    {
        EnableWindow(m_hwndParent, FALSE);
        m_dlgProgress.SetDescription(MAKEINTRESOURCE(IDS_PROGRESS_IMPORTING));
        m_dlgProgress.Show();
    }
    //
    // Clear any previous undo actions from the view's undo list.
    //
    m_DV.m_pUndoList->Clear();
}

DetailsView::Importer::~Importer(
    VOID
    )
{
    Destroy();
}


VOID
DetailsView::Importer::Destroy(
    VOID
    )
{
    if (NULL != m_hwndParent && !IsWindowEnabled(m_hwndParent))
    {
        EnableWindow(m_hwndParent, TRUE);
    }

    m_dlgProgress.Destroy();

    //
    // Update the view's "Undo" menu and toolbar button based on the current
    // contents of the undo list.
    //
    m_DV.EnableMenuItem_Undo(0 != m_DV.m_pUndoList->Count());
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [IDataObject *]

    Description: Imports user quota records given an IDataObject pointer.
        Called from DetailsView::Drop().

    Arguments:
        pIDataObject - Pointer to IDataObject interface of object containing
            import data.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    IDataObject *pIDataObject
    )
{
    HRESULT hResult = NO_ERROR;
    FORMATETC fmt;
    CStgMedium medium;

    //
    // Array to specify the clipboard formats and media types that
    // we can import from.  Ordered by preference.
    //
    struct
    {
        CLIPFORMAT fmt;
        DWORD tymed;
    } rgFmtMedia[] = {{ DataObject::m_CF_NtDiskQuotaExport, TYMED_ISTREAM},
                      { DataObject::m_CF_NtDiskQuotaExport, TYMED_HGLOBAL},
                      { CF_HDROP,                           TYMED_ISTREAM},
                      { CF_HDROP,                           TYMED_HGLOBAL}};

    DBGASSERT((NULL != pIDataObject));

    hResult = E_FAIL;
    for (INT i = 0; i < ARRAYSIZE(rgFmtMedia); i++)
    {
        //
        // See which of our supported formats/media types the drop
        // source supports.
        //
        DataObject::SetFormatEtc(fmt, rgFmtMedia[i].fmt, rgFmtMedia[i].tymed);

        //
        // NOTE:  I wanted to call QueryGetData to verify a source's support
        //        for a format.  However, it didn't work properly when
        //        pasting an HDROP from the shell.  Calling GetData()
        //        directly results in the proper behavior.
        //
        hResult = pIDataObject->GetData(&fmt, &medium);
        if (SUCCEEDED(hResult))
        {
            break;
        }
    }

    if (SUCCEEDED(hResult))
    {
        //
        // Successfully have dropped data from the source.
        // Import users from it.
        //
        hResult = Import(fmt, medium);
    }
    else
    {
        DBGERROR((TEXT("PasteFromData: Error 0x%08X, Drop source doesn't support our format/media"), hResult));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [FORMATETC&, STGMEDIUM&]

    Description: Imports one or more users from a storage medium.

    Arguments:
        fmt - Reference to the FORMATETC structure describing the data format.

        medium - Reference to the STGMEDIUM structure describing the medium.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    const FORMATETC& fmt,
    const STGMEDIUM& medium
    )
{
    HRESULT hResult   = E_FAIL;
    IStream *pIStream = NULL;

    if (TYMED_HGLOBAL == medium.tymed)
    {
        //
        // Medium type is an HGLOBAL but our import functions need
        // a stream.
        //
        hResult = CreateStreamOnHGlobal(medium.hGlobal, FALSE, &pIStream);
    }
    else if (TYMED_ISTREAM == medium.tymed)
    {
        pIStream = medium.pstm;
        hResult  = NO_ERROR;
    }
    //
    // OK.  The source can render data in one of our acceptable
    // formats and medium types.  Go ahead and have them render
    // it onto our stream.
    //
    if (NULL != pIStream)
    {
        if (DetailsView::DataObject::m_CF_NtDiskQuotaExport == fmt.cfFormat)
        {
            //
            // Stream contains quota record information directly.
            // Import the records.
            //
            Source src(pIStream);
            Import(src);
        }
        else if (CF_HDROP == fmt.cfFormat)
        {
            //
            // Stream contains names of files that potentially
            // contain quota record information.
            //
            HGLOBAL hDrop;
            hResult = GetHGlobalFromStream(pIStream, &hDrop);
            if (SUCCEEDED(hResult))
            {
                hResult = Import((HDROP)hDrop);
            }
        }
    }
    else
    {
        DBGERROR((TEXT("PasteFromData: GetData failed with error 0x%08X"), hResult));
    }
    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [LPCTSTR]

    Description: Imports settings for one or more users from a doc file on
        disk.  The doc file contains the import data directly in the stream.
        After opening and validating the storage and stream, it passes the
        stream to ImportUsersFromStream.

    Arguments:
        pszFilePath - Path to doc file containing import information stream.

        bUserCancelled - Reference to variable that is returned status
            indicating if the user cancelled the import operation.

    Returns:
        NO_ERROR = Success.
        S_FALSE  = Not a doc file.
        STG_E_FILENOTFOUND
        STG_E_OUTOFMEMORY
        STG_E_ACCESSDENIED
        STG_E_INVALIDNAME
        STG_E_TOOMANYOPENFILES

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    LPCTSTR pszFilePath
    )
{
    HRESULT hResult     = NO_ERROR;
    BOOL bStreamFailure = FALSE; // FALSE = Storage failure.

    //
    // Display the filename in the progress dialog.
    //
    m_dlgProgress.SetFileName(pszFilePath);

    //
    // Validate and open the file.
    //
    if (S_OK != StgIsStorageFile(pszFilePath))
    {
        //
        // Not a doc file.  Assume it was created using drag/drop.
        // Map the file into memory and import from that.
        // Contents will be validated during the import process.
        //
        MappedFile file;
        hResult = file.Open(pszFilePath);
        if (SUCCEEDED(hResult))
        {
            //
            // This typecast from __int64 to ULONG is OK. Truncation
            // will not be a problem.  There will be no quota import
            // storages larger than 4GB.
            //
            Source src(file.Base(), (ULONG)file.Size());
            hResult = Import(src);
        }
    }
    else
    {
        IStorage *pStg = NULL;
        //
        // It's a doc file.  Assume it's one created using OnCmdExport().
        // Contents will be validated during the import process.
        //
        hResult = StgOpenStorage(pszFilePath,
                                 NULL,
                                 STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                 NULL, 0,
                                 &pStg);

        if (SUCCEEDED(hResult))
        {
            //
            // Open the import stream.
            //
            IStream *pIStream;
            hResult = pStg->OpenStream(DetailsView::DataObject::SZ_EXPORT_STREAM_NAME,
                                       NULL,
                                       STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       0,
                                       &pIStream);
            if (SUCCEEDED(hResult))
            {

                //
                // Import information contained in the stream.
                //
                Source src(pIStream);
                hResult = Import(src);
                pIStream->Release();
            }
            else
            {
                DBGERROR((TEXT("Import: Error 0x%08X opening stream \"%s\""), hResult, DataObject::SZ_EXPORT_STREAM_NAME));
                //
                // Reporting logic below needs to know if it was a stream or storage
                // failure.
                //
                bStreamFailure = TRUE;
            }
            pStg->Release();
        }
        else
        {
            DBGERROR((TEXT("Import: Error 0x%08X opening storage \"%s\""), hResult, pszFilePath));
        }
    }

    if (FAILED(hResult))
    {
        UINT iMsg = IDS_IMPORT_STREAM_READ_ERROR; // Generic message.

        switch(hResult)
        {
            case STG_E_FILENOTFOUND:
                //
                // Both OpenStream and StgOpenStorage can return
                // STG_E_FILENOTFOUND.  However, they have two completely
                // different meanings from the user's perspective.
                //
                iMsg = bStreamFailure ? IDS_IMPORT_STREAM_INVALID_STREAM :
                                        IDS_IMPORT_STREAM_FILENOTFOUND;
                break;

            case STG_E_ACCESSDENIED:
                iMsg = IDS_IMPORT_STREAM_NOACCESS;
                break;

            case E_OUTOFMEMORY:
            case STG_E_INSUFFICIENTMEMORY:
                iMsg = IDS_IMPORT_STREAM_OUTOFMEMORY;
                break;

            case STG_E_INVALIDNAME:
                iMsg = IDS_IMPORT_STREAM_INVALIDNAME;
                break;

            case STG_E_TOOMANYOPENFILES:
                iMsg = IDS_IMPORT_STREAM_TOOMANYFILES;
                break;

            default:
                break;
        }
        DiskQuotaMsgBox(GetTopmostWindow(),
                        iMsg,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [HDROP]

    Description: Imports settings from one or more doc files specified
        in a DROPFILES buffer.  This is used when someone drops an export
        file onto the listview.  The doc file names are extracted from
        the HDROP buffer then handed off to ImportUsersFromFile.

    Arguments:
        pIStream - Pointer to IStream containing DROPFILES info.

        bUserCancelled - Reference to variable that is returned status
            indicating if the user cancelled the import operation.


    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    HDROP hDrop
    )
{
    HRESULT hResult = NO_ERROR;
    TCHAR szFile[MAX_PATH];

    DBGASSERT((NULL != hDrop));

    //
    // Get the count of files in the HDROP buffer.
    //
    UINT cFiles = DragQueryFile((HDROP)hDrop, (UINT)-1, NULL, 0);
    if ((UINT)-1 != cFiles)
    {
        //
        // Import users from each file in the HDROP buffer.
        // Bail out if user cancels operation.
        //
        for (INT i = 0; i < (INT)cFiles && !m_bUserCancelled; i++)
        {
            DragQueryFile(hDrop, i, szFile, ARRAYSIZE(szFile));
            hResult = Import(szFile);
        }
    }
    else
    {
        DBGERROR((TEXT("DragQueryFile returned -1")));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [Source&]

    Description: Imports settings for one or more users from a Source object.
        All import functions eventually get their information into a Source
        object format and call this function.  It then separates out the
        individual user information and calls ImportOneUser() to do the
        actual import.

    Arguments:
        source - Reference to Source containing user import info.

    Returns: Number of users imported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    Source& source
    )
{
    ULONG cbRead;
    HRESULT hResult = E_FAIL;

    try
    {
        //
        // Read and validate the stream signature.
        // This signature consists of a GUID so that we can validate any
        // stream used for import of quota information.
        //
        GUID guidStreamSignature;
        if (S_OK != source.Read(&guidStreamSignature, sizeof(guidStreamSignature), &cbRead))
            throw CFileException(CFileException::read, TEXT(""), 0);

        if (guidStreamSignature == GUID_NtDiskQuotaStream)
        {
            //
            // Read and validate the stream version.
            // Currently there is only 1 version of stream generated so validation
            // is simple.  If we ever rev the stream format and bump the version
            // to 2, we should still be able to handle version 1 streams.  The
            // only reason to display an error is if we encounter a totally bogus
            // stream version number.
            //
            DWORD nVersion;
            if (S_OK != source.Read(&nVersion, sizeof(nVersion), &cbRead))
                throw CFileException(CFileException::read, TEXT(""), 0);

            if (1 == nVersion)
            {
                INT cRecords;
                //
                // Read the count of records in the stream.
                //
                if (S_OK != source.Read(&cRecords, sizeof(cRecords), &cbRead))
                    throw CFileException(CFileException::read, TEXT(""), 0);

                //
                // Set up the progress bar to represent this stream.
                //
                m_dlgProgress.ProgressBarInit(0, cRecords, 1);

                for (INT i = 0; !m_bUserCancelled && i < cRecords; i++)
                {
                    //
                    // Read each record from the stream.
                    // A record consists of a SID-Length value followed by a SID
                    // then followed by the user's quota amount used, threshold
                    // and limit values.  Abort loop if user cancels the
                    // operation.
                    //
                    DWORD cbSid;
                    LPBYTE pbSid;
                    if (S_OK != source.Read(&cbSid, sizeof(cbSid), &cbRead))
                        throw CFileException(CFileException::read, TEXT(""), 0);

                    pbSid = new BYTE[cbSid];
                    try
                    {
                        if (NULL != pbSid)
                        {
                            PDISKQUOTA_USER pIUser = NULL;
                            LONGLONG llQuotaThreshold;
                            LONGLONG llQuotaLimit;
                            //
                            // Read in the user's SID.
                            //
                            if (S_OK != source.Read(pbSid, cbSid, &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota amount used.
                            // This isn't used in the import process but it's in
                            // the stream.  Therefore we just dump it into the
                            // threshold buffer.  It will be overwritten.
                            //
                            if (S_OK != source.Read(&llQuotaThreshold, sizeof(llQuotaThreshold), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota threshold.
                            //
                            if (S_OK != source.Read(&llQuotaThreshold, sizeof(llQuotaThreshold), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // Read in the user's quota limit.
                            //
                            if (S_OK != source.Read(&llQuotaLimit, sizeof(llQuotaLimit), &cbRead))
                                throw CFileException(CFileException::read, TEXT(""), 0);

                            //
                            // We have one record of data for a user.
                            // Now import it.
                            //
                            hResult = Import(pbSid, llQuotaThreshold, llQuotaLimit);
                            delete[] pbSid;
                        }
                    }
                    catch(CFileException& fe)
                    {
                        DBGERROR((TEXT("Import: File exception caught while reading import data.")));
                        delete[] pbSid;
                        throw;
                    }
                    catch(CAllocException& ae)
                    {
                        DBGERROR((TEXT("Import: Alloc exception caught while reading import data.")));
                        delete[] pbSid;
                        throw;
                    }
                }
            }
            else
            {
                //
                // Invalid stream version.
                // Our code should always be able to handle any version
                // we produce.  This code branch should only handle BOGUS
                // version numbers.  In other words, a message like "Can't
                // understand this version" is not acceptable.
                //
                DBGERROR((TEXT("Import: Invalid stream version (%d)."), nVersion));
                DiskQuotaMsgBox(GetTopmostWindow(),
                                IDS_IMPORT_STREAM_INVALID_STREAM,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONERROR | MB_OK);
            }
        }
        else
        {
            //
            // Invalid stream signature.
            //
            DBGERROR((TEXT("Import: Invalid stream signature.")));
            DiskQuotaMsgBox(GetTopmostWindow(),
                            IDS_IMPORT_STREAM_INVALID_STREAM,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONERROR | MB_OK);
        }
    }
    catch(CFileException& fe)
    {
        DBGERROR((TEXT("Import: File exception caught while reading import data.")));

        DiskQuotaMsgBox(GetTopmostWindow(),
                        IDS_IMPORT_STREAM_READ_ERROR,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);

        hResult = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::Import [LPBYTE, LONGLONG, LONGLONG]

    Description: Imports a single user into the system given the user's SID
        and quota settings.  This is the single function where all import
        mechanisms end up.  It does the actual importing of the user.

    Arguments:
        pbSid - Address of buffer containing user's SID.

        llQuotaThreshold - User's quota warning threshold setting.

        llQuotaLimit - User's quota limit setting.

    Returns:
        -1 = User pressed "Cancel" in either the "Replace User" dialog or
            in the progress dialog.

         0 = Failed to import user.

         1 = User imported.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
DetailsView::Importer::Import(
    LPBYTE pbSid,
    LONGLONG llQuotaThreshold,
    LONGLONG llQuotaLimit
    )
{
    INT iResult     = 0;
    HRESULT hResult = NO_ERROR;
    PDISKQUOTA_USER pIUser = NULL;
    static BOOL bReplaceExistingUser = FALSE;

    DBGASSERT((NULL != pbSid));

    if (m_bPromptOnReplace)
    {
        //
        // We'll be prompting the user if a record needs replacement.
        // They'll make a choice through the UI.
        // Assume for now that we won't be replacing the record.
        //
        bReplaceExistingUser = FALSE;
    }

    //
    // Add user to volume's quota file.
    //
    hResult = m_DV.m_pQuotaControl->AddUserSid(pbSid,
                                               DISKQUOTA_USERNAME_RESOLVE_SYNC,
                                               &pIUser);
    if (SUCCEEDED(hResult))
    {
        //
        // Either the user was added or already exists.
        //
        BOOL bAddNewUser = (S_FALSE != hResult);

        if (!bAddNewUser)
        {
            //
            // User already exists in the quota file.  Find it's entry
            // in the listview.
            //
            DBGASSERT((NULL != pIUser));
            pIUser->Release();
            INT iItem = m_DV.FindUserBySid(pbSid, &pIUser);

            if (m_bPromptOnReplace)
            {
                TCHAR szLogonName[MAX_USERNAME]   = { TEXT('\0') };
                TCHAR szDisplayName[MAX_USERNAME] = { TEXT('\0') };

                if (-1 != iItem)
                {
                    //
                    // Listview item found.
                    // Get the account's name string so we can ask the user
                    // if they want to replace it's quota settings.
                    //
                    DBGASSERT((NULL != pIUser));
                    pIUser->GetName(NULL, 0,
                                    szLogonName,   ARRAYSIZE(szLogonName),
                                    szDisplayName, ARRAYSIZE(szDisplayName));

                }

                CString strTitle(g_hInstDll, IDS_TITLE_DISK_QUOTA);
                CString strMsg(g_hInstDll,
                               IDS_IMPORT_REPLACE_RECORD,
                               szDisplayName,
                               szLogonName);

                //
                // Ask the user if they want to replace the record's
                // quota settings.
                //
                YesNoToAllDialog ynToAllDlg(IDD_YNTOALL);
                INT_PTR iResponse = ynToAllDlg.CreateAndRun(g_hInstDll,
                                                            GetTopmostWindow(),
                                                            strTitle,
                                                            strMsg);
                //
                // If the "Apply to All" checkbox was selected, we set this flag
                // so that the dialog isn't displayed again until the caller resets
                // m_bPromptOnReplace to TRUE.
                //
                m_bPromptOnReplace = !ynToAllDlg.ApplyToAll();

                switch(iResponse)
                {
                    case IDYES:
                        bReplaceExistingUser = TRUE;
                        break;

                    case IDCANCEL:
                        m_bUserCancelled = TRUE;
                        break;

                    default:
                        break;
                }
            }
        }
        if (bAddNewUser || bReplaceExistingUser)
        {
            DBGASSERT((NULL != pIUser));

            //
            // Write the new quota values because...
            //
            // 1. Added a new user record and setting initial values or...
            // 2. Replacing settings for an existing user.
            //
            if (NULL != pIUser)
            {
                LONGLONG llQuotaThresholdUndo;
                LONGLONG llQuotaLimitUndo;

                if (!bAddNewUser && bReplaceExistingUser)
                {
                    //
                    // Save the current threshold and limit values for "undo".
                    // Only need information for undo if replacing an existing
                    // user's settings.  For performance, only call when we need
                    // the info.
                    //
                    pIUser->GetQuotaThreshold(&llQuotaThresholdUndo);
                    pIUser->GetQuotaLimit(&llQuotaLimitUndo);
                }

                //
                // Set the new threshold and limit values.
                //
                pIUser->SetQuotaThreshold(llQuotaThreshold, TRUE);
                pIUser->SetQuotaLimit(llQuotaLimit, TRUE);

                if (bAddNewUser)
                {
                    //
                    // Add the user to the listview and create an UNDO object for the operation.
                    //
                    m_DV.AddUser(pIUser);
                    pIUser->AddRef();
                    m_DV.m_pQuotaControl->AddRef();

                    autoptr<UndoAdd> ptrUndoAdd = new UndoAdd(pIUser, m_DV.m_pQuotaControl);
                    m_DV.m_pUndoList->Add(ptrUndoAdd);
                    ptrUndoAdd.disown();
                }
                if (!bAddNewUser && bReplaceExistingUser)
                {
                    //
                    // This will update the record to display any changed quota values.
                    // Create an UNDO object for the operation.
                    //
                    m_DV.OnUserNameChanged(pIUser);
                    pIUser->AddRef();

                    autoptr<UndoModify> ptrUndoModify = new UndoModify(pIUser, llQuotaThresholdUndo, llQuotaLimitUndo);
                    m_DV.m_pUndoList->Add(ptrUndoModify);
                    ptrUndoModify.disown();
                }
            }
        }
    }

    if (!m_bUserCancelled)
        m_bUserCancelled = m_dlgProgress.UserCancelled();

    if (SUCCEEDED(hResult))
    {
        m_cImported++;
        m_dlgProgress.ProgressBarAdvance();
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DetailsView::Importer::GetTopmostWindow

    Description: Returns the HWND of the topmost window in the importer UI.
        If the UI's progress dialog is visible, the dialog's HWND is returned.
        Otherwise, the value of m_hwndParent is returned.
        The Importer uses this function to identify what window should be parent
        to any error message boxes.

    Arguments: None.

    Returns: HWND to use for parent of any messages boxes created by the
        Importer.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/20/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HWND
DetailsView::Importer::GetTopmostWindow(
    VOID
    )
{
   return m_dlgProgress.m_hWnd ? m_dlgProgress.m_hWnd : m_hwndParent;
}



///////////////////////////////////////////////////////////////////////////////
// The following StreamSource functions implement a layer of abstraction
// between the import function and the source of the import data.  This allows
// me to centralize the actual import processing in a single function
// without consideration of input source.
// There are several Import() overloads but they eventually all call down
// to Import(Source&).  These functions are very simple so I'm not going
// go bother documenting each.  I think it's pretty obvious what they do.
// Do note the use of the virtual constructor technique allowing the user
// to deal only with Source objects and not AnySource, StreamSource or
// MemorySource objects.  This may be unfamiliar to some.
//
// [brianau 7/25/97]
//
///////////////////////////////////////////////////////////////////////////////
//
// Source ---------------------------------------------------------------------
//
DetailsView::Importer::Source::Source(
    IStream *pStm
    ) : m_pTheSource(NULL)
{
    //
    // Create a stream source type object.
    //
    m_pTheSource = new StreamSource(pStm);
}


DetailsView::Importer::Source::Source(
    LPBYTE pb,
    ULONG cbMax
    ) : m_pTheSource(NULL)
{
    //
    // Create a memory source type object.
    //
    m_pTheSource = new MemorySource(pb, cbMax);
}

DetailsView::Importer::Source::~Source(
    VOID
    )
{
    //
    // Note:  Destructors must be virtual for this to work.
    //
    delete m_pTheSource;
}


HRESULT
DetailsView::Importer::Source::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_OUTOFMEMORY;
    if (NULL != m_pTheSource)
    {
        //
        // Delegate the read operation to the properly-typed
        // subobject.
        //
        hr = m_pTheSource->Read(pvOut, cb, pcbRead);
    }
    return hr;
}


//
// StreamSource ---------------------------------------------------------------
//
DetailsView::Importer::StreamSource::StreamSource(
    IStream *pStm
    ) : m_pStm(pStm)
{
    //
    // AddRef the stream pointer.
    //
    if (NULL != m_pStm)
        m_pStm->AddRef();
}

DetailsView::Importer::StreamSource::~StreamSource(
    VOID
    )
{
    //
    // Release the stream pointer.
    //
    if (NULL != m_pStm)
        m_pStm->Release();
}

HRESULT
DetailsView::Importer::StreamSource::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;
    if (NULL != m_pStm)
    {
        //
        // Read data from the stream.
        //
        hr = m_pStm->Read(pvOut, cb, pcbRead);
    }
    return hr;
}


//
// MemorySource ---------------------------------------------------------------
//
DetailsView::Importer::MemorySource::MemorySource(
    LPBYTE pb,
    ULONG cbMax
    ) : m_pb(pb),
        m_cbMax(cbMax)
{

}


HRESULT
DetailsView::Importer::MemorySource::Read(
    LPVOID pvOut,
    ULONG cb,
    ULONG *pcbRead
    )
{
    HRESULT hr = E_FAIL;

    if (m_cbMax >= cb)
    {
        //
        // Read data from the memory block.
        //
        CopyMemory(pvOut, m_pb, cb);
        m_pb    += cb;
        m_cbMax -= cb;
        if (NULL != pcbRead)
        {
            *pcbRead = cb;
        }
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\extinit.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: extinit.cpp

    Description: Implements IShellExtInit for disk quota shell extensions.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "extinit.h"
#include "prshtext.h"
#include "volprop.h"
#include "guidsp.h"

///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or
        IShellExtInit interface.  Only IID_IUnknown and
        IID_IShellExtInit are recognized.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Disabled MMC snapin code.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ShellExtInit::QueryInterface(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (IID_IUnknown == riid ||
            IID_IShellExtInit == riid)
        {
            *ppvOut = this;
            ((LPUNKNOWN)*ppvOut)->AddRef();
            hResult = NOERROR;
        }
        else if (IID_IShellPropSheetExt == riid)
        {
            //
            // This can throw OutOfMemory.
            //
            hResult = Create_IShellPropSheetExt(riid, ppvOut);
        }
#ifdef POLICY_MMC_SNAPIN
        else if (IID_ISnapInPropSheetExt == riid)
        {
            hResult = Create_ISnapInPropSheetExt(riid, ppvOut);
        }
#endif // POLICY_MMC_SNAPIN
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
ShellExtInit::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("ShellExtInit::AddRef, 0x%08X  %d -> %d\n"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
ShellExtInit::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("ShellExtInit::Release, 0x%08X  %d -> %d\n"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Initialize

    Description: Called by the shell to initialize the shell extension.

    Arguments:
        pidlFolder - Pointer to IDL of selected folder.  This NULL for
            property sheet and context menu extensions.

        lpDataObj - Pointer to data object containing list of selected objects.

        hkeyProgID - Registry key for the file object or folder type.

    Returns:
        S_OK    - Success.
        E_FAIL  - Can't initialize extension.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/28/98    Added mounted-volume support.                        BrianAu
                Includes introduction of CVolumeID object.
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
ShellExtInit::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpDataObj,
    HKEY hkeyProgID)
{
    HRESULT hResult = E_FAIL;
    if (NULL != lpDataObj)
    {
        //
        // First assume it's a normal volume ID (i.e. "C:\").
        // The DataObject will provide CF_HDROP if it is.
        //
        FORMATETC fe = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM medium;
        bool bMountedVol = false;

        hResult = lpDataObj->GetData(&fe, &medium);
        if (FAILED(hResult))
        {
            //
            // Isn't a normal volume name. Maybe it's a mounted volume.
            // Mounted volume names come in on a different clipboard format
            // so we can treat them differently from normal volume
            // names like "C:\".  A mounted volume name will be the path
            // to the folder hosting the mounted volume.
            // For mounted volumes, the DataObject provides CF "MountedVolume".
            //
            fe.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            hResult     = lpDataObj->GetData(&fe, &medium);
            bMountedVol = SUCCEEDED(hResult);
        }

        if (SUCCEEDED(hResult))
        {
            if (1 == DragQueryFile((HDROP)medium.hGlobal, (DWORD)-1, NULL, 0))
            {
                //
                // Retrieve volume ID string passed in from the shell.
                //
                CString strForParsing; // Used for calling Win32 functions.
                CString strForDisplay; // Used for UI display.
                CString strFSPath;     // Used when an FS path is required.
                DragQueryFile((HDROP)medium.hGlobal,
                              0,
                              strForParsing.GetBuffer(MAX_PATH),
                              MAX_PATH);
                strForParsing.ReleaseBuffer();

                if (!bMountedVol)
                {
                    //
                    // If it's a normal volume name like "C:\", just
                    // use that as the display name and FS Path also.
                    //
                    strFSPath = strForDisplay = strForParsing;
                }
                else
                {
                    //
                    // It's a mounted volume so we need to come up with something
                    // better than "\\?\Volume{ <guid> }\" to display.
                    //
                    // The UI spec says the name shall be like this:
                    //
                    //     <label> (<mounted path>)
                    //
                    TCHAR szMountPtGUID[MAX_PATH] = { TEXT('\0') };
                    GetVolumeNameForVolumeMountPoint(strForParsing,
                                                     szMountPtGUID,
                                                     ARRAYSIZE(szMountPtGUID));

                    TCHAR szLabel[MAX_VOL_LABEL]  = { TEXT('\0') };
                    GetVolumeInformation(szMountPtGUID,
                                         szLabel,
                                         ARRAYSIZE(szLabel),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         0);
                    //
                    // Format display name as:
                    //
                    // "VOL_LABEL (C:\MountDir)" or
                    // "(C:\MountDir)" if no volume label is available.
                    //
                    // First remove any trailing backslash from the original parsing
                    // string.  It was needed for the call to get the volume mount
                    // point but we don't want to display it in the UI.
                    //
                    if (!strForParsing.IsEmpty())
                    {
                        int iLastBS = strForParsing.Last(TEXT('\\'));
                        if (iLastBS == strForParsing.Length() - 1)
                            strForParsing = strForParsing.SubString(0, iLastBS);
                    }
                    strForDisplay.Format(g_hInstDll,
                                         IDS_FMT_MOUNTEDVOL_DISPLAYNAME,
                                         szLabel,
                                         strForParsing.Cstr());
                    //
                    // Remember the "C:\MountDir" form as the "FSPath".
                    //
                    strFSPath = strForParsing;
                    //
                    // From here on out, the mounted volume GUID string
                    // is used for parsing.
                    //
                    strForParsing = szMountPtGUID;
                }

                //
                // Store the parsing and display name strings in our CVolumeID
                // object for convenient packaging.  This way we can pass around
                // one object and the various parts of the UI can use either the
                // parsable or displayable name as they see fit.  Since the
                // CString objects are reference-counted, all the copying doesn't
                // result in duplication of the actual string contents.
                //
                m_idVolume.SetNames(strForParsing, strForDisplay, strFSPath);

                hResult = S_OK;
            }
            ReleaseStgMedium(&medium);
        }
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: ShellExtInit::Create_IShellPropSheetExt

    Description: Creates a shell property sheet extension object and returns
        a pointer to it's IShellPropSheetExt interface.

    Arguments:
        riid - Reference to interface IID.

        ppvOut - Address of interface pointer variable to receive interface
            pointer.

    Returns:
        NO_ERROR        - Success.
        E_FAIL          - Extension initialized with something other
                          than the name of a volume or directory.
                          - OR -
                          The volume or directory doesn't support quotas.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/16/96    Initial creation.                                    BrianAu
    10/07/97    Removed "access denied" and "invalid FS Ver" msgs    BrianAu
                from prop sheet page.  Only display page if
                volume supports quotas and quota control object
                can be initialized.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
ShellExtInit::Create_IShellPropSheetExt(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_FAIL;
    DWORD dwFileSysFlags = 0;
    TCHAR szFileSysName[MAX_PATH];

    if (GetVolumeInformation(m_idVolume.ForParsing(), // Volume id str [in]
                             NULL, 0,           // Don't want volume name
                             NULL,              // Don't want serial no.
                             NULL,              // Don't want max comp length.
                             &dwFileSysFlags,   // File system flags.
                             szFileSysName,
                             ARRAYSIZE(szFileSysName)))
    {
        //
        // Only continue if the volume supports quotas.
        //
        if (0 != (dwFileSysFlags & FILE_VOLUME_QUOTAS))
        {
            DiskQuotaPropSheetExt *pSheetExt = NULL;
            try
            {
                pSheetExt = new VolumePropPage;

                //
                // This can throw OutOfMemory.
                //
                hResult = pSheetExt->Initialize(m_idVolume,
                                                IDD_PROPPAGE_VOLQUOTA,
                                                VolumePropPage::DlgProc);
                if (SUCCEEDED(hResult))
                {
                    hResult = pSheetExt->QueryInterface(riid, ppvOut);
                }
            }
            catch(CAllocException& e)
            {
                hResult = E_OUTOFMEMORY;
            }
            if (FAILED(hResult))
            {
                delete pSheetExt;
                *ppvOut = NULL;
            }
        }
    }

    return hResult;
}

#ifdef POLICY_MMC_SNAPIN

HRESULT
ShellExtInit::Create_ISnapInPropSheetExt(
    REFIID riid,
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_FAIL;
    DiskQuotaPropSheetExt *pSheetExt = NULL;
    try
    {
        pSheetExt = new SnapInVolPropPage;

        hResult = pSheetExt->Initialize(NULL,
                                        IDD_PROPPAGE_POLICY,
                                        VolumePropPage::DlgProc);
        if (SUCCEEDED(hResult))
        {
            hResult = pSheetExt->QueryInterface(riid, ppvOut);
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }
    if (FAILED(hResult))
    {
        delete pSheetExt;
        *ppvOut = NULL;
    }
    return hResult;
}

#endif // POLICY_MMC_SNAPIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\factory.h ===
#ifndef _INC_DSKQUOTA_FACTORY_H
#define _INC_DSKQUOTA_FACTORY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.h

    Description: Contains declaration for the class factory object.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    02/04/98    Added creation of IComponent.                        BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

class DiskQuotaUIClassFactory : public IClassFactory
{
    public:
        DiskQuotaUIClassFactory(void)
            : m_cRef(0) { }

        //
        // IUnknown methods
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IClassFactory methods
        //
        STDMETHODIMP 
        CreateInstance(
            LPUNKNOWN pUnkOuter, 
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP 
        LockServer(
            BOOL fLock);

    private:
        LONG m_cRef;

        //
        // Prevent copying.
        //
        DiskQuotaUIClassFactory(const DiskQuotaUIClassFactory& rhs);
        DiskQuotaUIClassFactory& operator = (const DiskQuotaUIClassFactory& rhs);
};

//
// Since dskquoui.dll can offer up two somewhat-related objects (a shell extension
// and an MMC snapin extension), we create this intermediary class in case someone
// calls IClassFactory::CreateInstance asking for IUnknown (MMC does this).  When
// this happens, we don't know what object the client wants.  The caller then can 
// query this proxy object for a specific interface and the proxy generates the 
// appropriate object.
//
class InstanceProxy : public IUnknown
{
    public:
        InstanceProxy(void)
            : m_cRef(0) { }

        ~InstanceProxy(void) { }
        //
        // IUnknown methods
        //
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(VOID);
        STDMETHODIMP_(ULONG) Release(VOID);

    private:
        LONG m_cRef;
};




#endif // _INC_DSKQUOTA_FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\format.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: format.cpp

    Description: Implementation for class EnumFORMATETC.
        Moved from original location in dataobj.cpp (deleted from project).


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "format.h"


EnumFORMATETC::EnumFORMATETC(
    UINT cFormats, 
    LPFORMATETC prgFormats
    ) : m_cRef(0),
        m_cFormats(0),
        m_iCurrent(0),
        m_prgFormats(NULL)
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::EnumFORMATETC")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    m_prgFormats = new FORMATETC[m_cFormats = cFormats];

    for (UINT i = 0; i < m_cFormats; i++)
    {
        m_prgFormats[i] = prgFormats[i];
    }
}


EnumFORMATETC::EnumFORMATETC(
    const EnumFORMATETC& ef
    ) : m_cRef(0),
        m_cFormats(ef.m_cFormats),
        m_iCurrent(0),
        m_prgFormats(NULL)
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::EnumFORMATETC (Copy)")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    m_prgFormats = new FORMATETC[m_cFormats];

    for (UINT i = 0; i < m_cFormats; i++)
    {
        m_prgFormats[i] = ef.m_prgFormats[i];
    }
}



EnumFORMATETC::~EnumFORMATETC(
    VOID
    )
{
    DBGTRACE((DM_DRAGDROP, DL_HIGH, TEXT("EnumFORMATETC::~EnumFORMATETC")));
    DBGPRINT((DM_DRAGDROP, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    if (NULL != m_prgFormats)
        delete[] m_prgFormats;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown or 
        IEnumFORMATETC interface.  Only IID_IUnknown and 
        IID_IEnumFORMATETC are recognized.  The object referenced by the 
        returned interface pointer is uninitialized.  The recipient of the 
        pointer must call Initialize() before the object is usable.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
EnumFORMATETC::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IEnumFORMATETC == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
EnumFORMATETC::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("EnumFORMATETC::AddRef, 0x%08X  %d -> %d\n"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: EnumFORMATETC::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/25/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
EnumFORMATETC::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("EnumFORMATETC::Release, 0x%08X  %d -> %d\n"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


STDMETHODIMP
EnumFORMATETC::Next(
    DWORD cFormats,
    LPFORMATETC pFormats,
    LPDWORD pcReturned
    )
{
    HRESULT hResult = S_OK;

    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Next %d"), cFormats));
    DWORD iFormats = 0;
    if (NULL == pFormats)
        return E_INVALIDARG;

    while(cFormats-- > 0)
    {
        if (m_iCurrent < m_cFormats)
        {
            *(pFormats + iFormats++) = m_prgFormats[m_iCurrent++];
        }
        else
        {
            hResult = S_FALSE;
            break;
        }
    }

    if (NULL != pcReturned)
        *pcReturned = iFormats;

    return hResult;
}


STDMETHODIMP
EnumFORMATETC::Skip(
    DWORD cFormats
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Skip %d"), cFormats));
    while((cFormats-- > 0) && (m_iCurrent < m_cFormats))
        m_iCurrent++;

    return cFormats == 0 ? S_OK : S_FALSE;
}


STDMETHODIMP 
EnumFORMATETC::Reset(
    VOID
    )
{
    DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Reset")));
    m_iCurrent = 0;
    return S_OK;
}


STDMETHODIMP 
EnumFORMATETC::Clone(
    IEnumFORMATETC **ppvOut
    )
{
    HRESULT hResult = NO_ERROR;
    try
    {
        EnumFORMATETC *pNew = new EnumFORMATETC(*this);

        DBGPRINT((DM_DRAGDROP, DL_MID, TEXT("EnumFORMATETC::Clone")));
        hResult = pNew->QueryInterface(IID_IEnumFORMATETC, (LPVOID *)ppvOut);
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: factory.cpp

    Description: Contains the member function definitions for class
        DiskQuotaUIClassFactory.  The class factory object generates
        new instances of DiskQuotaControl objects.  The object implements
        IClassFactory.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
    02/04/98    Added creation of IComponent.                        BrianAu
    06/25/98    Disabled MMC snapin code.                            BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "factory.h"
#include "extinit.h"
#include "snapin.h"
#include "resource.h"
#include "guidsp.h"
//
// Verify that build is UNICODE.
//
#if !defined(UNICODE)
#   error This module must be compiled UNICODE.
#endif


extern LONG g_cLockThisDll;  // Supports LockServer().


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::QueryInterface

    Description: Retrieves a pointer to the IUnknown or IClassFactory 
        interface.  Recoginizes the IID_IUnknown and IID_IClassFactory
        interface IDs.

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added IShellPropSheetExt                             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::QueryInterface")));
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid || IID_IClassFactory == riid)
    {
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUIClassFactory::AddRef(
   VOID
   )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::AddRef, 0x%08X  %d -> %d"),
                     this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaUIClassFactory::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::Release, 0x%08X  %d -> %d"),
                     this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::CreateInstance

    Description: Creates a new instance of a DiskQuotaControl object, returning
        a pointer to its IDiskQuotaControl interface.

    Arguments:
        pUnkOuter - Pointer to outer object's IUnknown interface for IUnknown
            delegation in support of aggregation.  Aggregation is not supported
            by IDiskQuotaControl.

        riid - Reference to interface ID being requested.

        ppvOut - Address of interface pointer variable to accept interface
            pointer.

    Returns:
        NO_ERROR              - Success.
        CLASS_E_NOAGGREGATION - Aggregation was requested but is not supported.
        E_OUTOFMEMORY         - Insufficient memory to create new object.
        E_NOINTERFACE         - Requested interface not supported.
        E_INVALIDARG          - ppvOut arg was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
    08/15/96    Added shell extension support.                       BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::CreateInstance(
    LPUNKNOWN pUnkOuter, 
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::CreateInstance")));
    HRESULT hResult = NO_ERROR;

    TCHAR szGUID[MAX_PATH];
    StringFromGUID2(riid, szGUID, ARRAYSIZE(szGUID));
    DBGPRINT((DM_COM, DL_HIGH, TEXT("CreateInstance: %s"), szGUID));

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    try
    {
        if (NULL != pUnkOuter && IID_IUnknown != riid)
        {
            hResult = CLASS_E_NOAGGREGATION;
        }
        else 
        {
            InstanceProxy *pip = new InstanceProxy;
            hResult = pip->QueryInterface(riid, ppvOut);
            if (IID_IUnknown != riid || FAILED(hResult))
            {
                //
                // Either caller requested something other than IUnknown
                // or QI failed.  We can delete the instance proxy.
                // It's only necessary to keep around if the caller asked
                // for IUnknown.
                //
                delete pip;
            }
        }
    }
    catch(CAllocException& e)
    {
        hResult = E_OUTOFMEMORY;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaUIClassFactory::LockServer

    Description: Places/removes a lock on the DLL server.  See OLE 2
        documentation of IClassFactory for details.
        
    Arguments:
        fLock - TRUE = Increment lock count, FALSE = Decrement lock count.

    Returns:
        S_OK    - Success.
        S_FALSE - Lock count is already 0.  Can't be decremented.
        

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/22/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaUIClassFactory::LockServer(
    BOOL fLock
    )
{
    DBGTRACE((DM_COM, DL_HIGH, TEXT("DiskQuotaUIClassFactory::LockServer")));
    HRESULT hResult = S_OK;

    if (fLock)
    {
        //
        // Increment the lock count.
        //
        InterlockedIncrement(&g_cLockThisDll);
    }
    else
    {
        //
        // Decrement only if lock count is > 0.
        // Otherwise, it's an error.
        //
        LONG lLock = g_cLockThisDll - 1;
        if (0 <= lLock)
        {
            InterlockedDecrement(&g_cLockThisDll);
        }
        else
            hResult = S_FALSE;  // Lock count already at 0.
    }

    return hResult;
}



HRESULT
InstanceProxy::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    DBGTRACE((DM_COM, DL_HIGH, TEXT("InstanceProxy::QueryInterface")));
    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;
    if (IID_IUnknown == riid)
    {
        DBGPRINT((DM_COM, DL_MID, TEXT("Requested IID_IUnknown")));
        *ppvOut = this;
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

#ifdef POLICY_MMC_SNAPIN
    else if (IID_IComponentData == riid)
    {
        DBGPRINT((DM_COM, DL_MID, TEXT("Requested IID_IComponentData")));
        CSnapInCompData *psicd = new CSnapInCompData(g_hInstDll,
                                                     CString(g_hInstDll, IDS_SNAPIN_NAME),
                                                     CLSID_DiskQuotaUI);
        hResult = psicd->QueryInterface(riid, ppvOut);
        if (FAILED(hResult))
            delete psicd;
    }            
#endif // POLICY_MMC_SNAPIN

    else if (IID_IShellExtInit == riid)
    {
        DBGPRINT((DM_COM, DL_MID, TEXT("Requested IID_IShellExtInit")));
        ShellExtInit *pExtInit = new ShellExtInit;
        hResult = pExtInit->QueryInterface(IID_IShellExtInit, ppvOut);
        if (FAILED(hResult))
            delete pExtInit;
    }

    return hResult;
}

ULONG
InstanceProxy::AddRef(
   VOID
   )
{
    DBGTRACE((DM_COM, DL_MID, TEXT("InstanceProxy::AddRef")));
    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


ULONG
InstanceProxy::Release(
    VOID
    )
{
    DBGTRACE((DM_COM, DL_MID, TEXT("InstanceProxy::Release")));
    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\format.h ===
#ifndef _INC_DSKQUOTA_FORMAT_H
#define _INC_DSKQUOTA_FORMAT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: format.h

    Description: Declaration for class EnumFORMATETC.
        Moved from original location in dataobj.h (deleted from project).


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

class EnumFORMATETC : public IEnumFORMATETC
{
    private:
        LONG        m_cRef;
        UINT        m_cFormats;
        UINT        m_iCurrent;
        LPFORMATETC m_prgFormats;

        //
        // Prevent assignment.
        //
        void operator = (const EnumFORMATETC&);

    public:
        EnumFORMATETC(UINT cFormats, LPFORMATETC prgFormats);
        EnumFORMATETC(const EnumFORMATETC& ef);
        ~EnumFORMATETC(VOID);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID riid, 
            LPVOID *ppvOut);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IEnumFORMATETC methods.
        //
        STDMETHODIMP 
        Next(
            DWORD, 
            LPFORMATETC, 
            LPDWORD);

        STDMETHODIMP 
        Skip(
            DWORD);

        STDMETHODIMP 
        Reset(
            VOID);

        STDMETHODIMP 
        Clone(
            IEnumFORMATETC **);
};
        
#endif // _INC_DSKQUOTA_FORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\ownerdlg.h ===
#ifndef _INC_DSKQUOTA_OWNERDLG_H
#define _INC_DSKQUOTA_OWNERDLG_H

#ifndef _INC_DSKQUOTA_PRIVATE_H
#   include "private.h"
#endif

#ifndef _INC_DSKQUOTA_OWNERLST_H
#   include "ownerlst.h"
#endif

class CFileOwnerDialog
{
    public:
        CFileOwnerDialog(HINSTANCE hInstance,
                         HWND hwndParent,
                         LPCTSTR pszVolumeRoot,
                         const CArray<IDiskQuotaUser *>& rgpOwners);

        ~CFileOwnerDialog(void);

        INT_PTR Run(void);

    private:
        //
        // Code in ownerdlg.cpp relies on the values and order of these
        // enumerated constants.
        //
        enum { iLVSUBITEM_FILE = 0,
               iLVSUBITEM_FOLDER,
               iLVSUBITEM_OWNER
             };

        HINSTANCE  m_hInstance;
        HWND       m_hwndParent;
        HWND       m_hwndDlg;
        HWND       m_hwndLV;
        HWND       m_hwndOwnerCombo;
        HWND       m_hwndEditMoveTo;
        int        m_iLastColSorted;
        CPath      m_strVolumeRoot;
        const CArray<IDiskQuotaUser *>& m_rgpOwners; // Ref to existing list.
        COwnerList m_OwnerList;
        bool       m_bSortAscending;
        bool       m_bAbort;
        HANDLE     m_hOwnerListThread;

        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnInitDialog(HWND hwnd);
        INT_PTR OnDestroy(HWND hwnd);
        INT_PTR OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSetCursor(HWND hwnd);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        void OnLVN_GetDispInfo(LV_DISPINFO *plvdi);
        void OnLVN_ColumnClick(NM_LISTVIEW *pnmlv);
        void OnLVN_ItemChanged(NM_LISTVIEW *pnmlv);
        void OnLVN_KeyDown(NMLVKEYDOWN *plvkd);
        void InitializeList(const COwnerList& fol, HWND hwndList);
        void FillListView(const COwnerList& fol, HWND hwndList, int iOwner = -1);
        void InitializeOwnerCombo(const COwnerList& fol, HWND hwndCombo);
        void CreateListColumns(HWND hwndList, bool bShowOwner = true);
        bool IsSameVolume(LPCTSTR pszRoot1, LPCTSTR pszRoot2);
        bool BrowseForFolder(HWND hwndParent, CString *pstrFolder);
        bool ShouldEnableControl(UINT idCtl);
        void RemoveListViewItems(HWND hwndLV, const CArray<COwnerListItemHandle>& rgItemHandles);
        void BuildListOfSelectedFiles(HWND hwndLV, DblNulTermList *pList, CArray<COwnerListItemHandle> *prgItemHandles);
        void MoveSelectedFiles(HWND hwndLV, LPCTSTR pszDest);
        void DeleteSelectedFiles(HWND hwndLV);
        void FocusOnSomethingInListview(HWND hwndLV);
        void OnOwnerListComplete(void);

        int FindItemFromHandle(HWND hwndLV, const COwnerListItemHandle& handle);
        HRESULT TakeOwnershipOfSelectedFiles(HWND hwndLV);
        HRESULT GetOwnershipSid(array_autoptr<BYTE> *ptrSid);
        DWORD GetAllowedActions(HWND hwndLV);
        static int CALLBACK CompareLVItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
        static int CALLBACK BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
        static DWORD OwnerListThreadProc(LPVOID pvParam);

        HRESULT
        BuildFileOwnerList(
            LPCTSTR pszVolumeRoot,
            const CArray<IDiskQuotaUser *>& rgpOwners,
            COwnerList *pOwnerList);

        HRESULT
        AddFilesToOwnerList(
            LPCTSTR pszVolumeRoot,
            HANDLE hVolumeRoot,
            IDiskQuotaUser *pOwner,
            COwnerList *pOwnerList);

        NTSTATUS
        OpenNtObject (
            LPCWSTR pszFile,
            HANDLE RelatedObject,
            ULONG CreateOptions,
            ULONG DesiredAccess,
            ULONG ShareAccess,
            ULONG CreateDisposition,
            HANDLE *ph);

};



#endif // _INC_DSKQUOTA_OWNERDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\pch.h ===
#ifndef _INC_DSKQUOTA_PCH_H
#define _INC_DSKQUOTA_PCH_H
///////////////////////////////////////////////////////////////////////////////
/*  File: pch.h

    Description: Precompiled header file for dskquota project.
        Includes all headers that are compiled into the pre-compiled header.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/06/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "private.h"
#include "dynarray.h"
#include "..\common\resource.h"

#endif // _INC_DSKQUOTA_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\ownerlst.h ===
#ifndef _INC_DSKQUOTA_OWNERLST_H
#define _INC_DSKQUOTA_OWNERLST_H

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

#ifndef _INC_DSKQUOTA_CARRAY_H
#   include "carray.h"
#endif

#ifndef _INC_DSKQUOTA_H
#   include <dskquota.h>
#endif

//-----------------------------------------------------------------------------
// The following classes are used in managing the list of files owned by
// one or more users selected for deletion from within the details view.
//
//  COwnerList - A list of "owner" objects.  Each representing one of the
//      account selected for deletion from the details view.
//
//  COwnerListEntry - A single entry in the COwnerList container.  Each
//      entry contains a pointer to the IDiskQuotaUser inteface of the
//      file owner and an array of CStrings containing the names of the
//      files owned by that user.  A blank filename is considered "deleted".
//
//  COwnerListFile - A simple derivation from CPath that adds a 'directory'
//      boolean member.  This allows us to easily handle the differences 
//      between files and folders in the UI.  For all intents and purposes,
//      instances of this class can be treated as a simple CPath object.
//
//  COwnerListItemHandle - This is a simple class used to hide the encoding
//      of the owner index and file index in a listview LPARAM value.  The
//      owner index is the index of the LV item's owner in the COwnerList
//      container.  The file index is the index of the item's filename in the
//      owner's COwnerListEntry in the COwnerList container. Perfectly clear,
//      right?  Each listview item's LPARAM contains enough information
//      (iOwner and iFile) to locate the owner and file information in the
//      COwnerList container.  This encoding was done for efficiency reasons.
//      The encoding is currently 10 bits for iOwner (max of 1024) and 22
//      bits for iFile (max of 4 meg).  These values can be adjusted if
//      the balance isn't quite right.
//
//

class COwnerListFile : public CPath
{
    public:
        COwnerListFile(void)
            : m_bDirectory(false) { }

        COwnerListFile(LPCTSTR pszFile, bool bDirectory)
            : CPath(pszFile),
              m_bDirectory(bDirectory) { }

        bool IsDirectory(void) const
            { return m_bDirectory; }

    private:
        bool m_bDirectory;
};

        
class COwnerListEntry
{
    public:
        explicit COwnerListEntry(IDiskQuotaUser *pOwner);
        ~COwnerListEntry(void)
            { if (m_pOwner) m_pOwner->Release(); }

        IDiskQuotaUser* GetOwner(void) const
            { m_pOwner->AddRef(); return m_pOwner; }

        void GetOwnerName(CString *pstrOwner) const
            { *pstrOwner = m_strOwnerName; }

        int AddFile(LPCTSTR pszFile, bool bDirectory);

        void MarkFileDeleted(int iFile)
            { m_rgFiles[iFile].Empty(); }

        bool IsFileDeleted(int iFile) const
            { return !!m_rgFiles[iFile].IsEmpty(); }

        bool IsFileDirectory(int iFile) const
            { return m_rgFiles[iFile].IsDirectory(); }

        void GetFileName(int iFile, CPath *pstrFile) const
            { m_rgFiles[iFile].GetFileSpec(pstrFile); }

        void GetFolderName(int iFile, CPath *pstrFolder) const
            { m_rgFiles[iFile].GetPath(pstrFolder); }

        void GetFileFullPath(int iFile, CPath *pstrFullPath) const
            { *pstrFullPath = m_rgFiles[iFile]; }

        int FileCount(bool bIncludeDeleted = false);

#if DBG
        void Dump(void) const;
#endif

    private:
        IDiskQuotaUser        *m_pOwner;       // Ptr to owner object.
        CString                m_strOwnerName; // Owner's name for display.
        CArray<COwnerListFile> m_rgFiles;      // Filenames for display.

        //
        // Prevent copy.  Array makes it too expensive.
        //
        COwnerListEntry(const COwnerListEntry& rhs);
        COwnerListEntry& operator = (const COwnerListEntry& rhs);
};


class COwnerList
{
    public:
        COwnerList(void) { }
        ~COwnerList(void);

        int AddOwner(IDiskQuotaUser *pOwner);

        IDiskQuotaUser *GetOwner(int iOwner) const;

        void GetOwnerName(int iOwner, CString *pstrOwner) const
            { m_rgpOwners[iOwner]->GetOwnerName(pstrOwner); }

        int AddFile(int iOwner, LPCTSTR pszFile, bool bDirectory)
            { return m_rgpOwners[iOwner]->AddFile(pszFile, bDirectory); }

        void MarkFileDeleted(int iOwner, int iFile)
            { m_rgpOwners[iOwner]->MarkFileDeleted(iFile); }

        bool IsFileDeleted(int iOwner, int iFile) const
            { return m_rgpOwners[iOwner]->IsFileDeleted(iFile); }

        bool IsFileDirectory(int iOwner, int iFile) const
            { return m_rgpOwners[iOwner]->IsFileDirectory(iFile); }

        void GetFileName(int iOwner, int iFile, CPath *pstrFile) const
            { m_rgpOwners[iOwner]->GetFileName(iFile, pstrFile); }

        void GetFolderName(int iOwner, int iFile, CPath *pstrFolder) const
            { m_rgpOwners[iOwner]->GetFolderName(iFile, pstrFolder); }

        void GetFileFullPath(int iOwner, int iFile, CPath *pstrFullPath) const
            { m_rgpOwners[iOwner]->GetFileFullPath(iFile, pstrFullPath); }

        void Clear(void);

        int FileCount(int iOwner = -1, bool bIncludeDeleted = false) const;

        int OwnerCount(void) const
            { return m_rgpOwners.Count(); }

#if DBG
        void Dump(void) const;
#endif

    private:
        CArray<COwnerListEntry *> m_rgpOwners;

        //
        // Prevent copy.
        //
        COwnerList(const COwnerList& rhs);
        COwnerList& operator = (const COwnerList& rhs);
};



class COwnerListItemHandle
{
    public:
        explicit COwnerListItemHandle(int iOwner = -1, int iFile = -1)
            : m_handle((iOwner & MASK) | ((iFile << SHIFT) & ~MASK)) { }

        COwnerListItemHandle(LPARAM lParam)
            : m_handle(lParam) { }

        operator LPARAM() const
            { return m_handle; }

        int OwnerIndex(void) const
            { return int(m_handle & MASK); }

        int FileIndex(void) const
            { return int((m_handle >> SHIFT) & (~MASK >> SHIFT)); }

    private:
        LPARAM m_handle;

        enum { MASK = 0x3FF, SHIFT = 10 };
};



#endif // _INC_DSKQUOTA_OWNERLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\ownerlst.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ownerlst.h"


COwnerListEntry::COwnerListEntry(
    IDiskQuotaUser *pOwner
    ) : m_pOwner(pOwner)
{ 
    if (m_pOwner) 
    {
        TCHAR szDisplayName[MAX_PATH] = { TEXT('\0') };
        TCHAR szLogonName[MAX_PATH]   = { TEXT('\0') };
        m_pOwner->AddRef();
        if (SUCCEEDED(m_pOwner->GetName(NULL, 0, 
                                        szLogonName, ARRAYSIZE(szLogonName),
                                        szDisplayName, ARRAYSIZE(szDisplayName))))
        {
            if (TEXT('\0') != szDisplayName[0])
            {
                m_strOwnerName.Format(TEXT("%1 (%2)"), szDisplayName, szLogonName);
            }
            else if (TEXT('\0') != szLogonName[0])
            {
                m_strOwnerName = szLogonName;
            }
            else
            {
                //
                // If the account SID has NOT been resolved to a name, display
                // the SID as a string.  We do the same thing in the Quota Entries
                // view.
                //
                BYTE Sid[MAX_SID_LEN];
                DWORD cchSidStr = MAX_PATH;
                if (SUCCEEDED(m_pOwner->GetSid(Sid, ARRAYSIZE(Sid))))
                {
                    SidToString(Sid, m_strOwnerName.GetBuffer(cchSidStr), &cchSidStr);
                    m_strOwnerName.ReleaseBuffer();
                }
            }
        }
    }    
}


int
COwnerListEntry::AddFile(
    LPCTSTR pszFile,
    bool bDirectory
    )
{
    m_rgFiles.Append(COwnerListFile(pszFile, bDirectory));
    return m_rgFiles.Count() - 1;
}


int
COwnerListEntry::FileCount(
    bool bIncludeDeleted       // optional.  Default = false.
    )
{
    int cFiles = m_rgFiles.Count();
    int n = 0;
    for (int i = 0; i < cFiles; i++)
    {
        if (bIncludeDeleted || !m_rgFiles[i].IsEmpty())
            n++;
    }
    return n;
}


#if DBG
void
COwnerListEntry::Dump(
    void
    ) const
{
    DBGERROR((TEXT("\tm_pOwner........: 0x%08X"), m_pOwner));
    DBGERROR((TEXT("\tm_strOwnerName..: \"%s\""), m_strOwnerName.Cstr()));
    int cFiles = m_rgFiles.Count();
    DBGERROR((TEXT("\tcFiles..........: %d"), cFiles));
    for (int i = 0; i < cFiles; i++)
    {
        DBGERROR((TEXT("\tFile[%3d].......: \"%s\""), i, m_rgFiles[i].Cstr()));
    }
}
#endif // DBG


COwnerList::~COwnerList(
    void
    )
{
    Clear();
}


void
COwnerList::Clear(
    void
    )
{
    int cOwners = m_rgpOwners.Count();
    for (int i = 0; i < cOwners; i++)
    {
        delete m_rgpOwners[i];
        m_rgpOwners[i] = NULL;
    }
    m_rgpOwners.Clear();
}


int
COwnerList::AddOwner(
    IDiskQuotaUser *pOwner
    )
{
    m_rgpOwners.Append(new COwnerListEntry(pOwner));
    return m_rgpOwners.Count() - 1;
}


IDiskQuotaUser *
COwnerList::GetOwner(
    int iOwner
    ) const
{
    //
    // Caller must call Release() when done with returned iface pointer.
    //
    return m_rgpOwners[iOwner]->GetOwner();
}


int 
COwnerList::FileCount(
    int iOwner,
    bool bIncludeDeleted    // optional.  Default = false
    ) const
{
    int cFiles = 0;
    int iFirst = iOwner;
    int iLast  = iOwner;
    if (-1 == iOwner)
    {
        //
        // Count ALL files.
        //
        iFirst = 0;
        iLast = m_rgpOwners.Count() - 1;
    }
    for (int i = iFirst; i <= iLast; i++)
    {
        cFiles += m_rgpOwners[i]->FileCount(bIncludeDeleted);
    }
    return cFiles;
}

#if DBG
void
COwnerList::Dump(
    void
    ) const
{
    int cEntries = m_rgpOwners.Count();
    DBGERROR((TEXT("COwnerList::Dump - %d entries"), cEntries));
    for (int i = 0; i < cEntries; i++)
    {
        DBGERROR((TEXT("COwnerListEntry[%d] ========================="), i));
        m_rgpOwners[i]->Dump();
    }
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\ownerdlg.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ownerdlg.h"
#include "ownerlst.h"
#include "resource.h"
#include "uihelp.h"
#include "uiutils.h"

//
// Private message used to indicate that the owner list thread
// has completed it's work.  
//
const UINT PWM_OWNERLIST_COMPLETE = WM_USER + 1;
//
// Mask bits indicating what operations are allowed for a given
// file selection set in the listview.
//
const DWORD ACTION_NONE          = 0x00000000;
const DWORD ACTION_TAKEOWNERSHIP = 0x00000001;
const DWORD ACTION_MOVE          = 0x00000002;
const DWORD ACTION_DELETE        = 0x00000004;
const DWORD ACTION_ANY           = 0x00000007;


const static DWORD rgFileOwnerDialogHelpIDs[] =
{
    IDC_CMB_OWNERDLG_OWNERS,    IDH_CMB_OWNERDLG_OWNERS,
    IDC_LV_OWNERDLG,            IDH_LV_OWNERDLG,
    IDC_BTN_OWNERDLG_DELETE,    IDH_BTN_OWNERDLG_DELETE,
    IDC_BTN_OWNERDLG_MOVETO,    IDH_BTN_OWNERDLG_MOVETO,
    IDC_BTN_OWNERDLG_TAKE,      IDH_BTN_OWNERDLG_TAKE,
    IDC_BTN_OWNERDLG_BROWSE,    IDH_BTN_OWNERDLG_BROWSE,
    IDC_EDIT_OWNERDLG_MOVETO,   IDH_EDIT_OWNERDLG_MOVETO,
    0,0
};


CFileOwnerDialog::CFileOwnerDialog(HINSTANCE hInstance,
    HWND hwndParent,
    LPCTSTR pszVolumeRoot,
    const CArray<IDiskQuotaUser *>& rgpOwners
    ) : m_hInstance(hInstance),
        m_hwndParent(hwndParent),
        m_hwndDlg(NULL),
        m_hwndLV(NULL),
        m_hwndOwnerCombo(NULL),
        m_hwndEditMoveTo(NULL),
        m_iLastColSorted(-1),
        m_bSortAscending(true),
        m_bAbort(false),
        m_hOwnerListThread(NULL),
        m_rgpOwners(rgpOwners),
        m_strVolumeRoot(pszVolumeRoot)
{
}

CFileOwnerDialog::~CFileOwnerDialog(
    void
    )
{
    if (NULL != m_hOwnerListThread)
    {
        CloseHandle(m_hOwnerListThread);
    }
}


INT_PTR
CFileOwnerDialog::Run(
    void
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("CFileOwnerDialog::Run")));
    return DialogBoxParam(m_hInstance,
                          MAKEINTRESOURCE(IDD_OWNERSANDFILES),
                          m_hwndParent,
                          DlgProc,
                          (LPARAM)this);
}


INT_PTR CALLBACK
CFileOwnerDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    CFileOwnerDialog *pThis = (CFileOwnerDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    try
    {
        switch(uMsg)
        {
            case WM_INITDIALOG:
                //
                // Store "this" ptr in window's userdata.
                //
                SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
                pThis = (CFileOwnerDialog *)lParam;
                //
                // Save the HWND in our object.  We'll need it later.
                //
                pThis->m_hwndDlg = hwnd;
                return pThis->OnInitDialog(hwnd);

            case WM_DESTROY:
                return pThis->OnDestroy(hwnd);

            case WM_COMMAND:
                return pThis->OnCommand(hwnd, wParam, lParam);

            case WM_NOTIFY:
                return pThis->OnNotify(hwnd, wParam, lParam);

            case WM_CONTEXTMENU:
                return pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case PWM_OWNERLIST_COMPLETE:
                pThis->OnOwnerListComplete();
                break;

            case WM_SETCURSOR:
                return pThis->OnSetCursor(hwnd);
                break;

            case WM_HELP:
                WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgFileOwnerDialogHelpIDs);
                return TRUE;
        }
    }
    catch(CAllocException& me)
    {
        //
        // Announce any out-of-memory errors associated with running the dlg.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return FALSE;
}


INT_PTR
CFileOwnerDialog::OnInitDialog(
    HWND hwnd
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("CFileOwnerDialog::OnInitDialog")));

    //
    // Save HWNDs of controls we'll need later.
    //
    m_hwndLV         = GetDlgItem(hwnd, IDC_LV_OWNERDLG);
    m_hwndOwnerCombo = GetDlgItem(hwnd, IDC_CMB_OWNERDLG_OWNERS);
    m_hwndEditMoveTo = GetDlgItem(hwnd, IDC_EDIT_OWNERDLG_MOVETO);
    //
    // We want these controls to be disabled until the owner list
    // has been populated.
    //
    EnableWindow(m_hwndLV, FALSE);
    EnableWindow(m_hwndOwnerCombo, FALSE);
    EnableWindow(m_hwndEditMoveTo, FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_BTN_OWNERDLG_BROWSE), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CBX_OWNERDLG_EXCLUDEDIRS), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_CBX_OWNERDLG_EXCLUDEFILES), FALSE);
    //
    // Build the list of owners and filenames on the volume.
    // This can take a while depending on how many owners
    // are in m_rgpOwners, the size of the volume and how many
    // files each owner owns.  First clear the owner list in case Run()
    // is being called multiple times on the same dialog object.
    // Note that we build this list on a background thread so that
    // we don't block the UI while it's building.
    //
    m_OwnerList.Clear();
    DWORD idThread;
    m_hOwnerListThread = CreateThread(NULL,
                                      0,
                                      OwnerListThreadProc,
                                      this,
                                      0,
                                      &idThread);
    return TRUE;
}


INT_PTR
CFileOwnerDialog::OnSetCursor(
    HWND hwnd
    )
{
    if (m_hOwnerListThread && (WAIT_TIMEOUT == WaitForSingleObject(m_hOwnerListThread, 0)))
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;
    }
    return FALSE;
}


INT_PTR
CFileOwnerDialog::OnDestroy(
    HWND hwnd
    )
{
    m_bAbort = true;
    if (NULL != m_hOwnerListThread)
    {
        WaitForSingleObject(m_hOwnerListThread, INFINITE);
    }
    return TRUE;
}


DWORD
CFileOwnerDialog::OwnerListThreadProc(  // [static]
    LPVOID pvParam
    )
{
    CFileOwnerDialog *pThis = (CFileOwnerDialog *)pvParam;
    
    pThis->BuildFileOwnerList(pThis->m_strVolumeRoot,
                              pThis->m_rgpOwners,
                             &(pThis->m_OwnerList));

    PostMessage(pThis->m_hwndDlg, PWM_OWNERLIST_COMPLETE, 0, 0);
    return 0;
}

//
// Called in response to PWM_OWNERLIST_COMPLETE which is posted
// to the dialog when the OwnerListThreadProc has completed
// it's processing.
//
void
CFileOwnerDialog::OnOwnerListComplete(
    void
    )
{
    //
    // Set the message in the top of the dialog.
    //
    CString s(m_hInstance, IDS_FMT_OWNERDLG_HEADER, m_OwnerList.OwnerCount());
    SetWindowText(GetDlgItem(m_hwndDlg, IDC_TXT_OWNERDLG_HEADER), s);
    //
    // Populate the listview and owner combo.
    //
    InitializeList(m_OwnerList, m_hwndLV);
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
    //
    // Now we can enable the controls we disabled in OnInitDialog().
    //
    EnableWindow(m_hwndLV, TRUE);
    EnableWindow(m_hwndOwnerCombo, TRUE);
    EnableWindow(m_hwndEditMoveTo, TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_BTN_OWNERDLG_BROWSE), TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEDIRS), TRUE);
    EnableWindow(GetDlgItem(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEFILES), TRUE);

}



INT_PTR
CFileOwnerDialog::OnCommand(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult     = TRUE; // Assume not handled.
    WORD wID         = LOWORD(wParam);
    WORD wNotifyCode = HIWORD(wParam);
    HWND hCtl        = (HWND)lParam;

    switch(wID)
    {
        case IDCANCEL:
            EndDialog(hwnd, 0);
            bResult = FALSE;
            break;

        case IDC_CMB_OWNERDLG_OWNERS:
            if (CBN_SELCHANGE == wNotifyCode)
            {
                int iOwner = ComboBox_GetCurSel(m_hwndOwnerCombo);
                if (1 < m_OwnerList.OwnerCount())
                {
                    //
                    // Owner list contains more than one owner.  The combo
                    // contains a leading "All owners" entry.
                    //
                    iOwner--;
                }

                DBGASSERT((-1 <= iOwner));
                CAutoSetRedraw autoredraw(m_hwndLV, false);
                //
                // Only show "owner" column if user has selected "all owners" combo item.
                //
                CreateListColumns(m_hwndLV, -1 == iOwner);
                FillListView(m_OwnerList, m_hwndLV, iOwner);
            }
            bResult = FALSE;
            break;

        case IDC_BTN_OWNERDLG_BROWSE:
        {
            CString s;
            if (BrowseForFolder(hwnd, &s))
                SetWindowText(m_hwndEditMoveTo, s);
            break;
        }

        case IDC_BTN_OWNERDLG_DELETE:
            DeleteSelectedFiles(m_hwndLV);
            bResult = FALSE;
            break;

        case IDC_BTN_OWNERDLG_MOVETO:
        {
            CPath strDest;
            CPath strRoot;
            int cchEdit = Edit_GetTextLength(m_hwndEditMoveTo);
            Edit_GetText(m_hwndEditMoveTo,
                         strDest.GetBuffer(cchEdit + 1),
                         cchEdit + 1);
            strDest.ReleaseBuffer();
            strDest.Trim();
            strDest.GetRoot(&strRoot);

            if (IsSameVolume(strRoot, m_strVolumeRoot))
            {
                //
                // Don't let operator move files to a folder
                // on the same volume.
                //
                DiskQuotaMsgBox(m_hwndDlg,
                                IDS_ERROR_MOVETO_SAMEVOL,
                                IDS_TITLE_DISK_QUOTA,
                                MB_ICONINFORMATION | MB_OK);

                SetWindowText(m_hwndEditMoveTo, strDest);
                SetFocus(m_hwndEditMoveTo);
            }
            else
            {
                //
                // Eveything looks OK.  Try to move the files.
                //
                MoveSelectedFiles(m_hwndLV, strDest);
            }
            bResult = FALSE;
            break;
        }

        case IDC_BTN_OWNERDLG_TAKE:
        {
            HRESULT hr = TakeOwnershipOfSelectedFiles(m_hwndLV);
            if (FAILED(hr))
            {
                DBGERROR((TEXT("TakeOwnershipOfSelectedFiles failed with hr = 0x%08X"), hr));
            }
            break;
        }

        case IDC_EDIT_OWNERDLG_MOVETO:
            if (EN_UPDATE == wNotifyCode)
            {
                //
                // Disable the "Move" button if the destination edit field
                // is blank.
                //
                HWND hwnd    = GetDlgItem(m_hwndDlg, IDC_BTN_OWNERDLG_MOVETO);
                bool bEnable = ShouldEnableControl(IDC_BTN_OWNERDLG_MOVETO);
                if (bEnable != boolify(IsWindowEnabled(hwnd)))
                {
                    EnableWindow(hwnd, bEnable);
                }
            }
            break;

        case IDC_CBX_OWNERDLG_EXCLUDEFILES:
        case IDC_CBX_OWNERDLG_EXCLUDEDIRS:
            if (BN_CLICKED == wNotifyCode)
            {
                //
                // The allowable states for these two checkboxes are:
                //
                //   Excl Files      Excl Dirs
                //   --------------- ----------------
                //   Checked         Unchecked
                //   Unchecked       Checked
                //   Unchecked       Unchecked
                //
                // It makes no sense to have both checkboxes checked. 
                // This would cause the list to be empty and might 
                // generate user confusion.
                //
                if (IsDlgButtonChecked(m_hwndDlg, wID))
                {
                    UINT idOther = IDC_CBX_OWNERDLG_EXCLUDEFILES;
                    if (IDC_CBX_OWNERDLG_EXCLUDEFILES == wID)
                    {
                        idOther = IDC_CBX_OWNERDLG_EXCLUDEDIRS;
                    }
                    CheckDlgButton(m_hwndDlg, idOther, BST_UNCHECKED);
                }
                FillListView(m_OwnerList, m_hwndLV, ComboBox_GetCurSel(m_hwndOwnerCombo) - 1);
            }
            break;
    }
    return bResult;
}


INT_PTR
CFileOwnerDialog::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgFileOwnerDialogHelpIDs));

    return FALSE;
}


//
// Determine what actions are allowed for the current selection.
//
DWORD 
CFileOwnerDialog::GetAllowedActions(
    HWND hwndLV
    )
{
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, NULL, &rgItemHandles);
    if (0 != rgItemHandles.Count())
    {
        const int cHandles = rgItemHandles.Count();
        for(int i = 0; i < cHandles; i++)
        {
            COwnerListItemHandle handle = rgItemHandles[i];
            int iOwner = handle.OwnerIndex();
            int iFile  = handle.FileIndex();
            if (m_OwnerList.IsFileDirectory(iOwner, iFile))
            {
                //
                // If any directory exists in the selection,
                // "take ownership" is the only allowed action.
                //
                return ACTION_TAKEOWNERSHIP;
            }
        }
    }
    return ACTION_ANY;
}


//
// Determine if one of the move/delete/take buttons should be enabled
// or disabled.
//
bool
CFileOwnerDialog::ShouldEnableControl(
    UINT idCtl
    )
{
    bool bEnable = true;
    int cLVSel = ListView_GetSelectedCount(m_hwndLV);
    DWORD actions = GetAllowedActions(m_hwndLV);
    
    switch(idCtl)
    {
        case IDC_BTN_OWNERDLG_DELETE:
            bEnable = (0 != (ACTION_DELETE & actions)) && (0 < cLVSel);
            break;
            
        case IDC_BTN_OWNERDLG_TAKE:
            bEnable = (0 != (ACTION_TAKEOWNERSHIP & actions)) && (0 < cLVSel);
            break;

        case IDC_BTN_OWNERDLG_MOVETO:
            bEnable = (0 != (ACTION_MOVE & actions));
            if (bEnable && 0 < cLVSel)
            {
                CPath s;
                int cch = Edit_GetTextLength(m_hwndEditMoveTo);
                Edit_GetText(m_hwndEditMoveTo, s.GetBuffer(cch + 1), cch + 1);
                s.ReleaseBuffer();
                s.Trim();
                bEnable = 0 < s.Length();
            }
            break;

        case IDC_BTN_OWNERDLG_BROWSE:
        case IDC_EDIT_OWNERDLG_MOVETO:
            bEnable = (0 != (ACTION_MOVE & actions));
            break;

        default:
            break;
    }
    return bEnable;
}


INT_PTR
CFileOwnerDialog::OnNotify(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bResult = TRUE;
    LPNMHDR pnm  = (LPNMHDR)lParam;

    switch(pnm->code)
    {
        case LVN_GETDISPINFO:
            OnLVN_GetDispInfo((LV_DISPINFO *)lParam);
            break;

        case LVN_COLUMNCLICK:
            OnLVN_ColumnClick((NM_LISTVIEW *)lParam);
            break;

        case LVN_ITEMCHANGED:
            OnLVN_ItemChanged((NM_LISTVIEW *)lParam);
            break;

        case LVN_KEYDOWN:
            OnLVN_KeyDown((NMLVKEYDOWN *)lParam);
            break;

        default:
            break;
    }

    return bResult;
}


void
CFileOwnerDialog::OnLVN_GetDispInfo(
    LV_DISPINFO *plvdi
    )
{
    static CPath strPath;
    static CString strOwner;

    COwnerListItemHandle hItem(plvdi->item.lParam);
    int iOwner = hItem.OwnerIndex();
    int iFile  = hItem.FileIndex();

    if (LVIF_TEXT & plvdi->item.mask)
    {
        switch(plvdi->item.iSubItem)
        {
            case iLVSUBITEM_FILE:
            {
                CPath s;
                m_OwnerList.GetFileName(iOwner, iFile, &s);
                if (m_OwnerList.IsFileDirectory(iOwner, iFile))
                {
                    strPath.Format(m_hInstance, IDS_FMT_OWNERDLG_FOLDERNAME, s.Cstr());
                }
                else
                {
                    strPath = s;
                }
                plvdi->item.pszText = (LPTSTR)strPath.Cstr();
            }
            break;

            case iLVSUBITEM_FOLDER:
                m_OwnerList.GetFolderName(iOwner, iFile, &strPath);
                plvdi->item.pszText = (LPTSTR)strPath.Cstr();
                break;

            case iLVSUBITEM_OWNER:
                m_OwnerList.GetOwnerName(iOwner, &strOwner);
                plvdi->item.pszText = (LPTSTR)strOwner.Cstr();
                break;
        }
    }

    if (LVIF_IMAGE & plvdi->item.mask)
    {
        //
        // Not displaying any images.  This is just a placeholder.
        // Should be optimized out by compiler.
        //
    }
}


int CALLBACK
CFileOwnerDialog::CompareLVItems(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    CFileOwnerDialog *pdlg = reinterpret_cast<CFileOwnerDialog *>(lParamSort);
    int diff = 0;
    try
    {
        COwnerListItemHandle h1(lParam1);
        COwnerListItemHandle h2(lParam2);
        int iOwner1 = h1.OwnerIndex();
        int iOwner2 = h2.OwnerIndex();
        int iFile1  = h1.FileIndex();
        int iFile2  = h2.FileIndex();
        static CPath s1, s2;

        //
        // This array controls the comparison column IDs used when
        // values for the selected column are equal.  These should
        // remain in order of the iLVSUBITEM_xxxxx enumeration with
        // respect to the first element in each row.
        //
        static const int rgColComp[3][3] = {
            { iLVSUBITEM_FILE,   iLVSUBITEM_FOLDER, iLVSUBITEM_OWNER  },
            { iLVSUBITEM_FOLDER, iLVSUBITEM_FILE,   iLVSUBITEM_OWNER  },
            { iLVSUBITEM_OWNER,  iLVSUBITEM_FILE,   iLVSUBITEM_FOLDER }
                                           };
        int iCompare = 0;
        while(0 == diff && iCompare < ARRAYSIZE(rgColComp))
        {
            switch(rgColComp[pdlg->m_iLastColSorted][iCompare++])
            {
                case iLVSUBITEM_FILE:
                    pdlg->m_OwnerList.GetFileName(iOwner1, iFile1, &s1);
                    pdlg->m_OwnerList.GetFileName(iOwner2, iFile2, &s2);
                    break;

                case iLVSUBITEM_FOLDER:
                    pdlg->m_OwnerList.GetFolderName(iOwner1, iFile1, &s1);
                    pdlg->m_OwnerList.GetFolderName(iOwner2, iFile2, &s2);
                    break;

                case iLVSUBITEM_OWNER:
                    //
                    // Can use CPath (s1 and s2) in place of CString arg since
                    // CPath is derived from CString.
                    //
                    pdlg->m_OwnerList.GetOwnerName(iOwner1, &s1);
                    pdlg->m_OwnerList.GetOwnerName(iOwner2, &s2);
                    break;

                default:
                    //
                    // If you hit this, you need to update this function
                    // to handle the new column you've added to the listview.
                    //
                    DBGASSERT((false));
                    break;
            }
            diff = s1.Compare(s2);
        }
        //
        // Don't need contents of static strings between function invocations.
        // The strings are static to avoid repeated construction/destruction.
        // It's only a minor optimization.
        //
        s1.Empty();
        s2.Empty();
    }
    catch(CAllocException& e)
    {
        //
        // Do nothing.  Just return diff "as is".
        // Don't want to throw an exception back into comctl32.
        //
    }
    return pdlg->m_bSortAscending ? diff : -1 * diff;
}


void
CFileOwnerDialog::OnLVN_ColumnClick(
    NM_LISTVIEW *pnmlv
    )
{
    DBGTRACE((DM_VIEW, DL_LOW, TEXT("CFileOwnerDialog::OnLVN_ColumnClick")));

    if (m_iLastColSorted != pnmlv->iSubItem)
    {
        m_bSortAscending = true;
        m_iLastColSorted = pnmlv->iSubItem;
    }
    else
    {
        m_bSortAscending = !m_bSortAscending;
    }

    ListView_SortItems(m_hwndLV, CompareLVItems, LPARAM(this));
}


//
// Called whenever a listview item has changed state.
// I'm using this to update the "enabledness" of the
// dialog buttons.  If there's nothing selected in the listview,
// the move/delete/take buttons are disabled.
//
void
CFileOwnerDialog::OnLVN_ItemChanged(
    NM_LISTVIEW *pnmlv
    )
{
    static const int rgCtls[] = { IDC_BTN_OWNERDLG_DELETE,
                                  IDC_BTN_OWNERDLG_TAKE,
                                  IDC_BTN_OWNERDLG_MOVETO,
                                  IDC_BTN_OWNERDLG_BROWSE,
                                  IDC_EDIT_OWNERDLG_MOVETO};

    //
    // LVN_ITEMCHANGED is sent multiple times when you move the
    // highlight bar in a listview.
    // Only run this code when the "focused" state bit is set
    // for the "new state".  This should be the last call in
    // the series.
    //
    if (LVIS_FOCUSED & pnmlv->uNewState)
    {
        for (int i = 0; i < ARRAYSIZE(rgCtls); i++)
        {
            HWND hwnd    = GetDlgItem(m_hwndDlg, rgCtls[i]);
            bool bEnable = ShouldEnableControl(rgCtls[i]);
            if (bEnable != boolify(IsWindowEnabled(hwnd)))
            {
                EnableWindow(hwnd, bEnable);
            }
        }
    }
}


void
CFileOwnerDialog::OnLVN_KeyDown(
    NMLVKEYDOWN *plvkd
    )
{
    if (VK_DELETE == plvkd->wVKey)
    {
        DeleteSelectedFiles(m_hwndLV);
        FocusOnSomethingInListview(m_hwndLV);
    }
}



void
CFileOwnerDialog::FocusOnSomethingInListview(
    HWND hwndLV
    )
{
    //
    // Focus on something.
    //
    int iFocus = ListView_GetNextItem(hwndLV, -1, LVNI_FOCUSED);
    if (-1 == iFocus)
        iFocus = 0;

    ListView_SetItemState(hwndLV, iFocus, LVIS_FOCUSED | LVIS_SELECTED,
                                          LVIS_FOCUSED | LVIS_SELECTED);
}


//
// Creates the listview columns and populates the listview
// with filenames.
//
void
CFileOwnerDialog::InitializeList(
    const COwnerList& fol,  // file & owner list
    HWND hwndList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::InitializeList")));

    CreateListColumns(hwndList, 1 < m_OwnerList.OwnerCount());
    FillListView(fol, hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);
}


void
CFileOwnerDialog::CreateListColumns(
    HWND hwndList,
    bool bShowOwner    // Default is true.
    )
{
    //
    // Clear out the listview and header.
    //
    ListView_DeleteAllItems(hwndList);
    HWND hwndHeader = ListView_GetHeader(hwndList);
    if (NULL != hwndHeader)
    {
        while(0 < Header_GetItemCount(hwndHeader))
            ListView_DeleteColumn(hwndList, 0);
    }

    //
    // Create the header titles.
    //
    CString strFile(m_hInstance,   IDS_OWNERDLG_HDR_FILE);
    CString strFolder(m_hInstance, IDS_OWNERDLG_HDR_FOLDER);
    CString strOwner(m_hInstance,  IDS_OWNERDLG_HDR_OWNER);

    //
    // FEATURE:  Should probably allow for vertical scroll bar also.
    //
    RECT rcList;
    GetClientRect(hwndList, &rcList);
    int cxCol = (rcList.right - rcList.left) / (bShowOwner ? 3 : 2);

#define LVCOLMASK (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM)

    LV_COLUMN rgCols[] = {
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strFile,   0, iLVSUBITEM_FILE   },
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strFolder, 0, iLVSUBITEM_FOLDER },
         { LVCOLMASK, LVCFMT_LEFT, cxCol, strOwner,  0, iLVSUBITEM_OWNER  }
                         };
    //
    // Add the columns to the listview.
    //
    int cCols = bShowOwner ? ARRAYSIZE(rgCols) : ARRAYSIZE(rgCols) - 1;
    for (INT i = 0; i < cCols; i++)
    {
        if (-1 == ListView_InsertColumn(hwndList, i, &rgCols[i]))
        {
            DBGERROR((TEXT("CFileOwnerDialog::CreateListColumns failed to add column %d"), i));
        }
    }
}


void
CFileOwnerDialog::FillListView(
    const COwnerList& fol,  // file & owner list
    HWND hwndList,
    int iOwner              // default is -1 (all owners)
    )
{
    ListView_DeleteAllItems(hwndList);

    LV_ITEM item;
    item.iSubItem  = 0;
    item.mask      = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_PARAM;
    item.state     = 0;
    item.stateMask = 0;
    item.pszText   = LPSTR_TEXTCALLBACK;
    item.iImage    = I_IMAGECALLBACK;

    int iFirst = iOwner;
    int iLast  = iOwner;
    if (-1 == iOwner)
    {
        iFirst = 0;
        iLast  = fol.OwnerCount() - 1;
    }
    int iItem = 0;
    const bool bExclFiles = IsDlgButtonChecked(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEFILES);
    const bool bExclDirs  = IsDlgButtonChecked(m_hwndDlg, IDC_CBX_OWNERDLG_EXCLUDEDIRS);
    //
    // WARNING:  Reusing formal arg iOwner.  It's safe to do, but you
    //           should be aware that I'm doing it.
    //
    for (iOwner = iFirst; iOwner <= iLast; iOwner++)
    {
        int cFiles = fol.FileCount(iOwner, true);
        for (int iFile = 0; iFile < cFiles; iFile++)
        {
            bool bDirectory = fol.IsFileDirectory(iOwner, iFile);
            bool bFile      = !bDirectory;

            if ((bDirectory && !bExclDirs) || (bFile && !bExclFiles))
            {
                if (!fol.IsFileDeleted(iOwner, iFile))
                {
                    item.lParam = COwnerListItemHandle(iOwner, iFile);
                    item.iItem  = iItem++;
                    if (-1 == ListView_InsertItem(hwndList, &item))
                        DBGERROR((TEXT("Error adding LV item for owner %d, file %d"), iOwner, iFile));
                }
            }
        }
    }
}


void
CFileOwnerDialog::InitializeOwnerCombo(
    const COwnerList& fol,  // file & owner list
    HWND hwndCombo
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::InitializeList")));

    int iSelected = ComboBox_GetCurSel(hwndCombo);
    ComboBox_ResetContent(hwndCombo);

    CString s, s2;
    int cOwners = fol.OwnerCount();
    if (1 < cOwners)
    {
        //
        // Add "all owners" entry.
        //
        s.Format(m_hInstance, IDS_FMT_ALLOWNERS, fol.FileCount());
        ComboBox_InsertString(hwndCombo, -1, s);
    }

    for (int iOwner = 0; iOwner < cOwners; iOwner++)
    {
        fol.GetOwnerName(iOwner, &s2);
        s.Format(m_hInstance, IDS_FMT_OWNER, s2.Cstr(), fol.FileCount(iOwner));
        ComboBox_InsertString(hwndCombo, -1, s);
    }

    ComboBox_SetCurSel(hwndCombo, CB_ERR != iSelected ? iSelected : 0);

    //
    // Set the max height of the owner combo
    //
    RECT rcCombo;
    GetClientRect(m_hwndOwnerCombo, &rcCombo);
    SetWindowPos(m_hwndOwnerCombo,
                 NULL,
                 0, 0,
                 rcCombo.right - rcCombo.left,
                 200,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
}


//
// Determine if two volume root strings refer to the same volume.
// With volume mount points, "C:\" and "D:\DriveC" could refer to the
// same physical volume.  To differentiate we need to examine the unique
// volume name GUID strings.
//
bool
CFileOwnerDialog::IsSameVolume(
    LPCTSTR pszRoot1,
    LPCTSTR pszRoot2
    )
{
    TCHAR szVolGUID1[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    bool bSameVolume = false;

    //
    // GetVolumeNameForVolumeMountPoint requires trailing backslash on paths.
    //
    lstrcpyn(szTemp, pszRoot1, ARRAYSIZE(szTemp));
    PathAddBackslash(szTemp);
    
    if (GetVolumeNameForVolumeMountPoint(szTemp, szVolGUID1, ARRAYSIZE(szVolGUID1)))
    {
        TCHAR szVolGUID2[MAX_PATH];
        lstrcpyn(szTemp, pszRoot2, ARRAYSIZE(szTemp));
        PathAddBackslash(szTemp);

        if (GetVolumeNameForVolumeMountPoint(szTemp, szVolGUID2, ARRAYSIZE(szVolGUID2)))
        {
            if (0 == lstrcmpi(szVolGUID1, szVolGUID2))
                bSameVolume = true;
        }
    }
    return bSameVolume;
}

//
// Let the user browse for a folder.
// The selected folder path is returned in *pstrFolder.
//
bool
CFileOwnerDialog::BrowseForFolder(
    HWND hwndParent,
    CString *pstrFolder
    )
{
    bool bResult = false;
    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));

    CString strTitle(m_hInstance, IDS_BROWSEFORFOLDER);

    bi.hwndOwner      = hwndParent;
    bi.pidlRoot       = NULL;       // Start at desktop.
    bi.pszDisplayName = NULL;
    bi.lpszTitle      = strTitle.Cstr();
    //
    // FEATURE:  Setting the BIF_EDITBOX flag causes SHBrowseForFolder to invoke
    //          autocomplete through SHAutoComplete (in shlwapi).  SHAutoComplete
    //          loads browseui.dll to implement the autocomplete feature.  The bad
    //          part is that SHAutoComplete also unloads browseui.dll before it
    //          returns, resulting in calls to the unloaded WndProc.  I've notified
    //          ReinerF about this.  Turning off the BIF_EDITBOX bit prevents
    //          autocomplete from being used and thus prevents the problem.
    //          I want the edit box.  Turn it back on once they fix this bug.
    //
    //          brianau [1/30/97]
    //
    bi.ulFlags        = BIF_RETURNONLYFSDIRS; // | BIF_EDITBOX;
    bi.lpfn           = BrowseForFolderCallback;
    bi.lParam         = (LPARAM)pstrFolder;
    bi.iImage         = 0;

    bResult = boolify(SHBrowseForFolder(&bi));
    return bResult;
}


//
// Callback called by SHBrowseForFolder.  Writes selected folder path
// to CString object who's pointer is passed in lpData arg.
//
int
CFileOwnerDialog::BrowseForFolderCallback(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BrowseForFolderCallback")));
    CString *pstrFolder = (CString *)lpData;

    if (BFFM_SELCHANGED == uMsg)
    {
        SHGetPathFromIDList((LPCITEMIDLIST)lParam, pstrFolder->GetBuffer(MAX_PATH));
        pstrFolder->ReleaseBuffer();
    }
    return 0;
}


//
// Builds a double-nul terminated list of file paths from the listview
// along with an array of "item handle" objects that acts as a cross-
// reference between the list items, items in the listview and items
// in the file owner list.  Each handle contains an owner index and
// file index into the file owner list.  Each handle is also the value
// stored as the lParam in the listview items.
// Both pList and prgItemHandles arguments are optional.  Although,
// calling with neither non-null is sort of useless.
//
void
CFileOwnerDialog::BuildListOfSelectedFiles(
    HWND hwndLV,
    DblNulTermList *pList,
    CArray<COwnerListItemHandle> *prgItemHandles
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BuildListOfSelectedFiles")));
    int iItem = -1;
    CPath strPath;
    LV_ITEM item;

    if (NULL != prgItemHandles)
        prgItemHandles->Clear();
    while(-1 != (iItem = ListView_GetNextItem(hwndLV, iItem, LVNI_SELECTED)))
    {
        item.iSubItem = 0;
        item.iItem    = iItem;
        item.mask     = LVIF_PARAM;
        if (-1 != ListView_GetItem(hwndLV, &item))
        {
            COwnerListItemHandle hItem(item.lParam);
            m_OwnerList.GetFileFullPath(hItem.OwnerIndex(),
                                        hItem.FileIndex(),
                                        &strPath);
            if (pList)
                pList->AddString(strPath);
            if (prgItemHandles)
                prgItemHandles->Append(hItem);
        }
    }
}



//
// Given an item "handle", find it's entry in the listview.
//
int
CFileOwnerDialog::FindItemFromHandle(
    HWND hwndLV,
    const COwnerListItemHandle& handle
    )
{
    LV_FINDINFO lvfi;
    lvfi.flags  = LVFI_PARAM;
    lvfi.lParam = handle;
    return ListView_FindItem(hwndLV, -1, &lvfi);
}


//
// Scans an array of item handles and removes all corresponding
// items from the listview.
//
void
CFileOwnerDialog::RemoveListViewItems(
    HWND hwndLV,
    const CArray<COwnerListItemHandle>& rgItemHandles
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::RemoveListViewItems")));
    LV_ITEM item;
    CPath strPath;

    CAutoSetRedraw autoredraw(hwndLV, false);
    int cHandles = rgItemHandles.Count();
    for (int iHandle = 0; iHandle < cHandles; iHandle++)
    {
        COwnerListItemHandle handle = rgItemHandles[iHandle];
        int iItem = FindItemFromHandle(hwndLV, handle);
        if (-1 != iItem)
        {
            int iOwner = handle.OwnerIndex();
            int iFile  = handle.FileIndex();
            m_OwnerList.GetFileFullPath(iOwner, iFile, &strPath);

            if ((DWORD)-1 == GetFileAttributes(strPath))
            {
                //
                // File doesn't exist any more.
                // Delete from the listview.
                // Mark it as "deleted" in the ownerlist container.
                //
                ListView_DeleteItem(hwndLV, iItem);
                m_OwnerList.MarkFileDeleted(iOwner, iFile);
                DBGPRINT((DM_VIEW, DL_LOW, TEXT("Removed item %d \"%s\""),
                         iItem, strPath.Cstr()));
            }
        }
    }
    //
    // Refresh the owner combo to update the file counts.
    //
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
}


//
// Delete the files selected in the listview.
// Files deleted are removed from the listview.
//
void
CFileOwnerDialog::DeleteSelectedFiles(
    HWND hwndLV
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::DeleteSelectedFiles")));
    DblNulTermList list(1024);  // 1024 is the buffer growth size in chars.
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, &list, &rgItemHandles);
    if (0 < list.Count())
    {
        SHFILEOPSTRUCT fo;
        fo.hwnd   = m_hwndDlg;
        fo.wFunc  = FO_DELETE;
        fo.pFrom  = list;
        fo.pTo    = NULL;
        fo.fFlags = 0;

        if (0 != SHFileOperation(&fo))
        {
            DBGERROR((TEXT("SHFileOperation [FO_DELETE] failed")));
        }
        //
        // Remove listview items if their files were really deleted.
        //
        RemoveListViewItems(hwndLV, rgItemHandles);
    }
}


//
// Move the selected files to a new location.
// Moved files are removed from the listview.
//
void
CFileOwnerDialog::MoveSelectedFiles(
    HWND hwndLV,
    LPCTSTR pszDest
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::DeleteSelectedFiles")));
    DblNulTermList list(1024);  // 1024 is the buffer growth size in chars.
    CArray<COwnerListItemHandle> rgItemHandles;

    BuildListOfSelectedFiles(hwndLV, &list, &rgItemHandles);
    if (0 < list.Count())
    {
        CPath strDest(pszDest);
        if (1 == list.Count())
        {
            //
            // If we have only a single file we MUST create a fully-qualified
            // path to the destination file.  Oddities in the shell's move/copy
            // engine won't let us pass merely a destination folder in the
            // case where that folder doesn't exist.  If we give the full path
            // including filename we'll get the "folder doesn't exist, create
            // now?" messagebox as we would expect.  If we're moving multiple
            // files the shell accepts a single directory path.
            //
            LPCTSTR psz;
            DblNulTermListIter iter(list);
            if (iter.Next(&psz))
            {
                CPath strSrc(psz);           // Copy the source
                CPath strFile;               
                strSrc.GetFileSpec(&strFile);// Extract the filename.
                strDest.Append(strFile);     // Append to the dest path.
            }
        }
            
        SHFILEOPSTRUCT fo;
        fo.hwnd   = m_hwndDlg;
        fo.wFunc  = FO_MOVE;
        fo.pFrom  = list;
        fo.pTo    = strDest;
        fo.fFlags = FOF_RENAMEONCOLLISION;

        if (0 != SHFileOperation(&fo))
        {
            DBGERROR((TEXT("SHFileOperation [FO_MOVE] failed")));
        }
        //
        // Remove listview items if their file was really deleted.
        //
        RemoveListViewItems(hwndLV, rgItemHandles);
    }
}


//
// Get the SID to use for taking ownership of files.
// First try to get the first group SID with the SE_GROUP_OWNER attribute.
// If none found, use the operator's account SID.  The SID is in a
// dynamic buffer attached to the ptrSid autoptr argument.
//
HRESULT
CFileOwnerDialog::GetOwnershipSid(
    array_autoptr<BYTE> *ptrSid
    )
{
    HRESULT hr  = E_FAIL;
    DWORD dwErr = 0;

    //
    // Get the token handle. First try the thread token then the process
    // token.  If these fail we return early.  No sense in continuing
    // on if we can't get a user token.
    //
    CWin32Handle hToken;
    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_READ,
                         TRUE,
                         hToken.HandlePtr()))
    {
        if (ERROR_NO_TOKEN == GetLastError())
        {
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_READ,
                                  hToken.HandlePtr()))
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d opening process token"), dwErr));
                return HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d opening thread token"), dwErr));
            return HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Get the required size of the group token information buffer.
    //
    array_autoptr<BYTE> ptrTokenInfo;
    DWORD cbTokenInfo = 0;

    if (!GetTokenInformation(hToken,
                             TokenGroups,
                             NULL,
                             cbTokenInfo,
                             &cbTokenInfo))
    {
        dwErr = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
        {
            ptrTokenInfo = new BYTE[cbTokenInfo];
        }
        else
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d getting TokenGroups info [for size]"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    //
    // Get the group token information.
    //
    if (NULL != ptrTokenInfo.get())
    {
        if (!GetTokenInformation(hToken,
                                 TokenGroups,
                                 ptrTokenInfo.get(),
                                 cbTokenInfo,
                                 &cbTokenInfo))
        {
            dwErr = GetLastError();
            DBGERROR((TEXT("Error %d getting TokenGroups info"), dwErr));
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            //
            // Extract the first SID with the GROUP_OWNER bit set.
            //
            TOKEN_GROUPS *ptg = (TOKEN_GROUPS *)ptrTokenInfo.get();
            DBGASSERT((NULL != ptg));
            for (DWORD i = 0; i < ptg->GroupCount; i++)
            {
                SID_AND_ATTRIBUTES *psa = (SID_AND_ATTRIBUTES *)&ptg->Groups[i];
                DBGASSERT((NULL != psa));
                if (SE_GROUP_OWNER & psa->Attributes)
                {
                    int cbSid = GetLengthSid(psa->Sid);
                    *ptrSid = new BYTE[cbSid];
                    CopySid(cbSid, ptrSid->get(), psa->Sid);
                    hr = NOERROR;
                    break;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        //
        // Didn't find a SID from the group information.
        // Use the operator's SID.
        //
        cbTokenInfo = 0;
        if (!GetTokenInformation(hToken,
                                 TokenUser,
                                 NULL,
                                 cbTokenInfo,
                                 &cbTokenInfo))
        {
            dwErr = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
                ptrTokenInfo = new BYTE[cbTokenInfo];
            }
            else
            {
                DBGERROR((TEXT("Error %d getting TokenUser info [for size]"), dwErr));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }

        if (SUCCEEDED(hr))
        {
            //
            // Get the user token information.
            //
            if (!GetTokenInformation(hToken,
                                     TokenUser,
                                     ptrTokenInfo.get(),
                                     cbTokenInfo,
                                     &cbTokenInfo))
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d getting TokenUser info"), dwErr));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
            else
            {
                SID_AND_ATTRIBUTES *psa = (SID_AND_ATTRIBUTES *)ptrTokenInfo.get();
                DBGASSERT((NULL != psa));
                int cbSid = GetLengthSid(psa->Sid);
                *ptrSid = new BYTE[cbSid];
                CopySid(cbSid, ptrSid->get(), psa->Sid);
                hr = NOERROR;
            }
        }
    }
    if (SUCCEEDED(hr) && NULL != ptrSid->get() && !IsValidSid(ptrSid->get()))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }
    return hr;
}


//
// Transfers ownership of selected files in the listview to the
// currently logged-on user.
//
HRESULT
CFileOwnerDialog::TakeOwnershipOfSelectedFiles(
    HWND hwndLV
    )
{
    HRESULT hr = NOERROR;
    DWORD dwErr = 0;
    CArray<COwnerListItemHandle> rgItemHandles;
    
    BuildListOfSelectedFiles(hwndLV, NULL, &rgItemHandles);
    if (0 == rgItemHandles.Count())
        return S_OK;

    array_autoptr<BYTE> ptrSid;
    hr = GetOwnershipSid(&ptrSid);
    if (FAILED(hr))
        return hr;

    CPath strFile;
    int cHandles = rgItemHandles.Count();
    for (int i = 0; i < cHandles; i++)
    {
        COwnerListItemHandle handle = rgItemHandles[i];
        int iItem = FindItemFromHandle(hwndLV, handle);
        if (-1 != iItem)
        {
            SECURITY_DESCRIPTOR sd;
            if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            {
                int iOwner = handle.OwnerIndex();
                int iFile  = handle.FileIndex();
                m_OwnerList.GetFileFullPath(iOwner, iFile, &strFile);
                if (SetSecurityDescriptorOwner(&sd, ptrSid.get(), FALSE))
                {
                    if (SetFileSecurity(strFile, OWNER_SECURITY_INFORMATION, &sd))
                    {
                        ListView_DeleteItem(hwndLV, iItem);
                        m_OwnerList.MarkFileDeleted(iOwner, iFile);
                    }
                    else
                    {
                        dwErr = GetLastError();
                        DBGERROR((TEXT("Error %d setting new owner for \"%s\""),
                                 dwErr, strFile.Cstr()));
                        hr = HRESULT_FROM_WIN32(dwErr);
                    }
                }
                else
                {
                    dwErr = GetLastError();
                    DBGERROR((TEXT("Error %d setting security descriptor owner"), dwErr));
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
            }
            else
            {
                dwErr = GetLastError();
                DBGERROR((TEXT("Error %d initing security descriptor"), GetLastError()));
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }
        else
        {
            DBGERROR((TEXT("Can't find listview item for owner %d, file %d"),
                     handle.OwnerIndex(), handle.FileIndex()));
        }
    }
    //
    // Refresh the owner combo with the new file counts.
    //
    InitializeOwnerCombo(m_OwnerList, m_hwndOwnerCombo);
    return hr;
}



//
// The original code for listing files owned by a user was
// contributed by MarkZ.  I made some minor modifications
// to fit it into the diskquota project and make it more
// exception safe.
//
inline VOID *
Add2Ptr(VOID *pv, ULONG cb)
{
    return((BYTE *) pv + cb);
}

inline ULONG
QuadAlign( ULONG Value )
{
    return (Value + 7) & ~7;
}


//
// Add files owned by a particular user on a particular volume.
//
HRESULT
CFileOwnerDialog::AddFilesToOwnerList(
    LPCTSTR pszVolumeRoot,
    HANDLE hVolumeRoot,
    IDiskQuotaUser *pOwner,
    COwnerList *pOwnerList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::AddFilesToOwnerList")));
    DBGASSERT((NULL != hVolumeRoot));
    DBGASSERT((NULL != pOwner));
    DBGASSERT((NULL != pOwnerList));

    struct
    {
        ULONG Restart;
        BYTE Sid[MAX_SID_LEN];
    }FsCtlInput;

    NTSTATUS status = ERROR_SUCCESS;

    if (m_bAbort)
    {
        return S_OK;
    }

    //
    // Get owner's SID.
    //
    HRESULT hr = pOwner->GetSid(FsCtlInput.Sid, sizeof(FsCtlInput.Sid));
    if (FAILED(hr))
    {
        DBGERROR((TEXT("IDiskQuotaUser::GetSid failed with hr = 0x%08X"), hr));
        return hr;
    }

    //
    // Add the owner to the owner-file list.
    //
    int iOwner = pOwnerList->AddOwner(pOwner);

    IO_STATUS_BLOCK iosb;
    FsCtlInput.Restart = 1;
    BYTE Output[1024];
    bool bPathIsRemote = false;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;

    //
    // Determine if the volume is a remote device.  This will affect
    // our handling of the paths returned by NtQueryInformationFile.
    //
    status = NtQueryVolumeInformationFile(
                    hVolumeRoot,
                    &iosb,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation);
                    
    if (NT_SUCCESS(status))
    {
        bPathIsRemote = (FILE_REMOTE_DEVICE == DeviceInfo.Characteristics);
    }

    while (!m_bAbort)
    {
        status = NtFsControlFile(hVolumeRoot,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &iosb,
                                 FSCTL_FIND_FILES_BY_SID,
                                 &FsCtlInput,
                                 sizeof(FsCtlInput),
                                 Output,
                                 sizeof(Output));

        FsCtlInput.Restart = 0;

        if (!NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
        {
            DBGERROR((TEXT("NtFsControlFile failed with status 0x%08X"), status));
            return HRESULT_FROM_NT(status);
        }

        if (0 == iosb.Information)
        {
            //
            // No more data.
            //
            break;
        }

        PFILE_NAME_INFORMATION pFileNameInfo = (PFILE_NAME_INFORMATION)Output;

        while (!m_bAbort && ((PBYTE)pFileNameInfo < Output + iosb.Information))
        {
            ULONG Length = sizeof(FILE_NAME_INFORMATION) - sizeof(WCHAR) +
                           pFileNameInfo->FileNameLength;

            CNtHandle hChild;
            WCHAR szChild[MAX_PATH];

            RtlMoveMemory(szChild, pFileNameInfo->FileName, pFileNameInfo->FileNameLength);
            szChild[pFileNameInfo->FileNameLength / sizeof(WCHAR)] = L'\0';
            status = OpenNtObject(szChild,
                                  hVolumeRoot,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  FILE_READ_ATTRIBUTES,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  FILE_OPEN,
                                  hChild.HandlePtr());

            if (!NT_SUCCESS(status))
            {
                DBGERROR((TEXT("Unable to open file \"%s\".  Status = 0x%08X"),
                         szChild, status));
            }
            else if (!m_bAbort)
            {
                //
                // Directory entries get a slightly different treatment so
                // we need to know if an entry is a directory or not.
                //
                bool bIsDirectory = false;
                IO_STATUS_BLOCK iosb2;
                FILE_BASIC_INFORMATION fbi;
                status = NtQueryInformationFile(hChild,
                                                &iosb2,
                                                &fbi,
                                                sizeof(fbi),
                                                FileBasicInformation);
                if (!NT_SUCCESS(status))
                {
                    DBGERROR((TEXT("NtQueryInformationFile failed with status 0x%08X for \"%s\""),
                              status, szChild));
                }
                else if (0 != (FILE_ATTRIBUTE_DIRECTORY & fbi.FileAttributes))
                {
                    bIsDirectory = true;
                }
                
                //
                // Get the file's name (full path).
                //
                WCHAR szFile[MAX_PATH + 10];
                status = NtQueryInformationFile(hChild,
                                                &iosb2,
                                                szFile,
                                                sizeof(szFile),
                                                FileNameInformation);

                if (!NT_SUCCESS(status))
                {
                    DBGERROR((TEXT("NtQueryInformation file failed with status 0x%08X for \"%s\""),
                              status, szChild));
                }
                else if (!m_bAbort)
                {
                    PFILE_NAME_INFORMATION pfn = (PFILE_NAME_INFORMATION)szFile;
                    pfn->FileName[pfn->FileNameLength / sizeof(WCHAR)] = L'\0';
                    CPath path;

                    //
                    // If the path is remote, NtQueryInformationFile returns
                    // a string like this:
                    //
                    //  \server\share\dir1\dir2\file.ext
                    //
                    // If the path is local, NtQueryInformationFile returns
                    // a string like this:
                    //
                    //  \dir1\dir2\file.ext
                    //
                    // For remote paths we merely prepend a '\' to create a
                    // valid UNC path.  For local paths we prepend the local
                    // drive specification.
                    //
                    if (bPathIsRemote)
                    {
                        path = L"\\";
                        path += CString(pfn->FileName);
                    }
                    else
                    {
                        path = pszVolumeRoot;
                        path.Append(pfn->FileName);
                    }
                    DBGPRINT((DM_VIEW, DL_LOW, TEXT("Adding \"%s\""), path.Cstr()));
                    pOwnerList->AddFile(iOwner, path, bIsDirectory);
                }
            }
            hChild.Close();

            pFileNameInfo =
                (PFILE_NAME_INFORMATION) Add2Ptr(pFileNameInfo, QuadAlign(Length));
        }
    }
    return NOERROR;
}


//
// Build a list of files owned by a set of users on a particular volume.
// pszVolumeRoot is the volume root directory (i.e. "C:\").
// rgpOwners is an array of user object pointers, one for each owner.
// pOwnerList is the container where the resulting filenames are placed.
// Calls AddFilesToOwnerList() for each owner in rgpOwners.
//
HRESULT
CFileOwnerDialog::BuildFileOwnerList(
    LPCTSTR pszVolumeRoot,
    const CArray<IDiskQuotaUser *>& rgpOwners,
    COwnerList *pOwnerList
    )
{
    DBGTRACE((DM_VIEW, DL_MID, TEXT("CFileOwnerDialog::BuildFileOwnerList")));
    HRESULT hr = NOERROR;
    CNtHandle hVolumeRoot;
    NTSTATUS status = OpenNtObject(pszVolumeRoot,
                                   NULL,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   FILE_READ_ATTRIBUTES,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_OPEN,
                                   hVolumeRoot.HandlePtr());

    if (!NT_SUCCESS(status))
        return HRESULT_FROM_NT(status);

    int cOwners = rgpOwners.Count();
    for (int i = 0; i < cOwners && !m_bAbort; i++)
    {
        hr = AddFilesToOwnerList(pszVolumeRoot, hVolumeRoot, rgpOwners[i], pOwnerList);
    }
    return hr;
}


//
// MarkZ had this function in his original implementation so I just
// kept it.  I did need to fix a bug in the original code.  He was
// calling RtlFreeHeap() on str.Buffer for all cases.  This is was
// not applicable in the RtlInitUnicodeString() case where the
// unicode string is merely bound to the pszFile argument.
//
NTSTATUS
CFileOwnerDialog::OpenNtObject (
    LPCWSTR pszFile,
    HANDLE RelatedObject,
    ULONG CreateOptions,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    ULONG CreateDisposition,
    HANDLE *ph)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING str;
    IO_STATUS_BLOCK isb;
    bool bFreeString = false;

    if (NULL == RelatedObject)
    {
        RtlDosPathNameToNtPathName_U(pszFile, &str, NULL, NULL);
        bFreeString = true;
    }
    else
    {
        //
        // This just attaches pszFile to the rtl string.
        // We don't free it.
        //
        RtlInitUnicodeString(&str, pszFile);
    }

    InitializeObjectAttributes(&oa,
                               &str,
                               OBJ_CASE_INSENSITIVE,
                               RelatedObject,
                               NULL);

    status = NtCreateFile(ph,
                          DesiredAccess | SYNCHRONIZE,
                          &oa,
                          &isb,
                          NULL,                   // pallocationsize (none!)
                          FILE_ATTRIBUTE_NORMAL,
                          ShareAccess,
                          CreateDisposition,
                          CreateOptions,
                          NULL,                   // EA buffer (none!)
                          0);

    if (bFreeString)
        RtlFreeHeap(RtlProcessHeap(), 0, str.Buffer);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\progress.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: progress.cpp

    Description: Implements the various flavors of progress dialogs used
        in the quota UI.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "progress.h"
#include "resource.h"


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SendToProgressBar [inline]

    Description: Inline function that sends a message to the dialog's
        progress bar control.  If there is no progress bar control, the
        function returns FALSE.

    Arguments: Standard Win32 message arguments.

    Returns:
        If progress bar window exists, returns the result of SendMessage.
        Otherwise, returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
inline INT_PTR
ProgressDialog::SendToProgressBar(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (NULL != m_hwndProgressBar)
        return SendMessage(m_hwndProgressBar, uMsg, wParam, lParam);
    else
        return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressDialog

    Description: Class constructor for progress dialog base class.

    Arguments:
        idDialogTemplate - ID number for the dialog's resource template.

        idProgressBar - ID number for the progress bar control.

        idTxtDescription - ID number for text description in dialog.

        idTxtFileName - ID number for file name field in dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ProgressDialog::ProgressDialog(
    UINT idDialogTemplate,
    UINT idProgressBar,
    UINT idTxtDescription,
    UINT idTxtFileName
    ) : m_idDialogTemplate(idDialogTemplate),
        m_idProgressBar(idProgressBar),
        m_idTxtDescription(idTxtDescription),
        m_idTxtFileName(idTxtFileName),
        m_hWnd(NULL),
        m_bUserCancelled(FALSE)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("ProgressDialog::ProgressDialog")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    //
    // Do nothing.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::~ProgressDialog

    Description: Class destructor for progress dialog base class.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
ProgressDialog::~ProgressDialog(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("ProgressDialog::~ProgressDialog")));
    DBGPRINT((DM_VIEW, DL_HIGH, TEXT("\tthis = 0x%08X"), this));
    //
    // Call the Destroy() function to destroy the progress dialog window.
    //
    Destroy();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Create

    Description: Creates the dialog.

    Arguments:
        hInstance - Instance handle for the DLL containing the dialog
            resource template.

        hwndParent - Parent window for dialog.

    Returns:
        TRUE  = Dialog was created.
        FALSE = Dialog was not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
ProgressDialog::Create(
    HINSTANCE hInstance,
    HWND hwndParent
    )
{
    m_hWnd = CreateDialogParam(hInstance,
                               MAKEINTRESOURCE(m_idDialogTemplate),
                               hwndParent,
                               DlgProc,
                               (LPARAM)this);
    if (NULL != m_hWnd)
    {
        m_hwndProgressBar = GetDlgItem(m_hWnd, m_idProgressBar);
        DBGASSERT((NULL != m_hwndProgressBar));
    }
    return (NULL != m_hWnd);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Destroy

    Description: Destroys the dialog window.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Destroy(
    VOID
    )
{
    //
    // Note that m_hWnd is set to NULL in OnDestroy().
    //
    if (NULL != m_hWnd)
        DestroyWindow(m_hWnd);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::DlgProc [static]

    Description: Message procedure for the dialog.

    Arguments: Standard Win32 message proc arguments.

    Returns: Standard Win32 message proc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
ProgressDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    ProgressDialog *pThis = (ProgressDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
            //
            // Store "this" ptr in window's userdata.
            //
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
            pThis = (ProgressDialog *)lParam;
            //
            // Description text control is hidden by default.
            // Calling SetDescription() will show it.
            //
            ShowWindow(GetDlgItem(hwnd, pThis->m_idTxtDescription), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, pThis->m_idTxtFileName),    SW_HIDE);
            //
            // Center dialog in it's parent.
            //
            ::CenterPopupWindow(hwnd);
            //
            // Let derived classes respond to WM_INITDIALOG.
            //
            return pThis->OnInitDialog(hwnd, wParam, lParam);

        case WM_DESTROY:
            //
            // Let derived classes respond to WM_DESTROY.
            //
            return pThis->OnDestroy(hwnd);

        case WM_COMMAND:
            if (IDCANCEL == LOWORD(wParam))
            {
                //
                // User pressed "Cancel" button.
                // Set the "User cancelled" flag and let derived
                // classes respond to the cancellation.
                //
                pThis->m_bUserCancelled = TRUE;
                return pThis->OnCancel(hwnd, wParam, lParam);
            }
            break;

    }
    if (NULL != pThis)
    {
        //
        // Let derived classes respond to any message if they wish.
        // Note that only WM_INITDIALOG, WM_DESTROY and the "user cancelled"
        // events are the only special cases.
        //
        return pThis->HandleMessage(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::HandleMessage

    Description: Base class implementation of virtual function.  Derived
        classes can provide an implementation to handle any message other than
        WM_INITDIALOG or WM_DESTROY.  These two messages have their own
        virtual message handlers.

    Arguments: Standard Win32 message proc arguments.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::HandleMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnInitDialog

    Description: Base class implementation of virtual function.  Called
        when the base class receives WM_INITDIALOG.  Derived classes can
        provide an implementation if they wish to perform some operation
        in response to WM_INITDIALOG.

    Arguments:
        hwnd - Dialog window handle.

        wParam, lParam - Standard Win32 message proc arguments.

    Returns: Always returns TRUE so that USER will set the control focus.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnInitDialog(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnDestroy

    Description: Base class implementation of virtual function.  Called
        when the base class receives WM_DESTROY.  Derived classes can
        provide an implementation if they wish to perform some operation
        in response to WM_DESTROY.  Before returning, any derived implementation
        must call the base class implementation so that m_hWnd is properly
        set to NULL.

    Arguments:
        hwnd - Dialog window handle.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnDestroy(
    HWND hwnd
    )
{
    m_hWnd = NULL;
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::OnCancel

    Description: Base class implementation of virtual function.  Called
        when the user presses the "Cancel" button in the dialog.  This
        implementation assumes that the Cancel button is assigned the ID
        of IDCANCEL (standard).

    Arguments:
        hwnd - Dialog window handle.

        wParam, lParam - Standard Win32 message proc arguments.

    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
ProgressDialog::OnCancel(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::FlushMessages

    Description: While the dialog is active, call this periodically so that
        the thread is able to properly update the dialog and respond to the
        user pressing "Cancel".

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::FlushMessages(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        //
        // Process messages for the dialog's parent and all of it's children.
        //
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) &&
               WM_QUIT != msg.message)
        {
            GetMessage(&msg, NULL, 0, 0);
            if (!IsDialogMessage(m_hWnd, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetTitle

    Description: Sets the title string in the dialog.

    Arguments:
        pszTitle - Address of title string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetTitle(
    LPCTSTR pszTitle
    )
{
    DBGASSERT((NULL != pszTitle));
    if (NULL != m_hWnd)
    {
        if (0 == ((DWORD_PTR)pszTitle & ~0xffff))
        {
            TCHAR szText[MAX_PATH] = { TEXT('\0') };
            LoadString(g_hInstDll, (DWORD)((DWORD_PTR)pszTitle), szText, ARRAYSIZE(szText));
            pszTitle = szText;
        }
        SetWindowText(m_hWnd, pszTitle);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetDescription

    Description: Sets the progress description string in the dialog.

    Arguments:
        pszDescription - Address of description string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetDescription(
    LPCTSTR pszDescription
    )
{
    DBGASSERT((NULL != pszDescription));
    if (NULL != m_hWnd)
    {
        if (0 == ((DWORD_PTR)pszDescription & ~0xffff))
        {
            TCHAR szText[MAX_PATH] = { TEXT('\0') };
            LoadString(g_hInstDll, (DWORD)((DWORD_PTR)pszDescription), szText, ARRAYSIZE(szText));
            pszDescription = szText;
        }
        SetWindowText(GetDlgItem(m_hWnd, m_idTxtDescription), pszDescription);
        //
        // Description control is by default hidden.
        //
        ShowWindow(GetDlgItem(m_hWnd, m_idTxtDescription), SW_NORMAL);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::SetFileName

    Description: Sets the file name description string in the dialog.
        If the file name is too long, it is formatted with ellipses to
        fit in the space provided.

    Arguments:
        pszFileName - Address of file name string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::SetFileName(
    LPCTSTR pszFileName
    )
{
    DBGASSERT((NULL != pszFileName));
    if (NULL != m_hWnd)
    {
        HWND hwndCtl   = GetDlgItem(m_hWnd, m_idTxtFileName);
        HDC hdc        = GetDC(hwndCtl);
        RECT rc;
        LPTSTR pszText = StringDup(pszFileName);

        if (NULL != pszText)
        {
            GetClientRect(hwndCtl, &rc);

            DrawText(hdc,
                     pszText,
                     -1,
                     &rc,
                     DT_CENTER |
                     DT_PATH_ELLIPSIS |
                     DT_MODIFYSTRING);

            SetWindowText(hwndCtl, pszText);
            delete[] pszText;

            //
            // FileName control is by default hidden.
            //
            ShowWindow(hwndCtl, SW_NORMAL);
        }
        FlushMessages();
        ReleaseDC(hwndCtl, hdc);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarInit

    Description: Initializes the progress bar control with range and step
        values.  If this function is not called, the progress bar defaults
        to:
            iMin  =   0
            iMax  = 100
            iStep =  10

    Arguments:
        iMin - Minimum range value.

        iMax - Maximum range value.

        iStep - Amount bar advances each time PBM_STEPIT is received.

    Returns:
        TRUE  = Progress bar control accepted settings.
        FALSE = Progress bar rejected settings.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
ProgressDialog::ProgressBarInit(
    UINT iMin,
    UINT iMax,
    UINT iStep
    )
{
    BOOL bResult = FALSE;

    if (0 != SendToProgressBar(PBM_SETSTEP,  iStep, 0))
        bResult = (0 != SendToProgressBar(PBM_SETRANGE, 0, MAKELPARAM(iMin, iMax)));

    FlushMessages();
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarReset

    Description: Resets the progres bar position at 0.

    Arguments: None.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarReset(
    VOID
    )
{
    UINT iReturn = (UINT)ProgressBarSetPosition(0);
    FlushMessages();
    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarAdvance

    Description: Advances the progress bar a given number of counts.

    Arguments:
        iDelta - Number of counts to advance.  If -1, the bar is advanced
            by the step value supplied in ProgressBarInit.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarAdvance(
    UINT iDelta
    )
{
    UINT iReturn;
    if ((UINT)-1 == iDelta)
        iReturn = (UINT)SendToProgressBar(PBM_STEPIT, 0, 0);
    else
        iReturn = (UINT)SendToProgressBar(PBM_DELTAPOS, (WPARAM)iDelta, 0);

    FlushMessages();

    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::ProgressBarSetPosition

    Description: Advances the progress bar to a specific position.

    Arguments:
        iPosition - Specific position count.

    Returns:  Previous "position" of progress bar.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT
ProgressDialog::ProgressBarSetPosition(
    UINT iPosition
    )
{
    UINT iReturn = (UINT)SendToProgressBar(PBM_SETPOS, (WPARAM)iPosition, 0);
    FlushMessages();
    return iReturn;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Show

    Description: Makes the progress dialog visible.

    Arguments: None.

    Returns:  Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Show(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        ShowWindow(m_hWnd, SW_SHOWNORMAL);
        FlushMessages();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: ProgressDialog::Hide

    Description: Hides the progress dialog.

    Arguments: None.

    Returns:  Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
ProgressDialog::Hide(
    VOID
    )
{
    if (NULL != m_hWnd)
    {
        ShowWindow(m_hWnd, SW_HIDE);
        FlushMessages();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dskquoui.rc
//
#define IDM_LISTVIEW_MENU               105
#define IDD_PROPPAGE_USERQUOTA          106
#define IDD_PROPPAGE_VOLQUOTA           107
#define IDM_CONTEXT_MENU                114
#define IDI_QUOTA                       117
#define IDI_SINGLE_USER                 130
#define IDI_MULTI_USER                  131
#define IDI_OKBUBBLE                    132
#define IDI_WARNERR                     134
#define IDR_KBDACCEL                    140
#define IDD_FINDUSER                    146
#define IDD_PROGRESS                    147
#define IDD_YNTOALL                     149
#define IDI_QUOTA_OPEN                  150
#define IDD_PROPPAGE_POLICY             151
#define IDD_OWNERSANDFILES              152
#define IDD_ADDUSER                     154
#define IDC_TOOLBAR                     500
#define IDC_TOOLBAR_COMBO               502
#define IDC_TXT_QUOTA_STATUS            1001
#define IDC_CBX_ENABLE_QUOTA            1002
#define IDC_CBX_DENY_LIMIT              1005
#define IDC_RBN_DEF_NOLIMIT             1006
#define IDC_RBN_DEF_LIMIT               1007
#define IDC_EDIT_DEF_LIMIT              1008
#define IDC_EDIT_DEF_THRESHOLD          1009
#define IDC_BTN_DETAILS                 1012
#define IDC_BTN_EVENTLOG                1013
#define IDC_TXT_WARN_LEVEL              1017
#define IDC_GRP_ACTIONS                 1019
#define IDC_TXT_USERNAME                1020
#define IDC_GRP_DEFAULTS                1021
#define IDC_TXT_SPACEUSED               1023
#define IDC_TXT_SPACEREMAINING          1025
#define IDC_EDIT_USER_LIMIT             1026
#define IDC_EDIT_USER_THRESHOLD         1027
#define IDC_RBN_USER_LIMIT              1028
#define IDC_RBN_USER_NOLIMIT            1029
#define IDC_CMB_DEF_LIMIT               1037
#define IDC_CMB_DEF_THRESHOLD           1038
#define IDC_CMB_USER_LIMIT              1040
#define IDC_CMB_USER_THRESHOLD          1041
#define IDC_ICON_USER                   1043
#define IDC_ICON_USERSTATUS             1044
#define IDC_TRAFFIC_LIGHT               1045
#define IDR_AVI_TRAFFIC                 1046
#define IDC_CMB_FINDUSER                1047
#define IDC_TXT_FINDUSER                1048
#define IDC_PROGRESS_BAR                1049
#define IDC_CBX_YNTOALL                 1051
#define IDC_TXT_YNTOALL                 1052
#define IDC_TXT_PROGRESS_DESCRIPTION    1054
#define IDC_TXT_PROGRESS_FILENAME       1055
#define IDC_TXT_QUOTA_STATUS_LABEL      1064
#define IDC_LV_OWNERDLG                 1071
#define IDC_CMB_OWNERDLG_OWNERS         1073
#define IDC_RBN_POLICY_FIXED            1076
#define IDC_RBN_POLICY_REMOVABLE        1077
#define IDC_BTN_OWNERDLG_DELETE         1079
#define IDC_BTN_OWNERDLG_TAKE           1080
#define IDC_BTN_OWNERDLG_MOVETO         1081
#define IDC_BTN_OWNERDLG_BROWSE         1082
#define IDC_EDIT_OWNERDLG_MOVETO        1083
#define IDC_TXT_OWNERDLG_HEADER         1084
#define IDC_CBX_LOG_OVERLIMIT           1088
#define IDC_CBX_LOG_OVERWARNING         1089
#define IDC_TXT_DEFAULTS                1090
#define IDC_TXT_LOGGING                 1091
#define IDC_LBL_SPACEUSED               1092
#define IDC_LBL_SPACEREMAINING          1093
#define IDC_STATIC2                     1094
#define IDC_CBX_OWNERDLG_EXCLUDEFILES   1095
#define IDC_CBX_OWNERDLG_EXCLUDEDIRS    1096
#define IDM_QUOTA_NEW                   40001
#define IDM_QUOTA_EDIT                  40002
#define IDM_VIEW_TOOLBAR                40003
#define IDM_VIEW_STATUSBAR              40004
#define IDM_VIEW_ARRANGE_BYNAME         40010
#define IDM_VIEW_ARRANGE_BYUSED         40011
#define IDM_VIEW_ARRANGE_BYLIMIT        40012
#define IDM_VIEW_ARRANGE_BYTHRESHOLD    40013
#define IDM_VIEW_ARRANGE_BYPERCENT      40014
#define IDM_VIEW_REFRESH                40015
#define IDM_QUOTA_PROPERTIES            40016
#define IDM_QUOTA_CLOSE                 40017
#define IDM_HELP_TOPICS                 40018
#define IDM_HELP_ABOUT                  40019
#define IDM_EDIT_SELECTALL              40020
#define IDM_EDIT_INVERTSELECTION        40021
#define IDM_VIEW_SHOWFOLDER             40025
#define IDM_QUOTA_DELETE                40026
#define IDM_HELP_ABOUTNT                40027
#define IDM_VIEW_ARRANGE_BYFOLDER       40035
#define IDM_VIEW_ARRANGE_BYSTATUS       40036
#define IDM_DEBUG_DUMP                  40038
#define IDM_CLEAR_CACHE                 40039
#define IDM_EDIT_UNDO                   40040
#define IDM_EDIT_COPY                   40041
#define IDM_EDIT_FIND                   40042
#define IDM_EDIT_FIND_LIST              40043
#define IDM_QUOTA_IMPORT                40044
#define IDM_QUOTA_EXPORT                40045
#define IDS_WINDOWS                     40500
#define IDS_TOOLBAR_COMBO               40517
#define IDS_PROGRESS_IMPORTING          40518
#define IDS_PROGRESS_DELETING           40519
#define IDS_STATUS_OK                   40523
#define IDS_STATUS_WARNING              40524
#define IDS_STATUS_OVERLIMIT            40525
#define IDS_STATUS_UNKNOWN              40526
#define IDS_STATUS_DISABLED             40527
#define IDS_STATUS_ACTIVE               40528
#define IDS_STATUS_REBUILDING           40530
#define IDS_TITLE_DISK_QUOTA            40531
#define IDS_TITLE_COL_FOLDER            40532
#define IDS_TITLE_COL_USERNAME          40533
#define IDS_TITLE_COL_STATUS            40534
#define IDS_TITLE_COL_AMTUSED           40535
#define IDS_TITLE_COL_PCTUSED           40536
#define IDS_TITLE_COL_LIMIT             40537
#define IDS_TITLE_COL_THRESHOLD         40538
#define IDS_REPORT_HEADER_FOLDER        40539
#define IDS_REPORT_HEADER_USERNAME      40540
#define IDS_REPORT_HEADER_STATUS        40541
#define IDS_REPORT_HEADER_AMTUSED       40542
#define IDS_REPORT_HEADER_LIMIT         40543
#define IDS_REPORT_HEADER_THRESHOLD     40544
#define IDS_REPORT_HEADER_PCTUSED       40545
#define IDS_QUOTA_USED_SINGLEUSER       40546
#define IDS_TITLE_MULTIUSER             40547
#define IDS_TITLE_EDIT_USER             40548
#define IDS_TITLE_ADD_USER              40549
#define IDS_NOADD_EXISTING_USER         40550
#define IDS_NOADD_UNKNOWN_USER          40551
#define IDS_STATUSBAR_ITEMCOUNT         40554
#define IDS_STATUSBAR_ITEMCOUNT_STALE   40555
#define IDS_TITLE_MAINWINDOW            40556
#define IDS_USER_ACCOUNT_UNAVAILABLE    40557
#define IDS_USER_ACCOUNT_UNRESOLVED     40558
#define IDS_USER_ACCOUNT_UNKNOWN        40559
#define IDS_USER_ACCOUNT_INVALID        40560
#define IDS_USER_ACCOUNT_DELETED        40561
#define IDS_NOT_APPLICABLE              40562
#define IDS_DISABLE_QUOTA_WARNING       40564
#define IDS_ENABLE_QUOTA_WARNING        40565
#define IDS_OUTOFMEMORY                 40566
#define IDS_UNKNOWN_EXCEPTION           40567
#define IDS_UNKNOWN_ERROR               40568
#define IDS_NO_WRITE_ACCESS             40569
#define IDS_WRITE_ERROR                 40570
#define IDS_CANNOT_DELETE_USER          40571
#define IDS_CANNOT_DELETE_USERS         40572
#define IDS_ERROR_DELETE_USER           40573
#define IDS_ERROR_FILE_NOT_FOUND        40574
#define IDS_ERROR_FILE_CORRUPT          40575
#define IDS_ERROR_DDE_EXECUTE           40576
#define IDS_CONFIRM_DELETE_USER         40577
#define IDS_APPLY_SETTINGS_ERROR        40578
#define IDS_CANT_SET_ADMIN_LIMIT        40582
#define IDS_CANT_DELETE_ADMIN_RECORD    40583
#define IDS_USER_NOT_FOUND_IN_LISTVIEW  40584
#define IDS_EXPORT_STREAM_FAILED        40585
#define IDS_EXPORT_STREAM_NOACCESS      40586
#define IDS_EXPORT_STREAM_OUTOFMEMORY   40587
#define IDS_EXPORT_STREAM_INVALIDNAME   40588
#define IDS_EXPORT_STREAM_TOOMANYFILES  40589
#define IDS_EXPORT_STREAM_FILENAME_TEMPLATE 40590
#define IDS_IMPORT_STREAM_INVALID_STREAM 40591
#define IDS_IMPORT_STREAM_READ_ERROR    40592
#define IDS_IMPORT_STREAM_NOACCESS      40593
#define IDS_IMPORT_STREAM_OUTOFMEMORY   40594
#define IDS_IMPORT_STREAM_INVALIDNAME   40595
#define IDS_IMPORT_STREAM_TOOMANYFILES  40596
#define IDS_IMPORT_STREAM_FILENOTFOUND  40597
#define IDS_IMPORT_REPLACE_RECORD       40598
#define IDS_TT_QUOTA_NEW                40599
#define IDS_TT_QUOTA_DELETE             40600
#define IDS_TT_QUOTA_PROPERTIES         40601
#define IDS_TT_EDIT_UNDO                40602
#define IDS_TT_EDIT_FIND                40603
#define IDS_TITLE_EDIT_MULTIUSER        40605
#define IDS_TITLE_GENERAL               40606
#define IDS_TITLE_GETUSER_DIALOG        40607
#define IDS_FMT_ERR_ADDUSER             40608
#define IDS_MULTIPLE                    40609
#define IDS_PROGRESS_ADDUSER            40610
#define IDS_SNAPIN_COLUMN               40611
#define IDS_SNAPIN_RESULTNAME           40613
#define IDS_SNAPIN_SCOPENAME            40614
#define IDS_SNAPIN_NAME                 40615
#define IDS_VERB_OPEN                   40616
#define IDS_SNAPIN_POLICYDLG_TITLE      40617
#define IDS_OWNERDLG_HDR_FILE           40618
#define IDS_OWNERDLG_HDR_FOLDER         40619
#define IDS_OWNERDLG_HDR_OWNER          40620
#define IDS_FMT_ALLOWNERS               40621
#define IDS_FMT_OWNER                   40622
#define IDS_FMT_OWNERDLG_HEADER         40623
#define IDS_BROWSEFORFOLDER             40624
#define IDS_ERROR_MOVETO_SAMEVOL        40625
#define IDS_FMT_DISPLAY_LOGON_CONTAINER 40626
#define IDS_FMT_LOGON_CONTAINER         40627
#define IDS_FMT_DISPLAY_LOGON           40629
#define IDS_TITLE_COL_LOGONNAME         40630
#define IDS_REPORT_HEADER_LOGONNAME     40631
#define IDM_VIEW_ARRANGE_BYLOGONNAME    40632
#define IDS_PROGRESS_SEARCHINGFORFILES  40633
#define IDS_FMT_ERR_WARNOVERLIMIT       40634
#define IDS_FMT_MOUNTEDVOL_DISPLAYNAME  40636
#define IDS_EXPORT_STREAM_FILENAME_TEMPLATE_VOLSN 40637
#define IDS_DLGTITLE_IMPORT             40638
#define IDS_DLGTITLE_EXPORT             40639
#define IDS_FMT_OWNERDLG_FOLDERNAME     40640

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        155
#define _APS_NEXT_COMMAND_VALUE         40047
#define _APS_NEXT_CONTROL_VALUE         1096
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\progress.h ===
#ifndef _INC_DSKQUOTA_PROGRESS_H
#define _INC_DSKQUOTA_PROGRESS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: progress.h

    Description: Declarations for class ProgressDialog.  Any derivative
        classes should also be declared here.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
class ProgressDialog
{
    private:
        UINT   m_idDialogTemplate;
        UINT   m_idProgressBar;
        UINT   m_idTxtDescription;
        UINT   m_idTxtFileName;
        HWND   m_hwndProgressBar;
        BOOL   m_bUserCancelled;

        static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
        INT_PTR SendToProgressBar(UINT, WPARAM, LPARAM);

    protected:

        virtual INT_PTR HandleMessage(HWND, UINT, WPARAM, LPARAM);
        virtual INT_PTR OnInitDialog(HWND, WPARAM, LPARAM);
        virtual INT_PTR OnDestroy(HWND);
        virtual INT_PTR OnCancel(HWND, WPARAM, LPARAM);

    public:
        HWND m_hWnd;

        ProgressDialog(UINT idDialogTemplate,
                       UINT idProgressBar,
                       UINT idTxtDescription,
                       UINT idTxtFileName);

        ~ProgressDialog(VOID);

        UINT DialogID(VOID)
            { return m_idDialogTemplate; }

        BOOL UserCancelled(VOID)
            { return m_bUserCancelled; }

        virtual BOOL Create(HINSTANCE hInstance, HWND hwndParent);
        virtual VOID Destroy(VOID);
        virtual BOOL ProgressBarInit(UINT iMin, UINT iMax, UINT iStep);
        virtual UINT ProgressBarReset(VOID);
        virtual UINT ProgressBarAdvance(UINT iDelta = (UINT)-1);
        virtual UINT ProgressBarSetPosition(UINT iPosition);
        virtual VOID FlushMessages(VOID);
        virtual VOID SetTitle(LPCTSTR pszTitle);
        virtual VOID SetDescription(LPCTSTR pszDescription);
        virtual VOID SetFileName(LPCTSTR pszFileName);
        virtual VOID Show(VOID);
        virtual VOID Hide(VOID);
};

#endif // _INC_DSKQUOTA_PROGRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\prshtext.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: prshtext.cpp

    Description: DSKQUOTA property sheet extention implementation.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    07/03/97    Added m_hrInitialization member.                     BrianAu
    01/23/98    Removed m_hrInitialization member.                   BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"  // PCH
#pragma hdrstop

#include "dskquota.h"
#include "prshtext.h" 
#include "guidsp.h"

extern LONG g_cLockThisDll;


DiskQuotaPropSheetExt::DiskQuotaPropSheetExt(
    VOID
    ) : m_cRef(0),
        m_dwDlgTemplateID(0),
        m_lpfnDlgProc(NULL),
        m_hPage(NULL),
        m_pQuotaControl(NULL),
        m_cOleInitialized(0)
{
    DBGTRACE((DM_PRSHTEXT, DL_HIGH, TEXT("DiskQuotaPropSheetExt::DiskQuotaPropSheetExt")));
    InterlockedIncrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt

    Description: Destructor for the property sheet extension class.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt(VOID)
{
    DBGTRACE((DM_PRSHTEXT, DL_HIGH, TEXT("DiskQuotaPropSheetExt::~DiskQuotaPropSheetExt")));

    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    //
    // Call OleUninitialize for each time OleInitialize was called in Initialize().
    //
    while(0 != m_cOleInitialized--)
    {
        DBGASSERT((0 <= m_cOleInitialized)); // Make sure we don't go negative.
        CoUninitialize();
    }

    InterlockedDecrement(&g_cRefThisDll);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::QueryInterface

    Description: Returns an interface pointer to the object's IUnknown
        and IShellPropSheetExt interfaces.  

    Arguments:
        riid - Reference to requested interface ID.

        ppvOut - Address of interface pointer variable to accept interface ptr.

    Returns:
        NO_ERROR        - Success.
        E_NOINTERFACE   - Requested interface not supported.
        E_INVALIDARG    - ppvOut argument was NULL.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
DiskQuotaPropSheetExt::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    HRESULT hResult = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || 
        IID_IShellPropSheetExt == riid
#ifdef POLICY_MMC_SNAPIN
        || IID_ISnapInPropSheetExt == riid     // This is not a "real" interface.
#endif 
        )
    {
        *ppvOut = this;
    }

#ifdef POLICY_MMC_SNAPIN
    else if (IID_IDiskQuotaPolicy == riid)
    {
        hResult = CreateDiskQuotaPolicyObject(reinterpret_cast<IDiskQuotaPolicy **>(ppvOut));
    }
#endif

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hResult = NOERROR;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::AddRef

    Description: Increments object reference count.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaPropSheetExt::AddRef(
    VOID
    )
{
    ULONG ulReturn = m_cRef + 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaPropSheetExt::AddRef, 0x%08X  %d -> %d\n"),
             this, ulReturn - 1, ulReturn));

    InterlockedIncrement(&m_cRef);

    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::Release

    Description: Decrements object reference count.  If count drops to 0,
        object is deleted.

    Arguments: None.

    Returns: New reference count value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
DiskQuotaPropSheetExt::Release(
    VOID
    )
{
    ULONG ulReturn = m_cRef - 1;

    DBGPRINT((DM_COM, DL_HIGH, TEXT("DiskQuotaPropSheetExt::Release, 0x%08X  %d -> %d\n"),
             this, ulReturn + 1, ulReturn));

    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::Initialize

    Description: Initializes a new property sheet extension object.

    Arguments:
        idVolume - Reference to a CVolumeID object containing both parsable
                   and displayable names for the volume.  In the case of
                   normal volumes, this is the same string.  In the case
                   of mounted volumes, it may not be depending on what's
                   provided by the OS for the mounted volume.  Most mounted
                   volumes have names like "\\?\Volume{ GUID }\".

        dwDlgTemplateID - Resource ID for the dialog template to use for the
            property sheet.

        lpfnDlgProc - Address of dialog's window message procedure.

    Returns:
        NO_ERROR            - Success.
        ERROR_ACCESS_DENIED (hr) - Read access denied to the device.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/27/98    Replaced volume name arg with CVolumeID arg to       BrianAu
                support mounted volumes.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
DiskQuotaPropSheetExt::Initialize(
    const CVolumeID& idVolume,
    DWORD dwDlgTemplateID,
    DLGPROC lpfnDlgProc
    )
{
    HRESULT hResult = NO_ERROR;

    DBGASSERT((NULL != lpfnDlgProc));
    DBGASSERT((0    != dwDlgTemplateID));

    m_idVolume        = idVolume;
    m_dwDlgTemplateID = dwDlgTemplateID;
    m_lpfnDlgProc     = lpfnDlgProc;

    //
    // Volume parsing name will be blank for a snap-in prop page since
    // it isn't displayed on behalf of any particular volume.
    //
    if (!m_idVolume.ForParsing().IsEmpty())
    {
        hResult = CoInitialize(NULL);
        if (SUCCEEDED(hResult))
        {
            IDiskQuotaControl *pqc;
            m_cOleInitialized++;  // Need to call OleUninitialize once more in dtor.

            //
            // Validate that we can use quotas by instantiating the quota control
            // object.  If this fails the user probably doesn't have access
            // to manipulate quotas.
            //
            hResult = GetQuotaController(&pqc);
            if (SUCCEEDED(hResult))
            {
                pqc->Release();
                //
                // Also release the cached m_pQuotaControl ptr.  
                // We don't want to hold open a handle to the volume if our
                // page is not active.
                //
                m_pQuotaControl->Release();
                m_pQuotaControl = NULL;
            }
        }
    }

    return hResult;
}

//
// Get a pointer to the IDiskQuotaControl interface.
// If the cached m_pQuotaControl ptr is non-NULL we merely AddRef this
// and return it to the caller. Otherwise we CoCreate a new controller,
// cache the pointer in m_pQuotaControl and return that.
// 
// History:  
//  Originally we opened the controller in ::Initialize() and cached
//  the pointer in m_pQuotaControl.  The controller remained alive 
//  until the prop SHEET was destroyed.  This was holding open a handle
//  to the volume device which prevented the disk checking function 
//  on the "Tools" page from accessing the volume.  Therefore I 
//  changed the code so that now we call GetQuotaController whenever
//  we want an IDiskQuotaControl pointer.  The caller releases that
//  ptr when done with it.  Whenever the prop page becomes inactive
//  we release the cached m_pQuotaControl.  This ensures that the 
//  code has the volume open only when the page is active.
//  [brianau - 5/21/99]
//  
//
HRESULT
DiskQuotaPropSheetExt::GetQuotaController(
    IDiskQuotaControl **ppqc
    )
{
    HRESULT hr = NOERROR;

    *ppqc = NULL;
    if (NULL == m_pQuotaControl)
    {
        //
        // No cached ptr.  Create a new controller.
        //
        hr = CoCreateInstance(CLSID_DiskQuotaControl,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDiskQuotaControl,
                              (LPVOID *)&m_pQuotaControl);

        if (SUCCEEDED(hr))
        {
            hr = m_pQuotaControl->Initialize(m_idVolume.ForParsing(), TRUE);
            if (FAILED(hr))
            {
                m_pQuotaControl->Release();
                m_pQuotaControl = NULL;
            }
        }
    }

    if (NULL != m_pQuotaControl)
    {
        //
        // Ptr is cached.  Merely addref and return it.
        //
        *ppqc = m_pQuotaControl;
        static_cast<IUnknown *>(*ppqc)->AddRef();
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::AddPages

    Description: Called by the shell when a page is to be added to the property
        sheet.

    Arguments:
        lpfnAddPage - Address of a callback function provided by the shell 
            that is to be called if the property page creation succedes.

        lParam - Parameter to pass to lpfnAddPage function.

    Returns:
        NO_ERROR            - Success.
        E_FAIL              - Failed to create or add page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
DiskQuotaPropSheetExt::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam
    )
{
    HRESULT hResult = E_FAIL; // Assume failure.

    PROPSHEETPAGE psp;

    psp.dwSize          = sizeof(psp);
    psp.dwFlags         = PSP_USECALLBACK | PSP_USEREFPARENT;
    psp.hInstance       = g_hInstDll;
    psp.pszTemplate     = MAKEINTRESOURCE(m_dwDlgTemplateID);
    psp.hIcon           = NULL;
    psp.pszTitle        = NULL;
    psp.pfnDlgProc      = m_lpfnDlgProc;
    psp.lParam          = (LPARAM)this;
    psp.pcRefParent     = (UINT *)& g_cRefThisDll;
    psp.pfnCallback     = (LPFNPSPCALLBACK)PropSheetPageCallback;

    m_hPage = CreatePropertySheetPage(&psp);
    if (NULL != m_hPage)
    {
        if (!lpfnAddPage(m_hPage, lParam))
        {
            DBGERROR((TEXT("PRSHTEXT - Failed to add page.\n")));
            DestroyPropertySheetPage(m_hPage);
            m_hPage = NULL;
        }
    }
    else
    {
        DBGERROR((TEXT("PRSHTEXT - CreatePropertySheetPage failed.\n")));
    }
    if (NULL != m_hPage)
    {
        //
        // Incr ref count to keep the extension object alive.
        // The shell will release it as soon as the page is created.
        // We'll release it on PSPCB_RELEASE in PropSheetPageCallback.
        //
        AddRef();
        hResult = NO_ERROR;
    }

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DiskQuotaPropSheetExt::PropSheetPageCallback

    Description: Called by the property sheet code when the property page
        is being created and again when it is being destroyed.  This gives the
        page a chance to act at these critical points.  We primarily use it
        to call Release() on the page extension which calls the virtual
        destructor, ultimately destroying the VolumePropPage or FolderPropPage
        object.

    Arguments:
        hwnd - Always NULL (according to SDK docs).

        uMsg - PSPCB_CREATE  = Creating page.
               PSPCB_RELEASE = Destroying page.

        ppsp - Pointer to the PROPSHEETPAGE structure for the page.

    Returns:
        Return value is ignore when uMsg is PSPCB_RELEASE.
        On PSPCB_CREATE, returning 0 instructs the PropertySheet to NOT
            display the page.  1 means OK to display page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/12/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UINT CALLBACK 
DiskQuotaPropSheetExt::PropSheetPageCallback(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp	
    )
{
    UINT uReturn = 1;
    DiskQuotaPropSheetExt *pThis = (DiskQuotaPropSheetExt *)ppsp->lParam;
    DBGASSERT((NULL != pThis));

    switch(uMsg)
    {
        case PSPCB_CREATE:
            //
            // uReturn == 0 means Don't create the prop page.
            //
            uReturn = pThis->OnPropSheetPageCreate(ppsp);
            break;

        case PSPCB_RELEASE:
            //
            // uReturn is ignored for this uMsg.
            //
            pThis->OnPropSheetPageRelease(ppsp);
            //
            // This will release the extension and call the virtual
            // destructor (which will destroy the prop page object).
            //
            pThis->Release();
            break;
    }
    return uReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\prshtext.h ===
#ifndef _INC_DSKQUOTA_PRSHTEXT_H
#define _INC_DSKQUOTA_PRSHTEXT_H
///////////////////////////////////////////////////////////////////////////////
/*  File: prshtext.h

    Description: DSKQUOTA property sheet extention declaration.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
    06/27/98    Added support for mounted volumes.                   BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif

#ifndef _INC_DSKQUOTA_POLICY_H
#   include "policy.h"
#endif

//
// Base class for all DiskQuotaControl property sheet extensions.
//
class DiskQuotaPropSheetExt : public IShellPropSheetExt
{
    private:
        LONG               m_cRef;
        DWORD              m_dwDlgTemplateID;
        DLGPROC            m_lpfnDlgProc;

        static UINT CALLBACK 
        DiskQuotaPropSheetExt::PropSheetPageCallback(
            HWND hwnd,	
            UINT uMsg,	
            LPPROPSHEETPAGE ppsp);

#ifdef POLICY_MMC_SNAPIN
        //
        // This base class can't create a disk quota policy object.
        // Defer to the policy prop page derived class.
        //
        virtual HRESULT CreateDiskQuotaPolicyObject(IDiskQuotaPolicy **ppOut)
            { return E_NOINTERFACE; }
#endif

        //
        // Prevent copying.
        //
        DiskQuotaPropSheetExt(const DiskQuotaPropSheetExt&);
        DiskQuotaPropSheetExt& operator = (const DiskQuotaPropSheetExt&);

    protected:
        CVolumeID          m_idVolume;
        HPROPSHEETPAGE     m_hPage;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        INT                m_cOleInitialized;

        //
        // Subclasses can act on these notifications if they wish.
        // These are called from PropSheetPageCallback().
        //
        virtual UINT OnPropSheetPageCreate(LPPROPSHEETPAGE ppsp) 
            { return 1; }
        virtual VOID OnPropSheetPageRelease(LPPROPSHEETPAGE ppsp) { }

        HRESULT GetQuotaController(IDiskQuotaControl **ppqc);


    public:
        DiskQuotaPropSheetExt(VOID);
  
        //
        // Need to call subclass destructor when Release() 
        // destroys "this".
        //
        virtual ~DiskQuotaPropSheetExt(VOID);

        HRESULT Initialize(const CVolumeID& idVolume, 
                           DWORD dwDlgTemplateID,
                           DLGPROC lpfnDlgProc);

        //
        // IUnknown methods.
        //
        STDMETHODIMP         
        QueryInterface(
            REFIID, 
            LPVOID *);

        STDMETHODIMP_(ULONG) 
        AddRef(
            VOID);

        STDMETHODIMP_(ULONG) 
        Release(
            VOID);

        //
        // IShellPropSheetInit methods.
        //
        STDMETHODIMP
        AddPages(
            LPFNADDPROPSHEETPAGE lpfnAddPage,
            LPARAM lParam);

        STDMETHODIMP
        ReplacePage(
            UINT uPageID,
            LPFNADDPROPSHEETPAGE lpfnAddPage,
            LPARAM lParam)
                { return E_NOTIMPL; }
};

#endif // _INC_DSKQUOTA_PRSHTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\uihelp.h ===
#ifndef __UIHELP_H
#define __UIHELP_H

const TCHAR STR_DSKQUOUI_HELPFILE_HTML[]  = TEXT("DSKQUOUI.CHM > windefault");
const TCHAR STR_DSKQUOUI_HTMLHELP_TOPIC[] = TEXT("nt_diskquota_overview.htm");
const TCHAR STR_DSKQUOUI_HELPFILE[]       = TEXT("DSKQUOUI.HLP");

#define IDH_QUOTA_FIRST  (0x00000000)

//
//-----------------------------------------------------------------------------
// Volume property page IDD_PROPPAGE_VOLQUOTA
//-----------------------------------------------------------------------------
//
// The colors of the traffic light indicate the state of the volume's
// quota system.  
//
//  RED     = Quotas are not enabled on the volume.
//  YELLOW  = Quota information is being rebuilt on the volume.  Quotas
//            are not active.
//  GREEN   = Quotas are enabled on the volume.
//  
#define IDH_TRAFFIC_LIGHT           (IDH_QUOTA_FIRST +  0)
//
// Describes the status of the volume's quota system.
//
#define IDH_TXT_QUOTA_STATUS        (IDH_QUOTA_FIRST +  1)
//
// Check this to enable quotas on the volume.  Uncheck it to disable quotas.
//
#define IDH_CBX_ENABLE_QUOTA        (IDH_QUOTA_FIRST +  2)
//
// Check this to deny users disk space when they exceed their quota
// limit on the volume.
//
#define IDH_CBX_DENY_LIMIT          (IDH_QUOTA_FIRST +  4)
//
// Check this to automatically assign unlimited quota to new volume users.
//
#define IDH_RBN_DEF_NO_LIMIT        (IDH_QUOTA_FIRST +  5)
//
// Check this to automatically assign a quota limit to new volume users.
//
#define IDH_RBN_DEF_LIMIT           (IDH_QUOTA_FIRST +  6)
//
// Enter a quota limit to be automatically assigned to new volume users.
// For example: to assign 20 megabytes, enter 20 and select "MB" in the
// drop-down list.
//
#define IDH_EDIT_DEF_LIMIT          (IDH_QUOTA_FIRST +  7)
//
// Enter a quota warning threshold to be automatically assigned to new volume 
// users.  For example: to assign 18 megabytes, enter 18 and select "MB" in the
// drop-down list.
//
#define IDH_EDIT_DEF_THRESHOLD      (IDH_QUOTA_FIRST +  8)
//
// Select a unit of storage to apply to the quota limit value.  
// For example:  to assign 20 megabytes, enter 20 in the edit box and select
// "MB" in the drop-down list.
//
#define IDH_CMB_DEF_LIMIT           (IDH_QUOTA_FIRST +  9)
//
// Select a unit of storage to apply to the quota warning threshold value.  
// For example:  to assign 18 megabytes, enter 18 in the edit box and select
// "MB" in the drop-down list.
//
#define IDH_CMB_DEF_THRESHOLD       (IDH_QUOTA_FIRST + 10)
//
// Displays per-user quota information for the volume.
//
#define IDH_BTN_DETAILS             (IDH_QUOTA_FIRST + 11)
//
// Opens the Window NT Event Viewer.
//
#define IDH_BTN_EVENTLOG            (IDH_QUOTA_FIRST + 12)
//
// These items control how Windows NT responds when users exceed their
// warning threshold or quota limit values.
//
#define IDH_GRP_ACTIONS             (IDH_QUOTA_FIRST + 13)
//
// These items define default quota values automatically applied to new users 
// of the volume.
//
#define IDH_GRP_DEFAULTS            (IDH_QUOTA_FIRST + 14)

//-----------------------------------------------------------------------------
// User property page IDD_PROPPAGE_USERQUOTA
//-----------------------------------------------------------------------------
//
// Show the account name for the volume user.
//
#define IDH_TXT_USERNAME            (IDH_QUOTA_FIRST + 15)
//
// The number of bytes occupied by the user's data on the volume.
//
#define IDH_TXT_SPACEUSED           (IDH_QUOTA_FIRST + 16)
//
// The number of bytes available to the user on the volume.
//
#define IDH_TXT_SPACEREMAINING      (IDH_QUOTA_FIRST + 17)
//
// Indicates if the user's disk usage is under the warning threshold, over 
// the warning threshold or over the quota limit.
//
#define IDH_ICON_USERSTATUS         (IDH_QUOTA_FIRST + 18)
//
// These items define quota warning threshold and limit values for the user.
//
#define IDH_GRP_SETTINGS            (IDH_QUOTA_FIRST + 19)
//
// Check this to assign unlimited quota to the user.
//
#define IDH_RBN_USER_NOLIMIT        (IDH_QUOTA_FIRST + 20)
//
// Check this to assign a quota warning threshold and limit value to the user.
//
#define IDH_RBN_USER_LIMIT          (IDH_QUOTA_FIRST + 21)
//
// Enter a quota warning threshold to be assigned to the user. For example: 
// to assign 18 megabytes, enter 18 and select "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_EDIT_DEF_THRESHOLD
//
#define IDH_EDIT_USER_THRESHOLD     (IDH_QUOTA_FIRST + 22)
//
// Enter a quota limit value to be assigned to the user. For example: 
// to assign 20 megabytes, enter 20 and select "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_EDIT_DEF_LIMIT
//
#define IDH_EDIT_USER_LIMIT         (IDH_QUOTA_FIRST + 23)
//
// Select a unit of storage to apply to the quota limit value.  
// For example:  to assign 20 megabytes, enter 20 in the edit box and select
// "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_CMB_DEF_THRESHOLD
//
#define IDH_CMB_USER_LIMIT          (IDH_QUOTA_FIRST + 24)
//
// Select a unit of storage to apply to the quota warning threshold value.  
// For example:  to assign 18 megabytes, enter 18 in the edit box and select
// "MB" in the drop-down list.
//
// FEATURE:  This could be a duplicate of IDH_CMB_DEF_THRESHOLD
//
#define IDH_CMB_USER_THRESHOLD      (IDH_QUOTA_FIRST + 25)
//
// Show the domain/folder name for the volume user.
//
#define IDH_EDIT_DOMAINNAME         (IDH_QUOTA_FIRST + 26)

//-----------------------------------------------------------------------------
// File Owner dialog IDD_OWNERSANDFILES
//-----------------------------------------------------------------------------
//
// Select the owner of files to display in the list.
//
#define IDH_CMB_OWNERDLG_OWNERS     (IDH_QUOTA_FIRST + 27)
//
// List of files owned by selected user.
//
#define IDH_LV_OWNERDLG             (IDH_QUOTA_FIRST + 28)
//
// Permanently deletes from disk those files selected in the list.
//
#define IDH_BTN_OWNERDLG_DELETE     (IDH_QUOTA_FIRST + 29)
//
// Moves files selected in the list to another location.
//
#define IDH_BTN_OWNERDLG_MOVETO     (IDH_QUOTA_FIRST + 30)
//
// Transfers ownership of selected files to the logged-on user.
//
#define IDH_BTN_OWNERDLG_TAKE       (IDH_QUOTA_FIRST + 31)
//
// Displays a dialog for choosing a destination folder.
//
#define IDH_BTN_OWNERDLG_BROWSE     (IDH_QUOTA_FIRST + 32)
//
// Enter path to a destination folder.
//
#define IDH_EDIT_OWNERDLG_MOVETO    (IDH_QUOTA_FIRST + 33)

//-----------------------------------------------------------------------------
// Volume quota policy prop page IDD_PROPPAGE_POLICY
// Most of the controls in this dialog are duplicates of IDD_PROPPAGE_VOLQUOTA.
// Help for the additional controls is listed here.
//-----------------------------------------------------------------------------
//
// Check this to apply quota policy only to drives with non-removable media.
//
#define IDH_RBN_POLICY_FIXED        (IDH_QUOTA_FIRST + 34)
//
// Check this to apply quota policy to all NTFS storage volumes, including those
// with removable media.
//
#define IDH_RBN_POLICY_REMOVABLE    (IDH_QUOTA_FIRST + 35)
//
//-----------------------------------------------------------------------------
// These IDs are for controls on the volume prop page.  They were
// added late in the project and I didn't reserve any ranges for
// each page like I should have [brianau - 11/27/98]
//-----------------------------------------------------------------------------
//
// Check this to generate an event log entry when a user's disk space usage
// exceeds their assigned disk quota warning level.
//
#define IDH_CBX_LOG_OVERWARNING     (IDH_QUOTA_FIRST + 36)
//
// Check this to generate an event log entry when a user's disk space usage
// exceeds their assigned disk quota limit.
//
#define IDH_CBX_LOG_OVERLIMIT       (IDH_QUOTA_FIRST + 37)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\uiutils.cpp ===
#include "pch.h"
#pragma hdrstop

#include "uiutils.h"

void
CAutoWaitCursor::Reset(
    void
    )
{
    ShowCursor(FALSE);
    if (NULL != m_hCursor)
        SetCursor(m_hCursor);
    m_hCursor = NULL;
}


bool UseWindowsHelp(int idCtl)
{
    bool bUseWindowsHelp = false;
    switch(idCtl)
    {
        case IDOK:
        case IDCANCEL:
        case IDC_STATIC:
            bUseWindowsHelp = true;
            break;

        default:
            break;
    }
    return bUseWindowsHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\snapin.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: snapin.cpp

    Description: Implements the MMC snapin for disk quota policy.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#ifdef POLICY_MMC_SNAPIN

#include "snapin.h"
#include "resource.h"
#include "guidsp.h"
#include "policy.h"



//-----------------------------------------------------------------------------
// CSnapInItem
//-----------------------------------------------------------------------------
//
// General rendering function usable by this class and any
// derived classes to render data onto a medium.  Only accepts
// TYMED_HGLOBAL.
//
HRESULT
CSnapInItem::RenderData(  // [ static ]
    LPVOID pvData,
    int cbData,
    LPSTGMEDIUM pMedium
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInItem::RenderData [ general ]")));
    HRESULT hr = DV_E_TYMED;

    if (NULL == pvData || NULL == pMedium)
        return E_INVALIDARG;

    //
    // Make sure the type medium is HGLOBAL
    //
    if (TYMED_HGLOBAL == pMedium->tymed)
    {
        //
        // Create the stream on the hGlobal passed in
        //
        LPSTREAM pStream;
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &pStream);

        if (SUCCEEDED(hr))
        {
            //
            // Write to the stream the number of bytes
            //
            unsigned long written;

            hr = pStream->Write(pvData, cbData, &written);

            //
            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            //
            pStream->Release();
        }
    }

    return hr;
}


//
// Format a GUID as a string.
//
void
CSnapInItem::GUIDToString(   // [ static ]
    const GUID& guid,
    CString *pstr
    )
{
    StringFromGUID2(guid, pstr->GetBuffer(50), 50);
    pstr->ReleaseBuffer();
}



//-----------------------------------------------------------------------------
// CScopeItem
//-----------------------------------------------------------------------------
UINT CScopeItem::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
UINT CScopeItem::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CScopeItem::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CScopeItem::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

//
// Returns:  S_OK            = Data successfully rendered.
//           DV_E_CLIPFORMAT = Clipboard format not supported.
//           DV_E_TYMED      = Medium is not HGLOBAL.
//           Other           = Rendering error.
HRESULT
CScopeItem::RenderData(
    UINT cf,
    LPSTGMEDIUM pMedium
    ) const
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CScopeItem::RenderData")));
    HRESULT hr = DV_E_CLIPFORMAT;

    if (cf == m_cfNodeType)
    {
        DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("Rendering CCF_NODETYPE")));
        hr = CSnapInItem::RenderData((LPVOID)&m_idType, sizeof(m_idType), pMedium);
    }
    else if (cf == m_cfNodeTypeString)
    {
        DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("Rendering CCF_SZNODETYPE")));
        CString s;
        GUIDToString(m_idType, &s);
        hr = CSnapInItem::RenderData((LPVOID)s.Cstr(), (s.Length() + 1) * sizeof(TCHAR), pMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("Rendering CCF_DISPLAY_NAME")));
        const CString& s = m_cd.DisplayName();
        hr = CSnapInItem::RenderData((LPVOID)s.Cstr(), (s.Length() + 1) * sizeof(TCHAR), pMedium);
    }
    else if (cf == m_cfCoClass)
    {
        DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("Rendering CCF_SNAPIN_CLASSID")));
        hr = CSnapInItem::RenderData((LPVOID)&m_cd.ClassId(), sizeof(GUID), pMedium);
    }
    return hr;
}


CScopeItem::~CScopeItem(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CScopeItem::~CScopeItem")));
    while(0 < m_rgpChildren.Count())
    {
        delete m_rgpChildren[0];
        m_rgpChildren.Delete(0);
    }
    while(0 < m_rgpResultItems.Count())
    {
        delete m_rgpResultItems[0];
        m_rgpResultItems.Delete(0);
    }
}



//-----------------------------------------------------------------------------
// CSnapInComp
//-----------------------------------------------------------------------------

CSnapInComp::CSnapInComp(
    HINSTANCE hInstance,
    CSnapInCompData& cd
    ) : m_cRef(0),
        m_hInstance(hInstance),
        m_cd(cd),
        m_pConsole(NULL),
        m_pResult(NULL),
        m_pHeader(NULL),
        m_pImageResult(NULL),
        m_strColumn(hInstance, IDS_SNAPIN_COLUMN),
        m_cxColumn(200),
        m_lViewMode(LVS_ICON)
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInComp::CSnapInComp")));
}


CSnapInComp::~CSnapInComp(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInComp::~CSnapInComp")));

    if (NULL != m_pImageResult)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }
    if (NULL != m_pResult)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (NULL != m_pHeader)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (NULL != m_pConsole)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }
}



HRESULT
CSnapInComp::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInComp::QueryInterface")));
    DBGPRINTIID(DM_SNAPIN, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IComponent == riid)
    {
        *ppvOut = this;
    }
    else if (IID_IExtendContextMenu == riid)
    {
        *ppvOut = static_cast<IExtendContextMenu *>(this);
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}



ULONG
CSnapInComp::AddRef(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CSnapInComp::AddRef")));
    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


ULONG
CSnapInComp::Release(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CSnapInComp::Release")));
    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


HRESULT
CSnapInComp::Initialize(
    LPCONSOLE lpConsole
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::Initialize")));
    HRESULT hr = NOERROR;

    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    //
    // Get IResultData interface to result pane.
    //
    hr = m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void **>(&m_pResult));

    if (FAILED(hr))
        return hr;
    //
    // Get IHeaderCtrl interface to header control.
    //
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void **>(&m_pHeader));
    if (FAILED(hr))
        return hr;

//    m_pConsole->SetHeader(m_pHeader); // Needed?

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);

    return hr;
}


HRESULT
CSnapInComp::Notify(
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event, 
    long arg, 
    long param
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::Notify")));
    DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("\tpObj = 0x%08X, event = %d, arg = %d, param = 0x%08X"), lpDataObject, event, arg, param));
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_ADD_IMAGES:
            DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("MMCN_ADD_IMAGES")));
            {
                //
                // Result pane image list has only one icon.
                //
                HICON hIcon = LoadIcon(m_hInstance, MAKEINTRESOURCE(IDI_QUOTA));
                m_pImageResult->ImageListSetIcon(reinterpret_cast<long *>(hIcon), 0);
            }
            break;

        case MMCN_SHOW:
            DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("MMCN_SHOW, arg = %d"), arg));
            if (arg)
            {
                //
                // Showing view.  Set view information.
                //
                m_pHeader->InsertColumn(0, m_strColumn, LVCFMT_LEFT, m_cxColumn);
                m_pResult->SetViewMode(m_lViewMode);            

                CScopeItem *psi;
                hr = GetScopeItem((HSCOPEITEM)param, &psi);
                if (FAILED(hr))
                {
                    DBGERROR((TEXT("Failed getting item for MMCN_SHOW")));
                    return hr;
                }

                RESULTDATAITEM rdi;
                rdi.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                int cResultItems = psi->NumResultItems();

                for (int i = 0; i < cResultItems; i++)
                {
                    CResultItem *pri = psi->ResultItem(i);
                    DBGASSERT((NULL != pri));
                    rdi.str    = MMC_CALLBACK;
                    rdi.nImage = pri->ImageIndex();
                    rdi.lParam = (LPARAM)pri;
                    m_pResult->InsertItem(&rdi);
                }
            }
            else
            {
                //
                // Hiding view.  Gather view information.
                //
                m_pHeader->GetColumnWidth(0, &m_cxColumn);
                m_pResult->GetViewMode(&m_lViewMode);
            }
            break;

        case MMCN_CLICK:
        case MMCN_DBLCLICK:
            DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("MMCN_CLICK or MMCN_DBLCLICK")));
            m_cd.OpenVolumeQuotaProperties();
            break;

        default:
            break;
    }
    return hr;
}


HRESULT
CSnapInComp::Destroy(
    LONG cookie
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::Destroy")));
    if (NULL != m_pImageResult)
    {
        m_pImageResult->Release();
        m_pImageResult = NULL;
    }
    if (NULL != m_pResult)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }
    if (NULL != m_pHeader)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (NULL != m_pConsole)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    return NOERROR;
}


HRESULT
CSnapInComp::QueryDataObject(
    long cookie, 
    DATA_OBJECT_TYPES type, 
    LPDATAOBJECT *ppDataObject
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::QueryDataObject")));
    //
    // Forward the data object query to the component data object.
    //
    return m_cd.QueryDataObject(cookie, type, ppDataObject);
}


HRESULT
CSnapInComp::GetResultViewType(
    long cookie, 
    LPOLESTR *ppViewType, 
    long *pViewOptions
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::GetResultViewType")));
    //
    // Tell snapin mgr to use default listview.
    //
    return S_FALSE;
}


HRESULT
CSnapInComp::GetDisplayInfo(
    RESULTDATAITEM *prdi
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::GetDisplayInfo")));
    CSnapInItem *psi = reinterpret_cast<CSnapInItem *>(prdi->lParam);

    if (RDI_STR & prdi->mask)
    {
        prdi->str = (LPOLESTR)psi->DisplayName().Cstr();
    }
    if (RDI_IMAGE & prdi->mask)
    {
        prdi->nImage = psi->ImageIndex();
    }
    if (RDI_STATE & prdi->mask)
    {
        prdi->nState = 0;
    }
    if (RDI_INDEX & prdi->mask)
    {
        prdi->nIndex = 0;
    }
    if (RDI_INDENT & prdi->mask)
    {
        prdi->iIndent = 0;
    }
    
    return S_OK;
}



HRESULT
CSnapInComp::CompareObjects(
    LPDATAOBJECT pdoA, 
    LPDATAOBJECT pdoB
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::CompareObjects")));
    return m_cd.CompareObjects(pdoA, pdoB);
}


HRESULT
CSnapInComp::AddMenuItems(
    LPDATAOBJECT pDataObject, 
    LPCONTEXTMENUCALLBACK piCallback, 
    long *pInsertionAllowed
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::AddMenuItems")));
    return m_cd.AddMenuItems(pDataObject, piCallback, pInsertionAllowed);
}

HRESULT
CSnapInComp::Command(
    long lCommandID, 
    LPDATAOBJECT pDataObject
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInComp::Command")));
    return m_cd.Command(lCommandID, pDataObject);
}

 

HRESULT
CSnapInComp::GetScopeItem(
    HSCOPEITEM hItem,
    CScopeItem **ppsi
    ) const
{
    HRESULT hr;
    SCOPEDATAITEM item;
    item.mask = SDI_PARAM;
    item.ID   = hItem;

    hr = m_cd.m_pScope->GetItem(&item);
    if (SUCCEEDED(hr))
    {
        *ppsi = reinterpret_cast<CScopeItem *>(item.lParam);
    }
    return hr;
}


//-----------------------------------------------------------------------------
// CSnapInCompData
//-----------------------------------------------------------------------------

CSnapInCompData::CSnapInCompData(
    HINSTANCE hInstance,
    LPCTSTR pszDisplayName,
    const GUID& idClass
    ) : m_cRef(0),
        m_hInstance(hInstance),
        m_strDisplayName(pszDisplayName),
        m_idClass(idClass),
        m_pConsole(NULL),
        m_pScope(NULL),
        m_pRootScopeItem(NULL),
        m_hRoot(NULL),
        m_pGPEInformation(NULL)
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInCompData::CSnapInCompData")));

    InterlockedIncrement(&g_cRefThisDll);

    //
    // Root node.
    //
    m_pRootScopeItem = new CScopeItem(NODEID_DiskQuotaRoot, // Node ID
                                      *this,                // Snapin comp data ref.
                                      NULL,                 // Parent node ptr.
                                      TEXT("<root>"),       // Node name str.
                                      -1,                   // Image index.
                                      -1);                  // Image index "open".
    //
    // Add "Disk Quota Settings" as a child of the root.
    //
    CString strName(hInstance, IDS_SNAPIN_SCOPENAME);
    CScopeItem *psi = new CScopeItem(NODEID_DiskQuotaSettings,
                                     *this,
                                     m_pRootScopeItem,
                                     strName,
                                     iICON_QUOTA,
                                     iICON_QUOTA_OPEN);
    m_pRootScopeItem->AddChild(psi);

    //
    // Add single result item to "Disk Quota Settings".
    //
    strName.Format(hInstance, IDS_SNAPIN_RESULTNAME);
    psi->AddResultItem(new CResultItem(strName, 0, *psi));
}


CSnapInCompData::~CSnapInCompData(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInCompData::~CSnapInCompData")));

    delete m_pRootScopeItem;

    if (NULL != m_pScope)
        m_pScope->Release();

    if (NULL != m_pConsole)
        m_pConsole->Release();

    if (NULL != m_pGPEInformation)
        m_pGPEInformation->Release();

    InterlockedDecrement(&g_cRefThisDll);
}


HRESULT
CSnapInCompData::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInCompData::QueryInterface")));
    DBGPRINTIID(DM_SNAPIN, DL_MID, riid);
    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IUnknown == riid || IID_IComponentData == riid)
    {
        *ppvOut = this;
    }
    else if (IID_IPersistStreamInit == riid)
    {
        *ppvOut = static_cast<IPersistStreamInit *>(this);
    }
    else if (IID_IExtendContextMenu == riid)
    {
        *ppvOut = static_cast<IExtendContextMenu *>(this);
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}



ULONG
CSnapInCompData::AddRef(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CSnapInCompData::AddRef")));
    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


ULONG
CSnapInCompData::Release(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CSnapInCompData::Release")));
    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}


HRESULT
CSnapInCompData::Initialize(
    LPUNKNOWN pUnk
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Initialize")));
    DBGASSERT((NULL != pUnk));
    DBGASSERT((NULL == m_pConsole));

    HRESULT hr = pUnk->QueryInterface(IID_IConsole, 
                                      reinterpret_cast<void **>(&m_pConsole));

    if (FAILED(hr))
    {
        DBGERROR((TEXT("CSnapInCompData failed QI for IID_IConsole")));
        return hr;
    }

    hr = pUnk->QueryInterface(IID_IConsoleNameSpace,
                                      reinterpret_cast<void **>(&m_pScope));
    if (FAILED(hr))
    {
        DBGERROR((TEXT("CSnapInCompData failed QI for IID_IConsoleNameSpace")));
        return hr;
    }

    LPIMAGELIST pImageList = NULL;
    hr = m_pConsole->QueryScopeImageList(&pImageList);
    if (FAILED(hr))
    {
        DBGERROR((TEXT("CSnapInCompData failed to get scope image list")));
        return hr;
    }

    //
    // Set the scope pane's image list icons.
    //
    static const struct
    {
        int idIcon;
        int iIconIndex;

    } rgIcons[] = { { IDI_QUOTA,      iICON_QUOTA },
                    { IDI_QUOTA_OPEN, iICON_QUOTA_OPEN } };

    for (int i = 0; i < ARRAYSIZE(rgIcons); i++)
    {
        HICON hIcon = LoadIcon(m_hInstance, 
                               MAKEINTRESOURCE(rgIcons[i].idIcon));
        pImageList->ImageListSetIcon(reinterpret_cast<long *>(hIcon), 
                                     rgIcons[i].iIconIndex);
    }

    pImageList->Release();
        
    return hr;
}


HRESULT
CSnapInCompData::CreateComponent(
    LPCOMPONENT *ppComp
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::CreateComponent")));

    HRESULT hr = S_OK;
    try
    {
        CSnapInComp *pComp = new CSnapInComp(m_hInstance, *this);
        hr = pComp->QueryInterface(IID_IComponent, reinterpret_cast<void **>(ppComp));
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT
CSnapInCompData::Destroy(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Destroy")));

    if (NULL != m_pScope)
    {
        m_pScope->Release();
        m_pScope = NULL;
    }

    if (NULL != m_pConsole)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }
    return S_OK;
}


HRESULT
CSnapInCompData::Notify(
    LPDATAOBJECT pDataObject, 
    MMC_NOTIFY_TYPE event, 
    long arg, 
    long param
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Notify")));
    DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("\tpDataObj = 0x%08X, event = 0x%08X, arg = %d, param = 0x%08X"), 
              pDataObject, event, arg, param));
    HRESULT hr = S_OK;
    try
    {
        switch(event)
        {
            case MMCN_EXPAND:
                if (arg)
                {
                    if (NULL == m_pGPEInformation)
                    {
                        hr = pDataObject->QueryInterface(IID_IGPEInformation, 
                                                         reinterpret_cast<void **>(&m_pGPEInformation));
                    }
                    if (NULL != m_pGPEInformation)
                    {
                        hr = EnumerateScopePane((HSCOPEITEM)param);
                    }
                }
                break;

            default:
                break;
        }
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT 
CSnapInCompData::GetDisplayInfo(
    SCOPEDATAITEM *psdi
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::GetDispInfo")));
    DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("\tmask = 0x%08X"), psdi->mask));

    HRESULT hr = S_OK;

    CScopeItem *pItem = reinterpret_cast<CScopeItem *>(psdi->lParam);
    if (psdi->mask & SDI_STR)
    {
        psdi->displayname = (LPOLESTR)((LPCTSTR)pItem->DisplayName());
    }
    if (psdi->mask & SDI_IMAGE)
    {
        psdi->nImage = pItem->ImageIndex();
    }
    if (psdi->mask & SDI_OPENIMAGE)
    {
        psdi->nOpenImage = pItem->OpenImageIndex();
    }
    if (psdi->mask & SDI_CHILDREN)
    {
        psdi->cChildren = pItem->NumChildren();
    }

    return hr;
}


HRESULT
CSnapInCompData::CompareObjects(
    LPDATAOBJECT pdoA, 
    LPDATAOBJECT pdoB
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::GetDispInfo")));
    LPQUOTADATAOBJECT pDataA, pDataB;

    HRESULT hr = S_FALSE;

    if (FAILED(pdoA->QueryInterface(IID_IDiskQuotaSnapInData, reinterpret_cast<void **>(&pDataA))))
        return S_FALSE;

    if (FAILED(pdoB->QueryInterface(IID_IDiskQuotaSnapInData, reinterpret_cast<void **>(&pDataB))))
    {
        pDataA->Release();
        return FALSE;
    }

    CSnapInItem *psiA, *psiB;
    pDataA->GetItem(&psiA);
    pDataB->GetItem(&psiB);

    if (psiA == psiB)
        hr = S_OK;

    pDataA->Release();
    pDataB->Release();

    return hr;
}


HRESULT
CSnapInCompData::QueryDataObject(
    long cookie, 
    DATA_OBJECT_TYPES type, 
    LPDATAOBJECT *ppDataObject
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::QueryDataObject")));

    HRESULT hr = E_NOINTERFACE;
    CDataObject *pDataObject     = NULL;
    LPQUOTADATAOBJECT pQuotaData = NULL;

    try
    {
        pDataObject = new CDataObject(*this);
        pDataObject->SetType(type);
        pDataObject->SetItem(reinterpret_cast<CSnapInItem *>(cookie));

        hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT 
CSnapInCompData::EnumerateScopePane (
    HSCOPEITEM hParent
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::EnumerateScopePane")));
    HRESULT hr = S_OK;
    CScopeItem *psi = m_pRootScopeItem; // Default to enumerating from root.
    SCOPEDATAITEM item;

    if (NULL == m_hRoot)
        m_hRoot = hParent;      // Remember the root node's handle.

    if (m_hRoot != hParent)
    {
        item.mask = SDI_PARAM;
        item.ID   = hParent;

        hr = m_pScope->GetItem (&item);
        if (FAILED(hr))
        {
            DBGERROR((TEXT("Failed getting item")));
            return hr;
        }

        psi = reinterpret_cast<CScopeItem *>(item.lParam);
    }

    item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
    item.nState      = 0;
    item.relativeID  = hParent;

    int cChildren = psi->NumChildren();
    for (int iChild = 0; iChild < cChildren; iChild++)
    {
        CScopeItem *pChild = psi->Child(iChild);

        item.displayname = MMC_CALLBACK;
        item.nImage      = pChild->ImageIndex();
        item.nOpenImage  = pChild->OpenImageIndex();
        item.cChildren   = pChild->NumChildren();
        item.lParam      = reinterpret_cast<LPARAM>(pChild);

        m_pScope->InsertItem (&item);
    }
    return S_OK;
}



HRESULT
CSnapInCompData::InitNew(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::InitNew")));
    return S_OK;
}


HRESULT
CSnapInCompData::GetClassID(
    CLSID *pClassID
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::GetClassID")));
    if (!pClassID)
        return E_FAIL;

    *pClassID = ClassId();

    return S_OK;
}

HRESULT
CSnapInCompData::IsDirty(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::IsDirty")));
    return S_FALSE;
}

HRESULT
CSnapInCompData::Load(
    IStream *pStm
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Load")));
    return S_OK;
}


HRESULT
CSnapInCompData::Save(
    IStream *pStm, 
    BOOL fClearDirty
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Save")));
    return S_OK;
}


HRESULT 
CSnapInCompData::GetSizeMax(
    ULARGE_INTEGER *pcbSize
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::GetSizeMax")));
    DWORD dwSize = 0;

    if (NULL == pcbSize)
        return E_FAIL;

    pcbSize->QuadPart = 0;

    return S_OK;
}



HRESULT
CSnapInCompData::AddMenuItems(
    LPDATAOBJECT pDataObject, 
    LPCONTEXTMENUCALLBACK piCallback, 
    long *pInsertionAllowed
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::AddMenuItems")));
    HRESULT hr = S_OK;

    if (CCM_INSERTIONALLOWED_TOP & *pInsertionAllowed)
    {
        CString strOpen(m_hInstance, IDS_VERB_OPEN);
        CONTEXTMENUITEM ci;
        ci.strName           = strOpen;
        ci.strStatusBarText  = NULL;
        ci.lCommandID        = 0;
        ci.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        ci.fFlags            = 0;
        ci.fSpecialFlags     = CCM_SPECIAL_DEFAULT_ITEM;

        hr = piCallback->AddItem(&ci);
        if (FAILED(hr))
        {
            DBGERROR((TEXT("Error 0x%08X adding context menu item"), hr));
        }
    }
    return hr;
}

HRESULT
CSnapInCompData::Command(
    long lCommandID, 
    LPDATAOBJECT pDataObject
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::Command")));
    DBGPRINT((DM_SNAPIN, DL_LOW, TEXT("Command ID = %d"), lCommandID));

    if (0 == lCommandID)
        OpenVolumeQuotaProperties();
    else
        DBGERROR((TEXT("Unrecognized command ID (%d)"), lCommandID));

    return S_OK;
}

const int MAX_SNAPIN_PROP_PAGES = 1;

BOOL CALLBACK 
CSnapInCompData::AddPropSheetPage(
    HPROPSHEETPAGE hpage, 
    LPARAM lParam
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::AddPropSheetPage")));
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_SNAPIN_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }

    return FALSE;
}


DWORD
CSnapInCompData::PropPageThreadProc(
    LPVOID pvParam
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::PropPageThreadProc")));
    MSG msg;
    HWND hwndPropSheet = NULL;
    CSnapInCompData *pThis = (CSnapInCompData *)pvParam;

    com_autoptr<IShellExtInit> psei;
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_DiskQuotaUI,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IShellExtInit,
                              reinterpret_cast<void **>(psei.getaddr()));

        if (SUCCEEDED(hr))
        {
            com_autoptr<IShellPropSheetExt> pspse;
            hr = psei->QueryInterface(IID_ISnapInPropSheetExt,
                                     reinterpret_cast<void **>(pspse.getaddr()));
            if (SUCCEEDED(hr))
            {
                com_autoptr<IDiskQuotaPolicy> pdqp;
                hr = pspse->QueryInterface(IID_IDiskQuotaPolicy,
                                          reinterpret_cast<void **>(pdqp.getaddr()));
                if (SUCCEEDED(hr))
                {
                    pdqp->Initialize(pThis->m_pGPEInformation, NULL);

                    HPROPSHEETPAGE rghPages[1];

                    PROPSHEETHEADER psh;
                    ZeroMemory(&psh, sizeof(psh));
                    //
                    // Define sheet.
                    //
                    psh.dwSize          = sizeof(PROPSHEETHEADER);
                    psh.dwFlags         = PSH_MODELESS;
                    psh.hInstance       = pThis->m_hInstance;
                    psh.pszIcon         = NULL;
                    psh.pszCaption      = NULL;
                    psh.nPages          = 0;
                    psh.nStartPage      = 0;
                    psh.phpage          = rghPages;

                    pThis->m_pConsole->GetMainWindow(&psh.hwndParent);

                    hr = pspse->AddPages(AddPropSheetPage, (LPARAM)&psh);
                    if (SUCCEEDED(hr))
                    {
                        hwndPropSheet = (HWND)PropertySheet(&psh);
                        if (NULL != hwndPropSheet)
                        {
                            //
                            // Set the title on the property sheet.
                            //
                            CString strTitle(pThis->m_hInstance, IDS_SNAPIN_POLICYDLG_TITLE);
                            SetWindowText(hwndPropSheet, strTitle);

                            MSG msg;
                            while (0 != ::GetMessage(&msg, NULL, 0, 0))
                            {
                                if (!PropSheet_IsDialogMessage(hwndPropSheet, &msg))
                                {
                                    ::TranslateMessage(&msg);
                                    ::DispatchMessage(&msg);
                                }
                                if (NULL == PropSheet_GetCurrentPageHwnd(hwndPropSheet))
                                {
                                    DestroyWindow(hwndPropSheet);
                                    PostQuitMessage(0);
                                }
                            }
                        }
                        else if (-1 == (int)hwndPropSheet)
                        {
                            DBGERROR((TEXT("PropertySheet failed with error %d"), GetLastError()));
                        }
                    }
                    else
                    {
                        DBGERROR((TEXT("AddPages failed")));
                    }
                }
            }
        }
        else
            DBGERROR((TEXT("CoCreateInstance failed with result 0x%08X"), hr));

        CoUninitialize();
    }
    else
        DBGERROR((TEXT("CoInitialize failed with result 0x%08X"), hr));
    return 0;
}


//
// Create a new thread and run the volume properties dialog (modified for
// policy snapin).
//
HRESULT
CSnapInCompData::OpenVolumeQuotaProperties(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CSnapInCompData::OpenVolumeQuotaProperties")));
    HRESULT hr = E_FAIL;
    UINT idThread;
    HANDLE hThread = CreateThread(NULL,
                                  0,          // Default stack size
                                  (LPTHREAD_START_ROUTINE)PropPageThreadProc,
                                  (LPVOID)this,
                                  0,
                                  (LPDWORD)&idThread);
    if (INVALID_HANDLE_VALUE != hThread)
    {
        hr = NOERROR;
        CloseHandle(hThread);
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Snap-in data object implementation.  CDataObject
//-----------------------------------------------------------------------------
CDataObject::CDataObject(
    CSnapInCompData& cd
    ) : m_cRef(0),
        m_cd(cd),
        m_type(CCT_UNINITIALIZED),
        m_pItem(NULL)
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CDataObject::CDataObject")));

}


CDataObject::~CDataObject(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CDataObject::~CDataObject")));

}



HRESULT
CDataObject::QueryInterface(
    REFIID riid, 
    LPVOID *ppvOut
    )
{
    DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CDataObject::QueryInterface")));
    DBGPRINTIID(DM_SNAPIN, DL_MID, riid);

    HRESULT hr = E_NOINTERFACE;

    if (NULL == ppvOut)
        return E_INVALIDARG;

    *ppvOut = NULL;

    if (IID_IDiskQuotaSnapInData == riid)
    {
        *ppvOut = reinterpret_cast<IQuotaDataObject *>(this);
    }
    else if(IID_IUnknown == riid || IID_IDataObject == riid)
    {
        *ppvOut = this;
    }

    if (NULL != *ppvOut)
    {
        ((LPUNKNOWN)*ppvOut)->AddRef();
        hr = NOERROR;
    }

    return hr;
}



ULONG
CDataObject::AddRef(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CDataObject::AddRef")));

    ULONG ulReturn = m_cRef + 1;
    InterlockedIncrement(&m_cRef);
    return ulReturn;
}


ULONG
CDataObject::Release(
    void
    )
{
    DBGTRACE((DM_SNAPIN, DL_LOW, TEXT("CDataObject::Release")));

    ULONG ulReturn = m_cRef - 1;
    if (InterlockedDecrement(&m_cRef) == 0)
    {   
        delete this;
        ulReturn = 0;
    }
    return ulReturn;
}



HRESULT
CDataObject::GetDataHere(
    LPFORMATETC lpFormatetc, 
    LPSTGMEDIUM lpMedium
    )
{
    DBGTRACE((DM_SNAPIN, DL_HIGH, TEXT("CDataObject::GetDataHere")));
    HRESULT hr = S_OK;
    try
    {
        //
        // Forward the rendering request to the data object's item object.
        // 
        hr = m_pItem->RenderData(lpFormatetc->cfFormat, lpMedium);
    }
    catch(CAllocException& e)
    {
        DBGERROR((TEXT("Insufficient memory")));
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


#endif // POLICY_MMC_SNAPIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\snapin.h ===
#ifndef _INC_DSKQUOTA_SNAPIN_H
#define _INC_DSKQUOTA_SNAPIN_H
///////////////////////////////////////////////////////////////////////////////
/*  File: snapin.h

    Description: Declares classes used in the disk quota policy MMC snapin.
        Indentation indicates inheritance.

        Classes:
            CSnapInComp         - implements IComponent.
            CSnapInCompData     - implements IComponentData.
            CDataObject

            CSnapInItem         - abstract base class for scope/result items.
                CScopeItem      - MMC scope pane item
                CResultItem     - MMC result pane item

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/14/98    Initial creation.                                    BrianAu
    06/25/98    Disabled snapin code with #ifdef POLICY_MMC_SNAPIN.  BrianAu
                Switching to ADM-file approach to entering policy
                data.  Keeping snapin code available in case
                we decide to switch back at a later time.
*/
///////////////////////////////////////////////////////////////////////////////
#ifdef POLICY_MMC_SNAPIN

#ifndef __mmc_h__
#   include <mmc.h>
#endif

#ifndef _GPEDIT_H_
#   include <gpedit.h>
#endif

#ifndef _INC_DSKQUOTA_STRCLASS_H
#   include "strclass.h"
#endif

#ifndef _INC_DSKQUOTA_CARRAY_H
#   include "carray.h"
#endif

//
// This CSnapInItem hierarchy represents the relationships between scope-pane
// items and result-pane items.  CSnapInItem contains data common to both
// types of items.  It also allows us to give the node mgr CSnapInItem ptrs
// and use virtual functions to retrieve the proper type-specific data
// when required.
//                          
//                     CSnapInItem (pure virtual)
//                           |
//                         is a
//            +--------------+---------------+
//            |                              |
//            |                              |
//            |                              |
//       CScopeItem ----- contains ---->> CResultItem
//
//
class CSnapInCompData; // fwd decl.
class CResultItem;     // fwd decl.

//
// Pure virtual base class for snap-in scope items and result items.
//
class CSnapInItem 
{
    public:
        CSnapInItem(LPCTSTR pszDisplayName, int iImage)
            : m_strDisplayName(pszDisplayName),
              m_iImage(iImage)
              { DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInItem::CSnapInItem"))); }

        virtual ~CSnapInItem(void) 
            { DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CSnapInItem::~CSnapInItem"))); }

        int ImageIndex(void) const
            { return m_iImage; }

        const CString& DisplayName(void) const
            { return m_strDisplayName; }

        //
        // All derived types must provide implementations for
        // NodeType and RenderData.
        //
        virtual const GUID& NodeType(void) const = 0;
        virtual HRESULT RenderData(UINT cf, LPSTGMEDIUM pMedium) const = 0;

    protected:
        //
        // Helper functions for rendering data.
        //
        static void GUIDToString(const GUID& guid, CString *pstr);
        static HRESULT RenderData(LPVOID pvData, int cbData, LPSTGMEDIUM pMedium);

    private:
        int     m_iImage;           // Index of image in imagelist.
        CString m_strDisplayName;   // Item's display name string.

        //
        // Prevent copy.
        //
        CSnapInItem(const CSnapInItem& rhs);
        CSnapInItem& operator = (const CSnapInItem& rhs);
};

//
// An item in the MMC scope pane.
//
class CScopeItem : public CSnapInItem
{
    public:
        CScopeItem(const GUID& NodeType, 
                   const CSnapInCompData& cd,
                   CScopeItem *pParent,
                   LPCTSTR pszDisplayName, 
                   int iImage,
                   int iImageOpen)
            : CSnapInItem(pszDisplayName, iImage),
              m_idType(NodeType),
              m_pParent(pParent),
              m_cd(cd),
              m_iOpenImage(iImageOpen)
              { DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CScopeItem::CScopeItem"))); }

        virtual ~CScopeItem(void);

        int OpenImageIndex(void) const
            { return m_iOpenImage; }

        int NumChildren(void) const
            { return m_rgpChildren.Count(); }

        void AddChild(CScopeItem *pNode)
            { m_rgpChildren.Append(pNode); }

        CScopeItem *Child(int iChild) const
            { return m_rgpChildren[iChild]; }

        int NumResultItems(void) const
            { return m_rgpResultItems.Count(); }

        CResultItem *ResultItem(int iItem) const
            { return m_rgpResultItems[iItem]; }

        void AddResultItem(CResultItem *pItem)
            { m_rgpResultItems.Append(pItem); }

        virtual const GUID& NodeType(void) const
            { return m_idType; }

        virtual HRESULT RenderData(UINT cf, LPSTGMEDIUM pMedium) const;

    private:
        const GUID&            m_idType;         // Node type GUID.
        const CSnapInCompData& m_cd;             // Snapin's component data.
        int                    m_iOpenImage;     // Index of "open" image.
        CScopeItem            *m_pParent;        // Parent scope pane item.
        CArray<CScopeItem *>   m_rgpChildren;    // Scope pane children.
        CArray<CResultItem *>  m_rgpResultItems; // Result items.

        //
        // Standard clipboard formats required by MMC.
        //
        static UINT m_cfNodeType;
        static UINT m_cfNodeTypeString;
        static UINT m_cfDisplayName;
        static UINT m_cfCoClass;

        //
        // Prevent copy.
        //
        CScopeItem(const CScopeItem& rhs);
        CScopeItem& operator = (const CScopeItem& rhs);
};


//
// An item in the MMC result pane.
//
class CResultItem : public CSnapInItem
{
    public:
        CResultItem(LPCTSTR pszDisplayName, int iImage, CScopeItem& si)
            : CSnapInItem(pszDisplayName, iImage),
              m_scopeItem(si)
              { DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CResultItem::CResultItem"))); }

        virtual ~CResultItem(void)
              { DBGTRACE((DM_SNAPIN, DL_MID, TEXT("CResultItem::~CResultItem"))); }

        CScopeItem& ScopeItem(void) const
            { return m_scopeItem; }

        virtual const GUID& NodeType(void) const
            { return m_scopeItem.NodeType(); }

        virtual HRESULT RenderData(UINT cf, LPSTGMEDIUM pMedium) const
            { return m_scopeItem.RenderData(cf, pMedium); }

    private:
        CScopeItem& m_scopeItem;    // Item's "owner" in scope pane.

        //
        // Prevent copy.
        //
        CResultItem(const CResultItem& rhs);
        CResultItem& operator = (const CResultItem& rhs);
};


//
// Required implementation for IComponent.
//
class CSnapInComp : public IComponent,
                    public IExtendContextMenu
{
    public:
        CSnapInComp(HINSTANCE hInstance, CSnapInCompData& cd);
        ~CSnapInComp(void);

        HRESULT GetScopeItem(HSCOPEITEM hItem, CScopeItem **ppsi) const;

        //
        // IUnknown methods.
        //
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(VOID);
        STDMETHODIMP_(ULONG) Release(VOID);

        //
        // IComponent methods.
        //
        STDMETHODIMP Initialize(LPCONSOLE lpConsole);
        STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
        STDMETHODIMP Destroy(LONG cookie);
        STDMETHODIMP QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);
        STDMETHODIMP GetResultViewType(long cookie, LPOLESTR *ppViewType, long *pViewOptions);
        STDMETHODIMP GetDisplayInfo(RESULTDATAITEM *pResultDataItem); 
        STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

        //
        // IExtendContextMenu methods.
        //
        STDMETHODIMP AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback, long *pInsertionAllowed);
        STDMETHODIMP Command(long lCommandID, LPDATAOBJECT pDataObject);

    private:
        LONG             m_cRef;            // COM ref count.
        HINSTANCE        m_hInstance;       // For getting resources.
        CSnapInCompData& m_cd;              // Component's ComponentData
        LPCONSOLE        m_pConsole;        // The MMC console.
        LPRESULTDATA     m_pResult;         // The result pane.
        LPHEADERCTRL     m_pHeader;         // The result pane header ctrl.
        LPIMAGELIST      m_pImageResult;    // The result pane imagelist.
        CString          m_strColumn;       // Column header title.
        int              m_cxColumn;        // Column header width.
        long             m_lViewMode;       // Result pane view mode.

        //
        // Prevent copy.
        //
        CSnapInComp(const CSnapInComp& rhs);
        CSnapInComp& operator = (const CSnapInComp& rhs);
};

//
// Custom interface for data object.  Primary purpose is to distinguish
// our data object from any other data object.  This is done by calling
// QI for IQuotaDataObject.  If it succeeds, it's ours.
//
#undef INTERFACE
#define INTERFACE IQuotaDataObject
DECLARE_INTERFACE_(IQuotaDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IQuotaDataObject methods ***
    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetItem) (THIS_ CSnapInItem *pItem) PURE;
    STDMETHOD(GetItem) (THIS_ CSnapInItem **pItem) PURE;
};
typedef IQuotaDataObject *LPQUOTADATAOBJECT;


//
// The snap-in's data object.
//
class CDataObject : public IDataObject,
                    public IQuotaDataObject
{
    public:
        CDataObject(CSnapInCompData& cd);
        ~CDataObject(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(VOID);
        STDMETHODIMP_(ULONG) Release(VOID);

        //
        // IDataObject.  All but GetDataHere are unimplemented.
        //
        STDMETHODIMP GetDataHere(FORMATETC *pFormatetc, STGMEDIUM *pmedium);
        
        STDMETHODIMP GetData(FORMATETC *pFormatetc,  STGMEDIUM *pmedium)
            { return E_NOTIMPL; }
        STDMETHODIMP QueryGetData(FORMATETC *pFormatetc)
            { return E_NOTIMPL; }
        STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pFormatetcIn,  FORMATETC *pFormatetcOut)
            { return E_NOTIMPL; }
        STDMETHODIMP SetData(FORMATETC *pFormatetc, STGMEDIUM *pmedium, BOOL fRelease)
            { return E_NOTIMPL; }
        STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatetc)
            { return E_NOTIMPL; }
        STDMETHODIMP DAdvise(FORMATETC *pFormatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD * pdwConnection)
            { return E_NOTIMPL; }
        STDMETHODIMP DUnadvise(DWORD dwConnection)
            { return E_NOTIMPL; }
        STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
            { return E_NOTIMPL; }

        //
        // IQuotaDataObject.
        //
        STDMETHODIMP SetType(DATA_OBJECT_TYPES type)
            { m_type = type; return S_OK; }
        STDMETHODIMP GetType(DATA_OBJECT_TYPES *type)
            { *type = m_type; return S_OK; }
        STDMETHODIMP SetItem(CSnapInItem *pItem)
            { m_pItem = pItem; return S_OK; }
        STDMETHODIMP GetItem(CSnapInItem **ppItem)
            { *ppItem = m_pItem; return S_OK; }

    private:
        LONG               m_cRef;  // COM ref count.
        CSnapInCompData&   m_cd;    // Related component data object.
        DATA_OBJECT_TYPES  m_type;  // Type defined by MMC.
        CSnapInItem       *m_pItem; // Related snapin item.

        //
        // Prevent copy.
        //
        CDataObject(const CDataObject& rhs);
        CDataObject& operator = (const CDataObject& rhs);
};


//
// Required implementation for IComponentData.
//
class CSnapInCompData : public IComponentData,
                        public IPersistStreamInit,
                        public IExtendContextMenu
{
    public:
        //
        // Icon indexes in scope image list.
        //
        enum { iICON_QUOTA = 0,
               iICON_QUOTA_OPEN };

        CSnapInCompData(HINSTANCE hInstance, LPCTSTR pszDisplayName, const GUID& idClass);
        ~CSnapInCompData(void);

        const CString& DisplayName(void) const
            { return m_strDisplayName; }

        const GUID& ClassId(void) const
            { return m_idClass; }

        HRESULT OpenVolumeQuotaProperties(void);

        //
        // IUnknown methods.
        //
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(VOID);
        STDMETHODIMP_(ULONG) Release(VOID);

        //
        // IComponentData methods.
        //
        STDMETHODIMP Initialize(LPUNKNOWN pUnknown);
        STDMETHODIMP CreateComponent (LPCOMPONENT *ppComponent);
        STDMETHODIMP Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param);
        STDMETHODIMP Destroy(void);
        STDMETHODIMP GetDisplayInfo(SCOPEDATAITEM *pScopeDataItem);
        STDMETHODIMP CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
        STDMETHODIMP QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);

        //
        // IPersistStreamInit methods.
        //
        STDMETHODIMP GetClassID(CLSID *pClassID);
        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(IStream *pStm);
        STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
        STDMETHODIMP InitNew(void);

        //
        // IExtendContextMenu methods.
        //
        STDMETHODIMP AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback, long *pInsertionAllowed);
        STDMETHODIMP Command(long lCommandID, LPDATAOBJECT pDataObject);


    private:
        LONG                 m_cRef;             // obj ref counter.
        HINSTANCE            m_hInstance;        // for getting resources.
        CString              m_strDisplayName;   // Component's display name.
        const GUID&          m_idClass;          // Component's class ID.
        LPCONSOLE            m_pConsole;         // SnapIn mgr's console interface.
        LPCONSOLENAMESPACE   m_pScope;           // SnapIn mgr's scope interface.
        CScopeItem          *m_pRootScopeItem;   // Scope pane node tree root.
        HSCOPEITEM           m_hRoot;            // Root of extension's namespace
        LPGPEINFORMATION     m_pGPEInformation;

        HRESULT EnumerateScopePane(HSCOPEITEM hParent);
        static BOOL CALLBACK AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);
        static DWORD PropPageThreadProc(LPVOID pvParam);

        //
        // Prevent copy.
        //
        CSnapInCompData(const CSnapInCompData& rhs);
        CSnapInCompData& operator = (const CSnapInCompData& rhs);

        friend class CSnapInComp;
};

#endif // POLICY_MMC_SNAPIN

#endif // _INC_DSKQUOTA_SNAPIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\uiutils.h ===
#ifndef __INC_DSKQUOTA_UIUTILS_H
#define __INC_DSKQUOTA_UIUTILS_H

//
// Simple class for automating the display and resetting of a wait cursor.
//
class CAutoWaitCursor
{
    public:
        CAutoWaitCursor(void)
            : m_hCursor(SetCursor(LoadCursor(NULL, IDC_WAIT)))
            { ShowCursor(TRUE); }

        ~CAutoWaitCursor(void)
            { Reset(); }

        void Reset(void);

    private:
        HCURSOR m_hCursor;
};

bool UseWindowsHelp(int idCtl);

#endif //__INC_DSKQUOTA_UIUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\undo.h ===
#ifndef _INC_DSKQUOTA_UNDO_H
#define _INC_DSKQUOTA_UNDO_H
///////////////////////////////////////////////////////////////////////////////
/*  File: undo.h

    Description: Declarations for classes associated with the "undo" feature.



    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_DYNARRAY_H
#   include "dynarray.h"
#endif

class UndoList;  // Fwd decl.

//
// Virtual base class for all undo actions.
// UndoList maintains a list of these.
//
class UndoAction
{
    protected:
        PDISKQUOTA_CONTROL m_pQuotaControl; // Ptr to quota control object.
        PDISKQUOTA_USER m_pUser;            // User object affected by action.
        UndoList     *m_pUndoList;          // Containing undo list object.
        LONGLONG      m_llLimit;            // User object's previous quota limit.
        LONGLONG      m_llThreshold;        // Previous quota threshold.

    public:
        UndoAction(PDISKQUOTA_USER pUser, LONGLONG llThreshold, LONGLONG llLimit,
                   PDISKQUOTA_CONTROL pQuotaControl = NULL);
        ~UndoAction(VOID);

        virtual HRESULT Undo(VOID) = 0;

        VOID SetUndoList(UndoList *pUndoList)
            { m_pUndoList = pUndoList; }
};


//
// Class for restoring a deleted record.
//
class UndoDelete : public UndoAction
{
    public:
        UndoDelete(
            PDISKQUOTA_USER pUser,
            LONGLONG llThreshold,
            LONGLONG llLimit
            ) : UndoAction(pUser, llThreshold, llLimit) { }

        HRESULT Undo(VOID);
};


//
// Class for restoring a newly added record (delete it).
//
class UndoAdd : public UndoAction
{
    public:
        UndoAdd(
            PDISKQUOTA_USER pUser,
            PDISKQUOTA_CONTROL pQuotaControl
            ) : UndoAction(pUser, 0, 0, pQuotaControl) { }

        HRESULT Undo(VOID);
};


//
// Class for restoring a record's previous settings.
//
class UndoModify : public UndoAction
{
    public:
        UndoModify(
            PDISKQUOTA_USER pUser,
            LONGLONG llThreshold,
            LONGLONG llLimit
            ) : UndoAction(pUser, llThreshold, llLimit) { }

        HRESULT Undo(VOID);
};


//
// Container for a set of undo actions.
//
class UndoList
{
    private:
        PointerList        m_hList;         // List of undo action object ptrs.
        PointerList       *m_pUserList;     // List of quota user object ptrs.
        HWND               m_hwndListView;  // Listview we'll update.

    public:
        UndoList(PointerList *pUserList, HWND hwndListView)
            : m_pUserList(pUserList),
              m_hwndListView(hwndListView) { }

        ~UndoList(VOID);

        VOID Add(UndoAction *pAction)
            { 
                pAction->SetUndoList(this), 
                m_hList.Append((LPVOID)pAction); 
            }

        HWND GetListViewHwnd(VOID)
            { return m_hwndListView; }

        PointerList *GetUserList(VOID)
            { return m_pUserList; }
        
        VOID Undo(VOID);

        VOID Clear(VOID);

        INT Count(VOID)
            { return m_hList.Count(); }
};



    

#endif // _INC_DSKQUOTA_UNDO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\undo.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: undo.cpp

    Description: Definitions for classes associated with the "undo" feature.
        A client first creates an UndoList object.  Whenever an "undoable" 
        action is performed in the quota UI (modification/deletion), an
        undo action object is created and added to the UndoList object.  
        Each type of undo action object knows what is has to do to reverse
        the effects of the original operation.  When the client wants to 
        reverse the effects of all operations on the undo list, it merely
        commands the UndoList object to "Undo".  To clear the undo list,
        a client calls UndoList::Clear().


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include "undo.h"


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoAction::UndoAction
    Function: UndoAction::~UndoAction

    Description: Constructor and Destructor

    Arguments: 
        pUser - Address of IDiskQuotaUser interface for user associated
            with this undo action.

        llThreshold - Quota threshold value to be restored if action is 
            undone.

        llLimit - Quota limit value to be restored if action is undone.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UndoAction::UndoAction(
    PDISKQUOTA_USER pUser,
    LONGLONG llThreshold,
    LONGLONG llLimit,
    PDISKQUOTA_CONTROL pQuotaControl
    ) : m_pUser(pUser),
        m_pUndoList(NULL),
        m_pQuotaControl(pQuotaControl)
{
    DBGTRACE((DM_UNDO, DL_HIGH, TEXT("UndoAction::UndoAction")));
    DBGPRINT((DM_UNDO, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    DBGASSERT((NULL != m_pUser));
    m_llThreshold = llThreshold;
    m_llLimit     = llLimit;
}


UndoAction::~UndoAction(
    VOID
    )
{
    DBGTRACE((DM_UNDO, DL_HIGH, TEXT("UndoAction::~UndoAction")));
    DBGPRINT((DM_UNDO, DL_HIGH, TEXT("\tthis = 0x%08X"), this));

    if (NULL != m_pUser)
        m_pUser->Release();  // Release from Undo list.
    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::~UndoList

    Description: Destructor.  Destroys all undo action objects in the 
        undo list object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UndoList::~UndoList(
    VOID
    )
{
    Clear();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::Clears

    Description: Destroys all undo action objects in the 
        undo list object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID UndoList::Clear(
    VOID
    )
{
    UndoAction *pAction = NULL;

    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Cleared undo list")));
    m_hList.Lock();
    while(m_hList.RemoveFirst((LPVOID *)&pAction))
    {
        DBGASSERT((NULL != pAction));
        delete pAction;
    }
    m_hList.ReleaseLock();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoList::Undo

    Description: Iterates through all undo action objects and commands each
        to perform it's undo action.  Once the action is performed, the
        undo action object is destroyed.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID UndoList::Undo(
    VOID
    )
{
    UndoAction *pAction = NULL;

    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing undo list")));

    //
    // Disable redraw on the listview so that we only update once.
    //
    CAutoSetRedraw autoredraw(m_hwndListView, false);
    m_hList.Lock();
    while(m_hList.RemoveFirst((LPVOID *)&pAction))
    {
        DBGASSERT((NULL != pAction));
        pAction->Undo();
        delete pAction;
    }
    m_hList.ReleaseLock();
    InvalidateRect(m_hwndListView, NULL, FALSE);
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoDelete::Undo

    Description: Reverses the deletion of a user quota record.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoDelete::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing deletion")));

    HRESULT hResult = NO_ERROR;

    //
    // Just restore the quota settings.
    //
    hResult = m_pUser->SetQuotaLimit(m_llLimit, TRUE);
    hResult = m_pUser->SetQuotaThreshold(m_llThreshold, TRUE);

    if (SUCCEEDED(hResult))
    {
        //
        // Add the entry back into the listview.
        //
        HWND hwndListView      = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        LV_ITEM item;

        item.mask       = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE;
        item.state      = 0;
        item.stateMask  = 0;
        item.iSubItem   = 0;
        item.pszText    = LPSTR_TEXTCALLBACK;
        item.iImage     = I_IMAGECALLBACK;
        item.iItem      = 0;

        pUserList->Insert((LPVOID)m_pUser);
        if (-1 != ListView_InsertItem(hwndListView, &item))
        {
            m_pUser->AddRef();
        }
        else
            hResult = E_FAIL;
    }

    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoAdd::Undo

    Description: Reverses the addition of a user quota record by marking it
        for deletion.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/27/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoAdd::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing addition")));

    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_pUser));

    HRESULT hResult = m_pQuotaControl->DeleteUser(m_pUser);

    if (SUCCEEDED(hResult))
    {
        INT iItem;
        LV_FINDINFO fi;
        HWND hwndListView = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        fi.flags  = LVFI_PARAM;
        fi.lParam = (LPARAM)m_pUser;

        iItem = ListView_FindItem(hwndListView, -1, &fi);
        if (-1 != iItem)
        {
            PDISKQUOTA_USER pIUserToDelete = NULL;

            //
            // Delete the entry from the list view.
            //
            ListView_DeleteItem(hwndListView, iItem);

            //
            // Delete the entry from the user list.
            //
            pUserList->Remove((LPVOID *)&pIUserToDelete, iItem);


            pIUserToDelete->Release();  // Release from listview.
        }
        else
        {
            DBGERROR((TEXT("UndoAdd::Undo - Didn't find user in listview.")));
        }
    }
    else
    {
        DBGERROR((TEXT("UndoAdd::Undo - Error 0x%08X deleting user 0x%08X"),
                 hResult, m_pUser));
    }
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UndoModify::Undo

    Description: Reverses the modification of a user quota record.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/30/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UndoModify::Undo(
    VOID
    )
{
    DBGPRINT((DM_UNDO, DL_MID, TEXT("UNDO - Undoing modification")));

    HRESULT hResult = NO_ERROR;
    //
    // Restore the user's quota settings.
    //
    hResult = m_pUser->SetQuotaLimit(m_llLimit, TRUE);
    hResult = m_pUser->SetQuotaThreshold(m_llThreshold, TRUE);

    if (SUCCEEDED(hResult))
    {
        //
        // Locate the corresponding listview item and update it.
        //
        HWND hwndListView      = m_pUndoList->GetListViewHwnd();
        PointerList *pUserList = m_pUndoList->GetUserList();

        DBGASSERT((NULL != hwndListView));
        INT iItem = -1;

        if (pUserList->FindIndex((LPVOID)m_pUser, &iItem))
            ListView_Update(hwndListView, iItem);
        else
            hResult = E_FAIL;
    }
    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\userprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: userprop.cpp

    Description: Provides implementations for quota user property page.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Replaced AddUserPropSheet with AddUserDialog.        BrianAu
                Now that we're getting user info from the DS
                object picker, the prop sheet idea doesn't work
                so well.  A std dialog is better.
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h" // PCH
#pragma hdrstop

#include <lm.h>
#include "undo.h"
#include "userprop.h"
#include "userbat.h"
#include "uihelp.h"
#include "progress.h"
#include "uiutils.h"

//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgUserPropSheetHelpIDs[] =
{
    IDC_ICON_USER,               DWORD(-1),
    IDC_STATIC2,                 DWORD(-1),
    IDC_TXT_USERNAME,            IDH_TXT_USERNAME,
    IDC_TXT_SPACEUSED,           IDH_TXT_SPACEUSED,
    IDC_TXT_SPACEREMAINING,      IDH_TXT_SPACEREMAINING,
    IDC_LBL_SPACEUSED,           DWORD(-1),
    IDC_LBL_SPACEREMAINING,      DWORD(-1),
    IDC_ICON_USERSTATUS,         IDH_ICON_USERSTATUS,
    IDC_RBN_USER_NOLIMIT,        IDH_RBN_USER_NOLIMIT,
    IDC_RBN_USER_LIMIT,          IDH_RBN_USER_LIMIT,
    IDC_TXT_WARN_LEVEL,          DWORD(-1),
    IDC_EDIT_USER_LIMIT,         IDH_EDIT_USER_LIMIT,
    IDC_EDIT_USER_THRESHOLD,     IDH_EDIT_USER_THRESHOLD,
    IDC_CMB_USER_LIMIT,          IDH_CMB_USER_LIMIT,
    IDC_CMB_USER_THRESHOLD,      IDH_CMB_USER_THRESHOLD,
    0,0
};

#pragma data_seg()


//
// Messages for querying property page for icon images.
//
#define DQM_QUERY_STATUS_ICON      (WM_USER + 1)
#define DQM_QUERY_USER_ICON        (WM_USER + 2)
#define DQM_ENABLE_APPLY_BUTTON    (WM_USER + 3)

///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UserPropSheet

    Description: Constructor for a user property sheet object.
        Initializes the members that hold user quota data.

    Arguments: None.

    Returns: Nothing.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
UserPropSheet::UserPropSheet(
    PDISKQUOTA_CONTROL pQuotaControl,
    const CVolumeID& idVolume,
    HWND hWndParent,
    LVSelection& LVSel,
    UndoList& UndoList
    ) : m_cVolumeMaxBytes(0),
        m_pQuotaControl(pQuotaControl),
        m_UndoList(UndoList),
        m_LVSelection(LVSel),
        m_hWndParent(hWndParent),
        m_bIsDirty(FALSE),
        m_bHomogeneousSelection(TRUE),  // Assume selection is homogeneous.
        m_pxbQuotaLimit(NULL),
        m_pxbQuotaThreshold(NULL),
        m_idVolume(idVolume),
        m_strPageTitle(g_hInstDll, IDS_TITLE_GENERAL),
        m_idCtlNextFocus(-1)
{
    DBGASSERT((NULL != m_pQuotaControl));
    DBGASSERT((NULL != m_hWndParent));
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("UserPropSheet::UserPropSheet")));

    m_llQuotaUsed      = 0;
    m_llQuotaLimit     = 0;
    m_llQuotaThreshold = 0;

    DBGASSERT((0 == iICON_USER_SINGLE));
    DBGASSERT((1 == iICON_USER_MULTIPLE));
    m_hIconUser[0]     = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_SINGLE_USER));
    m_hIconUser[1]     = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_MULTI_USER));

    DBGASSERT((0 == iICON_STATUS_OK));
    DBGASSERT((1 == iICON_STATUS_OVER_THRESHOLD));
    DBGASSERT((2 == iICON_STATUS_OVER_LIMIT));
    m_hIconStatus[0]   = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_OKBUBBLE));
    m_hIconStatus[1]   = LoadIcon(NULL, IDI_WARNING);
    m_hIconStatus[2]   = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_WARNERR));
}



UserPropSheet::~UserPropSheet(
    VOID
    )
{
    DBGTRACE((DM_UPROP, DL_HIGH, TEXT("UserPropSheet::~UserPropSheet")));
    INT i = 0;

    if (NULL != m_pQuotaControl)
        m_pQuotaControl->Release();

    if (NULL != m_pxbQuotaLimit)
        delete m_pxbQuotaLimit;
    if (NULL != m_pxbQuotaThreshold)
        delete m_pxbQuotaThreshold;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::Run

    Description: Creates and runs the property sheet dialog.
        This is the only method a client needs to call once the object
        is created.

    Arguments: None.

    Returns:
        NO_ERROR
        E_FAIL      - Couldn't create property sheet.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::Run(
    VOID
    )
{
    HRESULT hResult = NO_ERROR; // Assume success.

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;

    ZeroMemory(&psh, sizeof(psh));
    ZeroMemory(&psp, sizeof(psp));

    //
    // Define page.
    //
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_USEREFPARENT | PSP_USETITLE;
    psp.hInstance       = g_hInstDll;
    psp.pszTemplate     = MAKEINTRESOURCE(IDD_PROPPAGE_USERQUOTA);
    psp.pszTitle        = (LPCTSTR)m_strPageTitle;
    psp.pfnDlgProc      = DlgProc;
    psp.lParam          = (LPARAM)this;
    psp.pcRefParent     = (UINT *)& g_cRefThisDll;

    //
    // Define sheet.
    //
    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.dwFlags         = PSH_PROPSHEETPAGE;
    psh.hwndParent      = m_hWndParent;
    psh.hInstance       = g_hInstDll;
    psh.pszIcon         = NULL;
    psh.pszCaption      = NULL;
    psh.nPages          = 1;
    psh.nStartPage      = 0;
    psh.ppsp            = (LPCPROPSHEETPAGE)&psp;

    if (0 <= PropertySheet(&psh))
        hResult = E_FAIL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY
UserPropSheet::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    UserPropSheet *pThis = (UserPropSheet *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                bResult = OnInitDialog(hDlg, wParam, lParam);
                break;

            case WM_NOTIFY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY")));
                bResult = pThis->OnNotify(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                break;

            case WM_CLOSE:
            case WM_ENDSESSION:
                DestroyWindow(hDlg);
                break;

            case DQM_ENABLE_APPLY_BUTTON:
                pThis->m_bIsDirty = TRUE;
                bResult = PropSheet_Changed(GetParent(hDlg), hDlg);
                break;

            //
            // These two icon query messages are for automated testing
            // of the UI.
            //
            case DQM_QUERY_USER_ICON:
                bResult = pThis->QueryUserIcon(hDlg);
                break;

            case DQM_QUERY_STATUS_ICON:
                bResult = pThis->QueryUserStatusIcon(hDlg);
                break;

            default:
                break;
        }

    }
    catch(CAllocException& e)
    {
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnInitDialog

    Description: Handler for WM_INITDIALOG.  Retrieves the "this" pointer from
        the PROPSHEETPAGE structure (pointed to by lParam) and saves it in
        the window's USERDATA.

    Arguments:
        hDlg - Dialog window handle.

        wParam - Handle of control to receive focus if we return FALSE.

        lParam - Pointer to PROPSHEETPAGE structure for the property page.

    Returns:
        TRUE  = Tells windows to assign focus to the control in wParam.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;

    PROPSHEETPAGE *pPage = (PROPSHEETPAGE *)lParam;
    UserPropSheet *pThis = (UserPropSheet *)pPage->lParam;
    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    DBGASSERT((NULL != pThis));

    //
    // Save "this" in the window's userdata.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);

    //
    // Read quota info from NTFS.
    // For single selection, we cache the selected user's info.
    // For multi selection, we cache the defaults for the volume.
    // If adding a new user (count == 0), we also use the defaults for the
    // volume.
    //
    pThis->RefreshCachedQuotaInfo();

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(pThis->m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        pThis->m_cVolumeMaxBytes = (LONGLONG)dwSectorsPerCluster *
                                   (LONGLONG)dwBytesPerSector *
                                   (LONGLONG)dwTotalClusters;
    }

    pThis->m_pxbQuotaLimit     = new XBytes(hDlg,
                                            IDC_EDIT_USER_LIMIT,
                                            IDC_CMB_USER_LIMIT,
                                            pThis->m_llQuotaLimit);
    pThis->m_pxbQuotaThreshold = new XBytes(hDlg,
                                            IDC_EDIT_USER_THRESHOLD,
                                            IDC_CMB_USER_THRESHOLD,
                                            pThis->m_llQuotaThreshold);

    pThis->InitializeControls(hDlg);

    return TRUE;  // Set focus to default control.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::RefreshCachedQuotaInfo

    Description: Reads the quota limit, threshold and used values from the
        property sheet's user object.  If multiple users are selected,
        only the first one is read.

    Arguments: None.

    Returns: Result of read operation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::RefreshCachedQuotaInfo(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;
    PDISKQUOTA_USER pUser = NULL;
    INT cSelectedUsers = m_LVSelection.Count();

    m_LVSelection.Retrieve(0, &pUser);

    //
    // Read quota threshold.  Multi-user selections use the volume's default.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaThreshold(&m_llQuotaThreshold);
    }
    else
    {
        hResult = m_pQuotaControl->GetDefaultQuotaThreshold(&m_llQuotaThreshold);
    }
    if (FAILED(hResult))
        goto refresh_quota_info_failed;

    //
    // Read quota limit.  Multi-user selections use the volume's default.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaLimit(&m_llQuotaLimit);
    }
    else
    {
        hResult = m_pQuotaControl->GetDefaultQuotaLimit(&m_llQuotaLimit);
    }
    if (FAILED(hResult))
        goto refresh_quota_info_failed;


    //
    // Read quota used.
    //
    if (1 == cSelectedUsers)
    {
        hResult = pUser->GetQuotaUsed(&m_llQuotaUsed);
    }
    else
    {
        m_llQuotaUsed = 0;
    }

refresh_quota_info_failed:
    return hResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD dwCtlId        = LOWORD(wParam);
    HWND hWndCtl         = (HWND)lParam;
    DWORD dwNotifyCode   = HIWORD(wParam);
    INT_PTR bResult      = FALSE;

    switch(dwCtlId)
    {
        case IDC_TXT_USERNAME:
            if (EN_SETFOCUS == dwNotifyCode && IDC_EDIT_USER_THRESHOLD == m_idCtlNextFocus)
            {
                //
                // Focus is being set as a result of an invalid entry
                // in the warning level field.  Force input focus to the
                // field and select the entire contents.  User can then just
                // enter a new value.
                //
                SetFocus(GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
                SendDlgItemMessage(hDlg, IDC_EDIT_USER_THRESHOLD, EM_SETSEL, 0, -1);
                m_idCtlNextFocus = -1;
            }
            break;

        case IDC_RBN_USER_NOLIMIT:
            if (m_pxbQuotaThreshold->IsEnabled())
            {
                //
                // This is simple.  Just set both the limit and threshold controls
                // to "no limit".
                //
                m_pxbQuotaThreshold->SetBytes(NOLIMIT);
                m_pxbQuotaLimit->SetBytes(NOLIMIT);
                m_bIsDirty = TRUE;
            }
            break;

        case IDC_RBN_USER_LIMIT:
        {
            LONGLONG llValue;

            //
            // This handler needs some logic.  We have to handle several
            // scenarios/rules with this one.
            // 1. Single vs. Multiple selection.
            // 2. Single selection for Administrator account.
            // 3. Multi selection homogeneous/heterogenous with respect to
            //    quota limit and threshold values.
            // 4. Can't display "No Limit" in edit controls when they're active.
            // 5. Use volume defaults for new user and hetergenous multi-select.
            //
            if (!m_pxbQuotaThreshold->IsEnabled())
            {
                enum use_types { USE_CACHED, USE_VOLDEF, USE_NOLIMIT };

                INT iUseAsValue = USE_CACHED;
                INT cSelected   = m_LVSelection.Count();

                ///////////////////////////////////////////////////////////////
                // First set the quota limit controls.
                ///////////////////////////////////////////////////////////////
                if (0 == cSelected)                     // Adding new user...
                {
                    iUseAsValue = USE_VOLDEF;
                }
                else if (1 == cSelected)                // One user selected...
                {
                    PDISKQUOTA_USER pUser = NULL;
                    m_LVSelection.Retrieve(0, &pUser);
                    if (UserIsAdministrator(pUser))
                    {
                        //
                        // If user is administrator, the limit is always "No Limit".
                        // This will disable the "Limit" controls and prevent
                        // user from setting a limit on this account.
                        //
                        iUseAsValue = USE_NOLIMIT;
                    }
                    else if (NOLIMIT == m_llQuotaLimit)
                    {
                        //
                        // Account isn't Administrator AND the limit is NOLIMIT.
                        // Use the volume's default "new user" limit value.
                        //
                        iUseAsValue = USE_VOLDEF;
                    }
                }
                else if (!m_bHomogeneousSelection || NOLIMIT == m_llQuotaLimit) // Multiple user.
                {
                    //
                    // Multiple non-homogeneous users get the volume's default limit.
                    // Multiple homogeneous users get their current cached setting unless
                    // the cached setting is NOLIMIT; in which case, they get the
                    // volume's defaults.
                    //
                    iUseAsValue = USE_VOLDEF;
                }

                //
                // Set the proper quota limit value in the edit/combo box control.
                //
                llValue = 0;
                switch(iUseAsValue)
                {
                    case USE_VOLDEF:
                        m_pQuotaControl->GetDefaultQuotaLimit(&llValue);
                        //
                        // If default is NOLIMIT, display 0 MB.  We can't display an
                        // "editable" No Limit in the edit control.  Only numbers.
                        //
                        if (NOLIMIT == llValue)
                            llValue = 0;
                        break;

                    case USE_NOLIMIT:
                        llValue = NOLIMIT;
                        break;

                    case USE_CACHED:
                        llValue = m_llQuotaLimit;
                        break;
                }

                m_pxbQuotaLimit->SetBytes(llValue);


                ///////////////////////////////////////////////////////////////
                // Now the threshold controls...
                ///////////////////////////////////////////////////////////////
                llValue = 0;
                iUseAsValue       = USE_CACHED;
                if (0 == cSelected)
                {
                    iUseAsValue = USE_VOLDEF;
                }
                else if (1 == cSelected)
                {
                    if (NOLIMIT == m_llQuotaThreshold)
                    {
                        iUseAsValue = USE_VOLDEF;
                    }
                }
                else if (!m_bHomogeneousSelection || NOLIMIT == m_llQuotaThreshold)
                {
                    iUseAsValue = USE_VOLDEF;
                }

                //
                // Set the proper quota threshold value in the edit/combo box control.
                //
                switch(iUseAsValue)
                {
                    case USE_VOLDEF:
                        m_pQuotaControl->GetDefaultQuotaThreshold(&llValue);
                        //
                        // If default is NOLIMIT, display 0 MB.  We can't display an
                        // "editable" No Limit in the edit control.  Only numbers.
                        //
                        if (NOLIMIT == llValue)
                            llValue = 0;
                        break;

                    case USE_NOLIMIT:
                        llValue = NOLIMIT;
                        break;

                    case USE_CACHED:
                        llValue = m_llQuotaThreshold;
                        break;
                }

                m_pxbQuotaThreshold->SetBytes(llValue);

                m_bIsDirty = TRUE;
            }
            break;
        }

        case IDC_EDIT_USER_LIMIT:
        case IDC_EDIT_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, EN_CHANGE")));
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    m_bIsDirty = TRUE;
                    break;

                case EN_KILLFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, EN_KILLFOCUS")));
                    bResult = OnEditNotifyKillFocus(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_USER_LIMIT:
        case IDC_CMB_USER_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("OnCommand, CBN_CHANGE")));
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    m_bIsDirty = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            bResult = TRUE;  // Didn't handle message.
            break;
    }


    if (m_bIsDirty)
        PropSheet_Changed(GetParent(hDlg), hDlg);

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnNotify

    Description: Handler for WM_NOTIFY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnNotify(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    switch(((NMHDR *)lParam)->code)
    {
        case PSN_SETACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_SETACTIVE")));
            bResult = OnSheetNotifySetActive(hDlg, wParam, lParam);
            break;

        case PSN_APPLY:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_APPLY")));
            bResult = OnSheetNotifyApply(hDlg, wParam, lParam);
            break;

        case PSN_KILLACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_KILLACTIVE")));
            bResult = OnSheetNotifyKillActive(hDlg, wParam, lParam);
            break;

        case PSN_RESET:
            DBGPRINT((DM_WND, DL_MID, TEXT("OnNotify, PSN_RESET")));
            //
            // Fall through.
            //
        default:
            break;
    }
    return bResult;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifySetActive

    Description: Handler for WM_NOTIFY - PSN_SETACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        FALSE = Accept activation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifySetActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifyApply

    Description: Handler for WM_NOTIFY - PSN_APPLY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE = PSN return value set using SetWindowLong.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifyApply(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult  = NO_ERROR;
    LONG dwPSNReturn = PSNRET_NOERROR;

    //
    // Only apply settings if the "Apply" button is enabled indicating
    // that something has been changed.  No need to apply unchanged
    // settings when the OK button is pressed.
    //
    if (m_bIsDirty)
    {
        if (PSNRET_NOERROR == dwPSNReturn)
        {
            //
            // We need to do this because if you activate the apply button
            // with Alt-A we receive PSN_APPLY before EN_KILLFOCUS.
            //
            m_pxbQuotaThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_THRESHOLD));
            m_pxbQuotaLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_USER_LIMIT));

            //
            // Ensure warning threshold is not above limit.
            //
            INT64 iThreshold = m_pxbQuotaThreshold->GetBytes();
            INT64 iLimit     = m_pxbQuotaLimit->GetBytes();

            if (NOLIMIT != iLimit && iThreshold > iLimit)
            {
                TCHAR szLimit[40], szThreshold[40];
                XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
                XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

                CString s(g_hInstDll, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
                switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
                {
                    case IDYES:
                        m_pxbQuotaThreshold->SetBytes(iLimit);
                        break;

                    case IDNO:
                        //
                        // This m_idCtlNextFocus hack stuff is here because I can't get
                        // the @#$%! prop sheet to return focus to the threshold control.
                        // The only way I've been able to get this to happen is to
                        // cache this ID value then on the EN_SETFOCUS generated when
                        // the page is activated, set focus to the control.
                        // Gross but it works without too much hassle. [brianau]
                        //
                        m_idCtlNextFocus = IDC_EDIT_USER_THRESHOLD;
                        dwPSNReturn = PSNRET_INVALID;
                        break;
                }
            }
        }
        if (PSNRET_NOERROR == dwPSNReturn)
        {
            hResult = ApplySettings(hDlg);
            if (FAILED(hResult))
            {
                INT idMsg   = IDS_UNKNOWN_ERROR;
                UINT uFlags = MB_OK;
                switch(hResult)
                {
                    case E_FAIL:
                        idMsg = IDS_WRITE_ERROR;
                        uFlags |= MB_ICONERROR;
                        break;

                    default:
                        switch(HRESULT_CODE(hResult))
                        {

//                      case ERROR_USER_EXISTS:
//                          idMsg = IDS_NOADD_EXISTING_USER;
//                          uFlags |= MB_ICONWARNING;
//                          break;
//
// FEATURE:  Still valid?  [brianau - 5/27/98]
//
                            case ERROR_NO_SUCH_USER:
                                idMsg = IDS_NOADD_UNKNOWN_USER;
                                uFlags |= MB_ICONWARNING;
                                break;

                            case ERROR_ACCESS_DENIED:
                                idMsg  = IDS_NO_WRITE_ACCESS;
                                uFlags |= MB_ICONWARNING;
                                break;

                            default:
                            uFlags |= MB_ICONERROR;
                            break;
                        }
                        break;
                }

                DiskQuotaMsgBox(GetDesktopWindow(),
                                idMsg,
                                IDS_TITLE_DISK_QUOTA,
                                uFlags);

                dwPSNReturn = PSNRET_INVALID;
            }
            else
            {
                m_bIsDirty = FALSE;
            }
        }
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwPSNReturn);

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnSheetNotifyKillActive

    Description: Handler for WM_NOTIFY - PSN_KILLACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE  = Invalid data entered.  Don't kill page.
        FALSE = All data is valid.  Ok to kill page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnSheetNotifyKillActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bAllDataIsValid = TRUE;

    //
    // No sheet-level validation performed at this time.
    //
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !bAllDataIsValid);

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnHelp

    Description: Handler for WM_HELP.  Displays context sensitive help.

    Arguments:
        lParam - Pointer to a HELPINFO structure.

    Returns: TRUE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgUserPropSheetHelpIDs);
    return TRUE;
}


INT_PTR
UserPropSheet::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgUserPropSheetHelpIDs));

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropPage::OnEditNotifyUpdate

    Description: Handler for WM_COMMAND, EN_UPDATE.
        Called whenever a character is entered in an edit control.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditNotifyUpdate(lParam);

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::OnEditNotifyKillFocus

    Description: Handler for WM_COMMAND, EN_KILLFOCUS.
        Called whenever focus leaves an edit control.
        Validates the value in the edit control and adjusts it if necessary.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnEditNotifyKillFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_EDIT_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_EDIT_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }

    if (NULL != pxb)
        pxb->OnEditKillFocus(lParam);

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropPage::OnComboNotifySelChange

    Description: Handler for WM_COMMAND, CBN_SELCHANGE.
        Called whenever the user selects the combo box.

    Arguments: Std DlgProc args.

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/03/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
UserPropSheet::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *pxb = NULL;

    switch(LOWORD(wParam))
    {
        case IDC_CMB_USER_LIMIT:
            pxb = m_pxbQuotaLimit;
            break;

        case IDC_CMB_USER_THRESHOLD:
            pxb = m_pxbQuotaThreshold;
            break;

        default:
            break;
    }
    if (NULL != pxb)
       pxb->OnComboNotifySelChange(lParam);

    return FALSE;
}




///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::ApplySettings

    Description: Applies the current settings to the user's quota information
        if they have not changed from the original settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR            - Success.
        E_INVALIDARG        - One of the settings was invalid.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    01/24/98    Added bUndo argument.                                BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::ApplySettings(
    HWND hDlg,
    bool bUndo    // Default == true.
    )
{
    HRESULT hResult         = NO_ERROR;
    BOOL  bTranslated       = FALSE;
    com_autoptr<DISKQUOTA_USER> ptrUser;
    UINT cUsers             = m_LVSelection.Count();
    UINT i                  = 0;
    LONGLONG llThreshold;
    LONGLONG llLimit;
    CAutoSetRedraw autoredraw(m_hWndParent);

    if (bUndo)
        m_UndoList.Clear();  // Clear current undo list.

    //
    // Determine what threshold and limit to apply.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        llThreshold = NOLIMIT;
        llLimit     = NOLIMIT;
    }
    else
    {
        llThreshold = m_pxbQuotaThreshold->GetBytes();
        llLimit     = m_pxbQuotaLimit->GetBytes();
    }

    if (cUsers > 1)
    {
        //
        // Create batch object and do batch update for multiple users.
        //
        com_autoptr<DISKQUOTA_USER_BATCH> ptrBatch;

        hResult = m_pQuotaControl->CreateUserBatch(ptrBatch.getaddr());
        if (SUCCEEDED(hResult))
        {
            for (i = 0; i < cUsers; i++)
            {
                m_LVSelection.Retrieve(i, ptrUser.getaddr());
                if (bUndo)
                {
                    //
                    // Add an entry to the undo list.
                    //
                    LONGLONG LimitUndo;
                    LONGLONG ThresholdUndo;
                    ptrUser->GetQuotaThreshold(&ThresholdUndo);
                    ptrUser->GetQuotaLimit(&LimitUndo);
                    //
                    // Use a local autoptr to ensure proper release of
                    // iface in case adding to the undo list throws an exception.
                    // On success, disown the real ptr so that the object
                    // stays with the undo list.
                    //
                    com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);
                    ptrUser->AddRef();
                    m_UndoList.Add(new UndoModify(ptrUser, ThresholdUndo, LimitUndo));
                    ptrQuotaUser.disown();
                }

                ptrUser->SetQuotaThreshold(llThreshold, FALSE);

                if (UserIsAdministrator(ptrUser) && NOLIMIT != llLimit)
                {
                    //
                    // User is the Administrator account AND
                    // We're trying to set the limit to something other than NOLIMIT.
                    // Can't set a limit on the administrator account.
                    //
                    DiskQuotaMsgBox(GetDesktopWindow(),
                                    IDS_CANT_SET_ADMIN_LIMIT,
                                    IDS_TITLE_DISK_QUOTA,
                                    MB_ICONWARNING | MB_OK);
                }
                else
                {
                    //
                    // OK to set quota limit.
                    //
                    ptrUser->SetQuotaLimit(llLimit, FALSE);
                }

                ptrBatch->Add(ptrUser);
            }

            hResult = ptrBatch->FlushToDisk();
        }
    }
    else
    {
        //
        // Do single user update or add new user.
        //
        m_LVSelection.Retrieve(0, ptrUser.getaddr());
        DBGASSERT((NULL != ptrUser.get()));

        if (bUndo)
        {
            //
            // Add an entry to the undo list.
            //
            LONGLONG LimitUndo;
            LONGLONG ThresholdUndo;
            ptrUser->GetQuotaThreshold(&ThresholdUndo);
            ptrUser->GetQuotaLimit(&LimitUndo);
            //
            // Use local autoptr to ensure proper release of iface ptr if
            // an exception is thrown.  Disown real ptr on success.
            //
            com_autoptr<DISKQUOTA_USER> ptrQuotaUser(ptrUser);
            ptrUser->AddRef();
            m_UndoList.Add(new UndoModify(ptrUser, ThresholdUndo, LimitUndo));
            ptrQuotaUser.disown();
        }

        if (llThreshold != m_llQuotaThreshold)
        {
            hResult = ptrUser->SetQuotaThreshold(llThreshold, TRUE);

            if (FAILED(hResult))
                goto apply_failed;

            m_llQuotaThreshold = llThreshold;
        }

        if (llLimit != m_llQuotaLimit)
        {
            hResult = ptrUser->SetQuotaLimit(llLimit, TRUE);
            if (FAILED(hResult))
                goto apply_failed;

            m_llQuotaLimit = llLimit;
        }

        //
        // Update the user's status icon and %used to reflect the new settings.
        //
        UpdateUserStatusIcon(hDlg,
                             m_llQuotaUsed,
                             m_llQuotaThreshold,
                             m_llQuotaLimit);

        UpdateSpaceUsed(hDlg,
                        m_llQuotaUsed,
                        m_llQuotaLimit,
                        1);
    }

    //
    // Update the listview item(s) so the user sees a visual response to
    // pressing the "Apply" button.
    //
    autoredraw.Set(false);
    for (i = 0; i < cUsers; i++)
    {
        INT iItem = 0;
        m_LVSelection.Retrieve(i, &iItem);
        ListView_Update(m_hWndParent, iItem);
    }
    autoredraw.Set(true);
    InvalidateRect(m_hWndParent, NULL, FALSE);

apply_failed:

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::InitializeControls

    Description: Initializes the page controls based on the user's
        quota settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
UserPropSheet::InitializeControls(
    HWND hDlg
    )
{
    PDISKQUOTA_USER pUser = NULL;
    UINT cUsers           = m_LVSelection.Count();

    if (1 == cUsers)
    {
        //
        // Initialize controls for a single user.
        //
        m_LVSelection.Retrieve(0, &pUser);

        //
        // Configure the Limit/NoLimit radio buttons.
        // Must examine the current threshold rather than the limit because of the
        // special-case for the Administrator account.  That account can have a
        // threshold value but quota limit must always be "No Limit".
        //
        CheckDlgButton(hDlg, IDC_RBN_USER_LIMIT,   NOLIMIT != m_llQuotaThreshold);
        CheckDlgButton(hDlg, IDC_RBN_USER_NOLIMIT, NOLIMIT == m_llQuotaThreshold);
        if (UserIsAdministrator(pUser))
        {
            //
            // Override initialization of Quota Limit control with "No Limit".
            //
            m_pxbQuotaLimit->SetBytes(NOLIMIT);
        }

        //
        // Note that the XBytes controls have already been set for single-user.
        // See OnInitDialog().
        //

        //
        // Configure the remaining dialog controls.
        //
        UpdateUserName(hDlg, pUser);
        UpdateSpaceUsed(hDlg, m_llQuotaUsed, m_llQuotaLimit, cUsers);
        UpdateUserStatusIcon(hDlg,
                             m_llQuotaUsed,
                             m_llQuotaThreshold,
                             m_llQuotaLimit);
    }
    else
    {
        //
        // Initialize controls for multiple users.
        //
        LONGLONG llLimit         = 0;
        LONGLONG llLastLimit     = 0;
        LONGLONG llThreshold     = 0;
        LONGLONG llLastThreshold = 0;
        LONGLONG llUsed          = 0;
        LONGLONG llTotalUsed     = 0;

        //
        // Add up the total usage by all users.
        //
        for (UINT i = 0; i < cUsers; i++)
        {
            m_LVSelection.Retrieve(i, &pUser);
            pUser->GetQuotaLimit(&llLimit);
            pUser->GetQuotaThreshold(&llThreshold);
            pUser->GetQuotaUsed(&llUsed);

            llTotalUsed += llUsed;
            if (m_bHomogeneousSelection)
            {
                //
                // Determine if at least one user has a different
                // threshold or limit. If all are the same, we can display
                // the values in the edit controls.  Otherwise, we default
                // to "No Limit".  Radio buttons don't provide an
                // indeterminate state like checkboxes.
                //
                if (i > 0 &&
                    (llLimit != llLastLimit ||
                     llThreshold != llLastThreshold))
                {
                    m_bHomogeneousSelection = FALSE;
                }
                else
                {
                    llLastLimit     = llLimit;
                    llLastThreshold = llThreshold;
                }
            }
        }

        //
        // If all selected objects have the same limit and threshold,
        // set the cached data to represent multiple-selection.
        // If any one is different, we stick with the volume's default
        // values set in RefreshCachedQuotaInfo().
        //
        if (m_bHomogeneousSelection)
        {
            m_llQuotaThreshold = llLastThreshold;
            m_llQuotaLimit     = llLastLimit;
        }
        else
        {
            //
            // Since not all selected users have the same limit/thresold,
            // the number we're displaying will be a change for at least
            // one user.  Activate the "Apply" button.
            //
            //
            PostMessage(hDlg, DQM_ENABLE_APPLY_BUTTON, 0, 0);
        }

        m_pxbQuotaThreshold->SetBytes(m_llQuotaThreshold);
        m_pxbQuotaLimit->SetBytes(m_llQuotaLimit);

        //
        // Configure the Limit/NoLimit radio buttons.
        //
        CheckDlgButton(hDlg,
                       IDC_RBN_USER_NOLIMIT,
                       NOLIMIT == m_llQuotaThreshold);
        CheckDlgButton(hDlg,
                       IDC_RBN_USER_LIMIT,
                       NOLIMIT != m_llQuotaThreshold);

        UpdateUserName(hDlg, cUsers);
        UpdateSpaceUsed(hDlg, llTotalUsed, NOLIMIT, cUsers);
        //
        // Don't display any user status icon for multi-users.
        //
    }


    //
    // If "No Limit" radio button is checked, set limit and threshold controls
    // to the "No Limit" state (disabled and displaying "No Limit" text).
    // This may override any setting we made above.
    //
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_USER_NOLIMIT))
    {
        m_pxbQuotaThreshold->SetBytes(NOLIMIT);
        m_pxbQuotaLimit->SetBytes(NOLIMIT);
    }

    //
    // Set user icon.
    //
    SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                STM_SETICON,
                (WPARAM)m_hIconUser[1 == cUsers ? iICON_USER_SINGLE :
                                                  iICON_USER_MULTIPLE],
                0);

    //
    // Force the property sheet to disable the "Apply" button.
    // The way I have set up the "Apply" enabling logic through OnCommand(),
    // merely initializing the edit controls on the page causes the Apply
    // button to become enabled.  Since the user hasn't changed anything
    // yet, it should be disabled.
    //
    m_bIsDirty = FALSE;
    PropSheet_UnChanged(GetParent(hDlg), hDlg);

    return NO_ERROR;
}





///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::QueryUserStatusIcon


    Description: This function is provided for automated testing of the UI.
        It is used by test scripts to determine which user status icon is
        currently displayed.

    Arguments:
        hDlg - Dialog handle.


    Returns: -1 = No icon displayed.
              0 = "Everything OK" icon.
              1 = Threshold exceded icon.
              2 = Limit exceded icon.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
UserPropSheet::QueryUserStatusIcon(
    HWND hDlg
    ) const
{
    HICON hicon = (HICON)SendMessage(GetDlgItem(hDlg, IDC_ICON_USERSTATUS),
                                    STM_GETICON,
                                    0, 0);

    for (UINT i = 0; i < cSTATUS_ICONS; i++)
    {
        if (hicon == m_hIconStatus[i])
            return i;
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::QueryUserIcon


    Description: This function is provided for automated testing of the UI.
        It is used by test scripts to determine which user status icon is
        currently displayed.

    Arguments:
        hDlg - Dialog handle.


    Returns: -1 = No icon displayed.
              0 = Single-user icon.
              1 = Multi-user icon.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT
UserPropSheet::QueryUserIcon(
    HWND hDlg
    ) const
{
    HICON hicon = (HICON)SendMessage(GetDlgItem(hDlg, IDC_ICON_USER),
                                     STM_GETICON,
                                     0, 0);

    for (UINT i = 0; i < cUSER_ICONS; i++)
    {
        if (hicon == m_hIconUser[i])
            return i;
    }
    return -1;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserStatusIcon

    Description: Updates the quota status icon in the dialog box.  This icon
        must match the icon displayed in the listview for the selected user.

    Arguments:
        hDlg - Dialog handle.

        iUsed - Quota bytes charged to user.

        iThreshold - Quota warning threshold (bytes).

        iLimit - User's quota limit.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserStatusIcon(
    HWND hDlg,
    LONGLONG iUsed,
    LONGLONG iThreshold,
    LONGLONG iLimit
    )
{
    //
    // Set the user status icon if user is exceding the
    // quota threshold or the limit.  This is the same icon that is
    // displayed in the listview status column.  This logic must
    // mirror that used in DetailsView::GetDispInfo_Image().
    //
    INT iIcon = iICON_STATUS_OK;
    if (NOLIMIT != iLimit && iUsed > iLimit)
    {
        iIcon = iICON_STATUS_OVER_LIMIT;
    }
    else if (NOLIMIT != iThreshold && iUsed > iThreshold)
    {
        iIcon = iICON_STATUS_OVER_THRESHOLD;
    }

    SendMessage(GetDlgItem(hDlg, IDC_ICON_USERSTATUS),
                STM_SETICON,
                (WPARAM)m_hIconStatus[iIcon],
                0);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserName

    Description: Updates the Domain\Name text with the user's domain name
        and account name strings.  This method is called for a single-user
        selection.

        Also sets the property sheet title text.

    Arguments:
        hDlg - Dialog handle.

        pUser - Address of user's IDiskQuotaUser interface.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/05/97    Added code to set prop sheet title text.             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserName(
    HWND hDlg,
    PDISKQUOTA_USER pUser
    )
{
    DBGASSERT((NULL != pUser));
    //
    // Display the user name, or some status text
    // if the name hasn't been resolved.
    //
    CString strLogonName;
    DWORD dwAccountStatus = 0;

    pUser->GetAccountStatus(&dwAccountStatus);

    if (DISKQUOTA_USER_ACCOUNT_RESOLVED == dwAccountStatus)
    {
        //
        // User account name has been resolved.  Display it.
        //
        TCHAR szLogonName[MAX_USERNAME];
        TCHAR szDisplayName[MAX_FULL_USERNAME];

        pUser->GetName(NULL, 0,
                       szLogonName, ARRAYSIZE(szLogonName),
                       szDisplayName, ARRAYSIZE(szDisplayName));

        if (TEXT('\0') != szLogonName[0])
        {
            if (TEXT('\0') != szDisplayName[0])
            {
                strLogonName.Format(g_hInstDll,
                                    IDS_FMT_DISPLAY_LOGON,
                                    szDisplayName,
                                    szLogonName);
            }
            else
            {
                strLogonName = szLogonName;
            }
        }
    }
    else
    {
        //
        // User account name has not been resolved or cannot
        // be resolved for some reason.  Display appropriate
        // status text.  This is the same text displayed in the
        // listview when the user's name has not been resolved.
        //
        INT idText = IDS_USER_ACCOUNT_UNKNOWN;

        switch(dwAccountStatus)
        {
            case DISKQUOTA_USER_ACCOUNT_UNAVAILABLE:
                idText = IDS_USER_ACCOUNT_UNAVAILABLE;
                break;

            case DISKQUOTA_USER_ACCOUNT_DELETED:
                idText = IDS_USER_ACCOUNT_DELETED;
                break;

            case DISKQUOTA_USER_ACCOUNT_INVALID:
                idText = IDS_USER_ACCOUNT_INVALID;
                break;

            case DISKQUOTA_USER_ACCOUNT_UNRESOLVED:
                idText = IDS_USER_ACCOUNT_UNRESOLVED;
                break;

            case DISKQUOTA_USER_ACCOUNT_UNKNOWN:
            default:
                break;
        }
        strLogonName.Format(g_hInstDll, idText);
    }
    SetDlgItemText(hDlg, IDC_TXT_USERNAME, strLogonName);

    //
    // Format and draw the prop sheet title string.
    //
    CString strSheetTitle(g_hInstDll,
                          IDS_TITLE_EDIT_USER,
                          (LPCTSTR)strLogonName);

    PropSheet_SetTitle(GetParent(hDlg), 0, (LPCTSTR)strSheetTitle);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateUserName

    Description: Replaces the user Domain\Name text with a message showing
        how many users are selected.   This is used for multi-user selections
        where no single user name is applicable.

        Also sets the property sheet title text.

    Arguments:
        hDlg - Dialog handle.

        cUsers - Number of users represented in the property dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/05/97    Added code to set prop sheet title text.             BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateUserName(
    HWND hDlg,
    INT cUsers
    )
{
    //
    // Hide name edit control.  Can't display names for all users.
    // Display "Multiple Quota Users." instead.
    //
    CString strText(g_hInstDll, IDS_TITLE_MULTIUSER, cUsers);
    SetDlgItemText(hDlg, IDC_TXT_USERNAME, strText);

    //
    // Set the title of the property sheet.
    //
    CString strSheetTitle(g_hInstDll, IDS_TITLE_EDIT_MULTIUSER);
    PropSheet_SetTitle(GetParent(hDlg), 0, (LPCTSTR)strSheetTitle);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: UserPropSheet::UpdateSpaceUsed

    Description: Updates the "space used" and "remaining" fields on the user
        property sheet.

    Arguments:
        hDlg - Dialog handle.

        iUsed - Quota bytes charged to user(s).

        iLimit - User's quota limit.

        cUsers - Number of users represented in the property dialog.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
UserPropSheet::UpdateSpaceUsed(
    HWND hDlg,
    LONGLONG iUsed,
    LONGLONG iLimit,
    INT cUsers
    )
{
    TCHAR szText[80];

    //
    // Display - Used: 999XB (99%)
    //
    XBytes::FormatByteCountForDisplay(iUsed,
                                      szText, ARRAYSIZE(szText));
    CString strText(szText);
    if (1 == cUsers)
    {
        //
        // Only single-user page gets (99%) appended.
        // Pct quota is meaningless for multiple users.
        //
        if (0 != iLimit && NOLIMIT != iLimit)
        {
            UINT iPct = (INT)((iUsed * 100) / iLimit);

            strText.Format(g_hInstDll,
                           IDS_QUOTA_USED_SINGLEUSER,
                           szText,
                           iPct);
        }
    }

    SetDlgItemText(hDlg,
                  IDC_TXT_SPACEUSED,
                  strText);


    //
    // Display - Remaining: 999XB
    //
    strText = szText;
    if (NOLIMIT != iLimit)
    {
        LONGLONG iAmount = 0;

        if (iUsed <= iLimit)
            iAmount = iLimit - iUsed;

        XBytes::FormatByteCountForDisplay(iAmount,
                                          strText.GetBuffer(80), 80);
        strText.ReleaseBuffer();
    }
    else
    {
        //
        // Display "N/A" if limit is NOLIMIT.
        //
        strText.Format(g_hInstDll, IDS_NOT_APPLICABLE);
    }

    SetDlgItemText(hDlg,
                   IDC_TXT_SPACEREMAINING,
                   strText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\volprop.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: volprop.cpp

    Description: Provides implementations for quota property pages.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
    11/27/98    Added logging checkboxes back in.                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "dskquota.h"
#include "volprop.h"
#include "uihelp.h"
#include "registry.h"
#include "guidsp.h"
#include "uiutils.h"

#ifdef POLICY_MMC_SNAPIN
#   include "snapin.h"
#endif

//
// Context help IDs.
//
#pragma data_seg(".text", "CODE")
const static DWORD rgVolumePropPageHelpIDs[] =
{
    IDC_TRAFFIC_LIGHT,          IDH_TRAFFIC_LIGHT,
    IDC_TXT_QUOTA_STATUS,       IDH_TXT_QUOTA_STATUS,
    IDC_TXT_QUOTA_STATUS_LABEL, DWORD(-1),
    IDC_CBX_ENABLE_QUOTA,       IDH_CBX_ENABLE_QUOTA,
    IDC_CBX_DENY_LIMIT,         IDH_CBX_DENY_LIMIT,
    IDC_RBN_DEF_NOLIMIT,        IDH_RBN_DEF_NO_LIMIT,
    IDC_RBN_DEF_LIMIT,          IDH_RBN_DEF_LIMIT,
    IDC_EDIT_DEF_LIMIT,         IDH_EDIT_DEF_LIMIT,
    IDC_EDIT_DEF_THRESHOLD,     IDH_EDIT_DEF_THRESHOLD,
    IDC_CMB_DEF_LIMIT,          IDH_CMB_DEF_LIMIT,
    IDC_CMB_DEF_THRESHOLD,      IDH_CMB_DEF_THRESHOLD,
    IDC_BTN_DETAILS,            IDH_BTN_DETAILS,
    IDC_BTN_EVENTLOG,           IDH_BTN_EVENTLOG,
    IDC_CBX_LOG_OVERWARNING,    IDH_CBX_LOG_OVERWARNING,
    IDC_CBX_LOG_OVERLIMIT,      IDH_CBX_LOG_OVERLIMIT,
    IDC_TXT_DEFAULTS,           IDH_GRP_DEFAULTS,
    IDC_TXT_LOGGING,            DWORD(-1),
    IDC_TXT_WARN_LEVEL,         DWORD(-1),
    0,0
};


#pragma data_seg()

#ifdef POLICY_MMC_SNAPIN
const TCHAR c_szSnapInPrefs[] = TEXT("GPTEditorExtData");
#endif

extern TCHAR c_szWndClassDetailsView[]; // defined in details.cpp

/*
// NOTE:  This code has been disabled.
//          I've left in case we decide to launch the event viewer from
//          the volume prop page again. [brianau - 3/23/98]
//
const TCHAR c_szVerbOpen[]          = TEXT("Open");
const TCHAR c_szManagementConsole[] = TEXT("MMC.EXE");
const TCHAR c_szMMCInitFile[]       = TEXT("%SystemRoot%\\System32\\EVENTVWR.MSC");
*/


#define VPPM_FOCUS_ON_THRESHOLDEDIT  (WM_USER + 1)


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::VolumePropPage

    Description: Constructor for a volume property page object.
        Initializes the members that hold volume quota data.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VolumePropPage::VolumePropPage(VOID)
    : m_dwQuotaState(0),
      m_dwQuotaLogFlags(0),
      m_idStatusUpdateTimer(0),
      m_dwLastStatusMsgID(0),
      m_cVolumeMaxBytes(NOLIMIT),
      m_pxbDefaultLimit(NULL),
      m_pxbDefaultThreshold(NULL),
      m_llDefaultQuotaThreshold(0),
      m_llDefaultQuotaLimit(0),
      m_idCtlNextFocus(-1)
{

}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::~VolumePropPage

    Description: Destructor for a volume property page object.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VolumePropPage::~VolumePropPage(
    VOID
    )
{
    delete m_pxbDefaultLimit;
    delete m_pxbDefaultThreshold;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::DlgProc

    Description: Static method called by windows to process messages for the
        property page dialog.  Since it's static, we have to save the "this"
        pointer in the window's USERDATA.

    Arguments: Standard WndProc-type arguments.

    Returns: Standard WndProc-type return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR APIENTRY
VolumePropPage::DlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = FALSE;

    //
    // Retrieve the "this" pointer from the dialog's userdata.
    // It was placed there in OnInitDialog().
    //
    VolumePropPage *pThis = (VolumePropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    try
    {
        switch(message)
        {
            case WM_INITDIALOG:
            {
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_INITDIALOG")));
                PROPSHEETPAGE *pPage = (PROPSHEETPAGE *)lParam;
                pThis = (VolumePropPage *)pPage->lParam;

                DBGASSERT((NULL != pThis));
                //
                // pThis pointer AddRef'd in AddPages().
                // Save it in the window's userdata.
                //
                SetWindowLongPtr(hDlg, DWLP_USER, (INT_PTR)pThis);
                bResult = pThis->OnInitDialog(hDlg, wParam, lParam);
                break;
            }

            case WM_SYSCOLORCHANGE:
                bResult = pThis->m_TrafficLight.ForwardMessage(message, wParam, lParam);
                break;

            case WM_NOTIFY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY")));
                bResult = pThis->OnNotify(hDlg, wParam, lParam);
                break;

            case WM_COMMAND:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND")));
                bResult = pThis->OnCommand(hDlg, wParam, lParam);
                break;

            case WM_HELP:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_HELP")));
                bResult = pThis->OnHelp(hDlg, wParam, lParam);
                break;

            case WM_CONTEXTMENU:
                bResult = pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
                break;

            case WM_DESTROY:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_DESTROY")));
                pThis->KillStatusUpdateTimer(hDlg);
                //
                // Nothing to do.
                //
                break;

            case WM_TIMER:
                DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_TIMER")));
                bResult = pThis->OnTimer(hDlg, wParam, lParam);
                break;

            case VPPM_FOCUS_ON_THRESHOLDEDIT:
                //
                // This is sort of a hack because of the way the prop sheet
                // code in comctl32 sets focus after a page has returned
                // PSNRET_INVALID.  It automatically activates the problem
                // page and sets focus to the FIRST control in the tab order.
                // Since the only failure we generate is from the threshold
                // exceeding the limit, I want to return focus to the threshold
                // edit control so that the user can directly change the offending
                // value.  Posting this custom message was the only way I
                // could get this to work. [brianau].
                //
                SetFocus((HWND)lParam);
                SendMessage((HWND)lParam, EM_SETSEL, 0, -1);
                break;

            default:
                break;
        }
    }
    catch(CAllocException& me)
    {
        //
        // Announce any out-of-memory errors associated with running the
        // volume Quota property page.
        //
        DiskQuotaMsgBox(GetDesktopWindow(),
                        IDS_OUTOFMEMORY,
                        IDS_TITLE_DISK_QUOTA,
                        MB_ICONERROR | MB_OK);
    }

    return bResult;
}






///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnInitDialog

    Description: Handler for WM_INITDIALOG.

    Arguments:
        hDlg - Dialog window handle.

        wParam - Handle of control to receive focus if we return FALSE.

        lParam - Pointer to PROPSHEETPAGE structure for the property page.

    Returns:
        TRUE  = Tells windows to assign focus to the control in wParam.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    02/10/98    Converted from static to a virtual function to       BrianAu
                support addition of SnapInVolPropPage class.
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hResult = NO_ERROR;
    DWORD dwSectorsPerCluster = 0;
    DWORD dwBytesPerSector    = 0;
    DWORD dwFreeClusters      = 0;
    DWORD dwTotalClusters     = 0;

    //
    // Load the volume's quota information into member variables.
    //
    hResult = RefreshCachedVolumeQuotaInfo();

    //
    // Calculate the volume's size.
    // We'll use this to limit user threshold and quota limit entries.
    //
    if (GetDiskFreeSpace(m_idVolume.ForParsing(),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters))
    {
        m_cVolumeMaxBytes = (UINT64)dwSectorsPerCluster *
                            (UINT64)dwBytesPerSector *
                            (UINT64)dwTotalClusters;
    }

    //
    // Create the XBytes objects to manage the relationship between the
    // limit/threshold edit controls and their combo boxes.
    //
    m_pxbDefaultLimit     = new XBytes(hDlg,
                                       IDC_EDIT_DEF_LIMIT,
                                       IDC_CMB_DEF_LIMIT,
                                       m_llDefaultQuotaLimit);
    m_pxbDefaultThreshold = new XBytes(hDlg,
                                       IDC_EDIT_DEF_THRESHOLD,
                                       IDC_CMB_DEF_THRESHOLD,
                                       m_llDefaultQuotaThreshold);

    m_TrafficLight.Initialize(GetDlgItem(hDlg, IDC_TRAFFIC_LIGHT), IDR_AVI_TRAFFIC);

    InitializeControls(hDlg);

    return TRUE;  // Set focus to default control.
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnCommand

    Description: Handler for WM_COMMAND.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT_PTR bResult = TRUE;
    DWORD dwCtlId        = LOWORD(wParam);
    HWND hWndCtl         = (HWND)lParam;
    DWORD dwNotifyCode   = HIWORD(wParam);
    BOOL bIsChecked      = FALSE;
    BOOL bEnableApplyBtn = FALSE;

    switch(dwCtlId)
    {
        case IDC_CBX_ENABLE_QUOTA:
        {
            //
            // This is executed when the user checks or unchecks the
            // "Enable quota management checkbox.
            //
            bIsChecked = IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA);
            //
            // Remember: Limit/Threshold Edit and combo boxes are enabled/disabled
            //           through XBytes::SetBytes().
            //
            m_pxbDefaultLimit->SetBytes(m_llDefaultQuotaLimit);
            m_pxbDefaultThreshold->SetBytes(m_llDefaultQuotaThreshold);

            CheckDlgButton(hDlg, IDC_RBN_DEF_NOLIMIT, NOLIMIT == m_pxbDefaultLimit->GetBytes());
            CheckDlgButton(hDlg, IDC_RBN_DEF_LIMIT,   BST_CHECKED != IsDlgButtonChecked(hDlg, IDC_RBN_DEF_NOLIMIT));
            CheckDlgButton(hDlg, IDC_CBX_DENY_LIMIT,  bIsChecked && DISKQUOTA_IS_ENFORCED(m_dwQuotaState));
            CheckDlgButton(hDlg,
                           IDC_CBX_LOG_OVERWARNING,
                           bIsChecked &&
                           DISKQUOTA_IS_LOGGED_USER_THRESHOLD(m_dwQuotaLogFlags));
            CheckDlgButton(hDlg,
                           IDC_CBX_LOG_OVERLIMIT,
                           bIsChecked &&
                           DISKQUOTA_IS_LOGGED_USER_LIMIT(m_dwQuotaLogFlags));

            EnableControls(hDlg);

            bEnableApplyBtn = TRUE;
            bResult = FALSE;
            break;
        }

        case IDC_CBX_DENY_LIMIT:
            bResult = FALSE;
            bEnableApplyBtn = TRUE;
            break;

        case IDC_RBN_DEF_NOLIMIT:
            DBGASSERT((IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA)));

            if (m_pxbDefaultLimit->IsEnabled())
            {
                m_pxbDefaultThreshold->SetBytes(NOLIMIT);
                m_pxbDefaultLimit->SetBytes(NOLIMIT);
                bEnableApplyBtn = TRUE;
            }
            bResult = FALSE;
            break;

        case IDC_RBN_DEF_LIMIT:
            //
            // If the original threshold was -1 (no limit), set to 0.
            // Otherwise, set to the original value.
            //
            DBGASSERT((IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA)));
            if (!m_pxbDefaultLimit->IsEnabled())
            {
                m_pxbDefaultLimit->SetBytes(NOLIMIT == m_llDefaultQuotaLimit ?
                                            0 : m_llDefaultQuotaLimit);
                m_pxbDefaultThreshold->SetBytes(NOLIMIT == m_llDefaultQuotaThreshold ?
                                                0 : m_llDefaultQuotaThreshold);


                EnableControls(hDlg);
                bEnableApplyBtn = TRUE;
            }
            bResult = FALSE;
            break;

        case IDC_EDIT_DEF_LIMIT:
        case IDC_EDIT_DEF_THRESHOLD:
            switch(dwNotifyCode)
            {
                case EN_UPDATE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_CHANGE")));
                    bResult = OnEditNotifyUpdate(hDlg, wParam, lParam);
                    bEnableApplyBtn = TRUE;
                    break;

                case EN_KILLFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_KILLFOCUS")));
                    bResult = OnEditNotifyKillFocus(hDlg, wParam, lParam);
                    break;

                case EN_SETFOCUS:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc; WM_COMMAND, EN_SETFOCUS")));
                    bResult = OnEditNotifySetFocus(hDlg, wParam, lParam);
                    break;

                default:
                    break;
            }
            break;

        case IDC_CMB_DEF_LIMIT:
        case IDC_CMB_DEF_THRESHOLD:
            switch(dwNotifyCode)
            {
                case CBN_SELCHANGE:
                    DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_COMMAND, CBN_CHANGE")));
                    bResult = OnComboNotifySelChange(hDlg, wParam, lParam);
                    bEnableApplyBtn = TRUE;
                    break;

                default:
                    break;
            }
            break;

        case IDC_BTN_DETAILS:
            bResult = OnButtonDetails(hDlg, wParam, lParam);
            break;

        case IDC_CBX_LOG_OVERLIMIT:
        case IDC_CBX_LOG_OVERWARNING:
            bEnableApplyBtn = TRUE;
            break;

/*
//
// NOTE: This code disabled until we decide to launch the event viewer
//         from the volume prop page.  Probably won't happen because we
//         can't define a quota-specific error type for NT events.
//         If we can't filter an event viewer list on quota-only events,
//         there's not much use in getting to the event viewer from here.
//         [brianau - 3/23/98]
//
        case IDC_BTN_EVENTLOG:
            bResult = OnButtonEventLog(hDlg, wParam, lParam);
            break;
*/

        default:
            break;
    }

    if (bEnableApplyBtn)
        PropSheet_Changed(GetParent(hDlg), hDlg);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnNotify

    Description: Handler for WM_NOTIFY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of selected control and notification code.

        lParam - HWND of selected control.

    Returns:
        TRUE  = Message wasn't handled.
        FALSE = Message was handled.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnNotify(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_MID, TEXT("VolumePropPage::OnNotify")));
    INT_PTR bResult = TRUE;

    switch(((NMHDR *)lParam)->code)
    {
        case PSN_SETACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_SETACTIVE")));
            bResult = OnSheetNotifySetActive(hDlg, wParam, lParam);
            break;

        case PSN_APPLY:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_APPLY")));
            bResult = OnSheetNotifyApply(hDlg, wParam, lParam);
            break;

        case PSN_KILLACTIVE:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_KILLACTIVE")));
            bResult = OnSheetNotifyKillActive(hDlg, wParam, lParam);
            break;

        case PSN_RESET:
            DBGPRINT((DM_WND, DL_MID, TEXT("DlgProc: WM_NOTIFY, PSN_RESET")));
            bResult = OnSheetNotifyReset(hDlg, wParam, lParam);
            break;

        default:
            break;
    }
    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifySetActive

    Description: Handler for WM_NOTIFY - PSN_SETACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        FALSE = Accept activation.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifySetActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifySetActive")));

    //
    // Update the status text and set the status update timer.
    //
    UpdateStatusIndicators(hDlg);
    SetStatusUpdateTimer(hDlg);

    if (IDC_EDIT_DEF_THRESHOLD == m_idCtlNextFocus)
    {
        //
        // Focus is being set as a result of an invalid entry
        // in the warning level field.  Force input focus to the
        // field and select the entire contents.  User can then just
        // enter a new value.
        //
        PostMessage(hDlg,
                    VPPM_FOCUS_ON_THRESHOLDEDIT,
                    0,
                    (LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_THRESHOLD));

        m_idCtlNextFocus = -1;
    }

    return 0;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyApply

    Description: Handler for WM_NOTIFY - PSN_APPLY.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE = PSN return value set using SetWindowLong.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyApply(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyApply")));
    HRESULT hResult  = NO_ERROR;
    LONG dwPSNReturn = PSNRET_NOERROR;
    INT idMsg        = -1;

    if (!IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA) &&
        !DISKQUOTA_IS_DISABLED(m_dwQuotaState))
    {
        idMsg = IDS_DISABLE_QUOTA_WARNING;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA) &&
        DISKQUOTA_IS_DISABLED(m_dwQuotaState))
    {
        idMsg = IDS_ENABLE_QUOTA_WARNING;
    }

    if (-1 != idMsg)
    {
        //
        // User wants to disable or enable quotas.
        // Warn about what this means and let them know that
        // re-activation of quotas requires a quota file rebuild.
        //
        if (IDCANCEL == DiskQuotaMsgBox(hDlg,
                                        idMsg,
                                        IDS_TITLE_DISK_QUOTA,
                                        MB_ICONWARNING | MB_OKCANCEL))
        {
            //
            // User decided to not continue the action.
            // Restore the checkbox to it's previous setting and abort the
            // settings change.
            // Sending the message to our DlgProc resets the dependent controls
            // to their proper states.
            //
            CheckDlgButton(hDlg,
                           IDC_CBX_ENABLE_QUOTA,
                           !IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA));

            SendMessage(hDlg,
                        WM_COMMAND,
                        (WPARAM)MAKELONG((WORD)IDC_CBX_ENABLE_QUOTA, (WORD)0),
                        (LPARAM)GetDlgItem(hDlg, IDC_CBX_ENABLE_QUOTA));

            dwPSNReturn = PSNRET_INVALID;
        }
    }

    if (PSNRET_NOERROR == dwPSNReturn)
    {
        //
        // We need to do this because if you activate the apply button
        // with Alt-A we receive PSN_APPLY before EN_KILLFOCUS.
        //
        m_pxbDefaultThreshold->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_THRESHOLD));
        m_pxbDefaultLimit->OnEditKillFocus((LPARAM)GetDlgItem(hDlg, IDC_EDIT_DEF_LIMIT));

        //
        // Ensure warning threshold is not above limit.
        //
        INT64 iThreshold = m_pxbDefaultThreshold->GetBytes();
        INT64 iLimit     = m_pxbDefaultLimit->GetBytes();

        if (iThreshold > iLimit)
        {
            TCHAR szLimit[40], szThreshold[40];
            XBytes::FormatByteCountForDisplay(iLimit, szLimit, ARRAYSIZE(szLimit));
            XBytes::FormatByteCountForDisplay(iThreshold, szThreshold, ARRAYSIZE(szThreshold));

            CString s(g_hInstDll, IDS_FMT_ERR_WARNOVERLIMIT, szThreshold, szLimit, szLimit);
            switch(DiskQuotaMsgBox(hDlg, s, IDS_TITLE_DISK_QUOTA, MB_ICONWARNING | MB_YESNO))
            {
                case IDYES:
                    m_pxbDefaultThreshold->SetBytes(iLimit);
                    break;

                case IDNO:
                    m_idCtlNextFocus = IDC_EDIT_DEF_THRESHOLD;
                    dwPSNReturn = PSNRET_INVALID;
                    break;
            }
        }
    }

    if (PSNRET_NOERROR == dwPSNReturn)
    {
        hResult = ApplySettings(hDlg);
        if (FAILED(hResult))
        {
             DiskQuotaMsgBox(hDlg,
                             IDS_APPLY_SETTINGS_ERROR,
                             IDS_TITLE_DISK_QUOTA,
                             MB_ICONERROR | MB_OK);
            dwPSNReturn = PSNRET_INVALID;
            InitializeControls(hDlg);
        }
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwPSNReturn);

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyKillActive

    Description: Handler for WM_NOTIFY - PSN_KILLACTIVE.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        TRUE  = Invalid data entered.  Don't kill page.
        FALSE = All data is valid.  Ok to kill page.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyKillActive(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyKillActive")));
    BOOL bAllDataIsValid = TRUE;

    if (bAllDataIsValid)
    {
        KillStatusUpdateTimer(hDlg);
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !bAllDataIsValid);

    //
    // Must release quota controller whenever the sheet is deactivated.
    // Without this we were holding open a handle to the volume.  This prevented
    // the disk check utility ("Tools" page) from accessing the volume.
    // Whenever we need an IDiskQuotaControl ptr we call GetQuotaController which
    // will create a new controller if necessary.
    //
    if (NULL != m_pQuotaControl)
    {
        m_pQuotaControl->Release();
        m_pQuotaControl = NULL;
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnSheetNotifyReset

    Description: Handler for WM_NOTIFY - PSN_RESET.

    Arguments:
        hDlg - Dialog window handle.

        wParam - ID of control.

        lParam - Address of NMHDR structure.

    Returns:
        No return value.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnSheetNotifyReset(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("VolumePropPage::OnSheetNotifyReset")));
    HRESULT hResult = NO_ERROR;

    //
    // Nothing to do right now.
    //

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnHelp

    Description: Handler for WM_HELP.  Displays context sensitive help.

    Arguments:
        lParam - Pointer to a HELPINFO structure.

    Returns: TRUE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnHelp(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, STR_DSKQUOUI_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) rgVolumePropPageHelpIDs);
    return TRUE;
}


INT_PTR
VolumePropPage::OnContextMenu(
    HWND hwndItem,
    int xPos,
    int yPos
    )
{
    int idCtl = GetDlgCtrlID(hwndItem);
    WinHelp(hwndItem,
            UseWindowsHelp(idCtl) ? NULL : STR_DSKQUOUI_HELPFILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)((LPTSTR)rgVolumePropPageHelpIDs));

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnTimer

    Description: Handler for WM_TIMER.  Updates the quota status text and
        traffic light.

    Arguments:
        wParam - Timer ID.

    Returns: FALSE (0);

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnTimer(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (wParam == m_idStatusUpdateTimer)
    {
        UpdateStatusIndicators(hDlg);
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnEditNotifyUpdate

    Description: Handler for WM_COMMAND, EN_UPDATE.
        Called whenever a character is entered in an edit control.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnEditNotifyUpdate(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_EDIT_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnEditNotifyUpdate(lParam);

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnEditNotifyKillFocus

    Description: Handler for WM_COMMAND, EN_KILLFOCUS.
        Called whenever focus leaves an edit control.
        Validates the value in the edit control and adjusts it if necessary.

    Arguments:

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
    11/12/98    Added code to call XBytes::OnEditKillFocus.          BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnEditNotifyKillFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_EDIT_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnEditKillFocus(lParam);

    return FALSE;
}


INT_PTR
VolumePropPage::OnEditNotifySetFocus(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Nothing to do.
    // FEATURE:  Delete this method?
    //
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnComboNotifySelChange

    Description: Handler for WM_COMMAND, CBN_SELCHANGE.
        Called whenever the user selects the combo box.

    Arguments: Std DlgProc args.

    Returns: FALSE;

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/17/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnComboNotifySelChange(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    XBytes *rgpxb[2] = { m_pxbDefaultLimit, m_pxbDefaultThreshold };
    const int iLIMIT     = 0;
    const int iTHRESHOLD = 1;
    int iCurrent         = iLIMIT;

    if (IDC_CMB_DEF_THRESHOLD == LOWORD(wParam))
        iCurrent = iTHRESHOLD;

    if (NULL != rgpxb[iCurrent])
        rgpxb[iCurrent]->OnComboNotifySelChange(lParam);

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnButtonDetails

    Description: Called when the user selects the "Details" button.
        If a details view is already active for this prop page, it is brought
        to the foreground.  If no details view is already active, a new one
        is created.

    Arguments: Standard DlgProc arguments.

    Returns:

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
VolumePropPage::OnButtonDetails(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (!ActivateExistingDetailsView())
    {
        //
        // This property page doesn't have an active details view.
        // Create one.  Note:  If something fails in the details view
        // creation, it isn't displayed.  The DetailsView code is
        // responsible for reporting any errors to the user.
        //
        // NOTE:  The VolumePropPage object never calls "delete"
        //        on the pDetailsView pointer.  The details view
        //        object must live on it's own (modeless) after it is created.
        //        If the VolumePropPage object (this object) is still alive
        //        when the details view object is destroyed, it will receive a
        //        WM_DETAILS_VIEW_DESTROYED message from the view object.  That's
        //        why we pass the hDlg in this constructor.  When this message
        //        is received, we set m_pDetailsView to NULL so that OnButtonDetails
        //        will know to create a new view object.
        //
        DetailsView *pDetailsView = new DetailsView;

        if (!pDetailsView->Initialize(m_idVolume))
        {
            //
            // Something failed.  Either out of memory or the view's thread
            // couldn't start.  Either way, the view won't run.
            // Need to call delete to clean up any partially-completed initialization.
            //
            delete pDetailsView;
        }
    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::OnButtonEventLog

    Description: Called when the user selects the "Event Log" button.
        Invokes the NT Event Viewer application.

    Arguments: Standard DlgProc arguments.

    Returns:

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    10/14/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifdef __NEVER__
//
// NOTE:  This code has been disabled.  I just left it in case we ever
//          decide to launch the event viewer from the volume prop page again.
//          [brianan - 3/23/98]
//
/*
INT_PTR
VolumePropPage::OnButtonEventLog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Expand the %SystemRoot% env var in the path to the MMC
    // initialization file (Event viewer).
    //
    CString strMMCInitFile(c_szMMCInitFile);
    strMMCInitFile.ExpandEnvironmentStrings();

    HINSTANCE SEhInstance = ShellExecute(hDlg,
                                c_szVerbOpen,
                                c_szManagementConsole,
                                strMMCInitFile,
                                NULL,
                                SW_SHOWNORMAL);

    if ((DWORD)SEhInstance <= 32)
    {
        //
        // Something failed.
        //
        INT iMsg = 0;
        switch((DWORD)SEhInstance)
        {
            case 0:
                throw CAllocException();
                break;

            case ERROR_FILE_NOT_FOUND:
                iMsg = IDS_ERROR_FILE_NOT_FOUND;
                break;

            case ERROR_BAD_FORMAT:
                iMsg = IDS_ERROR_FILE_CORRUPT;
                break;

            case SE_ERR_DDEBUSY:
            case SE_ERR_DDEFAIL:
            case SE_ERR_DDETIMEOUT:
                iMsg = IDS_ERROR_DDE_EXECUTE;
                break;

            default:
                //
                // The rest of the ShellExecute errors shouldn't happen
                // in this situation.
                //
                break;
        }

        if (0 != iMsg)
        {
            //
            // Display error message.
            // Note that this assumes error string resources have a %1 embedded
            // for displaying the filename.  If they don't, the following
            // logic will need to be changed.
            //
            CString strMsg(g_hInstDll, iMsg, c_szManagementConsole);
            DiskQuotaMsgBox(GetDesktopWindow(),
                            strMsg,
                            IDS_TITLE_DISK_QUOTA,
                            MB_ICONERROR | MB_OK);
        }
    }
    return 0;
}
*/
#endif // __NEVER__

///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::ActivateExistingDetailsView

    Description: Called by OnButtonDetails to see if there's already a details
                 view active for this volume.  If there is, open it.

    Arguments: None.

    Returns:
        TRUE  = Existing details view was found and promoted to the foreground.
        FALSE = Either no existing view was found or an existing one could
                not be promoted to the foreground.

    Exceptions: OutOfMemory.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    02/25/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL
VolumePropPage::ActivateExistingDetailsView(
    VOID
    ) const
{
    BOOL bResult = FALSE;
    CString strVolDisplayName;
    DetailsView::CreateVolumeDisplayName(m_idVolume, &strVolDisplayName);

    CString strDetailsViewTitle(g_hInstDll, IDS_TITLE_MAINWINDOW, (LPCTSTR)strVolDisplayName);

    HWND hwndDetailsView = FindWindow(c_szWndClassDetailsView,
                                      strDetailsViewTitle);

    if (NULL != hwndDetailsView)
    {
        //
        // Restore the details view and bring it to the front.
        //
        ShowWindow(hwndDetailsView, SW_RESTORE);
        bResult = SetForegroundWindow(hwndDetailsView);
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::ApplySettings

    Description: Applies the current settings to the volume if they have
        changed from the original settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR            - Success.
        E_INVALIDARG        - One of the settings was invalid.
        ERROR_ACCESS_DENIED (hr) - No WRITE access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::ApplySettings(
    HWND hDlg
    )
{
    HRESULT hResult         = NO_ERROR;
    DWORD dwStateSetting    = 0;
    DWORD dwLogFlagSettings = m_dwQuotaLogFlags;
    BOOL  bTranslated       = FALSE;
    LONGLONG llThreshold;
    LONGLONG llLimit;
    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Set quota state if changed.
        //
        QuotaStateFromControls(hDlg, &dwStateSetting);
        if (dwStateSetting != (m_dwQuotaState & DISKQUOTA_STATE_MASK))
        {
            hResult = pqc->SetQuotaState(dwStateSetting);
            if (FAILED(hResult))
                goto apply_failed;

            m_dwQuotaState = dwStateSetting;
        }

        //
        // Set quota log flags if changed.
        //
        LogFlagsFromControls(hDlg, &dwLogFlagSettings);
        if (dwLogFlagSettings != m_dwQuotaLogFlags)
        {
            hResult = pqc->SetQuotaLogFlags(dwLogFlagSettings);
            if (FAILED(hResult))
                goto apply_failed;

            m_dwQuotaLogFlags = dwLogFlagSettings;
        }

        //
        // Get current default quota threshold and limit values.
        //
        if (IsDlgButtonChecked(hDlg, IDC_RBN_DEF_NOLIMIT))
        {
            llThreshold = NOLIMIT;
            llLimit     = NOLIMIT;
        }
        else
        {
            llThreshold = m_pxbDefaultThreshold->GetBytes();
            llLimit     = m_pxbDefaultLimit->GetBytes();
        }

        //
        // Set default quota threshold if changed.
        //
        if (llThreshold != m_llDefaultQuotaThreshold)
        {
            hResult = pqc->SetDefaultQuotaThreshold(llThreshold);
            if (FAILED(hResult))
                goto apply_failed;

            m_llDefaultQuotaThreshold = llThreshold;
        }

        //
        // Set default quota limit if changed.
        //
        if (llLimit != m_llDefaultQuotaLimit)
        {
            hResult = pqc->SetDefaultQuotaLimit(llLimit);
            if (FAILED(hResult))
                goto apply_failed;

            m_llDefaultQuotaLimit = llLimit;
        }

apply_failed:

        pqc->Release();
    }
    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::RefreshCachedVolumeInfo

    Description: Reads the volume's quota information and stores it in
        member variables.

    Arguments: None.

    Returns:
        NO_ERROR            - Success.
        ERROR_ACCESS_DENIED (hr) - No READ access to quota device.
        E_FAIL              - Any other error.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::RefreshCachedVolumeQuotaInfo(
    VOID
    )
{
    HRESULT hResult = NO_ERROR;

    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Read quota state.
        //
        hResult = pqc->GetQuotaState(&m_dwQuotaState);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read quota log flags.
        //
        hResult = pqc->GetQuotaLogFlags(&m_dwQuotaLogFlags);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read default quota threshold.
        //
        hResult = pqc->GetDefaultQuotaThreshold(&m_llDefaultQuotaThreshold);
        if (FAILED(hResult))
            goto refresh_vol_info_failed;

        //
        // Read default quota limit.
        //
        hResult = pqc->GetDefaultQuotaLimit(&m_llDefaultQuotaLimit);

refresh_vol_info_failed:

        pqc->Release();
    }

    return hResult;
}


//
// Determine if a given disk quota policy value is set.
//
bool
VolumePropPage::SetByPolicy(
    LPCTSTR pszPolicyValue
    )
{
    DWORD dwData;
    DWORD dwType;
    DWORD cbData = sizeof(dwData);

    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        REGSTR_KEY_POLICYDATA,
                                        pszPolicyValue,
                                        &dwType,
                                        &dwData,
                                        &cbData));
}                                         


HRESULT
VolumePropPage::EnableControls(
    HWND hwndDlg
    )
{    
    BOOL bQuotaEnabled = (BST_CHECKED == IsDlgButtonChecked(hwndDlg, IDC_CBX_ENABLE_QUOTA));
    BOOL bEnable;

    //
    // "Enable quota management" checkbox.
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                1
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_ENABLE_QUOTA), 
                 !SetByPolicy(REGSTR_VAL_POLICY_ENABLE));
    //
    // "Deny disk space..." checkbox.
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                0
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_DENY_LIMIT), 
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_ENFORCE));
    //                 
    // Log event checkboxes
    //
    //  Policy   Quota Enabled     Ctl Enabled
    //    0            0                0
    //    0            1                1
    //    1            0                0
    //    1            1                0
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_LOG_OVERLIMIT),
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LOGLIMIT));

    EnableWindow(GetDlgItem(hwndDlg, IDC_CBX_LOG_OVERWARNING),
                 bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LOGTHRESHOLD));

    //
    // "Do not limit disk usage" radio button
    // "Limit disk space to" radio button
    //
    //  Policy    Quota Enabled     No Limit    Ctl Enabled
    //    0            0               0            0
    //    0            0               1            0
    //    0            1               0            0
    //    0            1               1            1
    //    1            0               0            0
    //    1            0               1            0
    //    1            1               0            0
    //    1            1               1            0
    //
    bEnable = bQuotaEnabled && !SetByPolicy(REGSTR_VAL_POLICY_LIMIT);
              
    EnableWindow(GetDlgItem(hwndDlg, IDC_RBN_DEF_NOLIMIT),    bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_RBN_DEF_LIMIT),      bEnable);
    //
    //  "Limit disk space" edit and combo controls.
    //
    //  Policy    Quota Enabled     No Limit    Ctl Enabled
    //    0            0               0            0
    //    0            0               1            0
    //    0            1               0            1
    //    0            1               1            0
    //    1            0               0            0
    //    1            0               1            0
    //    1            1               0            0
    //    1            1               1            0
    //
    bEnable = bQuotaEnabled && 
              !SetByPolicy(REGSTR_VAL_POLICY_LIMIT) &&
              NOLIMIT != m_pxbDefaultLimit->GetBytes();

    EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_DEF_LIMIT),     bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_CMB_DEF_LIMIT),      bEnable);

    bEnable = bQuotaEnabled && 
              !SetByPolicy(REGSTR_VAL_POLICY_THRESHOLD) &&
              NOLIMIT != m_pxbDefaultThreshold->GetBytes();

    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_WARN_LEVEL),     bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_EDIT_DEF_THRESHOLD), bEnable);
    EnableWindow(GetDlgItem(hwndDlg, IDC_CMB_DEF_THRESHOLD),  bEnable);
    //
    // Miscellaneous text controls.
    //
    //  Quota Enabled     Ctl Enabled
    //        0                0
    //        1                1
    //
    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_DEFAULTS), bQuotaEnabled);
    EnableWindow(GetDlgItem(hwndDlg, IDC_TXT_LOGGING),  bQuotaEnabled);

    return NOERROR;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::InitializeControls

    Description: Initializes the page controls based on the volume's
        quota settings.

    Arguments:
        hDlg - Dialog window handle.

    Returns:
        NO_ERROR - Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::InitializeControls(
    HWND hDlg
    )
{
    BOOL bQuotaEnabled  = !(DISKQUOTA_IS_DISABLED(m_dwQuotaState));
    BOOL bUnlimited     = (NOLIMIT == m_llDefaultQuotaLimit);

    CheckDlgButton(hDlg,
                   IDC_CBX_ENABLE_QUOTA,
                   bQuotaEnabled);

    CheckDlgButton(hDlg,
                   IDC_CBX_DENY_LIMIT,
                   DISKQUOTA_IS_ENFORCED(m_dwQuotaState));

    CheckDlgButton(hDlg,
                   IDC_CBX_LOG_OVERWARNING,
                   !DISKQUOTA_IS_DISABLED(m_dwQuotaState) &&
                   DISKQUOTA_IS_LOGGED_USER_THRESHOLD(m_dwQuotaLogFlags));

    CheckDlgButton(hDlg,
                   IDC_CBX_LOG_OVERLIMIT,
                   !DISKQUOTA_IS_DISABLED(m_dwQuotaState) &&
                   DISKQUOTA_IS_LOGGED_USER_LIMIT(m_dwQuotaLogFlags));

    CheckDlgButton(hDlg, IDC_RBN_DEF_NOLIMIT,  bUnlimited);
    CheckDlgButton(hDlg, IDC_RBN_DEF_LIMIT,   !bUnlimited);

    EnableControls(hDlg);

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::UpdateStatusIndicators
    Description: Updates the "Status" text message at the top of the property
        page according to the actual quota system state.  Also updates the
        traffic light AVI clip.

    Arguments:
        hDlg - Dialog handle.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/18/96    Initial creation.                                    BrianAu
    08/28/96    Added stoplight icon.                                BrianAu
    09/10/96    Converted stoplight from an icon to an AVI clip.     BrianAu
                Call it a traffic light now.
    07/14/97    Removed distinct "enforce" and "tracking" messages   BrianAu
                and replaced with a single "active" message.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::UpdateStatusIndicators(
    HWND hDlg
    )
{
    HRESULT hResult = NO_ERROR;
    DWORD dwMsgID   = IDS_STATUS_UNKNOWN;
    IDiskQuotaControl *pqc;

    hResult = GetQuotaController(&pqc);
    if (SUCCEEDED(hResult))
    {
        //
        // Update cached state information.
        //
        hResult = pqc->GetQuotaState(&m_dwQuotaState);
        pqc->Release();
        pqc = NULL;

    }
    if (SUCCEEDED(hResult))
    {
        //
        // Figure out what message to display.
        // "Rebuilding" overrides any other state.
        //
        if (DISKQUOTA_FILE_REBUILDING(m_dwQuotaState))
        {
            dwMsgID = IDS_STATUS_REBUILDING;
        }
        else switch(m_dwQuotaState & DISKQUOTA_STATE_MASK)
        {
            case DISKQUOTA_STATE_DISABLED:
                dwMsgID = IDS_STATUS_DISABLED;
                break;
            case DISKQUOTA_STATE_TRACK:
            case DISKQUOTA_STATE_ENFORCE:
                dwMsgID = IDS_STATUS_ACTIVE;
                break;
            default:
                break;
        }
    }

    if (dwMsgID != m_dwLastStatusMsgID)
    {
        //
        // Format the status text and configure the traffic light.
        //
        // Traffic light states:
        // RED             = Quotas disabled.
        // GREEN           = Quotas enabled.
        // Flashing YELLOW = Quota file is rebuilding.
        //
        INT iTrafficLightState = TrafficLight::GREEN;

        if (DISKQUOTA_FILE_REBUILDING(m_dwQuotaState))
            iTrafficLightState = TrafficLight::FLASHING_YELLOW;
        else if (DISKQUOTA_IS_DISABLED(m_dwQuotaState))
            iTrafficLightState = TrafficLight::RED;

        m_TrafficLight.Show(iTrafficLightState);

        CString strStatus(g_hInstDll, dwMsgID);
        SetWindowText(GetDlgItem(hDlg, IDC_TXT_QUOTA_STATUS), strStatus);

        m_dwLastStatusMsgID = dwMsgID;
        //
        // Re-initialize the controls based on the new state.
        //
        InitializeControls(hDlg);
    }

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::QuotaStateFromControls

    Description: Determines the quota state from the states of the individual
        controls on the page.

    Arguments:
        hDlg - Dialog's window handle.

        pdwState - Address of DWORD variable to receive state bits.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/19/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::QuotaStateFromControls(
    HWND hDlg,
    LPDWORD pdwState
    ) const
{
    DBGASSERT((NULL != pdwState));

    //
    // Set quota state if changed.
    //
    if (IsDlgButtonChecked(hDlg, IDC_CBX_ENABLE_QUOTA))
    {
        if (IsDlgButtonChecked(hDlg, IDC_CBX_DENY_LIMIT))
        {
            *pdwState = DISKQUOTA_STATE_ENFORCE;
        }
        else
            *pdwState = DISKQUOTA_STATE_TRACK;
    }
    else
        *pdwState = DISKQUOTA_STATE_DISABLED;

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::LogFlagsFromControls

    Description: Determines the log flags state from the states of the
        individual controls on the page.

    Arguments:
        hDlg - Dialog's window handle.

        pdwLogFlags - Address of DWORD variable to receive flag bits.

    Returns:
        Always returns NO_ERROR.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/19/96    Initial creation.                                    BrianAu
    08/01/97    Removed IDC_CBX_WARN_THRESHOLD from UI.              BrianAu
    11/20/98    Added "log over limit" and "log over warning"        BrianAu
                controls.
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
VolumePropPage::LogFlagsFromControls(
    HWND hDlg,
    LPDWORD pdwLogFlags
    ) const
{
    DBGASSERT((NULL != pdwLogFlags));
    DISKQUOTA_SET_LOG_USER_LIMIT(*pdwLogFlags,
                                 IsDlgButtonChecked(hDlg, IDC_CBX_LOG_OVERLIMIT));

    DISKQUOTA_SET_LOG_USER_THRESHOLD(*pdwLogFlags,
                                     IsDlgButtonChecked(hDlg, IDC_CBX_LOG_OVERWARNING));

    return NO_ERROR;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::TrafficLight::Initialize

    Description: Initializes the traffic light by opening the AVI clip.

    Arguments:
        hwndAnimateCtl - Handle to the animation control in the dialog.

        idAviClipRes - Resource ID of the AVI clip resource.

    Returns: Nothing.  If the thing doesn't load, it just won't play.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
VolumePropPage::TrafficLight::Initialize(
    HWND hwndAnimateCtl,
    INT idAviClipRes
    )
{
    DBGASSERT((NULL != hwndAnimateCtl));

    m_hwndAnimateCtl = hwndAnimateCtl;
    m_idAviClipRes   = idAviClipRes;

    Animate_Open(m_hwndAnimateCtl, MAKEINTRESOURCE(idAviClipRes));
//
// See note in TrafficLight::Show below.
//
//    Animate_SetFrameTime(m_hwndAnimateCtl, GetCaretBlinkTime());
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: VolumePropPage::TrafficLight::Show

    Description: Shows the traffic light in one of it's states.

    Arguments:
        eShow - One of the following enumerated constant values:

            OFF, YELLOW, RED, GREEN, FLASHING_YELLOW.

        NOTE:   THIS IS VERY IMPORTANT!!!

                The definitions of these constants MUST match as follows
                with the frame numbers in the AVI clip TRAFFIC.AVI.  If
                you change either, it won't work.

                Frame  Constant         Value
                ------ ---------------- ------
                  0     OFF               0
                  1     YELLOW            1
                  2     RED               2
                  3     GREEN             3
                N/A     FLASHING_YELLOW   4

                Flashing yellow is created by playing frames 0 and 1
                repeatedly.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    09/10/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
VolumePropPage::TrafficLight::Show(
    INT eShow
    )
{
    switch(eShow)
    {
        case OFF:
        case YELLOW:
        case RED:
        case GREEN:
            Animate_Seek(m_hwndAnimateCtl, eShow);
            break;

        case FLASHING_YELLOW:
            Animate_Seek(m_hwndAnimateCtl, YELLOW);
//
// NOTE:
//
// The common control guys didn't want me to add the ACM_SETFRAMETIME
// message so we can't vary the rate of the animation.  Since we can't
// have a fixed-rate blinking control, I'm just fixing the traffic light
// at yellow rather than flashing.  If we can ever add the frame time
// modification message to the animation control, we can activate
// this functionality.  A flashing light isn't worth the trouble of
// a unique implementation.  I really wanted this.  It looks cool.
//
// FEATURE:  If we have time.  Make this work without the animation control.
//          Note that I tried just setting the icon.  But since the volume
//          status checking is done on the same thread that processes the
//          STM_SETICON messgae, flashing of the icon is erratic.
//
//            Animate_Play(m_hwndAnimateCtl, YELLOW, OFF, (UINT)-1);
            break;

        default:
            break;
    }
}


INT_PTR
VolumePropPage::TrafficLight::ForwardMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return SendMessage(m_hwndAnimateCtl, uMsg, wParam, lParam);
}

#ifdef POLICY_MMC_SNAPIN

SnapInVolPropPage::~SnapInVolPropPage(
    void
    )
{
    if (NULL != m_pPolicy)
        m_pPolicy->Release();
}


BOOL
SnapInVolPropPage::OnInitDialog(
    HWND hDlg,
    UINT wParam,
    LONG lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::OnInitDialog")));
    HRESULT hr = NO_ERROR;
    bool bRemovableMedia = false;

    //
    // Policy object should have already been created and initialized
    // by the creator of the property sheet.  See CSnapInCompData::PropPageThreadProc.
    //
    DBGASSERT((NULL != m_pPolicy));

    //
    // Retrieve and restore the previous dialog state from when the
    // user last used the snapin.  We use the GPTInfo structure for
    // convenience since we're storing the same information that is
    // used for setting policy.
    //
    DISKQUOTAPOLICYINFO dqpi;
    RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (SUCCEEDED(keyPref.Open(KEY_READ)) &&
        SUCCEEDED(keyPref.GetValue(c_szSnapInPrefs, (LPBYTE)&dqpi, sizeof(dqpi))) &&
        sizeof(dqpi) == dqpi.cb)
    {
        m_llDefaultQuotaLimit     = dqpi.llDefaultQuotaLimit;
        m_llDefaultQuotaThreshold = dqpi.llDefaultQuotaThreshold;
        m_dwQuotaState            = dqpi.dwQuotaState;
        m_dwQuotaLogFlags         = dqpi.dwQuotaLogFlags;
        bRemovableMedia           = dqpi.bRemovableMedia;
    }
    else
        DBGERROR((TEXT("Error loading policy dialog information")));

    //
    // Create the XBytes objects to manage the relationship between the
    // limit/threshold edit controls and their combo boxes.
    //
    m_pxbDefaultLimit     = new XBytes(hDlg,
                                       IDC_EDIT_DEF_LIMIT,
                                       IDC_CMB_DEF_LIMIT,
                                       m_llDefaultQuotaLimit);

    m_pxbDefaultThreshold = new XBytes(hDlg,
                                       IDC_EDIT_DEF_THRESHOLD,
                                       IDC_CMB_DEF_THRESHOLD,
                                       m_llDefaultQuotaThreshold);

    InitializeControls(hDlg);

    return TRUE;  // Set focus to default control.
}


BOOL
SnapInVolPropPage::OnSheetNotifySetActive(
    HWND hDlg,
    UINT wParam,
    LONG lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::OnSheetNotifySetActive")));
    return FALSE;
}


BOOL
SnapInVolPropPage::OnSheetNotifyApply(
    HWND hDlg,
    UINT wParam,
    LONG lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::OnSheetNotifyApply")));
    LONG dwPSNReturn = PSNRET_NOERROR;
    HRESULT hr = NOERROR;

    DWORD dwState, dwLogFlags;
    LONGLONG llThreshold, llLimit;

    //
    // Policy object should have already been created and initialized
    // by the creator of the property sheet.  See CSnapInCompData::PropPageThreadProc.
    //
    DBGASSERT((NULL != m_pPolicy));

    //
    // Query the state of the dialog to get the quota settings.
    //
    QuotaStateFromControls(hDlg, &dwState);
    LogFlagsFromControls(hDlg, &dwLogFlags);
    if (IsDlgButtonChecked(hDlg, IDC_RBN_DEF_NOLIMIT))
    {
        llThreshold = NOLIMIT;
        llLimit     = NOLIMIT;
    }
    else
    {
        llThreshold = m_pxbDefaultThreshold->GetBytes();
        llLimit     = m_pxbDefaultLimit->GetBytes();
    }

    DISKQUOTAPOLICYINFO dqpi;
    dqpi.cb                      = sizeof(dqpi);
    dqpi.llDefaultQuotaThreshold = llThreshold;
    dqpi.llDefaultQuotaLimit     = llLimit;
    dqpi.dwQuotaState            = dwState;
    dqpi.dwQuotaLogFlags         = dwLogFlags;
    dqpi.bRemovableMedia         = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_RBN_POLICY_REMOVABLE));

    //
    // Save the policy information to the registry.
    //
    hr = m_pPolicy->Save(&dqpi);
    if (FAILED(hr))
    {
        DBGERROR((TEXT("Error 0x%08X saving policy information"), hr));
        //
        // Show some UI?
        //
    }

    //
    // Save current dialog state so that we can restore it next time the
    // user opens the snapin.  This way, if the user typically sets
    // quotas to the same values, the UI will appear much more friendly.
    //
    RegKey keyPref(HKEY_CURRENT_USER, REGSTR_KEY_DISKQUOTA);
    if (FAILED(keyPref.Open(KEY_WRITE)) ||
        FAILED(keyPref.SetValue(c_szSnapInPrefs, (LPBYTE)&dqpi, sizeof(dqpi))))
    {
        DBGERROR((TEXT("Error saving policy dialog information")));
    }

    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, dwPSNReturn);

    return TRUE;
}


BOOL
SnapInVolPropPage::OnSheetNotifyKillActive(
    HWND hDlg,
    UINT wParam,
    LONG lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::OnSheetNotifyKillActive")));
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
    return TRUE;
}



BOOL
SnapInVolPropPage::OnSheetNotifyReset(
    HWND hDlg,
    UINT wParam,
    LONG lParam
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::OnSheetNotifyReset")));
    return FALSE;
}


HRESULT
SnapInVolPropPage::CreateDiskQuotaPolicyObject(
    IDiskQuotaPolicy **ppOut
    )
{
    DBGTRACE((DM_VPROP, DL_HIGH, TEXT("SnapInVolPropPage::CreateDiskQuotaPolicyObject")));
    HRESULT hr = NOERROR;
    try
    {
        CDiskQuotaPolicy *pPolicy = new CDiskQuotaPolicy;
        hr = pPolicy->QueryInterface(IID_IDiskQuotaPolicy,
                                     reinterpret_cast<void **>(&m_pPolicy));
        if (SUCCEEDED(hr))
        {
            m_pPolicy->AddRef();
            *ppOut = m_pPolicy;
        }
    }
    catch(CAllocException& e)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#endif // POLICY_MMC_SNAPIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\userprop.h ===
#ifndef __DSKQUOTA_USER_PROPSHEET_H
#define __DSKQUOTA_USER_PROPSHEET_H
///////////////////////////////////////////////////////////////////////////////
/*  File: userprop.h

    Description: Provides declarations for quota user property page.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
    06/25/98    Replaced AddUserPropSheet with AddUserDialog.        BrianAu
                Now that we're getting user info from the DS
                object picker, the prop sheet idea doesn't work
                so well.  A std dialog is better.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_H
#   include "dskquota.h"
#endif
#ifndef _INC_DSKQUOTA_USER_H
#   include "user.h"
#endif
#ifndef _INC_DSKQUOTA_UNDO_H
#   include "undo.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"    // For LVSelection
#endif
#ifndef __OBJSEL_H_
#   include <objsel.h>
#endif

#include "resource.h"

//
// User property page.
//
class UserPropSheet
{
    private:
        enum { iICON_USER_SINGLE,
               iICON_USER_MULTIPLE,
               cUSER_ICONS };

        enum { iICON_STATUS_OK,
               iICON_STATUS_OVER_THRESHOLD,
               iICON_STATUS_OVER_LIMIT,
               cSTATUS_ICONS };

        //
        // Prevent copying.
        //
        UserPropSheet(const UserPropSheet&);
        void operator = (const UserPropSheet&);

        LONGLONG           m_cVolumeMaxBytes;
        LONGLONG           m_llQuotaUsed;
        LONGLONG           m_llQuotaLimit;
        LONGLONG           m_llQuotaThreshold;
        int                m_idCtlNextFocus;
        PDISKQUOTA_CONTROL m_pQuotaControl;
        UndoList&          m_UndoList;
        LVSelection&       m_LVSelection;
        HWND               m_hWndParent;
        CVolumeID          m_idVolume;
        CString            m_strPageTitle;
        BOOL               m_bIsDirty;
        BOOL               m_bHomogeneousSelection;      // All selected, same limit/threshold.
        HICON              m_hIconUser[cUSER_ICONS];     // 0=Single, 1=Multi-user.
        HICON              m_hIconStatus[cSTATUS_ICONS]; // 0=OK,1=Warn,2=Error
        XBytes            *m_pxbQuotaLimit;
        XBytes            *m_pxbQuotaThreshold;

        static INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);

        //
        // PSN_xxxx handlers.
        //
        INT_PTR OnSheetNotifyApply(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSheetNotifyKillActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnSheetNotifySetActive(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // EN_xxxx handlers.
        //
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifyKillFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // CBN_xxxx handlers.
        //
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);

        HRESULT UpdateControls(HWND hDlg) const;
        HRESULT InitializeControls(HWND hDlg);
        HRESULT RefreshCachedUserQuotaInfo(VOID);
        HRESULT ApplySettings(HWND hDlg, bool bUndo = true);
        HRESULT RefreshCachedQuotaInfo(VOID);

        VOID UpdateSpaceUsed(HWND hDlg, LONGLONG iUsed, LONGLONG iLimit, INT cUsers);
        VOID UpdateUserName(HWND hDlg, PDISKQUOTA_USER pUser);
        VOID UpdateUserName(HWND hDlg, INT cUsers);
        VOID UpdateUserStatusIcon(HWND hDlg, LONGLONG iUsed, LONGLONG iThreshold, LONGLONG iLimit);

        INT QueryUserIcon(HWND hDlg) const;
        INT QueryUserStatusIcon(HWND hDlg) const;

    public:
        //
        // Prop sheet for editing users.
        //
        UserPropSheet(PDISKQUOTA_CONTROL pQuotaControl,
                      const CVolumeID& idVolume,
                      HWND hWndParent,
                      LVSelection& LVSelection,
                      UndoList& UndoList);

        ~UserPropSheet(VOID);

        HRESULT Run(VOID);

        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

#endif // __DSKQUOTA_USER_PROPSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\yntoall.h ===
#ifndef _INC_DSKQUOTA_YNTOALL_H
#define _INC_DSKQUOTA_YNTOALL_H
///////////////////////////////////////////////////////////////////////////////
/*  File: yntoall.h

    Description: Declarations for class YesNoToAllDialog.
        This class provides a simple message box that includes an
        "apply to all" checkbox.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
class YesNoToAllDialog
{
    private:
        UINT   m_idDialogTemplate;
        HWND   m_hwndCbxApplyToAll;
        HWND   m_hwndTxtMsg;
        LPTSTR m_pszTitle;
        LPTSTR m_pszText;
        BOOL   m_bApplyToAll;

        static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

    public:
        YesNoToAllDialog(UINT idDialogTemplate);
        ~YesNoToAllDialog(VOID);

        BOOL ApplyToAll(VOID)
            { return m_bApplyToAll; }

        INT_PTR CreateAndRun(HINSTANCE hInstance, HWND hwndParent, LPCTSTR pszTitle, LPCTSTR pszText);
};

#endif // _INC_DSKQUOTA_YNTOALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\action.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: action.cpp

    Description: Implements classes to handle actions associated
        with user notifications (email, popup dialog etc).
        
            CAction
            CActionEmail
            CActionPopup

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include <commctrl.h>
#include "action.h"
#include "history.h"
#include "stats.h"
#include "resource.h"
#include "mapisend.h"

//-----------------------------------------------------------------------------
// CActionEmail
//-----------------------------------------------------------------------------

#ifdef UNICODE
#   define EMAIL_UNICODE TRUE
#else
#   define EMAIL_UNICODE FALSE
#endif

CActionEmail::CActionEmail(
    CMapiSession& MapiSession,  // For sending message.
    LPMAPIFOLDER pMapiFolder,   // For initializing message object.
    LPTSTR pszRecipientsTo,     // Other recips on "To:" line.
    LPTSTR pszRecipientsCc,     // Other recips on "Cc:" line.
    LPTSTR pszRecipientsBcc,    // Other recips on "Bcc:" line.
    LPCTSTR pszSubject,         // Message subject line.
    CMapiMessageBody& MsgBody   // Message body text.
    ) : m_MapiSession(MapiSession),
        m_MapiRecipients(EMAIL_UNICODE),
        m_MapiMsg(pMapiFolder, MsgBody, pszSubject)
{
    HRESULT hr;

    m_Mapi.Load();

    //
    // NOTE:  We hold a reference to a CMapiSession object.
    //        The CMapiSession object doen't employ any reference
    //        counting of it's own.  This code assumes that the 
    //        lifetime of the referenced section object exceeds the
    //        lifetime of the action object.  

    LPSPropValue pProps = NULL;
    ULONG cbProps = 0;

    //
    // Get the address properties for the MAPI session user.
    //
    hr = m_MapiSession.GetSessionUser(&pProps, &cbProps);
    if (SUCCEEDED(hr))
    {
        if (5 == cbProps)
        {
            SPropValue rgProp[5];

            //
            // Get the string resource containing "NT Disk Quota Administrator".
            // It's a resource for localization.
            //
            // FEATURE: This currently doesn't work although the Exchange guys
            //         tell me it should.  Currently, the mail message always
            //         arrives with the local user's name on the "From:" line.
            //         It should read "NT Disk Quota Administrator".
            //         Needs work. [brianau - 07/10/97]
            //
            CString strEmailFromName(g_hInstDll, IDS_EMAIL_FROM_NAME);

            //
            // Set the "PR_SENT_REPRESENTING_XXXX" props to the same
            // values as the "PR_SENDER_XXXX" props.
            //
            rgProp[0].ulPropTag      = PR_SENT_REPRESENTING_ADDRTYPE;
            rgProp[0].Value.LPSZ     = pProps[0].Value.LPSZ;

            rgProp[1].ulPropTag      = PR_SENT_REPRESENTING_NAME;
            rgProp[1].Value.LPSZ     = (LPTSTR)strEmailFromName;

            rgProp[2].ulPropTag      = PR_SENT_REPRESENTING_EMAIL_ADDRESS;
            rgProp[2].Value.LPSZ     = pProps[2].Value.LPSZ;

            rgProp[3].ulPropTag      = PR_SENT_REPRESENTING_ENTRYID;
            rgProp[3].Value.bin.cb   = pProps[3].Value.bin.cb;
            rgProp[3].Value.bin.lpb  = pProps[3].Value.bin.lpb;

            rgProp[4].ulPropTag      = PR_SENT_REPRESENTING_SEARCH_KEY;
            rgProp[4].Value.bin.cb   = pProps[4].Value.bin.cb;
            rgProp[4].Value.bin.lpb  = pProps[4].Value.bin.lpb;

            LPSPropProblemArray pProblems = NULL;

            //
            // Set the new properties.
            //
            hr = m_MapiMsg.SetProps(ARRAYSIZE(rgProp), rgProp, &pProblems);        
            hr = m_MapiMsg.SaveChanges(KEEP_OPEN_READWRITE);

            //
            // Add the recipient to the list of recipients.
            //
            hr = m_MapiRecipients.AddRecipient(pProps[2].Value.LPSZ, MAPI_TO);
        }
        m_Mapi.FreeBuffer(pProps);
    }

    //
    // Each element of this array contains a pointer to a list of 
    // recipient names (semicolon-delmited) and a recipient type
    // code.  This allows us to process all of the recipients
    // in a single loop.
    //
    struct recip {
        LPTSTR pszName;
        DWORD dwType;
    } rgRecips[] = {
                       { pszRecipientsTo,  MAPI_TO  },
                       { pszRecipientsCc,  MAPI_CC  },
                       { pszRecipientsBcc, MAPI_BCC },
                   };

    for (INT i = 0; i < ARRAYSIZE(rgRecips); i++)
    {
        LPTSTR pszNext  = rgRecips[i].pszName;
        LPCTSTR pszPrev = pszNext;
        //
        // Process the current list of recipient names until we reach
        // the terminating nul character.
        //
        while(TEXT('\0') != *pszPrev)
        {
            while((TEXT('\0') != *pszNext) && (TEXT(';') != *pszNext))
            {
                //
                // Find the next semicolon or the terminating nul.
                //
                pszNext++;
            }
            if (TEXT('\0') != *pszNext)
            {
                //
                // Found a semicolon.  Replace it with a nul and
                // skip ahead to the start of the next name.
                //
                *pszNext++ = TEXT('\0');
            }
            //
            // Add the name of the recipient pointed to by pszPrev
            // using the type code associated with this list of recipients.
            //
            m_MapiRecipients.AddRecipient(pszPrev, rgRecips[i].dwType);
            pszPrev = pszNext;
        }
    }
}

CActionEmail::~CActionEmail(
    VOID
    )
{
    m_Mapi.Unload();
}


//
// Send the email and record the send operation in our history record.
//
HRESULT
CActionEmail::DoAction(
    CHistory& history
    )
{
    HRESULT hr;

    //
    // Try sending the mail using the current ANSI/Unicode contents.
    //
    hr = m_MapiSession.Send(m_MapiRecipients, m_MapiMsg);
    if (MAPI_E_BAD_CHARWIDTH == hr)
    {
        //
        // Failed because the provider can't handle the character width.
        // Convert the address list to the opposite character width.
        //
        // FEATURE:  Currently, we just convert the address list.  We 
        //          should probably do the same thing with the message body
        //          and subject line.
        //
        CMapiRecipients recipTemp(!m_MapiRecipients.IsUnicode());
        recipTemp = m_MapiRecipients;
        //
        // Try to send again.
        //
        hr = m_MapiSession.Send(recipTemp, m_MapiMsg);
    }
    if (SUCCEEDED(hr))
    {
        //
        // Record in the history log that we've sent email.
        //
        history.RecordEmailSent();
    }
    return hr;
}

//-----------------------------------------------------------------------------
// CActionPopup
//-----------------------------------------------------------------------------

UINT CActionPopup::m_idAutoCloseTimer    = 1;
UINT CActionPopup::m_uAutoCloseTimeout   = 300000;  // Timeout in 5 minutes.

CActionPopup::CActionPopup(
    CStatisticsList& stats
    ) : m_stats(stats),
        m_hiconDialog(NULL),
        m_hwnd(NULL)
{
    m_hiconDialog = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_QUOTA));
}

CActionPopup::~CActionPopup(
    VOID
    )
{


}

typedef BOOL (WINAPI *LPFNINITCOMMONCONTROLSEX)(LPINITCOMMONCONTROLSEX);

HRESULT
CActionPopup::CreateAndRunPopup(
    HINSTANCE hInst,
    LPCTSTR pszDlgTemplate,
    HWND hwndParent
    )
{
    INT iResult = 1;

    //
    // Load and initialize comctl32.dll.
    // We need it for the listview control in the dialog.
    //
    m_hmodCOMCTL32 = ::LoadLibrary(TEXT("comctl32.dll"));
    if (NULL != m_hmodCOMCTL32)
    {
        LPFNINITCOMMONCONTROLSEX pfnInitCommonControlsEx = NULL;

        pfnInitCommonControlsEx = (LPFNINITCOMMONCONTROLSEX)::GetProcAddress(m_hmodCOMCTL32, "InitCommonControlsEx");
        if (NULL != pfnInitCommonControlsEx)
        {
            INITCOMMONCONTROLSEX iccex;

            iccex.dwSize = sizeof(iccex);
            iccex.dwICC  = ICC_LISTVIEW_CLASSES;

            if ((*pfnInitCommonControlsEx)(&iccex))
            {
                iResult = DialogBoxParam(hInst,
                                         pszDlgTemplate,
                                         hwndParent,
                                         DlgProc,
                                         (LPARAM)this);
            }
        }
    }

    return (0 == iResult) ? NOERROR : E_FAIL;
}


HRESULT 
CActionPopup::DoAction(
    CHistory& history
    )
{
    HRESULT hr = E_FAIL;
    if (0 == CreateAndRunPopup(g_hInstDll,
                               MAKEINTRESOURCE(IDD_QUOTA_POPUP),
                               GetDesktopWindow()))
    {
        //
        // Record in the history log that we've popped up a dialog.
        //
        history.RecordDialogPoppedUp();
        hr = NOERROR;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CActionPopup::DlgProc [static]

    Description: Message procedure for the dialog.

    Arguments: Standard Win32 message proc arguments.

    Returns: Standard Win32 message proc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK 
CActionPopup::DlgProc(
    HWND hwnd, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    CActionPopup *pThis = (CActionPopup *)GetWindowLong(hwnd, GWL_USERDATA);

    switch(uMsg)
    {
        case WM_INITDIALOG:
            //
            // Store "this" ptr in window's userdata.
            //
            SetWindowLong(hwnd, GWL_USERDATA, (LONG)lParam);
            pThis = (CActionPopup *)lParam;
            //
            // Save the HWND in our object.  We'll need it later.
            //
            pThis->m_hwnd = hwnd;

            return pThis->OnInitDialog(hwnd);

        case WM_DESTROY:
            return pThis->OnDestroy(hwnd);

        case WM_NCDESTROY:
            return pThis->OnNcDestroy(hwnd);

        case WM_TIMER:
            if (m_idAutoCloseTimer != wParam)
                break;
            //
            // Fall through to EndDialog...
            //
            DebugMsg(DM_ERROR, TEXT("CActionPopup::DlgProc - Dialog closed automatically."));

        case WM_COMMAND:
            EndDialog(hwnd, 0);
            break;

    }
    return FALSE;
}


BOOL
CActionPopup::OnInitDialog(
    HWND hwnd
    )
{
    BOOL bResult = TRUE;

    //
    // Set the quota icon.
    //
    SendMessage(hwnd, WM_SETICON, ICON_BIG,   (LPARAM)m_hiconDialog);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hiconDialog);

    //
    // Populate the listview with notification records.
    //
    InitializeList(GetDlgItem(hwnd, IDC_LIST_POPUP));

    //
    // Set the timer that will automatically close the dialog after 2 minutes.
    //
    SetTimer(hwnd, m_idAutoCloseTimer, m_uAutoCloseTimeout, NULL);

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CActionPopup::OnDestroy

    Description: 

    Arguments: 
        hwnd - Dialog window handle.
        
    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL 
CActionPopup::OnDestroy(
    HWND hwnd
    )
{
    KillTimer(hwnd, m_idAutoCloseTimer);
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CActionPopup::OnNcDestroy

    Description: 

    Arguments: 
        hwnd - Dialog window handle.
        
    Returns: Always returns FALSE.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL 
CActionPopup::OnNcDestroy(
    HWND hwnd
    )
{
    //
    // We no longer need comctl32.
    // Unload it.
    //
    if (NULL != m_hmodCOMCTL32)
    {
        FreeLibrary(m_hmodCOMCTL32);
        m_hmodCOMCTL32 = NULL;
    }
    return FALSE;
}


//
// Creates the listview columns and populates the listview from
// the statistics list object.
//
VOID
CActionPopup::InitializeList(
    HWND hwndList
    )
{
    //
    // We want to base pixel units off of dialog units.
    //
    INT DialogBaseUnitsX = LOWORD(GetDialogBaseUnits());

#define PIXELSX(du)  ((INT)((DialogBaseUnitsX * du) / 4))

    //
    // Create the header titles.
    //
    CString strVolume(g_hInstDll,  IDS_LVHDR_VOLUME);
    CString strUsed(g_hInstDll,    IDS_LVHDR_USED);
    CString strWarning(g_hInstDll, IDS_LVHDR_WARNING);
    CString strLimit(g_hInstDll,   IDS_LVHDR_LIMIT);

#define LVCOLMASK (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM)

    LV_COLUMN rgCols[] = { 
                         { LVCOLMASK, LVCFMT_LEFT, PIXELSX(70), strVolume,  0, 0 },
                         { LVCOLMASK, LVCFMT_LEFT, PIXELSX(60), strUsed,    0, 1 },
                         { LVCOLMASK, LVCFMT_LEFT, PIXELSX(50), strWarning, 0, 2 },
                         { LVCOLMASK, LVCFMT_LEFT, PIXELSX(50), strLimit,   0, 3 }
                         };

    //
    // Add the columns to the listview.
    //
    for (INT i = 0; i < ARRAYSIZE(rgCols); i++)
    {
        if (-1 == ListView_InsertColumn(hwndList, i, &rgCols[i]))
        {
            DebugMsg(DM_ERROR, TEXT("CActionPopup::InitializeList failed to add column %d"), i);
        }
    }

    //
    // How many statistics objects are there in the stats list?
    //
    INT cEntries = m_stats.Count();
    //
    // This prevents the listview from having to extend itself each time we
    // add an item.
    //
    ListView_SetItemCount(hwndList, cEntries);

    //
    // Item struct for adding listview items and setting item text.
    //
    LV_ITEM item;
    item.mask = LVIF_TEXT;

    //
    // Scratch string for storing formatted column text.
    //
    CString str;

    //
    // For each row...
    //
    INT iRow = 0;
    for (INT iEntry = 0; iEntry < cEntries; iEntry++)
    {
        item.iItem = iRow;
        //
        // Retrieve the statistics object for this row.
        //
        const CStatistics *pStats = m_stats.GetEntry(iEntry);
        Assert(NULL != pStats);

        if (0 == iEntry)
        {
            //
            // First row.  Get the user's display name and
            // format/set the header message.
            //
            str.Format(g_hInstDll, IDS_POPUP_HEADER);
            SetWindowText(GetDlgItem(m_hwnd, IDC_TXT_POPUP_HEADER), str);
        }
                          
        if (pStats->IncludeInReport())
        {
            //
            // For each column...
            //
            for (INT iCol = 0; iCol < ARRAYSIZE(rgCols); iCol++)
            {
                item.iSubItem = iCol;
                switch(iCol)
                {
                    case 0:
                        //
                        // Location (volume display name)
                        //
                        item.pszText = pStats->GetVolumeDisplayName() ?
                                       (LPTSTR)((LPCTSTR)pStats->GetVolumeDisplayName()) :
                                       TEXT("");
                        break;                    

                    case 1:
                    {
                        TCHAR szBytes[40];
                        TCHAR szBytesOver[40];
                        //
                        // Quota Used
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaUsed().QuadPart,
                                                          szBytes, ARRAYSIZE(szBytes));

                        __int64 diff = pStats->GetUserQuotaUsed().QuadPart - pStats->GetUserQuotaThreshold().QuadPart;
                        if (0 > diff)
                        {
                            diff = 0;
                        }

                        XBytes::FormatByteCountForDisplay(diff, szBytesOver, ARRAYSIZE(szBytesOver));
                        str.Format(g_hInstDll, IDS_LVFMT_USED, szBytes, szBytesOver);

                        item.pszText = (LPTSTR)str;
                        break;
                    }

                    case 2:
                        //
                        // Warning Level
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaThreshold().QuadPart,
                                                          str.GetBuffer(40), 40);
                        item.pszText = (LPTSTR)str;
                        break;

                    case 3:
                        //
                        // Quota Limit.
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaLimit().QuadPart,
                                                          str.GetBuffer(40), 40);
                        item.pszText = (LPTSTR)str;
                        break;

                    default:
                        break;
                }
                if (0 == iCol)
                {
                    //
                    // Add the item to the listview.
                    //
                    if (-1 == ListView_InsertItem(hwndList, &item))
                    {
                        DebugMsg(DM_ERROR, TEXT("CActionPopup::InitializeList failed to add entry %d,%d"), iRow, iCol);
                    }
                }
                else
                {
                    //
                    // Set the text for a listview column entry.
                    // Note: There's no return value to check.
                    //
                    ListView_SetItemText(hwndList, iRow, iCol, (item.pszText));
                }
            }
            iRow++;
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\volprop.h ===
#ifndef _INC_DSKQUOTA_VOLPROP_H
#define _INC_DSKQUOTA_VOLPROP_H
///////////////////////////////////////////////////////////////////////////////
/*  File: volprop.h

    Description: Provides declarations for quota property pages.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    08/15/96    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _INC_DSKQUOTA_PRSHTEXT_H
#   include "prshtext.h"
#endif
#ifndef _INC_DSKQUOTA_DETAILS_H
#   include "details.h"
#endif

#ifdef POLICY_MMC_SNAPIN
#   ifndef _INC_DSKQUOTA_POLICY_H
#       include "policy.h"
#   endif
#endif

#include "resource.h"


const DWORD IDT_STATUS_UPDATE              = 1;
const DWORD STATUS_UPDATE_TIMER_PERIOD     = 2000; // Update every 2 sec.

#define TLM_SETSTATE (WM_USER + 100)  // TLM = Traffic Light Message.

//
// Volume property page.
//
class VolumePropPage : public DiskQuotaPropSheetExt
{
    protected:
            class TrafficLight
            {
                private:
                    HWND m_hwndAnimateCtl;
                    INT m_idAviClipRes;

                    //
                    // Prevent copy.
                    //
                    TrafficLight(const TrafficLight& rhs);
                    TrafficLight& operator = (const TrafficLight& rhs);

                public:
                    TrafficLight(VOID)
                        : m_hwndAnimateCtl(NULL),
                          m_idAviClipRes(-1)
                          { }

                    TrafficLight(HWND hwndAnimateCtl, INT idAviClipRes)
                        : m_hwndAnimateCtl(hwndAnimateCtl),
                          m_idAviClipRes(idAviClipRes)
                    {
                        Initialize(hwndAnimateCtl, idAviClipRes);
                    }

                    VOID Initialize(HWND hwndAnimateCtl, INT idAviClipRes);

                    ~TrafficLight(VOID)
                        { Animate_Close(m_hwndAnimateCtl); }

                    enum { YELLOW, OFF, RED, GREEN, FLASHING_YELLOW };

                    VOID Show(INT eShow);

                    INT_PTR ForwardMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
            };

        DWORD          m_dwQuotaState;
        DWORD          m_dwQuotaLogFlags;
        LONGLONG       m_llDefaultQuotaThreshold;
        LONGLONG       m_llDefaultQuotaLimit;
        UINT64         m_cVolumeMaxBytes;
        UINT_PTR       m_idStatusUpdateTimer;
        DWORD          m_dwLastStatusMsgID;
        int            m_idCtlNextFocus;
        DetailsView   *m_pDetailsView;
        XBytes        *m_pxbDefaultLimit;
        XBytes        *m_pxbDefaultThreshold;
        TrafficLight  m_TrafficLight;


        virtual INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnNotify(HWND hDlg, WPARAM wParam, LPARAM lParam);

        INT_PTR OnContextMenu(HWND hwndItem, int xPos, int yPos);
        INT_PTR OnHelp(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnTimer(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnButtonDetails(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnButtonEventLog(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // PSN_xxxx handlers.
        //
        virtual INT_PTR OnSheetNotifyApply(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyKillActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyReset(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifySetActive(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // EN_xxxx handlers.
        //
        INT_PTR OnEditNotifyUpdate(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifyKillFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);
        INT_PTR OnEditNotifySetFocus(HWND hDlg, WPARAM wParam, LPARAM lParam);

        //
        // CBN_xxxx handlers.
        //
        INT_PTR OnComboNotifySelChange(HWND hDlg, WPARAM wParam, LPARAM lParam);


        HRESULT UpdateControls(HWND hDlg) const;
        HRESULT InitializeControls(HWND hDlg);
        HRESULT EnableControls(HWND hDlg);
        HRESULT RefreshCachedVolumeQuotaInfo(VOID);
        HRESULT ApplySettings(HWND hDlg);
        HRESULT QuotaStateFromControls(HWND hDlg, LPDWORD pdwState) const;
        HRESULT LogFlagsFromControls(HWND hDlg, LPDWORD pdwLogFlags) const;
        BOOL ActivateExistingDetailsView(VOID) const;
        bool SetByPolicy(LPCTSTR pszPolicyValue);

        HRESULT UpdateStatusIndicators(HWND hDlg);

        VOID SetStatusUpdateTimer(HWND hDlg)
            {
                if (0 == m_idStatusUpdateTimer)
                    m_idStatusUpdateTimer = SetTimer(hDlg,
                                                     IDT_STATUS_UPDATE,
                                                     STATUS_UPDATE_TIMER_PERIOD,
                                                     NULL);
            }
        VOID KillStatusUpdateTimer(HWND hDlg)
            {
                if (0 != m_idStatusUpdateTimer)
                {
                    KillTimer(hDlg, m_idStatusUpdateTimer);
                    m_idStatusUpdateTimer = 0;
                }
            }

        //
        // Prevent copy.
        //
        VolumePropPage(const VolumePropPage& rhs);
        VolumePropPage& operator = (const VolumePropPage& rhs);

    public:
        VolumePropPage(VOID);
        ~VolumePropPage(VOID);

        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

#ifdef POLICY_MMC_SNAPIN

//
// A specialization of VolumePropPage to address the specific needs of
// of the disk quota policy property sheet displayed from within MMC.  The
// similarities between the two classes called for reusing as much of the
// VolumePropPage implementation as possible.
// The differences from VolumePropPage are:
//
//  1. "Quota Entries" and "Event Log" buttons are hidden.
//  2. Traffic light and status messages are hidden.
//  3. Page is not opened up "over" a specific volume.
//  4. When user selects "OK" or "Apply", quota information is written to
//     the registry.
//
class CSnapInCompData; // fwd decl.
class SnapInVolPropPage : public VolumePropPage
{
    public:
        SnapInVolPropPage(void)
            : m_pPolicy(NULL) { }

        ~SnapInVolPropPage(void);

    private:
        LPDISKQUOTAPOLICY m_pPolicy;

        virtual INT_PTR OnInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual HRESULT CreateDiskQuotaPolicyObject(IDiskQuotaPolicy **ppOut);

        //
        // PSN_xxxx handlers.
        //
        virtual INT_PTR OnSheetNotifyApply(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyKillActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifyReset(HWND hDlg, WPARAM wParam, LPARAM lParam);
        virtual INT_PTR OnSheetNotifySetActive(HWND hDlg, WPARAM wParam, LPARAM lParam);
};

#endif // POLICY_MMC_SNAPIN


#ifdef PER_DIRECTORY_QUOTAS
//
// Folder property page.
//
class FolderPropPage : public DiskQuotaPropSheetExt
{
//
// This class has not been implemented.
// At some future date, we may implement per-directory quota management.
// If such support is required, look at class VolumePropPage.
// You should be able to provide a similar implementation only with
// directory-specific features.  All features common to volumes and
// directories are in class DiskQuotaPropSheetExt.
//
    public:
        //
        // Dialog Proc callback.
        //
        static INT_PTR APIENTRY DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
            { return FALSE; }
};


#endif // PER_DIRECTORY_QUOTAS




#endif // __DSKQUOTA_PROPSHEET_EXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\action.h ===
#ifndef __ACTION_H
#define __ACTION_H
///////////////////////////////////////////////////////////////////////////////
/*  File: action.h

    Description: Declarations for classes to handle actions associated
        with user notifications (email, popup dialog etc).
        
            CAction
            CActionEmail
            CActionPopup

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef __MAPISEND_H
#   include "mapisend.h"
#endif


//
// Fwd declarations.  Don't need headers.
//
class CHistory;
class CStatisticsList;

class CAction
{
    public:
        CAction(VOID) { };
        virtual ~CAction(VOID) { };

        virtual HRESULT DoAction(CHistory& history) = 0;

    private:
        //
        // Prevent copy.
        //
        CAction(const CAction& rhs);
        CAction& operator = (const CAction& rhs);
};


class CActionEmail : public CAction
{
    public:
        CActionEmail(CMapiSession& MapiSession,
                     LPMAPIFOLDER pMapiFolder,
                     LPTSTR pszRecipientsTo,
                     LPTSTR pszRecipientsCc,
                     LPTSTR pszRecipientsBcc,
                     LPCTSTR pszSubject,
                     CMapiMessageBody& MsgBody);

        virtual ~CActionEmail(VOID);

        virtual HRESULT DoAction(CHistory& history);

    private:
        CMapiSession&   m_MapiSession;    // Reference to MAPI session object.
        CMapiRecipients m_MapiRecipients; // List of recipients for for message.
        CMapiMessage    m_MapiMsg;        // MAPI message we'll build and send.
        MAPI            m_Mapi;           // MAPI functions.

        //
        // Prevent copy.
        //
        CActionEmail(const CActionEmail& rhs);
        CActionEmail& operator = (const CActionEmail& rhs);
};

class CActionPopup : public CAction
{
    public:
        CActionPopup(CStatisticsList& stats);

        virtual ~CActionPopup(VOID);

        virtual HRESULT DoAction(CHistory& history);

    private:
        CStatisticsList& m_stats;
        HWND             m_hwnd;
        HINSTANCE        m_hmodCOMCTL32;
        HICON            m_hiconDialog;
        static UINT      m_idAutoCloseTimer;
        static UINT      m_uAutoCloseTimeout;

        HRESULT CreateAndRunPopup(
            HINSTANCE hInst,
            LPCTSTR pszDlgTemplate,
            HWND hwndParent);

        static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        BOOL OnInitDialog(HWND hwnd);
        BOOL OnDestroy(HWND hwnd);
        BOOL OnNcDestroy(HWND hwnd);
        VOID InitializeList(HWND hwndList);

        //
        // Prevent copy.
        //
        CActionPopup(const CActionPopup& rhs);
        CActionPopup& operator = (const CActionPopup& rhs);
};

#endif //__ACTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\ui\yntoall.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: yntoall.cpp

    Description: Implements the YesNoToAll dialog.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#pragma hdrstop

#include "yntoall.h"
#include "resource.h"



///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::YesNoToAllDialog

    Description: Class constructor.

    Arguments:
        idDialogTemplate - ID number for the dialog's resource template.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
YesNoToAllDialog::YesNoToAllDialog(
    UINT idDialogTemplate
    ) : m_idDialogTemplate(idDialogTemplate),
        m_hwndCbxApplyToAll(NULL),
        m_hwndTxtMsg(NULL),
        m_bApplyToAll(FALSE),
        m_pszTitle(NULL),
        m_pszText(NULL)
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("YesNoToAllDialog::YesNoToAllDialog")));
    //
    // Do nothing.
    //
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::~YesNoToAllDialog

    Description: Class destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
YesNoToAllDialog::~YesNoToAllDialog(
    VOID
    )
{
    DBGTRACE((DM_VIEW, DL_HIGH, TEXT("YesNoToAllDialog::YesNoToAllDialog")));
    //
    // Call the Destroy() function to destroy the progress dialog window.
    //
    delete[] m_pszTitle;
    delete[] m_pszText;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::Create

    Description: Creates the dialog.

    Arguments:
        hInstance - Instance handle for the DLL containing the dialog
            resource template.

        hwndParent - Parent window for dialog.

        lpszTitle - Title for dialog.

        lpszText - Text message for dialog.

    Returns:
        TRUE  = Dialog was created.
        FALSE = Dialog was not created.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR
YesNoToAllDialog::CreateAndRun(
    HINSTANCE hInstance,
    HWND hwndParent,
    LPCTSTR pszTitle,
    LPCTSTR pszText
    )
{
    DBGASSERT((NULL != pszTitle));
    DBGASSERT((NULL != pszText));

    //
    // Set these in member variables so that the text can be set in the
    // dialog in response to WM_INITDIALOG.
    //
    m_pszTitle = StringDup(pszTitle);
    m_pszText  = StringDup(pszText);

    return DialogBoxParam(hInstance,
                          MAKEINTRESOURCE(m_idDialogTemplate),
                          hwndParent,
                          DlgProc,
                          (LPARAM)this);
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: YesNoToAllDialog::DlgProc [static]

    Description: Message procedure for the dialog.

    Arguments: Standard Win32 message proc arguments.

    Returns: Standard Win32 message proc return values.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    05/28/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
YesNoToAllDialog::DlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // Retrieve the dialog object's ptr from the window's userdata.
    // Place there in response to WM_INITDIALOG.
    //
    YesNoToAllDialog *pThis = (YesNoToAllDialog *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
            //
            // Store "this" ptr in window's userdata.
            //
            SetWindowLongPtr(hwnd, DWLP_USER, (INT_PTR)lParam);
            pThis = (YesNoToAllDialog *)lParam;

            //
            // Center popup on the desktop.
            //
            ::CenterPopupWindow(hwnd, GetDesktopWindow());
            pThis->m_hwndTxtMsg        = GetDlgItem(hwnd, IDC_TXT_YNTOALL);
            pThis->m_hwndCbxApplyToAll = GetDlgItem(hwnd, IDC_CBX_YNTOALL);
            SetWindowText(pThis->m_hwndTxtMsg, pThis->m_pszText);
            SetWindowText(hwnd, pThis->m_pszTitle);
            SendMessage(pThis->m_hwndCbxApplyToAll,
                        BM_SETCHECK,
                        pThis->m_bApplyToAll ? (WPARAM)BST_CHECKED : (WPARAM)BST_UNCHECKED,
                        0);

            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                case IDYES:
                case IDNO:
                    DBGASSERT((NULL != pThis));
                    pThis->m_bApplyToAll = (BST_CHECKED == SendMessage(pThis->m_hwndCbxApplyToAll, BM_GETCHECK, 0, 0));
                    EndDialog(hwnd, LOWORD(wParam));
                    break;
            }
            break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\history.h ===
#ifndef __HISTORY_H
#define __HISTORY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: history.h

    Description: To prevent the watchdog from excessive repeate notifications,
        the system administrator can set a minimum period for notification
        silence.  This class (CHistory) manages the reading of this setting
        along with remembering the last time an action occured.  A client
        of the object is able to ask it if a given action should be performed
        on the basis of past actions.
        
            CHistory


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef __DSKQUOTA_REG_PARAMS_H
#   include "regparam.h"
#endif

class CPolicy;

class CHistory
{
    public:
        CHistory(CPolicy& policy);
        ~CHistory(VOID) { };

        BOOL ShouldPopupDialog(VOID);
        BOOL ShouldSendEmail(VOID);
        BOOL ShouldDoAnyNotifications(VOID);
        VOID RecordDialogPoppedUp(VOID);
        VOID RecordEmailSent(VOID);
    private:
        RegParamTable m_RegParams;
        CPolicy&      m_policy;    // To get min email/popup periods.

        static VOID GetSysTime(LPFILETIME pftOut);
        static INT CalcDiffMinutes(const FILETIME& ftA, const FILETIME& ftB);

        //
        // Registry parameter value names.
        //
        static const TCHAR SZ_REG_LAST_NOTIFY_EMAIL_TIME[];
        static const TCHAR SZ_REG_LAST_NOTIFY_POPUP_TIME[];

        //
        // Prevent copy.
        //
        CHistory(const CHistory& rhs);
        CHistory& operator = (const CHistory& rhs);
};

#endif //__HISTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\dskquowd.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: dskquowd.cpp

    Description: Main entry point for the Windows NT Disk Quota Notification
        WatchDog.  This DLL exports the functions ProcessGPTA and ProcessGPTW
        to be called periodically from WINLOGON.EXE.  When invoked, the
        module enumerates all local and connected volumes, gathers quota
        statistics for each and generates email messages and/or a popup
        dialog as specified by system policy and the volume's quota settings.

        Ideally, the underlying file system could generate notifications
        warning users of approaching a quota limit.  However, within base
        NT, the name used by the user for identifying a drive is unknown.
        Therefore, a message meaningful to the user cannot be generated
        by NTFS.  It must be performed by the client workstation.  Hence,
        this watchdog applet is required.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "precomp.hxx" // PCH
#pragma hdrstop

#define INITGUIDS
#include "dskquota.h"

#include "watchdog.h"


HINSTANCE g_hInstDll;    // DLL instance handle.

//
// Location in HKEY_CURRENT_USER for configuration and state data.
// Names are #define'd in ..\common\private.h
//
TCHAR g_szRegSubKeyAdmin[] = G_SZ_REGSUBKEY_ADMIN;
TCHAR g_szRegSubKeyUser[]  = G_SZ_REGSUBKEY_USER;


///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessAttach

    Description: Handles all tasks associated with a process attaching to 
        the DLL.

        Try to keep processing time to a minimum.

    Arguments:
        hInstDll - The DLL instance handle passed to DllMain.

    Returns:
        NOERROR    - Success.
        E_FAIL     - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessAttach(
    HINSTANCE hInstDll
    )
{
    HRESULT hResult = E_FAIL;

    //
    // Start IceCAP profiling.
    //
    ICAP_START_ALL;

#ifdef DEBUG
    // 
    // Default is DM_NONE.
    //
    SetDebugMask(DM_ASSERT | DM_ERROR);
#endif

    g_hInstDll = hInstDll;
    DisableThreadLibraryCalls(hInstDll);

    if (FAILED(g_OleAlloc.Initialize()))
    {
        goto proc_attach_failed;
    }

    hResult = NOERROR;

proc_attach_failed:
        NULL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: OnProcessDetach

    Description: Handles all tasks associated with a process detaching from 
        the DLL.

    Arguments: None.

    Returns:
        NOERROR    - Success.
        E_FAIL     - Something failed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
OnProcessDetach(
    VOID
    )
{
    HRESULT hResult = NOERROR;

    //
    // Stop IceCAP profiling.
    //
    ICAP_STOP_ALL;

    return hResult;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: DllMain

    Description: Main entry point for OLE component server.

    Arguments:
        hInstDll - Instance handle of DLL

        fdwReason - Reason DllMain is being called.  Can be at Process attach/
            detach or Thread attach/detach.

        lpdwReserved - Reserved.

    Returns:
        TRUE    - Successful initialization.
        FALSE   - Failed initialization.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
BOOL WINAPI 
DllMain(
    HINSTANCE hInstDll, 
    DWORD fdwReason, 
    LPVOID lpvReserved
    )
{
    BOOL bResult = FALSE;

    switch(fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DM_OLE, TEXT("DSKQUOWD - DLL_PROCESS_ATTACH"));
            bResult = SUCCEEDED(OnProcessAttach(hInstDll));
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bResult = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DM_OLE, TEXT("DSKQUOWD - DLL_PROCESS_DETACH"));
            bResult = SUCCEEDED(OnProcessDetach());
            break;
    }

    return bResult;
}

BOOL
ProcessGPT(
    HANDLE hUserToken,          // User's token
    HKEY hKeyCurrentUser,       // Registry key to the root of the user's profile
    LPTSTR pszGPTPath,          // UNC path to the gpt
    BOOL bMachinePolicyOnly,    // Only apply machine policy
    BOOL bBackgroundRefresh,    // This is a background refresh - ok to do slow stuff...
    BOOL bDelete                // Delete policy
    )
{
    BOOL bResult = FALSE; // Assume failure.

    try
    {
        HRESULT hr;

        //
        // Create a watchdog object and tell it to run.
        //
        CWatchDog Hooch(hUserToken);
        hr = Hooch.Run();

        bResult = SUCCEEDED(hr);

        if (FAILED(hr))
        {
            DebugMsg(DM_ERROR, 
                     TEXT("ProcessGPT - CWatchDog::Run failed with error 0x%08X"), hr);
        }
    }
    catch(OutOfMemory)
    {
        //
        // Handle general out-of-memory exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPT - Insufficient memory"));
    }
    catch(CString::Exception& e)
    {
        //
        // The CString class throws it's own exceptions.
        //
        switch(e.Reason())
        {
            case CString::Exception::Index:
                DebugMsg(DM_ERROR, TEXT("ProcessGPT - CString::Exception::Index"));
                break;
            case CString::Exception::Memory:
                DebugMsg(DM_ERROR, TEXT("ProcessGPT - CString::Exception::Memory"));
                break;
            default:
                DebugMsg(DM_ERROR, TEXT("ProcessGPT - CString::Exception::Unknown"));
                break;
        }
    }
    catch(...)
    {
        //
        // Report any general exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPT - Unknown exception"));
    }

    return bResult;
}


BOOL 
ProcessGPTW (
    HANDLE hUserToken,          // User's token
    HKEY hKeyCurrentUser,       // Registry key to the root of the user's profile
    LPWSTR pszGPTPathW,          // UNC path to the gpt
    BOOL bMachinePolicyOnly,    // Only apply machine policy
    BOOL bBackgroundRefresh,    // This is a background refresh - ok to do slow stuff...
    BOOL bDelete                // Delete policy
    )
{
    BOOL bResult      = FALSE;
    LPTSTR pszGPTPath = NULL;
    LPSTR pszGPTPathA = NULL;

    try
    {
#ifndef UNICODE
        //
        // Get the size of the buffer needed to hold pszGPTPathA as a UNICODE str.
        //
        INT cchA = WideCharToMultiByte(CP_ACP,
                                       0,
                                       pszGPTPathW,
                                       -1,
                                       NULL,
                                       0, NULL, NULL);
        //
        // Allocate the ANSI buffer.
        //
        LPSTR pszGPTPathA = new WCHAR[cchA];
        if (NULL != pszGPTPathA)
        {
            //
            // Now convert the UNICODE string to ANSI.
            //
            cchA = MultiByteToWideChar(CP_ACP,
                                       0,
                                       pszGPTPathW,
                                       -1,
                                       pszGPTPathA,
                                       cchA);
        }
        pszGPTPath = pszGPTPathA;
#else
        pszGPTPath = pszGPTPathW;
#endif

        if (NULL != pszGPTPath && TEXT('\0') != *pszGPTPath)
        {
            //
            // Process the GPT using the UNICODE/Ansi-sensitive version.
            // ProcessGPT will trap any exceptions.
            //
            bResult = ProcessGPT(hUserToken,
                                 hKeyCurrentUser,
                                 pszGPTPath,
                                 bMachinePolicyOnly,
                                 bBackgroundRefresh,
                                 bDelete);
        }
    }
    catch(OutOfMemory)
    {
        //
        // Handle general out-of-memory exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPTW - Insufficient memory"));
    }
    catch(...)
    {
        //
        // Report any general exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPTW - Unknown exception"));
    }

    if ((LPWSTR)pszGPTPath != pszGPTPathW)
    {
        //
        // If pszGPTPath isn't pointing to the UNICODE version, it is either
        // pointing to the ANSI version or it's NULL.
        //
        Assert(NULL == pszGPTPath || pszGPTPathA == (LPSTR)pszGPTPath);
        delete[] pszGPTPath;
    }

    return bResult;
}


BOOL 
ProcessGPTA (
    HANDLE hUserToken,          // User's token
    HKEY hKeyCurrentUser,       // Registry key to the root of the user's profile
    LPSTR pszGPTPathA,          // UNC path to the gpt
    BOOL bMachinePolicyOnly,    // Only apply machine policy
    BOOL bBackgroundRefresh,    // This is a background refresh - ok to do slow stuff...
    BOOL bDelete                // Delete policy
    )
{
    BOOL bResult       = FALSE;
    LPTSTR pszGPTPath  = NULL;
    LPWSTR pszGPTPathW = NULL;

    try
    {
#ifdef UNICODE
        //
        // Get the size of the buffer needed to hold pszGPTPathA as a UNICODE str.
        //
        INT cchW = MultiByteToWideChar(CP_ACP,
                                       0,
                                       pszGPTPathA,
                                       -1,
                                       NULL,
                                       0);
        //
        // Allocate the UNICODE buffer.
        //
        LPWSTR pszGPTPathW = new WCHAR[cchW];
        if (NULL != pszGPTPathW)
        {
            //
            // Now convert the ANSI string to UNICODE.
            //
            cchW = MultiByteToWideChar(CP_ACP,
                                       0,
                                       pszGPTPathA,
                                       -1,
                                       pszGPTPathW,
                                       cchW);
        }
        pszGPTPath = pszGPTPathW;
#else
        pszGPTPath = pszGPTPathA;
#endif

        if (NULL != pszGPTPath && TEXT('\0') != *pszGPTPath)
        {
            //
            // Process the GPT using the UNICODE/Ansi-sensitive version.
            // ProcessGPT will trap any exceptions.
            //
            bResult = ProcessGPT(hUserToken,
                                 hKeyCurrentUser,
                                 pszGPTPath,
                                 bMachinePolicyOnly,
                                 bBackgroundRefresh,
                                 bDelete);
        }
    }
    catch(OutOfMemory)
    {
        //
        // Handle general out-of-memory exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPTA - Insufficient memory"));
    }
    catch(...)
    {
        //
        // Report any general exceptions.
        //
        DebugMsg(DM_ERROR, TEXT("ProcessGPTA - Unknown exception"));
    }

    if ((LPSTR)pszGPTPath != pszGPTPathA)
    {
        //
        // If pszGPTPath isn't pointing to the ANSI version, it is either
        // pointing to the UNICODE version or it's NULL.
        //
        Assert(NULL == pszGPTPath || pszGPTPathW == (LPWSTR)pszGPTPath);
        delete[] pszGPTPath;
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\mapisend.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: mapisend.cpp

    Description: Implements the most basic MAPI email client to send a message
        to one or more recipients.  All operations are done without UI.

        classes:    CMapiSession
                    CMapiRecipients
                    CMapiMessage
                    CMapiMessageBody
                    MAPI

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
    06/22/97    Added class MAPI.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include "precomp.hxx"
#pragma hdrstop

#include "mapisend.h"


//
// Global MAPI object to provide dynamic linking to MAPI32.DLL.
// All MAPI32.DLL functions are called through this object.
//
MAPI MAPI32;


//
// How many entries we grow the recipients list by when it is enlarged.
//
#ifdef DEBUG
    //
    // For debugging and development, stress the list-growth code by making
    // it extend the list each time a recipient is added.
    //
    UINT CMapiRecipients::m_cGrowIncr = 1;
#else // !DEBUG
    //
    // For production builds, fix the growth increment at 3.  3 is arbitrary
    // but is probably a good conservative guess.  Want to avoid
    // list growth in the typical scenario.  
    //
    //      1 for the quota user.
    //      1 for the volume administrator.
    //      1 for the user's manager (? probably not)
    //
    // Note that the list growth code always runs at least once because
    // we use it to create the initial list.  
    //
    UINT CMapiRecipients::m_cGrowIncr = 3;
#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CMapiRecipients

    Description: Constructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiRecipients::CMapiRecipients(
    BOOL bUnicode
    ) : m_pal(NULL),
        m_bUnicode(bUnicode),
        m_cMaxEntries(0)
{

}

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::~CMapiRecipients

    Description: Destructor.
        Frees the MAPI address list.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiRecipients::~CMapiRecipients(
    VOID
    )
{
    if (NULL != m_pal)
    {
        MAPI32.FreePadrlist(m_pal);
    }
}

CMapiRecipients::CMapiRecipients(
    const CMapiRecipients& rhs
    ) : m_pal(NULL),
        m_bUnicode(FALSE),
        m_cMaxEntries(0)
{
#ifdef UNICODE
    m_bUnicode = TRUE;
#endif

    *this = rhs;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::operator = (const CMapiRecipients& rhs)

    Description: Assignment copy.

    Arguments:
        rhs - Reference to source recipient list.

    Returns: Reference to destination recipient list.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiRecipients& 
CMapiRecipients::operator = (
    const CMapiRecipients& rhs
    )
{
    if (this != &rhs)
    {
        BOOL bConvertStrings = m_bUnicode != rhs.m_bUnicode;

        //
        // Delete the current address list.
        //
        if (NULL != m_pal)
        {
            MAPI32.FreePadrlist(m_pal);
            m_pal = NULL;
        }

        //
        // Copy the Max entry count.
        //
        // NOTE:  We DO NOT copy the m_bUnicode attribute.
        //        This attribute stays with the object for life.
        //
        m_cMaxEntries = rhs.m_cMaxEntries;

        if (NULL != rhs.m_pal)
        {
            HRESULT hr = E_FAIL;
            UINT cb;

            cb = sizeof(ADRLIST) + ((m_cMaxEntries - 1) * sizeof(ADRENTRY));
            hr = MAPI32.AllocateBuffer(cb, (LPVOID *)&m_pal);
            if (SUCCEEDED(hr))
            {
                ZeroMemory(m_pal, cb); // Note: m_pal->cEntries is init'd to 0.
                if (NULL != m_pal)
                {
                    for (UINT i = 0; i < rhs.m_pal->cEntries && SUCCEEDED(hr); i++)
                    {
                        hr = CopyAdrListEntry(m_pal->aEntries[i], 
                                              rhs.m_pal->aEntries[i], 
                                              bConvertStrings);
                        if (SUCCEEDED(hr))
                        {
                            m_pal->cEntries++;
                        }
                    }
                }
            }
            if (FAILED(hr))
            {
                //
                // Something went wrong.  Leave the object in an empty state.
                //
                if (NULL != m_pal)
                    MAPI32.FreePadrlist(m_pal);

                m_pal         = NULL;
                m_cMaxEntries = 0;
            }
        }
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::Count

    Description: Returns the count of valid entries in the address list.

    Arguments: None.

    Returns: Count of entries.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
INT 
CMapiRecipients::Count(
    VOID
    ) const
{
    return m_pal ? m_pal->cEntries : 0;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::AddRecipient

    Description: Adds a new recipient/recipient-type pair to the address list.

    Arguments:
        pszEmailName - Name of recipient typically used as an email destination.

        dwType - Recipient type.  Can be one of the following:

            MAPI_ORIG
            MAPI_TO
            MAPI_CC
            MAPI_BCC

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiRecipients::AddRecipient(
    LPCTSTR pszEmailName, 
    DWORD dwType
    )
{
    HRESULT hr = NO_ERROR;
    
    if (NULL == m_pal || m_pal->cEntries == m_cMaxEntries)
    {
        //
        // Either we're just starting up (no list created yet),
        // or the current list is full.  Grow the list.
        //
        hr = Grow(m_cGrowIncr);
    }
    if (SUCCEEDED(hr) && NULL != m_pal)
    {
        UINT cb;
        INT i = m_pal->cEntries++;

        m_pal->aEntries[i].ulReserved1 = 0;
        m_pal->aEntries[i].cValues     = 2;

        //
        // Allocate the SPropValue buffer for this new entry.
        // Our entries have 2 values (name and type).
        // Caller must call IAddrBook::ResolveName() to get the remaining
        // recipient information.
        //
        cb = sizeof(SPropValue) * m_pal->aEntries[i].cValues;
        hr = MAPI32.AllocateBuffer(cb, (LPVOID *)&m_pal->aEntries[i].rgPropVals);
        if (SUCCEEDED(hr))
        {
            ZeroMemory(m_pal->aEntries[i].rgPropVals, cb);
            //
            // Allocate the buffer for the recipient email name string.
            //
            hr = MAPI32.AllocateMore((lstrlen(pszEmailName)+1) * sizeof(TCHAR),
                                    (LPVOID)m_pal->aEntries[i].rgPropVals,
                                    (LPVOID *)&m_pal->aEntries[i].rgPropVals[0].Value.LPSZ);
            if (SUCCEEDED(hr))
            {
                //
                // Store the recipient email name string.
                //
                m_pal->aEntries[i].rgPropVals[0].ulPropTag  = PR_DISPLAY_NAME;
                lstrcpy(m_pal->aEntries[i].rgPropVals[0].Value.LPSZ, pszEmailName);

                //
                // Store the recipient type (i.e. MAPI_TO, MAPI_CC etc).
                //
                m_pal->aEntries[i].rgPropVals[1].ulPropTag  = PR_RECIPIENT_TYPE;
                m_pal->aEntries[i].rgPropVals[1].Value.l    = dwType;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::Grow

    Description: Increases the size of the address list, preserving any
        existing list entries.

    Arguments:
        cGrowIncr - Number of entries to grow the list by.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::Grow(
    UINT cGrowIncr
    )
{
    HRESULT hr         = E_FAIL;
    LPADRLIST m_palNew = NULL;
    UINT cb;

    //
    // Allocate the new buffer m_cGrowIncr entries larger than the
    // current buffer.  The (-1) is because the declaration of ADRLIST already
    // includes one entry.
    //
    cb = sizeof(ADRLIST) + ((m_cMaxEntries + cGrowIncr - 1) * sizeof(ADRENTRY));
    hr = MAPI32.AllocateBuffer(cb, (LPVOID *)&m_palNew);
    if (SUCCEEDED(hr))
    {
        ZeroMemory(m_palNew, cb); // Note: m_palNew->cEntries is init'd to 0.
        if (NULL != m_pal)
        {
            //
            // We have an existing address list.
            // Copy it to the new list buffer.
            // If we fail the copy of an entry, we abort the loop and m_palNew->cEntries
            // accurately reflects how many valid entries we have.
            //
            for (UINT i = 0; i < m_pal->cEntries && SUCCEEDED(hr); i++)
            {
                hr = CopyAdrListEntry(m_palNew->aEntries[i], m_pal->aEntries[i], FALSE);
                if (SUCCEEDED(hr))
                {
                    m_palNew->cEntries++;
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        //
        // Delete the original list (if it exists) and store the
        // address of the new list in m_pal.
        //
        LPADRLIST palOrig = m_pal;
        m_pal = m_palNew;
        if (NULL != palOrig)
            MAPI32.FreePadrlist(palOrig);

        m_cMaxEntries += cGrowIncr;
    }
    else
    {
        //
        // Something went wrong.  Just delete the new list and keep the old one
        // the way it was.
        //
        if (NULL != m_palNew)
            MAPI32.FreePadrlist(m_palNew);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CopyAdrListEntry

    Description: Copies a single list entry from one entry structure to another.
        All entry-type-specific issues are addressed.

    Arguments:
        Dest - Reference to destination entry structure.

        Src - Reference to source entry structure.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::CopyAdrListEntry(
    ADRENTRY& Dest,
    ADRENTRY& Src,
    BOOL bConvertStrings
    )
{
    HRESULT hr;
    UINT cb = 0;
    
    //
    // Allocate buffer for the new entry and it's property values.
    //
    cb = sizeof(SPropValue) * Src.cValues;
    hr = MAPI32.AllocateBuffer(cb, (LPVOID *)&Dest.rgPropVals);
    if (SUCCEEDED(hr))
    {
        ZeroMemory(Dest.rgPropVals, cb);
        Dest.cValues = 0;
        //
        // Copy each of the values.
        // If we fail the copy of a value, we abort the loop and Dest.cValues
        // accurately reflects how many valid prop values we have.
        //
        for (UINT i = 0; i < Src.cValues && SUCCEEDED(hr); i++)
        {
            hr = CopySPropVal((LPVOID)Dest.rgPropVals, // Base for new allocations
                              Dest.rgPropVals[i],      // Destination SPropVal
                              Src.rgPropVals[i],       // Source SPropVal
                              bConvertStrings);
            if (SUCCEEDED(hr))
            {
                Dest.cValues++;
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CopySPropVal

    Description: Copies a single property value from one SPropValue object
        to another.  Used by CopyAdrListEntry to copy the individual properties
        belonging to an entry.

    Arguments:
        pvBaseAlloc - Pointer to use as the "lpObject" argument in a call
            to MAPIAllocateMore() if memory must be reallocated during
            the copy process.

        Dest - Reference to destination property value structure.

        Src - Reference to source property value structure.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::CopySPropVal(
    LPVOID pvBaseAlloc,
    SPropValue& Dest,
    SPropValue& Src,
    BOOL bConvertStrings
    )
{
    HRESULT hr = NO_ERROR;
    BOOL bCopyTag = TRUE;

    //
    // Copy method varies depending on property type.
    //
    switch(PROP_TYPE(Src.ulPropTag))
    {
        case PT_I2:
            Dest.Value.i = Src.Value.i;
            break;
        case PT_LONG:
            Dest.Value.l = Src.Value.l;
            break;
        case PT_R4:
            Dest.Value.flt = Src.Value.flt;
            break;
        case PT_DOUBLE:
            Dest.Value.dbl = Src.Value.dbl;
            break;
        case PT_BOOLEAN:
            Dest.Value.b = Src.Value.b;
            break;
        case PT_CURRENCY:
            Dest.Value.cur = Src.Value.cur;
            break;
        case PT_APPTIME:
            Dest.Value.at = Src.Value.at;
            break;
        case PT_SYSTIME:
            Dest.Value.ft = Src.Value.ft;
            break;
        case PT_I8:
            Dest.Value.li = Src.Value.li;
            break;
        case PT_ERROR:
            Dest.Value.err = Src.Value.err;
            break;
        case PT_NULL:
        case PT_OBJECT:
            Dest.Value.x = Src.Value.x;
            break;
        case PT_STRING8:
            if (bConvertStrings && m_bUnicode)
            {
                //
                // The recipients list is unicode, the source is ANSI
                // and we're supposed to convert strings.  That means
                // we need to convert from Ansi to Unicode.
                //
                hr = CopySPropValString(pvBaseAlloc,
                                        &Dest.Value.lpszW,
                                        Src.Value.lpszA);

                Dest.ulPropTag = PROP_TAG(PT_UNICODE, PROP_ID(Src.ulPropTag));
                bCopyTag       = FALSE;
            }
            else
            {
                //
                // No conversion required.  Just a straight copy.
                //
                hr = CopyVarLengthSPropVal(pvBaseAlloc, 
                                           (LPVOID *)&Dest.Value.lpszA, 
                                           Src.Value.lpszA,
                                           (lstrlenA(Src.Value.lpszA)+1) * sizeof(char));
            }
            break;
                
        case PT_UNICODE:
            if (bConvertStrings && !m_bUnicode)
            {
                //
                // The recipients list is Ansi, the source is Unicode
                // and we're supposed to convert strings.  That means
                // we need to convert from Unicode to Ansi.
                //
                hr = CopySPropValString(pvBaseAlloc,
                                        &Dest.Value.lpszA,
                                        Src.Value.lpszW);

                Dest.ulPropTag = PROP_TAG(PT_STRING8, PROP_ID(Src.ulPropTag));
                bCopyTag       = FALSE;
            }
            else
            {
                //
                // No conversion required.  Just a straight copy.
                //
                hr = CopyVarLengthSPropVal(pvBaseAlloc, 
                                           (LPVOID *)&Dest.Value.lpszW, 
                                           Src.Value.lpszW,
                                           (lstrlenW(Src.Value.lpszW)+1) * sizeof(WCHAR));
            }
            break;

        case PT_BINARY:
            hr = CopyVarLengthSPropVal(pvBaseAlloc, 
                                       (LPVOID *)&Dest.Value.bin.lpb, 
                                       Src.Value.bin.lpb,
                                       Src.Value.bin.cb);
            break;
        case PT_CLSID:
            hr = CopyVarLengthSPropVal(pvBaseAlloc, 
                                       (LPVOID *)&Dest.Value.lpguid, 
                                       Src.Value.lpguid,
                                       sizeof(*(Src.Value.lpguid)));
            break;
        default:
            //
            // FEATURE:  Assert here so we know if we should be handling
            //          some other property type.
            //
            hr = E_FAIL;
            break;
    }
    if (SUCCEEDED(hr))
    {
        //
        // Copy the common stuff.
        //
        Dest.dwAlignPad = Src.dwAlignPad;
        if (bCopyTag)
        {
            Dest.ulPropTag  = Src.ulPropTag;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CopyVarLengthSPropVal

    Description: Copies a single variable-length property value item from
        one location in memory to another.  Memory for the destination is
        automatically allocated.  This function is used to copy prop values
        of types STRING, BINARY etc.

    Arguments:
        pvBaseAlloc - Pointer to use as the "lpObject" argument in a call
            to MAPIAllocateMore().

        ppvDest - Address of pointer variable to receive the address of  
            the newly allocated buffer.

        pvSrc - Address of source buffer.

        cb - Number of bytes to copy from pvSrc to *ppvDest.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::CopyVarLengthSPropVal(
    LPVOID pvBaseAlloc,
    LPVOID *ppvDest,
    LPVOID pvSrc,
    INT cb
    )
{
    HRESULT hr;
             
    hr = MAPI32.AllocateMore(cb, pvBaseAlloc, ppvDest);
    if (SUCCEEDED(hr))
    {
        CopyMemory(*ppvDest, pvSrc, cb);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CopySPropValString (ANSI -> UNICODE)

    Description: Copies a string property value item from one location
        to another; performing ANSI/UNICODE translations as required.

    Arguments:
        pvBaseAlloc - Pointer to use as the "lpObject" argument in a call
            to MAPIAllocateMore().

        ppszDestW - Address of pointer variable to receive the address of  
            the newly wide character buffer.

        pszSrcA - Address of ANSI source buffer.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::CopySPropValString(
    LPVOID pvBaseAlloc,
    LPWSTR *ppszDestW,
    LPCSTR pszSrcA
    )
{
    HRESULT hr;

    INT cchW = MultiByteToWideChar(CP_ACP,
                                   0,
                                   pszSrcA,
                                   -1,
                                   NULL,
                                   0);

    hr = MAPI32.AllocateMore(cchW * sizeof(WCHAR), pvBaseAlloc, (LPVOID *)ppszDestW);
    if (SUCCEEDED(hr))
    {
        MultiByteToWideChar(CP_ACP,
                            0,
                            pszSrcA,
                            -1,
                            *ppszDestW,
                            cchW);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiRecipients::CopySPropValString (UNICODE -> ANSI)

    Description: Copies a string property value item from one location
        to another; performing ANSI/UNICODE translations as required.

    Arguments:
        pvBaseAlloc - Pointer to use as the "lpObject" argument in a call
            to MAPIAllocateMore().

        ppszDestA - Address of pointer variable to receive the address of  
            the newly ANSI character buffer.

        pszSrcW - Address of UNICODE source buffer.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiRecipients::CopySPropValString(
    LPVOID pvBaseAlloc,
    LPSTR *ppszDestA,
    LPCWSTR pszSrcW
    )
{
    HRESULT hr;

    INT cchA = WideCharToMultiByte(CP_ACP,
                                   0,
                                   pszSrcW,
                                   -1,
                                   NULL,
                                   0,
                                   NULL, NULL);

    hr = MAPI32.AllocateMore(cchA * sizeof(CHAR), pvBaseAlloc, (LPVOID *)ppszDestA);
    if (SUCCEEDED(hr))
    {
        WideCharToMultiByte(CP_ACP,
                            0,
                            pszSrcW,
                            -1,
                            *ppszDestA,
                            cchA,
                            NULL, NULL);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::CMapiSession

    Description: Constructor.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiSession::CMapiSession(
    VOID
    ) : m_pSession(NULL),
        m_pDefMsgStore(NULL),
        m_pOutBoxFolder(NULL),
        m_bMapiInitialized(FALSE)
{
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::CMapiSession

    Description: Constructor.  Initializes MAPI.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiSession::~CMapiSession(
    VOID
    )
{
    if (NULL != m_pOutBoxFolder)
    {
        m_pOutBoxFolder->Release();
    }
    if (NULL != m_pDefMsgStore)
    {
        m_pDefMsgStore->Release();
    }
    if (NULL != m_pSession)
    {
        m_pSession->Release();
    }
    if (m_bMapiInitialized)
    {
        //
        // If MAPI was initialized, uninitialize it.
        //
        MAPI32.Uninitialize();
        //
        // Unload MAPI32.DLL.
        //
        MAPI32.Unload();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::Initialize

    Description: Initializes the session object by:
    
        1. Initializing MAPI if neccessary, 
        2. Logging on to create the MAPI session object.
        3. Open the default msg store.
        4. Open the outbox folder in the default msg store.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiSession::Initialize(
    VOID
    )
{
    HRESULT hr = NO_ERROR;

    if (!m_bMapiInitialized)
    {
        //
        // Load MAPI32.DLL.
        //
        MAPI32.Load();

        //
        // Initialize MAPI if it hasn't been initialized.
        //
        hr = MAPI32.Initialize(NULL);
        if (SUCCEEDED(hr))
        {
            //
            // Remember that MAPI has been initialized.
            //
            m_bMapiInitialized = TRUE;
        }
    }
    if (m_bMapiInitialized)
    {
        //
        // Attempt logon only if MAPI has been initialized.
        //
        DWORD dwLogonFlags = MAPI_TIMEOUT_SHORT | MAPI_USE_DEFAULT | MAPI_EXTENDED | MAPI_ALLOW_OTHERS;
#ifdef UNICODE
        dwLogonFlags |= MAPI_UNICODE;
#endif
        if (NULL != m_pSession)
        {
            //
            // Release any previously-held session interface ptr.
            //
            m_pSession->Release();
            m_pSession = NULL;
        }
        hr = MAPI32.LogonEx(0,             // Hwnd for any UI.
                            NULL,          // Profile name.
                            NULL,          // Password.
                            dwLogonFlags,  // Flags
                            &m_pSession);  // Session obj ptr (out).

        if (SUCCEEDED(hr))
        {
            ReportErrorsReturned(hr);
            //
            // We're logged on.  Open the default msg store and out box folder.
            //
            hr = OpenDefMsgStore();
            if (SUCCEEDED(hr))
            {
                hr = OpenOutBoxFolder();
            }
        }
    }
    return hr;
}
    

///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::OpenDefMsgStore

    Description: Opens the session's default message store.
        Stores the resulting IMsgStore ptr in m_pDefMsgStore.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiSession::OpenDefMsgStore(
    VOID
    )
{
    HRESULT hr = E_FAIL;
    SPropValue spv;

    SizedSPropTagArray(2, sptCols) = {2, PR_ENTRYID, PR_DEFAULT_STORE};
    SRestriction sres;

    if (NULL != m_pSession)
    {
        LPMAPITABLE pTable;
        hr = m_pSession->GetMsgStoresTable(0, &pTable);
        ReportErrorsReturned(hr);
        if (SUCCEEDED(hr))
        {
            //
            // Find the entry ID for the default store in the session's
            // msg stores table.
            //
            LPSRowSet pRow = NULL;

            sres.rt                        = RES_PROPERTY;
            sres.res.resProperty.relop     = RELOP_EQ;
            sres.res.resProperty.ulPropTag = PR_DEFAULT_STORE;
            sres.res.resProperty.lpProp    = &spv;

            spv.ulPropTag = PR_DEFAULT_STORE;
            spv.Value.b   = TRUE;

            hr = MAPI32.HrQueryAllRows(pTable,                   // Table ptr.
                                      (LPSPropTagArray)&sptCols, // Column set
                                      &sres,                     // Row restrictions
                                      NULL,                      // Sort order set
                                      0,                         // All rows.
                                      &pRow);                    // Resulting row set (out)
  
            ReportErrorsReturned(hr);
            if (SUCCEEDED(hr))
            {
                SBinary sbEID = {0, NULL};

                if (NULL != pRow &&
                    0 != pRow->cRows &&
                    0 != pRow->aRow[0].cValues &&
                    PR_ENTRYID == pRow->aRow[0].lpProps[0].ulPropTag)
                {
                    sbEID = pRow->aRow[0].lpProps[0].Value.bin;

                    //
                    // Found the ID.  Now open the store.
                    //
                    if (NULL != m_pDefMsgStore)
                    {
                        //
                        // Release any previously-held store interface ptr.
                        //
                        m_pDefMsgStore->Release();
                        m_pDefMsgStore = NULL;
                    }
                    hr = m_pSession->OpenMsgStore(0,                    // Hwnd for any UI
                                                  sbEID.cb,             // Entry ID size.
                                                  (LPENTRYID)sbEID.lpb, // Entry ID ptr.
                                                  NULL,                 // Use Std iface.
                                                  MAPI_BEST_ACCESS,     // read/write access
                                                  &m_pDefMsgStore);     // Store ptr (out)

                    ReportErrorsReturned(hr);
                }
                else
                {
                    hr = MAPI_E_NOT_FOUND;
                }
                MAPI32.FreeProws(pRow);
            }
            pTable->Release();
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::GetSessionUser

    Description: Returns the address properties for the session user.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiSession::GetSessionUser(
    LPSPropValue *ppProps,
    ULONG        *pcbProps
    )
{
    HRESULT hr = E_FAIL;

    if (NULL != m_pSession)
    {
        ULONG cbEID = 0;
        LPENTRYID lpEID = NULL;
        //
        // Get the "identity" of the session.
        // In general, this is the user's entry ID.
        //
        hr = m_pSession->QueryIdentity(&cbEID, &lpEID);
        if (SUCCEEDED(hr))
        {
            LPADRBOOK pAddrBook = NULL;
            hr = GetAddressBook(&pAddrBook);
            if (SUCCEEDED(hr))
            {
                ULONG ulObjType = 0;
                IMAPIProp *pMailUser = NULL;

                //
                // Open the user's entry in the address book.
                //
                hr = pAddrBook->OpenEntry(cbEID,
                                          lpEID,
                                          NULL,
                                          0,
                                          &ulObjType,
                                          (LPUNKNOWN *)&pMailUser);
                if (SUCCEEDED(hr))
                {
                    ULONG ulFlags = 0;
                    ULONG cProps  = 0;
#ifdef UNICODE
                    //
                    // For unicode builds, we want UNICODE property strings.
                    //
                    ulFlags |= MAPI_UNICODE;
#endif

                    SizedSPropTagArray(5, tags) = { 5, PR_ADDRTYPE,
                                                       PR_DISPLAY_NAME,
                                                       PR_EMAIL_ADDRESS,
                                                       PR_ENTRYID,
                                                       PR_SEARCH_KEY };

                    //
                    // Retrieve the user properties and return them to
                    // the caller.
                    //
                    hr = pMailUser->GetProps((LPSPropTagArray)&tags, // Prop tags
                                              ulFlags,                     
                                              pcbProps,              // Prop cnt (out)
                                              ppProps);              // Prop ptr (out)
                    ReportErrorsReturned(hr);
                    pMailUser->Release();
                }
                pAddrBook->Release();
            }
            MAPI32.FreeBuffer(lpEID);
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::OpenOutBoxFolder

    Description: Opens the outbox folder in the default message store.
        Stores the resulting IMAPIFolder ptr in m_pOutBoxFolder.

    Arguments: None.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiSession::OpenOutBoxFolder(
    VOID
    )
{
    HRESULT hr = E_FAIL;

    if (NULL != m_pSession && NULL != m_pDefMsgStore)
    {
        LPSPropValue pProps = NULL;
        ULONG ulObjType;
        ULONG cProps;
        ULONG ulFlags = 0;
#ifdef UNICODE
        //
        // For unicode builds, we want UNICODE property strings.
        //
        ulFlags |= MAPI_UNICODE;
#endif
        
        SizedSPropTagArray(1, sptFolders) = { 1, PR_IPM_OUTBOX_ENTRYID };

        //
        // Retrieve the entry ID for the outbox in the default msg store.
        //
        hr = m_pDefMsgStore->GetProps((LPSPropTagArray)&sptFolders, // Prop tags
                                      ulFlags,                     
                                      &cProps,                      // Prop cnt (out)
                                      &pProps);                     // Prop ptr (out)

        ReportErrorsReturned(hr);
        if (SUCCEEDED(hr))
        {
            if (0 != cProps && NULL != pProps)
            {
                if (pProps[0].ulPropTag == sptFolders.aulPropTag[0])
                {
                    //
                    // Get the MAPI folder interface ptr for the outbox folder.
                    //
                    if (NULL != m_pOutBoxFolder)
                    {
                        //
                        // Release any previously-held outbox interface ptr.
                        //
                        m_pOutBoxFolder->Release();
                        m_pOutBoxFolder = NULL;
                    }
                    hr = m_pSession->OpenEntry(pProps[0].Value.bin.cb,
                                               (LPENTRYID)pProps[0].Value.bin.lpb,
                                               NULL,
                                               MAPI_MODIFY,
                                               &ulObjType,
                                               (LPUNKNOWN *)&m_pOutBoxFolder);

                    ReportErrorsReturned(hr);
                }
                else
                {
                    hr = MAPI_E_NOT_FOUND;
                }
                MAPI32.FreeBuffer(pProps);
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::Send

    Description: Sends a message to a list of recipients.  There are 3
        versions that allow simple and complex formatting of the
        message body:

        1. First version lets you pass in simple text strings for the
           subject and body text.  This is the simplest way to send a 
           short, simple message.

        2. Second version lets you pass in the subject as a simple text
           string but then lets you create a complex message body as
           a CMapiMessageBody object.  This probably won't get used much.  

        3. The third version lets you create a CMapiMessage object
           containing subject line and body text. This is the method
           to use if you want to create a message with complex formatting.

        Sending a message with CMapiSession::Send ensures that the
        recipient list contains fully resolved names.  If you send
        a message with CMapiMessage::Send, you must resolve the names
        before the Send call is made.

    Arguments:
        pAdrList - Address of MAPI ADRLIST structure containing the
            list of recipient addresses.  It is assumed that
            the list contains unresolved recipients but this is not a 
            requirement.

        pszSubject - Address of subject line text.

        pszBody - Address of msg body text.

        body - Reference to CMapiMessageBody object containing the message text.

        msg - Reference to CMapiMessage object containing the subject line 
            and message body text.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
//
// Simplest form.  Just give an address list, subject line and body 
// text string.
//
HRESULT
CMapiSession::Send(
    LPADRLIST pAdrList,
    LPCTSTR pszSubject,
    LPCTSTR pszBody
    )
{
    HRESULT hr;
    //
    // Create a local CMapiMessage object with the given subject
    // line and body text.  Then just send it.
    //
    CMapiMessage msg(m_pOutBoxFolder);
    hr = msg.SetSubject(pszSubject);
    if (SUCCEEDED(hr))
    {
        hr = msg.Append(pszBody);
        if (SUCCEEDED(hr))
        {
            hr = Send(pAdrList, msg);
        }
    }
    return hr;
}

//
// If you already have a CMapiMessageBody object created with text, this is the
// version you want to use.
//
HRESULT
CMapiSession::Send(
    LPADRLIST pAdrList,
    LPCTSTR pszSubject,
    CMapiMessageBody& body
    )
{
    //
    // Create a local CMapiMessage object with the given subject
    // line and body text.  Then just send it.
    //
    CMapiMessage msg(m_pOutBoxFolder, body, pszSubject);

    return Send(pAdrList, msg);
}


//
// If you already have a CMapiMessage object create with subject line
// and body text, use this.  The other versions of Send() eventually
// call this one.
//
HRESULT
CMapiSession::Send(
    LPADRLIST pAdrList,
    CMapiMessage& msg
    )
{
    HRESULT hr = E_FAIL;

    hr = ResolveAddresses(pAdrList);
    if (SUCCEEDED(hr))
    {
        hr = msg.Send(pAdrList);
        DebugMsg(DM_ERROR, TEXT("CMapiSession::Send, Result = 0x%08X"), hr);
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::GetAddressBook

    Description: Returns the session's address book pointer.

    Arguments:
        ppAdrBook - Address of pointer variable to receive pointer value.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiSession::GetAddressBook(
    LPADRBOOK *ppAdrBook
    )
{
    HRESULT hr = E_POINTER;
    if (NULL != m_pSession && NULL != ppAdrBook)
    {  
        hr = m_pSession->OpenAddressBook(0,             // Hwnd for UI
                                         NULL,          // Use std interface
                                         AB_NO_DIALOG,  // No UI.
                                         ppAdrBook);    // Book ptr (out)

        ReportErrorsReturned(hr);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::ReportErrorsReturned [static]

    Description: When a MAPI function returns MAPI_W_ERRORS_RETURNED,
        error information can be obtained by calling IMapiSession::GetLastError.
        This function encapsulates the necessary behavior to get this error
        information and dump it to the debugger.  An option to write a 
        warning/error to the system event log is planned.

    Arguments:
        hr - HRESULT containing the error code.

        bLogEvent [optional] - If True, write an event to the system event
            log.  This option is not in place yet.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/16/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
CMapiSession::ReportErrorsReturned(
    HRESULT hr, 
    BOOL bLogEvent // Unused at this time.
    )
{
    if (MAPI_W_ERRORS_RETURNED == hr)
    {
        LPMAPIERROR pMapiErrors = NULL;
        DWORD dwFlags           = 0;
#ifdef UNICODE
        dwFlags |= MAPI_UNICODE;
#endif
        hr = m_pSession->GetLastError(hr, dwFlags, &pMapiErrors);
        if (S_OK == hr)
        {
            if (NULL != pMapiErrors)
            {
                DebugMsg(DM_ERROR, TEXT("MAPI returned errors.\n"));
                DebugMsg(DM_ERROR, TEXT("\tVersion.......: %d"), pMapiErrors->ulVersion);
                DebugMsg(DM_ERROR, TEXT("\tComponent.....: %s"), pMapiErrors->lpszComponent ?
                                                                 pMapiErrors->lpszComponent :
                                                                 TEXT("Not Provided"));
                DebugMsg(DM_ERROR, TEXT("\tError.........: %s"), pMapiErrors->lpszError ?
                                                                 pMapiErrors->lpszError :
                                                                 TEXT("Not Provided"));
                DebugMsg(DM_ERROR, TEXT("\tContext.......: %d"), pMapiErrors->ulContext);
                DebugMsg(DM_ERROR, TEXT("\tLowLevel Error: %d\n"), pMapiErrors->ulLowLevelError);
                if (bLogEvent)
                {
                    //
                    // Open event log and write error?
                    //
                }
                MAPI32.FreeBuffer(pMapiErrors);
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::GetOutBoxFolder

    Description: Returns the session's outbox folder pointer.

    Arguments:
        ppOutBoxFolder - Address of pointer variable to receive pointer value.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiSession::GetOutBoxFolder(
    LPMAPIFOLDER *ppOutBoxFolder
    )
{
    HRESULT hr = E_POINTER;

    if (NULL != m_pOutBoxFolder && NULL != ppOutBoxFolder)
    {
        *ppOutBoxFolder = m_pOutBoxFolder;
        (*ppOutBoxFolder)->AddRef();
        hr = NO_ERROR;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiSession::ResolveAddresses

    Description: Resolves names in an address list.

    Arguments:
        pAdrList - Pointer to the address list to be resolved.

    Returns: 

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiSession::ResolveAddresses(
    LPADRLIST pAdrList
    )
{
    HRESULT hr;
    LPADRBOOK pAdrBook = NULL;

    hr = GetAddressBook(&pAdrBook);
    if (SUCCEEDED(hr))
    {
        hr = pAdrBook->ResolveName(0,          // Hwnd for UI
                                   0,          // Flags (no UI).
                                   NULL,       // Dlg title (none).
                                   pAdrList);  // ADRLIST ptr

        ReportErrorsReturned(hr);
        pAdrBook->Release();
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessageBody::CMapiMessageBody

    Description: Constructors.

    Arguments:
        rhs - Reference to source CMapiMessageBody object in copy ctor.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiMessageBody::CMapiMessageBody(
    VOID
    ) : m_pStg(NULL),
        m_pStm(NULL)
{
    CommonConstruct();
}

CMapiMessageBody::CMapiMessageBody(
    const CMapiMessageBody& rhs
    ) : m_pStg(NULL),
        m_pStm(NULL)
{
    CommonConstruct();
    *this = rhs;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessageBody::~CMapiMessageBody

    Description: Destructor.

    Arguments: None.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiMessageBody::~CMapiMessageBody(
    VOID
    )
{
    if (NULL != m_pStm)
    {
        m_pStm->Release();
    }
    if (NULL != m_pStg)
    {
        m_pStg->Release();
    }
}
    
    
///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessageBody::operator = 

    Description: Assignment operator.

    Arguments:
        rhs - Reference to source CMapiMessageBody object.

    Returns: Reference to *this.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiMessageBody& 
CMapiMessageBody::operator = (
    const CMapiMessageBody& rhs
    )
{
    if (this != &rhs)
    {
        if (NULL != m_pStm && NULL != rhs.m_pStm)
        {
            HRESULT hr;
            LPSTREAM pStmClone;

            //
            // Create a clone of the source stream so that we don't alter
            // the source's seek ptr.
            //
            hr = rhs.m_pStm->Clone(&pStmClone);
            if (SUCCEEDED(hr))
            {
                ULARGE_INTEGER ulSize = {0, 0};
                LARGE_INTEGER lSeek   = {0, 0};
                //
                // Reset the source stream seek ptr to the beginnging.
                //
                pStmClone->Seek(lSeek, STREAM_SEEK_SET, NULL);
                //
                // Truncate the destination stream to clear it.
                //
                m_pStm->SetSize(ulSize);
                //
                // Copy all of the source stream to the dest stream.
                //
                ulSize.LowPart = 0xFFFFFFFF;
                hr = pStmClone->CopyTo(m_pStm,      // Destination stream.
                                       ulSize,      // Write all bytes.
                                       NULL,        // pcbRead
                                       NULL);       // pcbWritten
                pStmClone->Release();
            }
        }
    }
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessageBody::CommonConstruct

    Description: Performs operations common to all forms of constructors.

        1. Creates Storage object.
        2. Creates Stream "MSGBODY" in storage.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiMessageBody::CommonConstruct(
    VOID
    )
{
    HRESULT hr;
    DWORD grfMode = STGM_DIRECT | STGM_READWRITE |
                    STGM_CREATE | STGM_SHARE_EXCLUSIVE;
    //
    // Create the output doc file.
    //
    hr = StgCreateDocfile(NULL,     // Temp file with unique name.
                          grfMode,  // Access flags.
                          0,        // Reserved
                          &m_pStg); // Stg ptr (out)

    if (SUCCEEDED(hr))
    {
        //
        // Create the stream in the doc file.
        //
        hr = m_pStg->CreateStream(L"MSGBODY",  // Stream name.
                                  grfMode,     // Access flags.
                                  0,           // Reserved.
                                  0,           // Reserved.
                                  &m_pStm);    // Stream ptr (out)
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessageBody::Append

    Description: Appends text to the msg body stream.  Two versions are 
        provided.  One accepts a nul-terminated format string while the other
        accepts the resource ID for a string resource.  Both formats allow
        variable replacement arguments for replaceable arguments in the
        format strings (i.e. %1, %2 etc.)

    Arguments:
        hInst - Module instance handle for string/message resource.

        pszFmt - Address of format string.

        idFmt - ID of format resource string.  May be a string or message
            resource.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiMessageBody::Append(
    LPCTSTR pszFmt,
    ...
    )
{
    HRESULT hr;
    va_list args;
    va_start(args, pszFmt);

    hr = Append(pszFmt, &args);

    va_end(args);

    return hr;
}

HRESULT 
CMapiMessageBody::Append(
    LPCTSTR pszFmt,
    va_list *pargs
    )
{
    HRESULT hr = E_POINTER;

    if (NULL != m_pStm)
    {
        CString str;
        if (str.Format(pszFmt, pargs))
        {
            hr = m_pStm->Write((LPCTSTR)str, str.LengthBytes(), NULL);
        }
    }
    return hr;
}

HRESULT
CMapiMessageBody::Append(
    HINSTANCE hInst,
    UINT idFmt,
    ...
    )
{
    HRESULT hr;

    va_list(args);
    va_start(args, idFmt);

    hr = Append(hInst, idFmt, &args);

    va_end(args);
    return hr;
}


HRESULT
CMapiMessageBody::Append(
    HINSTANCE hInst,
    UINT idFmt,
    va_list *pargs
    )
{
    HRESULT hr = E_POINTER;

    if (NULL != m_pStm)
    {
        CString str;
        if (str.Format(hInst, idFmt, pargs))
        {
            hr = m_pStm->Write((LPCTSTR)str, str.LengthBytes(), NULL);
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::CMapiMessage

    Description: Constructors.

    Arguments:
        pFolder - Address of LPMAPIFOLDER object in which the message is
            to be created.  

        body - Reference to a CMapiMessageBody object containing text for the
            body of the message.

        pszSubject [optional] - Address of message subject line string.

    Returns: Nothing.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiMessage::CMapiMessage(
    LPMAPIFOLDER pFolder
    ) : m_pMsg(NULL)
{
    CommonConstruct(pFolder);
}

CMapiMessage::CMapiMessage(
    LPMAPIFOLDER pFolder,
    CMapiMessageBody& body, 
    LPCTSTR pszSubject /* optional */
    ) : m_pMsg(NULL),
        m_body(body)
{
    CommonConstruct(pFolder);
    if (NULL != pszSubject)
    {
        SetSubject(pszSubject);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::~CMapiMessage

    Description: Destructor.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
CMapiMessage::~CMapiMessage(
    VOID
    )
{
    if (NULL != m_pMsg)
    {
        m_pMsg->Release();
    }
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::CommonConstruct

    Description: Performs operations common to all forms of constructors.

        1. Creates the MAPI message object.
        2. Sets the DELETE_AFTER_SUBMIT property (common to all messages).

    Arguments:
        pFolder - Address of LPMAPIFOLDER object in which the message is
            to be created.  

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiMessage::CommonConstruct(
    LPMAPIFOLDER pFolder
    )
{
    HRESULT hr = E_POINTER;

    if (NULL != pFolder)
    {
        hr = pFolder->CreateMessage(NULL, 0, &m_pMsg);
        if (SUCCEEDED(hr))
        {
            //
            // Don't want sent message hanging around in users's outbox.
            //
            SPropValue rgProp[1];
            rgProp[0].ulPropTag  = PR_DELETE_AFTER_SUBMIT;
            rgProp[0].Value.b    = TRUE;

            hr = m_pMsg->SetProps(ARRAYSIZE(rgProp), rgProp, NULL);
        }
    }
    return hr;
}


HRESULT 
CMapiMessage::SetProps(
    ULONG cValues, 
    LPSPropValue lpPropArray, 
    LPSPropProblemArray *lppProblems
    )
{
    HRESULT hr = E_UNEXPECTED;
    if (NULL != m_pMsg)
    {
        hr = m_pMsg->SetProps(cValues, lpPropArray, lppProblems);
    }
    return hr;

}


HRESULT
CMapiMessage::SaveChanges(
    ULONG ulFlags
    )
{
    HRESULT hr = E_UNEXPECTED;
    if (NULL != m_pMsg)
    {
        hr = m_pMsg->SaveChanges(ulFlags);
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::SetSubject

    Description: Sets the PR_SUBJECT property of the message.

    Arguments:
        pszSubject - Address of new subject string.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CMapiMessage::SetSubject(
    LPCTSTR pszSubject
    )
{
    HRESULT hr = E_POINTER;
    if (NULL != m_pMsg)
    {
        //
        // Set the msg subject text property.
        //
        SPropValue spvProp;
        spvProp.ulPropTag  = PR_SUBJECT;
        spvProp.Value.LPSZ = (LPTSTR)pszSubject;

        hr = m_pMsg->SetProps(1, &spvProp, NULL);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::SetRecipients

    Description: Sets the recipients for the message.  It is assumed that
        the recipients in pAdrList have been resolved.

    Arguments:
        pAdrList - Address of MAPI address list containing resolved addresses.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiMessage::SetRecipients(
    LPADRLIST pAdrList
    )
{
    HRESULT hr = E_POINTER;
    if (NULL != m_pMsg)
    {
        hr = m_pMsg->ModifyRecipients(0, pAdrList);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::Send

    Description: Sends the message to a list of recipients.

    Arguments:
        pAdrList [optional] - Address of MAPI address list containing 
            resolved addresses.  If this argument is NULL, the caller must
            call SetRecipients before calling Send.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiMessage::Send(
    LPADRLIST pAdrList /* optional */
    )
{
    HRESULT hr = E_POINTER;
    if (NULL != m_pMsg)
    {
        hr = NO_ERROR;
        if (NULL != pAdrList)
        {
            //
            // If there's an address list, set the recipients.
            // If not, the caller must call SetRecipients before calling Send().
            // Otherwise, there will be no recipients to send it to.
            //
            hr = SetRecipients(pAdrList);
        }
        if (SUCCEEDED(hr))
        {
            LPSTREAM pPropStream;
            hr = m_pMsg->OpenProperty(PR_BODY,
                                      &IID_IStream,
                                      STGM_READWRITE | STGM_DIRECT,
                                      MAPI_CREATE | MAPI_MODIFY,
                                      (LPUNKNOWN *)&pPropStream);
            if (S_OK == hr)
            {
                LPSTREAM pMsgBodyStm = (LPSTREAM)m_body;
                LPSTREAM pMsgBodyStmClone;

                //
                // Clone the body stream so that we don't alter it's seek ptr.
                //
                hr = pMsgBodyStm->Clone(&pMsgBodyStmClone);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER ulSize = {0xFFFFFFFF, 0};
                    LARGE_INTEGER lSeek   = {0, 0};

                    //
                    // Copy the msg body stream to the PR_BODY property.
                    //
                    pMsgBodyStmClone->Seek(lSeek, STREAM_SEEK_SET, NULL);
                    pMsgBodyStmClone->CopyTo(pPropStream, ulSize, NULL, NULL);
                    pPropStream->Commit(STGC_DEFAULT);
                    //
                    // Release temp streams.
                    //
                    pPropStream->Release();
                    pMsgBodyStmClone->Release();
                    //
                    // Send it!
                    // Note:  Calling SaveChanges() is not required if the message
                    //        is being sent immediately.
                    //
                    hr = m_pMsg->SubmitMessage(FORCE_SUBMIT);
                }
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: CMapiMessage::Append

    Description: Appends text to the msg body stream.  Two versions are 
        provided.  One accepts a nul-terminated format string while the other
        accepts the resource ID for a string resource.  Both formats allow
        variable replacement arguments for replaceable arguments in the
        format strings (i.e. %1, %2 etc.)

    Arguments:
        hInst - Module instance handle for string/message resource.

        pszFmt - Address of format string.

        idFmt - ID of format resource string.  May be a string or message
            resource.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
CMapiMessage::Append(
    LPCTSTR pszFmt,
    ...
    )
{
    HRESULT hr;

    va_list args;
    va_start(args, pszFmt);
    hr = m_body.Append(pszFmt, &args);
    va_end(args);

    return hr;
}


HRESULT
CMapiMessage::Append(
    HINSTANCE hInst,
    UINT idFmt,
    ...
    )
{
    HRESULT hr;

    va_list(args);
    va_start(args, idFmt);
    hr = m_body.Append(hInst, idFmt, &args);
    va_end(args);

    return hr;
}



//
// Static members of class MAPI.
//
LONG                 MAPI::m_cLoadCount;
HINSTANCE            MAPI::m_hmodMAPI;
LPMAPIINITIALIZE     MAPI::m_pfnInitialize;
LPMAPILOGONEX        MAPI::m_pfnLogonEx;
LPMAPIUNINITIALIZE   MAPI::m_pfnUninitialize;
LPMAPIALLOCATEBUFFER MAPI::m_pfnAllocateBuffer;
LPMAPIALLOCATEMORE   MAPI::m_pfnAllocateMore;
LPMAPIFREEBUFFER     MAPI::m_pfnFreeBuffer;
LPMAPIHRQUERYALLROWS MAPI::m_pfnHrQueryAllRows;
LPMAPIFREEPADRLIST   MAPI::m_pfnFreePadrlist;             
LPMAPIFREEPROWS      MAPI::m_pfnFreeProws;


///////////////////////////////////////////////////////////////////////////////
/*  Function: MAPI::MAPI

    Description: Constructor.  

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
MAPI::MAPI(
    VOID
    )
{

}


///////////////////////////////////////////////////////////////////////////////
/*  Function: MAPI::~MAPI

    Description: Destructor.  Ensures MAPI32.DLL is unloaded.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
MAPI::~MAPI(
    VOID
    )
{
    //
    // m_cLoadCount should be 0 at this point if calls to Load() and
    // Unload() are balanced.  
    //
    ASSERT(0 == m_cLoadCount);
    if (0 < m_cLoadCount)
    {
        //
        // Calls to Load() and Unload() are not balanced due to programmer 
        // error or maybe an exception preventing a call to Unload().
        // This will force Unload to call FreeLibrary().
        //
        m_cLoadCount = 1;
    }
    Unload();
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: MAPI::Load

    Description: Load MAPI32.DLL and call GetProcAddress for all of the
        MAPI32 functions we're interested in using.  Maintains a reference
        count so redundant calls to LoadLibrary are avoided.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
HRESULT
MAPI::Load(
    VOID
    )
{
    Assert(0 <= m_cLoadCount);
    if (0 == m_cLoadCount++)
    {
        m_hmodMAPI = ::LoadLibrary(TEXT("MAPI32.DLL"));
        if (NULL != m_hmodMAPI)
        {
            m_pfnInitialize     = (LPMAPIINITIALIZE)    ::GetProcAddress(m_hmodMAPI, "MAPIInitialize");
            m_pfnLogonEx        = (LPMAPILOGONEX)       ::GetProcAddress(m_hmodMAPI, "MAPILogonEx");
            m_pfnUninitialize   = (LPMAPIUNINITIALIZE)  ::GetProcAddress(m_hmodMAPI, "MAPIUninitialize");
            m_pfnAllocateBuffer = (LPMAPIALLOCATEBUFFER)::GetProcAddress(m_hmodMAPI, "MAPIAllocateBuffer");
            m_pfnAllocateMore   = (LPMAPIALLOCATEMORE)  ::GetProcAddress(m_hmodMAPI, "MAPIAllocateMore");
            m_pfnFreeBuffer     = (LPMAPIFREEBUFFER)    ::GetProcAddress(m_hmodMAPI, "MAPIFreeBuffer");
            m_pfnHrQueryAllRows = (LPMAPIHRQUERYALLROWS)::GetProcAddress(m_hmodMAPI, "HrQueryAllRows@24");
            m_pfnFreePadrlist   = (LPMAPIFREEPADRLIST)  ::GetProcAddress(m_hmodMAPI, "FreePadrlist@4");
            m_pfnFreeProws      = (LPMAPIFREEPROWS)     ::GetProcAddress(m_hmodMAPI, "FreeProws@4");
        }
    }
    return (NULL != m_hmodMAPI) ? NO_ERROR : E_FAIL;
}


///////////////////////////////////////////////////////////////////////////////
/*  Function: MAPI::Unload

    Description: Unloads MAPI32.DLL if the reference count drops to 0. If
        the library is unloaded, all of the function pointers are
        set to NULL.

    Arguments: None.

    Returns:

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/22/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
VOID
MAPI::Unload(
    VOID
    )
{
    ASSERT(0 < m_cLoadCount);
    if (0 == --m_cLoadCount)
    {
        if (NULL != m_hmodMAPI)
        {
            ::FreeLibrary(m_hmodMAPI);
            m_hmodMAPI = NULL;
        }
        m_pfnInitialize     = NULL;
        m_pfnLogonEx        = NULL;
        m_pfnUninitialize   = NULL;
        m_pfnAllocateBuffer = NULL;
        m_pfnAllocateMore   = NULL;
        m_pfnFreeBuffer     = NULL;
        m_pfnHrQueryAllRows = NULL;
        m_pfnFreePadrlist   = NULL;
        m_pfnFreeProws      = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////
// The remaining MAPI::XXXX functions are merely simple wrappers around the
// corresponding functions in MAPI32.DLL.
// See the MAPI SDK for information concerning their use.
///////////////////////////////////////////////////////////////////////////////

HRESULT 
MAPI::LogonEx(
    ULONG ulUIParam,   
    LPTSTR lpszProfileName,   
    LPTSTR lpszPassword,   
    FLAGS flFlags,   
    LPMAPISESSION FAR * lppSession
    )
{
    ASSERT(NULL != m_pfnLogonEx);
    if (NULL != m_pfnLogonEx)
        return (*m_pfnLogonEx)(ulUIParam, lpszProfileName, lpszPassword, flFlags, lppSession);
    else
        return E_POINTER;
}

HRESULT 
MAPI::Initialize(
    LPVOID lpMapiInit
    )
{
    ASSERT(NULL != m_pfnInitialize);
    if (NULL != m_pfnInitialize)
        return (*m_pfnInitialize)(lpMapiInit);
    else
        return E_POINTER;
}


VOID
MAPI::Uninitialize(
    VOID
    )
{
    ASSERT(NULL != m_pfnUninitialize);
    if (NULL != m_pfnUninitialize)
        (*m_pfnUninitialize)();
}    



SCODE 
MAPI::AllocateBuffer(
    ULONG cbSize,   
    LPVOID FAR * lppBuffer
    )
{
    ASSERT(NULL != m_pfnAllocateBuffer);
    if (NULL != m_pfnAllocateBuffer)
        return (*m_pfnAllocateBuffer)(cbSize, lppBuffer);
    else
        return E_POINTER;
}


SCODE 
MAPI::AllocateMore(
    ULONG cbSize,   
    LPVOID lpObject,   
    LPVOID FAR * lppBuffer
    )
{
    ASSERT(NULL != m_pfnAllocateMore);
    if (NULL != m_pfnAllocateMore)
        return (*m_pfnAllocateMore)(cbSize, lpObject, lppBuffer);
    else
        return E_POINTER;
}


ULONG 
MAPI::FreeBuffer(
    LPVOID lpBuffer
    )
{
    ASSERT(NULL != m_pfnFreeBuffer);
    if (NULL != m_pfnFreeBuffer)
        return (*m_pfnFreeBuffer)(lpBuffer);
    else
        return (ULONG)E_POINTER;
}


HRESULT 
MAPI::HrQueryAllRows(
    LPMAPITABLE lpTable,
    LPSPropTagArray lpPropTags,
    LPSRestriction lpRestriction,
    LPSSortOrderSet lpSortOrderSet,
    LONG crowsMax,
    LPSRowSet FAR *lppRows
    )
{
    ASSERT(NULL != m_pfnHrQueryAllRows);
    if (NULL != m_pfnHrQueryAllRows)
        return (*m_pfnHrQueryAllRows)(lpTable, 
                                      lpPropTags, 
                                      lpRestriction, 
                                      lpSortOrderSet, 
                                      crowsMax, 
                                      lppRows);
    else
        return E_POINTER;
}


VOID 
MAPI::FreePadrlist(
    LPADRLIST lpAdrList
    )
{
    ASSERT(NULL != m_pfnFreePadrlist);
    if (NULL != m_pfnFreePadrlist)
        (*m_pfnFreePadrlist)(lpAdrList);
}


VOID 
MAPI::FreeProws(
    LPSRowSet lpRows
    )
{
    ASSERT(NULL != m_pfnFreeProws);
    if (NULL != m_pfnFreeProws)
        (*m_pfnFreeProws)(lpRows);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\history.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: history.cpp

    Description: To prevent the watchdog from excessive repeate notifications,
        the system administrator can set a minimum period for notification
        silence.  This class (CHistory) manages the reading of this setting
        along with remembering the last time an action occured.  A client
        of the object is able to ask it if a given action should be performed
        on the basis of past actions.
        
            CHistory


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include "history.h"
#include "policy.h"

//
// Defined in dskquowd.cpp
//
extern TCHAR g_szRegSubKeyUser[];
extern TCHAR g_szRegSubKeyAdmin[];

//
// History-related registry parameter value names.
//
const TCHAR CHistory::SZ_REG_LAST_NOTIFY_POPUP_TIME[] = TEXT("LastNotifyPopupTime");
const TCHAR CHistory::SZ_REG_LAST_NOTIFY_EMAIL_TIME[] = TEXT("LastNotifyEmailTime");


CHistory::CHistory(
    CPolicy& policy
    ) : m_policy(policy)
{
    //
    // Build our registry parameter table.  This will create 
    // any keys (using the defaults provided) that don't already exist.
    //
    FILETIME ft = {0, 0};

    m_RegParams.AddBinaryParam(HKEY_CURRENT_USER,
                               g_szRegSubKeyAdmin,
                               SZ_REG_LAST_NOTIFY_POPUP_TIME,
                               (LPBYTE)&ft,
                               sizeof(ft));

    m_RegParams.AddBinaryParam(HKEY_CURRENT_USER,
                               g_szRegSubKeyAdmin,
                               SZ_REG_LAST_NOTIFY_EMAIL_TIME,
                               (LPBYTE)&ft,
                               sizeof(ft));
}



//
// Compare the current time with the last time a popup was displayed
// and the minimum popup period stored in the registry.
// If the elapsed time since the last popup exceeds the minimum period
// value stored in the registry, return TRUE.
//
BOOL
CHistory::ShouldPopupDialog(
    VOID
    )
{
    FILETIME ftLastPopup;
    FILETIME ftNow;
    DWORD    dwMinPeriod = 0;

    GetSysTime(&ftNow);
    
    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_LAST_NOTIFY_POPUP_TIME,
                             (LPBYTE)&ftLastPopup,
                             sizeof(ftLastPopup));


    //
    // Get the minimum popup period from the policy object.
    //
    dwMinPeriod = (DWORD)m_policy.GetMinNotifyPopupDialogPeriod();

    return (INT)dwMinPeriod <= CalcDiffMinutes(ftNow, ftLastPopup);
}


//
// Compare the current time with the last time email was sent
// and the minimum email period stored in the registry.
// If the elapsed time since the last email exceeds the minimum period
// value stored in the registry, return TRUE.
//
BOOL
CHistory::ShouldSendEmail(
    VOID
    )
{
    FILETIME ftLastEmail;
    FILETIME ftNow;
    DWORD    dwMinPeriod = 0;

    GetSysTime(&ftNow);
    
    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_LAST_NOTIFY_EMAIL_TIME,
                             (LPBYTE)&ftLastEmail,
                             sizeof(ftLastEmail));

    //
    // Get the minimum popup period from the policy object.
    //
    dwMinPeriod = (DWORD)m_policy.GetMinNotifyEmailPeriod();

    return (INT)dwMinPeriod <= CalcDiffMinutes(ftNow, ftLastEmail);
}


//
// Should we do ANY notifications based on history information?
//
BOOL 
CHistory::ShouldDoAnyNotifications(
    VOID
    )
{
    return ShouldSendEmail() || 
           ShouldPopupDialog();
}       


//
// Save the current system time in the registry as the "last time"
// a popup was displayed.
//
VOID
CHistory::RecordDialogPoppedUp(
    VOID
    )
{
    FILETIME ftNow;

    GetSysTime(&ftNow);
    
    m_RegParams.SetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_LAST_NOTIFY_POPUP_TIME,
                             (LPBYTE)&ftNow,
                             sizeof(ftNow));
}


//
// Save the current system time in the registry as the "last time"
// an email message was sent.
//
VOID
CHistory::RecordEmailSent(
    VOID
    )
{
    FILETIME ftNow;

    GetSysTime(&ftNow);
    
    m_RegParams.SetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_LAST_NOTIFY_EMAIL_TIME,
                             (LPBYTE)&ftNow,
                             sizeof(ftNow));
}


//
// Get the system time as a FILETIME struct.
//
VOID
CHistory::GetSysTime(
    LPFILETIME pftOut
    )
{
    SYSTEMTIME st;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, pftOut);
}


//
// Calculate the difference between two FILETIME structures and
// return the difference converted to minutes.
//
INT
CHistory::CalcDiffMinutes(
    const FILETIME& ftA,
    const FILETIME& ftB
    )
{
    LARGE_INTEGER liMinA;
    LARGE_INTEGER liMinB;
    LARGE_INTEGER liDiff;

    liMinA.LowPart  = ftA.dwLowDateTime;
    liMinA.HighPart = ftA.dwHighDateTime;

    liMinB.LowPart  = ftB.dwLowDateTime;
    liMinB.HighPart = ftB.dwHighDateTime;
    
    liDiff.QuadPart = liMinA.QuadPart - liMinB.QuadPart;

    return (INT)(liDiff.QuadPart / ((__int64)600000000L));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\mapisend.h ===
#ifndef __MAPISEND_H
#define __MAPISEND_H
///////////////////////////////////////////////////////////////////////////////
/*  File: mapisend.h

    Description: Implements the most basic MAPI email client to send a message
        to one or more recipients.  All operations are done without UI.

        classes:    CMapiSession
                    CMapiMessage
                    CMapiMessageBody
                    CMapiRecipients
                    MAPI

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    06/18/97    Initial creation.                                    BrianAu
    06/22/97    Added class MAPI so clients can dynamically link     BrianAu
                to MAPI32.DLL.
*/
///////////////////////////////////////////////////////////////////////////////
#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef MAPIX_H
#   include <mapix.h>
#endif

#ifndef _MAPIUTIL_H_
#   include <mapiutil.h>
#endif

#ifndef MAPITAGS_H
#   include <mapitags.h>
#endif


//-----------------------------------------------------------------------------
// MAPI
//
// This class allows a MAPI client to dynamically link to MAPI32.DLL instead
// of statically linking to it.  This can help performance in that loading
// MAPI is explicitly controlled.  The following example shows how to use
// the class.
//
// MAPI mapi;
// HRESULT hr;
//
// hr = mapi.Load(); // This calls LoadLibrary on MAPI32.DLL.
// if SUCCEEDED(hr))
// {
//     hr = mapi.Initialize(NULL);
//     if (SUCCEEDED(hr))
//     {
//         LPMAPISESSION pSession;
//         hr = mapi.LogonEx(0,             // Hwnd for any UI.
//                           NULL,          // Profile name.
//                           NULL,          // Password.
//                           dwLogonFlags,  // Flags
//                           &pSession);    // Session obj ptr (out).
//         if (SUCCEEDED(hr))
//         {
//             //
//             // Use MAPI interfaces.
//             //
//         }
//         mapi.Uninitialize();
//     }
//     mapi.Unload();  // This calls FreeLibrary for MAPI32.DLL
// }
//
//
//-----------------------------------------------------------------------------

//
// Function pointer typedefs for some MAPI functions.
// Used for defining function pointers in class MAPI.
//
//
// HrQueryAllRows
//
typedef HRESULT (STDMETHODCALLTYPE MAPIHRQUERYALLROWS)(
            LPMAPITABLE lpTable,
            LPSPropTagArray lpPropTags,
            LPSRestriction lpRestriction,
            LPSSortOrderSet lpSortOrderSet,
            LONG crowsMax,
            LPSRowSet FAR *lppRows);

typedef MAPIHRQUERYALLROWS FAR *LPMAPIHRQUERYALLROWS;
//
// FreePadrlist
//
typedef VOID (STDAPICALLTYPE MAPIFREEPADRLIST)(LPADRLIST lpAdrList);
typedef MAPIFREEPADRLIST FAR *LPMAPIFREEPADRLIST;
//
// FreeProws
//
typedef VOID (STDAPICALLTYPE MAPIFREEPROWS)(LPSRowSet lpRows);
typedef MAPIFREEPROWS FAR *LPMAPIFREEPROWS;


class MAPI
{
    public:
        MAPI(VOID);
        ~MAPI(VOID);

        HRESULT Load(VOID);
        VOID Unload(VOID);

        HRESULT LogonEx(
            ULONG ulUIParam,   
            LPTSTR lpszProfileName,   
            LPTSTR lpszPassword,   
            FLAGS flFlags,   
            LPMAPISESSION FAR * lppSession);

        HRESULT Initialize(
            LPVOID lpMapiInit);

        VOID Uninitialize(VOID);

        SCODE AllocateBuffer(
            ULONG cbSize,   
            LPVOID FAR * lppBuffer);

        SCODE AllocateMore(
            ULONG cbSize,   
            LPVOID lpObject,   
            LPVOID FAR * lppBuffer);

        ULONG FreeBuffer(
            LPVOID lpBuffer);

        HRESULT HrQueryAllRows(
            LPMAPITABLE lpTable,
            LPSPropTagArray lpPropTags,
            LPSRestriction lpRestriction,
            LPSSortOrderSet lpSortOrderSet,
            LONG crowsMax,
            LPSRowSet FAR *lppRows);

        VOID FreePadrlist(LPADRLIST lpAdrlist);

        VOID FreeProws(LPSRowSet lpRows);

    private:
        static LONG                 m_cLoadCount;
        static HINSTANCE            m_hmodMAPI;
        static LPMAPIINITIALIZE     m_pfnInitialize;
        static LPMAPILOGONEX        m_pfnLogonEx;
        static LPMAPIUNINITIALIZE   m_pfnUninitialize;
        static LPMAPIALLOCATEBUFFER m_pfnAllocateBuffer;
        static LPMAPIALLOCATEMORE   m_pfnAllocateMore;
        static LPMAPIFREEBUFFER     m_pfnFreeBuffer;
        static LPMAPIHRQUERYALLROWS m_pfnHrQueryAllRows;
        static LPMAPIFREEPADRLIST   m_pfnFreePadrlist;             
        static LPMAPIFREEPROWS      m_pfnFreeProws;

        //
        // Prevent copy.
        //
        MAPI(const MAPI& rhs);
        MAPI& operator = (const MAPI& rhs);
};



//-----------------------------------------------------------------------------
// CMapiRecipients
//      Hides the grossness of adding entries and properties to a MAPI
//      address list.
//-----------------------------------------------------------------------------
class CMapiRecipients
{
    public:
        CMapiRecipients(BOOL bUnicode = TRUE);
        ~CMapiRecipients(VOID);

        CMapiRecipients(const CMapiRecipients& rhs);
        CMapiRecipients& operator = (const CMapiRecipients& rhs);

        //
        // Does the address list contain unicode names?
        //
        BOOL IsUnicode(VOID)
            { return m_bUnicode; }
        //
        // Add a recipient to the address list.
        //
        HRESULT AddRecipient(LPCTSTR pszEmailName, DWORD dwType);
        //
        // Return a count of entries in the address list.
        //
        INT Count(VOID) const;

        //
        // Make it easy to use a CMapiRecipients object in calls to MAPI
        // functions taking an LPADRLIST.  Do note however that by 
        // giving a MAPI function direct access to the address list,
        // you circumvent the automatic growth function built into this
        // class.  This conversion capability is generally intended for
        // resolving names (which modifies the list but doesn't add entries) 
        // or for read access to the list.
        //
        operator LPADRLIST() const
            { return m_pal; }
            
    private:
        LPADRLIST   m_pal;          // Ptr to actual address list.
        UINT        m_cMaxEntries;  // Size of list (max entries)
        BOOL        m_bUnicode;     // Contains Ansi or Unicode names?
        static UINT m_cGrowIncr;    // How many entries we grow by each time.

        HRESULT Grow(
            UINT cEntries);

        HRESULT CopyAdrListEntry(
            ADRENTRY& Dest,
            ADRENTRY& Src,
            BOOL bConvertStrings);

        HRESULT CopySPropVal(
            LPVOID pvBaseAlloc,
            SPropValue& Dest,
            SPropValue& Src,
            BOOL bConvertStrings);

        HRESULT CopyVarLengthSPropVal(
            LPVOID pvBaseAlloc,
            LPVOID *ppvDest,
            LPVOID pvSrc,
            INT cb);

        HRESULT CopySPropValString(
            LPVOID pvBaseAlloc,
            LPSTR *ppszDestA,
            LPCWSTR pszSrcW);

        HRESULT CopySPropValString(
            LPVOID pvBaseAlloc,
            LPWSTR *ppszDestW,
            LPCSTR pszSrcA);
};


//-----------------------------------------------------------------------------
// CMapiMessageBody
//      Encapsulates the addition of text into a MAPI message body.
//      Maintains body text in an OLE stream so that we can easily append
//      text as needed.   Provides formatted text input through Append().
//-----------------------------------------------------------------------------
class CMapiMessageBody
{
    public:
        CMapiMessageBody(VOID);
        ~CMapiMessageBody(VOID);

        CMapiMessageBody(const CMapiMessageBody& rhs);
        CMapiMessageBody& operator = (const CMapiMessageBody& rhs);

        //
        // Append text to the stream.
        //
        HRESULT Append(LPCTSTR pszFmt, ...);
        HRESULT Append(HINSTANCE hInst, UINT idFmt, ...);
        HRESULT Append(LPCTSTR pszFmt, va_list *pargs);
        HRESULT Append(HINSTANCE hInst, UINT idFmt, va_list *pargs);

        BOOL IsValid(VOID)
            { return NULL != m_pStg && NULL != m_pStm; }

        operator LPSTREAM()
            { return m_pStm; }

        operator LPSTORAGE()
            { return m_pStg; }

    private:
        LPSTORAGE m_pStg;
        LPSTREAM  m_pStm;

        HRESULT CommonConstruct(VOID);
};


//-----------------------------------------------------------------------------
// CMapiMessage
//-----------------------------------------------------------------------------
class CMapiMessage
{
    public:
        CMapiMessage(LPMAPIFOLDER pFolder);
        CMapiMessage(LPMAPIFOLDER pFolder, CMapiMessageBody& body, LPCTSTR pszSubject = NULL);
        ~CMapiMessage(VOID);

        //
        // Set the message's subject line.
        //
        HRESULT SetSubject(LPCTSTR pszSubject);
        //
        // Append a line of text to the message body.
        //
        HRESULT Append(LPCTSTR pszFmt, ...);
        HRESULT Append(HINSTANCE hInst, UINT idFmt, ...);
        //
        // Set the message's recipient list.
        //
        HRESULT SetRecipients(LPADRLIST pAdrList);
        //
        // Set props on a message.
        //
        HRESULT SetProps(ULONG cValues, 
                         LPSPropValue lpPropArray, 
                         LPSPropProblemArray *lppProblems);
        //
        // Save property changes.
        //
        HRESULT SaveChanges(ULONG ulFlags);
        //
        // Send the message.
        // Assumes address list is completely resolved.
        //
        HRESULT Send(LPADRLIST pAdrList = NULL);
        
    private:
        LPMESSAGE        m_pMsg;
        CMapiMessageBody m_body;

        HRESULT CommonConstruct(LPMAPIFOLDER pFolder);

        //
        // Prevent copy.
        //
        CMapiMessage(const CMapiMessage& rhs);
        CMapiMessage& operator = (const CMapiMessage& rhs);
};


//-----------------------------------------------------------------------------
// CMapiSession
//      Encapsulates a basic MAPI session for sending very simple text 
//      messages.
//-----------------------------------------------------------------------------
class CMapiSession
{
    public:
        CMapiSession(VOID);
        ~CMapiSession(VOID);

        //
        // Log on to MAPI, open the default store and open the outbox.
        // If this succeeds, you're ready to send messages.  The dtor
        // will close everything down.
        //
        HRESULT Initialize(VOID);
        //
        // Send a message to a list of recipients.
        //
        HRESULT Send(LPADRLIST pAdrList, LPCTSTR pszSubject, LPCTSTR pszMsg);
        HRESULT Send(LPADRLIST pAdrList, LPCTSTR pszSubject, CMapiMessageBody& body);
        HRESULT Send(LPADRLIST pAdrList, CMapiMessage& msg);
        //
        // Get pointer to the address book.
        //
        HRESULT GetAddressBook(LPADRBOOK *ppAdrBook);
        //
        // Get pointer to outbox folder.
        //
        HRESULT GetOutBoxFolder(LPMAPIFOLDER *ppOutBoxFolder);
        //
        // Resolve a list of adresses.
        //
        HRESULT ResolveAddresses(LPADRLIST pAdrList);
        //
        // Get name of current session user.
        //
        HRESULT GetSessionUser(LPSPropValue *ppProps, ULONG *pcbProps);
        //
        // Report MAPI errors returned by some MAPI API calls.
        // The error information is returned in a MAPIERROR
        // structure.
        //
        VOID ReportErrorsReturned(HRESULT hr, BOOL bLogEvent = FALSE);


    private:
        LPMAPISESSION m_pSession;           // Ptr to MAPI session object.
        LPMDB         m_pDefMsgStore;       // Ptr to MAPI default msg store obj.
        LPMAPIFOLDER  m_pOutBoxFolder;      // Ptr to MAPI outbox folder object.
        BOOL          m_bMapiInitialized;   // Has MAPI been initialized?

        HRESULT OpenDefMsgStore(VOID);
        HRESULT OpenOutBoxFolder(VOID);

        //
        // Prevent copy.
        //
        CMapiSession(const CMapiSession& rhs);
        CMapiSession& operator = (const CMapiSession& rhs);
};



#endif //__MAPISEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\policy.cpp ===
#include <precomp.hxx>
#pragma hdrstop
///////////////////////////////////////////////////////////////////////////////
/*  File: policy.cpp

    Description: A system administrator is able to specify control parameters
        for the watchdog.  These include:
        
            Show popup dialog to user (yes/no)
            Send user email message (yes/no)
            Minimum period between popup dialogs (minutes)
            Minimum period between email messages (minutes)
            Add users to "To:" email list <email address list>
            Add users to "Cc:" email list <email address list>
            Add users to "Bcc:" email list <email address list>

        A client of the object is able to ask it if a given action should be
        performed (dialog, email) and for the additional email names.
        
            CPolicy

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
    07/10/97    Store info in HKEY_CURRENT_USER instead of           BrianAu
                policy.ini.
*/
///////////////////////////////////////////////////////////////////////////////

#include "policy.h"

//
// Defined in dskquowd.cpp
//
extern TCHAR g_szRegSubKeyUser[];
extern TCHAR g_szRegSubKeyAdmin[];

//
// Names of registry file sections and values.
//
const TCHAR CPolicy::SZ_REG_SHOW_USER_POPUP[]  = TEXT("ShowUserPopup");
const TCHAR CPolicy::SZ_REG_MIN_PERIOD_POPUP[] = TEXT("MinNotifyMinutesPopup");
const TCHAR CPolicy::SZ_REG_MIN_PERIOD_EMAIL[] = TEXT("MinNotifyMinutesEmail");
const TCHAR CPolicy::SZ_REG_SEND_USER_EMAIL[]  = TEXT("SendUserEmail");
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_TO[]    = TEXT("SendEmailTo");
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_CC[]    = TEXT("SendEmailCc");
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_BCC[]   = TEXT("SendEmailBcc");

//
// Default values written to empty registry key.
//
const INT   CPolicy::I_REG_SEND_USER_EMAIL_DEFAULT   = 1;
const INT   CPolicy::I_REG_SHOW_USER_POPUP_DEFAULT   = 1;
const INT   CPolicy::I_REG_MIN_PERIOD_POPUP_DEFAULT  = 240;
const INT   CPolicy::I_REG_MIN_PERIOD_EMAIL_DEFAULT  = 240;
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_TO_DEFAULT[]  = TEXT("");
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_CC_DEFAULT[]  = TEXT("");
const TCHAR CPolicy::SZ_REG_SEND_EMAIL_BCC_DEFAULT[] = TEXT("");



CPolicy::CPolicy(
    VOID
    ) : m_bSendUserEmail(FALSE),
        m_bPopupDialog(FALSE),
        m_iMinPeriodPopupDialog(I_REG_MIN_PERIOD_POPUP_DEFAULT),
        m_iMinPeriodEmail(I_REG_MIN_PERIOD_EMAIL_DEFAULT)
{
    //
    // Create the registry param table entries we'll be using.
    // These statements also specify the default values to use as well
    // as allowable limits (for DWORD values).
    //
    m_RegParams.AddDWordParam(HKEY_CURRENT_USER,
                              g_szRegSubKeyAdmin,
                              SZ_REG_SEND_USER_EMAIL,
                              0,
                              1,
                              I_REG_SEND_USER_EMAIL_DEFAULT);

    m_RegParams.AddDWordParam(HKEY_CURRENT_USER,
                              g_szRegSubKeyAdmin,
                              SZ_REG_SHOW_USER_POPUP,
                              0,
                              1,
                              I_REG_SHOW_USER_POPUP_DEFAULT);

    m_RegParams.AddDWordParam(HKEY_CURRENT_USER,
                              g_szRegSubKeyAdmin,
                              SZ_REG_MIN_PERIOD_POPUP,
                              0,
                              0xFFFFFFFF,
                              I_REG_MIN_PERIOD_POPUP_DEFAULT);

    m_RegParams.AddDWordParam(HKEY_CURRENT_USER,
                              g_szRegSubKeyAdmin,
                              SZ_REG_MIN_PERIOD_EMAIL,
                              0,
                              0xFFFFFFFF,
                              I_REG_MIN_PERIOD_EMAIL_DEFAULT);

    m_RegParams.AddSzParam(HKEY_CURRENT_USER,
                           g_szRegSubKeyAdmin,
                           SZ_REG_SEND_EMAIL_TO,
                           SZ_REG_SEND_EMAIL_TO_DEFAULT);

    m_RegParams.AddSzParam(HKEY_CURRENT_USER,
                           g_szRegSubKeyAdmin,
                           SZ_REG_SEND_EMAIL_CC,
                           SZ_REG_SEND_EMAIL_CC_DEFAULT);

    m_RegParams.AddSzParam(HKEY_CURRENT_USER,
                           g_szRegSubKeyAdmin,
                           SZ_REG_SEND_EMAIL_BCC,
                           SZ_REG_SEND_EMAIL_BCC_DEFAULT);

    //
    // Now retrieve our parameters from the registry.
    // If the parameters don't exist, they'll be created.
    //
    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_SEND_EMAIL_TO,
                             m_strOtherEmailTo.GetBuffer(MAX_PATH),
                             MAX_PATH);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_SEND_EMAIL_CC,
                             m_strOtherEmailCc.GetBuffer(MAX_PATH),
                             MAX_PATH);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_SEND_EMAIL_BCC,
                             m_strOtherEmailBcc.GetBuffer(MAX_PATH),
                             MAX_PATH);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_SHOW_USER_POPUP,
                             (LPDWORD)&m_bPopupDialog);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_SEND_USER_EMAIL,
                             (LPDWORD)&m_bSendUserEmail);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_MIN_PERIOD_POPUP,
                             (LPDWORD)&m_iMinPeriodPopupDialog);

    m_RegParams.GetParameter(HKEY_CURRENT_USER,
                             g_szRegSubKeyAdmin,
                             SZ_REG_MIN_PERIOD_EMAIL,
                             (LPDWORD)&m_iMinPeriodEmail);
}




CPolicy::~CPolicy(
    VOID
    )
{
    //
    // Nothing to do.
    //
}


//
// Should we send any email?
//
BOOL 
CPolicy::ShouldSendEmail(
    VOID
    ) const
{
    return ShouldSendUserEmail()           ||
           0 != m_strOtherEmailTo.Length() ||
           0 != m_strOtherEmailCc.Length() ||
           0 != m_strOtherEmailBcc.Length();
}

//
// Should we do any notifications (popup or email) ?
//
BOOL 
CPolicy::ShouldDoAnyNotifications(
    VOID
    ) const
{
    return ShouldSendEmail() ||
           ShouldPopupDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\profile.cpp ===
#include <precomp.hxx>
#pragma hdrstop

#include "policy.h"

//
// Names of registry/INI file sections and values.
//
TCHAR CPolicy::SZ_REGINI_WATCHDOG[]              = TEXT("DiskQuotaWatchDog");
TCHAR CPolicy::SZ_REGINI_SHOW_CLIENT_DIALOG[]    = TEXT("ShowClientDialog");
TCHAR CPolicy::SZ_REGINI_SEND_USER_EMAIL[]       = TEXT("SendUserEmail");
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_TO[]         = TEXT("SendEmailTo");
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_CC[]         = TEXT("SendEmailCc");
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_BCC[]        = TEXT("SendEmailBcc");


BOOL  CPolicy::I_REGINI_SEND_USER_EMAIL_DEFAULT     = 1;
BOOL  CPolicy::I_REGINI_SHOW_CLIENT_DIALOG_DEFAULT  = 0;
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_TO_DEFAULT[]    = TEXT("brianau@microsoft.com");
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_CC_DEFAULT[]    = TEXT("");
TCHAR CPolicy::SZ_REGINI_SEND_EMAIL_BCC_DEFAULT[]   = TEXT("");


CPolicy::CPolicy(
    VOID
    ) : m_bSendUserEmail(FALSE),
        m_bShowClientDialog(FALSE)
{

}


CPolicy::~CPolicy(
    VOID
    )
{
    //
    // Nothing to do.
    //
}


VOID 
CPolicy::Reset(
    VOID
    )
{
    m_bSendUserEmail    = FALSE;
    m_bShowClientDialog = FALSE;

    m_strOtherEmailTo.Empty();
    m_strOtherEmailCc.Empty();
    m_strOtherEmailBcc.Empty();
}


HRESULT 
CPolicy::Load(
    LPCTSTR pszIniFile
    )
{
    //
    // Clear out previous policy contents.
    //
    Reset();

    //
    // Load the contents of the INI file using appropriate defaults
    // if any values are not found.
    //
    LoadString(pszIniFile,
               SZ_REGINI_WATCHDOG,
               SZ_REGINI_SEND_EMAIL_TO,
               SZ_REGINI_SEND_EMAIL_TO_DEFAULT,
               m_strOtherEmailTo);

    LoadString(pszIniFile,
               SZ_REGINI_WATCHDOG,
               SZ_REGINI_SEND_EMAIL_CC,
               SZ_REGINI_SEND_EMAIL_CC_DEFAULT,
               m_strOtherEmailCc);

    LoadString(pszIniFile,
               SZ_REGINI_WATCHDOG,
               SZ_REGINI_SEND_EMAIL_BCC,
               SZ_REGINI_SEND_EMAIL_BCC_DEFAULT,
               m_strOtherEmailBcc);

    m_bShowClientDialog = GetPrivateProfileInt(SZ_REGINI_WATCHDOG,
                                               SZ_REGINI_SHOW_CLIENT_DIALOG,
                                               I_REGINI_SHOW_CLIENT_DIALOG_DEFAULT,
                                               pszIniFile);

    m_bSendUserEmail = GetPrivateProfileInt(SZ_REGINI_WATCHDOG,
                                            SZ_REGINI_SEND_USER_EMAIL,
                                            I_REGINI_SEND_USER_EMAIL_DEFAULT,
                                            pszIniFile);
    return NO_ERROR;
}

//
// Loads policy string.  Handles proper sizing of the value buffer.
// Caller is responsible for calling delete[] on *ppsz.
//
HRESULT
CPolicy::LoadString(
    LPCTSTR pszFile,
    LPCTSTR pszSection,
    LPCTSTR pszValueName,
    LPCTSTR pszDefaultValue,
    CString& strOut
    )
{
    HRESULT hr      = E_OUTOFMEMORY;
    INT cchIncr     = MAX_PATH;
    INT cchValue    = 0;
    INT cchRead     = 0;

    do
    {
        cchValue += cchIncr;
        cchRead = GetPrivateProfileString(pszSection,
                                          pszValueName,
                                          pszDefaultValue,
                                          strOut.GetBuffer(cchValue),
                                          cchValue,
                                          pszFile);
        if (0 == cchRead)
        {
            hr = E_FAIL;
        }
    }
    while(SUCCEEDED(hr) && cchRead == (cchValue - 1));

    return hr;
}        



HRESULT 
CPolicy::Load(
    HKEY hkeyReg
    )
{
    HRESULT hr = NO_ERROR;
    //
    // Clear out previous policy contents.
    //
    Reset();

    return hr;
}


//
// Should we send any email?
//
BOOL 
CPolicy::ShouldSendAnyEmail(
    VOID
    ) const
{
    return ShouldSendUserEmail()           ||
           0 != m_strOtherEmailTo.Length() ||
           0 != m_strOtherEmailCc.Length() ||
           0 != m_strOtherEmailBcc.Length();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dskquowd.rc
//
#define IDS_EMAIL_VOLUME                1
#define IDS_EMAIL_WARNING               2
#define IDS_EMAIL_LIMIT                 3
#define IDS_EMAIL_USED                  4
#define IDS_EMAIL_FMT_VOLUME            5
#define IDS_EMAIL_FMT_WARNING           6
#define IDS_EMAIL_FMT_LIMIT             7
#define IDS_EMAIL_FMT_USED              8
#define IDS_EMAIL_SUBJECT_LINE          9
#define IDS_EMAIL_HEADER                10
#define IDS_EMAIL_DENY_AT_LIMIT         14
#define IDS_EMAIL_FROM_NAME             15
#define IDS_LVHDR_VOLUME                16
#define IDS_LVHDR_WARNING               17
#define IDS_LVHDR_LIMIT                 18
#define IDS_LVHDR_USED                  19
#define IDS_LVFMT_USED                  20
#define IDS_POPUP_HEADER                21
#define IDI_QUOTA                       50
#define IDD_QUOTA_POPUP                 101
#define IDC_LIST_POPUP                  1002
#define IDC_TXT_POPUP_HEADER            1003
#define IDC_ICON_QUOTA                  1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\profile.h ===
#ifndef __POLICY_H
#define __POLICY_H

#ifndef _WINDOWS_
#   include <windows.h>
#endif

//
// This class provides an in-memory copy of the notification policy 
// information contained in an INI file or the registry.
//
class CPolicy
{
    public:
        CPolicy(VOID);
        ~CPolicy(VOID);

        HRESULT Load(LPCTSTR pszIniFile);
        HRESULT Load(HKEY hkeyReg);

        VOID GetOtherEmailTo(CString& strOut)
            { strOut = m_strOtherEmailTo; }

        LPTSTR GetOtherEmailTo(VOID)
            { return (LPTSTR)m_strOtherEmailTo; }

        VOID GetOtherEmailCc(CString& strOut)
            { strOut = m_strOtherEmailCc; }

        LPTSTR GetOtherEmailCc(VOID)
            { return (LPTSTR)m_strOtherEmailCc; }

        VOID GetOtherEmailBcc(CString& strOut)
            { strOut = m_strOtherEmailBcc; }

        LPTSTR GetOtherEmailBcc(VOID)
            { return (LPTSTR)m_strOtherEmailBcc; }

        BOOL ShouldSendUserEmail(VOID) const
            { return m_bSendUserEmail; }

        BOOL ShouldShowClientDialog(VOID) const
            { return m_bShowClientDialog; }

        BOOL ShouldSendAnyEmail(VOID) const;

    private:
        BOOL    m_bSendUserEmail;        // Should we send user email?
        BOOL    m_bShowClientDialog;     // Should we popup a dialog on client?
        CString m_strOtherEmailTo;       // Comma-sep list of email names.
        CString m_strOtherEmailCc;       // Comma-sep list of email names.
        CString m_strOtherEmailBcc;      // Comma-sep list of email names.

        VOID Reset(VOID);

        HRESULT LoadString(
            LPCTSTR pszFile,
            LPCTSTR pszSection,
            LPCTSTR pszValueName,
            LPCTSTR pszDefaultValue,
            CString& strOut);

        //
        // Prevent copy.
        //
        CPolicy(const CPolicy& rhs);
        CPolicy& operator = (const CPolicy& rhs);

        //
        // Names of registry/INI file sections and values.
        //
        static TCHAR SZ_REGINI_WATCHDOG[];
        static TCHAR SZ_REGINI_SEND_USER_EMAIL[];
        static TCHAR SZ_REGINI_SHOW_CLIENT_DIALOG[];
        static TCHAR SZ_REGINI_SEND_EMAIL_TO[];
        static TCHAR SZ_REGINI_SEND_EMAIL_CC[];
        static TCHAR SZ_REGINI_SEND_EMAIL_BCC[];

        static INT   I_REGINI_SEND_USER_EMAIL_DEFAULT;
        static INT   I_REGINI_SHOW_CLIENT_DIALOG_DEFAULT;
        static TCHAR SZ_REGINI_SEND_EMAIL_TO_DEFAULT[];
        static TCHAR SZ_REGINI_SEND_EMAIL_CC_DEFAULT[];
        static TCHAR SZ_REGINI_SEND_EMAIL_BCC_DEFAULT[];
};

#endif //__POLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\stats.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: stats.cpp

    Description: These classes provide temporary storage of quota
        information for a given volume/user pair.  Creation of the object
        automatically gathers the necessary quota and user information.  
        Clients then query the objects to retrieve quota statistics when
        desired.

            CStatistics
            CStatisticsList
                                                            +----------+
                                                       +--->| CVolume  |
                                                       |    +----------+
            +-----------------+     +-------------+<---+
            | CStatisticsList |<-->>| CStatistics | contains
            +-----------------+     +-------------+<---+
                                                       |    +-------------+
                                                       +--->| CVolumeUser |
                                                            +-------------+

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include "dskquota.h"
#include "stats.h"

//
// Gather quota statistics for a given volume-user pair.
//
CStatistics::CStatistics(
    TCHAR chVolLetter,
    LPCTSTR pszVolDisplayName,
    LPBYTE pUserSid
    ) : m_vol(chVolLetter, pszVolDisplayName),
        m_bQuotaEnabled(FALSE),
        m_bWarnAtThreshold(FALSE),
        m_bDenyAtLimit(FALSE),
        m_bValid(FALSE)
{
    //
    // If the volume doesn't support quotas, no use in continuing
    // with the expensive stuff.
    //
    if (m_vol.SupportsQuotas())
    {
        HRESULT hr;

        hr = OleInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            //
            // Load dskquota.dll, creating a new disk quota controller object.
            //
            IDiskQuotaControl *pQC;
            hr = CoCreateInstance(CLSID_DiskQuotaControl,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDiskQuotaControl,
                                  (LPVOID *)&pQC);

            if (SUCCEEDED(hr))
            {
                //
                // Initialize the quota controller for this volume.
                // We need only read access.
                //
                TCHAR szVolume[] = TEXT("X:\\");
                szVolume[0] = m_vol.GetLetter();

                hr = IDiskQuotaControl_Initialize(pQC, szVolume, GENERIC_READ);
                if (SUCCEEDED(hr))
                {
                    DWORD dwQuotaState    = 0;
                    DWORD dwQuotaLogFlags = 0;

                    //
                    // Get the volume's quota state flags.
                    //
                    hr = pQC->GetQuotaState(&dwQuotaState);
                    if (SUCCEEDED(hr))
                    {
                        m_bQuotaEnabled = !DISKQUOTA_IS_DISABLED(dwQuotaState);
                        m_bDenyAtLimit  = DISKQUOTA_IS_ENFORCED(dwQuotaState);
                    }
                    //
                    // Get the volume's quota logging flags.
                    //
                    hr = pQC->GetQuotaLogFlags(&dwQuotaLogFlags);
                    if (SUCCEEDED(hr))
                    {
                        m_bWarnAtThreshold = m_bQuotaEnabled &&
                                             DISKQUOTA_IS_LOGGED_USER_THRESHOLD(dwQuotaLogFlags);
                    }

                    //
                    // Get the quota user object for the current user.
                    //
                    oleauto_ptr<IDiskQuotaUser> ptrUser;

                    hr = pQC->FindUserSid(pUserSid,
                                          ptrUser._getoutptr(),
                                          DISKQUOTA_USERNAME_RESOLVE_SYNC);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get the user's account and friendly names.
                        //
                        TCHAR szUserName[MAX_PATH]      = { TEXT('\0') };
                        TCHAR szUserDomain[MAX_PATH]    = { TEXT('\0') };
                        TCHAR szUserAccount[MAX_PATH]   = { TEXT('\0') };
                        TCHAR szUserEmailName[MAX_PATH] = { TEXT('\0') };

                        IDiskQuotaUser_GetName(ptrUser, 
                                               szUserDomain, ARRAYSIZE(szUserDomain), 
                                               szUserAccount, ARRAYSIZE(szUserAccount),
                                               szUserName, ARRAYSIZE(szUserName));

                        //
                        // Get the user's quota statistics for the volume.
                        //
                        DISKQUOTA_USER_INFORMATION dui;

                        hr = ptrUser->GetQuotaInformation((LPBYTE)&dui, sizeof(dui));
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Make sure we didn't enumerate a non-existant user.
                            // This is because of the way NTFS enumerates quota records.
                            // Even if there is no record currently in the quota file,
                            // enumeration returns a record.  This is consistent with 
                            // automatic addition of users upon first write to the
                            // volume.  We must check the quota information to
                            // determine if it's an active user.
                            //
                            if (((__int64)-2) != dui.QuotaLimit.QuadPart &&
                                (0 != dui.QuotaLimit.QuadPart ||
                                 0 != dui.QuotaThreshold.QuadPart ||
                                 0 != dui.QuotaUsed.QuadPart))
                            {
                                //
                                // Store user-specific info.
                                //
                                CString strUserDisplayName;
                                if (TEXT('\0') != szUserName[0])
                                {
                                    //
                                    // User has a "friendly" name associated
                                    // with their account.  Include it in the display
                                    // name.
                                    //
                                    strUserDisplayName.Format(TEXT("%1\\%2 (%3)"),
                                                              szUserDomain,
                                                              szUserAccount,
                                                              szUserName);
                                }
                                else
                                {
                                    //
                                    // No "friendly" name associated with user account.
                                    //
                                    strUserDisplayName.Format(TEXT("%1\\%2"),
                                                              szUserDomain,
                                                              szUserAccount,
                                                              szUserName);
                                }
                                //
                                // Store the user's information in the volume-user object.
                                //
                                hr = m_volUser.SetUserInfo(strUserDisplayName, 
                                                           szUserEmailName,
                                                           dui.QuotaThreshold,
                                                           dui.QuotaLimit,
                                                           dui.QuotaUsed);
                                if (FAILED(hr))
                                {
                                    DebugMsg(DM_ERROR, 
                                             TEXT("Error 0x%08X setting user info on volume \"%s\"."), 
                                             hr, pszVolDisplayName);
                                }
                                m_bValid = SUCCEEDED(hr);
                            }
                        }
                        else
                        {
                            DebugMsg(DM_ERROR, 
                                     TEXT("Error 0x%08X getting user quota info on volume \"%s\"."), 
                                     hr, pszVolDisplayName);
                        }
                    }
                    else
                    {
                        DebugMsg(DM_ERROR, 
                                 TEXT("Error 0x%08X finding quota user on volume \"%s\"."), 
                                 hr, pszVolDisplayName);
                    }
                }
                else
                {
                    DebugMsg(DM_ERROR, 
                             TEXT("Error 0x%08X initializing QC for volume \"%s\"."), 
                             hr, pszVolDisplayName);
                }
                pQC->ShutdownAndRelease(TRUE);
            } // if SUCCEEDED(CoCreateInstance())
            else
                DebugMsg(DM_ERROR, TEXT("Failed CoCreateInstance.  0x%08X"), hr);

            OleUninitialize();
        } // if SUCCEEDED(OleInitialize())
        else
            DebugMsg(DM_ERROR, TEXT("Failed OleInitialize.  0x%08X"), hr);
    } // if m_vol.SupportsQuotas()
    else
        DebugMsg(DM_ERROR, TEXT("Volume \"%s\" doesn't support quotas."), pszVolDisplayName);
}

//
// Determine if a specific statistics object contains statistics that
// will generate either an email notification or a popup notification.
//
BOOL 
CStatistics::IncludeInReport(
    VOID
    ) const
{
    BOOL bReport = FALSE;

    //
    // First check data validity and volume settings.
    //
    if (IsValid() &&        // Does volume support quotas and was vol opened?
        QuotasEnabled() &&  // Are quotas enabled on the volume?
        WarnAtThreshold())  // Is the "warn at threshold" bit set on the vol?
    {
        //
        // Now see if user's quota usage warrants reporting.
        // Report if AmtUsed > Threshold.
        //
        if (GetUserQuotaUsed().QuadPart > GetUserQuotaThreshold().QuadPart)
        {
            bReport = TRUE;
        }
    }
    return bReport;
}



CStatisticsList::CStatisticsList(
    VOID
    )
{
    //
    // Nothing to do.
    //
}

CStatisticsList::~CStatisticsList(
    VOID
    )
{
    INT cEntries = m_List.Count();
    for (INT i = 0; i < cEntries; i++)
    {
        delete m_List[i];
    }
    m_List.Clear();
}


const CStatistics *
CStatisticsList::GetEntry(
    INT iEntry
    )
{
    return m_List[iEntry];
}


HRESULT 
CStatisticsList::AddEntry(
    TCHAR chVolLetter,
    LPCTSTR pszVolDisplayName,
    LPBYTE pUserSid
    )
{
    HRESULT hr = E_OUTOFMEMORY;

    CStatistics *pStats = NULL;

    //
    // Create a new statistics object.
    // The ctor will fill in the volume and user information.
    //
    pStats = new CStatistics(chVolLetter, 
                             pszVolDisplayName, 
                             pUserSid);
    if (NULL != pStats)
    {
        if (pStats->IsValid())
        {
            BOOL bDuplicate = FALSE;

            //
            // Look for a duplicate.  Shouldn't be one but just to make sure.
            //
            INT cEntries = m_List.Count();

            for (INT i = 0; i < cEntries; i++)
            {
                const CStatistics *pEntry = m_List[i];

                if (pStats->SameVolume(*pEntry))
                    bDuplicate = TRUE;
            }
            if (!bDuplicate)
            {
                hr = S_OK;
                try
                {
                    m_List.Append(pStats);
                }
                catch(OutOfMemory)
                {
                    DebugMsg(DM_ERROR, TEXT("CStatisticsList::AddEntry - Insufficient memory."));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                //
                // FEATURE:  We should really assert here.
                //
                DebugMsg(DM_ERROR, TEXT("CStatisticsList::AddEntry - Duplicate entry found."));
                hr = S_FALSE;
            }
        }
        else
        {
            //
            // Stats object is invalid.  Probably because the volume
            // doesn't support quotas.
            //
            DebugMsg(DM_ERROR, TEXT("CStatisticsList::AddEntry - Volume stats not valid."));
            hr = S_FALSE;
        }
    }
    if (S_OK != hr)
    {
        //
        // CStatistics object wasn't added to the list.
        // Probably was a duplicate (shouldn't happen) or the volume
        // didn't support quotas.
        //
        delete pStats;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\policy.h ===
#ifndef __POLICY_H
#define __POLICY_H
///////////////////////////////////////////////////////////////////////////////
/*  File: policy.h

    Description: A system administrator is able to specify control parameters
        for the watchdog.  These include:
        
            Show popup dialog to user (yes/no)
            Send user email message (yes/no)
            Minimum period between popup dialogs (minutes)
            Minimum period between email messages (minutes)
            Add users to "To:" email list <email address list>
            Add users to "Cc:" email list <email address list>
            Add users to "Bcc:" email list <email address list>

        A client of the object is able to ask it if a given action should be
        performed (dialog, email) and for the additional email names.
        
            CPolicy

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
    07/10/97    Store info in HKEY_CURRENT_USER instead of           BrianAu
                policy.ini.
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef __DSKQUOTA_REG_PARAMS_H
#   include "regparam.h"
#endif


//
// This class provides an in-memory copy of the notification policy 
// information contained in an INI file or the registry.
//
class CPolicy
{
    public:
        CPolicy(VOID);
        ~CPolicy(VOID);

        VOID GetOtherEmailTo(CString& strOut)
            { strOut = m_strOtherEmailTo; }

        LPTSTR GetOtherEmailTo(VOID)
            { return (LPTSTR)m_strOtherEmailTo; }

        VOID GetOtherEmailCc(CString& strOut)
            { strOut = m_strOtherEmailCc; }

        LPTSTR GetOtherEmailCc(VOID)
            { return (LPTSTR)m_strOtherEmailCc; }

        VOID GetOtherEmailBcc(CString& strOut)
            { strOut = m_strOtherEmailBcc; }

        LPTSTR GetOtherEmailBcc(VOID)
            { return (LPTSTR)m_strOtherEmailBcc; }

        INT GetMinNotifyPopupDialogPeriod(VOID)
            { return m_iMinPeriodPopupDialog; }

        INT GetMinNotifyEmailPeriod(VOID)
            { return m_iMinPeriodEmail; }

        BOOL ShouldSendUserEmail(VOID) const
            { return m_bSendUserEmail; }

        BOOL ShouldPopupDialog(VOID) const
            { return m_bPopupDialog; }

        BOOL ShouldSendEmail(VOID) const;

        BOOL ShouldDoAnyNotifications(VOID) const;

    private:
        RegParamTable m_RegParams;       // Registry parameter table.
        BOOL    m_bSendUserEmail;        // Should we send user email?
        BOOL    m_bPopupDialog;          // Should we popup a dialog on client?
        INT     m_iMinPeriodPopupDialog; // Minimum minutes between popup dialogs.
        INT     m_iMinPeriodEmail;       // Minimum minutes between email messages.
        CString m_strOtherEmailTo;       // Comma-sep list of email names.
        CString m_strOtherEmailCc;       // Comma-sep list of email names.
        CString m_strOtherEmailBcc;      // Comma-sep list of email names.

        //
        // Prevent copy.
        //
        CPolicy(const CPolicy& rhs);
        CPolicy& operator = (const CPolicy& rhs);

        //
        // Names of registry values.
        //
        static const TCHAR SZ_REG_SEND_USER_EMAIL[];
        static const TCHAR SZ_REG_SHOW_USER_POPUP[];
        static const TCHAR SZ_REG_MIN_PERIOD_POPUP[];
        static const TCHAR SZ_REG_MIN_PERIOD_EMAIL[];
        static const TCHAR SZ_REG_SEND_EMAIL_TO[];
        static const TCHAR SZ_REG_SEND_EMAIL_CC[];
        static const TCHAR SZ_REG_SEND_EMAIL_BCC[];

        //
        // Default values for registry.
        //
        static const INT   I_REG_SEND_USER_EMAIL_DEFAULT;
        static const INT   I_REG_SHOW_USER_POPUP_DEFAULT;
        static const INT   I_REG_MIN_PERIOD_POPUP_DEFAULT;
        static const INT   I_REG_MIN_PERIOD_EMAIL_DEFAULT;
        static const TCHAR SZ_REG_SEND_EMAIL_TO_DEFAULT[];
        static const TCHAR SZ_REG_SEND_EMAIL_CC_DEFAULT[];
        static const TCHAR SZ_REG_SEND_EMAIL_BCC_DEFAULT[];

};

#endif //__POLICY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\stats.h ===
#ifndef __STATS_H
#define __STATS_H
///////////////////////////////////////////////////////////////////////////////
/*  File: stats.h

    Description: These classes provide temporary storage of quota
        information for a given volume/user pair.  Creation of the object
        automatically gathers the necessary quota and user information.  
        Clients then query the objects to retrieve quota statistics when
        desired.

            CStatistics
            CStatisticsList
                                                            +----------+
                                                       +--->| CVolume  |
                                                       |    +----------+
            +-----------------+     +-------------+<---+
            | CStatisticsList |<-->>| CStatistics | contains
            +-----------------+     +-------------+<---+
                                                       |    +-------------+
                                                       +--->| CVolumeUser |
                                                            +-------------+

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef __VOLUSER_H
#   include "voluser.h"
#endif

#ifndef __VOLUME_H
#   include "volume.h"
#endif

class CStatistics
{
    public:
        CStatistics(TCHAR chVolLetter, 
                    LPCTSTR pszVolDisplayName, 
                    LPBYTE pUserSid);
        ~CStatistics(VOID) { };

        BOOL SameVolume(const CStatistics& rhs) const
            { return m_vol == rhs.m_vol; }

        TCHAR GetVolumeLetter(VOID) const
            { return m_vol.GetLetter(); }

        VOID GetVolumeDisplayName(CString& strOut) const
            { m_vol.GetDisplayName(strOut); }

        LPCTSTR GetVolumeDisplayName(VOID) const
            { return m_vol.GetDisplayName(); }

        BOOL QuotasEnabled(VOID) const
            { return m_bQuotaEnabled; }

        BOOL WarnAtThreshold(VOID) const
            { return m_bWarnAtThreshold; }

        BOOL DenyAtLimit(VOID) const
            { return m_bDenyAtLimit; }

        VOID GetUserDisplayName(CString& strOut) const
            { m_volUser.GetDisplayName(strOut); }

        LPCTSTR GetUserDisplayName(VOID) const
            { return m_volUser.GetDisplayName(); }

        VOID GetUserEmailName(CString& strOut) const
            { m_volUser.GetEmailName(strOut); }

        LPCTSTR GetUserEmailName(VOID) const
            { return m_volUser.GetEmailName(); }

        LARGE_INTEGER GetUserQuotaThreshold(VOID) const
            { return m_volUser.GetQuotaThreshold(); }

        LARGE_INTEGER GetUserQuotaLimit(VOID) const
            { return m_volUser.GetQuotaLimit(); }

        LARGE_INTEGER GetUserQuotaUsed(VOID) const
            { return m_volUser.GetQuotaUsed(); }

        BOOL IsValid(VOID) const
            { return m_bValid; }

        BOOL IncludeInReport(VOID) const;

    private:
        CVolume        m_vol;               // Volume-specific info.
        CVolumeUser    m_volUser;           // User-specific info.
        BOOL           m_bQuotaEnabled;     // Are quotas enabled?
        BOOL           m_bWarnAtThreshold;  // Warn user at threshold?
        BOOL           m_bDenyAtLimit;      // Deny disk space at limit?
        BOOL           m_bValid;            // Is this object valid?

        //
        // Prevent copy.
        //
        CStatistics(const CStatistics& rhs);
        CStatistics& operator = (const CStatistics& rhs);
};


class CStatisticsList
{
    public:
        CStatisticsList(VOID);
        ~CStatisticsList(VOID);

        INT Count(VOID)
            { return m_List.Count(); }

        const CStatistics *GetEntry(INT iEntry);

        HRESULT AddEntry(TCHAR chVolLetter,
                         LPCTSTR pszVolDisplayName,
                         LPBYTE pUserSid);

    private:
        CArray<CStatistics *> m_List;
};


#endif //__STATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\volume.h ===
#ifndef __VOLUME_H
#define __VOLUME_H
///////////////////////////////////////////////////////////////////////////////
/*  File: volume.h

    Description: The CVolume class maintains information about a particular
        disk volume.  During initialization, the object determines if the
        associated volume supports quotas.  The object's client can then query
        it for volume-specific quota information.  Objects of this class are used
        in the CStatistics class to store information about a user/volume
        pair.

            CVolume


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif

class CVolume
{
    public:
        CVolume(TCHAR chLetter, LPCTSTR pszDisplayName);
        ~CVolume(VOID);

        BOOL operator == (const CVolume& rhs) const
            { return m_dwSerialNo == rhs.m_dwSerialNo; }

        TCHAR GetLetter(VOID) const
            { return m_chLetter; }

        VOID GetDisplayName(CString& strOut) const
            { strOut = m_strDisplayName; }

        LPCTSTR GetDisplayName(VOID) const
            { return (LPCTSTR)m_strDisplayName; }

        BOOL SupportsQuotas(VOID) const
            { return m_bSupportsQuotas; }

    private:
        TCHAR   m_chLetter;          // Driver letter
        DWORD   m_dwSerialNo;        // Drive serial number (unique ID)
        CString m_strDisplayName;    // Display name from shell.
        BOOL    m_bSupportsQuotas;   // Does volume support quotas?

        //
        // Prevent copy.
        //
        CVolume(const CVolume& rhs);
        CVolume& operator = (const CVolume& rhs);
};


#endif // __VOLUME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\volume.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: volume.cpp

    Description: The CVolume class maintains information about a particular
        disk volume.  During initialization, the object determines if the
        associated volume supports quotas.  The object's client can then query
        it for volume-specific quota information. Objects of this class are used
        in the CStatistics class to store information about a user/volume
        pair.

            CVolume


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include "volume.h"


CVolume::CVolume(
    TCHAR chLetter,
    LPCTSTR pszDisplayName
    ) : m_chLetter(chLetter),
        m_dwSerialNo(0),
        m_strDisplayName(pszDisplayName),
        m_bSupportsQuotas(FALSE)
{
    TCHAR szVolume[] = TEXT("X:\\");
    DWORD dwFsFlags = 0;

    szVolume[0] = m_chLetter;

    if (::GetVolumeInformation(szVolume,      // i.e. "X:"
                               NULL,          // Vol name, don't need it.
                               0,             // Vol name buf len.
                               &m_dwSerialNo, // Serial number var ptr.
                               NULL,          // Max component len var ptr.
                               &dwFsFlags,    // File system flags var ptr.
                               NULL,          // File sys name, don't need it.
                               0))            // File sys name buf len.
    {
        m_bSupportsQuotas = (0 != (dwFsFlags & FILE_VOLUME_QUOTAS));
    }
    else
    {
        DebugMsg(DM_ERROR, 
                 TEXT("CVolume - GetVolumeInformation for \"%s\" failed with error %d"), 
                 pszDisplayName, GetLastError());
    }
}

CVolume::~CVolume(
    VOID
    )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\voluser.h ===
#ifndef __VOLUSER_H
#define __VOLUSER_H
///////////////////////////////////////////////////////////////////////////////
/*  File: voluser.h

    Description: The CVolumeUser class maintains quota information about a 
        particular user on a volume.  Objects of this class are used
        in the CStatistics class to store information about a user/volume
        pair.

            CVolumeUser


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif


class CVolumeUser
{
    public:
        CVolumeUser(VOID);
        CVolumeUser(
            LPCTSTR pszDisplayName, 
            LPCTSTR pszEmailName,
            LARGE_INTEGER liQuotaThreshold,
            LARGE_INTEGER liQuotaLimit,
            LARGE_INTEGER liQuotaUsed);

        ~CVolumeUser(VOID);

        HRESULT SetUserInfo(
            LPCTSTR pszDisplayName, 
            LPCTSTR pszEmailName,
            LARGE_INTEGER liQuotaThreshold,
            LARGE_INTEGER liQuotaLimit,
            LARGE_INTEGER liQuotaUsed);

        VOID GetDisplayName(CString& strOut) const
            { strOut = m_strDisplayName; }

        LPCTSTR GetDisplayName(VOID) const
            { return (LPCTSTR)m_strDisplayName; }

        VOID GetEmailName(CString& strOut) const
            { strOut = m_strEmailName; }

        LPCTSTR GetEmailName(VOID) const
            { return (LPCTSTR)m_strEmailName; }

        LARGE_INTEGER GetQuotaThreshold(VOID) const
            { return m_liQuotaThreshold; }

        LARGE_INTEGER GetQuotaLimit(VOID) const
            { return m_liQuotaLimit; }

        LARGE_INTEGER GetQuotaUsed(VOID) const
            { return m_liQuotaUsed; }

    private:
        CString       m_strDisplayName;    // User's name for display
        CString       m_strEmailName;      // User's name for sending email.
        LARGE_INTEGER m_liQuotaThreshold;  // User's quota threshold on vol
        LARGE_INTEGER m_liQuotaLimit;      // User's quota limi on vol.
        LARGE_INTEGER m_liQuotaUsed;       // Quota used on vol by user.
};

#endif //__VOLUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\voluser.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: voluser.cpp

    Description: The CVolumeUser class maintains quota information about a 
        particular user on a volume.  Objects of this class are used
        in the CStatistics class to store information about a user/volume
        pair.

            CVolumeUser


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include "voluser.h"


CVolumeUser::CVolumeUser(
    VOID
    )
{
    m_liQuotaThreshold.QuadPart = 0;
    m_liQuotaLimit.QuadPart     = 0;
    m_liQuotaUsed.QuadPart      = 0;
}

CVolumeUser::CVolumeUser(
    LPCTSTR pszDisplayName, 
    LPCTSTR pszEmailName,
    LARGE_INTEGER liQuotaThreshold,
    LARGE_INTEGER liQuotaLimit,
    LARGE_INTEGER liQuotaUsed
    )
{
    SetUserInfo(pszDisplayName, 
                pszEmailName,
                liQuotaThreshold, 
                liQuotaLimit, 
                liQuotaUsed);
}


CVolumeUser::~CVolumeUser(
    VOID
    )
{

}


HRESULT 
CVolumeUser::SetUserInfo(
    LPCTSTR pszDisplayName, 
    LPCTSTR pszEmailName, 
    LARGE_INTEGER liQuotaThreshold,
    LARGE_INTEGER liQuotaLimit,
    LARGE_INTEGER liQuotaUsed
    )
{
    m_strDisplayName = pszDisplayName;
    m_strEmailName   = pszEmailName;

    m_liQuotaThreshold = liQuotaThreshold;
    m_liQuotaLimit     = liQuotaLimit;
    m_liQuotaUsed      = liQuotaUsed;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EFSADU.rc
//
#define IDS_DETAILWINTITLE              2
#define IDS_NOINFO                      4
#define IDS_ERRORMEM                    5
#define IDS_ADDUSERERR                  6
#define IDS_REMOVEUSERERR               7
#define IDS_CERTFILEFILTER              8
#define IDS_CERTFILEOPENERR             9
#define IDS_CERTFILEFORMATERR           10
#define IDS_UNKNOWNUSER                 11
#define IDS_NOCERTNAME                  13
#define IDS_NORECINFO                   15
#define IDS_DLGTITLE                    16
#define IDS_DISPTEXT                    17
#define IDS_NOREMOVEALL                 18
#define IDS_NOADDUSERDIR                19
#define IDS_COULDNOTVERIFYCERT          20
#define IDS_ACCEPTSELFCERT              21
#define IDS_ADDEFSEKUFAIL               22
#define IDS_INTERNALERROR               23
#define IDS_USERCOLTITLE                24
#define IDS_CERTCOLTITLE                25
#define IDS_RECCOLTITLE                 26
#define IDD_ENCRYPT_DETAILS             101
#define IDD_COMPLETION                  102
#define IDD_LOCATING                    103
#define IDD_WELCOME                     104
#define IDC_REMOVE                      1002
#define IDC_ADD                         1013
#define IDC_LISTUSER                    1017
#define IDC_LISTRA                      1018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\watchdog.cpp ===
///////////////////////////////////////////////////////////////////////////////
/*  File: watchdog.cpp

    Description: The CWatchDog class is the main control object for the
        disk quota watchdog applet.  A client merely creates a CWatchDog
        and tells it to "Run()".

            CWatchDog

        To run, the object does the following:

        1. Enumerates all local and connected volumes on the machine.
        2. For any volumes that support quotas, quota statistics are 
           gathered for both the volume and the local user on the volume.
           Statistics are maintained in a list of CStatistics objects; one
           object for each volume/user pair.
        3. Once all information has been gathered, a list of action objects
           (CActionEmail, CActionPopup) are created.  System policy and 
           previous notification history are considered when creating action
           objects.
        4. When all action objects are created, they are performed.


    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////
#include <precomp.hxx>
#pragma hdrstop

#include "action.h"
#include "watchdog.h"
#include "resource.h"

//
// Required so we can create auto_ptr<BYTE>
//
struct Byte
{
    BYTE b;
};


CWatchDog::CWatchDog(
    HANDLE htokenUser
    ) : m_htokenUser(htokenUser),
        m_history(m_policy)
{
    //
    // Nothing else to do.
    //
}


CWatchDog::~CWatchDog(
    VOID
    )
{
    ClearActionList();
}


//
// This is the function that does it all!
// Just create a watchdog object and tell it to run.
//
HRESULT
CWatchDog::Run(
    VOID
    )
{
    HRESULT hr = NOERROR;

    //
    // First check to see if we should do anything based upon the user's
    // notification history stored in the registry and the notification
    // policy defined by the system administrator.  If we've recently
    // displayed a popup or sent email, or if the system policy says
    // "don't send email or display a popup", we won't go any further.
    // No sense doing anything expensive if we don't need to.
    //
    if (ShouldDoAnyNotifications())
    {
        shauto_ptr<ITEMIDLIST> ptrIdlDrives;
        oleauto_ptr<IShellFolder> ptrDesktop;
        //
        // Bind to the desktop folder.
        //
        hr = SHGetDesktopFolder(ptrDesktop._getoutptr());
        if (SUCCEEDED(hr))
        {
            hr = SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, ptrIdlDrives._getoutptr());
            if (SUCCEEDED(hr))
            {
                //
                // Bind to the "Drives" folder.
                //
                oleauto_ptr<IShellFolder> ptrDrives;
                hr = ptrDesktop->BindToObject(ptrIdlDrives, NULL, IID_IShellFolder, (LPVOID *)ptrDrives._getoutptr());
                if (SUCCEEDED(hr))
                {
                    //
                    // Gather quota statistics for local and connected drives.
                    //
                    hr = GatherQuotaStatistics(ptrDrives);
                    if (SUCCEEDED(hr) && (0 < m_statsList.Count()))
                    {
                        //
                        // Build up the list of actions required.
                        //
                        hr = BuildActionList();
                        if (SUCCEEDED(hr) && (0 < m_actionList.Count()))
                        {
                            //
                            // We have a list of actions.  Do them.
                            //
                            hr = DoActions();
                        }
                    }
                }
            }
        }
    }
    return hr;
}


//
// Gather up all of the quota statistics for the volumes in the shell's "Drives" 
// folder and the quota statistics on those volumes for the current user if
// applicable.  
//
HRESULT
CWatchDog::GatherQuotaStatistics(
    IShellFolder *psfDrives
    )
{
    HRESULT hr;
    oleauto_ptr<IEnumIDList> ptrEnum;

    //
    // Enumerate all of the non-folder objects in the drives folder.
    //
    hr = psfDrives->EnumObjects(NULL, SHCONTF_NONFOLDERS, ptrEnum._getoutptr());
    if (SUCCEEDED(hr))
    {
        //
        // Convert the user's token to a SID.
        //
        auto_ptr<Byte> ptrSid = (Byte *)GetUserSid(m_htokenUser);
        if (NULL != (Byte *)ptrSid)
        {
            shauto_ptr<ITEMIDLIST> ptrIdlItem;
            ULONG ulFetched = 0;
            //
            // For each item in the drives folder...
            //
            while(S_OK == ptrEnum->Next(1, ptrIdlItem._getoutptr(), &ulFetched))
            {
                TCHAR szName[MAX_PATH];
                TCHAR szDisplayName[MAX_PATH];
                StrRet strretName((LPITEMIDLIST)ptrIdlItem);
                StrRet strretDisplayName((LPITEMIDLIST)ptrIdlItem);

                //
                // Get the non-display name form; i.e. "G:\"
                //
                hr = psfDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_FORPARSING, &strretName);
                if (SUCCEEDED(hr))
                {
                    strretName.GetString(szName, ARRAYSIZE(szName));
                    //
                    // Protect against getting something like "Dial-up Networking"
                    // and thinking it's drive 'D'.
                    //
                    if (TEXT(':') == szName[1])
                    {
                        //
                        // Get the display name form; i.e. "My Disk (G:)"
                        //
                        psfDrives->GetDisplayNameOf(ptrIdlItem, SHGDN_NORMAL, &strretDisplayName);
                        strretDisplayName.GetString(szDisplayName, ARRAYSIZE(szDisplayName));
                   
                        //
                        // Add the volume/user pair to the statistics list.
                        // This function does a lot of things.
                        //   1. Checks to see if volume supports quotas.
                        //   2. Gets volume quota information.
                        //   3. Gets user quota information for this volume.
                        //
                        // If something fails or the volume doesn't support quotas,
                        // the entry is not added to the list and will therefore not
                        // participate in any quota notification actions.
                        //
                        m_statsList.AddEntry(szName[0], szDisplayName, (LPBYTE)((Byte *)ptrSid));
                    }
                }
            }
        }
    }
    return hr;
}                                


//
// Build up the list of actions from our list of volume/user statistics.
// Note that it's important we build the email actions before the popup
// dialog actions.  Actions are appended to the action list.  The popup
// dialog used in popup actions may be a modal dialog which will block
// the call to DoAction() until the user responds.  If the user is away
// from the computer for a while, this will prevent any pending email
// notifications from going out.  Therefore, we always want to get the
// email notifications out of the way before we handle any notifications
// that might require user intervention.
//
HRESULT
CWatchDog::BuildActionList(
    VOID
    )
{
    HRESULT hr = NOERROR;

    //
    // Clear out any previous action objects.
    //
    ClearActionList();

    if (ShouldSendEmail())
    {
        //
        // Build up any actions requiring email.
        // Important that email comes before popup dialogs in action list.
        // See note in function header for details.
        //
        BuildEmailActions();
    }

    if (ShouldPopupDialog())
    {
        //
        // Build up any actions requiring popup dialogs.
        //
        BuildPopupDialogActions();
    }

    return hr;
}


//
// Build up all of the required email messages, appending them to the action
// list.  This is where all of the email message formatting is done.
// Currently, it's all done in this one function.  If more sophisticated
// email is required at a later date, this function may need to be
// divided into more functions with this as the central entry point.
//
HRESULT
CWatchDog::BuildEmailActions(
    VOID
    )
{
    HRESULT hr = NOERROR;
    INT cStatsEntries = m_statsList.Count();

    if (0 < cStatsEntries)
    {
        //
        // Now we know we'll need MAPI.  Go ahead and initialize the
        // session.  This will:
        //   1. Load MAPI32.DLL.
        //   2. Logon to MAPI creating a MAPI session.
        //   3. Obtain a pointer to the outbox.
        //
        // Note that MAPI will be uninitialized and MAPI32.DLL will be
        // unloaded when the session object is destroyed.
        //
        hr = m_mapiSession.Initialize();
        if (SUCCEEDED(hr))
        {
            //
            // Get the outbox object interface pointer.
            //
            LPMAPIFOLDER pOutBoxFolder;
            hr = m_mapiSession.GetOutBoxFolder(&pOutBoxFolder);
            if (SUCCEEDED(hr))       
            {
                //
                // OK.  Now we have loaded MAPI, created a MAPI session
                // and we have a pointer to the outbox folder.  Now we can
                // create messages and send them.
                //

                //
                // These are the pieces of the text message.
                //
                CMapiMessageBody body;    // Message body text.

                //
                // Add the canned header to the email message.
                //
                body.Append(g_hInstDll, IDS_EMAIL_HEADER);

                //
                // Subject line contains the computer name.
                //
                CString strComputerName;
                DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
                GetComputerName(strComputerName.GetBuffer(cchComputerName), 
                                &cchComputerName);

                CString strSubject(g_hInstDll, IDS_EMAIL_SUBJECT_LINE, (LPCTSTR)strComputerName);
                CString strVolume(g_hInstDll, IDS_EMAIL_VOLUME);
                CString strWarning(g_hInstDll, IDS_EMAIL_WARNING);
                CString strLimit(g_hInstDll, IDS_EMAIL_LIMIT);
                CString strUsed(g_hInstDll, IDS_EMAIL_USED);

                INT cEmailMsgEntries = 0;
                //
                // Enumerate all of the entries in the statistics list.
                // Each entry contains information for a volume/user pair.
                // 
                for (INT i = 0; i < cStatsEntries && SUCCEEDED(hr); i++)
                {
                    //
                    // Retrieve the next entry from the list.
                    //
                    const CStatistics *pStats = m_statsList.GetEntry(i);
                    Assert(NULL != pStats);
                    //
                    // Do these stats require reporting?  Some reasons
                    // why not...
                    //    1. Volume doesn't support quotas 
                    //           (non-NTFS, non-NTFS 5.0)
                    //    2. No access to volume.  Can't open it.
                    //    3. "Warn user over threshold" bit on the volume
                    //       is not set.
                    //    4. User's quota usage is below threshold value.
                    // 
                    if (pStats->IncludeInReport())
                    {
                        //
                        // Now create the message text for the volume 
                        // in this statistics object.
                        //
                        TCHAR szBytes[40];
                        TCHAR szBytesOver[40];

                        //
                        // "Location: MyShare on MyDisk (C:)"
                        //
                        LPCTSTR pszVolDisplayName = pStats->GetVolumeDisplayName() ?
                                                    pStats->GetVolumeDisplayName() :
                                                    TEXT("");
                        body.Append(g_hInstDll, 
                                    IDS_EMAIL_FMT_VOLUME, 
                                    (LPCTSTR)strVolume,
                                    pszVolDisplayName);

                        //
                        // "Quota Used: 91MB (1MB over warning)"
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaUsed().QuadPart,
                                                          szBytes, ARRAYSIZE(szBytes));

                        //
                        // Format and add the "1MB" part of "(1MB over warning)".  
                        //
                        __int64 diff = pStats->GetUserQuotaUsed().QuadPart - pStats->GetUserQuotaThreshold().QuadPart;
                        if (0 > diff)
                        {
                            diff = 0;
                        }

                        XBytes::FormatByteCountForDisplay(diff, szBytesOver, ARRAYSIZE(szBytesOver));

                        body.Append(g_hInstDll,
                                    IDS_EMAIL_FMT_USED, 
                                    (LPCTSTR)strUsed, 
                                    szBytes,
                                    szBytesOver);
                        //
                        // "Warning Level: 90MB"
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaThreshold().QuadPart,
                                                          szBytes, ARRAYSIZE(szBytes));
                        body.Append(g_hInstDll,
                                    IDS_EMAIL_FMT_WARNING, 
                                    (LPCTSTR)strWarning, 
                                    szBytes);

                        //
                        // "Quota Limit: 100MB"
                        //
                        XBytes::FormatByteCountForDisplay(pStats->GetUserQuotaLimit().QuadPart,
                                                          szBytes, ARRAYSIZE(szBytes));
                        body.Append(g_hInstDll,
                                    IDS_EMAIL_FMT_LIMIT, 
                                    (LPCTSTR)strLimit, 
                                    szBytes);

                        if (pStats->DenyAtLimit())
                        {
                            //
                            // Volume is set to deny writes at the quota limit.
                            // Add a reminder of this fact.
                            //
                            body.Append(g_hInstDll, IDS_EMAIL_DENY_AT_LIMIT);
                        }
                        //
                        // Keep track of how many volume entries we've added to
                        // the message.  If the count is 0 when we're done, no sense
                        // in creating/sending the message.
                        //
                        cEmailMsgEntries++;
                    }
                }
                if (0 < cEmailMsgEntries)
                {
                    //
                    // Create an email action object from the text
                    // we've formatted above.
                    //
                    CAction *pAction = new CActionEmail(m_mapiSession,
                                                        pOutBoxFolder,
                                                        m_policy.GetOtherEmailTo(),
                                                        m_policy.GetOtherEmailCc(),
                                                        m_policy.GetOtherEmailBcc(),
                                                        strSubject,
                                                        body);
                    if (NULL != pAction)
                    {
                        //
                        // Add the action object to the list of action objects.
                        //
                        m_actionList.Append(pAction);
                    }
                }
                pOutBoxFolder->Release();
            }
            else
            {
                DebugMsg(DM_ERROR, TEXT("CWatchDog::BuildEmailActions: Error 0x%08X getting MAPI outbox"), hr);
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("CWatchDog::BuildEmailActions: Error 0x%08X initializing MAPI session"), hr);
        }
    }
    return hr;
}



//
// Build up all of the required popup actions, appending them to the action
// list.  
//
HRESULT
CWatchDog::BuildPopupDialogActions(
    VOID
    )
{
    HRESULT hr = NOERROR;
    //
    // Create a dialog popup action object.
    // It uses the statistics list to fill it's listview
    // control.  Other than that, it's fully self-contained.
    // Note however that we're just passing a reference
    // to the statistics list and the CActionPopup object doesn't
    // create a copy of the object.  Therefore, the statistics
    // list object MUST live longer than the popup object.
    // This is a safe assumption in the current design.
    //
    CAction *pAction = new CActionPopup(m_statsList);

    if (NULL != pAction)
    {
        //
        // Add the action object to the list of action objects.
        //
        m_actionList.Append(pAction);
    }
    return hr;
}

//
// Remove all actions from the action list.
//
VOID
CWatchDog::ClearActionList(
    VOID
    )
{
    INT cActions = m_actionList.Count();
    for (INT i = 0; i < cActions; i++)
    {
        delete m_actionList[i];
    }
    m_actionList.Clear();
}


//
// Perform the actions in the action list.
//
HRESULT
CWatchDog::DoActions(
    VOID
    )
{
    HRESULT hr = NOERROR;

    INT cActions = m_actionList.Count();
    
    //
    // For each action in the action list...
    //
    for (INT i = 0; i < cActions; i++)
    {
        Assert(NULL != m_actionList[i]);
        //
        // Do the action.
        // Pass in a reference to our CHistory object so that the
        // action object can update the history record appropriately.
        //
        hr = m_actionList[i]->DoAction(m_history);
    }
    return hr;
}


//
// Convert a user's token handle into a SID.
// Caller is responsible for calling delete[] on the returned buffer when
// done with it.
//
LPBYTE
CWatchDog::GetUserSid(
    HANDLE htokenUser
    )
{
    LPBYTE pbUserSid = NULL;
    BOOL bResult     = FALSE;

    if (NULL != htokenUser)
    {
        //
        // Note the use of "Byte" and not "BYTE".  auto_ptr<> requires
        // a class, struct or union.  No scalar types.
        //
        auto_ptr<Byte> ptrUserToken = NULL;
        DWORD cbUserToken = 256;

        //
        // Start with a 256-byte buffer.
        //
        ptrUserToken = new Byte[cbUserToken];

        if (NULL != (Byte *)ptrUserToken)
        {
            //
            // Get the user's token information from the system.
            //
            DWORD cbUserTokenReqd;
            bResult = ::GetTokenInformation(htokenUser,
                                            TokenUser,
                                            ptrUserToken,
                                            cbUserToken,
                                            &cbUserTokenReqd);

            if (!bResult && (cbUserTokenReqd > cbUserToken))
            {
                //
                // Buffer wasn't large enough.  Try again
                // with the size value returned from the previous call.
                // ptrUserToken is an auto_ptr so the original buffer
                // is automagically deleted.
                //
                ptrUserToken = new Byte[cbUserTokenReqd];
                if (NULL != (Byte *)ptrUserToken)
                {
                    bResult = ::GetTokenInformation(htokenUser,
                                                    TokenUser,
                                                    ptrUserToken,
                                                    cbUserTokenReqd,
                                                    &cbUserTokenReqd);
                }
            }
        }
        if (bResult)
        {
            TOKEN_USER *pToken = (TOKEN_USER *)((Byte *)ptrUserToken);
            if (::IsValidSid(pToken->User.Sid))
            {
                //
                // If the SID is valid, create a new buffer and copy
                // the SID bytes to it.  We'll return the new buffer
                // to the caller.
                //
                INT cbUserSid = ::GetLengthSid(pToken->User.Sid);
            
                pbUserSid = new BYTE[cbUserSid];
                if (NULL != pbUserSid)
                {
                    ::CopySid(cbUserSid, pbUserSid, pToken->User.Sid);
                }
            }
            else
            {
                DebugMsg(DM_ERROR, TEXT("CWatchDog::GetUserSid - Invalid SID for user token 0x%08X"), htokenUser);
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("CWatchDog::GetUserSid - GetTokenInformation failed with error 0x%08X"), GetLastError());
        }
    }        
    else
    {
        DebugMsg(DM_ERROR, TEXT("CWatchDog::GetUserSid - OpenThreadToken failed with error 0x%08X"), GetLastError());
    }
    return pbUserSid;
}

//
// Should we send email based on policy/history?
//
BOOL 
CWatchDog::ShouldSendEmail(
    VOID
    )
{
    return m_policy.ShouldSendEmail() &&
           m_history.ShouldSendEmail();
}


//
// Should we show a popup based on policy/history?
//
BOOL
CWatchDog::ShouldPopupDialog(
    VOID
    )
{
    return m_policy.ShouldPopupDialog() &&
           m_history.ShouldPopupDialog();
}

//
// Should we do anything based on policy/history?
//
BOOL
CWatchDog::ShouldDoAnyNotifications(
    VOID
    )
{
    return m_policy.ShouldDoAnyNotifications() &&
           m_history.ShouldDoAnyNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\dskquota\watchdog\watchdog.h ===
#ifndef __WATCHDOG_H
#define __WATCHDOG_H
///////////////////////////////////////////////////////////////////////////////
/*  File: watchdog.h

    Description: The CWatchDog class is the main control object for the
        disk quota watchdog applet.  A client merely creates a CWatchDog
        and tells it to "Run()".

            CWatchDog

        To run, the object does the following:

        1. Enumerates all local and connected volumes on the machine.
        2. For any volumes that support quotas, quota statistics are 
           gathered for both the volume and the local user on the volume.
           Statistics are maintained in a list of CStatistics objects; one
           object for each volume/user pair.
        3. Once all information has been gathered, a list of action objects
           (CActionEmail, CActionPopup) are created.  System policy and 
           previous notification history are considered when creating action
           objects.
        4. When all action objects are created, they are performed.

    Revision History:

    Date        Description                                          Programmer
    --------    ---------------------------------------------------  ----------
    07/01/97    Initial creation.                                    BrianAu
*/
///////////////////////////////////////////////////////////////////////////////

#ifndef _WINDOWS_
#   include <windows.h>
#endif

#ifndef _SHLOBJ_H_
#   include <shlobj.h>
#endif

#ifndef __MAPISEND_H
#   include "mapisend.h"
#endif

#ifndef __STATS_H
#   include "stats.h"
#endif

#ifndef __POLICY_H
#   include "policy.h"
#endif

#ifndef __HISTORY_H
#   include "history.h"
#endif

#ifndef __ACTION_H
#   include "action.h"
#endif

//
// This guy controls the whole thing.
// Just create a CWatchDog object and call Run().
// That's all there is to it.
//
class CWatchDog
{
    public:
        CWatchDog(HANDLE htokenUser);
        ~CWatchDog(VOID);

        HRESULT Run(VOID);

    private:
        HANDLE          m_htokenUser;   // User account token.
        CPolicy         m_policy;       // Controls what actions occur.
        CHistory        m_history;      // Controls notification frequency.
        CStatisticsList m_statsList;    // User & Volume quota info.
        CArray<CAction *> m_actionList; // List of actions to perform.
        CMapiSession    m_mapiSession;  // MAPI session object for sending email

        HRESULT GatherQuotaStatistics(IShellFolder *psfDrives);

        HRESULT BuildActionList(VOID);

        HRESULT BuildPopupDialogActions(VOID);

        HRESULT BuildEmailActions(VOID);

        HRESULT DoActions(VOID);

        VOID ClearActionList(VOID);

        LPBYTE GetUserSid(HANDLE htokenUser);

        BOOL ShouldReportTheseStats(const CStatistics& stats);

        BOOL ShouldSendEmail(VOID);

        BOOL ShouldPopupDialog(VOID);

        BOOL ShouldDoAnyNotifications(VOID);

        //
        // Prevent copy.
        //
        CWatchDog(const CWatchDog& rhs);
        CWatchDog& operator = (const CWatchDog& rhs);
};

#endif // __WATCHDOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\efsadu.h ===
// EFSADU.h : main header file for the EFSADU DLL
//

#if !defined(AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp
// See EFSADU.cpp for the implementation of this class
//

class CEFSADUApp : public CWinApp
{
public:
	CEFSADUApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEFSADUApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CEFSADUApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFSADU_H__15788838_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\efsadu.cpp ===
// EFSADU.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "EFSADU.h"
#include "userlist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp

BEGIN_MESSAGE_MAP(CEFSADUApp, CWinApp)
	//{{AFX_MSG_MAP(CEFSADUApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEFSADUApp construction

CEFSADUApp::CEFSADUApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance

}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEFSADUApp object

CEFSADUApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\efsui.h ===
/*
Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    efsui.h

Abstract:

    Header file for Encryped File System UI

*/

// Brings up the encryption details page
STDAPI_(void) EfsDetail(HWND hwndParent, LPCWSTR FileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EFSADU.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
// #include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
// #include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1578883A_4F37_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\userlist.h ===
#if !defined(AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_)
#define AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// USERLIST.h : header file
//

#include "users.h"
#include "lmcons.h"
#include "dns.h"
#include "ntdsapi.h"
#include <wincrypt.h>

/////////////////////////////////////////////////////////////////////////////
// USERLIST dialog

class USERLIST : public CDialog
{
// Construction
public:
	USERLIST(CWnd* pParent = NULL);   // standard constructor
	USERLIST(LPCTSTR FileName, CWnd* pParent = NULL); 
	DWORD ApplyChanges(LPCTSTR FileName);

    DWORD    AddNewUsers(CUsers &NewUsers);

// Dialog Data
	//{{AFX_DATA(USERLIST)
	enum { IDD = IDD_ENCRYPT_DETAILS };
	CListCtrl	m_RecoveryListCtrl;
	CListCtrl	m_UserListCtrl;
	CButton	m_AddButton;
	CButton	m_RemoveButton;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(USERLIST)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(USERLIST)
	afx_msg void OnRemove();
	virtual void OnCancel();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnSetfocusListuser(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusListuser(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedListuser(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	DWORD TryGetBetterNameInCert(PEFS_HASH_BLOB HashData, LPTSTR *UserName);
	void SetUpListBox(BOOL *Enable);
	void ShowRemove(void);
    DWORD GetCertNameFromCertContext(PCCERT_CONTEXT CertContext, LPTSTR * UserDispName);
    DWORD CertInStore(HCERTSTORE *pStores, DWORD StoreNum, PCCERT_CONTEXT selectedCert);
    CString m_FileName;
    CUsers m_Users;
    CUsers m_Recs;
    LONG   m_CurrentUsers;
    CERT_CHAIN_PARA m_CertChainPara;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_USERLIST_H__3A1CD0AB_4FC3_11D1_BB5D_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\userlist.cpp ===
// USERLIST.cpp : implementation file
//

#include "stdafx.h"
#include "EFSADU.h"
#include "USERLIST.h"
#include "cryptui.h"
#include "objsel.h"
#include <winefs.h>
#include "efsui.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define OTHERPEOPLE  L"AddressBook"
#define TRUSTEDPEOPLE L"TrustedPeople"


LPSTR   EfsOidlpstr  = szOID_KP_EFS;

/////////////////////////////////////////////////////////////////////////////
// USERLIST dialog


USERLIST::USERLIST(CWnd* pParent /*=NULL*/)
	: CDialog(USERLIST::IDD, pParent)
{
	//{{AFX_DATA_INIT(USERLIST)
	//}}AFX_DATA_INIT
}

USERLIST::USERLIST(LPCTSTR FileName, CWnd* pParent /*=NULL*/)
	: CDialog(USERLIST::IDD, pParent)
{
    m_FileName = FileName;
}


void USERLIST::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(USERLIST)
	DDX_Control(pDX, IDC_LISTRA, m_RecoveryListCtrl);
	DDX_Control(pDX, IDC_LISTUSER, m_UserListCtrl);
	DDX_Control(pDX, IDC_ADD, m_AddButton);
	DDX_Control(pDX, IDC_REMOVE, m_RemoveButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(USERLIST, CDialog)
	//{{AFX_MSG_MAP(USERLIST)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_NOTIFY(NM_SETFOCUS, IDC_LISTUSER, OnSetfocusListuser)
	ON_NOTIFY(NM_KILLFOCUS, IDC_LISTUSER, OnKillfocusListuser)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTUSER, OnItemchangedListuser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// USERLIST message handlers

void USERLIST::OnRemove()
{
	int     ItemPos;
    BOOL    NoAction = FALSE;
    CString NoCertName;

    try{
        NoCertName.LoadString(IDS_NOCERTNAME);
    }
    catch(...){
        NoAction = TRUE;
    }

    if (NoAction){
        return;
    }

	ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );
    while ( ItemPos != -1 ){

        CString CertName;
        LPTSTR  pCertName;


        CertName = m_UserListCtrl.GetItemText( ItemPos, 0 );
        if ( !CertName.Compare(NoCertName) ){
            pCertName = NULL;            
        } else {
            pCertName = CertName.GetBuffer(CertName.GetLength() + 1);
        }

        m_Users.Remove( pCertName);
        m_UserListCtrl.DeleteItem( ItemPos );
        if (pCertName){
            CertName.ReleaseBuffer();
        }

        //
        // Because we have deleted the item. We have to start from -1 again.
        //

        ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );

    }

    m_AddButton.SetFocus();

}

void USERLIST::OnCancel()
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();
}

void USERLIST::OnOK()
{
	// TODO: Add extra validation here

    LONG NoUsersToAdd =  m_Users.GetUserAddedCnt();
    LONG NoUsersToRemove = m_Users.GetUserRemovedCnt();

    if ( (NoUsersToRemove - NoUsersToAdd) >= m_CurrentUsers) {

        //
        // All the users are going to be removed from the file. Do not allow.
        //

        CString ErrMsg;

        if (ErrMsg.LoadString(IDS_NOREMOVEALL)){
            MessageBox(ErrMsg);
        }
        return;
    }
	
	CDialog::OnOK();
}

STDAPI_(void) EfsDetail(HWND hwndParent, LPCWSTR FileName)
{
    INT_PTR RetCode;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD FileAttributes = GetFileAttributes(FileName);

    if ( (-1 != FileAttributes) && ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        CString ErrMsg;

        if (ErrMsg.LoadString(IDS_NOADDUSERDIR)){
            MessageBox(hwndParent, ErrMsg, NULL, MB_OK);
        }
        return;
    }

    CWnd cwnd;
    cwnd.FromHandle(hwndParent);

    USERLIST DetailDialog(FileName, &cwnd);

    RetCode = DetailDialog.DoModal();
    if ( IDOK == RetCode ){

        //
        // Commit the change
        //

        DetailDialog.ApplyChanges( FileName );

    } else if (IDCANCEL == RetCode) {

        //
        // Nothing needs to be done
        //

    }

}

BOOL WINAPI EfsFilter(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData
)
{
    BOOL disp = FALSE;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage = 0;

    if (CertGetEnhancedKeyUsage(
            pCertContext,
            0,
            NULL,                                   
            &cbUsage) && 0 != cbUsage){

        pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];

        if (pUsage){

            if (CertGetEnhancedKeyUsage(
                    pCertContext,
                    0,
                    pUsage,
                    &cbUsage)){

                //
                // Search for EFS usage
                //

                DWORD cUsages = pUsage->cUsageIdentifier;
                while (cUsages){
                    if (!strcmp(szOID_KP_EFS, pUsage->rgpszUsageIdentifier[cUsages-1])){
                        disp = TRUE;
                        break;
                    }
                    cUsages--;
                } 


            }

            delete [] pUsage;

        }
    }

    return disp;

}


BOOL USERLIST::OnInitDialog()
{
    CDialog::OnInitDialog();
    CString WinTitle;
    RECT    ListRect;
    DWORD   ColWidth;
    CString ColName;
    CString ColCert;
    CString RecName;

    LPTSTR  UserCertName = NULL;
    BOOL    EnableAddButton = FALSE;
    PENCRYPTION_CERTIFICATE_HASH_LIST pUsers = NULL;
	PENCRYPTION_CERTIFICATE_HASH_LIST pRecs = NULL;

    try {

        DWORD RetCode;

        AfxFormatString1( WinTitle, IDS_DETAILWINTITLE, m_FileName );
        SetWindowText( WinTitle );

        m_CertChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
        m_CertChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

        //
        // Check EFS EKU
        //

        m_CertChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        m_CertChainPara.RequestedUsage.Usage.rgpszUsageIdentifier=&EfsOidlpstr;

        m_UserListCtrl.GetClientRect(&ListRect);
        ColName.LoadString(IDS_USERCOLTITLE);
        ColCert.LoadString(IDS_CERTCOLTITLE);
        RecName.LoadString(IDS_RECCOLTITLE);
        ColWidth = ( ListRect.right - ListRect.left  ) / 4;
        m_UserListCtrl.InsertColumn(0, ColName, LVCFMT_LEFT, ColWidth*3 );
        m_UserListCtrl.InsertColumn(1, ColCert, LVCFMT_LEFT, ColWidth );

        m_RecoveryListCtrl.GetClientRect(&ListRect);
        ColWidth = ( ListRect.right - ListRect.left  ) / 4;
        m_RecoveryListCtrl.InsertColumn(0, RecName, LVCFMT_LEFT, ColWidth*3 );
        m_RecoveryListCtrl.InsertColumn(1, ColCert, LVCFMT_LEFT, ColWidth );

        RetCode = QueryUsersOnEncryptedFile( (LPWSTR)(LPCWSTR) m_FileName, &pUsers);
        if ( !RetCode ){

			RetCode = QueryRecoveryAgentsOnEncryptedFile( (LPWSTR)(LPCWSTR) m_FileName, &pRecs);

			if ( !RetCode ){

				//
				// Got the info about the encrypted file
				//


				DWORD   NUsers = pUsers->nCert_Hash;
                BOOL    RecDone = FALSE;
                PENCRYPTION_CERTIFICATE_HASH_LIST pCertHashList = pUsers;

                m_CurrentUsers = (LONG) NUsers;

				//
				// Get all the users
				//

				while ( NUsers > 0 ){


					UserCertName = new TCHAR[_tcslen(pCertHashList->pUsers[NUsers - 1]->lpDisplayInformation) + 1];
					if (UserCertName){
						_tcscpy(UserCertName, pCertHashList->pUsers[NUsers - 1]->lpDisplayInformation);
					} else {
						AfxThrowMemoryException( );
					}

					//
					// We got the user name
					//

                    if (RecDone){
					    RetCode = m_Recs.Add(
											    UserCertName,
											    pCertHashList->pUsers[NUsers - 1]->pHash,
											    NULL
											    );
                    } else {

                        //
                        // Try to get a better name from the cert
                        //

                        LPTSTR UserName;

                        RetCode = TryGetBetterNameInCert(pCertHashList->pUsers[NUsers - 1]->pHash, &UserName);
                        if (ERROR_SUCCESS == RetCode){

                            //
                            // We get a better name from the certs
                            //

                            delete [] UserCertName;
                            UserCertName = UserName; 

                        }

					    RetCode = m_Users.Add(
											    UserCertName,
											    pCertHashList->pUsers[NUsers - 1]->pHash,
											    NULL
											    );
                    }

					if ( NO_ERROR != RetCode ) {
						delete [] UserCertName;
						UserCertName = NULL;
					}

					NUsers--;
                    if (NUsers == 0 && !RecDone){

                        //
                        // Let's deal with the recovery agents.
                        //

                        RecDone = TRUE;
                        pCertHashList = pRecs;
                        NUsers = pRecs->nCert_Hash;
                    }
				}


                if ( pRecs ){
	                FreeEncryptionCertificateHashList( pRecs );
	                pRecs = NULL;
                }

				//
				// In memory intial list established
				//

				SetUpListBox(&EnableAddButton);
            } else {

                //
                // Cannot get recovery info
                //
                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_NORECINFO)){
                    MessageBox(ErrMsg);
                }

            }

            if ( pUsers ){
	            FreeEncryptionCertificateHashList( pUsers );
	            pUsers = NULL;
            } 

        } else {

            //
            // Cannot get user info
            //

            CString ErrMsg;

            if (ErrMsg.LoadString(IDS_NOINFO)){
                MessageBox(ErrMsg);
            }
        }

    }
     catch (...) {
        //
        // The exception mostly is caused by out of memory.
        // We can not prevent the page to be displayed from this routine,
        // So we just go ahead with empty list
        //

        m_UserListCtrl.DeleteAllItems( );
        m_RecoveryListCtrl.DeleteAllItems( );


        //
        // Delete works even if UserCertName == NULL
        //

        delete [] UserCertName;
        if ( pUsers ){
            FreeEncryptionCertificateHashList( pUsers );
        }
        if ( pRecs ){
            FreeEncryptionCertificateHashList( pRecs );
        }

    }

    m_RemoveButton.EnableWindow( FALSE );
    if ( !EnableAddButton ){
        m_AddButton.EnableWindow( FALSE );
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void USERLIST::ShowRemove()
{
    if (m_UserListCtrl.GetSelectedCount() > 0){

        //
        // Enable the Remove Button
        //

        m_RemoveButton.EnableWindow( TRUE );

    } else {
        
        //
        // Disable the Remove Button
        //

        m_RemoveButton.EnableWindow( FALSE );

    }
}

DWORD
USERLIST::ApplyChanges(
    LPCTSTR FileName
    )
{
    DWORD RetCode = NO_ERROR;
    DWORD NoUsersToRemove;
    DWORD NoUsersToAdd;
    DWORD RemoveUserIndex;
    DWORD AddUserIndex;
    PENCRYPTION_CERTIFICATE_HASH_LIST RemoveUserList = NULL;
    PENCRYPTION_CERTIFICATE_LIST AddUserList = NULL;
    PVOID   EnumHandle;


    //
    //  Get all the users to be added or removed first
    //

    NoUsersToAdd =  m_Users.GetUserAddedCnt();
    NoUsersToRemove = m_Users.GetUserRemovedCnt();

    if ( (NoUsersToAdd == 0) && (NoUsersToRemove == 0)){
        return NO_ERROR;
    }

    if ( NoUsersToAdd ) {

        //
        // At least one user is to be added
        //

        DWORD   BytesToAllocate;

        BytesToAllocate = sizeof ( ENCRYPTION_CERTIFICATE_LIST ) +
                                       NoUsersToAdd  * sizeof ( PENCRYPTION_CERTIFICATE ) +
                                       NoUsersToAdd * sizeof (ENCRYPTION_CERTIFICATE);
        AddUserList = (PENCRYPTION_CERTIFICATE_LIST) new BYTE[BytesToAllocate];
        if ( NULL == AddUserList ){

            //
            // Out of memory. Try our best to display the error message.
            //

            try {

                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_ERRORMEM)){
                    ::MessageBox(NULL, ErrMsg, NULL, MB_OK);
                }
            }
            catch (...) {
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        AddUserList->nUsers = NoUsersToAdd;
        AddUserList->pUsers = (PENCRYPTION_CERTIFICATE *)(((PBYTE) AddUserList) +
                    sizeof ( ENCRYPTION_CERTIFICATE_LIST ));
    }

    if ( NoUsersToRemove ){

            //
            // At least one user is to be removed
            //

        DWORD   BytesToAllocate;

        BytesToAllocate = sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ) +
                                       NoUsersToRemove  * sizeof ( PENCRYPTION_CERTIFICATE_HASH) +
                                       NoUsersToRemove * sizeof (ENCRYPTION_CERTIFICATE_HASH);


        RemoveUserList = (PENCRYPTION_CERTIFICATE_HASH_LIST) new BYTE[BytesToAllocate];
        if ( NULL == RemoveUserList ){

            //
            // Out of memory. Try our best to display the error message.
            //

            if (AddUserList){
                delete [] AddUserList;
                AddUserList = NULL;
            }

            try {

                CString ErrMsg;

                if (ErrMsg.LoadString(IDS_ERRORMEM)){
                    ::MessageBox(NULL, ErrMsg, NULL, MB_OK);
                }
            }
            catch (...) {
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RemoveUserList->nCert_Hash = NoUsersToRemove;
        RemoveUserList->pUsers =  (PENCRYPTION_CERTIFICATE_HASH *)(((PBYTE) RemoveUserList) +
                    sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ));
    }

    EnumHandle = m_Users.StartEnum();
    RemoveUserIndex = 0;
    AddUserIndex = 0;
    while ( EnumHandle ){

        DWORD   Flag;
        PSID         UserSid;
        PVOID      CertData;
        LPTSTR   UserName;

        EnumHandle = m_Users.GetNextChangedUser(
                                    EnumHandle,
                                    &UserName,
                                    &UserSid,
                                    &CertData,
                                    &Flag
                                    );

        if ( Flag ){

            //
            // We get our changed user
            //

            if ( Flag & USERADDED ){

                ASSERT( AddUserList );

                //
                // Add the user to the adding list
                //

                PENCRYPTION_CERTIFICATE   EfsCert;

                ASSERT (AddUserIndex < NoUsersToAdd);

                EfsCert= (PENCRYPTION_CERTIFICATE)(((PBYTE) AddUserList) +
                            sizeof ( ENCRYPTION_CERTIFICATE_LIST ) +
                            NoUsersToAdd  * sizeof ( PENCRYPTION_CERTIFICATE) +
                            AddUserIndex * sizeof (ENCRYPTION_CERTIFICATE));

                AddUserList->pUsers[AddUserIndex] = EfsCert;
                EfsCert->pUserSid =  (SID *) UserSid;
                EfsCert->cbTotalLength = sizeof (ENCRYPTION_CERTIFICATE);
                EfsCert->pCertBlob = (PEFS_CERTIFICATE_BLOB) CertData;

                AddUserIndex++;

            } else if ( Flag & USERREMOVED ) {

                ASSERT (RemoveUserList);

                //
                // Add the user to the removing list
                //

                PENCRYPTION_CERTIFICATE_HASH    EfsCertHash;

                ASSERT (RemoveUserIndex < NoUsersToRemove);

                EfsCertHash= (PENCRYPTION_CERTIFICATE_HASH)(((PBYTE) RemoveUserList) +
                            sizeof ( ENCRYPTION_CERTIFICATE_HASH_LIST ) +
                            NoUsersToRemove   * sizeof ( PENCRYPTION_CERTIFICATE_HASH) +
                            RemoveUserIndex * sizeof (ENCRYPTION_CERTIFICATE_HASH));

                RemoveUserList->pUsers[RemoveUserIndex] = EfsCertHash;
                EfsCertHash->cbTotalLength = sizeof (ENCRYPTION_CERTIFICATE_HASH);
                EfsCertHash->pUserSid = (SID *)UserSid;
                EfsCertHash->pHash = (PEFS_HASH_BLOB) CertData;
                EfsCertHash->lpDisplayInformation = NULL;

                RemoveUserIndex++;
            } else {
                ASSERT(FALSE);
            }

        }

    }

    ASSERT(RemoveUserIndex == NoUsersToRemove);
    ASSERT(AddUserIndex == NoUsersToAdd);

    if ( AddUserIndex && AddUserList ){

        //
        // Add the user to the file list
        //

        RetCode = AddUsersToEncryptedFile(FileName, AddUserList);
        if ( NO_ERROR != RetCode ){

            CString ErrMsg;
            TCHAR   ErrCode[16];

            _ltot(RetCode, ErrCode, 10 );
            AfxFormatString1( ErrMsg, IDS_ADDUSERERR, ErrCode );
            MessageBox(ErrMsg);

        }

    }

    if ( RemoveUserIndex && RemoveUserList){

        //
        // Remove the user from the list
        //

        DWORD RetCodeBak = RetCode;

        RetCode = RemoveUsersFromEncryptedFile(FileName, RemoveUserList);
        if ( NO_ERROR != RetCode ){

            CString ErrMsg;
            TCHAR   ErrCode[16];

            _ltot(RetCode, ErrCode, 10 );
            AfxFormatString1( ErrMsg, IDS_REMOVEUSERERR, ErrCode );
            MessageBox(ErrMsg);

        } else {

            //
            // Reflect the error happened
            //

            RetCode = RetCodeBak;
        }

    }

    if (AddUserList){
        delete [] AddUserList;
    }
    if (RemoveUserList){
        delete [] RemoveUserList;
    }

    return RetCode;
}

DWORD
USERLIST::AddNewUsers(CUsers &NewUser)
{
    DWORD RetCode = ERROR_SUCCESS;

    m_UserListCtrl.DeleteAllItems( );
    RetCode = m_Users.Add(NewUser);
    SetUpListBox(NULL);

    return RetCode;
}


void USERLIST::SetUpListBox(BOOL *EnableAdd)
{
    PVOID   EnumHandle;

    try{
        CString NoCertName;

        NoCertName.LoadString(IDS_NOCERTNAME);

        if (EnumHandle = m_Users.StartEnum()){

            LV_ITEM fillItem;

            fillItem.mask = LVIF_TEXT;


            //
            // At least one user is available
            //
            while ( EnumHandle ){
                CString CertName;
                CString CertHash;

                fillItem.iItem = 0;
                fillItem.iSubItem = 0;

                EnumHandle = m_Users.GetNextUser(EnumHandle, CertName, CertHash);
                if (!EnumHandle && CertName.IsEmpty() && CertHash.IsEmpty()) {
                    //
                    // No more items.
                    //

                    break;

                }
                if (CertName.IsEmpty()){
                    fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                } else {
                    fillItem.pszText = CertName.GetBuffer(CertName.GetLength() + 1);
                }

                //
                // Add the user to the list
                //

                fillItem.iItem = m_UserListCtrl.InsertItem(&fillItem);

                if (CertName.IsEmpty()){
                    NoCertName.ReleaseBuffer();
                } else {
                    CertName.ReleaseBuffer();
                }

                if ( fillItem.iItem != -1 ){
                    if ( EnableAdd ){
                        *EnableAdd = TRUE;
                    }

                    if (CertHash.IsEmpty()){
                        fillItem.pszText = NULL;
                    } else {
                        fillItem.pszText = CertHash.GetBuffer(CertHash.GetLength() + 1);
                    }

                    fillItem.iSubItem = 1;
                    m_UserListCtrl.SetItem(&fillItem);
                    
                    if (!CertHash.IsEmpty()){
                        CertHash.ReleaseBuffer();
                    }
                }
              
            }
        }

        if (EnableAdd){

            //
            // From the dialog init. Do the Rec list as well
            //

            if (EnumHandle = m_Recs.StartEnum()){

                LV_ITEM fillItem;

                fillItem.mask = LVIF_TEXT;

                //
                // At least one user is available
                //

                while ( EnumHandle ){

                    CString CertName;
                    CString CertHash;

                    fillItem.iItem = 0;
                    fillItem.iSubItem = 0;

                    EnumHandle = m_Recs.GetNextUser(EnumHandle, CertName, CertHash);

                    if (!EnumHandle && CertName.IsEmpty() && CertHash.IsEmpty()) {
                        //
                        // No more items.
                        //
    
                        break;
    
                    }
                    //
                    // Add the agent to the list
                    //

                    if (CertName.IsEmpty()){
                        fillItem.pszText = NoCertName.GetBuffer(NoCertName.GetLength() + 1);
                    } else {
                        fillItem.pszText = CertName.GetBuffer(CertName.GetLength() + 1);
                    }

                    fillItem.iItem = m_RecoveryListCtrl.InsertItem(&fillItem);

                    if (CertName.IsEmpty()){
                        NoCertName.ReleaseBuffer();
                    } else {
                        CertName.ReleaseBuffer();
                    }

                    if ( fillItem.iItem != -1 ){

                        if (CertHash.IsEmpty()){
                            fillItem.pszText = NULL;
                        } else {
                            fillItem.pszText = CertHash.GetBuffer(CertHash.GetLength() + 1);
                        }

                        fillItem.iSubItem = 1;
                        m_RecoveryListCtrl.SetItem(&fillItem);
                    
                        if (!CertHash.IsEmpty()){
                            CertHash.ReleaseBuffer();
                        }
                    }

               }
            }
        }
    }
    catch(...){
        m_UserListCtrl.DeleteAllItems( );
        m_RecoveryListCtrl.DeleteAllItems( );
        if ( EnableAdd ){
            *EnableAdd = FALSE;
        }
    }

}

DWORD
USERLIST::GetCertNameFromCertContext(
    PCCERT_CONTEXT CertContext,
    LPTSTR * UserDispName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the user name from the certificate
// Arguments:
//      CertContext -- Cert Context
//      UserCertName -- User Common Name
//                                  ( Caller is responsible to delete this memory using delete [] )
//  Return Value:
//      ERROR_SUCCESS if succeed.
//      If No Name found. "USER_UNKNOWN is returned".
//
//////////////////////////////////////////////////////////////////////
{
    DWORD   NameLength;
    DWORD   UserNameBufLen = 0;
    DWORD   BlobLen = 0;
    PCERT_EXTENSION AlterNameExt = NULL;
    BOOL    b;
    LPTSTR  DNSName = NULL;
    LPTSTR  UPNName = NULL;
    LPTSTR  CommonName = NULL;

    if ( NULL == UserDispName ){
        return ERROR_SUCCESS;
    }

    *UserDispName = NULL;

    AlterNameExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME2,
            CertContext->pCertInfo->cExtension,
            CertContext->pCertInfo->rgExtension
            );

    if (AlterNameExt){

        //
        // Find the alternative name
        //

        b = CryptDecodeObject(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                szOID_SUBJECT_ALT_NAME ,
                AlterNameExt->Value.pbData,
                AlterNameExt->Value.cbData,
                0,
                NULL,
                &BlobLen
                );
        if (b){

            //
            // Let's decode it
            //

            CERT_ALT_NAME_INFO *AltNameInfo = NULL;

            AltNameInfo = (CERT_ALT_NAME_INFO *) new BYTE[BlobLen];

            if (AltNameInfo){

                b = CryptDecodeObject(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        szOID_SUBJECT_ALT_NAME,
                        AlterNameExt->Value.pbData,
                        AlterNameExt->Value.cbData,
                        0,
                        AltNameInfo,
                        &BlobLen
                        );
                if (b){

                    //
                    // Now search for the UPN, SPN, DNS, EFS name
                    //

                    DWORD   cAltEntry = AltNameInfo->cAltEntry;
                    DWORD   ii = 0;

                    while (ii < cAltEntry){
                        if ((AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_OTHER_NAME ) &&
                             !strcmp(szOID_NT_PRINCIPAL_NAME, AltNameInfo->rgAltEntry[ii].pOtherName->pszObjId)
                            ){

                            //
                            // We found the UPN name
                            //

                            CERT_NAME_VALUE* CertUPNName = NULL;

                            b = CryptDecodeObject(
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                    AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                    0,
                                    NULL,
                                    &BlobLen
                                    );
                            if (b){

                                CertUPNName = (CERT_NAME_VALUE *) new BYTE[BlobLen];
                                if (CertUPNName){
                                    b = CryptDecodeObject(
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            X509_UNICODE_ANY_STRING,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.pbData,
                                            AltNameInfo->rgAltEntry[ii].pOtherName->Value.cbData,
                                            0,
                                            CertUPNName,
                                            &BlobLen
                                            );
                                    if (b){
                                        UPNName = (LPTSTR)new BYTE[CertUPNName->Value.cbData + sizeof(WCHAR)];
                                        if (UPNName){
                                            wcscpy(UPNName, (LPCTSTR) CertUPNName->Value.pbData);
                                        }
                                    }
                                    delete [] CertUPNName;
                                    if (UPNName){

                                        //
                                        // Got the UPN name. Stop searching.
                                        //
                                        break;
                                    }
                                }
                            }

                                            
                        } else {

                            //
                            // Check for other alternative name
                            //

                            if (AltNameInfo->rgAltEntry[ii].dwAltNameChoice == CERT_ALT_NAME_DNS_NAME){
                                DNSName = AltNameInfo->rgAltEntry[ii].pwszDNSName;
                            } 

                        }

                        ii++;

                    }

                    if ( NULL == UPNName ){

                        //
                        // No UPN name, let's get the other option
                        //

                        if (DNSName){
                            UPNName = (LPTSTR)new TCHAR[wcslen( DNSName ) + 1];
                            if (UPNName){
                                wcscpy(UPNName, DNSName);
                            }
                        }

                    }
                }
                delete [] AltNameInfo;
            }

        }
    }


    NameLength = CertGetNameString(
                                CertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                NULL,
                                0
                                );

    if ( NameLength > 1){

        //
        // The display name exist. Go get the display name.
        //

        CommonName = new TCHAR[NameLength];
        if ( NULL == CommonName ){
            if (UPNName){
                delete [] UPNName;
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        UserNameBufLen = NameLength;
        NameLength = CertGetNameString(
                                    CertContext,
                                    CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                    0,
                                    NULL,
                                    CommonName,
                                    UserNameBufLen
                                    );

        ASSERT (NameLength == UserNameBufLen);

    } 


    if (CommonName || UPNName){

        NameLength = 3;
        if (CommonName){
            NameLength += wcslen(CommonName);
        }
        if (UPNName){
            NameLength += wcslen(UPNName);
        }
        

        *UserDispName = new TCHAR[NameLength];
        if (CommonName){
            wcscpy(*UserDispName, CommonName);
            if (UPNName){
                wcscat(*UserDispName, L"(");
                wcscat(*UserDispName, UPNName);
                wcscat(*UserDispName, L")");
            }
        } else {
            wcscpy(*UserDispName, UPNName);
        }

        if (CommonName){
            delete [] CommonName;
        }
        if (UPNName){
            delete [] UPNName;
        }
        return ERROR_SUCCESS;
    } 

    try {

        CString UnknownCertName;

        UnknownCertName.LoadString(IDS_NOCERTNAME);

        UserNameBufLen = UnknownCertName.GetLength();

        *UserDispName = new TCHAR[UserNameBufLen + 1];
        _tcscpy( *UserDispName, UnknownCertName);

    }
    catch (...){
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;

}

void USERLIST::OnAdd() 
{
    CRYPTUI_SELECTCERTIFICATE_STRUCTW cryptUI;
    HCERTSTORE otherStore;
    HCERTSTORE trustedStore;
    HCERTSTORE memStore;
    HCERTSTORE localStore[2];
    PCCERT_CONTEXT selectedCert;
    CString DlgTitle;
    CString DispText;
    LPTSTR  UserDispName;
    HRESULT hr;
    DWORD   rc;
    DWORD   StoreNum = 0;
    DWORD   StoreIndex = 0xffffffff;
    BOOL    EfsEkuExist = FALSE;
    DWORD   ii;
    BOOL    ContinueProcess = TRUE;

    otherStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            OTHERPEOPLE
                            );

    trustedStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            TRUSTEDPEOPLE
                            );

    if (otherStore) {
        localStore[0] = otherStore;
        StoreNum++;
    }
    if (trustedStore) {
        localStore[StoreNum] = trustedStore;
        StoreNum++;
    }

    memStore = CertOpenStore(
                         CERT_STORE_PROV_MEMORY,
                         0,
                         0,
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                         NULL
                         );
    if (!memStore) {

        CString ErrMsg;
        TCHAR   ErrCode[16];
        

        _ltot(GetLastError(), ErrCode, 10 );
        AfxFormatString1( ErrMsg, IDS_INTERNALERROR, ErrCode );
        MessageBox(ErrMsg);

        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
        return;
    }

    //
    // Let's put it into a memory store to eliminate the redundancy
    //

    ii = 0;
    while ( (ii < StoreNum) && ContinueProcess ) {

        PCCERT_CONTEXT pCertContext = NULL;

        while (pCertContext = CertEnumCertificatesInStore(
                              localStore[ii],              
                              pCertContext     
                              ))  {

            if (!CertAddCertificateLinkToStore(
                      memStore,                
                      pCertContext,          
                      CERT_STORE_ADD_USE_EXISTING,               
                      NULL         
                      )){

                CString ErrMsg;
                TCHAR   ErrCode[16];
                
        
                _ltot(GetLastError(), ErrCode, 10 );
                AfxFormatString1( ErrMsg, IDS_INTERNALERROR, ErrCode );
                MessageBox(ErrMsg);
                ContinueProcess = FALSE;
                break;
            }

        } 
        ii++;
    }

    if (!ContinueProcess) {
        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
        CertCloseStore( memStore, 0 );
        return;
    }

    if (StoreNum != 0) {
        RtlZeroMemory(&cryptUI, sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCTW));
        cryptUI.dwSize = sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCTW);
	    cryptUI.dwFlags = CRYPTUI_SELECTCERT_ADDFROMDS;
        cryptUI.cDisplayStores = 1; 
        cryptUI.rghDisplayStores = &memStore;
        cryptUI.pFilterCallback = EfsFilter;
        cryptUI.dwDontUseColumn = CRYPTUI_SELECT_LOCATION_COLUMN | CRYPTUI_SELECT_ISSUEDBY_COLUMN | CRYPTUI_SELECT_INTENDEDUSE_COLUMN;
        if (DlgTitle.LoadString(IDS_DLGTITLE)){
            cryptUI.szTitle = (LPCWSTR) DlgTitle.GetBuffer(DlgTitle.GetLength() + 1);
        }
        if (DispText.LoadString(IDS_DISPTEXT)){
            cryptUI.szDisplayString = (LPCWSTR) DispText.GetBuffer(DispText.GetLength() + 1);
        }
        selectedCert = CryptUIDlgSelectCertificateW(&cryptUI);
        if ( selectedCert ){

            PCCERT_CHAIN_CONTEXT pChainContext;

            //
            // Let's first see if the cert is from DS, if Yes, add the EFS EKU first if no EKU.
            //

            StoreIndex = CertInStore(localStore, StoreNum, selectedCert);

            if (StoreIndex >= StoreNum){

                //
                // The cert is not in the local stores. Let's see if we need add the EKU or not. 
                //

                EfsEkuExist = EfsFilter(selectedCert, NULL, NULL);
                if (!EfsEkuExist) {

                    //
                    // Let's add the EFS EKU
                    //

                    CTL_USAGE    EfsEkuUsage;
                    DWORD        cbEncoded;
                    void         *pbEncoded;
                    CRYPT_DATA_BLOB EfsEkuBlob;

                    EfsEkuUsage.cUsageIdentifier = 1; // Only adding EFS EKU
                    EfsEkuUsage.rgpszUsageIdentifier = &EfsOidlpstr;
                    if(!CryptEncodeObjectEx(
                            X509_ASN_ENCODING,
                            szOID_ENHANCED_KEY_USAGE,
                            &EfsEkuUsage,
		                    CRYPT_ENCODE_ALLOC_FLAG,
		                    NULL, // Use LocalFree
                            &pbEncoded,
                            &cbEncoded
                        )){

                        //
                        // Failed to encode the EFS EKU
                        //
                        CString ErrMsg;
                        TCHAR   ErrCode[16];
                        
            
                        ContinueProcess = FALSE;
                        _ltot(GetLastError(), ErrCode, 10 );
                        AfxFormatString1( ErrMsg, IDS_ADDEFSEKUFAIL, ErrCode );
                        MessageBox(ErrMsg);


                    } else {
                        //
                        // Now let's add the EKU to the cert
                        //

                        EfsEkuBlob.cbData=cbEncoded;
                        EfsEkuBlob.pbData=(BYTE *)pbEncoded;
                        
                        if(!CertSetCertificateContextProperty(
                                selectedCert,
                                CERT_ENHKEY_USAGE_PROP_ID,
                                0,
                                &EfsEkuBlob)){
    
                            //
                            // Failed to add the EFS EKU
                            //
    
                            CString ErrMsg;
                            TCHAR   ErrCode[16];
                            
                
                            ContinueProcess = FALSE;
                            _ltot(GetLastError(), ErrCode, 10 );
                            AfxFormatString1( ErrMsg, IDS_ADDEFSEKUFAIL, ErrCode );
                            MessageBox(ErrMsg);
    
    
                        }
                    }


                }


            }

            //
            // Let's validate the cert first
            //

            if (ContinueProcess && CertGetCertificateChain (
                                        HCCE_CURRENT_USER,
                                        selectedCert,
                                        NULL,
                                        NULL,
                                        &m_CertChainPara,
                                        CERT_CHAIN_REVOCATION_CHECK_CHAIN,
                                        NULL,
                                        &pChainContext
                                        )) {

                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[ pChainContext->cChain - 1 ];
                PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[ pChain->cElement - 1 ];
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;
                BOOL ContinueAdd = TRUE;

                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;


                if (0 == (dwErrorStatus & ~CERT_TRUST_REVOCATION_STATUS_UNKNOWN)) {

                    

                    //
                    // The validation succeed. If the cert is from the DS (not in the store we opened), we will put it
                    // in the my Other People's store
                    //

                    
                    if (StoreIndex >= StoreNum) {

                        //
                        // The cert is not in our local stores. Add it to the other people
                        //

                        if (otherStore) {
                            if(!CertAddCertificateContextToStore(
                                   otherStore,
                                   selectedCert,
                                   CERT_STORE_ADD_NEW,
                                   NULL) ) {
                
                                //
                                // The error code is only for debug.
                                // If we failed to add the cert to other People store,
                                // it is fine to continue
                                //

                                rc = GetLastError();
                
                            }
                        }

                    }

                } else {

                    //
                    // The cert validation failed, as the user if we will accept the cert. If yes, the cert
                    // will be added to my TrustedPeople.
                    //

                    if (((dwErrorStatus & ~CERT_TRUST_REVOCATION_STATUS_UNKNOWN) == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned) {

                        //
                        // A self signed cert. Ask the user if he would like to accept.
                        // If it is already in the trusted store, we can skip the pop up.
                        //


                        DWORD   StoreIndex;


                        if (trustedStore) {
                            StoreIndex = CertInStore(&trustedStore, 1, selectedCert);
                        }

                        if (StoreIndex >= 1) {

                            CString ErrMsg;
                            TCHAR   ErrCode[16];
                            int     buttonID;

                            _ltot(GetLastError(), ErrCode, 10 );
                            AfxFormatString1( ErrMsg, IDS_ACCEPTSELFCERT, ErrCode );
                            buttonID = MessageBox(ErrMsg, NULL, MB_ICONQUESTION | MB_YESNO);
                            if (IDYES == buttonID) {
    
                                //
                                // User Accepted the cert.
                                //
                                if (trustedStore) {
                                    if(!CertAddCertificateContextToStore(
                                           trustedStore,
                                           selectedCert,
                                           CERT_STORE_ADD_NEW,
                                           NULL) ) {
                        
                                        //
                                        // The error code is only for debug.
                                        // If we failed to add the cert to other People store,
                                        // it is fine to continue
                                        //
        
                                        rc = GetLastError();
                        
                                    }
                                }
    
                            } else {
    
                                //
                                // User declined the cert.
                                //
    
                                ContinueAdd = FALSE;
                            }
                        }
                

                    } else {

                        //
                        //  Let's get the error code of the chain building.
                        //

                        CERT_CHAIN_POLICY_PARA PolicyPara;
                        CERT_CHAIN_POLICY_STATUS PolicyStatus;

                        ContinueAdd = FALSE;

                        RtlZeroMemory(&PolicyPara, sizeof(CERT_CHAIN_POLICY_PARA));
                        RtlZeroMemory(&PolicyStatus, sizeof(CERT_CHAIN_POLICY_STATUS));

                        PolicyPara.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
                        PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

                        if (CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_BASE,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus
                            ) && PolicyStatus.dwError ) {

                            //
                            // Display the error to the user.
                            //

                            DWORD len;
                            LPWSTR DisplayBuffer;
                        
                            len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL, PolicyStatus.dwError, 0,
                                    (LPWSTR)&DisplayBuffer, 0, NULL);
    
    
                            if (len && DisplayBuffer) {
    
                                MessageBox(DisplayBuffer);
        
                                LocalFree(DisplayBuffer);
                            }
                        }
                        

                    }


                }

                CertFreeCertificateChain( pChainContext );

                if (ContinueAdd) {
                    hr = GetCertNameFromCertContext(selectedCert, &UserDispName);
                    if ( ERROR_SUCCESS == hr ){
        
                        EFS_CERTIFICATE_BLOB CertBlob;
        
                        CertBlob.cbData = selectedCert->cbCertEncoded;
                        CertBlob.pbData = selectedCert->pbCertEncoded;
                        CertBlob.dwCertEncodingType = selectedCert->dwCertEncodingType;
                        hr = m_Users.Add(
                                        UserDispName,
                                        (PVOID)&CertBlob,
                                        NULL,
                                        USERADDED,
                                        (PVOID)selectedCert
                                        );
        
                        if ( (ERROR_SUCCESS != hr) && (CRYPT_E_EXISTS != hr) ){
        
                            //
                            // Error in adding the user
                            //
        
                            CertFreeCertificateContext(selectedCert);
                            selectedCert = NULL;
        
                        } else {

                            //
                            // We could just insert the items here to improve the performace.
                            // But we don't have the time right now. We could fix this later
                            // if performance is a problem here.
                            //

                            m_UserListCtrl.DeleteAllItems( );
                            SetUpListBox(NULL);

                            if ( hr == ERROR_SUCCESS ){

                                //
                                // UserDispName is used in m_Users.Add
                                //

                                UserDispName = NULL;
                            }

/* This is the old code when we have the single list.        
                            //
                            // Add the user to the list box.
                            //
                            if ( hr == ERROR_SUCCESS ){
                                
                               if (m_UsersList.AddString(UserDispName) < 0){
        
                                    //
                                    // Error to add to the list box
                                    //
        
                                    m_Users.Remove(UserDispName);
                                }

                                UserDispName = NULL;
        
                            } else {
        
                                //
                                // Let's check if we need to add this to the list box.
                                //
                                if (m_UsersList.FindStringExact( 0, UserDispName ) < 0){
        
                                    //
                                    // Not found
                                    //
                                    
                                    if (m_UsersList.AddString(UserDispName) < 0){
        
                                        //
                                        // Error to add to the list box
                                        //
        
                                        m_Users.Remove(UserDispName);
                                    }
        
                                }
                                
                            }
*/
                        }
                        if (UserDispName){
                            delete [] UserDispName; 
                        }
        
                    } else {
                        CertFreeCertificateContext(selectedCert);
                    }
                }
            } else {

                CString ErrMsg;
                TCHAR   ErrCode[16];

                CertFreeCertificateContext(selectedCert);
        
                if (ContinueProcess) {

                    //
                    // The error has not been processed.
                    //

                    _ltot(GetLastError(), ErrCode, 10 );
                    AfxFormatString1( ErrMsg, IDS_COULDNOTVERIFYCERT, ErrCode );
                    MessageBox(ErrMsg);
                }
        
            }

        } 
        
        if (!DlgTitle.IsEmpty()){
            DlgTitle.ReleaseBuffer();
        }
        if (!DispText.IsEmpty()){
            DispText.ReleaseBuffer();
        }
        if (otherStore) {
            CertCloseStore( otherStore, 0 );
        }
        if (trustedStore) {
            CertCloseStore( trustedStore, 0 );
        }
    }

    CertCloseStore( memStore, 0 );

    return;
}

DWORD USERLIST::TryGetBetterNameInCert(PEFS_HASH_BLOB HashData, LPTSTR *UserName)
{

    HCERTSTORE localStore;
    PCCERT_CONTEXT pCertContext;
    DWORD   retCode;


    //
    // We will add the remote case later
    //

    localStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                            TRUSTEDPEOPLE
                            );

    if (localStore != NULL) {

        //
        // Let's try to the cert in the store
        //
        pCertContext = CertFindCertificateInStore( localStore,
                                                   CRYPT_ASN_ENCODING,
                                                   0,
                                                   CERT_FIND_HASH,
                                                   (CRYPT_HASH_BLOB *)HashData,
                                                   NULL
                                                   );
        if ( pCertContext ){

            retCode = GetCertNameFromCertContext(
                            pCertContext,
                            UserName
                            );
            CertFreeCertificateContext(pCertContext);

        }
	else { 
	    retCode = GetLastError();
	}

        CertCloseStore( localStore, 0 );

    } else {

        retCode = GetLastError();

    }   
    
    return retCode;

}

DWORD USERLIST::CertInStore(HCERTSTORE *pStores, DWORD StoreNum, PCCERT_CONTEXT selectedCert)
{
    DWORD ii = 0;
    PCCERT_CONTEXT pCert = NULL;

    while (ii < StoreNum) {
        pCert = CertFindCertificateInStore(
                    pStores[ii],
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    0,
                    CERT_FIND_EXISTING,
                    selectedCert,
                    pCert
                    );
        if (pCert) {

            //
            // We found it.
            //
            CertFreeCertificateContext(pCert);
            break;
        }
        ii++;
    }

    return ii; 
}

void USERLIST::OnSetfocusListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{
    int ItemPos;

    ShowRemove();

    ItemPos = m_UserListCtrl.GetNextItem( -1, LVNI_SELECTED );
    if ( ItemPos == -1 ){
         m_UserListCtrl.SetItem(0, 0, LVIF_STATE, NULL, 0, LVIS_SELECTED, LVIS_SELECTED, 0);

    }
	
	*pResult = 0;
}

void USERLIST::OnKillfocusListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{

    ShowRemove();
	
	*pResult = 0;

}

void USERLIST::OnItemchangedListuser(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    ShowRemove();
	
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\users.h ===
// Users.h: interface for the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
#define AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <winefs.h>

#define USERINFILE  1
#define USERADDED   2
#define USERREMOVED 4

typedef struct USERSONFILE {
    USERSONFILE *       Next;
    DWORD               Flag; // If the item is added, removed or existed in the file
    PVOID               Cert; // Either the hash or the Blob
    PVOID               Context; // Cert Context. To be released when the item is deleted.
    LPTSTR              UserName;
    PSID                UserSid;
} USERSONFILE, *PUSERSONFILE;

//
// This class supports single thread only.
//

class CUsers  
{
public:
	CUsers();
	virtual ~CUsers();

public:
	void Clear(void);
	DWORD GetUserRemovedCnt();

	DWORD GetUserAddedCnt();

    DWORD   Add(
                LPTSTR UserName,
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PVOID Context = NULL
              );

    DWORD   Add( CUsers &NewUsers );

    PUSERSONFILE RemoveItemFromHead(void);

    DWORD   Remove(
                LPCTSTR UserName
                );
 
    PVOID   StartEnum();

    PVOID   GetNextUser(
                PVOID Token, 
                CString &UserName,
                CString &CertHash
                );

	PVOID GetNextChangedUser(
                PVOID Token, 
                LPTSTR *UserName,
                PSID *UserSid, 
                PVOID *CertData, 
                DWORD *Flag
                );

	void ConvertHashToStr(
                PBYTE pHashData,
                DWORD cbData,
                LPWSTR OutHashStr
                );
    

private:
	DWORD m_UserAddedCnt;
	DWORD m_UserRemovedCnt;
    PUSERSONFILE    m_UsersRoot;

};

#endif // !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\encrypt\users.cpp ===
// Users.cpp: implementation of the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "efsadu.h"
#include "Users.h"
#include <wincrypt.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUsers::CUsers()
{
    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;
}

//////////////////////////////////////////////////////////////////////
// Walk through the chain to free the memory
//////////////////////////////////////////////////////////////////////

CUsers::~CUsers()
{
    Clear();
}

PUSERSONFILE
CUsers::RemoveItemFromHead(void)
{
    PUSERSONFILE PItem = m_UsersRoot;
    if (m_UsersRoot){
        m_UsersRoot = m_UsersRoot->Next;
        if ((PItem->Flag & USERADDED) && !(PItem->Flag & USERREMOVED)){
            m_UserAddedCnt--;
        }
        if ((PItem->Flag & USERINFILE) && (PItem->Flag & USERREMOVED)){
            m_UserRemovedCnt--;
        }
    }
    return PItem;
}

DWORD
CUsers::Add( CUsers &NewUsers )
{
    PUSERSONFILE NewItem;

    while (NewItem = NewUsers.RemoveItemFromHead()){
        PUSERSONFILE    TmpItem = m_UsersRoot;
        
        while ( TmpItem ){

            if ((NewItem->UserName && TmpItem->UserName && !_tcsicmp(NewItem->UserName, TmpItem->UserName)) ||
                 ((NULL == NewItem->UserName) && (TmpItem->UserName == NULL))){

                //
                // User exist
                //

                if ( TmpItem->Flag & USERREMOVED ){

                    if ( TmpItem->Flag & USERADDED ){

                        ASSERT(!(TmpItem->Flag & USERINFILE));

                        //
                        //    User added and removed
                        //
                        m_UserAddedCnt++;

                    } else if ( TmpItem->Flag & USERINFILE ){

                        //
                        //    User added and removed
                        //
                        m_UserRemovedCnt--;

                    }
                    TmpItem->Flag &= ~USERREMOVED;
                }

                //
                // The caller will count on CUsers to release the memory
                //

                if (NewItem->UserName){
                    delete [] NewItem->UserName;
                }
                if ( NewItem->Context ) {
                    CertFreeCertificateContext((PCCERT_CONTEXT)NewItem->Context);
                }
                delete [] NewItem->Cert;
                if (NewItem->UserSid){
                    delete [] NewItem->UserSid;
                }
                delete NewItem;
                NewItem = NULL;                
                break;
            }
            TmpItem = TmpItem->Next;
        }

        if (NewItem ){ 
            //
            // New item. Insert into the head.
            //

            NewItem->Next = m_UsersRoot;
            m_UsersRoot = NewItem;
            m_UserAddedCnt++;
        }

    }

    return ERROR_SUCCESS;
}

DWORD
CUsers::Add(
    LPTSTR UserName,
    PVOID UserCert, 
    PSID UserSid, /* = NULL */
    DWORD Flag, /* = USERINFILE */
    PVOID Context /* = NULL */
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Create an item for a user
// Arguments:
//      UserName -- User's name
//      UserCert -- User's certificate blob or hash
//      UserSid -- User's ID. Can be NULL
//      Flag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      NO_ERROR if succeed.
//      Will throw exception if memory allocation fails. ( From new.)
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE UserItem;
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    PEFS_CERTIFICATE_BLOB CertBlob;
    PEFS_HASH_BLOB  CertHashBlob;
    DWORD   CertSize;
    DWORD   SidSize;

    if ( !UserCert ){
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT ( (( Flag & USERADDED ) || ( Flag & USERINFILE )) &&
                       ( (Flag & (USERADDED | USERINFILE)) != (USERADDED | USERINFILE)));


    //
    // If the user already in the memory, no new item is to be created except for unknown user
    //

    while ( TmpUserItem ){
        if ( (UserName && TmpUserItem->UserName && !_tcsicmp(UserName, TmpUserItem->UserName)) ||
              ((NULL == UserName) && (TmpUserItem->UserName == NULL))){

            //
            // User exist
            //

            if ( TmpUserItem->Flag & USERREMOVED ){

                if ( TmpUserItem->Flag & USERADDED ){

                    ASSERT(!(TmpUserItem->Flag & USERINFILE));

                    //
                    //    User added and removed
                    //
                    m_UserAddedCnt++;

                } else if ( TmpUserItem->Flag & USERINFILE ){

                    //
                    //    User added and removed
                    //
                    m_UserRemovedCnt--;

                }
                TmpUserItem->Flag &= ~USERREMOVED;
            }

            //
            // The caller will count on CUsers to release 
            // the context if the call returns CRYPT_E_EXISTS. This is just for
            // performance reason.
            //
/*
            if (UserName){
                delete [] UserName;
            }
*/
            if ( Context ) {
                CertFreeCertificateContext((PCCERT_CONTEXT)Context);
                Context = NULL;
            }
            return CRYPT_E_EXISTS;
        }
        TmpUserItem = TmpUserItem->Next;
    }
    
    try {
        UserItem = new USERSONFILE;
        if ( NULL == UserItem ){
            AfxThrowMemoryException( );
        }

        UserItem->Next = NULL;

        //
        // In case exception raised, we can call delete.
        // Delete NULL is OK, but random data is not OK.
        //

        UserItem->UserSid = NULL;
        UserItem->Cert = NULL;
        UserItem->Context = NULL;

        if ( UserSid ){
            SidSize = GetLengthSid( UserSid );
            if (  SidSize > 0 ){
                UserItem->UserSid = new BYTE[SidSize];
                if ( NULL == UserItem->UserSid ){
                    AfxThrowMemoryException( );
                }
                if ( !CopySid(SidSize, UserItem->UserSid, UserSid)){
                    delete [] UserItem->UserSid;
                    delete UserItem;
                    return GetLastError();
                }
                
            } else {
                delete UserItem;
                return GetLastError();
            }
        } else {
            UserItem->UserSid = NULL;
        }
 
        if ( Flag & USERINFILE ){

            //
            // The info is from the file. Use the hash structure
            //

            CertHashBlob = ( PEFS_HASH_BLOB ) UserCert;
            CertSize = sizeof(EFS_HASH_BLOB) + CertHashBlob->cbData;
            UserItem->Cert = new BYTE[CertSize];
            if ( NULL == UserItem->Cert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_HASH_BLOB)UserItem->Cert)->cbData = CertHashBlob->cbData;
            ((PEFS_HASH_BLOB)UserItem->Cert)->pbData = (PBYTE)(UserItem->Cert) + sizeof(EFS_HASH_BLOB);
            memcpy(((PEFS_HASH_BLOB)UserItem->Cert)->pbData, 
                   CertHashBlob->pbData,
                   CertHashBlob->cbData
                  );
        } else {

            //
            // The info is from the user picked cert. Use Cert Blob structure
            //

            CertBlob = ( PEFS_CERTIFICATE_BLOB ) UserCert;
            CertSize = sizeof(EFS_CERTIFICATE_BLOB) + CertBlob->cbData;
            UserItem->Cert = new BYTE[CertSize];
            if ( NULL == UserItem->Cert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->cbData = CertBlob->cbData;
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->dwCertEncodingType = CertBlob->dwCertEncodingType;
            ((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->pbData = (PBYTE)(UserItem->Cert) + sizeof(EFS_CERTIFICATE_BLOB);
            memcpy(((PEFS_CERTIFICATE_BLOB)UserItem->Cert)->pbData, 
                   CertBlob->pbData,
                   CertBlob->cbData
                  );

        }
 
        UserItem->UserName = UserName;
        UserItem->Context = Context;
        UserItem->Flag = Flag;
        if ( Flag & USERADDED ){
            m_UserAddedCnt ++;
        }
    }
    catch (...) {
        delete [] UserItem->UserSid;
        delete [] UserItem->Cert;
        delete UserItem;
        AfxThrowMemoryException( );
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    //
    // Add to the head
    //

    if ( NULL != m_UsersRoot ){
        UserItem->Next = m_UsersRoot;
    }
    m_UsersRoot = UserItem;

    return NO_ERROR;
}

DWORD
CUsers::Remove(
    LPCTSTR UserName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Remove a user from the list. Actually just mark for remove.
// Arguments:
//      UserName -- User's name
//  Return Value:
//      NO_ERROR if succeed.
//      ERROR_NOT_FOUND if the user cannot be found.
// 
//////////////////////////////////////////////////////////////////////
{
    PUSERSONFILE TmpUserItem = m_UsersRoot;

    BOOL    UserMatched =FALSE;

    while ( TmpUserItem ){
        if (((NULL==UserName) && ( NULL == TmpUserItem->UserName)) || 
            ( UserName && TmpUserItem->UserName && !_tcsicmp(UserName, TmpUserItem->UserName))){

            //
            // User exist, mark it for remove
            //

            if ( TmpUserItem->Flag & USERINFILE ){
                m_UserRemovedCnt++;
            } else if ( TmpUserItem->Flag & USERADDED ) {
                m_UserAddedCnt--;
            }
            TmpUserItem->Flag |= USERREMOVED;
            return NO_ERROR;
        }
        TmpUserItem = TmpUserItem->Next;
    }
    return ERROR_NOT_FOUND;
}

PVOID
CUsers::StartEnum()
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Prepare for GetNextUser
// Arguments:
//
//  Return Value:
//      A pointer used for GetNextUser
// 
//////////////////////////////////////////////////////////////////////
{
    return ((PVOID)m_UsersRoot);
}

PVOID
CUsers::GetNextUser(
    PVOID Token, 
    CString &UserName,
    CString &CertHash
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get next user in the list.(Not removed).
// Arguments:
//      UserName -- Next User's name
//      CertHash -- Certificate Thumbprinter
//      Token -- A pointer returned by previous GetNextUser or StartEnum. 
// Return Value:
//      A pointer for GetNextUser()
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE   TmpItem = (PUSERSONFILE) Token;
    PVOID   RetPointer = NULL;

    while ( TmpItem ){

        if ( TmpItem->Flag & USERREMOVED ){
            TmpItem = TmpItem->Next;
            continue;
        }

        try{    
            LPWSTR     HashString = NULL;

            UserName = TmpItem->UserName;

            if (TmpItem->Flag & USERINFILE){

                PEFS_HASH_BLOB UserHashBlob;

                UserHashBlob = (PEFS_HASH_BLOB)TmpItem->Cert;
                HashString = new WCHAR[((((UserHashBlob->cbData + 1)/2) * 5) + 1)];
                if (HashString) {
                    ConvertHashToStr(UserHashBlob->pbData, UserHashBlob->cbData, HashString);
                }

            } else if ( TmpItem->Context ){

                DWORD cbHash;
                PBYTE pbHash;

                if (CertGetCertificateContextProperty(
                             (PCCERT_CONTEXT)TmpItem->Context,
                             CERT_HASH_PROP_ID,
                             NULL,
                             &cbHash
                             )) {

                    pbHash = (PBYTE)new BYTE[cbHash];

                    if (pbHash != NULL) {

                        if (CertGetCertificateContextProperty(
                                     (PCCERT_CONTEXT)TmpItem->Context,
                                     CERT_HASH_PROP_ID,
                                     pbHash,
                                     &cbHash
                                     )) {

                            HashString = new WCHAR[((((cbHash + 1)/2) * 5) + 1)];
                            if (HashString) {
                                ConvertHashToStr(pbHash, cbHash, HashString);
                            }
                        }
                      
                        delete [] pbHash;

                    }
                }

            }
            
            CertHash = HashString;
            if (HashString){
                delete [] HashString;
            }
            RetPointer = TmpItem->Next;
        }
        catch (...){

            //
            // Out of memory
            //

            TmpItem = NULL;
            RetPointer = NULL;
        }
        break;
    }

    if ( NULL == TmpItem ){
        UserName.Empty();
        CertHash.Empty();
    }
    return RetPointer;

}

DWORD CUsers::GetUserAddedCnt()
{
    return m_UserAddedCnt;
}

DWORD CUsers::GetUserRemovedCnt()
{
    return m_UserRemovedCnt;
}

PVOID
CUsers::GetNextChangedUser(
    PVOID Token, 
    LPTSTR * UserName,
    PSID * UserSid, 
    PVOID * CertData, 
    DWORD * Flag
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the info for changed users. This method is not well behaved in the
//  sense of OOP. It exposes internal pointers to the ouside world. The gain
//  is performance. At this moment, CUsers is a supporting class and used only
//  by USERLIST and CAddSheet (single thread). We can make USERLIST a 
//  friend of CUsers if such concerns are raised in the future or reimplement this. 
//  The same issue applies to the enumerate methods.
//
// Arguments:
//      Token -- A pointer to the item returned in previous GetNextChangedUser or StartEnum.
//      UserName -- User's name
//      CertData -- User's certificate blob or hash
//      UserSid -- User's ID. Can be NULL
//      Flag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      Next item pointer.
// 
//////////////////////////////////////////////////////////////////////
{
    BOOL    ChangedUserFound = FALSE;

    while ( Token ){

        *Flag = ((PUSERSONFILE) Token)->Flag;

        if ( ( *Flag & USERADDED ) && !( *Flag & USERREMOVED )){

            //
            // The user is to to be added to the file
            //

            *Flag = USERADDED;
            ChangedUserFound = TRUE;

        } else if ( ( *Flag & USERREMOVED ) && ( *Flag & USERINFILE)){

            //
            // The user is to be removed from the file
            //

            *Flag = USERREMOVED;
            ChangedUserFound = TRUE;

        }

        if ( ChangedUserFound ){

            *UserName = ((PUSERSONFILE) Token)->UserName;
            *UserSid = ((PUSERSONFILE) Token)->UserSid;
            *CertData = ((PUSERSONFILE) Token)->Cert;
            return ((PUSERSONFILE) Token)->Next;

        } else {

            Token = ((PUSERSONFILE) Token)->Next;

        }

    }

    *UserName = NULL;
    *UserSid = NULL;
    *CertData = NULL;
    *Flag = 0;
    return NULL;
}

void CUsers::Clear()
{

    PUSERSONFILE TmpUserItem = m_UsersRoot;
    while (TmpUserItem){
        m_UsersRoot = TmpUserItem->Next;
        delete [] TmpUserItem->UserName;
        delete [] TmpUserItem->Cert;
        if (TmpUserItem->UserSid){
            delete [] TmpUserItem->UserSid;
        }
        if (TmpUserItem->Context){
            CertFreeCertificateContext((PCCERT_CONTEXT)TmpUserItem->Context);
        }
        delete TmpUserItem;
        TmpUserItem = m_UsersRoot;
    }

    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;

}

void CUsers::ConvertHashToStr(
    PBYTE pHashData,
    DWORD cbData,
    LPWSTR OutHashStr
    )
{

    DWORD Index = 0;
    BOOLEAN NoLastZero = FALSE;

    for (; Index < cbData; Index+=2) {

        BYTE HashByteLow = pHashData[Index] & 0x0f;
        BYTE HashByteHigh = (pHashData[Index] & 0xf0) >> 4;

        OutHashStr[Index * 5/2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
        OutHashStr[Index * 5/2 + 1] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);

        if (Index + 1 < cbData) {
            HashByteLow = pHashData[Index+1] & 0x0f;
            HashByteHigh = (pHashData[Index+1] & 0xf0) >> 4;
    
            OutHashStr[Index * 5/2 + 2] = HashByteHigh > 9 ? (WCHAR)(HashByteHigh - 9 + 0x40): (WCHAR)(HashByteHigh + 0x30);
            OutHashStr[Index * 5/2 + 3] = HashByteLow > 9 ? (WCHAR)(HashByteLow - 9 + 0x40): (WCHAR)(HashByteLow + 0x30);
    
            OutHashStr[Index * 5/2 + 4] = L' ';

        } else {
            OutHashStr[Index * 5/2 + 2] = 0;
            NoLastZero = TRUE;
        }

    }

    if (!NoLastZero) {
        OutHashStr[Index*5/2] = 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\aboutwep\res.h ===
/**********************/
/* AboutWEP Resources */
/**********************/

#define ID_DLG_ABOUT     100
#define ID_DLG_ABOUT_EGA 101

#define ID_ICON_APP    201
#define ID_NAME_APP    202
#define ID_NAME_CREDIT 203

#define ID_USER_MSFT   301

#define ID_BMP_CLR     666
#define ID_BMP_BAW     999


#define dxpMSFT       260     /* Width  of MSFT bitmap */
#define dypMSFT        65     /* Height of MSFT bitmap */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\back.h ===
#ifdef WINVER_2
typedef BITMAP BMP;
#else
typedef BITMAPINFOHEADER BMP;
#endif

#ifdef WINVER_2
#define DyBmp(bmp) ((int) bmp.bmHeight)
#define DxBmp(bmp) ((int) bmp.bmWidth)
#define CplnBmp(bmp) (bmp.bmPlanes)
#define OfsBits(bgnd) (sizeof(BMPHDR)+sizeof(BMP))
#define CbLine(bgnd) (bgnd.bm.bmWidthBytes)
#else
#define DyBmp(bmp) ((int) bmp.biHeight)
#define DxBmp(bmp) ((int) bmp.biWidth)
#define CplnBmp(bmp) 1
#define OfsBits(bgnd) (bgnd.dwOfsBits)
#define CbLine(bgnd) (bgnd.cbLine)
#endif


#ifdef WINVER_2
typedef INT BMPHDR;
#else
typedef BITMAPFILEHEADER BMPHDR;
#endif


typedef struct _bgnd
	{
	PT ptOrg;
	OFSTRUCT of;
	BMP bm;
#ifdef WINVER_3
	// must folow a bm
	BYTE rgRGB[64];  // bug: wont work with >16 color bmps
	INT cbLine;
	LONG dwOfsBits;
#endif
	BOOL fUseBitmap;
	DY dyBand;
	INT ibndMac;
	HANDLE *rghbnd;
	} BGND;





/* PUBLIC routines */



BOOL FInitBgnd(CHAR *szFile);
BOOL FDestroyBgnd();
BOOL FGetBgndFile(CHAR *sz);
VOID DrawBgnd(X xLeft, Y yTop, X xRight, Y yBot);
VOID SetBgndOrg();



/* Macros */

extern BGND bgnd;

#define FUseBitmapBgnd() (bgnd.fUseBitmap)


#define BFT_BITMAP 0x4d42   /* 'BM' */
#define ISDIB(bft) ((bft) == BFT_BITMAP)
#define WIDTHBYTES(i)   ((i+31)/32*4)      /* ULONG aligned ! */
WORD        DibNumColors(VOID FAR * pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\aboutwep\about.c ===
/****************************************************************************

    ABOUT MICROSOFT DIALOG DLL

	 by RobD

****************************************************************************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>
#include <basetsd.h>
#include "res.h"


/* Local Variables */

BOOL     fEGA;         /* TRUE if working with EGA */
BOOL     fColor;       /* TRUE if working with a color display */
INT      cUsers = 0;   /* Count of users of the bitmap */

HANDLE   hInstDll;
HDC      hdcMSFT;
HBITMAP  hbmpMSFT;

HICON    hiconApp;
LPSTR    lpstrApp;
LPSTR    lpstrCredit;

#define  cchMax 80
#define  cchMaxTitle 73
CHAR     szAbout[cchMax] = "About ";
LPSTR    lpszTitle = &szAbout[6];


VOID  APIENTRY AboutWEP(HWND, HICON, LPSTR, LPSTR);



/****** L I B  M A I N ******/

/* Called once to  initialize data */
/* Determines if display is color and remembers the hInstance for the DLL */

INT  APIENTRY LibMain(HANDLE hInst, ULONG ul_reason_being_called, LPVOID lpReserved)
{

	if (fEGA = GetSystemMetrics(SM_CYSCREEN) < 351)
		fColor = FALSE;
	else
		{
		HDC hDC = GetDC(GetDesktopWindow());
		fColor = (GetDeviceCaps(hDC, NUMCOLORS) != 2);
		ReleaseDC(GetDesktopWindow(),hDC);
		}

	hInstDll = hInst;
	
	return 1;

    UNREFERENCED_PARAMETER(ul_reason_being_called);
    UNREFERENCED_PARAMETER(lpReserved);
}


/****** W E P ******/

/* Called upon exit/last use */

VOID  APIENTRY WEP(INT nParm)
{
	return;
         (nParm);
}



/*** A B O U T  D L G  P R O C ***/

/* Main Dialog Procedure */

INT_PTR APIENTRY AboutDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
		{
	case WM_INITDIALOG:
		{
		RECT rect;

		SetWindowText(hDlg, (LPSTR) szAbout);
		
		if (hiconApp != NULL)
            SendDlgItemMessage(hDlg, ID_ICON_APP, STM_SETICON, (LONG_PTR)hiconApp, 0);
		if (lpstrApp != NULL)
			SetDlgItemText(hDlg, ID_NAME_APP, lpstrApp);
		if (lpstrCredit != NULL)
			SetDlgItemText(hDlg, ID_NAME_CREDIT, lpstrCredit);

		CreateWindow("button", "",
			WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
			10, 10, dxpMSFT, dypMSFT, hDlg, (HMENU)ID_USER_MSFT, hInstDll, NULL);

		GetWindowRect(hDlg,&rect);
		SetWindowPos(hDlg,NULL,
        	(GetSystemMetrics(SM_CXSCREEN) - (rect.right  - rect.left)) >> 1,
        	(GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top)) / 3,
			0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

		return (TRUE);
		}


	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam))
			{
		case IDOK:
		case IDCANCEL:
			{
			EndDialog(hDlg, TRUE);
			return (TRUE);
			}

		default:
			break;
			}

		break;


	case WM_DRAWITEM:
		{
#define lpDI ((LPDRAWITEMSTRUCT) lParam)

		if ((lpDI->CtlID == ID_USER_MSFT) && (hdcMSFT != NULL))
			BitBlt(lpDI->hDC, 0, 0, dxpMSFT, dypMSFT, hdcMSFT, 0, 0, SRCCOPY);

#undef lpDI
		}
		break;


	default:
		break;
		}

	return (FALSE);
}



/****** A B O U T  W E P ******/

VOID  APIENTRY AboutWEP(HWND hwnd, HICON hicon, LPSTR lpTitle, LPSTR lpCredit)
{
	hiconApp    = hicon;
	lpstrApp    = lpTitle;
	lpstrCredit = lpCredit;
	
	GetWindowText(hwnd, lpszTitle, cchMaxTitle);

	if (cUsers++ == 0)
		{
		hdcMSFT   = CreateCompatibleDC(NULL);
		hbmpMSFT  = LoadBitmap(hInstDll,
			fColor ? MAKEINTRESOURCE(ID_BMP_CLR) : MAKEINTRESOURCE(ID_BMP_BAW) );
		if ((hdcMSFT != NULL) && (hbmpMSFT != NULL))
			SelectObject(hdcMSFT, hbmpMSFT);
		}

	DialogBox(hInstDll,
		fEGA ? MAKEINTRESOURCE(ID_DLG_ABOUT_EGA) : MAKEINTRESOURCE(ID_DLG_ABOUT),
		hwnd, AboutDlgProc);

	if ((--cUsers == 0) && (hdcMSFT != NULL))
		{
		DeleteDC(hdcMSFT);
		DeleteObject(hbmpMSFT);
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\crd.h ===
#include "cdt.h"


typedef INT CD;

// CaRD struct, this is what a card be
typedef struct _crd
	{
	unsigned cd  : 15;		// card # (1..52)
	unsigned fUp : 1;		// is this card up/down
	PT pt;				// upper-left corner of card
	} CRD;




/* WARNING: Order of su's is assumed */
#define suClub 0
#define suDiamond 1
#define suHeart 2
#define suSpade 3
#define suMax 4
#define suFirst suClub

#define raAce 0
#define raDeuce 1
#define raTres 2
#define raFour 3
#define raFive 4
#define raSix 5
#define raSeven 6
#define raEight 7
#define raNine 8
#define raTen 9
#define raJack 10
#define raQueen 11
#define raKing 12
#define raMax 13
#define raNil 15
#define raFirst raAce

typedef INT RA;
typedef INT SU;

#define cdNil 0x3c


#define cIDFACEDOWN (IDFACEDOWNLAST-IDFACEDOWNFIRST+1)

#define SuFromCd(cd) ((cd)&0x03)
#define RaFromCd(cd) ((cd)>>2)
#define Cd(ra, su) (((ra)<<2)|(su))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\debug.h ===
typedef struct
	{
	VOID *pgmcol;
	WORD lvl;
	WORD msg;
	WORD wp1;
	WORD wp2;
	WORD wResult;
	} MDBG;



#define imdbgMax 500



VOID InitDebug();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\std.h ===
#include <memory.h>


typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;


#define fTrue	1
#define fFalse 0

// PoinT structure 
typedef struct _pt
	{
	X x;
	Y y;
	} PT;



// DEL structure
typedef struct _del
	{
	DX dx;
	DY dy;
	} DEL;


// ReCt structure 
typedef struct _rc
	{
	X xLeft;
	Y yTop;
	X xRight;
	Y yBot;
	} RC;


#ifdef DEBUG
#define VSZASSERT static char *vszAssert = __FILE__;
#define Assert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } } 
#define SideAssert(f) { if (!(f)) { AssertFailed(vszAssert, __LINE__); } } 
#else
#define Assert(f)
#define SideAssert(f) (f)
#define VSZASSERT
#endif



VOID *PAlloc(INT cb);
VOID FreeP();

INT CchString();
CHAR *PszCopy(CHAR *pszFrom, CHAR *rgchTo);
INT CchSzLen(CHAR *sz);
INT CchLpszLen(CHAR FAR *lpsz);
INT CchDecodeInt(CHAR *rgch, INT w);
VOID Error(CHAR *sz);
VOID ErrorIds(INT ids);
INT WMin(INT w1, INT w2);
INT WMax(INT w1, INT w2);
INT WParseLpch(CHAR FAR **plpch);
BOOL FInRange(INT w, INT wFirst, INT wLast);
INT PegRange(INT w, INT wFirst, INT wLast);
VOID NYI();
INT CchString(CHAR *sz, INT ids);
VOID InvertRc(RC *prc);
VOID OffsetPt(PT *ppt, DEL *pdel, PT *pptDest);
BOOL FRectAllVisible(HDC hdc, RC *prc);



#ifdef DEBUG
VOID AssertFailed(CHAR *szFile, INT li);
#endif

#define bltb(pb1, pb2, cb) memcpy(pb2, pb1, cb)
/*
short  APIENTRY MulDiv(short, short, short);
*/


extern HWND hwndApp;
extern HANDLE hinstApp;



BOOL FWriteIniString(INT idsTopic, INT idsItem, CHAR *szValue);
BOOL FWriteIniInt(INT idsTopic, INT idsItem, INT w);
BOOL FGetIniString(INT idsTopic, INT idsItem, CHAR *sz, CHAR *szDefault, INT cchMax);
INT GetIniInt(INT idsTopic, INT idsItem, INT wDefault);



VOID CrdRcFromPt(PT *ppt, RC *prc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\cards.c ===
#include <windows.h>
#include <port1632.h>
#include "std.h"
#include "crd.h"
#include "back.h"
#include "debug.h"

#ifdef DEBUG
#undef Assert
#define Assert(f) { if (!(f)) { char s[80]; wsprintf(s, "CARDS.DLL: %s(%d)", (LPSTR) __FILE__, __LINE__); MessageBox(NULL, s, "Assert Failure", MB_OK); return FALSE; } }
#endif

VOID SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);
VOID RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy);

static HBITMAP HbmFromCd(INT cd);
BOOL   FLoadBack(INT cd);


VOID MyDeleteHbm(HBITMAP hbm);


typedef struct
{
    INT id;
    DX  dx;
    DY     dy;
} SPR;

#define isprMax 4

typedef struct
{
    INT cdBase;
    DX dxspr;
    DY dyspr;
    INT isprMac;
    SPR rgspr[isprMax];
} ANI;
    
// we removed the older card decks that required Animation. The new
// card deck doesn't involve any animation.

#define ianiMax 0

static INT        cLoaded = 0;
static HBITMAP    hbmCard[52] =
    {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
static HBITMAP    hbmGhost = NULL;
static HBITMAP    hbmBack = NULL;
static HBITMAP    hbmDeckX = NULL;
static HBITMAP    hbmDeckO = NULL;
static INT        idback = 0;
static INT        dxCard, dyCard;
static INT        cInits = 0;

HANDLE    hinstApp;

/****** L I B  M A I N ******/

/* Called once to  initialize data */
/* Determines if display is color and remembers the hInstance for the DLL */

INT  APIENTRY LibMain(HANDLE hInst, ULONG ul_reason_being_called, LPVOID lpReserved)
{

    hinstApp = hInst;
    
    return 1;
    UNREFERENCED_PARAMETER(ul_reason_being_called);
    UNREFERENCED_PARAMETER(lpReserved);
}


BOOL FInRange(INT w, INT wFirst, INT wLast)
{
    Assert(wFirst <= wLast);
    return(w >= wFirst && w <= wLast);
}

BOOL  APIENTRY cdtInit(INT FAR *pdxCard, INT FAR *pdyCard)
/*
 * Parameters:
 *    pdxCard, pdyCard
 *            Far pointers to ints where card size will be placed
 *
 * Returns:
 *    True when successful, False when it can't find one of the standard
 *    bitmaps.
 */
{
    BITMAP   bmCard;
    HDC      hdc;

    if (cInits++ != 0)
    {
        *pdxCard = dxCard;
        *pdyCard = dyCard;
        return fTrue;
    }
    hbmGhost = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDGHOST));
    hbmDeckX = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDX));
    hbmDeckO = LoadBitmap( hinstApp, MAKEINTRESOURCE(IDO));
    if(hbmGhost == NULL || hbmDeckX == NULL || hbmDeckO == NULL)
        goto Fail;
    GetObject( hbmGhost, sizeof( BITMAP), (LPSTR)&bmCard);
    dxCard = *pdxCard = bmCard.bmWidth;
    dyCard = *pdyCard = bmCard.bmHeight;
    return fTrue;
Fail:
    MyDeleteHbm(hbmGhost);
    MyDeleteHbm(hbmDeckX);
    MyDeleteHbm(hbmDeckO);
    return fFalse;
    UNREFERENCED_PARAMETER(hdc);
}




BOOL  APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy,
                        			INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *    hdc      HDC to window to draw cards on
 *    x, y    Where you'd like them
 * dx,dy card extents
 *    cd        Card to be drawn
 *    mode    Way you want it drawn (or with MINLONG if to be fast)
 *
 * Returns:
 *    True if card successfully drawn, False otherwise
 */
{
    static HBITMAP        hbmSav;
    HDC          hdcMemory;
    DWORD        dwRop = 0;
    HBRUSH       hbr;
    PT           pt;
    POINT        ptReal;
    LONG         rgRGB[12];
    DWORD        dwOldBknd;
    BOOL         bFast=FALSE;    // true if we shouldn't save corners

    if( mode & MINLONG )
    {
        mode= mode + MINLONG;
        bFast= TRUE;
    }

    Assert(hdc != NULL);
    switch (mode)
    {
        default:
            Assert(fFalse);
            break;
        case FACEUP:
            hbmSav = HbmFromCd(cd);
            dwRop = SRCCOPY;
            rgbBgnd = RGB(255,255,255);
            break;
        case FACEDOWN:
            if(!FLoadBack(cd))
                return fFalse;
            hbmSav = hbmBack;
            dwRop = SRCCOPY;
            break;
        case REMOVE:
        case GHOST:
            hbr = CreateSolidBrush( rgbBgnd);
            if(hbr == NULL)
                return fFalse;
            /* *(LONG *)&pt = +++GetDCOrg - NO 32BIT FORM(probably can noop)+++(hdc); */
            //guess again! -- 12-Jul-1994 JonPa
            GetDCOrgEx(hdc, &ptReal);
            pt.x = ptReal.x;
            pt.y = ptReal.y;

            (VOID)MSetBrushOrg( hdc, pt.x, pt.y);
            MUnrealizeObject( hbr);
            if((hbr = SelectObject( hdc, hbr)) != NULL)
            {
                PatBlt(hdc, x, y, dx, dy, PATCOPY);
                hbr = SelectObject( hdc, hbr);
            }
            if (hbr)
                DeleteObject( hbr);
            if(mode == REMOVE)
                return fTrue;
            Assert(mode == GHOST);
             // default: fall thru

        case INVISIBLEGHOST:
            hbmSav = hbmGhost;
            dwRop = SRCAND;
            break;

        case DECKX:
            hbmSav = hbmDeckX;
            dwRop = SRCCOPY;
            break;
        case DECKO:
            hbmSav = hbmDeckO;
            dwRop = SRCCOPY;
            break;
            
        case HILITE:
            hbmSav = HbmFromCd( cd);
            dwRop = NOTSRCCOPY;
            break;
    }
    if (hbmSav == NULL)
        return fFalse;
    else
    {
        hdcMemory = CreateCompatibleDC( hdc);
        if(hdcMemory == NULL)
            return fFalse;

        if((hbmSav = SelectObject( hdcMemory, hbmSav)) != NULL)
        {
            dwOldBknd = SetBkColor(hdc, rgbBgnd);
            if( !bFast )
                SaveCorners(hdc, rgRGB, x, y, dx, dy);
            if(dx != dxCard || dy != dyCard)
                StretchBlt(hdc, x, y, dx, dy, hdcMemory, 0, 0, dxCard, dyCard, dwRop);
            else
                BitBlt( hdc, x, y, dxCard, dyCard, hdcMemory, 0, 0, dwRop);

            SelectObject( hdcMemory, hbmSav);
            /* draw the border for the red cards */
            if(mode == FACEUP)
                {
                INT icd;

                icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13+1;
                if((icd >= IDADIAMONDS && icd <= IDTDIAMONDS) ||
                    (icd >= IDAHEARTS && icd <= IDTHEARTS))
                    {
                    PatBlt(hdc, x+2, y, dx-4, 1, BLACKNESS);  // top
                    PatBlt(hdc, x+dx-1, y+2, 1, dy-4, BLACKNESS); // right
                    PatBlt(hdc, x+2, y+dy-1, dx-4, 1, BLACKNESS); // bottom
                    PatBlt(hdc, x, y+2, 1, dy-4, BLACKNESS); // left
                    SetPixel(hdc, x+1, y+1, 0L); // top left
                    SetPixel(hdc, x+dx-2, y+1, 0L); // top right
                    SetPixel(hdc, x+dx-2, y+dy-2, 0L); // bot right
                    SetPixel(hdc, x+1, y+dy-2, 0L);    // bot left
                    }    			
                }

            if( !bFast )
                RestoreCorners(hdc, rgRGB, x, y, dx, dy);

            SetBkColor(hdc, dwOldBknd);
        }
        DeleteDC( hdcMemory);
        return fTrue;
    }
}




BOOL  APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd)
/*
 * Parameters:
 *    hdc        HDC to window to draw cards on
 *    x, y    Where you'd like them
 *    cd        Card to be drawn
 *    mode    Way you want it drawn
 *
 * Returns:
 *    True if card successfully drawn, False otherwise
 */
{

    return cdtDrawExt(hdc, x, y, dxCard, dyCard, cd, mode, rgbBgnd);
}



VOID SaveCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
{
    if(dx != dxCard || dy != dyCard)
        return;
    
    // Upper Left
    rgRGB[0] = GetPixel(hdc, x, y);
    rgRGB[1] = GetPixel(hdc, x+1, y);
    rgRGB[2] = GetPixel(hdc, x, y+1);

    // Upper Right
    x += dx -1;
    rgRGB[3] = GetPixel(hdc, x, y);
    rgRGB[4] = GetPixel(hdc, x-1, y);
    rgRGB[5] = GetPixel(hdc, x, y+1);

    // Lower Right
    y += dy-1;
    rgRGB[6] = GetPixel(hdc, x, y);
    rgRGB[7] = GetPixel(hdc, x, y-1);
    rgRGB[8] = GetPixel(hdc, x-1, y);

    // Lower Left
    x -= dx-1;
    rgRGB[9] = GetPixel(hdc, x, y);
    rgRGB[10] = GetPixel(hdc, x+1, y);
    rgRGB[11] = GetPixel(hdc, x, y-1);

}






BOOL  APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr)
{
    INT iani;
    ANI *pani;
    SPR *pspr;
    HBITMAP hbm;
    HDC hdcMem;
    X xSrc;
    Y ySrc;

    // remove animation as we are removing those card decks but just in case
    // someone calls this function, don't do anything.
    return fTrue;

#ifdef UNUSEDCODE 
    if(ispr < 0)        
        return fFalse;
    Assert(hdc != NULL);
    for(iani = 0; iani < ianiMax; iani++)
    {
        if(cd == rgani[iani].cdBase)
        {
            pani = &rgani[iani];
            if(ispr < pani->isprMac)
            {
                pspr = &pani->rgspr[ispr];
                Assert(pspr->id != 0);
                if(pspr->id == cd)
                {
                    xSrc = pspr->dx;
                    ySrc = pspr->dy;
                }
                else
                    xSrc = ySrc = 0;

                hbm = LoadBitmap(hinstApp, MAKEINTRESOURCE(pspr->id));
                if(hbm == NULL)
                    return fFalse;

                hdcMem = CreateCompatibleDC(hdc);
                if(hdcMem == NULL)
                {
                    DeleteObject(hbm);
                    return fFalse;
                }

                if((hbm = SelectObject(hdcMem, hbm)) != NULL)
                {
                    BitBlt(hdc, x+pspr->dx, y+pspr->dy, pani->dxspr, pani->dyspr,
                        hdcMem, xSrc, ySrc, SRCCOPY);
                    DeleteObject(SelectObject(hdcMem, hbm));
                }
                DeleteDC(hdcMem);
                return fTrue;
            }
        }
    }
    return fFalse;

#endif

}



VOID RestoreCorners(HDC hdc, LONG FAR *rgRGB, INT x, INT y, INT dx, INT dy)
{
    if(dx != dxCard || dy != dyCard)
        return;

    // Upper Left
    SetPixel(hdc, x, y, rgRGB[0]);
    SetPixel(hdc, x+1, y, rgRGB[1]);
    SetPixel(hdc, x, y+1, rgRGB[2]);

    // Upper Right
    x += dx-1;
    SetPixel(hdc, x, y, rgRGB[3]);
    SetPixel(hdc, x-1, y, rgRGB[4]);
    SetPixel(hdc, x, y+1, rgRGB[5]);

    // Lower Right
    y += dy-1;
    SetPixel(hdc, x, y, rgRGB[6]);
    SetPixel(hdc, x, y-1, rgRGB[7]);
    SetPixel(hdc, x-1, y, rgRGB[8]);

    // Lower Left
    x -= dx-1;
    SetPixel(hdc, x, y, rgRGB[9]);
    SetPixel(hdc, x+1, y, rgRGB[10]);
    SetPixel(hdc, x, y-1, rgRGB[11]);
}




/* loads global bitmap hbmBack */
BOOL FLoadBack(INT idbackNew)
    {
    extern HBITMAP hbmBack;
    extern INT idback;
    CHAR szPath[64];
    INT fh;
    CHAR *pch;

    Assert(FInRange(idbackNew, IDFACEDOWNFIRST, IDFACEDOWNLAST));

    if(idback != idbackNew)
        {
        MyDeleteHbm(hbmBack);
        if((hbmBack = LoadBitmap(hinstApp, MAKEINTRESOURCE(idbackNew))) != NULL)
            idback = idbackNew;
        else
            idback = 0;
        }
    return idback != 0;
    UNREFERENCED_PARAMETER(pch);
    UNREFERENCED_PARAMETER(szPath);
    UNREFERENCED_PARAMETER(fh);
    }



static HBITMAP HbmFromCd(INT cd)
    {
    static INT    iNext = 0;
    INT            icd;

    if (hbmCard[cd] == NULL)
        {
        if (cLoaded >= CLOADMAX)
            {
            for (; hbmCard[iNext] == NULL;
                iNext = (iNext == 51) ? 0 : iNext + 1);
            DeleteObject( hbmCard[iNext]);
            hbmCard[iNext] = NULL;
            cLoaded--;
            }

        icd = RaFromCd(cd) % 13 + SuFromCd(cd) * 13;
        while ((hbmCard[cd]=LoadBitmap(hinstApp,MAKEINTRESOURCE(icd+1)))
                == NULL)
            {
            if (cLoaded == 0)
                return NULL;
            else
                {
                for (; hbmCard[iNext] == NULL;
                    iNext = (iNext == 51) ? 0 : iNext + 1);
                DeleteObject( hbmCard[iNext]);
                hbmCard[iNext] = NULL;
                cLoaded--;
                }
            }
        cLoaded++;
        }
    return hbmCard[cd];
    }


VOID MyDeleteHbm(HBITMAP hbm)    
    {
    if(hbm != NULL)
        DeleteObject(hbm);
    }

VOID  APIENTRY cdtTerm()
/*
 * Free up space if it's time to do so.
 *
 * Parameters:
 *    none
 *
 * Returns:
 *    nothing
 */
    {
    INT    i;

    if (--cInits > 0)
        return;
    for (i = 0; i < 52; i++)
        MyDeleteHbm(hbmCard[i]);
    MyDeleteHbm(hbmGhost);
    MyDeleteHbm(hbmBack);
    MyDeleteHbm(hbmDeckX);
    MyDeleteHbm(hbmDeckO);
    }

INT  APIENTRY WEP(INT nCmd)
{
    return 1;
    UNREFERENCED_PARAMETER(nCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\cards.h ===
/* Type def's needed if your using the card DLL */

typedef enum { faceup = 0,
               facedown = 1,
               hilite = 2,
               ghost = 3,
               remove = 4
             } cardMode;

typedef enum { club = 0,
               diamond = 1,
               heart = 2,
               spade = 3
             } cardSuit;

typedef enum { ace = 0,
               two = 1,
               three = 2,
               four = 3,
               five = 4,
               six = 5,
               seven = 6,
               eight = 7,
               nine = 8,
               ten = 9,
               jack = 10,
               queen = 11,
               king = 12
             } cardRank;

/* Commonly needed macros for card games. */

#define CardIndex(suit, rank)    ((rank) << 2 + (suit))
#define CardSuit(index)          ((index) & 3)
#define CardRank(index)          ((index) >> 2)
#define SameSuit(index1, index2) (CardSuit((index1)) == CardSuit((index2)))
#define SameRank(index1, index2) (CardRank((index1)) == CardRank((index2)))

#define ACELOW    13
#define ACEHIGH   14
#define IndexValue(index, acerank)  (CardRank(index) % (acerank))
//-protect-#define RanksHigher(index1, index2, acerank)
//        (IndexValue((index1), (acerank)) > IndexValue((index2), (acerank)))

/* Function prototypes for API resolved in the cards DLL */

BOOL  APIENTRY cdtInit(INT FAR *width, INT FAR *height);
BOOL  APIENTRY cdtDraw(HDC hDC, INT x, INT y,
                        INT crd, cardMode mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtTerm(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\cruel\cruel.c ===
#include <windows.h>
#include <port1632.h>
#include "cards.h"
#include "cruel.h"
#include "cdt.h"
#include "stdlib.h"

typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;

// ReCt structure
typedef struct _rc
	{
	X xLeft;
	Y yTop;
	X xRight;
	Y yBot;
	} RC;

#define IDCARDBACK 65
#define ININAME "entpack.ini"

#define APPTITLE    "Cruel"

#define HI 0
#define LOW 1
#define SUM 2
#define TOTAL 3
#define WINS 4

#define  abs(x)   (((x) < 0) ? (-(x)) : (x))
#define  NEXT_ROUND  4000
#define  INVALID_POS 255
#define  MAXUNDOSIZE 100

extern VOID  APIENTRY AboutWEP(HWND hwnd, HICON hicon, LPSTR lpTitle, LPSTR lpCredit);

LRESULT APIENTRY WndProc (HWND, UINT, WPARAM, LPARAM) ;
VOID Deal(VOID);
VOID InitBoard(VOID);
VOID DrawLayout(HDC hDC);
VOID DrawFoundation(HDC hDC);
VOID UpdateDeck(HDC hDC);
VOID UpdateLayout(HDC hDC, INT column);
VOID DoWinEffects(HDC hDC);
BOOL MoveCard(HDC hDC, INT startRow, INT startColumn,
                       INT endRow, INT endColumn,
                       BOOL bValidate);
VOID RestoreLayout(HDC hDC);
VOID APIENTRY Help(HWND hWnd, UINT wCommand, ULONG_PTR lParam);
VOID UndoMove(HDC hDC);
INT  Message(HWND hWnd, WORD wId, WORD wFlags);
VOID MyDrawText(HDC hDC, LPSTR lpBuf, INT w, LPRECT lpRect, WORD wFlags);
BOOL CheckGameOver(VOID);
INT_PTR CALLBACK BackDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus);
VOID ChangeBack(WORD wNewDeckBack);
VOID DoBacks(VOID);
VOID DrawGameOver(VOID);
BOOL fDialog(INT id,HWND hwnd,DLGPROC fpfn);

BOOL APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd, INT mode, DWORD rgbBgnd);
BOOL APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr);
VOID DrawAnimate(INT cd, MPOINT *ppt, INT iani);
BOOL DeckAnimate(INT iqsec);
VOID APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime);
INT_PTR APIENTRY RecordDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ReadOnlyProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam);
VOID MarkControlReadOnly(HWND hwndCtrl, BOOL bReadOnly);
VOID ShowStacks(VOID);

VOID SaveState(VOID);
VOID RestoreState(VOID);
LPSTR lstrtok(LPSTR lpStr, LPSTR lpDelim);
static BOOL IsInString(CHAR c, LPSTR s);
VOID DisplayStats(VOID);

INT sprintf();

#if 0
INT init[2][6] = { { 49, 33, 13, 46, 10, 47 },
                   { 39, 31, 19, 44, 28, 8 }};
#endif

typedef struct tagCardRec {
   INT card;
   struct tagCardRec *next;
   } CardRec;

CardRec *FreeList[52];
INT freePos;
CardRec deck[52];
CardRec *layout[2][6];
RECT layoutRect[2][6];
INT foundation[4];
RECT foundationRect[4];
INT nCards;
LONG nStats[5];

CHAR szAppName[80], szGameOver[80], szGameOverS[80];
CHAR szOOM[256], szRecordTitle[80];

WORD wDeckBack;
BOOL bGameInProgress = FALSE;

typedef struct tagUndoRec {
   INT  startRow, startColumn, endRow, endColumn;
   } UndoRec;
UndoRec undo[MAXUNDOSIZE];
INT undoPos;

INT xClient, yClient, xCard, yCard;
INT xInc, yInc;
DWORD dwBkgnd;
WORD wErrorMessages;
HWND hWnd;
HANDLE hMyInstance;

MMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow) /* { */
     MSG         msg ;
     WNDCLASS    wndclass ;
     HANDLE      hAccel;

    if (!LoadString(hInstance, IDSOOM, szOOM, 256)
        || !LoadString(hInstance, IDSAppName, szAppName, 80)
        || !LoadString(hInstance, IDSGameOver, szGameOver, 80)
        || !LoadString(hInstance, IDSGameOverS, szGameOverS, 80)
        || !LoadString(hInstance, IDSRecordTitle, szRecordTitle, 80)
        )
        return FALSE;

    if (hPrevInstance) {
        hWnd = FindWindow(szAppName, NULL);
        if (hWnd)
        {
            hWnd = GetLastActivePopup(hWnd);
            BringWindowToTop(hWnd);
            if (IsIconic(hWnd))
                ShowWindow(hWnd, SW_RESTORE);
        }
        return FALSE;
    }

    wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS ;
    wndclass.lpfnWndProc   = WndProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = hInstance ;
    wndclass.hIcon         = LoadIcon (hInstance, szAppName) ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = CreateSolidBrush(dwBkgnd = RGB(0,130,0));
    wndclass.lpszMenuName  = szAppName ;
    wndclass.lpszClassName = szAppName ;

    if (!RegisterClass (&wndclass))
        return FALSE ;

    RestoreState();

     hWnd = CreateWindow (szAppName, APPTITLE,
                         WS_OVERLAPPEDWINDOW | WS_MAXIMIZE,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         NULL, NULL, hInstance, NULL) ;

     if (!hWnd)
        return FALSE;

     hAccel = LoadAccelerators(hInstance, szAppName);

     if (!hAccel)
        return FALSE;

    if(SetTimer(hWnd, 666, 250, TimerProc) == 0) {
	    return FALSE;
    }


     ShowWindow (hWnd, SW_SHOWMAXIMIZED) ;
     UpdateWindow (hWnd) ;

     hMyInstance = hInstance;
     while (GetMessage (&msg, NULL, 0, 0))
          {
          if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
          }
     return (INT) msg.wParam ;
     }

VOID MyDrawText(HDC hDC, LPSTR lpBuf, INT w, LPRECT lpRect, WORD wFlags)
{
    DWORD dwOldBk, dwOldTextColor;
    HBRUSH hBrush, hOldBrush;

    dwOldBk = SetBkColor(hDC, dwBkgnd);
    dwOldTextColor = SetTextColor(hDC, RGB(255,255,255));
    if (hBrush = CreateSolidBrush(dwBkgnd)) {
        if (hOldBrush = SelectObject(hDC, hBrush)) {
            PatBlt(hDC, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
                lpRect->bottom - lpRect->top, PATCOPY);
            SelectObject(hDC, hOldBrush);
        }
        DeleteObject(hBrush);
    }
    DrawText(hDC, lpBuf, w, lpRect, wFlags);
    SetBkColor(hDC, dwOldBk);
    SetTextColor(hDC, dwOldTextColor);
}

VOID  APIENTRY Help(HWND hWnd, UINT wCommand, ULONG_PTR lParam)
{
   CHAR szHelpPath[100], *pPath;

   pPath = szHelpPath
         + GetModuleFileName(hMyInstance, szHelpPath, 99);
   
   if (pPath != szHelpPath) // if GetModuleFileName succeeded
   {
       while (*pPath-- != '.')
          ;
       ++pPath;
       *++pPath = 'H';
       *++pPath = 'L';
       *++pPath = 'P';
       *++pPath = '\0';

       WinHelp(hWnd, szHelpPath, wCommand, lParam);
   }
}

BOOL CheckGameOver(VOID)
{
    CardRec *pCard;
    INT colStart, colEnd, rowStart, rowEnd;
    BOOL bMoveFound;
    HDC hDC;
    RECT rect;

    /* check to see if there is a card to play */
    bMoveFound = FALSE;
    for (rowStart = 0; rowStart < 2; ++rowStart)
        for (colStart = 0; colStart < 6; ++colStart) {
            if (!layout[rowStart][colStart])
                continue;
            for (rowEnd = -1; rowEnd < 2; ++rowEnd)
                for (colEnd = 0; colEnd < ((rowEnd < 0) ? 4 : 6); ++colEnd) {
                    if (rowEnd == -1 && foundation[colEnd] == wDeckBack)
                        continue;

                    if (MoveCard(NULL, rowStart, colStart, rowEnd, colEnd, TRUE)) {
                        bMoveFound = TRUE;
                        goto endMoveSearch;
                    }
                }
        }
endMoveSearch:

    /* if a move was found game ain't over! */
    if (bMoveFound)
        return FALSE;

    /* count # of cards left */
    nCards = 0;
    for (rowStart = 0; rowStart < 2; ++rowStart)
        for (colStart = 0; colStart < 6; ++colStart)
            for (pCard = layout[rowStart][colStart]; pCard; pCard = pCard->next)
                ++nCards;

    /* if no cards then we have a winner! */
    if (!nCards) {
        Message(hWnd, IDSWinner, MB_OK | MB_ICONEXCLAMATION);
        undoPos = 0;
    }
    else
        DrawGameOver();

    if (!nCards)
        ++nStats[WINS];

    if (nCards < nStats[LOW])
        nStats[LOW] = nCards;

    if (nCards > nStats[HI])
        nStats[HI] = nCards;

    ++nStats[TOTAL];
    nStats[SUM] += nCards;

    bGameInProgress = FALSE;
    return TRUE;
}

VOID DrawGameOver(VOID)
{
    HDC hDC;
    CHAR buffer[80];
    RECT rect;

    wsprintf(buffer, (nCards == 1) ? szGameOverS : szGameOver, nCards);
    rect.bottom = yClient - 15;
    rect.top = rect.bottom - 10;
    rect.left = 0;
    rect.right = xClient;
    if (hDC = GetDC(hWnd)) {
        MyDrawText(hDC, buffer, -1, &rect, DT_CENTER | DT_NOCLIP);
        ReleaseDC(hWnd, hDC);
    }
}

LRESULT APIENTRY WndProc (
     HWND         hWnd,
     UINT         iMessage,
     WPARAM       wParam,
     LPARAM       lParam)
     {
     HDC          hDC ;
     HMENU        hMenu;
     PAINTSTRUCT  ps ;
     INT          i, j ;
     POINT        mpt;
     MPOINT       pt;
     RECT         tmpRect;
     LONG         Area, maxArea;
     static BOOL  fBoard = FALSE;
     static HWND  hWndButton = NULL;
     INT          row, column;
     static BOOL  fTracking = FALSE;
     static INT   startRow, startColumn, endRow, endColumn;
     static RECT  trackRect;
     static HDC   hDCTrack;
     static HBRUSH hBrush, hOldBrush;
     static HPEN  hOldPen;
     static MPOINT ptOldPos;
     FARPROC lpAbout;
     HANDLE hLib;

     switch (iMessage)
          {
          case WM_CREATE:
               cdtInit(&xCard, &yCard);
               Deal();
               startRow = startColumn = endRow = endColumn = INVALID_POS;
               hBrush = CreateSolidBrush(dwBkgnd);
               if (!hBrush)
                   return -1L;
               CheckGameOver();
               break;

          case WM_SIZE:
               xClient = LOWORD(lParam);
               yClient = HIWORD(lParam);
               break;

          case WM_PAINT:
               hDC = BeginPaint (hWnd, &ps) ;
               SetBkColor(hDC, dwBkgnd);
               if (!fBoard)
               {
                  InitBoard();
                  if (!hWndButton)
                     hWndButton = CreateWindow("button", "Deal",
                                             WS_CHILD |
                                             WS_VISIBLE |
                                             BS_DEFPUSHBUTTON,
                                             20 + 5 * xInc,
                                             10 + yCard / 4,
                                             xCard,
                                             yCard / 2,
                                             hWnd, (HMENU)NEXT_ROUND,
                                             hMyInstance, NULL);
                  fBoard = TRUE;
               }
               DrawLayout(hDC);
               DrawFoundation(hDC);

               if (!bGameInProgress)
                  DrawGameOver();

			      EndPaint(hWnd, &ps);
			      break;

          case WM_LBUTTONDBLCLK:
               pt = MAKEMPOINT(lParam);

               for (row = 0; row < 2; ++row)
                  for (column = 0; column < 6; ++column)
                  {
		     MPOINT2POINT(pt, mpt);
                     if (!layout[row][column] ||
                         !PtInRect(&layoutRect[row][column], mpt))
                        continue;

                     i = CardSuit(layout[row][column]->card);
                     j = CardRank(layout[row][column]->card);

                     if (CardRank(foundation[i]) == j - 1) {
                        hDC = GetDC(hWnd);
                        if (hDC) {
                            MoveCard(hDC, row, column, -1, i, FALSE);
                            ReleaseDC(hWnd, hDC);
                        }
                     } else {
                        if (wErrorMessages)
                            Message(hWnd, IDSNotNextCard, MB_OK);
                     }


                     return 0L;
                  }
               break;

          case WM_LBUTTONDOWN:
               pt = MAKEMPOINT(lParam);

               for (row = 0; row < 2; ++row)
                  for (column = 0; column < 6; ++column)
                  {
		     MPOINT2POINT(pt, mpt);
                     if (!layout[row][column] ||
                         !PtInRect(&layoutRect[row][column], mpt))
                        continue;

                     fTracking = TRUE;
                     startRow = row;
                     startColumn = column;
                     trackRect = layoutRect[row][column];
                     hDCTrack = GetDC(hWnd);
                     hOldBrush = SelectObject(hDCTrack,
                                             GetStockObject(NULL_BRUSH));
                     hOldPen = SelectObject(hDCTrack,
                                            GetStockObject(WHITE_PEN));
                     SetROP2(hDCTrack, R2_XORPEN);
                     Rectangle(hDCTrack, trackRect.left, trackRect.top,
                                         trackRect.right, trackRect.bottom);
                     ptOldPos = pt;
                     SetCapture(hWnd);
                     goto foundSource;
                  }
               foundSource:
               break;

           case WM_MOUSEMOVE:
               pt = MAKEMPOINT(lParam);

               if (fTracking && !(wParam & MK_LBUTTON))
                  PostMessage(hWnd, WM_LBUTTONUP, wParam, lParam);
               else if (!fTracking ||
                        ((pt.x == ptOldPos.x) && (pt.y == ptOldPos.y)))
                  break;

               Rectangle(hDCTrack, trackRect.left, trackRect.top,
                                    trackRect.right, trackRect.bottom);
               OffsetRect(&trackRect, pt.x - ptOldPos.x,
                                      pt.y - ptOldPos.y);
               ptOldPos = pt;
               Rectangle(hDCTrack, trackRect.left, trackRect.top,
                                    trackRect.right, trackRect.bottom);
               break;

          case WM_LBUTTONUP:
               if (!fTracking)
                  break;

               ReleaseCapture();

               endRow = endColumn = INVALID_POS;
               maxArea = 0;
               for (row = 0; row < 2; ++row)
                  for (column = 0; column < 6; ++column)
                  {
                     if (!layout[row][column] ||
                         !IntersectRect(&tmpRect, &trackRect,
                                        &layoutRect[row][column]))
                        continue;

                     Area = abs((tmpRect.right - tmpRect.left)
                                * (tmpRect.bottom - tmpRect.top));

                     if (Area > maxArea) {
                        endRow = row;
                        endColumn = column;
                        maxArea = Area;
                     }
                  }

               if (maxArea)
                  goto foundTarget;

               endRow = -1;
               for (column = 0; column < 4; ++column)
                  if (IntersectRect(&tmpRect, &trackRect, &foundationRect[column]))
                  {

                     Area = abs((tmpRect.right - tmpRect.left)
                                * (tmpRect.bottom - tmpRect.top));

                     if (Area > maxArea) {
                        endColumn = column;
                        maxArea = Area;
                     }
                  }
               foundTarget:
               fTracking = FALSE;

                 Rectangle(hDCTrack, trackRect.left, trackRect.top,
                                          trackRect.right, trackRect.bottom);
               if (startRow != endRow || startColumn != endColumn) {
                 if ((endRow != INVALID_POS) && (endColumn != INVALID_POS))
                     MoveCard(hDCTrack, startRow, startColumn, endRow, endColumn, FALSE);
                 startRow = startColumn = endRow = endColumn = INVALID_POS;
               }
               SelectObject(hDCTrack, hOldBrush);
               SelectObject(hDCTrack, hOldPen);
               ReleaseDC(hWnd, hDCTrack);
               break;

          case WM_INITMENU:
               hMenu = GetMenu(hWnd);
               EnableMenuItem(hMenu, IDM_OPTIONSUNDO, MF_BYCOMMAND |
                              undoPos ? MF_ENABLED : MF_GRAYED);
                     CheckMenuItem(hMenu, IDM_OPTIONSERROR,
                                   wErrorMessages ? MF_CHECKED : MF_UNCHECKED);
               break;

	  case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam))
               {
                  case IDM_NEWGAME:
                     Deal();
                     fBoard = FALSE;
                     InvalidateRect(hWnd, NULL, TRUE);
                     CheckGameOver();
                     break;

                  case IDM_EXIT:
                     DestroyWindow(hWnd);
                     break;

                  case IDM_OPTIONSDECK:
                     DoBacks();
                     break;

                  case IDM_ABOUT:

                     hLib = MLoadLibrary("shell32.dll");
                     if (hLib < (HANDLE)32)
                        break;
                     lpAbout = GetProcAddress(hLib, (LPSTR)"ShellAboutA");

                     if (lpAbout) {
                     (*lpAbout)(hWnd,
                              (LPSTR) szAppName, (LPSTR)"by Ken Sykes",
                              LoadIcon(hMyInstance, szAppName));
                     }
                     FreeLibrary(hLib);

                     break;

                    case MENU_INDEX:
                        Help(hWnd, HELP_INDEX, 0L);
                        break;

                    case MENU_HOWTOPLAY:
                        Help(hWnd, HELP_CONTEXT, 1L);
                        break;

                    case MENU_COMMANDS:
                        Help(hWnd, HELP_CONTEXT, 2L);
                        break;

                    case MENU_USINGHELP:
                        Help(hWnd, HELP_HELPONHELP, 0L);
                        break;

                  case IDM_OPTIONSERROR:
                     wErrorMessages = (WORD) ~wErrorMessages;
                     break;

                  case IDM_OPTIONSUNDO:
                     hDC = GetDC(hWnd);
                     UndoMove(hDC);
                     ReleaseDC(hWnd, hDC);
                     break;

                  case IDM_GAMERECORD:
                     DisplayStats();
                     break;

                  case IDM_DOMINIMIZE:
                     ShowWindow(hWnd, SW_MINIMIZE);
                     break;

                  case NEXT_ROUND:
                     if (!bGameInProgress)
                        break;

                     if (!undoPos) {
                        if (wErrorMessages)
                            Message(hWnd, IDSNoCardsMoved, MB_OK);
                        break;
                     }

                     UnionRect(&tmpRect, &layoutRect[0][0],
                                         &layoutRect[1][5]);
                     hDC = GetDC(hWnd);
                     FillRect(hDC, &tmpRect, hBrush);
                     RestoreLayout(hDC);
                     DrawLayout(hDC);
                     ReleaseDC(hWnd, hDC);
                     undoPos = 0;
                     CheckGameOver();
                     break;
               }
               break;

          case WM_DESTROY:
	       KillTimer(hWnd, 666);
               cdtTerm();
               Help(hWnd, HELP_QUIT, 0L);
               DeleteObject(hBrush);
               SaveState();
               PostQuitMessage (0) ;
               break ;

          default:
               return DefWindowProc (hWnd, iMessage, wParam, lParam) ;
          }
     return 0L ;
     }

VOID Deal(VOID)
{
   INT i, p1, p2;
   INT row, column;
   CardRec tmp, *pDeck;
   cardSuit suit;
   cardRank rank;

   /* stuff cards into deck */
   pDeck = deck;
    for (i = 4; i < 52; ++i)
        (pDeck++)->card = i;

   /* shuffle them around */
   srand(LOWORD(GetTickCount()));
    for (p2 = 0; p2 < 7; ++p2) {
        for (i = 47; i > 0; --i) {
            p1 = rand() % i;
            tmp = deck[p1];
            deck[p1] = deck[i];
            deck[i] = tmp;
        }
    }


   /* establish layout links */
   pDeck = deck;
   for (row = 0; row < 2; ++row)
      for (column = 0; column < 6; ++column)
      {
         layout[row][column] = pDeck;
         for (i = 0; i < 3; ++i, ++pDeck)
            pDeck->next = pDeck + 1;
         (pDeck++)->next = NULL;
      }

   /* put aces in foundation */
   for (i = 0; i < 4; ++i)
      foundation[i] = i;

#if 0
   {
      INT i,j, *p;

      for (i = 0; i < 2; ++i)
        for (j = 0; j < 6; ++j)
            layout[i][j]->card = init[i][j];

      p = (INT *) &init[0][0];
      j = *p;
      for (i = 1; i < 12; ++i)
        p[i-1] = p[i];
      p[11] = j;
   }
#endif

   bGameInProgress = TRUE;
}

VOID InitBoard(VOID)
{
   INT xPos, yPos;
   INT row, column, i;
   RECT *pRect;

   /* compute x and y increments */
   xInc = (xClient - 40) / 6;
   yInc = (yClient - 20) / 3;

   /* compute foundation rectangles */
   yPos = 10;
   pRect = foundationRect;
   for (xPos = 20 + xInc, i = 0; i < 4; ++i, xPos += xInc, ++pRect)
   {
      pRect->left = xPos;
      pRect->top = yPos;
      pRect->right = xPos + xCard;
      pRect->bottom = yPos + yCard;
   }

   /* compute layout rectangles */
   pRect = &layoutRect[0][0];
   for (row = 0, yPos = 10 + yInc; row < 2; ++row, yPos += yInc)
      for (column = 0, xPos = 20; column < 6; ++column, xPos += xInc)
      {
         pRect->left = xPos;
         pRect->top = yPos;
         pRect->right = xPos + xCard;
         (pRect++)->bottom = yPos + yCard;
      }

   undoPos = 0;
   freePos = 0;

}

VOID DrawLayout(HDC hDC)
{
   INT row, column;

   for (row = 0; row < 2; ++row)
      for (column = 0; column < 6; ++column)
      {
         if (!layout[row][column])
            continue;

         cdtDraw(hDC, layoutRect[row][column].left,
                      layoutRect[row][column].top,
                      layout[row][column]->card,
                      faceup, dwBkgnd);
      }
}

VOID DrawFoundation(HDC hDC)
{
   INT i;

    for (i = 0; i < 4; ++i)
        cdtDraw(hDC, foundationRect[i].left, foundationRect[i].top,
                    foundation[i],
                    (foundation[i] == wDeckBack) ? facedown : faceup, dwBkgnd);
}

BOOL MoveCard(HDC hDC, INT startRow, INT startColumn,
                       INT endRow, INT endColumn,
                       BOOL bValidate)
{
   CardRec *pStart = layout[startRow][startColumn];
   CardRec *pEnd = layout[endRow][endColumn];
   INT startCard = pStart->card;
   INT endCard;
   cardMode drawmode;
   BOOL bDone;

   if (pEnd == (CardRec*)NULL)	/* on NT, this causes exception */
   	endCard = (endRow < 0) ? foundation[endColumn] : 0;
   else
	endCard = (endRow < 0) ? foundation[endColumn] : pEnd->card;

   /* make sure suits match */
   if (CardSuit(startCard) != CardSuit(endCard))
   {
      if (!bValidate && wErrorMessages)
         Message(hWnd, IDSWrongSuit, MB_OK);
      return FALSE;
   }

   /* take action based on where card is moved ... */
   if (endRow < 0)
   {     /* card to foundation */

      /* card must be one higher than top of foundation */

      if (IndexValue(startCard, ACELOW) != IndexValue(endCard, ACELOW) + 1)
      {
         if (!bValidate && wErrorMessages)
            Message(hWnd, IDSNotNextCard, MB_OK);
         return FALSE;
      }

      if (bValidate)
         return TRUE;

      /* move card to foundation and draw it */
        if (CardRank(startCard) == king) {
            startCard = wDeckBack;
            drawmode = facedown;
        } else
            drawmode = faceup;

      foundation[endColumn] = startCard;
      cdtDraw(hDC, foundationRect[endColumn].left,
                   foundationRect[endColumn].top,
                   startCard, drawmode, dwBkgnd);
      layout[startRow][startColumn] = pStart->next;
      FreeList[freePos++] = pStart;
   }
   else
   {  /* card to another pile */

      /* card must be one lower in rank */
      if (IndexValue(startCard, ACELOW) != IndexValue(endCard, ACELOW) - 1)
      {
         if (!bValidate && wErrorMessages)
            Message(hWnd, IDSWrongRank, MB_OK);
         return FALSE;
      }

      if (bValidate)
         return TRUE;

      /* move card to new pile and display it */
      layout[endRow][endColumn] = pStart;
      layout[startRow][startColumn] = pStart->next;
      pStart->next = pEnd;
      cdtDraw(hDC, layoutRect[endRow][endColumn].left,
                   layoutRect[endRow][endColumn].top,
                   startCard, faceup, dwBkgnd);
   }

   /* erase old card and expose new card */
   if (layout[startRow][startColumn])
      cdtDraw(hDC, layoutRect[startRow][startColumn].left,
                   layoutRect[startRow][startColumn].top,
                   layout[startRow][startColumn]->card, faceup, dwBkgnd);
   else
      cdtDraw(hDC, layoutRect[startRow][startColumn].left,
                   layoutRect[startRow][startColumn].top,
                   0, remove, dwBkgnd);

    if (undoPos == MAXUNDOSIZE) {
        Message(hWnd, IDSUndoFull, MB_OK);
        undoPos = 0;
    }

    undo[undoPos].startRow = startRow;
    undo[undoPos].endRow = endRow;
    undo[undoPos].startColumn = startColumn;
    undo[undoPos].endColumn = endColumn;
    ++undoPos;

    bDone = TRUE;
    for (startCard = 0; startCard < 4; ++startCard)
        if (foundation[startCard] != wDeckBack) {
            bDone = FALSE;
            break;
        }

    if (bDone)
        CheckGameOver();

    return TRUE;
}

VOID RestoreLayout(HDC hDC)
{
   INT i, j;
   CardRec *pCurPos, *pList;

   /* stage 1: Chain cards together ... */

   /* find last non-empty stack */
   for (i = 0; i < 12; ++i)
      if (layout[i / 6][i % 6])
         break;

   /* start the list here */
   pList = pCurPos = layout[i / 6][i % 6];

   /* work towards last stack */
   for (; i < 11; ++i)
   {
      while (pCurPos->next)
         pCurPos = pCurPos->next;
      pCurPos->next = layout[(i+1) / 6][(i+1) % 6];
   }

   /* stage 2: deal them back to layout again ... */
   for (i = 0; i < 12; ++i)
   {
      layout[i / 6][i % 6] = pList;
      for (j = 0; j < 3; ++j)
         if (pList && pList->next)
            pList = pList->next;
         else
            break;
      if (j != 3)
         break;
      else
      {
         pCurPos = pList->next;
         pList->next = NULL;
         pList = pCurPos;
      }
   }

   /* rest of stacks are empty */
   for (++i; i < 12; ++i)
      layout[i / 6][i % 6] = NULL;
}

VOID UndoMove(HDC hDC)
{
    CHAR buffer[10];
    RECT *pRect, rect;
    INT column, card;
    HBRUSH hBrush;
    CardRec *pCard;
    INT endRow, endColumn, startRow, startColumn;

    --undoPos;
    endRow = undo[undoPos].endRow;
    startRow = undo[undoPos].startRow;
    endColumn = undo[undoPos].endColumn;
    startColumn = undo[undoPos].startColumn;

    if (endRow < 0) {
        /* move card from foundation back to pile */
        if (!freePos) {
            Message(hWnd, IDSIntFreePos, MB_OK | MB_ICONHAND);
            return;
        }
        pCard = FreeList[--freePos];

        /* move card to pile */
        if (foundation[endColumn] == wDeckBack)
            foundation[endColumn] = 48 + endColumn;
//            foundation[endColumn] = CardIndex(endColumn, king);
        pCard->card = card = foundation[endColumn];
        pCard->next = layout[startRow][startColumn];
        layout[startRow][startColumn] = pCard;

        /* decrement card on foundation */
        foundation[endColumn] -= 4;
//        foundation[endColumn] = CardIndex(CardSuit(card), CardRank(card)-1);

        /* update the foundation */
        cdtDraw(hDC, foundationRect[endColumn].left,
                     foundationRect[endColumn].top,
                     foundation[endColumn], faceup, dwBkgnd);

        /* update the pile */
        cdtDraw(hDC, layoutRect[startRow][startColumn].left,
                     layoutRect[startRow][startColumn].top,
                     pCard->card, faceup, dwBkgnd);
    } else {
        /* move card from one pile to the other */
        pCard = layout[endRow][endColumn];
        layout[endRow][endColumn] = pCard->next;

        pCard->next = layout[startRow][startColumn];
        layout[startRow][startColumn] = pCard;

        /* update pile we moved card back to (start) */
        cdtDraw(hDC, layoutRect[startRow][startColumn].left,
                     layoutRect[startRow][startColumn].top,
                     pCard->card, faceup, dwBkgnd);

        /* update pile we moved card back from (end), which could be empty
        ** now.
        */
        if (layout[endRow][endColumn])
            cdtDraw(hDC, layoutRect[endRow][endColumn].left,
                        layoutRect[endRow][endColumn].top,
                        layout[endRow][endColumn]->card, faceup, dwBkgnd);
        else
            cdtDraw(hDC, layoutRect[endRow][endColumn].left,
                        layoutRect[endRow][endColumn].top,
                        0, remove, dwBkgnd);
    }
}

INT Message(HWND hWnd, WORD wId, WORD wFlags)
{
    static CHAR szBuf[256];

    if (!LoadString(hMyInstance, wId, szBuf, 256) ||
        wId == IDSOOM) {
        lstrcpy(szBuf, szOOM);
        wFlags = MB_ICONHAND | MB_SYSTEMMODAL;
    }

    if (!(wFlags & MB_SYSTEMMODAL))
        wFlags |= MB_TASKMODAL;

    if (!(wFlags & (MB_ICONHAND | MB_ICONEXCLAMATION | MB_ICONINFORMATION)))
        wFlags |= MB_ICONEXCLAMATION;

    return MessageBox(hWnd, szBuf, szAppName, wFlags);
}

VOID DoBacks()
	{

	DialogBox(hMyInstance, MAKEINTRESOURCE(1), hWnd, BackDlgProc);

	}

INT_PTR  CALLBACK BackDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	WORD	cmd;
        static INT modeNew;
	INT iback;
	MEASUREITEMSTRUCT FAR *lpmi;
	DRAWITEMSTRUCT FAR *lpdi;
	HBRUSH hbr;
	RC rc, rcCrd;
	HDC hdc;
	INT i;

	switch(wm)
		{
	case WM_INITDIALOG:
                modeNew = wDeckBack;
		SetFocus(GetDlgItem(hdlg, modeNew));
		return FALSE;

	case WM_COMMAND:
		cmd = GET_WM_COMMAND_ID(wParam, lParam);
		if(cmd >= IDFACEDOWNFIRST && cmd <= IDFACEDOWN12) {
		 	modeNew = cmd;
                        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_DOUBLECLICKED) {
			    ChangeBack((WORD)modeNew);
			    EndDialog(hdlg, 0);
                        }
		} else
			switch(cmd)
				{
			case IDOK:
				ChangeBack((WORD)modeNew);
				/* fall thru */

			case IDCANCEL:
				EndDialog(hdlg, 0);
				break;

				}
		break;

	case WM_MEASUREITEM:
		lpmi = (MEASUREITEMSTRUCT FAR *)lParam;
		lpmi->CtlType = ODT_BUTTON;
		lpmi->itemWidth = xCard /* 32 */;
		lpmi->itemHeight = yCard /* 54 */;
		break;
	case WM_DRAWITEM:
		lpdi = (DRAWITEMSTRUCT FAR *)lParam;

		CopyRect((LPRECT) &rc, &lpdi->rcItem);
		rcCrd = rc;
		InflateRect((LPRECT) &rcCrd, -3, -3);
		hdc = lpdi->hDC;

		if (lpdi->itemAction == ODA_DRAWENTIRE)
		  {
		    cdtDrawExt(hdc, rcCrd.xLeft, rcCrd.yTop,
			    rcCrd.xRight-rcCrd.xLeft, rcCrd.yBot-rcCrd.yTop,
			    lpdi->CtlID, FACEDOWN, 0L);
		    FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
		    break;
		  }
		if (lpdi->itemAction == ODA_SELECT)
		    InvertRect(hdc, (LPRECT)&rcCrd);

		if (lpdi->itemAction == ODA_FOCUS)
		    FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);

		break;
	default:
		return FALSE;
		}
	return TRUE;
	}

BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus)
	{
	HBRUSH hbr;
	RC rc;
	hbr = CreateSolidBrush(GetSysColor(fFocus ? COLOR_HIGHLIGHT : COLOR_WINDOW));
	if(hbr == NULL)
		return FALSE;
	rc = *prc;
	FrameRect(hdc, (LPRECT) &rc, hbr);
	InflateRect((LPRECT) &rc, -1, -1);
	FrameRect(hdc, (LPRECT) &rc, hbr);
	DeleteObject(hbr);
	return TRUE;
	}


VOID ChangeBack(WORD wNewDeckBack)
{
    HDC hDC;
    INT i;

    hDC = GetDC(hWnd);

    for (i = 0; i < 4; ++i) {
        if (foundation[i] == wDeckBack) {
            if (hDC)
                cdtDraw(hDC, foundationRect[i].left, foundationRect[i].top, wNewDeckBack, facedown, dwBkgnd);
            foundation[i] = wNewDeckBack;
        }
    }

    if (hDC)
        ReleaseDC(hWnd, hDC);

    wDeckBack = wNewDeckBack;
    return;
}

VOID DrawAnimate(INT cd, MPOINT *ppt, INT iani)
{
    HDC hDC;
    INT i;

    if(!(hDC = GetDC(hWnd)))
	    return;

    for (i = 0; i < 4; ++i)
        if (foundation[i] == wDeckBack)
            cdtAnimate(hDC, cd, foundationRect[i].left, foundationRect[i].top, iani);

    ReleaseDC(hWnd, hDC);
}

BOOL DeckAnimate(INT iqsec)
{
    INT iani;
    MPOINT pt;

    pt.x = pt.y = 0; /* not used! */

    switch(wDeckBack) {
        case IDFACEDOWN3:
	        DrawAnimate(IDFACEDOWN3, &pt, iqsec % 4);
	        break;
        case IDFACEDOWN10:  // krazy kastle
	        DrawAnimate(IDFACEDOWN10, &pt, iqsec % 2);
	        break;

        case IDFACEDOWN11:  // sanflipe
	        if((iani = (iqsec+4) % (50*4)) < 4)
		        DrawAnimate(IDFACEDOWN11, &pt, iani);
	        else
		        // if a menu overlapps an ani while it is ani'ing, leaves deck
		        // bitmap in inconsistent state...
		        if(iani % 6 == 0)
			        DrawAnimate(IDFACEDOWN11, &pt, 3);
	        break;
        case IDFACEDOWN12:  // SLIME
	        if((iani = (iqsec+4) % (15*4)) < 4)
		        DrawAnimate(IDFACEDOWN12, &pt, iani);
	        else
		        // if a menu overlapps an ani while it is ani'ing, leaves deck
		        // bitmap in inconsistent state...
		        if(iani % 6 == 0)
			        DrawAnimate(IDFACEDOWN12, &pt, 3);
	        break;
    }

    return TRUE;
}

VOID  APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime)
{
    static INT x = 0;

    if (bGameInProgress)
        DeckAnimate(x++);
    return;
}


VOID SaveState(VOID)
{
    CHAR sz[80];

    wsprintf(sz, "%ld %ld %ld %ld %ld", nStats[0], nStats[1],
             nStats[2], nStats[3], nStats[4]);
    WritePrivateProfileString(szAppName, "Stats", sz, ININAME);

    wsprintf(sz, "%d %d", wErrorMessages, wDeckBack);
    WritePrivateProfileString(szAppName, "MenuState", sz, ININAME);
}

VOID DisplayStats(VOID)
{
    CHAR sz[80];

    fDialog(2, hWnd, RecordDlgProc);
}

VOID RestoreState(VOID)
{
    CHAR sz[80], *psz;
    INT col;
    DWORD cchRead;

    cchRead = GetPrivateProfileString(szAppName, "Stats", "0 52 0 0 0", sz,
                                      sizeof(sz), ININAME);

    psz = (cchRead > 0) ? lstrtok(sz, " ") : NULL;
    col = 0;
    if (psz) {
        nStats[0] = atol(psz);
        for (col = 1; col < 5 && psz; ++col)
            nStats[col] = atol(psz = lstrtok(NULL, " "));
    }

    for (; col < 5; ++col)
        nStats[col] = 0;

    cchRead = GetPrivateProfileString(szAppName, "MenuState", "0 65 4", sz,
                                      sizeof(sz), ININAME);

    psz = (cchRead > 0) ? lstrtok(sz, " ") : NULL;
    if (psz) {
        wErrorMessages = (WORD) atoi(psz);
        psz = lstrtok(NULL, " ");

        wDeckBack = IDCARDBACK;
        if (psz)
            wDeckBack = (WORD) atoi(psz);

    } else {
        wErrorMessages = 0;
        wDeckBack = IDCARDBACK;
    }
}

static BOOL IsInString(CHAR c, LPSTR s)
{
   while (*s && *s != c)
      s = AnsiNext(s);

   return *s;
}

/* write our own strtok to avoid pulling in entire string library ... */
LPSTR lstrtok(LPSTR lpStr, LPSTR lpDelim)
{
   static LPSTR lpString;
   LPSTR lpRetVal, lpTemp;

   /* if we are passed new string skip leading delimiters */
   if(lpStr) {
      lpString = lpStr;

      while (*lpString && IsInString(*lpString, lpDelim))
         lpString = AnsiNext(lpString);
   }

   /* if there are no more tokens return NULL */
   if(!*lpString)
      return NULL;

   /* save head of token */
   lpRetVal = lpString;

   /* find delimiter or end of string */
   while(*lpString && !IsInString(*lpString, lpDelim))
      lpString = AnsiNext(lpString);

   /* if we found a delimiter insert string terminator and skip */
   if(*lpString) {
      lpTemp = AnsiNext(lpString);
      *lpString = '\0';
      lpString = lpTemp;
   }

   /* return token */
   return(lpRetVal);
}


/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)						       |
|									       |
|   Description:                                                               |
|	This function displays a dialog box and returns the exit code.	       |
|	the function passed will have a proc instance made for it.	       |
|									       |
|   Arguments:                                                                 |
|	id		resource id of dialog to display		       |
|	hwnd		parent window of dialog 			       |
|	fpfn		dialog message function 			       |
|                                                                              |
|   Returns:                                                                   |
|	exit code of dialog (what was passed to EndDialog)		       |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL fDialog(INT id,HWND hwnd,DLGPROC fpfn)
{
    BOOL	f;
    HANDLE	hInst;

    hInst = (HANDLE)GetWindowLongPtr(hwnd,GWLP_HINSTANCE);
    fpfn  = MakeProcInstance(fpfn,hInst);
    f = (BOOL) DialogBox(hInst,MAKEINTRESOURCE(id),hwnd,fpfn);
    FreeProcInstance ((FARPROC)fpfn);
    return f;
}

INT_PTR  APIENTRY RecordDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CHAR sz[80];
    HWND hwndEdit;
    INT  i;

    switch(wm) {

        case WM_INITDIALOG:
            hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
            SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (szRecordTitle));


            wsprintf(sz, "%ld\t%ld\t%ld\t%ld\t%ld", nStats[TOTAL], nStats[WINS],
                    nStats[HI], nStats[LOW], nStats[TOTAL] ? (nStats[SUM] / nStats[TOTAL]) : 0);
            SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (sz));
            MarkControlReadOnly(hwndEdit, TRUE);
            return TRUE;

	case WM_COMMAND:
	    switch(GET_WM_COMMAND_ID(wParam, lParam)) {
		case IDOK:
                    /* fall thru */

		case IDCANCEL:
                    hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
                    MarkControlReadOnly(hwndEdit, FALSE);
		    EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
		    break;

                case IDD_CLEARSCORES:
                    for (i = 0; i < 5; ++i)
                        nStats[i] = 0;
                    nStats[LOW] = 52;
                    lstrcpy(sz, "0\t0\t0\t52\t0");
                    hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
                    SendMessage(hwndEdit, LB_DELETESTRING, 1, 0L);
                    SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (sz));
                    break;
	    }
	    break;
    }

    return FALSE;
}


static WNDPROC lpOldWP;

VOID MarkControlReadOnly(HWND hwndCtrl, BOOL bReadOnly)
{
    if (bReadOnly)
        lpOldWP = (WNDPROC) SetWindowLongPtr(hwndCtrl, GWLP_WNDPROC,
                                             (LONG_PTR) ReadOnlyProc);
    else
        SetWindowLongPtr(hwndCtrl, GWLP_WNDPROC, (LONG_PTR) lpOldWP);
}

LRESULT APIENTRY ReadOnlyProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
    switch (wMessage) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return 0L;
    }

   return CallWindowProc(lpOldWP, hwnd, wMessage, wParam, lParam);
}

#if 0
VOID ShowStacks(VOID)
{
    CHAR szBuf[80];

    wsprintf(szBuf,
             "%02d %02d %02d %02d %02d %02d\n%02d %02d %02d %02d %02d %02d",
             layout[0][0] ? layout[0][0]->card : -1,
             layout[0][1] ? layout[0][1]->card : -1,
             layout[0][2] ? layout[0][2]->card : -1,
             layout[0][3] ? layout[0][3]->card : -1,
             layout[0][4] ? layout[0][4]->card : -1,
             layout[0][5] ? layout[0][5]->card : -1,
             layout[1][0] ? layout[1][0]->card : -1,
             layout[1][1] ? layout[1][1]->card : -1,
             layout[1][2] ? layout[1][2]->card : -1,
             layout[1][3] ? layout[1][3]->card : -1,
             layout[1][4] ? layout[1][4]->card : -1,
             layout[1][5] ? layout[1][5]->card : -1);

    MessageBox(hWnd, szBuf, "Card Stacks", MB_OK);

    wsprintf(szBuf,
             "%02d %02d %02d %02d %02d %02d\n%02d %02d %02d %02d %02d %02d",
             layout[0][0] ? IndexValue(layout[0][0]->card, ACELOW) : -1,
             layout[0][1] ? IndexValue(layout[0][1]->card, ACELOW) : -1,
             layout[0][2] ? IndexValue(layout[0][2]->card, ACELOW) : -1,
             layout[0][3] ? IndexValue(layout[0][3]->card, ACELOW) : -1,
             layout[0][4] ? IndexValue(layout[0][4]->card, ACELOW) : -1,
             layout[0][5] ? IndexValue(layout[0][5]->card, ACELOW) : -1,
             layout[1][0] ? IndexValue(layout[1][0]->card, ACELOW) : -1,
             layout[1][1] ? IndexValue(layout[1][1]->card, ACELOW) : -1,
             layout[1][2] ? IndexValue(layout[1][2]->card, ACELOW) : -1,
             layout[1][3] ? IndexValue(layout[1][3]->card, ACELOW) : -1,
             layout[1][4] ? IndexValue(layout[1][4]->card, ACELOW) : -1,
             layout[1][5] ? IndexValue(layout[1][5]->card, ACELOW) : -1);

    MessageBox(hWnd, szBuf, "IndexValue", MB_OK);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\cruel\cruel.h ===
#define  IDM_NEWGAME       1
#define  IDM_EXIT          2
#define  IDM_ABOUT         3
#define  IDM_OPTIONSUNDO   4
#define  IDM_OPTIONSERROR  5
#define  IDM_HELP          6
#define  IDM_GAMERECORD    8
#define  IDM_OPTIONSDECK   9

#define  IDM_DOMINIMIZE 20

#define  IDD_OK     1
#define  IDD_CANCEL 0
#define  IDD_EDITWINDOW 100
#define  IDD_RECORD 101
#define  IDD_CLEARSCORES 102

/* help menu item*/
#define MENU_HOWTOPLAY	1000
#define MENU_INDEX      1001
#define MENU_USINGHELP  1003
#define MENU_COMMANDS   1004

/* String IDs */
#define IDSOOM          1000
#define IDSAppName      1001
#define IDSNotNextCard  1002
#define IDSNoCardsMoved 1003
#define IDSWrongSuit    1004
#define IDSWrongRank    1005
#define IDSUndoFull     1006
#define IDSWinner       1007
#define IDSIntFreePos   1008
#define IDSGameOver     1009
#define IDSGameOverS    1010
#define IDSRecordTitle  1011
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\carddll\cdt.h ===
#define CLOADMAX	5

/* Command ids */
#define IDACLUBS	 1
#define ID2CLUBS	 2
#define ID3CLUBS	 3
#define ID4CLUBS	 4
#define ID5CLUBS	 5
#define ID6CLUBS	 6
#define ID7CLUBS	 7
#define ID8CLUBS	 8
#define ID9CLUBS	 9
#define IDTCLUBS	 10
#define IDJCLUBS	 11
#define IDQCLUBS	 12
#define IDKCLUBS	 13

#define IDADIAMONDS	 14
#define ID2DIAMONDS	 15
#define ID3DIAMONDS	 16
#define ID4DIAMONDS	 17
#define ID5DIAMONDS	 18
#define ID6DIAMONDS	 19
#define ID7DIAMONDS	 20
#define ID8DIAMONDS	 21
#define ID9DIAMONDS	 22
#define IDTDIAMONDS	 23
#define IDJDIAMONDS	 24
#define IDQDIAMONDS	 25
#define IDKDIAMONDS	 26

#define IDAHEARTS	 27
#define ID2HEARTS	 28
#define ID3HEARTS	 29
#define ID4HEARTS	 30
#define ID5HEARTS	 31
#define ID6HEARTS	 32
#define ID7HEARTS	 33
#define ID8HEARTS	 34
#define ID9HEARTS	 35
#define IDTHEARTS	 36
#define IDJHEARTS	 37
#define IDQHEARTS	 38
#define IDKHEARTS	 39

#define IDASPADES	 40
#define ID2SPADES	 41
#define ID3SPADES	 42
#define ID4SPADES	 43
#define ID5SPADES	 44
#define ID6SPADES	 45
#define ID7SPADES	 46
#define ID8SPADES	 47
#define ID9SPADES	 48
#define IDTSPADES	 49
#define IDJSPADES	 50
#define IDQSPADES	 51
#define IDKSPADES	 52

#define IDGHOST	53

#define IDFACEDOWN1 	54
#define IDFACEDOWN2 	55
#define IDFACEDOWN3 	56
#define IDFACEDOWN4 	57
#define IDFACEDOWN5 	58
#define IDFACEDOWN6 	59
#define IDFACEDOWN7 	60
#define IDFACEDOWN8 	61
#define IDFACEDOWN9 	62
#define IDFACEDOWN10 	63
#define IDFACEDOWN11 	64
#define IDFACEDOWN12	   65

#define IDFACEDOWNFIRST IDFACEDOWN1
#define IDFACEDOWNLAST IDFACEDOWN12

#define IDX 67
#define IDO 68
#define IDMAX IDDECK



/* internal ID's for animation */

#define IDASLIME1 678
#define IDASLIME2 679

#define IDAKASTL1 680

#define IDAFLIPE1 681
#define IDAFLIPE2 682


#define IDABROBOT1 683
#define IDABROBOT2 684


/* Red non-face card frame */
#define IDFRAME 999


#define FACEUP		0
#define FACEDOWN	1   /* for compatibility with old apps, use IDFACEDOWNFIRST..IDFACEDOWNLAST */
#define HILITE		2
#define GHOST		3
#define REMOVE		4
#define INVISIBLEGHOST 5
#define DECKX		6
#define DECKO		7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\dialog.c ===
/****************************************************************************

Dialog.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32

Contains dialog box callback procedures.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"


static void CentreDialog(HWND hDlg);


/****************************************************************************

MoveColDlg

If there is ambiguity about whether the user intends to move a single card
or a column to an empty column, this dialog lets the user decide.

The return code in EndDialog tells the caller the user's choice:
    -1      user chose cancel
    FALSE   user chose to move a single card
    TRUE    user chose to move a column

****************************************************************************/

INT_PTR  APIENTRY MoveColDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:                 
            CentreDialog(hDlg);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    EndDialog(hDlg, -1);
                    return TRUE;
                    break;

                case IDC_SINGLE:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                    break;

                case IDC_MOVECOL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;
            }
            break;
    }
    return FALSE;                             /* Didn't process a message    */
}


/****************************************************************************

GameNumDlg

The variable gamenumber must be set with a default value before this
dialog is invoked.  That number is placed in an edit box where the user
can accept it by pressing Enter or change it.  EndDialog returns TRUE
if the user chose a valid number (1 to MAXGAMENUMBER) and FALSE otherwise.

****************************************************************************/

INT_PTR  APIENTRY GameNumDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    // For context sensitive help
    static DWORD aIds[] = {     
        IDC_GAMENUM,        IDH_GAMENUM,        
        0,0 }; 

    switch (message) {
        case WM_INITDIALOG:                     // set default gamenumber
            CentreDialog(hDlg);
            SetDlgItemInt(hDlg, IDC_GAMENUM, gamenumber, FALSE);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    gamenumber = CANCELGAME;
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDOK:
                    gamenumber = (int) GetDlgItemInt(hDlg, IDC_GAMENUM, NULL, TRUE);

                    // negative #s are special cases -- unwinnable shuffles

                    if (gamenumber < -2 || gamenumber > MAXGAMENUMBER)
                        gamenumber = 0;
                    EndDialog(hDlg, gamenumber != 0);
                    return TRUE;
            }
            break;

         // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}


/****************************************************************************

YouWinDlg(HWND, unsigned, UINT, LONG)

****************************************************************************/

INT_PTR  APIENTRY YouWinDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hSelect;                // handle to check box

    switch (message) {
        case WM_INITDIALOG:                 // initialize checkbox
            hSelect = GetDlgItem(hDlg, IDC_YWSELECT);
            SendMessage(hSelect, BM_SETCHECK, bSelecting, 0);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDYES:
                    hSelect = GetDlgItem(hDlg, IDC_YWSELECT);
                    bSelecting = (BOOL) SendMessage(hSelect, BM_GETCHECK, 0, 0);
                    EndDialog(hDlg, IDYES);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, IDNO);
                    return TRUE;
            }
            break;
    }
    return FALSE;                           // didn't process a message
}


/****************************************************************************

YouLoseDlg

The user can choose to play a new game (same shuffle or new shuffle) or not.

****************************************************************************/

INT_PTR  APIENTRY YouLoseDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hSameGame;              // handle to check box
    BOOL    bSame;                  // value of check box

    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            bGameInProgress = FALSE;
            UpdateLossCount();
            hSameGame = GetDlgItem(hDlg, IDC_YLSAME);
            SendMessage(hSameGame, BM_SETCHECK, TRUE, 0);   // default to same
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDYES:
                case IDOK:
                    hSameGame = GetDlgItem(hDlg, IDC_YLSAME);
                    bSame = (BOOL) SendMessage(hSameGame, BM_GETCHECK, 0, 0);
                    if (bSame)
                        PostMessage(hMainWnd,WM_COMMAND,IDM_RESTART,gamenumber);
                    else
                    {
                        if (bSelecting)
                            PostMessage(hMainWnd, WM_COMMAND, IDM_SELECT, 0);
                        else
                            PostMessage(hMainWnd, WM_COMMAND, IDM_NEWGAME, 0);
                    }
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    gamenumber = 0;
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;
    }
    return FALSE;
}


#define ARRAYSIZE(a) ( sizeof(a) / sizeof(a[0]) )

/****************************************************************************

StatsDlg

This dialog box shows current wins and losses, as well as total stats
including data from .ini file.

The IDC_CLEAR message clears out the entire section from the .ini file.

****************************************************************************/

INT_PTR  APIENTRY StatsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hText;                      // handle to text control with stats
    UINT    cTLost, cTWon;              // total losses and wins
    UINT    cTLosses, cTWins;           // streaks
    UINT    wPct;                       // winning % this session
    UINT    wTPct;                      // winning % including .ini data
    UINT    wStreak;                    // current streak amount
    UINT    wSType;                     // current streak type
    TCHAR   sbuffer[40];                // streak buffer
    int     nResp;                      // messagebox response
    TCHAR   buffer[256];                // extra buffer needed for loadingstrings.
    LONG    lRegResult;                 // used to store return code from registry call

    // for context sensitive help
    static DWORD aIds[] = {     
        IDC_CLEAR,        IDH_CLEAR,
        IDC_STEXT1,       IDH_STEXT1,
        IDC_STEXT2,       IDH_STEXT2,
        IDC_STEXT3,       IDH_STEXT3,
        0,0 }; 


    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            wPct = CalcPercentage(cWins, cLosses);

            /* Get cT... data from the registry */

            lRegResult = REGOPEN

            if (ERROR_SUCCESS == lRegResult)
            {
                cTLost = GetInt(pszLost, 0);
                cTWon  = GetInt(pszWon, 0);

                wTPct  = CalcPercentage(cTWon, cTLost);

                cTLosses = GetInt(pszLosses, 0);
                cTWins   = GetInt(pszWins, 0);

                wStreak = GetInt(pszStreak, 0);
                if (wStreak != 0)
                {
                    wSType = GetInt(pszSType, 0);

                    if (wStreak == 1)
                    {
                        LoadString(hInst, (wSType == WON ? IDS_1WIN : IDS_1LOSS),
                                    sbuffer, ARRAYSIZE(sbuffer));
                    }
                    else
                    {
                        LoadString(hInst, (wSType == WON ? IDS_WINS : IDS_LOSSES),
                                    smallbuf, SMALL);
                        wsprintf(sbuffer, smallbuf, wStreak);
                    }
                }
                else
                    wsprintf(sbuffer, TEXT("%u"), 0);

                // set the dialog text.
                LoadString(hInst, IDS_STATS1, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, wPct, cWins, cLosses);
                hText = GetDlgItem(hDlg, IDC_STEXT1);
                SetWindowText(hText, bigbuf);

                LoadString(hInst, IDS_STATS2, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, wTPct, cTWon, cTLost);
                hText = GetDlgItem(hDlg, IDC_STEXT2);
                SetWindowText(hText, bigbuf);

                LoadString(hInst, IDS_STATS3, buffer, ARRAYSIZE(buffer));
                wsprintf(bigbuf, buffer, cTWins, cTLosses, (LPTSTR) sbuffer);
                hText = GetDlgItem(hDlg, IDC_STEXT3);
                SetWindowText(hText, bigbuf);


                REGCLOSE;
            }
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDC_CLEAR:
                    LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                    LoadString(hInst, IDS_RU_SURE, bigbuf, BIG);
                    MessageBeep(MB_ICONQUESTION);
                    nResp = MessageBox(hDlg, bigbuf, smallbuf,
                                       MB_YESNO | MB_ICONQUESTION);
                    if (nResp == IDNO)
                        break;

                    lRegResult = REGOPEN

                    if (ERROR_SUCCESS == lRegResult)
                    {
                        DeleteValue(pszWon);
                        DeleteValue(pszLost);
                        DeleteValue(pszWins);
                        DeleteValue(pszLosses);
                        DeleteValue(pszStreak);
                        DeleteValue(pszSType);
                        REGCLOSE
                    }

                    cWins = 0;
                    cLosses = 0;
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;
        
        // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}


/****************************************************************************

CalcPercentage

Percentage is rounded off, but never up to 100.

****************************************************************************/

UINT CalcPercentage(UINT cWins, UINT cLosses)
{
    UINT    wPct = 0;
    UINT    lDenom;         // denominator

    lDenom = cWins + cLosses;

    if (lDenom != 0L)
        wPct = (((cWins * 200) + lDenom) / (2 * lDenom));

    if (wPct >= 100 && cLosses != 0)
        wPct = 99;

    return wPct;
}


/****************************************************************************

GetHelpFileName()

Puts the full path name of the helpfile in bigbuf
side effect: contents of bigbuf are altered

****************************************************************************/

CHAR *GetHelpFileName()
{
    CHAR    *psz;               // used to construct pathname

    psz = bighelpbuf + GetModuleFileNameA(hInst, bighelpbuf, BIG-1);

    if (psz - bighelpbuf > 4)
    {
        while (*psz != '.')
            --psz;
    }

    strcpy(psz, ".chm");
       
    return bighelpbuf;
}


/****************************************************************************

Options Dlg

****************************************************************************/

INT_PTR OptionsDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hMessages;          // handle to messages checkbox
    HWND    hQuick;             // quick checkbox
    HWND    hDblClick;          // double click checkbox


    // For context sensitive help
    static DWORD aIds[] = {     
        IDC_MESSAGES,       IDH_OPTIONS_MESSAGES,     
        IDC_QUICK,          IDH_OPTIONS_QUICK,     
        IDC_DBLCLICK,       IDH_OPTIONS_DBLCLICK,         
        0,0 }; 


    switch (message) {
        case WM_INITDIALOG:
            CentreDialog(hDlg);
            hMessages = GetDlgItem(hDlg, IDC_MESSAGES);
            SendMessage(hMessages, BM_SETCHECK, bMessages, 0);

            hQuick = GetDlgItem(hDlg, IDC_QUICK);
            SendMessage(hQuick, BM_SETCHECK, bFastMode, 0);

            hDblClick = GetDlgItem(hDlg, IDC_DBLCLICK);
            SendMessage(hDblClick, BM_SETCHECK, bDblClick, 0);

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDYES:
                case IDOK:
                    hMessages = GetDlgItem(hDlg, IDC_MESSAGES);
                    bMessages = (BOOL)SendMessage(hMessages, BM_GETCHECK, 0, 0);

                    hQuick = GetDlgItem(hDlg, IDC_QUICK);
                    bFastMode = (BOOL)SendMessage(hQuick, BM_GETCHECK, 0, 0);

                    hDblClick = GetDlgItem(hDlg, IDC_DBLCLICK);
                    bDblClick = (BOOL)SendMessage(hDblClick, BM_GETCHECK, 0, 0);

                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
            break;

        // context sensitive help.
        case WM_HELP: 
            WinHelp(((LPHELPINFO) lParam)->hItemHandle, TEXT("freecell.hlp"), 
            HELP_WM_HELP, (ULONG_PTR) aIds);         
            break;  

        case WM_CONTEXTMENU: 
            WinHelp((HWND) wParam, TEXT("freecell.hlp"), HELP_CONTEXTMENU, 
            (ULONG_PTR) aIds);         
            break;   

    }
    return FALSE;
}



/****************************************************************************

ReadOptions and WriteOptions retrieve and update .ini file

****************************************************************************/

VOID ReadOptions()
{
    LONG lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        bMessages = GetInt(pszMessages, TRUE);
        bFastMode = GetInt(pszQuick, FALSE);
        bDblClick = GetInt(pszDblClick, TRUE);
        REGCLOSE
    }
}


VOID WriteOptions()
{
    LONG lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        if (bMessages)
            DeleteValue(pszMessages);
        else
            SetInt(pszMessages, 0);

        if (bFastMode)
            SetInt(pszQuick, 1);
        else
            DeleteValue(pszQuick);

        if (bDblClick)
            DeleteValue(pszDblClick);
        else
            SetInt(pszDblClick, 0);

        RegFlushKey(hkey);

        REGCLOSE
    }
}


/****************************************************************************

Registry helper functions

These all assume that REGOPEN has been called first.
Remember to REGCLOSE when you're done.
DeleteValue is implemented as a macro.

****************************************************************************/

int GetInt(const TCHAR *pszValue, int nDefault)
{
    DWORD       dwType = REG_BINARY;
    DWORD       dwSize = sizeof(LONG_PTR);
    LONG_PTR    dwNumber, ret;

    if (!hkey)
	return nDefault;

    ret = RegQueryValueEx(hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
                &dwSize);

    if (ret)
        return nDefault;

    return (int)dwNumber;
}

long SetInt(const TCHAR *pszValue, int n)
{
    long dwNumber = (long)n;
    if (hkey)
    	return RegSetValueEx(hkey, pszValue, 0, REG_BINARY,
                (unsigned char *)&dwNumber, sizeof(dwNumber));
    else
	return 1;
}


/****************************************************************************

CentreDialog

****************************************************************************/
void CentreDialog(HWND hDlg)
{
    RECT rcDlg, rcMainWnd, rcOffset;

    GetClientRect(hMainWnd, &rcMainWnd);
    GetClientRect(hDlg, &rcDlg);
    GetWindowRect(hMainWnd, &rcOffset);
    rcOffset.top += GetSystemMetrics(SM_CYCAPTION);
    rcOffset.top += GetSystemMetrics(SM_CYMENU);

    SetWindowPos(hDlg, 0,
        ((rcMainWnd.right - rcDlg.right) / 2) + rcOffset.left,
        ((rcMainWnd.bottom - rcDlg.bottom) / 2) + rcOffset.top,
        0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\freecons.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**        Copyright(c) Microsoft Corp., 1991, 1992, 1993                 **/
/***************************************************************************/

//  Defined constants for FreeCell

#define IDM_ABOUT       101
#define IDM_NEWGAME     102
#define IDM_SELECT      103
#define IDM_MOVECARD    104
#define IDM_STATS       105
#define IDM_HELP        106
#define IDM_RESTART     107
#define IDM_EXIT        108
#define IDM_OPTIONS     109
#define IDM_HOWTOPLAY   110
#define IDM_HELPONHELP  111
#define IDM_FAKETIMER   112
#define IDM_CHEAT       114
#define IDM_UNDO        115

#define IDC_MOVECOL     201
#define IDC_SINGLE      202
#define IDC_GAMENUM     203
#define IDC_YLSAME      205
#define IDC_STEXT       206
#define IDC_CLEAR       207
#define IDC_YWSELECT    208
#define IDC_MESSAGES    209
#define IDC_QUICK       210
#define IDC_DBLCLICK    211
#define IDC_STEXT1      212
#define IDC_STEXT2      213
#define IDC_STEXT3      214

#define IDS_APPNAME     301
#define IDS_CREDITS     302
#define IDS_APPNAME2    303
#define IDS_MEMORY      304
#define IDS_RESIGN      305
#define IDS_ILLEGAL     306
#define IDS_TOOFEWFREE  307
#define IDS_CARDSLEFT   308
#define IDS_RU_SURE     309
#define IDS_1WIN        310
#define IDS_1LOSS       311
#define IDS_WINS        312
#define IDS_LOSSES      313
#define IDS_HELP1       314
#define IDS_HELP2       315
#define IDS_STREAK      316
#define IDS_STYPE       317
#define IDS_FULLNAME    318
#define IDS_STATS1      319
#define IDS_STATS2      320
#define IDS_STATS3      321

#define DLG_MOVECOL     500
#define DLG_GAMENUM     501
#define DLG_YOULOSE     502
#define DLG_YOUWIN      503
#define DLG_STATS       504
#define DLG_OPTIONS     505

#define ID_ICON_MAIN    601


#define IDH_OPTIONS_MESSAGES  1001   
#define IDH_OPTIONS_QUICK     1002
#define IDH_OPTIONS_DBLCLICK  1003
#define IDH_GAMENUM           1004
#define IDH_CLEAR             1005
#define IDH_STEXT1            1006
#define IDH_STEXT2            1007
#define IDH_STEXT3            1008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\game.c ===
/****************************************************************************

Game.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Routines for playing the game are here and in game2.c

****************************************************************************/


#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <memory.h>


/****************************************************************************

SetFromLoc

User clicks to select card to transfer FROM.

****************************************************************************/

VOID SetFromLoc(HWND hWnd, UINT x, UINT y)
{
    HDC  hDC;
    UINT col, pos;

    wFromCol = EMPTY;                       // assume we didn't find a card
    wFromPos = EMPTY;

    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

    if (Point2Card(x, y, &col, &pos))
    {

        if (col == TOPROW)
        {
            if (card[TOPROW][pos] == EMPTY || pos > 3)
                return;
        }
        else
        {
            pos = FindLastPos(col);
            if (pos == EMPTY)               // empty column
                return;
        }
    }
    else
        return;

    wFromCol = col;                     // ok, we have a card
    wFromPos = pos;
    wMouseMode = TO;
    hDC = GetDC(hWnd);
    DrawCard(hDC, col, pos, card[col][pos], HILITE);
    if (col == TOPROW && pos < 4)
        DrawKing(hDC, LEFT, TRUE);
    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

ProcessMoveRequest

After user has selected a FROM card with SetFromLoc() above, he then
chooses a TO location with the mouse which this function processes.

Note that the layout of the cards (the card array) is copied into
an array called shadow.  This is so queued move requests can be determined
before we commit to moving the cards.

****************************************************************************/

VOID ProcessMoveRequest(HWND hWnd, UINT x, UINT y)
{
    UINT tcol, tpos;        // location to move selected card TO
    UINT freecells;         // number of free cells unoccupied
    UINT trans;             // number of cards requested transfer requires
    UINT maxtrans;          // MaxTransfer() number
    INT  i;                 // index
    TCHAR buffer[160];      // extra buffer needed for MessageBox

    assert(wFromCol != EMPTY);

    /* Make copy of card[][] in shadow[][] */

    memcpy(&(shadow[0][0]), &(card[0][0]), sizeof(card));

    Point2Card(x, y, &tcol, &tpos);     // determine requested TO loc.

    if (tcol >= MAXCOL)                 // if illegal move selected...
    {
        tpos = wFromPos;                // cancel it.
        tcol = wFromCol;
    }

    if (tcol == TOPROW)                 // if moving to top row
    {
        if (tpos > 7)                   // illegal move...
        {
            tpos = wFromPos;            // so cancel it.
            tcol = wFromCol;
        }
    }
    else                                // if moving to a column...
    {
        tpos = FindLastPos(tcol);       // find end of column
        if (tpos == EMPTY)              // if column is empty...
            tpos = 0;                   // move to top of column.
    }

    /* if moving between non-empty columns */

    if (wFromCol != TOPROW && tcol != TOPROW && card[tcol][0] != EMPTY)
    {
        freecells = 0;                          // count free freecells
        for (i = 0; i < 4; i++)
            if (card[TOPROW][i] == EMPTY)
                freecells++;

        trans = NumberToTransfer(wFromCol, tcol);   // how many required?
        DEBUGMSG(TEXT("trans is %u  "), trans);
        DEBUGMSG(TEXT("and MaxTransfer() is %u\r\n"), MaxTransfer());

        if (trans > 0)                              // legal move?
        {
            maxtrans = MaxTransfer();
            if (trans <= maxtrans)                  // enough free cells?
            {
                MultiMove(wFromCol, tcol);
            }
            else if (bMessages)
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_TOOFEWFREE, buffer, sizeof(buffer)/sizeof(TCHAR));
                wsprintf(bigbuf, buffer, trans, maxtrans);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);

                /* illegal move, so deselect that card */

                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
        else
        {
            if (bMessages)
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_ILLEGAL, bigbuf, BIG);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
    }
    else        // else move involves TOPROW or move to empty column
    {
        bMoveCol = 0;
        if (IsValidMove(hWnd, tcol, tpos))
        {
            if (bMoveCol)                       // user selected move column?
                MoveCol(wFromCol, tcol);
            else
                QueueTransfer(wFromCol, wFromPos, tcol, tpos);
        }
        else
        {
            if (bMessages && (bMoveCol != -1))  // user did not select Cancel
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_ILLEGAL, bigbuf, BIG);
                MessageBeep(MB_ICONINFORMATION);
                MessageBox(hWnd, bigbuf, smallbuf, MB_ICONINFORMATION);
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else if (bMoveCol == -1)            // user selected cancel
            {
                // deselect
                QueueTransfer(wFromCol, wFromPos, wFromCol, wFromPos);
            }
            else
                return;
        }
    }

    Cleanup();              // queue transfers of unneeded cards
    MoveCards(hWnd);        // start transferring queued cards
    wMouseMode = FROM;      // next mouse click chooses FROM card
}


/****************************************************************************

ProcessDoubleClick

Double clicking on card in a column moves it to the first free cell found.
After finding the free cell, this routine is identical to ProcessMoveRequest.

****************************************************************************/

BOOL ProcessDoubleClick(HWND hWnd)
{
    UINT freecell = EMPTY;          // assume none found
    INT  i;                         // counter

    for (i = 3; i >= 0; i--)            // look for free cell;
        if (card[TOPROW][i] == EMPTY)
            freecell = (UINT) i;

    if (freecell == EMPTY)              // if none found
        return FALSE;

    memcpy(&(shadow[0][0]), &(card[0][0]), sizeof(card));

    wFromPos = FindLastPos(wFromCol);
    QueueTransfer(wFromCol, wFromPos, TOPROW, freecell);
    Cleanup();
    MoveCards(hWnd);
    wMouseMode = FROM;
    return TRUE;
}


/****************************************************************************

IsValidMove

This function determines if moving from wFromCol,wFromPos to tcol,tpos
is valid.  It can assume wFromCol and tcol are not both non-empty columns.
In other words, except for moves to empty columns, it is concerned with
moving only one card.

If the move is to an empty column, the user can select if he wants to move
one card or as much of the column as possible.

****************************************************************************/

BOOL IsValidMove(HWND hWnd, UINT tcol, UINT tpos)
{
    CARD    fcard, tcard;           // card values (0 to 51)
    UINT    trans;                  // num cards required for transfer
    UINT    freecells;              // num of unoccupied free cells
    UINT    pos;

    DEBUGMSG(TEXT("IVM: tpos is %d\r\n"), tpos);
    assert (tpos < MAXPOS);

    bMoveCol = FALSE;               // assume FALSE

    /* allow cancel move from top row. */

    if (wFromCol == TOPROW && tcol == TOPROW && wFromPos == tpos)
        return TRUE;

    fcard = card[wFromCol][wFromPos];
    tcard = card[tcol][tpos];

    /* transfer to empty column */

    if ((wFromCol != TOPROW) && (tcol != TOPROW) && (card[tcol][0] == EMPTY))
    {
        trans = NumberToTransfer(wFromCol, tcol);   // how many required?
        freecells = 0;
        for (pos = 0; pos < 4; pos++)               // count free cells
            if (card[TOPROW][pos] == EMPTY)
                freecells++;

        if (freecells == 0 && trans > 1)            // no freecells anyway
            trans = 1;

        if (trans == 0)                             // if no valid move
            return FALSE;
        else if (trans == 1)                        // if only 1 card can move
            return TRUE;

        /* If multiple cards can move, user must disambiguate request. */

        bMoveCol = (BOOL) DialogBox(hInst, TEXT("MoveCol"), hWnd, MoveColDlg);

        if (bMoveCol == -1)         // CANCEL chosen
            return FALSE;

        return TRUE;
    }

    if (tcol == TOPROW)
    {
        if (tpos < 4)               // free cells
        {
            if (tcard == EMPTY)
                return TRUE;
            else
                return FALSE;
        }
        else                        // home cells
        {
            if (VALUE(fcard) == ACE && tcard == EMPTY)      // ace on new pile
                return TRUE;

            else if (SUIT(fcard) == SUIT(tcard))            // same suit
            {
                if (VALUE(fcard) == (VALUE(tcard) + 1))     // next card
                    return TRUE;
                else
                    return FALSE;
            }
            return FALSE;
        }
    }
    else                                // tcol is not TOPROW
    {
        if (card[tcol][0] == EMPTY)     // top of empty column always ok
            return TRUE;

        return FitsUnder(fcard, tcard);
    }
}


/****************************************************************************

Cleanup

This function checks if exposed cards (cards in home cells or bottoms
of columns) are no longer needed (Useless.)

When it finds cards it doesn't need, it queues them for transfer.  It
keeps looking until an entire pass finds no new useless cards.

****************************************************************************/

VOID Cleanup()
{
    UINT    col, pos;
    UINT    i;                      // counter
    CARD    c;
    BOOL    bMore = TRUE;           // assume we need another pass

    while (bMore)
    {
        bMore = FALSE;

        for (pos = 0; pos < 4; pos++)       // do TOPROW first
        {
            c = card[TOPROW][pos];
            if (Useless(c))                 // if card is discardable
            {
                bMore = TRUE;                       // need another pass

                /* If this is the first card of this suit, we need to
                   determine which home cell it can use.  */

                if (homesuit[SUIT(c)] == EMPTY)
                {
                    i = 4;
                    while (card[TOPROW][i] != EMPTY)
                        i++;
                    homesuit[SUIT(c)] = i;
                }
                QueueTransfer(TOPROW, pos, TOPROW, homesuit[SUIT(c)]);
            }
        }

        for (col = 1; col <= 8; col++)          // do columns next
        {
            pos = FindLastPos(col);
            if (pos != EMPTY)
            {
                c = card[col][pos];
                if (Useless(c))
                {
                    bMore = TRUE;
                    if (homesuit[SUIT(c)] == EMPTY)
                    {
                        i = 4;
                        while (card[TOPROW][i] != EMPTY)
                            i++;
                        homesuit[SUIT(c)] = i;
                    }
                    QueueTransfer(col, pos, TOPROW, homesuit[SUIT(c)]);
                }
            }
        }
    }
}


/****************************************************************************

Useless

returns TRUE if a card can be safely discarded (no existing cards could
possibly play on it.)

Note that the lines identified with // *** are required in the 32 bit version
since EMPTY == 0xFFFF is not longer equal to -1 as was the case in 16 bit

****************************************************************************/

BOOL Useless(CARD c)
{
    CARD limit;                     // top home card of this suit

    if (c == EMPTY)
        return FALSE;               // no card to discard

    if (bCheating == CHEAT_WIN)
        return TRUE;

    if (VALUE(c) == ACE)
        return TRUE;                // ACEs can always be cleaned up

    else if (VALUE(c) == DEUCE)     // DEUCEs need only check if ACE is up
    {
        if (home[SUIT(c)] == ACE)
            return TRUE;
        else
            return FALSE;
    }
    else                            // else check both cards that can play on it
    {
        limit = VALUE(c) - 1;
        if (home[SUIT(c)] != limit) // is this the next card?
            return FALSE;

        if (COLOUR(c) == RED)
        {
            if (home[CLUB] == EMPTY || home[SPADE] == EMPTY)  // ***
                return FALSE;
            else
                return (home[CLUB] >= limit && home[SPADE] >= limit);
        }
        else
        {
            if (home[DIAMOND] == EMPTY || home[HEART] == EMPTY)   // ***
                return FALSE;
            else
                return (home[DIAMOND] >= limit && home[HEART] >= limit);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\game2.c ===
/****************************************************************************

Game2.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Routines for playing the game are here and in game.c

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <ctype.h>                  // for isdigit()


static HCURSOR  hFlipCursor;

/******************************************************************************

MaxTransfer

This function and the recursive MaxTransfer2 determine the maximum
number of cards that could be transfered given the current number
of free cells and empty columns.

******************************************************************************/

UINT MaxTransfer()
{
    UINT freecells = 0;
    UINT freecols  = 0;
    UINT col, pos;

    for (pos = 0; pos < 4; pos++)               // count free cells
        if (card[TOPROW][pos] == EMPTY)
            freecells++;

    for (col = 1; col <= 8; col++)              // count empty columns
        if (card[col][0] == EMPTY)
            freecols++;

    return MaxTransfer2(freecells, freecols);
}

UINT MaxTransfer2(UINT freecells, UINT freecols)
{
   if (freecols == 0)
      return(freecells + 1);
   return(freecells + 1 + MaxTransfer2(freecells, freecols-1));
}


/******************************************************************************

NumberToTransfer

Given a from column and a to column, this function returns the number of
cards required to do the transfer, or 0 if there is no legal move.

If the transfer is from a column to an empty column, this function returns
the maximum number of cards that could transfer.

******************************************************************************/

UINT NumberToTransfer(UINT fcol, UINT tcol)
{
    UINT fpos, tpos;
    CARD tcard;                         // card to transfer onto
    UINT number = 0;                    // the returned result

    assert(fcol > 0 && fcol < 9);
    assert(tcol > 0 && tcol < 9);
    assert(card[fcol][0] != EMPTY);

    if (fcol == tcol)
        return  1;                      // cancellation takes one move

    fpos = FindLastPos(fcol);

    if (card[tcol][0] == EMPTY)         // if transfer to empty column
    {
        while (fpos > 0)
        {
            if (!FitsUnder(card[fcol][fpos], card[fcol][fpos-1]))
                break;
            fpos--;
            number++;
        }
        return (number+1);
    }
    else
    {
        tpos = FindLastPos(tcol);
        tcard = card[tcol][tpos];
        for (;;)
        {
            number++;
            if (FitsUnder(card[fcol][fpos], tcard))
                return number;
            if (fpos == 0)
                return 0;
            if (!FitsUnder(card[fcol][fpos], card[fcol][fpos-1]))
                return 0;
            fpos--;
        }
    }
}


/******************************************************************************

FitsUnder

returns TRUE if fcard fits under tcard

******************************************************************************/

BOOL FitsUnder(CARD fcard, CARD tcard)
{
    if ((VALUE(tcard) - VALUE(fcard)) != 1)
        return FALSE;

    if (COLOUR(fcard) == COLOUR(tcard))
        return FALSE;

    return TRUE;
}



/******************************************************************************

IsGameLost

If there are legal moves remaining, the game is not lost and this function
returns without doing anything.

Otherwise, it pops up the YouLose dialog box.

******************************************************************************/

VOID IsGameLost(HWND hWnd)
{
    UINT    col, pos;
    UINT    fcol, tcol;
    CARD    lastcard[MAXCOL];       // array of cards at bottoms of columns
    CARD    c;
    UINT    cMoves = 0;             // count of legal moves remaining

    if (bCheating == CHEAT_LOSE)
        goto cheatloselabel;

    for (pos = 0; pos < 4; pos++)           // any free cells?
        if (card[TOPROW][pos] == EMPTY)
            return;

    for (col = 1; col < MAXCOL; col++)      // any free columns?
        if (card[col][0] == EMPTY)
            return;

    /* Do the bottom cards of any column fit in the home cells? */

    for (col = 1; col < MAXCOL; col++)
    {
        lastcard[col] = card[col][FindLastPos(col)];
        c = lastcard[col];
        if (VALUE(c) == ACE)
            cMoves++;
        if (home[SUIT(c)] == (VALUE(c) - 1))    // fits in home cell?
            cMoves++;
    }

    /* Do any of the cards in the free cells fit in the home cells? */

    for (pos = 0; pos < 4; pos++)
    {
        c = card[TOPROW][pos];
        if (home[SUIT(c)] == (VALUE(c) - 1))
            cMoves++;
    }

    /* Do any of the cards in the free cells fit under a column? */

    for (pos = 0; pos < 4; pos++)
        for (col = 1; col < MAXCOL; col++)
            if (FitsUnder(card[TOPROW][pos], lastcard[col]))
                cMoves++;

    /* Do any of the bottom cards fit under any other bottom card? */

    for (fcol = 1; fcol < MAXCOL; fcol++)
        for (tcol = 1; tcol < MAXCOL; tcol++)
            if (tcol != fcol)
                if (FitsUnder(lastcard[fcol], lastcard[tcol]))
                    cMoves++;

    if (cMoves > 0)
    {
        if (cMoves == 1)                    // one move left
        {
            cFlashes = 4;                   // flash this many times

            if (idTimer != 0)
                KillTimer(hWnd, FLASH_TIMER);

            idTimer = SetTimer(hWnd, FLASH_TIMER, FLASH_INTERVAL, NULL);
        }
        return;
    }

    /* We've tried everything.  There are no more legal moves. */

  cheatloselabel:
    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);
    DialogBox(hInst, TEXT("YouLose"), hWnd, YouLoseDlg);
    gamenumber = 0;                         // cancel mouse activity
    bCheating = FALSE;
}


/****************************************************************************

FindLastPos

returns position of last card in column, or EMPTY if column is empty.

****************************************************************************/

UINT FindLastPos(UINT col)
{
    UINT pos = 0;

    if (col > 9)
        return EMPTY;

    while (card[col][pos] != EMPTY)
        pos++;
    pos--;

    return pos;
}



/******************************************************************************

UpdateLossCount

If game is lost, update statistics.

******************************************************************************/

VOID UpdateLossCount()
{
    int     cLifetimeLosses;        // includes .ini stats
    int     wStreak, wSType;        // streak length and type
    int     wLosses;                // record loss streak
    LONG    lRegResult;             // used to store return code from registry call

    // repeats and negative (unwinnable) games don't count

    if ((gamenumber > 0) && (gamenumber != oldgamenumber))
    {
        lRegResult = REGOPEN

        if (ERROR_SUCCESS == lRegResult)
        {
            cLifetimeLosses = GetInt(pszLost, 0);
            cLifetimeLosses++;
            cLosses++;
            cGames++;
            SetInt(pszLost, cLifetimeLosses);
            wSType = GetInt(pszSType, WON);
            if (wSType == WON)
            {
                SetInt(pszSType, LOST);
                wStreak = 1;
                SetInt(pszStreak, wStreak);
            }
            else
            {
                wStreak = GetInt(pszStreak, 0);
                wStreak++;
                SetInt(pszStreak, wStreak);
            }

            wLosses = GetInt(pszLosses, 0);
            if (wLosses < wStreak)  // if new record
            {
                wLosses = wStreak;
                SetInt(pszLosses, wLosses);
            }

            REGCLOSE
        }
    }
    oldgamenumber = gamenumber;
}


/******************************************************************************

KeyboardInput

Handles keyboard input from the main message loop.  Only digits are considered.
This function works by simulating mouse clicks for each digit pressed.

Note that when you have selected a card in a free cell, but you want to
select another card, you press '0' again.  This function sends (not posts,
sends so that bMessages can be turned off) a mouse click to deselect that
card, and then looks if there is another card in free cells to the right,
and if so, selects it.

******************************************************************************/

VOID KeyboardInput(HWND hWnd, UINT keycode)
{
    UINT    x, y;
    UINT    col = TOPROW;
    UINT    pos = 0;
    BOOL    bSave;              // save status of bMessages;
    CARD    c;

    if (!isdigit(keycode))
        return;

    switch (keycode) {

        case '0':                               // free cell
            if (wMouseMode == FROM)             // select a card to transfer
            {
                for (pos = 0; pos < 4; pos++)
                    if (card[TOPROW][pos] != EMPTY)
                        break;
                if (pos == 4)                   // no card to select
                    return;
            }
            else                                // transfer TO free cell
            {
                if (wFromCol == TOPROW)         // pick new free cell
                {
                    /* Turn off messages so deselection moves don't complain
                       if there is only one move left. */

                    bSave = bMessages;
                    bMessages = FALSE;

                    /* deselect current selection */

                    Card2Point(TOPROW, wFromPos, &x, &y);
                    SendMessage(hWnd, WM_LBUTTONDOWN, 0,
                                MAKELONG((WORD)x, (WORD)y));

                    /* find next non-empty free cell */

                    for (pos = wFromPos+1; pos < 4; pos++)
                    {
                        if (card[TOPROW][pos] != EMPTY)
                            break;
                    }

                    bMessages = bSave;
                    if (pos == 4)       // none found, so leave deselected
                        return;
                }
                else                    // transfer from a column, not TOPROW
                {
                    for (pos = 0; pos < 4; pos++)
                        if (card[TOPROW][pos] == EMPTY)
                            break;

                    if (pos == 4)       // no empty freecells
                        pos = 0;        // force an error message
                }
            }
            break;

        case '9':                           // home cell
            if (wMouseMode == FROM)         // can't move from home cell
                return;

            c = card[wFromCol][wFromPos];
            pos = homesuit[SUIT(c)];
            if (pos == EMPTY)               // no home suit so can't do anything
                pos = 4;                    // force error
            break;

        default:                            // columns 1 to 8
            col = keycode - '0';
            break;
    }

    if (col == wFromCol && wMouseMode == TO && col > 0 && col < 9 &&
        card[col][1] != EMPTY)
    {
        bFlipping = (BOOL) SetTimer(hWnd, FLIP_TIMER, FLIP_INTERVAL, NULL);
    }

    if (bFlipping)
    {
        hFlipCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);
        Flip(hWnd);         // do first card manually
    }
    else
    {
        Card2Point(col, pos, &x, &y);
        PostMessage(hWnd, WM_LBUTTONDOWN, 0,
                    MAKELONG((WORD)x, (WORD)y));
    }
}


/******************************************************************************

Flash

This function is called by the FLASH_TIMER to flash main window.

******************************************************************************/

VOID Flash(HWND hWnd)
{
    FlashWindow(hWnd, TRUE);
    cFlashes--;

    if (cFlashes <= 0)
    {
        FlashWindow(hWnd, FALSE);
        KillTimer(hWnd, FLASH_TIMER);
        idTimer = 0;
    }
}


/******************************************************************************

Flip

This function is called by the FLIP_TIMER to flip cards through in one
column.  It is used for keyboard players who want to reveal hidden cards.

******************************************************************************/

VOID Flip(HWND hWnd)
{
    HDC     hDC;
    UINT    x, y;
    static  UINT    pos = 0;

    hDC = GetDC(hWnd);
    DrawCard(hDC, wFromCol, pos, card[wFromCol][pos], FACEUP);
    pos++;
    if (card[wFromCol][pos] == EMPTY)
    {
        pos = 0;
        KillTimer(hWnd, FLIP_TIMER);
        bFlipping = FALSE;
        ShowCursor(FALSE);
        SetCursor(hFlipCursor);

        /* cancel move */

        Card2Point(wFromCol, pos, &x, &y);
        PostMessage(hWnd, WM_LBUTTONDOWN, 0,
                    MAKELONG((WORD)x, (WORD)y));
    }
    ReleaseDC(hWnd, hDC);
}


/******************************************************************************

Undo

Undo last move

******************************************************************************/

VOID Undo(HWND hWnd)
{
    int   i;

    if (cUndo == 0)
        return;

    SetCursor(LoadCursor(NULL, IDC_WAIT));  // set cursor to hourglass
    SetCapture(hWnd);
    ShowCursor(TRUE);

    for (i = cUndo-1; i >= 0; i--)
    {
        CARD c;
        int fcol, fpos, tcol, tpos;

        fcol = movelist[i].tcol;
        fpos = movelist[i].tpos;
        tcol = movelist[i].fcol;
        tpos = movelist[i].fpos;

        if (fcol != TOPROW && fcol == tcol)     // no move so exit
            break;

        if (fcol != TOPROW)
            fpos = FindLastPos(fcol);

        if (tcol != TOPROW)
            tpos = FindLastPos(tcol) + 1;

        Glide(hWnd, fcol, fpos, tcol, tpos);    // send the card on its way

        c = card[fcol][fpos];

        if (fcol == TOPROW && fpos > 3)         // if from home cell
        {
            wCardCount++;
            DisplayCardCount(hWnd);             // update display

            home[SUIT(c)]--;

            if (VALUE(c) == ACE)
            {
                card[fcol][fpos] = EMPTY;
                homesuit[SUIT(c)] = EMPTY;
            }
            else
            {
                card[fcol][fpos] -= 4;
            }
        }
        else
            card[fcol][fpos] = EMPTY;

        card[tcol][tpos] = c;
    }

    cUndo = 0;
    EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

    ShowCursor(FALSE);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    ReleaseCapture();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\display.c ===
/****************************************************************************

Display.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Contains routines dealing with pixels and card shuffling.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <stdlib.h>                     // rand() prototype
#include <time.h>

// This static data has to do with positions of the cards on the screen.
// See CalcOffsets() below for descriptions.  Note that wOffset[TOPROW]
// is the left edge of the leftmose home cell.

static UINT wOffset[MAXCOL];        // left edge of column n (n from 1 to 8)
static UINT wIconOffset;            // left edge of icon (btwn home & free)
static UINT wVSpace;                // vert space between home and columns
static UINT wUpdateCol, wUpdatePos; // card user chose to transfer FROM
static BOOL bCardRevealed;          // right mouse button show a card?

#define BGND    (255)               // used for cdtDrawExt
#define ICONY   ((dyCrd - ICONHEIGHT) / 3)


/****************************************************************************

CalcOffsets

This function determines the locations where cards are drawn.

****************************************************************************/

VOID CalcOffsets(HWND hWnd)
{
    RECT rect;
    UINT i;
    UINT leftedge;
    BOOL bEGAmode = FALSE;

    if (GetSystemMetrics(SM_CYSCREEN) <= 350)   // EGA
        bEGAmode = TRUE;

    GetClientRect(hWnd, &rect);

    wOffset[TOPROW] = rect.right - (4 * dxCrd);         // home cells

    leftedge = (rect.right - ((MAXCOL-1) * dxCrd)) / MAXCOL;
    for (i = 1; i < MAXCOL; i++)
        wOffset[i] = leftedge + (((i-1) * (rect.right-leftedge)) / (MAXCOL-1));

    /* place icon half way between free cells and home cells */

    wIconOffset = (rect.right-ICONWIDTH) / 2;

    if (bEGAmode)
        wVSpace = 4;
    else
        wVSpace = 10;

    /* dyTops is the vertical space between stacked cards.  To fit the
       theoretical maximum, the formula is dyTops = (dyCrd * 9) / 50.
       A compromise is used to make the cards easier to see.  It is possible,
       therefore, that some stacks could get long enough for the bottom
       cards no to be visible.  The situation for EGA is worse, as cards
       are both closer together, and more likely to fall off the bottom.
       An alternative is to squish the bitmaps dyCrd = (35 * dyCrd) / 48. */

    dyTops = (dyCrd * 9) / 46;      // space between tops of cards in columns

    if (bEGAmode)
        dyTops = (dyTops * 4) / 5;
}


/****************************************************************************

ShuffleDeck

If seed is non-zero, that number is used as rand() seed to shuffle
deck.  Otherwise, a seed is generated and presented to the user who
may change it in a dialog box.

****************************************************************************/

VOID ShuffleDeck(HWND hWnd, UINT_PTR seed)
{
    UINT i, j;                      // generic counters
    UINT col, pos;
    UINT wLeft = 52;                // cards left to be chosen in shuffle
    CARD deck[52];                  // deck of 52 unique cards

    if (seed == 0)                // if user must select seed
    {
        gamenumber = GenerateRandomGameNum();

         /* Keep calling GameNumDlg until valid number chosen. */

        while (!DialogBox(hInst, TEXT("GameNum"), hWnd, GameNumDlg))
        {
        }

        if (gamenumber == CANCELGAME)       // if user chose CANCEL button
            return;
    }
    else
    {
        gamenumber = (INT) seed;
    }

    LoadString(hInst, IDS_APPNAME2, bigbuf, BIG);
    wsprintf(smallbuf, bigbuf, gamenumber);
    SetWindowText(hWnd, smallbuf);

    for (col = 0; col < MAXCOL; col++)          // clear the deck
    {
        for (pos = 0; pos < MAXPOS; pos++)
        {
            card[col][pos] = EMPTY;
        }
    }

    /* shuffle cards */

    for (i = 0; i < 52; i++)            // put unique card in each deck loc.
    {
        deck[i] = i;
    }

    if (gamenumber == -1)               // special unwinnable shuffle
    {
        i = 0;

        for (pos = 0; pos < 7; pos++)
        {
            for (col = 1; col < 5; col++)
            {
                card[col][pos] = i++;
            }

            i+= 4;
        }

        for (pos = 0; pos < 6; pos++)
        {
            i -= 12;

            for (col = 5; col < 9; col++)
            {
                card[col][pos] = i++;
            }
        }
    }
    else if (gamenumber == -2)
    {
        i = 3;

        for (col = 1; col < 5; col++)
        {
            card[col][0] = i--;
        }

        i = 51;

        for (pos = 1; pos < 7; pos++)
        {
            for (col = 1; col < 5; col++)
            {
                card[col][pos] = i--;
            }
        }

        for (pos = 0; pos < 6; pos++)
        {
            for (col = 5; col < 9; col++)
            {
                card[col][pos] = i--;
            }
        }
    }
    else
    {

        //
        // Caution:
        //	This shuffle algorithm has been published to people all around. The intention
        //	was to let people track the games by game numbers. So far all the games between
        //	1 and 32767 except one have been proved to have a winning solution. Do not change
        //	the shuffling algorithm else you will incur the wrath of people who have invested
        //	a huge amount of time solving these games.
        //	

        //	The game number can now be upto a million as the srand takes an integer but the
        //	the random value generated by rand() is only from 0 to 32767.
        //

        srand(gamenumber);
        for (i = 0; i < 52; i++)
        {
            j = rand() % wLeft;
            wLeft --;
            card[(i%8)+1][i/8] = deck[j];
            deck[j] = deck[wLeft];
        }
    }
}


/****************************************************************************

PaintMainWindow

This function is called in response to WM_PAINT.

****************************************************************************/

VOID PaintMainWindow(HWND hWnd)
{
    PAINTSTRUCT ps;
    UINT    col, pos;
    UINT    y;              // y location of icon
    CARD    c;
    INT     mode;           // mode to draw card (FACEUP or HILITE)
    HCURSOR hCursor;        // original cursor
    HPEN    hOldPen;

    BeginPaint(hWnd, &ps);

    /* Draw icon with 3D box around it. */

    y = ICONY;

    hOldPen = SelectObject(ps.hdc, hBrightPen);
    MoveToEx(ps.hdc, wIconOffset-3, y + ICONHEIGHT + 1, NULL);
    LineTo(ps.hdc, wIconOffset-3, y-3);
    LineTo(ps.hdc, wIconOffset+ICONWIDTH + 2, y-3);

    SelectObject(ps.hdc, GetStockObject(BLACK_PEN));
    MoveToEx(ps.hdc, wIconOffset + ICONWIDTH + 2, y-2, NULL);
    LineTo(ps.hdc, wIconOffset + ICONWIDTH + 2, y + ICONHEIGHT + 2);
    LineTo(ps.hdc, wIconOffset - 3, y + ICONHEIGHT + 2);

    DrawKing(ps.hdc, SAME, TRUE);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    /* Top row first */

    for (pos = 0; pos < 8; pos++)
    {
        mode = FACEUP;
        if ((c = card[TOPROW][pos]) == EMPTY)
            c = IDGHOST;
        else if (wMouseMode == TO && pos == wFromPos && TOPROW == wFromCol)
            mode = HILITE;

        DrawCard(ps.hdc, TOPROW, pos, c, mode);
    }

    /* Then, the 8 columns */

    for (col = 1; col < MAXCOL; col++)
    {
        for (pos = 0; pos < MAXPOS; pos++)
        {
            if ((c = card[col][pos]) == EMPTY)
                break;

            if (wMouseMode == TO && pos == wFromPos && col == wFromCol)
                mode = HILITE;
            else
                mode = FACEUP;

            DrawCard(ps.hdc, col, pos, c, mode);
        }
    }

    if (bWonState)
        Payoff(ps.hdc);

    ShowCursor(FALSE);
    SetCursor(hCursor);
    SelectObject(ps.hdc, hOldPen);
    EndPaint(hWnd, &ps);
    DisplayCardCount(hWnd);
}


/****************************************************************************

DrawCard

This function takes a card value and position (in col and pos),
converts it to x and y, and displays it in the specified mode.

****************************************************************************/

VOID DrawCard(HDC hDC, UINT col, UINT pos, CARD card, INT mode)
{
    UINT    x, y;
    HDC     hMemDC;
    HBITMAP hOldBitmap;

    Card2Point(col, pos, &x, &y);
    if (card == IDGHOST && hBM_Ghost)
    {
        hMemDC = CreateCompatibleDC(hDC);
        if (hMemDC)
        {
            hOldBitmap = SelectObject(hMemDC, hBM_Ghost);
            BitBlt(hDC, x, y, dxCrd, dyCrd, hMemDC, 0, 0, SRCCOPY);
            SelectObject(hMemDC, hOldBitmap);
            DeleteDC(hMemDC);
        }
    }
    else
        cdtDrawExt(hDC, x, y, dxCrd, dyCrd, card, mode, BGND);
}

VOID DrawCardMem(HDC hMemDC, CARD card, INT mode)
{
    cdtDrawExt(hMemDC, 0, 0-dyTops, dxCrd, dyCrd, card, mode, BGND);
}


/****************************************************************************

RevealCard

When the user chooses a hidden card by clicking the right mouse button,
this function displays the entire card bitmap.

****************************************************************************/

VOID RevealCard(HWND hWnd, UINT x, UINT y)
{
    UINT col, pos;
    HDC  hDC;

    bCardRevealed = FALSE;              // no card revealed yet
    if (Point2Card(x, y, &col, &pos))
    {
        wUpdateCol = col;               // save for RestoreColumn()
        wUpdatePos = pos;
    }
    else
        return;                         // not a card

    if (col == 0 || pos == (MAXPOS-1))
        return;

    if (card[col][pos+1] == EMPTY)
        return;

    hDC = GetDC(hWnd);
    DrawCard(hDC, col, pos, card[col][pos], FACEUP);
    ReleaseDC(hWnd, hDC);
    bCardRevealed = TRUE;               // ok, card has been revealed
}


/****************************************************************************

RestoreColumn

After RevealCard has messed up a column by revealing a hidden card,
this routine patches it up again by redisplaying all the cards from
the revealed card down to the bottom of the column.  If the bottom card
is selected for a move, it is correctly shown hilighted.

****************************************************************************/

VOID RestoreColumn(HWND hWnd)
{
    HDC     hDC;
    UINT    pos;
    UINT    lastpos = EMPTY;    // last pos in column (for HILITE mode)
    INT     mode;               // HILITE or FACEUP

    if (!bCardRevealed)
        return;

    if (wMouseMode == TO)
        lastpos = FindLastPos(wUpdateCol);

    hDC = GetDC(hWnd);
    mode = FACEUP;
    for (pos = (wUpdatePos + 1); pos < MAXPOS; pos++)
    {
        if (card[wUpdateCol][pos] == EMPTY)
            break;

        if (wMouseMode == TO && pos == lastpos && wUpdateCol == wFromCol)
            mode = HILITE;

        DrawCard(hDC, wUpdateCol, pos, card[wUpdateCol][pos], mode);
    }
    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

Point2Card

Given an x,y location (typically a mouse click) this function returns
the column and position of that card through pointers.  The function
return value is TRUE if it found a card, and FALSE otherwise.

****************************************************************************/

BOOL Point2Card(UINT x, UINT y, UINT *col, UINT *pos)
{
    if (y < dyCrd)                          // TOPROW
    {
        if (x < (UINT) (4 * dxCrd))         // free cells
        {
            *col = TOPROW;
            *pos = x / dxCrd;
            return TRUE;
        }
        else if (x < wOffset[TOPROW])       // between free cells & home cells
            return FALSE;

        x -= wOffset[TOPROW];
        if (x < (UINT) (4 * dxCrd))         // home cells
        {
            *col = TOPROW;
            *pos = (x / dxCrd) + 4;
            return TRUE;
        }
        else                                // right of home cells
            return FALSE;
    }

    if (y < (dyCrd + wVSpace))              // above column cards
        return FALSE;

    if (x < wOffset[1])                     // left of column 1
        return FALSE;

    *col = (x - wOffset[1]) / (wOffset[2] - wOffset[1]);
    (*col)++;

    if (x > (wOffset[*col] + dxCrd))
        return FALSE;               // between columns

    y -= (dyCrd + wVSpace);

    *pos = min((y / dyTops), MAXPOS);

    if (card[*col][0] == EMPTY)
        return FALSE;               // empty column

    if (*pos < (MAXPOS-1))
    {
        if (card[*col][(*pos)+1] != EMPTY)  // if partially hidden card...
            return TRUE;                    // we're done
    }

    while (card[*col][*pos] == EMPTY)
        (*pos)--;

    if (y > ((*pos * dyTops) + dyCrd))
        return FALSE;                       // below last card in column
    else
        return TRUE;
}


/****************************************************************************

Card2Point

Given a column and position, this function returns the x and y pixel
location of the upper left hand corner of the card.

****************************************************************************/

VOID Card2Point(UINT col, UINT pos, UINT *x, UINT *y)
{
    assert(col <= MAXCOL);
    assert(pos <= MAXPOS);

    if (col == TOPROW)      // column 0 is really the top row of 8 slots
    {
        *y = 0;
        *x = pos * dxCrd;
        if (pos > 3)
            *x += wOffset[TOPROW] - (4 * dxCrd);
    }
    else
    {
        *x = wOffset[col];
        *y = dyCrd + wVSpace + (pos * dyTops);
    }
}


/****************************************************************************

DisplayCardCount

This function displays wCardCount (the number of cards not in home cells)
at the right edge of the menu bar.  If necessary, the old value is erased.

****************************************************************************/

VOID DisplayCardCount(HWND hWnd)
{
    RECT rect;                          // client rect
    HDC  hDC;
    TCHAR buffer[25];                   // current value in ASCII stored here
    TCHAR oldbuffer[25];                // previous value in ASCII
    UINT xLoc;                          // x pixel loction for count
    UINT wCount;                        // temp wCardCount holder
    static UINT yLoc = 0;               // y pixel location for count
    static UINT wOldCount = 0;          // previous count value
    HFONT hOldFont = NULL;
    SIZE  size;


    if (IsIconic(hWnd))                 // don't draw on icon!
        return;

    hDC = GetWindowDC(hWnd);                // get DC for entire window
    if (!hDC)
        return;

    SetBkColor(hDC, GetSysColor(COLOR_MENU));

     if (hMenuFont)
        hOldFont = SelectObject(hDC, hMenuFont);

    wCount = wCardCount;
    if (wCount == 0xFFFF)                   // decremented past 0?
        wCount = 0;

    LoadString(hInst, IDS_CARDSLEFT, smallbuf, SMALL);
    wsprintf(buffer, smallbuf, wCount);

    if (yLoc == 0)                          // needs to be set only once
    {
        TEXTMETRIC  tm;
        int         offset;

        GetTextMetrics(hDC, &tm);
        offset = (GetSystemMetrics(SM_CYMENU) - tm.tmHeight) / 2;

        yLoc = GetSystemMetrics(SM_CYFRAME)         // sizing frame
         + GetSystemMetrics(SM_CYCAPTION)           // height of caption
         + offset;
    }

    GetClientRect(hWnd, &rect);
    GetTextExtentPoint32(hDC, buffer, lstrlen(buffer), &size);
    xLoc = rect.right - size.cx;

    if (xLoc > xOldLoc)                     // need to erase old score?
    {
        SetTextColor(hDC, GetSysColor(COLOR_MENU));     // background colour
        wsprintf(oldbuffer, smallbuf, wOldCount);
        TextOut(hDC, xOldLoc, yLoc, oldbuffer, lstrlen(buffer));
    }
    SetTextColor(hDC, GetSysColor(COLOR_MENUTEXT));
    TextOut(hDC, xLoc, yLoc, buffer, lstrlen(buffer));

    xOldLoc = xLoc;
    wOldCount = wCount;

    if (hMenuFont)
        SelectObject(hDC, hOldFont);

    ReleaseDC(hWnd, hDC);
}


/****************************************************************************

Payoff

Draws the Big King when you win the game.

****************************************************************************/

VOID Payoff(HDC hDC)
{
    HDC     hMemDC;             // bitmap memory DC
    HBITMAP hBitmap;
    HBITMAP hOldBitmap;
    INT     xStretch = 320;     // stretched size of bitmap
    INT     yStretch = 320;

    if (GetSystemMetrics(SM_CYSCREEN) <= 350)   // EGA
    {
        xStretch = 32 * 8;
        yStretch = 32 * 6;
    }

    DrawKing(hDC, NONE, TRUE);

    hMemDC = CreateCompatibleDC(hDC);
    if (!hMemDC)
        return;

    hBitmap = LoadBitmap(hInst, TEXT("KingSmile"));

    if (hBitmap)
    {
        hOldBitmap = SelectObject(hMemDC, hBitmap);
        StretchBlt(hDC, 10, dyCrd + 10, xStretch, yStretch, hMemDC, 0, 0,
                   BMWIDTH, BMHEIGHT, SRCCOPY);
        SelectObject(hMemDC, hOldBitmap);
        DeleteObject(hBitmap);
    }
    DeleteDC(hMemDC);
}


/****************************************************************************

DrawKing

Draws the small king in the box between the free and home cells.
If state is SAME, the previous bitmap is displayed.  If bDraw is
FALSE, oldstate is updated, but the bitmap is not displayed.

****************************************************************************/

VOID DrawKing(HDC hDC, UINT state, BOOL bDraw)
{
    HDC     hMemDC;                     // bitmap memory DC
    HBITMAP hBitmap;
    HBITMAP hOldBitmap;
    static  UINT oldstate = RIGHT;      // previous state -- RIGHT is default
    HBRUSH  hOldBrush;

    if (state == oldstate)
        return;

    if (state == SAME)
        state = oldstate;

    if (!bDraw)
    {
        oldstate = state;
        return;
    }

    hMemDC = CreateCompatibleDC(hDC);
    if (!hMemDC)
        return;

    if (state == RIGHT)
        hBitmap = LoadBitmap(hInst, TEXT("KingBitmap"));
    else if (state == LEFT)
        hBitmap = LoadBitmap(hInst, TEXT("KingLeft"));
    else if (state == SMILE)
        hBitmap = LoadBitmap(hInst, TEXT("KingSmile"));
    else        // NONE
        hBitmap = CreateCompatibleBitmap(hDC, BMWIDTH, BMHEIGHT);

    if (hBitmap)
    {
        hOldBitmap = SelectObject(hMemDC, hBitmap);
        if (state == NONE)
        {
            hOldBrush = SelectObject(hMemDC, hBgndBrush);
            PatBlt(hMemDC, 0, 0, BMWIDTH, BMHEIGHT, PATCOPY);
            SelectObject(hMemDC, hOldBrush);
        }
        BitBlt(hDC,wIconOffset,ICONY,BMWIDTH,BMHEIGHT,hMemDC,0,0,SRCCOPY);
        SelectObject(hMemDC, hOldBitmap);
        DeleteObject(hBitmap);
    }
    DeleteDC(hMemDC);
    oldstate = state;
}


/****************************************************************************

GenerateRandomGameNum

returns a UINT from 1 to MAXGAMENUBMER

****************************************************************************/


UINT GenerateRandomGameNum()
{
    UINT wGameNum;

    srand((unsigned int)time(NULL));
    rand();
    rand();
    wGameNum = rand();
    while (wGameNum < 1 || wGameNum > MAXGAMENUMBER)
        wGameNum = rand();
    return wGameNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\freecell.h ===
/****************************************************************************

FREECELL.H

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Main header file for Windows Free Cell.  Constants are in freecons.h

****************************************************************************/

#include <windows.h>
#include <port1632.h>

#define     WINHEIGHT     480
#define     WINWIDTH      640

#define     FACEUP          0               // card mode
#define     FACEDOWN        1
#define     HILITE          2
#define     GHOST           3
#define     REMOVE          4
#define     INVISIBLEGHOST  5
#define     DECKX           6
#define     DECKO           7

#define     EMPTY  0xFFFFFFFF
#define     IDGHOST        52               // eg, empty free cell

#define     MAXPOS         21
#define     MAXCOL          9               // includes top row as column 0

#define     MAXMOVELIST   150               // size of movelist array

#define     TOPROW          0               // column 0 is really the top row

#define     BLACK           0               // COLOUR(card)
#define     RED             1

#define     ACE             0               // VALUE(card)
#define     DEUCE           1

#define     CLUB            0               // SUIT(card)
#define     DIAMOND         1
#define     HEART           2
#define     SPADE           3

#define     FROM            0               // wMouseMode
#define     TO              1

#define     ICONWIDTH      32               // in pixels
#define     ICONHEIGHT     32

#define     BIG           128               // str buf sizes
#define     SMALL          32

#define     MAXGAMENUMBER   1000000
#define     CANCELGAME      (MAXGAMENUMBER + 1)

#define     NONE            0               // king bitmap identifiers
#define     SAME            1
#define     RIGHT           2
#define     LEFT            3
#define     SMILE           4

#define     BMWIDTH        32               // bitmap width
#define     BMHEIGHT       32               // bitmap height

#define     LOST            0               // used for streaks
#define     WON             1

#define     FLASH_TIMER     2               // timer id for main window flash
#define     FLASH_INTERVAL  400             // flash timer interval
#define     FLIP_TIMER      3               // timer id for flipping column
#define     FLIP_INTERVAL   300

#define     CHEAT_LOSE      1               // used with bCheating
#define     CHEAT_WIN       2


/* Macros */

#define     SUIT(card)      ((card) % 4)
#define     VALUE(card)     ((card) / 4)
#define     COLOUR(card)    (SUIT(card) == 1 || SUIT(card) == 2)

#define     REGOPEN         RegCreateKey(HKEY_CURRENT_USER, pszRegPath, &hkey);
#define     REGCLOSE        RegCloseKey(hkey);
#define     DeleteValue(v)  RegDeleteValue(hkey, v)


/* Types */

typedef INT     CARD;

typedef struct {                // movelist made up of these
      UINT  fcol;
      UINT  fpos;
      UINT  tcol;
      UINT  tpos;
   } MOVE;


/* Callback function prototypes */

// INT  PASCAL MMain(HANDLE, HANDLE, LPSTR, INT);
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);

INT_PTR  APIENTRY About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY GameNumDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY MoveColDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY StatsDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY YouLoseDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY YouWinDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR  APIENTRY OptionsDlg(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);


/* Functions imported from cards.dll */

BOOL  APIENTRY cdtInit(UINT FAR *pdxCard, UINT FAR *pdyCard);
BOOL  APIENTRY cdtDraw(HDC hdc, INT x, INT y, INT cd, INT mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd,
                           INT mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtTerm(VOID);

/* Other function prototypes */

VOID CalcOffsets(HWND hWnd);
UINT CalcPercentage(UINT cWins, UINT cLosses);
VOID Card2Point(UINT col, UINT pos, UINT *x, UINT *y);
VOID Cleanup(VOID);
VOID CreateMenuFont(VOID);
VOID DisplayCardCount(HWND hWnd);
VOID DrawCard(HDC hDC, UINT col, UINT pos, CARD c, INT mode);
VOID DrawCardMem(HDC hMemDC, CARD c, INT mode);
VOID DrawKing(HDC hDC, UINT state, BOOL bDraw);
UINT FindLastPos(UINT col);
BOOL FitsUnder(CARD fcard, CARD tcard);
VOID Flash(HWND hWnd);
VOID Flip(HWND hWnd);
UINT GenerateRandomGameNum(VOID);
CHAR *GetHelpFileName(VOID);
INT  GetInt(CONST TCHAR *pszValue, INT nDefault);
VOID Glide(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID GlideStep(HDC hDC, UINT x1, UINT y1, UINT x2, UINT y2);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, INT nCmdShow);
VOID IsGameLost(HWND hWnd);
BOOL IsValidMove(HWND hWnd, UINT tcol, UINT tpos);
VOID KeyboardInput(HWND hWnd, UINT keycode);
UINT MaxTransfer(VOID);
UINT MaxTransfer2(UINT freecells, UINT freecols);
VOID MoveCards(HWND hWnd);
VOID MoveCol(UINT fcol, UINT tcol);
VOID MultiMove(UINT fcol, UINT tcol);
UINT NumberToTransfer(UINT fcol, UINT tcol);
VOID PaintMainWindow(HWND hWnd);
VOID Payoff(HDC hDC);
BOOL Point2Card(UINT x, UINT y, UINT *col, UINT *pos);
BOOL ProcessDoubleClick(HWND hWnd);
VOID ProcessMoveRequest(HWND hWnd, UINT x, UINT y);
VOID ProcessTimer(HWND hWnd);
VOID QueueTransfer(UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID ReadOptions(VOID);
VOID RestoreColumn(HWND hWnd);
VOID RevealCard(HWND hWnd, UINT x, UINT y);
VOID SetCursorShape(HWND hWnd, UINT x, UINT y);
VOID SetFromLoc(HWND hWnd, UINT x, UINT y);
LONG SetInt(CONST TCHAR *pszValue, INT n);
VOID ShuffleDeck(HWND hWnd, UINT_PTR seed);
VOID StartMoving(HWND hWnd);
VOID Transfer(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos);
VOID Undo(HWND hWnd);
VOID UpdateLossCount(VOID);
BOOL Useless(CARD c);
VOID WMCreate(HWND hWnd);
VOID WriteOptions(VOID);


/* Global variables */

TCHAR   bigbuf[BIG];            // general purpose LoadString() buffer
CHAR    bighelpbuf[BIG];        // general purpose char buffer.
BOOL    bCheating;              // hit magic key to win?
BOOL    bDblClick;              // honor double click?
BOOL    bFastMode;              // hidden option, don't do glides?
BOOL    bFlipping;              // currently flipping cards in a column?
BOOL    bGameInProgress;        // true if game is in progress
BOOL    bMessages;              // are "helpful" MessageBoxen shown?
BOOL    bMonochrome;            // 2 colour display?
BOOL    bMoveCol;               // did user request column move (or 1 card)?
BOOL    bSelecting;             // is user selecting game numbers?
BOOL    bWonState;              // TRUE if game won and new game not started
UINT    dxCrd, dyCrd;           // extents of card bitmaps in pixels
CARD    card[MAXCOL][MAXPOS];   // current layout of cards
INT     cFlashes;               // count of main window flashes remaining
UINT    cGames;                 // number of games played in current session
UINT    cLosses;                // number of losses in current session
UINT    cWins;                  // number of wins in current session
UINT    cMoves;                 // number of moves in this game
UINT    dyTops;                 // vert space between cards in columns
CARD    shadow[MAXCOL][MAXPOS]; // shadows card array for multi-moves & cleanup
INT     gamenumber;             // current game number (rand seed)
HBITMAP hBM_Ghost;              // bitmap for ghost (empty) free/home cells
HBITMAP hBM_Bgnd1;              // screen under source location
HBITMAP hBM_Bgnd2;              // screen under destination location
HBITMAP hBM_Fgnd;               // bitmap that moves across screen
HICON   hIconMain;              // the main freecell icon.
HKEY    hkey;                   // registry key
HPEN    hBrightPen;             // 3D highlight colour
HANDLE  hInst;                  // current instance
HWND    hMainWnd;               // hWnd for main window
HFONT   hMenuFont;              // for Cards Left display
CARD    home[4];                // card on top of home pile for this suit
CARD    homesuit[4];            // suit for each home pile
HBRUSH  hBgndBrush;             // green background brush
UINT_PTR idTimer;               // flash timer id
UINT    moveindex;              // index to end of movelist
MOVE    movelist[MAXMOVELIST];  // compacted list of pending moves for timer
INT     oldgamenumber;          // previous game (repeats don't count in score)
TCHAR   *pszIni;                // .ini filename
TCHAR   smallbuf[SMALL];        // generic small buffer for LoadString()
TCHAR   titlebuf[BIG];          // a buffer used to store the window title.
UINT    wCardCount;             // cards not yet in home cells (0 == win)
UINT    wFromCol;               // col user has selected to transfer from
UINT    wFromPos;               // pos "
UINT    wMouseMode;             // selecting place to transfer FROM or TO
UINT    xOldLoc;                // previous location of cards left text
INT     cUndo;                  // number of cards to undo

/* registry value names */

extern CONST TCHAR pszRegPath[];
extern CONST TCHAR pszWon[];
extern CONST TCHAR pszLost[];
extern CONST TCHAR pszWins[];
extern CONST TCHAR pszLosses[];
extern CONST TCHAR pszStreak[];
extern CONST TCHAR pszSType[];
extern CONST TCHAR pszMessages[];
extern CONST TCHAR pszQuick[];
extern CONST TCHAR pszDblClick[];
extern CONST TCHAR pszAlreadyPlayed[];


/* TRACE mechanism */

#if    0
TCHAR    szDebugBuffer[256];
#define DEBUGMSG(parm1,parm2)\
    { wsprintf(szDebugBuffer,parm1,parm2);\
     OutputDebugString(szDebugBuffer); }

#define  assert(p)   { if (!(p)) {wsprintf(szDebugBuffer, TEXT("assert: %s %d\r\n"),\
                      __FILE__, __LINE__); OutputDebugString(szDebugBuffer);}}

#else
#define DEBUGMSG(parm1,parm2)
#endif

#define SPY(parm1)              // not used in NT version
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\freecell.c ===
/****************************************************************************

Freecell.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32


Main source module for Windows Free Cell.
Contains WinMain, initialization routines, and MainWndProc.


Design notes:

Note that although this program uses some of the mapping macros,
this version of the code is 32 bit only!  See Wep2 sources for
16 bit sources.

The current layout of the cards is kept in the array card[MAXCOL][MAXPOS].
In this scheme, column 0 is actually the top row.  In this "column", pos
0 to 3 are the free cells, and 4 to 7 are the home cells.  The other
columns numbered 1 to 8 are the stacked card columns.

See PaintMainWindow() for some details on changing the display for EGA.

A previous version of Free Cell used a timer for multi-card moves.
WM_FAKETIMER messages are now sent manually to accomplish the same thing.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <shellapi.h>
#include <regstr.h>
#include <htmlhelp.h>   // for HtmlHelp()
#include <commctrl.h>   // for fusion classes.


/* Registry strings -- do not translate */

CONST TCHAR pszRegPath[]  = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\FreeCell");
CONST TCHAR pszWon[]      = TEXT("won");
CONST TCHAR pszLost[]     = TEXT("lost");
CONST TCHAR pszWins[]     = TEXT("wins");
CONST TCHAR pszLosses[]   = TEXT("losses");
CONST TCHAR pszStreak[]   = TEXT("streak");
CONST TCHAR pszSType[]    = TEXT("stype");
CONST TCHAR pszMessages[] = TEXT("messages");
CONST TCHAR pszQuick[]    = TEXT("quick");
CONST TCHAR pszDblClick[] = TEXT("dblclick");
CONST TCHAR pszAlreadyPlayed[] = TEXT("AlreadyPlayed");


#define  WTSIZE     50              // window text size in characters

void _setargv() { }     // reduces size of C runtimes
void _setenvp() { }

/****************************************************************************

WinMain(HANDLE, HANDLE, LPSTR, int)

****************************************************************************/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow) /* { */
    MSG msg;                            // message
    HANDLE  hAccel;                     // LifeMenu accelerators

    if (!hPrevInstance)                 // Other instances of app running?
        if (!InitApplication(hInstance))    // Initialize shared things
            return FALSE;                   // Exits if unable to initialize

    if (!InitInstance(hInstance, nCmdShow))
        return FALSE;

    hAccel = LoadAccelerators(hInstance, TEXT("FreeMenu"));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(hMainWnd, hAccel, &msg))
        {
            TranslateMessage(&msg);    // Translates virtual key codes
            DispatchMessage(&msg);     // Dispatches message to window
        }
    }
    DEBUGMSG(TEXT("----  Free Cell Terminated ----\n\r"),0);
    return (INT) msg.wParam;             /* Returns the value from PostQuitMessage */
}


/****************************************************************************

InitApplication(HANDLE hInstance)

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS    wc;
    HDC         hIC;            // information context
    INITCOMMONCONTROLSEX icc;   // common control registration.


    DEBUGMSG(TEXT("----  Free Cell Initiated  ----\n\r"),0);

    /* Check if monochrome */

    hIC = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);
    if (GetDeviceCaps(hIC, NUMCOLORS) == 2)
    {
        bMonochrome = TRUE;
        /* BrightPen is not so bright in mono. */
        hBrightPen = CreatePen(PS_SOLID, 1, RGB(  0,   0,   0));
        hBgndBrush = CreateSolidBrush(RGB(255, 255, 255));
    }
    else
    {
        bMonochrome = FALSE;
        hBrightPen = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
        hBgndBrush = CreateSolidBrush(RGB(0, 127, 0));      // green background
    }
    DeleteDC(hIC);

    // Create the freecell icon
    hIconMain = LoadIcon(hInstance, MAKEINTRESOURCE(ID_ICON_MAIN));

    // Register the common controls.
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC  = ICC_ANIMATE_CLASS | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_HOTKEY_CLASS | ICC_LISTVIEW_CLASSES | 
                 ICC_PAGESCROLLER_CLASS | ICC_PROGRESS_CLASS | ICC_TAB_CLASSES | ICC_UPDOWN_CLASS | ICC_USEREX_CLASSES;
    InitCommonControlsEx(&icc);

    wc.style = CS_DBLCLKS;              // allow double clicks
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = hIconMain;
    wc.hCursor = NULL;
    wc.hbrBackground = hBgndBrush;
    wc.lpszMenuName =  TEXT("FreeMenu");
    wc.lpszClassName = TEXT("FreeWClass");

    return RegisterClass(&wc);
}


/****************************************************************************

InitInstance(HANDLE hInstance, int nCmdShow)

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    HWND        hWnd;               // Main window handle.
    UINT        col, pos;
    INT         nWindowHeight;
    UINT        wAlreadyPlayed;     // have we already updated the registry ?
    UINT        cTLost, cTWon;      // total losses and wins
    UINT        cTLosses, cTWins;   // streaks
    UINT        wStreak;            // current streak amount
    UINT        wSType;             // current streak type
    LONG        lRegResult;                 // used to store return code from registry call


    if (!hBrightPen || !hBgndBrush)
        return FALSE;

    /* Initialize some global variables */

    for (col = 0; col < MAXCOL; col++)          // clear the deck
        for (pos = 0; pos < MAXPOS; pos++)
            card[col][pos] = EMPTY;

    hInst = hInstance;
    cWins = 0;
    cLosses = 0;
    cGames = 0;
    cUndo = 0;
    gamenumber = 0;             // so no cards are drawn in main wnd
    oldgamenumber = 0;          // this is first game and will count
    hMenuFont = 0;

    bWonState = FALSE;
    bGameInProgress = FALSE;
    bCheating = FALSE;
    bFastMode = FALSE;
    bFlipping = FALSE;
    pszIni = TEXT("entpack.ini");
    bDblClick = TRUE;
    bMessages = FALSE;

    /* for VGA or smaller, window will just fit inside screen */

    nWindowHeight = min(WINHEIGHT, GetSystemMetrics(SM_CYSCREEN));

    /* Create a main window for this application instance.  */

    LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
    hWnd = CreateWindow(
        TEXT("FreeWClass"),             // See RegisterClass() call.
        smallbuf,                       // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // Window style.
        CW_USEDEFAULT,                  // Default horizontal position.
        CW_USEDEFAULT,                  // Default vertical position.
        WINWIDTH,                       //         width.
        nWindowHeight,                  //         height.
        NULL,                           // Overlapped windows have no parent.
        NULL,                           // Use the window class menu.
        hInstance,                      // This instance owns this window.
        NULL                            // Pointer not needed.
    );

    /* If window could not be created, return "failure" */

    if (!hWnd)
        return FALSE;
    hMainWnd = hWnd;

    /* Make the window visible; update its client area; and return "success" */

    ShowWindow(hWnd, nCmdShow);     // Show the window
    UpdateWindow(hWnd);             // Sends WM_PAINT message


    // Do the transfer of stats from the .ini file to the
    // registry (for people migrating from NT 4.0 freecell to NT 5.0)

    lRegResult = REGOPEN

    if (ERROR_SUCCESS == lRegResult)
    {
        wAlreadyPlayed = GetInt(pszAlreadyPlayed, 0);

        // If this is the first time we are playing 
        // update the registry with the stats from the .ini file.
        if (!wAlreadyPlayed)
        {
            LoadString(hInst, IDS_APPNAME, bigbuf, BIG);

            // Read the stats from the .ini file. (if present)
            // If we can't read the stats, default value is zero.
            cTLost = GetPrivateProfileInt(bigbuf, TEXT("lost"), 0, pszIni);
            cTWon  = GetPrivateProfileInt(bigbuf, TEXT("won"), 0, pszIni);

            cTLosses = GetPrivateProfileInt(bigbuf, TEXT("losses"), 0, pszIni);
            cTWins   = GetPrivateProfileInt(bigbuf, TEXT("wins"), 0, pszIni);

            wStreak = GetPrivateProfileInt(bigbuf, TEXT("streak"), 0, pszIni);
            wSType = GetPrivateProfileInt(bigbuf, TEXT("stype"), 0, pszIni);

            // Copy the stats from the .ini file to the registry.
            SetInt(pszLost, cTLost);
            SetInt(pszWon, cTWon);
            SetInt(pszLosses, cTLosses);
            SetInt(pszWins, cTWins);
            SetInt(pszStreak, wStreak);
            SetInt(pszSType, wSType);

            // Set the already-played flag to 1.
            SetInt(pszAlreadyPlayed, 1);
        }

        REGCLOSE;
    }

    return TRUE;                    // Returns the value from PostQuitMessage
}


/****************************************************************************

MainWndProc(HWND, unsigned, UINT, LONG)

****************************************************************************/

LRESULT APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT     i;                      // generic counter
    int     nResp;                  // messagebox response
    UINT    col, pos;
    UINT    wCheck;                 // for checking IDM_MESSAGES menu item
    HDC     hDC;
    POINT   FAR *MMInfo;            // for GetMinMaxInfo
    HBRUSH  hOldBrush;
    RECT    rect;
    HMENU   hMenu;
    static  BOOL bEatNextMouseHit = FALSE;  // is next hit only for activation?

    switch (message) {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_ABOUT:
                    LoadString(hInst, IDS_FULLNAME, bigbuf, BIG);
                    LoadString(hInst, IDS_CREDITS, smallbuf, SMALL);
                    ShellAbout(hWnd, (LPCTSTR)bigbuf, (LPCTSTR)smallbuf, hIconMain);
                               
                    break;


                case IDM_EXIT:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    break;

                case IDM_NEWGAME:
                    lParam = GenerateRandomGameNum();
                case IDM_SELECT:
                case IDM_RESTART:
                    if (bGameInProgress)
                    {
                        LoadString(hInst, IDS_RESIGN, bigbuf, BIG);
                        LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                        MessageBeep(MB_ICONQUESTION);
                        if (IDNO == MessageBox(hWnd, bigbuf, smallbuf,
                                                 MB_YESNO | MB_ICONQUESTION))
                        {
                            break;
                        }
                        UpdateLossCount();
                    }

                    if (wParam == IDM_RESTART)
                    {
                        if (bGameInProgress)
                            lParam = gamenumber;
                        else
                            lParam = oldgamenumber;
                    }
                    else if (wParam == IDM_SELECT)
                        lParam = 0L;

                    if (wParam == IDM_NEWGAME)
                        bSelecting = FALSE;
                    else if (wParam == IDM_SELECT)
                        bSelecting = TRUE;

                    bGameInProgress = FALSE;
                    wFromCol = EMPTY;               // no FROM selected
                    wMouseMode = FROM;              // FROM selected next
                    moveindex = 0;                  // no queued moves
                    for (i = 0; i < 4; i++)         // nothing in home cells
                    {
                        homesuit[i] = EMPTY;
                        home[i] = EMPTY;
                    }
                    ShuffleDeck(hWnd, lParam);
                    if (gamenumber == CANCELGAME)
                        break;

                    InvalidateRect(hWnd, NULL, TRUE);
                    wCardCount = 52;
                    bGameInProgress = TRUE;
                    hMenu = GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_RESTART, MF_ENABLED);
                    DisplayCardCount(hWnd);
                    hDC = GetDC(hWnd);
                    DrawKing(hDC, RIGHT, FALSE);
                    bWonState = FALSE;
                    ReleaseDC(hWnd, hDC);
                    break;

                case IDM_STATS:
                    DialogBox(hInst, TEXT("Stats"), hWnd, StatsDlg);
                    break;

                case IDM_OPTIONS:
                    DialogBox(hInst, MAKEINTRESOURCE(DLG_OPTIONS), hWnd, OptionsDlg);
                    break;

                case IDM_HELP:
                    HtmlHelpA(GetDesktopWindow(), GetHelpFileName(), HH_DISPLAY_TOPIC, 0);
                    break;

                case IDM_HOWTOPLAY:
                    HtmlHelpA(GetDesktopWindow(), GetHelpFileName(), HH_DISPLAY_INDEX, 0);                    
                    break;

                case IDM_HELPONHELP:
                    HtmlHelpA(GetDesktopWindow(), "NTHelp.chm", HH_DISPLAY_TOPIC, 0);
                    break;

                case IDM_UNDO:
                    Undo(hWnd);
                    break;

                 /* Hidden options -- these strings need not be translated */

                case IDM_CHEAT:
                    i = MessageBox(hWnd, TEXT("Choose Abort to Win,\n")
                                   TEXT("Retry to Lose,\nor Ignore to Cancel."),
                                   TEXT("User-Friendly User Interface"),
                                   MB_ABORTRETRYIGNORE | MB_ICONQUESTION);
                    if (i == IDABORT)
                        bCheating = CHEAT_WIN;
                    else if (i == IDRETRY)
                        bCheating = CHEAT_LOSE;
                    else
                        bCheating = FALSE;
                    break;

                default:
                    return DefWindowProc(hWnd, message, wParam, lParam);
            }
            break;

        case WM_CLOSE:
            if (bGameInProgress)        // did user quit mid-game?
            {
                LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
                LoadString(hInst, IDS_RESIGN, bigbuf, BIG);
                MessageBeep(MB_ICONQUESTION);
                nResp = MessageBox(hWnd, bigbuf, smallbuf,
                                   MB_YESNO | MB_ICONQUESTION);
                if (nResp == IDNO)
                    break;

                UpdateLossCount();
            }

            WriteOptions();
            return DefWindowProc(hWnd, message, wParam, lParam);

        case WM_CREATE:
            WMCreate(hWnd);
            break;

        case WM_DESTROY:
            if (hBgndBrush)
                DeleteObject(hBgndBrush);
            if (hBrightPen)
                DeleteObject(hBrightPen);
            if (hBM_Fgnd)
                DeleteObject(hBM_Fgnd);
            if (hBM_Bgnd1)
                DeleteObject(hBM_Bgnd1);
            if (hBM_Bgnd2)
                DeleteObject(hBM_Bgnd2);
            if (hBM_Ghost)
                DeleteObject(hBM_Ghost);
            if (hMenuFont)
                DeleteObject(hMenuFont);

            cdtTerm();
            PostQuitMessage(0);
            break;

        case WM_PAINT:
            PaintMainWindow(hWnd);
            break;

        case WM_SIZE:
            DrawMenuBar(hWnd);              // fixes overlapping score on menu
            xOldLoc = 30000;                // force cards left to redraw
            DisplayCardCount(hWnd);         // must update if size changes
            break;

        /***** NOTE: WM_LBUTTONDBLCLK falls through to WM_LBUTTONDOWN ****/

        /* Double clicking works by simulating a move to a free cell.  On
           the off cycle (that is, when wMouseMode == FROM) the double
           click is processed as a single click to cancel the move, and a
           second double click message is posted. */

        case WM_LBUTTONDBLCLK:
            if (moveindex != 0)     // no mouse hit while cards moving
                break;

            if (gamenumber == 0)
                break;

            if (bFlipping)
                break;

             if (bDblClick && wFromCol > TOPROW && wFromCol < MAXCOL)
            {
                if (wMouseMode == TO)
                {
                    Point2Card(LOWORD(lParam), HIWORD(lParam), &col, &pos);
                    if (col == wFromCol)
                        if (ProcessDoubleClick(hWnd))   // if card moved ok
                            break;
                }
                else
                    PostMessage(hWnd, message, wParam, lParam);
            }

        case WM_LBUTTONDOWN:
            if (bEatNextMouseHit)       // is this only window activation?
            {
                bEatNextMouseHit = FALSE;
                break;
            }
            bEatNextMouseHit = FALSE;

            if (bFlipping)          // cards flipping for keyboard players
                break;

            if (moveindex != 0)     // no mouse hit while cards moving
                break;

            if (gamenumber == 0)
                break;

            if (wMouseMode == FROM)
                SetFromLoc(hWnd, LOWORD(lParam), HIWORD(lParam));
            else
                ProcessMoveRequest(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;


        case WM_RBUTTONDOWN:
            SetCapture(hWnd);
            if (bFlipping)
                break;

            if (gamenumber != 0)
                RevealCard(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_RBUTTONUP:
            ReleaseCapture();
            RestoreColumn(hWnd);
            break;

        case WM_MOUSEACTIVATE:                  // app is being activated,
            if (LOWORD(lParam) == HTCLIENT)     // so don't try new cell on
                bEatNextMouseHit = TRUE;        // clicked location
            break;

        case WM_MOUSEMOVE:
            SetCursorShape(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOVE:                           // card count erases when moved
            DisplayCardCount(hWnd);
            return (DefWindowProc(hWnd, message, wParam, lParam));

        case WM_GETMINMAXINFO:
            if (GetSystemMetrics(SM_CXSCREEN) > 640)    // skip if VGA
            {
                MMInfo = (POINT FAR *) lParam;  // see SDK ref
                if (MMInfo[4].x > WINWIDTH)
                    MMInfo[4].x = WINWIDTH;     // set max window width to 640
            }
            else
                return DefWindowProc(hWnd, message, wParam, lParam);

            break;

        case WM_CHAR:
            if (!bFlipping)
                KeyboardInput(hWnd, (UINT) wParam);
            break;

        case WM_TIMER:                          // flash main window
            if (wParam == FLASH_TIMER)
                Flash(hWnd);
            else
                Flip(hWnd);
            break;       

        default:                                // Passes it on if unproccessed
            return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


/****************************************************************************

WMCreate

Handles WM_CREATE message in main window.

****************************************************************************/

VOID WMCreate(HWND hWnd)
{
    BOOL    bResult;                // result of cards.dll initialization
    HDC     hDC;
    HDC     hMemDC;
    HBITMAP hOldBitmap;
    HBRUSH  hOldBrush;
    HPEN    hOldPen;

    /* initialize cards.dll */


	bResult = cdtInit(&dxCrd, &dyCrd);

    CalcOffsets(hWnd);

    hDC = GetDC(hWnd);
    hMemDC = CreateCompatibleDC(hDC);
    hBM_Fgnd  = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Bgnd1 = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Bgnd2 = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    hBM_Ghost = CreateCompatibleBitmap(hDC, dxCrd, dyCrd);
    if (hBM_Ghost)          // if memory allocation succeeded
    {
        hOldBitmap = SelectObject(hMemDC, hBM_Ghost);
        hOldBrush  = SelectObject(hMemDC, hBgndBrush);
        PatBlt(hMemDC, 0, 0, dxCrd, dyCrd, PATCOPY);

        hOldPen = SelectObject(hMemDC, GetStockObject(BLACK_PEN));
        MoveToEx(hMemDC, 0, dyCrd-2, NULL);
        LineTo(hMemDC, 0, 0);
        LineTo(hMemDC, dxCrd-1, 0);

        SelectObject(hMemDC, hBrightPen);
        MoveToEx(hMemDC, dxCrd-1, 1, NULL);
        LineTo(hMemDC, dxCrd-1, dyCrd-1);
        LineTo(hMemDC, 0, dyCrd-1);

        SelectObject(hMemDC, hOldPen);
        SelectObject(hMemDC, hOldBitmap);
        SelectObject(hMemDC, hOldBrush);
    }
    DeleteDC(hMemDC);
    ReleaseDC(hWnd, hDC);

    if (!bResult || !hBM_Fgnd || !hBM_Bgnd1 || !hBM_Bgnd2)
    {
        LoadString(hInst, IDS_MEMORY, bigbuf, BIG);
        LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
        MessageBeep(MB_ICONHAND);
        MessageBox(hWnd, bigbuf, smallbuf, MB_OK | MB_ICONHAND);
        PostQuitMessage(0);
        return;
    }

    ReadOptions();

    CreateMenuFont();
}


/****************************************************************************

CreateMenuFont

Makes a copy of the menu font and puts the handle in hMenuFont

****************************************************************************/

VOID CreateMenuFont()
{
    LOGFONT lf;                         // description of menu font
    NONCLIENTMETRICS ncm;

    hMenuFont = 0;
    ncm.cbSize = sizeof(ncm);

    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
        return;

    lf.lfHeight         = (int)ncm.lfMenuFont.lfHeight;
    lf.lfWidth          = (int)ncm.lfMenuFont.lfWidth;
    lf.lfEscapement     = (int)ncm.lfMenuFont.lfEscapement;
    lf.lfOrientation    = (int)ncm.lfMenuFont.lfOrientation;
    lf.lfWeight         = (int)ncm.lfMenuFont.lfWeight;
    lf.lfItalic         = ncm.lfMenuFont.lfItalic;
    lf.lfUnderline      = ncm.lfMenuFont.lfUnderline;
    lf.lfStrikeOut      = ncm.lfMenuFont.lfStrikeOut;
    lf.lfCharSet        = ncm.lfMenuFont.lfCharSet;
    lf.lfOutPrecision   = ncm.lfMenuFont.lfOutPrecision;
    lf.lfClipPrecision  = ncm.lfMenuFont.lfClipPrecision;
    lf.lfQuality        = ncm.lfMenuFont.lfQuality;
    lf.lfPitchAndFamily = ncm.lfMenuFont.lfPitchAndFamily;
    lstrcpyn(lf.lfFaceName, ncm.lfMenuFont.lfFaceName, LF_FACESIZE);

    hMenuFont = CreateFontIndirect(&lf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\golf\golf.h ===
#define  IDM_NEWGAME       1
#define  IDM_EXIT          2
#define  IDM_ABOUT         3
#define  IDM_OPTIONSUNDO   4
#define  IDM_OPTIONSERROR  5
#define  IDM_HELP          6
#define  IDM_GAMERECORD    8
#define  IDM_OPTIONSDECK   9

#define  IDD_OK     1
#define  IDD_CANCEL 0
#define  IDD_EDITWINDOW 100
#define  IDD_RECORD 101
#define  IDD_CLEARSCORES 102

/* help menu item*/
#define MENU_HOWTOPLAY	1000
#define MENU_INDEX      1001
#define MENU_USINGHELP  1003
#define MENU_COMMANDS   1004

/* String IDs */
#define IDSOOM          1000
#define IDSAppName      1001
#define IDSNoCardOnKing 1002
#define IDSNotAdjacent  1003
#define IDSWinner       1004
#define IDSGameOver     1005
#define IDSGameOverS    1006
#define IDSRecordTitle  1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\glide.c ===
/****************************************************************************

Glide.c

June 91, JimH     initial code
Oct 91,  JimH     port to Win32


Routines for gliding cards are here.  There is only one public entry point
to these routines, the function Glide().

The glide speed can be altered by changing STEPSIZE.  A large number (like
37) makes for fast glides.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <math.h>               // for labs()


#define STEPSIZE    37          // size of glide steps in pixels
#define BGND        255         // used for cdtDrawExt

static  HDC     hMemB1, hMemB2, hMemF;  // mem DC associated with above bitmaps
static  HBITMAP hOB1, hOB2, hOF;        // old bitmaps in above mem DCs
static  UINT    dwPixel[12];            // corner pixels that are saved/restored
static  HRGN    hRgn, hRgn1, hRgn2;     // hRgn1 is source, hRgn2 is destination


static  VOID GlideInit(HWND hWnd, UINT fcol, UINT tcol);
static  INT  IntSqrt(INT square);
static  VOID SaveCorners(HDC hDC, UINT x, UINT y);
static  VOID RestoreCorners(HDC hDC, UINT x, UINT y);


/******************************************************************************

Glide

Given a from and to location, this function animates the movement of
the card.

******************************************************************************/

VOID Glide(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    HDC     hDC;
    INT     dx, dy;             // total distance card travels
    UINT    x1, y1, x2, y2;     // start and end locations for each step
    UINT    xStart, yStart;     // beginning position
    UINT    xEnd =0, yEnd = 0;  // destination position
    INT     i;
    INT     distance;           // distance card travles +/- 3 pixels
    INT     steps;              // number of steps card takes in glide total
    BOOL    bSaved = FALSE;     // corner pixels saved?

    if (fcol != tcol || fpos != tpos)               // if card moves
    {
        hDC = GetDC(hWnd);
        hMemB1 = CreateCompatibleDC(hDC);           // memory DCs for bitmaps
        hMemB2 = CreateCompatibleDC(hDC);
        hMemF  = CreateCompatibleDC(hDC);

        hRgn1 = CreateRectRgn(1, 1, 2, 2);
        hRgn2 = CreateRectRgn(1, 1, 2, 2);
        hRgn  = CreateRectRgn(1, 1, 2, 2);

        if (hMemB1 && hMemB2 && hMemF && hRgn1 && hRgn2 && hRgn)
        {
            hOB1 =   SelectObject(hMemB1, hBM_Bgnd1);
            hOB2 =   SelectObject(hMemB2, hBM_Bgnd2);
            hOF  =   SelectObject(hMemF,  hBM_Fgnd);

            GlideInit(hWnd, fcol, fpos);      // set up hBM_Bgnd1 and hBM_Fgnd

            Card2Point(fcol, fpos, &xStart, &yStart);
            Card2Point(tcol, tpos, &xEnd, &yEnd);
            SaveCorners(hDC, xEnd, yEnd);
            bSaved = TRUE;

            /* Determine how far to travel and how many steps to take. */

            x1 = xStart;
            y1 = yStart;
            dx = xEnd - xStart;
            dy = yEnd - yStart;
            distance = IntSqrt(dx*dx + dy*dy);

            if (bFastMode)
                steps = 1;
            else
                steps = distance / STEPSIZE;

            /* Determine intermediate glide locations.  Long arithmetic is
               needed to prevent overflows. */ 

            for (i = 1; i < steps; i++)
            {
                x2 = xStart + ((i * dx) / steps);
                y2 = yStart + ((i * dy) / steps);
                GlideStep(hDC, x1, y1, x2, y2);
                x1 = x2;
                y1 = y2;
            }

            /* Erase last background manually -- DrawCard will do last card. */

            BitBlt(hMemB1, xEnd-x1, yEnd-y1, dxCrd, dyCrd, hMemF,0,0,SRCCOPY);
            BitBlt(hDC, x1, y1, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);

            /* Select original bitmaps so mem DCs can be destroyed. */

            SelectObject(hMemB1, hOB1);
            SelectObject(hMemB2, hOB2);
            SelectObject(hMemF, hOF);
        }
        else
        {
            LoadString(hInst, IDS_MEMORY, bigbuf, BIG);
            LoadString(hInst, IDS_APPNAME, smallbuf, SMALL);
            MessageBeep(MB_ICONHAND);
            MessageBox(hWnd, bigbuf, smallbuf, MB_OK | MB_ICONHAND);
            moveindex = 0;      // don't try moving more cards
            PostQuitMessage(0);
        }

        DeleteDC(hMemB1);
        DeleteDC(hMemB2);
        DeleteDC(hMemF);
        ReleaseDC(hWnd, hDC);

        DeleteObject(hRgn);
        DeleteObject(hRgn1);
        DeleteObject(hRgn2);
    }

    /* Draw last card with DrawCard so end result guaranteed correct. */

    hDC = GetDC(hWnd);
    DrawCard(hDC, tcol, tpos, card[fcol][fpos], FACEUP);
    if (bSaved)
        RestoreCorners(hDC, xEnd, yEnd);
    ReleaseDC(hWnd, hDC);
}


/******************************************************************************

GlideInit

Blt what is under the card source location into hMemB1, and the
card to be moved into hMemF.

******************************************************************************/

VOID GlideInit(HWND hWnd, UINT fcol, UINT fpos)
{
    if (fcol == TOPROW)     // if it's top row, background is ghost bitmap.
    {
        if (fpos > 3 && VALUE(card[fcol][fpos]) != ACE)
        {
            HDC     hDC;
            UINT    x, y;

            hDC = GetDC(hWnd);
            Card2Point(fcol, fpos, &x, &y);
            SaveCorners(hDC, x, y);
            cdtDrawExt(hMemB1,0,0,dxCrd,dyCrd,card[fcol][fpos]-4,FACEUP,BGND);
            RestoreCorners(hMemB1, 0, 0);
            ReleaseDC(hWnd, hDC);
        }
        else
        {
            SelectObject(hMemB2, hBM_Ghost);
            BitBlt(hMemB1, 0, 0, dxCrd, dyCrd, hMemB2, 0, 0, SRCCOPY);
            SelectObject(hMemB2, hBM_Bgnd2);
        }
    }
    else    // else background contains bottom part of card above.
    {
        SelectObject(hMemB1, hBgndBrush);
        PatBlt(hMemB1, 0, 0, dxCrd, dyCrd, PATCOPY);

        if (fpos != 0)
        {
            cdtDrawExt(hMemB1, 0, 0-dyTops, dxCrd, dyCrd, card[fcol][fpos-1],
                        FACEUP, BGND);
        }
    }

    /* Foreground bitmap is just the card to be moved. */

    cdtDrawExt(hMemF, 0, 0, dxCrd, dyCrd, card[fcol][fpos], FACEUP, 0);
}



/******************************************************************************

GlideStep

This routine gets called once for each step in the glide animation.  On
input, it needs the screen under the source in hMemB1, and the card to be
moved in hMemF.  It calculates the screen under the destination itself and
blts it into hMemB2.  At the end of the animation, it moves hMemB2 into
hMemB1 so it can be call again immediately with new coordinates.

******************************************************************************/

VOID GlideStep(HDC hDC, UINT x1, UINT y1, UINT x2, UINT y2)
{
    HDC     hMemTemp;               // used to swap mem DCs.

    SetRectRgn(hRgn1, x1, y1, x1+dxCrd, y1+dyCrd);
    SetRectRgn(hRgn2, x2, y2, x2+dxCrd, y2+dyCrd);

    /* create background of new location by combing screen background
       plus overlap from old background */

    BitBlt(hMemB2, 0, 0, dxCrd, dyCrd, hDC, x2, y2, SRCCOPY);
    BitBlt(hMemB2, x1-x2, y1-y2, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);

    /* Draw old background and then draw card  */

    CombineRgn(hRgn, hRgn1, hRgn2, RGN_DIFF);  // part of hRgn1 not in hRgn2
    SelectObject(hDC, hRgn);
    BitBlt(hDC, x1, y1, dxCrd, dyCrd, hMemB1, 0, 0, SRCCOPY);
    SelectObject(hDC, hRgn2);
    BitBlt(hDC, x2, y2, dxCrd, dyCrd, hMemF, 0, 0, SRCCOPY);

    /* copy new background to old background, or rather, accomplish the
       same effect by swapping the associated memory device contexts. */

    hMemTemp = hMemB1;
    hMemB1 = hMemB2;
    hMemB2 = hMemTemp;
}


/******************************************************************************

IntSqrt

Newton's method to find a quick close-enough square root without pulling
in the floating point libraries.

f(x)  == x*x - square == 0
f'(x) == 2x

******************************************************************************/

INT IntSqrt(INT square)
{
    INT guess, lastguess;

    lastguess = square;
    guess = min(square / 2, 1024);

    while (abs(guess-lastguess) > 3)         // 3 is close enough
    {
        lastguess = guess;
        guess -= ((guess * guess) - square) / (2 * guess);
    }

    return guess;
}



/******************************************************************************

SaveCorners
RestoreCorners

based on similar routines in cards.dll

******************************************************************************/

VOID SaveCorners(HDC hDC, UINT x, UINT y)
{
    // Upper Left
    dwPixel[0] = GetPixel(hDC, x, y);
    dwPixel[1] = GetPixel(hDC, x+1, y);
    dwPixel[2] = GetPixel(hDC, x, y+1);

    // Upper Right
    x += dxCrd -1;
    dwPixel[3] = GetPixel(hDC, x, y);
    dwPixel[4] = GetPixel(hDC, x-1, y);
    dwPixel[5] = GetPixel(hDC, x, y+1);

    // Lower Right
    y += dyCrd-1;
    dwPixel[6] = GetPixel(hDC, x, y);
    dwPixel[7] = GetPixel(hDC, x, y-1);
    dwPixel[8] = GetPixel(hDC, x-1, y);

    // Lower Left
    x -= dxCrd-1;
    dwPixel[9] = GetPixel(hDC, x, y);
    dwPixel[10] = GetPixel(hDC, x+1, y);
    dwPixel[11] = GetPixel(hDC, x, y-1);
}

VOID RestoreCorners(HDC hDC, UINT x, UINT y)
{
    // Upper Left
    SetPixel(hDC, x, y, dwPixel[0]);
    SetPixel(hDC, x+1, y, dwPixel[1]);
    SetPixel(hDC, x, y+1, dwPixel[2]);

    // Upper Right
    x += dxCrd-1;
    SetPixel(hDC, x, y, dwPixel[3]);
    SetPixel(hDC, x-1, y, dwPixel[4]);
    SetPixel(hDC, x, y+1, dwPixel[5]);

    // Lower Right
    y += dyCrd-1;
    SetPixel(hDC, x, y, dwPixel[6]);
    SetPixel(hDC, x, y-1, dwPixel[7]);
    SetPixel(hDC, x-1, y, dwPixel[8]);

    // Lower Left
    x -= dxCrd-1;
    SetPixel(hDC, x, y, dwPixel[9]);
    SetPixel(hDC, x+1, y, dwPixel[10]);
    SetPixel(hDC, x, y-1, dwPixel[11]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\freecell\transfer.c ===
/****************************************************************************

Transfer.c

June 91, JimH     initial code
Oct  91, JimH     port to Win32

Routines for transfering cards and queing cards for transfer are here.

****************************************************************************/

#include "freecell.h"
#include "freecons.h"
#include <assert.h>
#include <memory.h>


/****************************************************************************

Transfer

This function actually moves the cards.  It both updates the card array,
and draws the bitmaps.  Note that it moves only one card per call.

****************************************************************************/

VOID Transfer(HWND hWnd, UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    CARD    c;
    HDC     hDC;

    DEBUGMSG(TEXT("Transfer request from (%u, "), fcol);
    DEBUGMSG(TEXT("%u) to ("), fpos);
    DEBUGMSG(TEXT("%u, "), tcol);
    DEBUGMSG(TEXT("%u)\r\n"), tpos);

    assert(fpos < MAXPOS);
    assert(tpos < MAXPOS);

    UpdateWindow(hWnd);     // ensure cards are drawn before animation starts

    if (fcol == TOPROW)     // can't transfer FROM home cells
    {
        if ((fpos > 3) || (card[TOPROW][fpos] == IDGHOST))
            return;
    }
    else
    {
        if ((fpos = FindLastPos(fcol)) == EMPTY)    // or from empty column
            return;

        if (fcol == tcol)               // click and release on same column
        {
            hDC = GetDC(hWnd);
            DrawCard(hDC, fcol, fpos, card[fcol][fpos], FACEUP);
            ReleaseDC(hWnd, hDC);
            return;
        }
    }

    if (tcol == TOPROW)
    {
        if (tpos > 3)                       // if move to home cell
        {
            wCardCount--;
            DisplayCardCount(hWnd);         // update display
            c = card[fcol][fpos];
            home[SUIT(c)] = VALUE(c);       // new card at top of home[suit]
        }
    }
    else
        tpos = FindLastPos(tcol) + 1;       // bottom of column

    Glide(hWnd, fcol, fpos, tcol, tpos);    // send the card on its way

    c = card[fcol][fpos];
    card[fcol][fpos] = EMPTY;
    card[tcol][tpos] = c;

    /* If ACE being moved to home cell, update homesuit array. */

    if (VALUE(c) == ACE && tcol == TOPROW && tpos > 3)
        homesuit[SUIT(c)] = tpos;

    if (tcol == TOPROW)
    {
        hDC = GetDC(hWnd);
        DrawKing(hDC, tpos < 4 ? LEFT : RIGHT, TRUE);
        ReleaseDC(hWnd, hDC);
    }
}


/******************************************************************************

MoveCol

User has requested a multi-card move to an empty column

******************************************************************************/

VOID MoveCol(UINT fcol, UINT tcol)
{
    UINT freecells;                     // number of free cells
    CARD free[4];                       // locations of free cells
    UINT trans;                         // number to transfer
    INT  i;                             // counter

    assert(fcol != TOPROW);
    assert(tcol != TOPROW);
    assert(card[fcol][0] != EMPTY);

    /* Count number of free cells and put locations in free[] */

    freecells = 0;
    for (i = 0; i < 4; i++)
    {
        if (card[TOPROW][i] == EMPTY)
        {
            free[freecells] = i;
            freecells++;
        }
    }

    /* Find number of cards to transfer */

    if (fcol == TOPROW || tcol == TOPROW)
        trans = 1;
    else
        trans = NumberToTransfer(fcol, tcol);

    if (trans > (freecells+1))                    // don't transfer too many
        trans = freecells+1;

    /* Move to free cells */

    trans--;
    for (i = 0; i < (INT)trans; i++)
        QueueTransfer(fcol, 0, TOPROW, free[i]);

    /* Transfer last card directly */

    QueueTransfer(fcol, 0, tcol, 0);

    /* transfer from free cells to column */

    for (i = trans-1; i >= 0; i--)
        QueueTransfer(TOPROW, free[i], tcol, 0);
}


/******************************************************************************

MultiMove

User has chosen to move from one non-empty column to another.

******************************************************************************/

VOID MultiMove(UINT fcol, UINT tcol)
{
    CARD free[4];                       // locations of free cells
    UINT freecol[MAXCOL];               // locations of free columns
    UINT freecells;                     // number of free cells
    UINT trans;                         // number to transfer
    UINT col, pos;
    INT  i;                             // counter

    assert(fcol != TOPROW);
    assert(tcol != TOPROW);
    assert(card[fcol][0] != EMPTY);

    /* Count number of free cells and put locations in free[] */

    freecells = 0;
    for (pos = 0; pos < 4; pos++)
    {
        if (card[TOPROW][pos] == EMPTY)
        {
            free[freecells] = pos;
            freecells++;
        }
    }

    /* Find the number of cards to move.  If the number is too big to
       move all at once, push partial results into available columns. */

    trans = NumberToTransfer(fcol, tcol);
    if (trans > (freecells+1))
    {
        i = 0;
        for (col = 1; col < MAXCOL; col++)
            if (card[col][0] == EMPTY)
                freecol[i++] = col;

        /* transfer into free columns until direct transfer can be made */

        i = 0;
        while (trans > (freecells + 1))
        {
            MoveCol(fcol, freecol[i]);
            trans -= (freecells + 1);
            i++;
        }

        MoveCol(fcol, tcol);                    // do last transfer directly

        for (i--; i >= 0; i--)                  // gather cards in free cells
            MoveCol(freecol[i], tcol);
    }
    else                                        // else all one MoveCol()
    {
        MoveCol(fcol, tcol);
    }
}


/****************************************************************************

QueueTransfer

In order that multi-card moves happen slowly enough for the user to
watch, they are not moved as soon as they are calculated.  Instead,
they first are queued using this function into the movelist array.

After the request is queued, the card array is updated to reflect the
request.  This is ok because the card array is saved away in shadow
temporarily.  The same logic as in Transfer() is used to update card.

****************************************************************************/

VOID QueueTransfer(UINT fcol, UINT fpos, UINT tcol, UINT tpos)
{
    CARD    c;
    MOVE    move;

    assert(moveindex < MAXMOVELIST);
    assert(fpos < MAXPOS);
    assert(tpos < MAXPOS);

    move.fcol = fcol;               // package move request into MOVE type
    move.fpos = fpos;
    move.tcol = tcol;
    move.tpos = tpos;
    movelist[moveindex++] = move;   // store request in array and update index

    /* Now update card array if necessary. */

    if (fcol == TOPROW)
    {
        if ((fpos > 3) || (card[TOPROW][fpos] == IDGHOST))
            return;
    }
    else
    {
        if ((fpos = FindLastPos(fcol)) == EMPTY)
            return;

        if (fcol == tcol)               // click and release on same column
            return;
    }

    if (tcol == TOPROW)
    {
        if (tpos > 3)
        {
            c = card[fcol][fpos];
            home[SUIT(c)] = VALUE(c);
        }
    }
    else
        tpos = FindLastPos(tcol) + 1;

    c = card[fcol][fpos];
    card[fcol][fpos] = EMPTY;
    card[tcol][tpos] = c;

    if (VALUE(c) == ACE && tcol == TOPROW && tpos > 3)
        homesuit[SUIT(c)] = tpos;
}


/******************************************************************************

MoveCards

If there are queued transfer requests, this function moves them.

******************************************************************************/

VOID MoveCards(HWND hWnd)
{
    UINT     i;

    if (moveindex == 0)             // if there are no queued requests
        return;

    /* restore card to its state before requests got queued. */

    memcpy(&(card[0][0]), &(shadow[0][0]), sizeof(card));

    SetCursor(LoadCursor(NULL, IDC_WAIT));  // set cursor to hourglass
    SetCapture(hWnd);
    ShowCursor(TRUE);

    for (i = 0; i < moveindex; i++)
        Transfer(hWnd, movelist[i].fcol, movelist[i].fpos,
                    movelist[i].tcol, movelist[i].tpos);

    if ((moveindex > 1) || (movelist[0].fcol != movelist[0].tcol))
    {
        cUndo = moveindex;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_ENABLED);
    }
    else
    {
        cUndo = 0;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);
    }

    moveindex = 0;                      // no cards left to move

    ShowCursor(FALSE);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    ReleaseCapture();

    if (wCardCount == 0)                // if game is won
    {
        INT     cLifetimeWins;          // wins including .ini stats
        INT     wStreak, wSType;        // streak length and type
        INT     wWins;                  // record win streak
        INT_PTR nResponse;              // dialog box response
        HDC     hDC;
        LONG    lRegResult;

        cUndo = 0;
        EnableMenuItem(GetMenu(hWnd), IDM_UNDO, MF_GRAYED);

        lRegResult = REGOPEN

        if (ERROR_SUCCESS == lRegResult)
        {
            bGameInProgress = FALSE;
            bCheating = FALSE;
            cLifetimeWins = GetInt(pszWon, 0);

            if (gamenumber != oldgamenumber)    // repeats don't count
            {
                cLifetimeWins++;
                cWins++;
                cGames++;
                SetInt(pszWon, cLifetimeWins);
                wSType = GetInt(pszSType, LOST);
                if (wSType == LOST)
                {
                    SetInt(pszSType, WON);
                    wStreak = 1;
                    SetInt(pszStreak, 1);
                }
                else
                {
                    wStreak = GetInt(pszStreak, 0);
                    wStreak++;
                    SetInt(pszStreak, wStreak);
                }

                wWins = GetInt(pszWins, 0);
                if (wWins < wStreak)    // if new record
                {
                    wWins = wStreak;
                    SetInt(pszWins, wWins);
                }
            }

            REGCLOSE
        }

        hDC = GetDC(hWnd);
        Payoff(hDC);
        ReleaseDC(hWnd, hDC);

        bWonState = TRUE;
        nResponse = DialogBox(hInst, TEXT("YouWin"), hWnd, YouWinDlg);

        if (nResponse == IDYES)
            PostMessage(hWnd, WM_COMMAND,
                        bSelecting ? IDM_SELECT : IDM_NEWGAME, 0);

        oldgamenumber = gamenumber;
        gamenumber = 0;                 // turn off mouse handling
    }
    else
        IsGameLost(hWnd);               // check for game lost
}


/******************************************************************************

SetCursorShape

This function is called in response to WM_MOUSEMOVE.  If the current pointer
position represents a legal move, the cursor shape changes to indicate this.

******************************************************************************/

VOID SetCursorShape(HWND hWnd, UINT x, UINT y)
{
    UINT    tcol = 0, tpos = 0;
    UINT    trans;              // number of cards required to transfer
    BOOL    bFound;             // is cursor over card?
    HDC     hDC;

    /* If we're flipping, cursor is always an hourglass. */

    if (bFlipping)
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return;
    }

    bFound = Point2Card(x, y, &tcol, &tpos);

    if (bFound && tcol == TOPROW)
    {
        hDC = GetDC(hWnd);

        if (tpos < 4)
            DrawKing(hDC, LEFT, TRUE);
        else
            DrawKing(hDC, RIGHT, TRUE);

        ReleaseDC(hWnd, hDC);
    }

    /* Unless we're chosing a move target, cursor is just an arrow. */

    if (wMouseMode != TO)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* If we're not on a card, check if we're pointing to an empty
       column (up arrow), otherwise arrow. */

    if (!bFound)
    {
        if ((tcol > 0 && tcol < 9) && (card[tcol][0] == EMPTY))
            SetCursor(LoadCursor(NULL, IDC_UPARROW));
        else
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    if (tcol != TOPROW)
        tpos = FindLastPos(tcol);

    /* Check for cancel request. */

    if (wFromCol == tcol && wFromPos == tpos)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* Check moves from or to the top row. */

    if (wFromCol == TOPROW || tcol == TOPROW)
    {
        if (IsValidMove(hWnd, tcol, tpos))
        {
            if (tcol == TOPROW)
                SetCursor(LoadCursor(NULL, IDC_UPARROW));
            else
                SetCursor(LoadCursor(hInst, TEXT("DownArrow")));
        }
        else
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        return;
    }

    /* Check moves between columns. */

    trans = NumberToTransfer(wFromCol, tcol);   // how many required?

    if ((trans > 0) && (trans <= MaxTransfer()))
        SetCursor(LoadCursor(hInst, TEXT("DownArrow")));
    else
        SetCursor(LoadCursor(NULL, IDC_ARROW));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\golf\golf.c ===
#include <windows.h>
#include <port1632.h>
#include "cards.h"
#include "golf.h"
#include "cdt.h"
#include "stdlib.h"

#define ININAME "entpack.ini"

typedef INT X;
typedef INT Y;
typedef INT DX;
typedef INT DY;

// ReCt structure
typedef struct _rc
        {
        X xLeft;
        Y yTop;
        X xRight;
        Y yBot;
        } RC;

#define  abs(x)   (((x) < 0) ? (-(x)) : (x))

#define IDCARDBACK 65

#define APPTITLE    "Golf"

LRESULT APIENTRY WndProc (HWND, UINT, WPARAM, LPARAM) ;
VOID Deal(VOID);
VOID InitBoard(VOID);
VOID DrawLayout(HDC hDC);
VOID DrawPile(HDC hDC);
VOID UpdateDeck(HDC hDC);
BOOL UpdateLayout(HDC hDC, INT column, BOOL bValidate);
VOID UndoMove(HDC hDC);
VOID DoWinEffects(HDC hDC);
VOID UpdateScore(HDC hDC);
VOID  APIENTRY Help(HWND hWnd, UINT wCommand, ULONG_PTR lParam);
INT_PTR APIENTRY BackDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus);
VOID ChangeBack(WORD wNewDeckBack);
VOID DoBacks(VOID);
VOID MyDrawText(HDC hDC, LPSTR lpBuf, INT w, LPRECT lpRect, WORD wFlags);
INT Message(HWND hWnd, WORD wId, WORD wFlags);
BOOL fDialog(INT id,HWND hwnd,DLGPROC fpfn);

BOOL  APIENTRY cdtDrawExt(HDC hdc, INT x, INT y, INT dx, INT dy, INT cd, INT mode, DWORD rgbBgnd);
BOOL  APIENTRY cdtAnimate(HDC hdc, INT cd, INT x, INT y, INT ispr);
VOID DrawAnimate(INT cd, MPOINT *ppt, INT iani);
BOOL DeckAnimate(INT iqsec);
VOID  APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime);
VOID SaveState(VOID);
VOID RestoreState(VOID);
LPSTR lstrtok(LPSTR lpStr, LPSTR lpDelim);
static BOOL IsInString(CHAR c, LPSTR s);
VOID DrawGameOver(HDC hDC);
INT_PTR  APIENTRY RecordDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY ReadOnlyProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam);
VOID MarkControlReadOnly(HWND hwndCtrl, BOOL bReadOnly);

BOOL CheckGameOver(HDC hDC);

INT layout[52], pile[52], col[7];
INT deckStart, deckEnd, pilePos, nCards;
INT xClient, yClient, xCard, yCard;
INT xPileInc, yPileInc;
INT nCardsLeft[7], nWins, nGames;

DWORD dwBkgnd;
RECT deckRect, cntRect, pileRect, colRect[7];
WORD wErrorMessages;
WORD wDeckBack = IDCARDBACK;
FARPROC lpfnTimerProc;

typedef struct tagUndoRec {
   enum { Layout, Deck } origin;
   INT  column;
   } UndoRec;
UndoRec undo[52];
INT undoPos;

HWND hWnd;
HANDLE hMyInstance;
CHAR szAppName[80];
CHAR szOOM[256];
CHAR szGameOver[80], szGameOverS[80], szRecordTitle[80];
BOOL bGameInProgress = FALSE;

MMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
     /* { */
     MSG         msg ;
     WNDCLASS    wndclass ;
     HANDLE      hAccel;

    if (!LoadString(hInstance, IDSOOM, szOOM, 256) ||
        !LoadString(hInstance, IDSAppName, szAppName, 80) ||
        !LoadString(hInstance, IDSGameOver, szGameOver, 80) ||
        !LoadString(hInstance, IDSGameOverS, szGameOverS, 80) ||
        !LoadString(hInstance, IDSRecordTitle, szRecordTitle, 80)
        )
        return FALSE;

    if (hPrevInstance) {
        hWnd = FindWindow(szAppName, NULL);
        if (hWnd)
        {
            hWnd = GetLastActivePopup(hWnd);
            BringWindowToTop(hWnd);
            if (IsIconic(hWnd))
                ShowWindow(hWnd, SW_RESTORE);
        }
        return FALSE;
    }


    wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
    wndclass.lpfnWndProc   = WndProc ;
    wndclass.cbClsExtra    = 0 ;
    wndclass.cbWndExtra    = 0 ;
    wndclass.hInstance     = hInstance ;
    wndclass.hIcon         = LoadIcon (hInstance, "Golf") ;
    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground = CreateSolidBrush(dwBkgnd = RGB(0,130,0));
    wndclass.lpszMenuName  = szAppName ;
    wndclass.lpszClassName = szAppName ;

    if (!RegisterClass (&wndclass))
        return FALSE ;

     hWnd = CreateWindow (szAppName, APPTITLE,
                         WS_OVERLAPPEDWINDOW | WS_MAXIMIZE,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, CW_USEDEFAULT,
                         NULL, NULL, hInstance, NULL) ;

     if (!hWnd)
        return FALSE;

     hAccel = LoadAccelerators(hInstance, szAppName);

     if (!hAccel)
        return FALSE;

    if(SetTimer(hWnd, 666, 250, TimerProc) == 0) {
            return FALSE;
    }

    RestoreState();

     ShowWindow (hWnd, SW_SHOWMAXIMIZED) ;
     UpdateWindow (hWnd) ;

     hMyInstance = hInstance;
     while (GetMessage (&msg, NULL, 0, 0))
          {
          if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
          }
     return (INT) msg.wParam ;
     }

VOID  APIENTRY Help(HWND hWnd, UINT wCommand, ULONG_PTR lParam)
{
   CHAR szHelpPath[100], *pPath;

   pPath = szHelpPath
         + GetModuleFileName(hMyInstance, szHelpPath, 99);
   
   if (pPath != szHelpPath)
   {
       while (*pPath-- != '.')
          ;
       ++pPath;
       *++pPath = 'H';
       *++pPath = 'L';
       *++pPath = 'P';
       *++pPath = '\0';

       WinHelp(hWnd, szHelpPath, wCommand, lParam);
   }
}

VOID MyDrawText(HDC hDC, LPSTR lpBuf, INT w, LPRECT lpRect, WORD wFlags)
{
    DWORD dwOldBk, dwOldTextColor;
    HBRUSH hBrush, hOldBrush;

    dwOldBk = SetBkColor(hDC, dwBkgnd);
    dwOldTextColor = SetTextColor(hDC, RGB(255,255,255));
    if (hBrush = CreateSolidBrush(dwBkgnd)) {
        if (hOldBrush = SelectObject(hDC, hBrush)) {
            PatBlt(hDC, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
                lpRect->bottom - lpRect->top, PATCOPY);
            SelectObject(hDC, hOldBrush);
        }
        DeleteObject(hBrush);
    }
    DrawText(hDC, lpBuf, w, lpRect, wFlags);
    SetBkColor(hDC, dwOldBk);
    SetTextColor(hDC, dwOldTextColor);
}

VOID UpdateScore(HDC hDC)
{
    CHAR buffer[5];

    if (deckEnd - deckStart + 1) {
        wsprintf(buffer, "%2d", deckEnd - deckStart + 1);
        MyDrawText(hDC, buffer, -1, &cntRect, DT_RIGHT | DT_NOCLIP);
    }
}

VOID DisplayWins(VOID)
{
    fDialog(2, hWnd, RecordDlgProc);
}


LRESULT APIENTRY WndProc (
     HWND         hWnd,
     UINT         iMessage,
     WPARAM       wParam,
     LPARAM       lParam)
     {
     HDC          hDC ;
     HMENU        hMenu;
     PAINTSTRUCT  ps ;
     SHORT        i, j ;
     MPOINT       pt;
     POINT        mpt;
     static BOOL  fBoard;
     FARPROC      lpAbout;
     HANDLE hLib;

     switch (iMessage)
          {
          case WM_CREATE:
               cdtInit(&xCard, &yCard);
               Deal();
               fBoard = FALSE;
               break;

          case WM_SIZE:
               xClient = LOWORD(lParam);
               yClient = HIWORD(lParam);
               break;

          case WM_PAINT:
               hDC = BeginPaint (hWnd, &ps) ;
               if (!fBoard)
               {
                  InitBoard();
                  fBoard = TRUE;
               }
               DrawLayout(hDC);
               DrawPile(hDC);
                              EndPaint(hWnd, &ps);
                              break;

          case WM_LBUTTONDOWN:
               pt.x = LOWORD(lParam);
               pt.y = HIWORD(lParam);

               MPOINT2POINT(pt, mpt);
               if (PtInRect(&deckRect, mpt))
               {
                  SendMessage(hWnd, WM_KEYDOWN, VK_SPACE, 0L);
                  break;
               }

               i = 0;
               for (j = 0; j < 7; ++j)
                  if (PtInRect(colRect + j, mpt))
                  {
                     i = (SHORT) (j + 1);
                     break;
                  }
               if (i)
                  SendMessage(hWnd, WM_KEYDOWN, '0' + i, 0L);

               break;

          case WM_INITMENU:
               hMenu = GetMenu(hWnd);
               EnableMenuItem(hMenu, IDM_OPTIONSUNDO, MF_BYCOMMAND |
                              undoPos ? MF_ENABLED : MF_GRAYED);
                CheckMenuItem(hMenu, IDM_OPTIONSERROR,
                            wErrorMessages ? MF_CHECKED : MF_UNCHECKED);
               break;

          case WM_RBUTTONDOWN:
               SendMessage(hWnd, WM_KEYDOWN, VK_SPACE, 0L);
               break;

          case WM_KEYDOWN:
               hDC = GetDC(hWnd);

               switch (wParam)
               {
                  case VK_ESCAPE:
                     ShowWindow(hWnd, SW_MINIMIZE);
                     break;


                  case VK_SPACE:
                     UpdateDeck(hDC);
                     break;
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                     UpdateLayout(hDC, (CHAR) wParam - '1', FALSE);
                     break;
               }

               ReleaseDC(hWnd, hDC);
               break;

          case WM_COMMAND:
                switch(GET_WM_COMMAND_ID(wParam, lParam))
               {
                  case IDM_NEWGAME:
                     Deal();
                     fBoard = FALSE;
                     InvalidateRect(hWnd, NULL, TRUE);
                     break;

                  case IDM_EXIT:
                     DestroyWindow(hWnd);
                     break;

                  case IDM_OPTIONSDECK:
                     DoBacks();
                     break;

                  case IDM_GAMERECORD:
                     DisplayWins();
                     break;

                  case IDM_ABOUT:
                     hLib = MLoadLibrary("shell32.dll");
                     if (hLib < (HANDLE)32)
                        break;

                     lpAbout = GetProcAddress(hLib, (LPSTR)"ShellAboutA");

                     if (lpAbout) {
                     (*lpAbout)(hWnd, szAppName, "by Ken Sykes", LoadIcon(hMyInstance, szAppName));
                     }

                     FreeLibrary(hLib);
                     break;

                    case MENU_INDEX:
                        Help(hWnd, HELP_INDEX, 0L);
                        break;

                    case MENU_HOWTOPLAY:
                        Help(hWnd, HELP_CONTEXT, 1L);
                        break;

                    case MENU_COMMANDS:
                        Help(hWnd, HELP_CONTEXT, 2L);
                        break;

                    case MENU_USINGHELP:
                        Help(hWnd, HELP_HELPONHELP, 0L);
                        break;

                  case IDM_OPTIONSERROR:
                     wErrorMessages = (WORD) ~wErrorMessages;
                     break;

                  case IDM_OPTIONSUNDO:
                     hDC = GetDC(hWnd);
                     UndoMove(hDC);
                     ReleaseDC(hWnd, hDC);
                     break;

               }
               break;

          case WM_DESTROY:
               KillTimer(hWnd, 666);
               FreeProcInstance(lpfnTimerProc);
               cdtTerm();
               Help(hWnd, HELP_QUIT, 0L);
               SaveState();
               PostQuitMessage (0) ;
               break ;

          default:
               return DefWindowProc (hWnd, iMessage, wParam, lParam) ;
          }
     return 0L ;
     }

VOID Deal(VOID)
{
   INT i, p1, p2, tmp;

   /* stuff cards into layout */
   for (i = 0; i < 52; ++i)
      layout[i] = i;

   /* shuffle them around */
   srand(LOWORD(GetTickCount()));
   for (i = 0; i < 500; ++i)
   {
      p1 = rand() % 52;
      p2 = rand() % 52;
      tmp = layout[p1];
      layout[p1] = layout[p2];
      layout[p2] = tmp;
   }

   /* initialize column pointers */
   for (i = 0; i < 7; ++i)
      col[i] = i * 5 + 4;
   deckStart = 35;
   deckEnd = 51;
   pilePos = 0;

   /* turn over the first card */
   pile[pilePos] = layout[deckEnd--];
   nCards = 35;

   bGameInProgress = TRUE;
}

VOID InitBoard(VOID)
{
   INT xPos, yPos;
   INT xStep, yStep, col;

   xPos = 30;
   yPos = yClient - yCard - 30;
   deckRect.left = xPos;
   deckRect.right = xPos + xCard;
   deckRect.top = yPos;
   deckRect.bottom = yPos + yCard;

   cntRect.left = xPos;
   cntRect.right = cntRect.left + xCard;
   cntRect.top = yPos + yCard + 5;
   cntRect.bottom = cntRect.top + 20;

   xPos += xCard + 20;
   pileRect.left = xPos;
   pileRect.right = xPos + xCard;
   pileRect.top = yPos;
   pileRect.bottom = yPos + yCard;
   xPileInc = (xClient - 2 * xCard - 50) / 52;
   yPileInc = 18;

   xStep = xCard + 10;
   yStep = yPileInc;

   for (col = 0, xPos = 30; col < 7; ++col, xPos += xStep)
   {
      yPos = 10 + 5 * yStep;
      colRect[col].left = xPos;
      colRect[col].right = xPos + xCard;
      colRect[col].top = yPos - yStep;
      colRect[col].bottom = yPos - yStep + yCard;
   }

   undoPos = 0;

}

VOID DrawLayout(HDC hDC)
{
   INT xStep, yStep, column, i, *card;
   RECT rect;

   xStep = xCard + 10;
   yStep = yPileInc;

   for (column = 0; column < 7; ++column)
   {
      /* if column is empty skip it */
      if (col[column] < 5 * column)
         continue;

      /* start rectangle at top of column */
      rect = colRect[column];
      OffsetRect(&rect, 0, -yStep * (col[column] - 5 * column));

      card = layout + 5 * column;
      while (rect.top <= colRect[column].top)
      {
         cdtDraw(hDC, rect.left, rect.top, *card++, faceup, dwBkgnd);
         OffsetRect(&rect, 0, yStep);
      }
   }
}

VOID DrawPile(HDC hDC)
{
   INT i, xPos;

   if (bGameInProgress)
       cdtDraw(hDC, deckRect.left, deckRect.top, wDeckBack, facedown, dwBkgnd);
   else
       DrawGameOver(hDC);

   UpdateScore(hDC);

   for (i = 0, xPos = 50 + xCard; i <= pilePos; ++i, xPos += xPileInc)
      cdtDraw(hDC, xPos, pileRect.top, pile[i], faceup, dwBkgnd);
}

VOID UpdateDeck(HDC hDC)
{
   /* if deck is empty return */
   if (deckEnd < deckStart)
      return;

   /* move card to pile */
   pile[++pilePos] = layout[deckEnd--];

   /* fill in undo buffer */
   undo[undoPos++].origin = Deck;

   /* draw new card */
   OffsetRect(&pileRect, xPileInc, 0);
   cdtDraw(hDC, pileRect.left, pileRect.top, pile[pilePos], faceup, dwBkgnd);

   /* update counter */
   UpdateScore(hDC);

   /* if we turned up last card remove facedown bitmap */
   CheckGameOver(hDC);
}

BOOL CheckGameOver(HDC hDC)
{
    RECT rect;
    INT  i;

    if (deckEnd >= deckStart)
        return FALSE;

    SetBkColor(hDC, dwBkgnd);
    cdtDraw(hDC, 30, yClient - yCard - 30, 0, remove, dwBkgnd);
    rect = cntRect;
    MyDrawText(hDC, "", 0, &rect, DT_LEFT | DT_NOCLIP);

    for (i = 0; i < 7; ++i)
        if (UpdateLayout(hDC, i, TRUE))
            return FALSE;

    bGameInProgress = FALSE;

    DrawGameOver(hDC);

    ++nCardsLeft[(nCards - 1) / 5];
    ++nGames;

    return TRUE;
}

VOID DrawGameOver(HDC hDC)
{
    CHAR buffer[30];
    RECT rect;

    wsprintf(buffer, (nCards == 1) ? szGameOverS : szGameOver, nCards);
    rect = cntRect;
    rect.left = 0;
    rect.right = xClient;
    MyDrawText(hDC, buffer, -1, &rect, DT_CENTER | DT_NOCLIP);
}

BOOL UpdateLayout(HDC hDC, INT column, BOOL bValidate)
{
   INT colpos, dist;

   /* if column is empty, ignore */
   colpos = col[column];
   if (colpos < 0 || (colpos / 5) != column)
      return FALSE;

   /* if card on top of pile is a king, don't move card to pile */
   if (CardRank(pile[pilePos]) == king)
   {
      if (wErrorMessages && !bValidate)
         Message(hWnd, IDSNoCardOnKing, MB_OK);
      return FALSE;
   }

   /* if card is not adjacent, don't move it to pile */
   dist = IndexValue(pile[pilePos], ACELOW)
        - IndexValue(layout[colpos], ACELOW);
   if (abs(dist) != 1)
   {
      if (wErrorMessages && !bValidate)
         Message(hWnd, IDSNotAdjacent, MB_OK);
      return FALSE;
   }

   if (bValidate)
      return TRUE;

   /* move card to pile */
   pile[++pilePos] = layout[colpos--];
   col[column] = colpos;

   /* fill in undo buffer */
   undo[undoPos].origin = Layout;
   undo[undoPos++].column = column;

   /* remove card from layout */
   SetBkColor(hDC, dwBkgnd);
   cdtDraw(hDC, colRect[column].left, colRect[column].top,
                pile[pilePos], remove, dwBkgnd);

   if (colpos >= 5 * column)
   {
      OffsetRect(colRect + column, 0, -yPileInc);
      cdtDraw(hDC, colRect[column].left, colRect[column].top,
                  layout[colpos], faceup, dwBkgnd);
   }

   /* draw card on pile */
   OffsetRect(&pileRect, xPileInc, 0);
   cdtDraw(hDC, pileRect.left, pileRect.top, pile[pilePos], faceup, dwBkgnd);

   /* decrement # of cards */
   --nCards;

   if (!nCards)
      DoWinEffects(hDC);

   /* if deck is empty display game over message */
   CheckGameOver(hDC);

   return TRUE;
}

VOID UndoMove(HDC hDC)
{
   CHAR buffer[10];
   RECT *pRect, rect;
   INT column;
   HBRUSH hBrush;

   --undoPos;

   /* erase the top card on the pile */
   SetBkColor(hDC, dwBkgnd);
   cdtDraw(hDC, pileRect.left, pileRect.top, pile[pilePos], remove, dwBkgnd);
   OffsetRect(&pileRect, -xPileInc, 0);

   /* redraw the card that will now be at top of pile */
   if (pilePos)
      cdtDraw(hDC, pileRect.left, pileRect.top,
              pile[pilePos-1], faceup, dwBkgnd);

    if (!bGameInProgress)
    {
        rect = cntRect;
        rect.left = rect.right + 1;
        rect.right = xClient;
        rect.bottom = yClient;
        hBrush = CreateSolidBrush(dwBkgnd);
        if (hBrush) {
            FillRect(hDC, &rect, hBrush);
            DeleteObject(hBrush);
        }

        if (nCards)
            --nCardsLeft[(nCards - 1) / 5];
        else
            --nWins;
        --nGames;

        bGameInProgress = TRUE;
    }

   /* move the card back where it belongs */
   if (undo[undoPos].origin == Deck)
   {
      if (deckEnd < deckStart)
        cdtDraw(hDC, 30, yClient - yCard - 30, wDeckBack, facedown, dwBkgnd);

      layout[++deckEnd] = pile[pilePos--];
      UpdateScore(hDC);
   }
   else
   {
      column = undo[undoPos].column;
      pRect = colRect + column;
      if (col[column] >= 5 * column)
         OffsetRect(pRect, 0, yPileInc);
      cdtDraw(hDC, pRect->left, pRect->top, pile[pilePos], faceup, dwBkgnd);
      layout[++col[undo[undoPos].column]] = pile[pilePos--];

      ++nCards;
   }
}

VOID DoWinEffects(HDC hDC)
{
   Message(hWnd, IDSWinner, MB_OK);
   ++nWins;
   ++nGames;

   undoPos = 0;
}

VOID DoBacks()
        {
        
        DialogBox(hMyInstance, MAKEINTRESOURCE(1), hWnd, BackDlgProc);

        }

INT_PTR  APIENTRY BackDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
        {
        static INT modeNew;
        INT iback;
        MEASUREITEMSTRUCT FAR *lpmi;
        DRAWITEMSTRUCT FAR *lpdi;
        HBRUSH hbr;
        RC rc, rcCrd;
        HDC hdc;
        INT i;

        switch(wm)
                {
        case WM_INITDIALOG:
                modeNew = wDeckBack;
                SetFocus(GetDlgItem(hdlg, modeNew));
                return FALSE;

        case WM_COMMAND:

                if(GET_WM_COMMAND_ID(wParam, lParam) >= IDFACEDOWNFIRST &&
                   GET_WM_COMMAND_ID(wParam, lParam) <= IDFACEDOWN12) {
                        modeNew = GET_WM_COMMAND_ID(wParam, lParam) ;
                        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_DOUBLECLICKED) {
                            ChangeBack((WORD)modeNew);
                            EndDialog(hdlg, 0);
                        }
                } else
                        switch(wParam)
                                {
                        case IDOK:
                                ChangeBack((WORD)modeNew);
                                /* fall thru */

                        case IDCANCEL:
                                EndDialog(hdlg, 0);
                                break;

                                }
                break;

        case WM_MEASUREITEM:
                lpmi = (MEASUREITEMSTRUCT FAR *)lParam;
                lpmi->CtlType = ODT_BUTTON;
                lpmi->itemWidth = xCard /* 32 */;
                lpmi->itemHeight = yCard /* 54 */;
                break;
        case WM_DRAWITEM:
                lpdi = (DRAWITEMSTRUCT FAR *)lParam;

                CopyRect((LPRECT) &rc, &lpdi->rcItem);
                rcCrd = rc;
                InflateRect((LPRECT) &rcCrd, -3, -3);
                hdc = lpdi->hDC;

                if (lpdi->itemAction == ODA_DRAWENTIRE)
                  {
                    cdtDrawExt(hdc, rcCrd.xLeft, rcCrd.yTop,
                            rcCrd.xRight-rcCrd.xLeft, rcCrd.yBot-rcCrd.yTop,
                            lpdi->CtlID, FACEDOWN, 0L);
                    FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);
                    break;
                  }
                if (lpdi->itemAction == ODA_SELECT)
                    InvertRect(hdc, (LPRECT)&rcCrd);

                if (lpdi->itemAction == ODA_FOCUS)
                    FDrawFocus(hdc, &rc, lpdi->itemState & ODS_FOCUS);

                break;
        default:
                return FALSE;
                }
        return TRUE;
        }

BOOL FDrawFocus(HDC hdc, RC *prc, BOOL fFocus)
        {
        HBRUSH hbr;
        RC rc;
        hbr = CreateSolidBrush(GetSysColor(fFocus ? COLOR_HIGHLIGHT : COLOR_WINDOW));
        if(hbr == NULL)
                return FALSE;
        rc = *prc;
        FrameRect(hdc, (LPRECT) &rc, hbr);
        InflateRect((LPRECT) &rc, -1, -1);
        FrameRect(hdc, (LPRECT) &rc, hbr);
        DeleteObject(hbr);
        return TRUE;
        }


VOID ChangeBack(WORD wNewDeckBack)
{
    HDC hDC;

    wDeckBack = wNewDeckBack;

    if (deckEnd < deckStart)
        return;

    hDC = GetDC(hWnd);
    if (hDC) {
        cdtDraw(hDC, deckRect.left, deckRect.top, wDeckBack, facedown, dwBkgnd);
        ReleaseDC(hWnd, hDC);
    }
}

INT Message(HWND hWnd, WORD wId, WORD wFlags)
{
    static CHAR szBuf[256];

    if (!LoadString(hMyInstance, wId, szBuf, 256) ||
        wId == IDSOOM) {
        lstrcpy(szBuf, szOOM);
        wFlags = MB_ICONHAND | MB_SYSTEMMODAL;
    }

    if (!(wFlags & MB_SYSTEMMODAL))
        wFlags |= MB_TASKMODAL;

    if (!(wFlags & (MB_ICONHAND | MB_ICONEXCLAMATION | MB_ICONINFORMATION)))
        wFlags |= MB_ICONEXCLAMATION;

    return MessageBox(hWnd, szBuf, szAppName, wFlags);
}


VOID DrawAnimate(INT cd, MPOINT *ppt, INT iani)
{
    HDC hDC;

    if(!(hDC = GetDC(hWnd)))
            return;
    cdtAnimate(hDC, cd, ppt->x, ppt->y, iani);
    ReleaseDC(hWnd, hDC);
}

BOOL DeckAnimate(INT iqsec)
{
    INT iani;
    MPOINT pt;


    pt.x = (SHORT) deckRect.left;
    pt.y = (SHORT) deckRect.top;

    switch(wDeckBack) {
        case IDFACEDOWN3:
                DrawAnimate(IDFACEDOWN3, &pt, iqsec % 4);
                break;
        case IDFACEDOWN10:  // krazy kastle
                DrawAnimate(IDFACEDOWN10, &pt, iqsec % 2);
                break;

        case IDFACEDOWN11:  // sanflipe
                if((iani = (iqsec+4) % (50*4)) < 4)
                        DrawAnimate(IDFACEDOWN11, &pt, iani);
                else
                        // if a menu overlapps an ani while it is ani'ing, leaves deck
                        // bitmap in inconsistent state...
                        if(iani % 6 == 0)
                                DrawAnimate(IDFACEDOWN11, &pt, 3);
                break;
        case IDFACEDOWN12:  // SLIME
                if((iani = (iqsec+4) % (15*4)) < 4)
                        DrawAnimate(IDFACEDOWN12, &pt, iani);
                else
                        // if a menu overlapps an ani while it is ani'ing, leaves deck
                        // bitmap in inconsistent state...
                        if(iani % 6 == 0)
                                DrawAnimate(IDFACEDOWN12, &pt, 3);
                break;
    }

    return TRUE;
}

VOID  APIENTRY TimerProc(HWND hwnd, UINT wm, UINT_PTR id, DWORD dwTime)
{
    static INT x = 0;

    if (deckEnd >= deckStart)
        DeckAnimate(x++);
    return;
}

VOID SaveState(VOID)
{
    CHAR sz[80];

    wsprintf(sz, "%d %d %d %d %d %d %d %d %d", nGames, nWins, nCardsLeft[0],
             nCardsLeft[1], nCardsLeft[2], nCardsLeft[3],
             nCardsLeft[4], nCardsLeft[5], nCardsLeft[6]);
    WritePrivateProfileString(szAppName, "Stats", sz, ININAME);

    wsprintf(sz, "%d %d", wErrorMessages, wDeckBack);
    WritePrivateProfileString(szAppName, "MenuState", sz, ININAME);
}

VOID RestoreState(VOID)
{
    CHAR sz[80], *psz;
    INT col;
    DWORD cchRead;

    cchRead = GetPrivateProfileString(szAppName, "Stats", "0 0 0 0 0 0 0 0 0", sz,
                                      sizeof(sz), ININAME);

    psz = (cchRead > 0) ? lstrtok(sz, " ") : NULL;
    if (psz) {
        nGames = atoi(psz);
        psz = lstrtok(NULL, " ");
        nWins = psz ? atoi(psz) : 0;
    } else
        nGames = nWins = 0;

    for (col = 0; col < 7 && psz; ++col)
        nCardsLeft[col] = atoi(psz = lstrtok(NULL, " "));

    for (; col < 7; ++col)
        nCardsLeft[col] = 0;

    cchRead = GetPrivateProfileString(szAppName, "MenuState", "0 65", sz,
                                      sizeof(sz), ININAME);

    psz = (cchRead > 0) ? lstrtok(sz, " ") : NULL;
    if (psz) {
        wErrorMessages = (WORD) atoi(psz);
        psz = lstrtok(NULL, " ");

        wDeckBack = (WORD) IDCARDBACK;

        if (psz)
            wDeckBack = (WORD) atoi(psz); 

    } else {
        wErrorMessages = 0;
        wDeckBack = IDCARDBACK;
    }
}

static BOOL IsInString(CHAR c, LPSTR s)
{
   while (*s && *s != c)
      s = AnsiNext(s);

   return *s;
}

/* write our own strtok to avoid pulling in entire string library ... */
LPSTR lstrtok(LPSTR lpStr, LPSTR lpDelim)
{
   static LPSTR lpString;
   LPSTR lpRetVal, lpTemp;

   /* if we are passed new string skip leading delimiters */
   if(lpStr) {
      lpString = lpStr;

      while (*lpString && IsInString(*lpString, lpDelim))
         lpString = AnsiNext(lpString);
   }

   /* if there are no more tokens return NULL */
   if(!*lpString)
      return NULL;

   /* save head of token */
   lpRetVal = lpString;

   /* find delimiter or end of string */
   while(*lpString && !IsInString(*lpString, lpDelim))
      lpString = AnsiNext(lpString);

   /* if we found a delimiter insert string terminator and skip */
   if(*lpString) {
      lpTemp = AnsiNext(lpString);
      *lpString = '\0';
      lpString = lpTemp;
   }

   /* return token */
   return(lpRetVal);
}

/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,fpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|       the function passed will have a proc instance made for it.             |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       fpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL fDialog(INT id,HWND hwnd,DLGPROC fpfn)
{
    BOOL        f;
    HANDLE      hInst;

    hInst = (HANDLE) GetWindowLongPtr(hwnd,GWLP_HINSTANCE);
    fpfn  = MakeProcInstance(fpfn,hInst);
    f = (BOOL) DialogBox(hInst,MAKEINTRESOURCE(id),hwnd, fpfn);
    FreeProcInstance (fpfn);
    return f;
}

INT_PTR  APIENTRY RecordDlgProc(HANDLE hdlg, UINT wm, WPARAM wParam, LPARAM lParam)
{
    CHAR sz[80];
    HWND hwndEdit;
    INT  i;

    switch(wm) {

        case WM_INITDIALOG:
            hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
            SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (szRecordTitle));

            wsprintf(sz, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d", nGames, nWins, nCardsLeft[0],
                    nCardsLeft[1], nCardsLeft[2], nCardsLeft[3],
                    nCardsLeft[4], nCardsLeft[5], nCardsLeft[6]);
            SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (sz));
            MarkControlReadOnly(hwndEdit, TRUE);
            return TRUE;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    /* fall thru */

                case IDCANCEL:
                    hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
                    MarkControlReadOnly(hwndEdit, FALSE);
                    EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);

                    break;

                case IDD_CLEARSCORES:
                    nGames = nWins = 0;
                    for (i = 0; i < 7; ++i)
                        nCardsLeft[i] = 0;
                    lstrcpy(sz, "0\t0\t0\t0\t0\t0\t0\t0\t0");
                    hwndEdit = GetDlgItem(hdlg, IDD_RECORD);
                    SendMessage(hwndEdit, LB_DELETESTRING, 1, 0L);
                    SendMessage(hwndEdit, LB_ADDSTRING, 0, (LPARAM) (sz));
                    break;
            }
            break;
    }

    return FALSE;
}


static WNDPROC lpOldWP;

VOID MarkControlReadOnly(HWND hwndCtrl, BOOL bReadOnly)
{
    if (bReadOnly)
        lpOldWP = (WNDPROC) SetWindowLongPtr(hwndCtrl, GWLP_WNDPROC,
                                            (LONG_PTR) ReadOnlyProc);
    else
        SetWindowLongPtr(hwndCtrl, GWLP_WNDPROC, (LONG_PTR)lpOldWP);
}

LRESULT APIENTRY ReadOnlyProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam)
{
    switch (wMessage) {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
            return 0L;
    }

   return CallWindowProc(lpOldWP, hwnd, wMessage, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\scrapp.h ===
#define idmOptions	0
#define idmHelp		1

#define idmSetTimeout	100
#define idmBlankNow	101
#define idmAbout	102
#define idmBlankPtr	103
#define idmBackground	104
#define idmQuit		105
#define idmSetDir	106
#define idmIndex	107
#define idmOverview	108
#define idmHowTo	109
#define idmCommands	110
#define idmAutoload	111

#define idOK		IDOK
#define idCancel	IDCANCEL
#define idTimeout	3
#define idList		4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\std.h ===
typedef BOOL F;
#define fFalse 0
#define fTrue 1

typedef UCHAR CH;

#ifndef PM
typedef CH * SZ;
#endif

typedef VOID * PV;
#define pvNil ((PV) 0)

#define hNil ((HANDLE) 0)


#ifdef PM
typedef POINTL PT;
typedef HPS CVS;
#endif
#ifdef WIN
typedef MPOINT PT;
typedef HDC CVS;
#ifndef _ALPHA_
typedef LPSTR PSZ;  // MAY CAUSE PROBLEMS ON ALPHA
#endif
typedef HANDLE HAB;
#define EXPENTRY  APIENTRY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\scrsave.h ===
#define SSM_OPEN	1
#define SSM_CLOSE	2
#define SSM_BLANK	3
#define SSM_UNBLANK	4
#define SSM_ANIMATE	5
#define SSM_SECOND	6
#define SSM_DIALOG	7


extern VOID  APIENTRY ScrBlank(SHORT);

extern VOID  APIENTRY ScrSetIgnore(SHORT);

extern INT   APIENTRY ScrGetTimeout(VOID);
extern VOID  APIENTRY ScrSetTimeout(INT);

extern VOID  APIENTRY ScrQueryServerName(CHAR FAR *);
extern VOID  APIENTRY ScrQueryServerDesc(CHAR FAR *);
extern SHORT  APIENTRY ScrLoadServer(CHAR FAR *);
extern VOID  APIENTRY ScrChooseRandomServer(VOID);
extern BOOL  APIENTRY ScrSetServer(CHAR FAR *);

extern VOID  APIENTRY ScrEnablePtrBlank(INT);
extern INT   APIENTRY ScrQueryPtrBlank(VOID);

extern VOID  APIENTRY ScrSetBackground(SHORT);
extern INT   APIENTRY ScrQueryBackground(VOID);

extern VOID  APIENTRY ScrRestoreScreen(VOID);


extern VOID  APIENTRY SeedRand(LONG);
extern SHORT  APIENTRY WRand(UINT);

#ifdef WIN
extern VOID  APIENTRY ScrInvokeDlg(HANDLE, HWND);
#endif

typedef BOOL (CALLBACK *SCRSAVEPROC)(INT, LPVOID, LONG_PTR, LONG_PTR);
extern BOOL ScrSaveProc(INT, LPVOID, LONG_PTR, LONG_PTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\dropout\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\firework\firework.c ===
#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif
#ifdef PM
#include <cstd.h>
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
INT _acrtused = 0;
#endif

#include "std.h"

#include "scrsave.h"

VOID CreateFountain();
VOID CreateRocket();
VOID CreateBang();
VOID CallAobProc();

INT PenRand();


#define penBlack 0
#define penWhite 15

INT dxScreen, dyScreen;


#ifdef WIN

#define hdc hps

LONG mppenrgb [] =
	{
	RGB(0x00, 0x00, 0x00),
	RGB(0x00, 0x00, 0x80),
	RGB(0x00, 0x80, 0x00),
	RGB(0x00, 0x80, 0x80),
	RGB(0x80, 0x00, 0x00),
	RGB(0x80, 0x00, 0x80),
	RGB(0x80, 0x80, 0x00),
	RGB(0x80, 0x80, 0x80),
	RGB(0xc0, 0xc0, 0xc0),
	RGB(0x00, 0x00, 0xff),
	RGB(0x00, 0xff, 0x00),
	RGB(0x00, 0xff, 0xff),
	RGB(0xff, 0x00, 0x00),
	RGB(0xff, 0x00, 0xff),
	RGB(0xff, 0xff, 0x00),
	RGB(0xff, 0xff, 0xff)
	};

#endif




extern VOID Animate(CVS);
extern VOID SecondProc(VOID);


INT dxScreen, dyScreen;
CVS hps;

BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Fireworks";
		while ((*lpsz++ = *lpch++) != '\0')
			;

		lpsz = (PSZ) l2;
		lpch = "Exploding Rockets\n\nby Brad Christian";
		while ((*lpsz++ = *lpch++) != '\0')
			;

#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		CreateFountain();
		break;
		
	case SSM_ANIMATE:
		Animate((CVS) l1);
		break;
		
	case SSM_SECOND:
		SecondProc();
		break;
		}
	
	return fTrue;
	}



#define aomMove		0
#define aomDraw		1
#define aomErase	2

#define shpRect		0
#define shpText		1


typedef struct _aob
	{
	INT aot;
	INT shp;
	LONG x, y;
	INT dx, dy;
	LONG pen;
	INT dxMove, dyMove;
	INT dxAccel, dyAccel;
	INT ifr;
	INT xTarget, yTarget;
	SZ sz;
	} AOB;

#define iaobMax		100

AOB rgaob [iaobMax];
	
INT iaobMac = sizeof (rgaob) / sizeof (AOB);


AOB * PaobNew(aot)
	{
	INT iaob;
	AOB * paob;
	
	paob = rgaob;
	for (iaob = 0; paob->aot != 0; iaob += 1, paob += 1)
		{
		if (iaob == iaobMac - 1)
			return pvNil;
		}
	
	paob->aot = aot;
	paob->shp = shpRect;
	paob->x = 0;
	paob->y = 0;
	paob->dx = 0;
	paob->dy = 0;
	paob->dxMove = 0;
	paob->dyMove = 0;
	paob->dxAccel = 0;
	paob->dyAccel = 0;
	paob->ifr = 0;
	paob->xTarget = 0;
	paob->yTarget = 0;
	paob->sz = "";
	paob->pen = 0;
	
	return paob;
	}

	
VOID CreateFountain()
	{
	AOB * paob;
	
	if ((paob = PaobNew(3)) == pvNil)
		return;
	
	paob->x = (LONG) (dxScreen / 2 - 1) << 16;
	paob->y = (LONG) (dyScreen - 2) << 16;
	paob->xTarget = PenRand();
	paob->yTarget = PenRand();
	}


VOID FountainProc(paob, aom)
AOB * paob;
	{
	switch (aom)
		{
	case aomMove:
		if (paob->ifr == 4)
			{
			AOB * paobT;
			
			paob->ifr = WRand(3);
			if ((paobT = PaobNew(4)) == pvNil)
				break;
			paobT->dx = paobT->dy = 1;
			paobT->dxMove = (WRand(256 * 4) - 256 * 2);
			paobT->dyMove = -((WRand(5 * 256) + 2560));
			if (WRand(10) == 5)
				paobT->dyMove *= 2;
			paobT->dyAccel = 128;
			paobT->pen = WRand(10) < 5 ? paob->yTarget : paob->xTarget;
			paobT->x = (LONG) (dxScreen / 2) << 16;
			paobT->y = (LONG) dyScreen << 16;
			
			if (WRand(30) < 2)
				{
				paob->xTarget = PenRand();
				paob->yTarget = PenRand();
				}
			}
		break;
		}
	}


VOID AshProc(paob, aom)
AOB * paob;
	{
	switch (aom)
		{
	case aomMove:
		if ((paob->y >> 16) > dyScreen)
			paob->aot = 0;
		break;
		}
	}

	
VOID CreateRocket(x, y)
	{
	AOB * paob;
	
	if ((paob = PaobNew(2)) == pvNil)
		return;
	
	paob->x = (LONG) (dxScreen / 2 + ((WRand(10) > 5) ? -dxScreen : dxScreen) / 4) << 16;
	paob->y = (LONG) (dyScreen - 1) << 16;

	paob->dx = 2;
	paob->dy = 4;

#ifdef LOWRES
	paob->dx /= 2;
	paob->dy /= 2;
#endif

	paob->pen = penWhite;
	paob->dyMove = 256 * -WRand(3);
	paob->dyAccel = (256 + 128) * -1;
	paob->xTarget = x;
	paob->yTarget = y;
	}

	
VOID RocketProc(paob, aom)
AOB * paob;
	{
	AOB * paobT;
		
	switch (aom)
		{
	case aomMove:
		if (paob->y >> 16 <= paob->yTarget || paob->dyMove > 2 * 256)
			{
			paob->aot = 0;
			CreateBang((INT) (paob->x >> 16), 
				(INT) (paob->y >> 16));
			return;
			}
			
		if (paob->ifr == 10)
			{
			paob->dyAccel = 0;
			}
		else if (paob->ifr == 30)
			{
			paob->dyAccel = 256;
			}
		
		if ((paob->ifr % 20) == 0)
			{
			if (paob->x >> 16 < paob->xTarget && paob->dxMove < 4 * 256)
				paob->dxMove += 256;
			if (paob->x >> 16 > paob->xTarget && paob->dxMove > -4 * 256)
				paob->dxMove -= 256;
			
			}
		if ((paobT = PaobNew(1)) != pvNil)
			{
			paobT->x = paob->x;
			paobT->y = paob->y + ((LONG) paob->dy << 16);
			paobT->dx = 1;
			paobT->dy = 1;
			paobT->dxMove = paob->dxMove + 256 * (WRand(3) - 1);
			paobT->dyMove = paob->dyMove;
			paobT->dxAccel = 0;
			paobT->dyAccel = 2 * 256 + 128;
			paobT->ifr = -WRand(12);
			paobT->xTarget = 0;
			paobT->yTarget = 0;
			}
		break;
		}
	}
	
	
VOID BangProc(paob, aom)
AOB * paob;
	{
	switch (aom)
		{
	case aomMove:
		if (paob->ifr >= (paob->dx == 1 ? WRand(2) + 4 : 1 + WRand(4)))
			{
			AOB * paobT;
			
			paob->ifr = 0;
			paob->dx -= 1;
			paob->dy -= 1;
			if (paob->dx <= 0 || paob->dy <= 0)
				{
				if (WRand(256) == 0)
					{
					CreateBang((INT) (paob->x >> 16), 
						(INT) (paob->y >> 16));
					}

				paob->aot = 0;
				return;
				}
//#ifdef FOO
			if ((paobT = PaobNew(1)) != pvNil)
				{
				paobT->x = paob->x + ((LONG) WRand(0xffff) << 2);
				paobT->y = paob->y + ((LONG) WRand(0xffff) << 2);
				paobT->dx = paob->dx;
				paobT->dy = paob->dy;
				paobT->pen = paob->pen;
				paobT->dxMove = paob->dxMove + 
					(WRand(4 * 256 - 1) - 512);
				paobT->dyMove = paob->dyMove + 
					(WRand(4 * 256 - 1) - 512);
				paobT->dxAccel = 0;
				paobT->dyAccel = 256 + WRand(128);
				paobT->ifr = 0;
				}
//#endif

			paob->dxMove += 256 * (WRand(3) - 1);
			paob->dyMove += 256 * (WRand(3) - 1);
			}
			
		if (paob->dx == 1)
			paob->pen = PenRand() / 2;
		break;
		}
	}
	

VOID CreateBang(x, y)
	{
	AOB * paob;
	INT i;
	LONG lTime;
	INT cpen;
	INT rgpen [3];

	cpen = WRand(3) + 1;
	
	for (i = 0; i < cpen; i += 1)
		{
		if ((rgpen[i] = PenRand()) == penBlack)
			rgpen[i] = penWhite;
		}
	
	for (i = 1; i < 18 + WRand(5); i += 1)
		{
		if ((paob = PaobNew(1)) == pvNil)
			break;
		
		paob->x = ((LONG) (x + WRand(8) - 4) << 16);
		paob->y = ((LONG) (y + WRand(8) - 4) << 16);
		paob->dx = paob->dy = WRand(3) + 3;
#ifdef LOW_RES
		paob->dx /= 2;
		paob->dy /= 2;
#endif

		paob->pen = rgpen[WRand(cpen)];
		
		paob->dxMove = (WRand(8 * 256 - 1) - 4 * 256);
		paob->dxMove *= 3;
#ifdef LOW_RES
		paob->dxMove /= 2;
#endif

		paob->dyMove = (WRand(8 * 256 - 1) - 4 * 256);
		paob->dyMove *= 3;
#ifdef LOW_RES
		paob->dyMove /= 2;
#endif
		paob->dyAccel = 128;
		}
	}


/* This does the work of creating a new frame of video */
VOID Animate(CVS hpsUse)
	{
	INT iaob;
	AOB * paob;

	hps = hpsUse;

	paob = rgaob;
	for (iaob = 0; iaob < iaobMac; iaob += 1, paob += 1)
		{
		if (paob->aot == 0)
			continue;
		
		/* erase object */
		CallAobProc(paob, aomErase);
		switch (paob->shp)
			{
		case shpRect:
#ifdef WIN
			PatBlt(hdc, (INT) (paob->x >> 16), 
				(INT) (paob->y >> 16), 
				paob->dx, paob->dy, BLACKNESS);
#endif
#ifdef PM
			{
			RECTL rectl;
			
			rectl.xLeft = paob->x >> 16;
			rectl.yTop = dyScreen - (paob->y >> 16);
			rectl.xRight = rectl.xLeft + paob->dx;
			rectl.yBottom = rectl.yTop - paob->dy;
			WinFillRect(hps, &rectl, CLR_BLACK);
			}
#endif
			break;
			
		case shpText:
#ifdef WIN_REVIEW
			SetBkMode(hdc, TRANSPARENT);
			SetTextColor(hdc, 0L);
			TextOut(hdc, paob->x >> 16, paob->y >> 16, 
				paob->sz, strlen(paob->sz));
#endif
#ifdef PM
			/* REVIEW */
#endif
			break;
			}			

		/* move object */
		CallAobProc(paob, aomMove);
		if (paob->aot == 0)
			continue;
		paob->x += ((LONG) paob->dxMove) << 8;
		paob->y += ((LONG) paob->dyMove) << 8;
		paob->dxMove += paob->dxAccel;
		paob->dyMove += paob->dyAccel;
		paob->ifr += 1;
	
		/* draw object */
		CallAobProc(paob, aomDraw);
		switch (paob->shp)
			{
		case shpRect:
#ifdef WIN
			if (paob->dx == 1 && paob->dy == 1)
				{
				SetPixel(hdc, (INT) (paob->x >> 16), 
					(INT) (paob->y >> 16),
					mppenrgb[paob->pen]);
				}
			else
				{
				HANDLE hT;
				LOGBRUSH lbrush;
				
				lbrush.lbStyle = BS_SOLID;
				lbrush.lbColor = mppenrgb[paob->pen];
				lbrush.lbHatch = 0;
				hT = SelectObject(hdc, 
					CreateBrushIndirect(&lbrush));
				PatBlt(hdc, (INT) (paob->x >> 16), 
					(INT) (paob->y >> 16), 
					paob->dx, paob->dy, PATCOPY);
				DeleteObject(SelectObject(hdc, hT));
				}
#endif
#ifdef PM
			{
			RECTL rectl;
			
			rectl.xLeft = paob->x >> 16;
			rectl.yTop = dyScreen - (paob->y >> 16);
			rectl.xRight = rectl.xLeft + paob->dx;
			rectl.yBottom = rectl.yTop - paob->dy;
			WinFillRect(hps, &rectl, paob->pen);
			}
#endif

			break;
			
		case shpText:
#ifdef WIN_REVIEW
			SetBkMode(hdc, TRANSPARENT);
			SetTextColor(hdc, mppenrgb[paob->pen]);
			TextOut(hdc, paob->x >> 16, paob->y >> 16, 
				paob->sz, strlen(paob->sz));
#endif
#ifdef PM
			/* REVIEW */
#endif
			break;
			}
		}
	}


PenRand()
	{
	return WRand(16);
	}

	
typedef VOID (*AOBPROC)(AOB*, INT);
VOID BangProc(AOB*,INT);
VOID RocketProc(AOB*,INT);
VOID FountainProc(AOB*,INT);
VOID AshProc(AOB*,INT);

AOBPROC rgpfnAobProc[] =
	{
	BangProc,
	RocketProc,
	FountainProc,
	AshProc
	};
	

VOID CallAobProc(paob, aom)
AOB * paob;
	{
	if (paob == NULL || (INT)(paob->aot - 1) > 
	    sizeof (rgpfnAobProc) / sizeof (AOBPROC))
		return;
	(*rgpfnAobProc[paob->aot - 1])(paob, aom);
	}


VOID SecondProc(VOID)
	{
	if (WRand(100) < 30)
		{
		CreateRocket(WRand(dxScreen) / 2, 
			WRand(dyScreen) / 2);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\dropout\dropout.c ===
// "Dropout" module for IdleWild.
//
// By Tony Krueger

#ifdef PM
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
/*int _acrtused = 0;*/
#endif
#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"

#define cMovesMax	20	/* Max number of moves in one ANIMATE call */
#define cxBlockMax	32	/* Enough for 8514 */
#define cyBlockMax	24
#define FUsedXY(x, y)	rgf[x + y * cxBlock]

// Globals
INT dxScreen, dyScreen;
HDC hMemoryDC = NULL;
HBITMAP hbmpScreen = NULL;
HBITMAP hbmpBlock = NULL;
HBITMAP hbmpOld = NULL;
INT fBlock;
INT x, y, dx, dy, dyVel;
INT dxBlock, dyBlock;
INT cxBlock, cyBlock;
INT fAbove;
INT cBlockRemain;
UCHAR rgf[cxBlockMax * cyBlockMax];

INT rand();

BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Dropout";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
		lpsz = (PSZ) l2;
		lpch = "Screen Blocks\nDrop Out\n\nby Tony Krueger";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		break;
		
	case SSM_BLANK:
		{
		CVS cvs;

		ScrRestoreScreen();
		
		cvs = (CVS) l1;

		dxBlock = 32;
		dyBlock = dxBlock * GetDeviceCaps(cvs, ASPECTX) 
			/ GetDeviceCaps(cvs, ASPECTY);
		if (dyBlock <= 0)	// Assure at least one
			dyBlock = 1;

		cxBlock = (dxScreen + dxBlock - 1) / dxBlock;
		cyBlock = (dyScreen + dyBlock - 1) / dyBlock;

		// Assure number of blocks small enough
		while (cxBlock * cyBlock > cxBlockMax * cyBlockMax)
			{
			dxBlock *= 2;
			dyBlock *= 2;
			cxBlock = (dxScreen + dxBlock - 1) / dxBlock;
			cyBlock = (dyScreen + dyBlock - 1) / dyBlock;
			}

		cBlockRemain = cxBlock * cyBlock;
		for (x = 0; x < cxBlock; x++)
			for (y = 0; y < cyBlock; y++)
				FUsedXY(x, y) = fFalse;

		hMemoryDC = CreateCompatibleDC(cvs);
		hbmpScreen = CreateCompatibleBitmap(cvs, dxScreen, dyScreen);
		hbmpBlock = CreateCompatibleBitmap(cvs, dxBlock, dyBlock);

		if (hMemoryDC == NULL || hbmpScreen == NULL || hbmpBlock == NULL)
			{
			if (hMemoryDC != NULL)
				DeleteDC(hMemoryDC);
			hMemoryDC = NULL;
			if (hbmpScreen != NULL)
				DeleteObject(hbmpScreen);
			hbmpScreen = NULL;
			if (hbmpBlock != NULL)
				DeleteObject(hbmpBlock);
			hbmpBlock = NULL;
			ScrChooseRandomServer();
			}
		else
			{
			hbmpOld = SelectObject(hMemoryDC, hbmpScreen);
			BitBlt(hMemoryDC, 0, 0, dxScreen, dyScreen, cvs, 0, 0, SRCCOPY);
			}
		fBlock = fFalse;
		}
		break;

	case SSM_UNBLANK:
		if (hMemoryDC != NULL)
			{
			SelectObject(hMemoryDC, hbmpOld);
			DeleteDC(hMemoryDC);
			}
		if (hbmpScreen != NULL)
			DeleteObject(hbmpScreen);
		if (hbmpBlock != NULL)
			DeleteObject(hbmpBlock);
		break;

	case SSM_ANIMATE:
		{
		CVS cvs;

		cvs = (CVS) l1;

		if (fBlock)
			{
			INT cMoves = 0;

			while (cMoves < cMovesMax && x <= dxScreen && x >= -dxBlock)
				{
				SelectObject(hMemoryDC, hbmpBlock);
				BitBlt(cvs, x, y, dxBlock, dyBlock, hMemoryDC, 0, 0, SRCCOPY);
				SelectObject(hMemoryDC, hbmpScreen);

				dyVel += 1;

				dy = dyVel / 16;
				if (dy > 0)
					BitBlt(cvs, x, y, dxBlock, dy, hMemoryDC, x, y, SRCCOPY);
				else if (dy < 0)
					BitBlt(cvs, x, y + dyBlock + dy, dxBlock, -dy, hMemoryDC, x, y + dyBlock + dy, SRCCOPY);
				if (dx > 0)
					BitBlt(cvs, x, y, dx, dyBlock, hMemoryDC, x, y, SRCCOPY);
				else if (dx < 0)
					BitBlt(cvs, x + dxBlock + dx, y, -dx, dyBlock, hMemoryDC, x + dxBlock + dx, y, SRCCOPY);
				y += dy;
				x += dx;
				if (y >= dyScreen - dyBlock && fAbove)
					{
					dyVel = -dyVel * 3 / 4 ;
					fAbove = fFalse;
					}
				else
					fAbove = fTrue;
				cMoves++;
				}
			fBlock = (x <= dxScreen && x >= -dxBlock);
			}
		else
			{
			INT cMoves = 0;

			do
				{
				// Choose random block
				x = WRand(cxBlock);
				y = WRand(cyBlock);
				}
			while (cMoves++ < cMovesMax && FUsedXY(x, y) == fTrue);

			if (cBlockRemain <= 0 || hMemoryDC == NULL)
				{
				ScrChooseRandomServer();
				}
			else if (cMoves < cMovesMax)
				{
				FUsedXY(x, y) = fTrue;
				cBlockRemain--;

				x *= dxBlock;
				y *= dyBlock;

				// Copy original block into block bitmap
				SelectObject(hMemoryDC, hbmpBlock);
				BitBlt(hMemoryDC, 0, 0, dxBlock, dyBlock, cvs, x, y, SRCCOPY);

				// Black out block on screen
				PatBlt(cvs, x, y, dxBlock, dyBlock, BLACKNESS);
				// And on screen bitmap
				SelectObject(hMemoryDC, hbmpScreen);
				PatBlt(hMemoryDC, x, y, dxBlock, dyBlock, BLACKNESS);

				do
					{
				 	dx = WRand(5) - 2;
					dyVel = -(WRand(5) * 16);
					}
				while (dx == 0);

				fAbove = fTrue;
				fBlock = fTrue;
				}
			}

		}
		break;
		}
	
	return fTrue;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\firework\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\life\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\idlewild\idlewild.c ===
/*#define DEBUG*/
#define WEP_ABOUT	/* Use Windows Entertainment Pack standard about box*/
#define QUIT_ON_CLOSE	/* Unloads IdleWild when window is closed*/
/*#define NO_ICON	/* Eliminate running IW icon and task list line*/

#include <windows.h>
#include <port1632.h>
#include <dos.h>
#include "scrapp.h"
#include "scrsave.h"

/* REVIEW: these configuration strings probably belong in resources...*/
CHAR szAppName [] = "IdleWild";		/* Window titles, etc.*/
CHAR szNameVer [] = "IdleWild";		/* About box*/
CHAR szExt [] = "IW";			/* File name extension*/
CHAR szHelpFileName [] = "IDLEWILD.HLP";/* Name of help file*/

CHAR szMyName [] = "by Bradford Christian"; /* for about box*/


#ifdef COMMENT /* Other strings...*/

/* Messages...  (* debug version only)*/
Cannot initialize!
Illegal value!
Random
Choose a blanker at random
Blackness
Just blacks out the screen
*FInitScrSave failed!
*Cannot register IWINFO class!
*Cannot create window!
*Cannot create list or info window!


/* WIN.INI Entries...*/
BlankWith = < driver name (as it appears in list)
 > 
BlankDelay = < seconds > 
BlankMouse = < 0 or 1 > 
Directory = < path for driver file directory > 

#endif /* COMMENT*/


extern SHORT  APIENTRY FInitScrSave();
extern VOID  APIENTRY TermScrSave();

extern VOID  APIENTRY AboutWEP(HWND, HICON, LPSTR, LPSTR);

VOID WriteIniInfo();
VOID ReadIniInfo();
VOID ExecIdm();

FGetAutoLoad();
FInitApp(HINSTANCE hInstance, HINSTANCE hPrevInstance, int sw);
CmdBlankNow();
CmdIndex();
CmdQuit();
InitMenuPopup(HMENU hmenu, INT iMenu);
SelServer();
UpdList();
INT_PTR APIENTRY TimeoutProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);

HINSTANCE hInst;
HICON hicon;
MSG msg;
HWND hwndFrame, hwndList, hwndInfo, hwndDlg;
INT dyFont;
INT dxFont;
INT litRandom, litBlackness, litCur;
BOOL fWriteIni;
BOOL fAutoload;

#ifdef NO_ICON
HWND hwndApp;
#endif

MMain(hInstance, hPrevInstance, lpszCmdLine, sw) /* { */
CHAR FAR *lpch;
BOOL fBlankNow;

hInst = hInstance;
fBlankNow = FALSE;
for (lpch = lpszCmdLine; *lpch != '\0'; lpch += 1)
{
    if (*lpch == '/') {
	lpch += 1;
	if (*lpch == 's' || *lpch == 'S')
	    fBlankNow = TRUE;
    }
}



if (!fBlankNow)
{
    CHAR szExePath [128];

    WriteProfileString("windows", "ScreenSaveActive", "1");
    GetModuleFileName(hInstance, szExePath, sizeof (szExePath));
    WritePrivateProfileString("boot", "SCRNSAVE.EXE", szExePath,
        "system.ini");
}


/* If we're already running another instance, tell it come up...*/
if (hPrevInstance != NULL)
{
    HWND hwnd;

    if ((hwnd = FindWindow(
#ifdef NO_ICON
        "IWAPP",
#else
        szAppName, 
#endif
        szAppName)) != NULL) {
	SendMessage(hwnd, WM_USER, fBlankNow, 0);
	return FALSE;
    }
}



fAutoload = FGetAutoLoad();

if (fBlankNow)
{
    sw &= ~SW_SHOWNORMAL;
    sw |= SW_SHOWMINIMIZED;
}


if (!FInitApp(hInstance, hPrevInstance, sw)
)
{
    MessageBox(NULL, "Cannot initialize!", szAppName, MB_OK);
    return FALSE;
}



if (fBlankNow)
CmdBlankNow();

while (GetMessage((LPMSG) 
&msg, NULL, 0, 0)
)
{
    /* 'cause key doesn't get passed on to hwndFrame...*/
    if (msg.message == WM_KEYDOWN) {
	switch (msg.wParam) {
	case VK_RETURN:
	    CmdBlankNow();
	    break;

	case VK_F1:
	    CmdIndex();
	    break;
	}
    }

    TranslateMessage((LPMSG) & msg);
    DispatchMessage((LPMSG) & msg);
}



return (int)msg.wParam;
}


LRESULT APIENTRY WndProcInfo(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT paint;
    RECT rect;
    CHAR szDesc [256];

    switch (wm) {
    default:
	return DefWindowProc(hwnd, wm, wParam, lParam);

    case WM_LBUTTONDBLCLK:
	ScrInvokeDlg(hInst, hwndFrame);
	break;

    case WM_PAINT:
	hdc = BeginPaint(hwnd, &paint);
	rect.left = dyFont / 2;
	rect.right = dyFont * 10 - dyFont / 2;
	rect.top = dyFont / 2;
	rect.bottom = dyFont * 8 - dyFont / 2;
	if (litCur == litRandom)
	    strcpy(szDesc, "Choose a blanker at random");
	else if (litCur == litBlackness)
	    strcpy(szDesc, "Just blacks out the screen");
	else
	    ScrQueryServerDesc(szDesc);
	SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
	DrawText(hdc, szDesc, -1, &rect, 
	    DT_CENTER | DT_EXPANDTABS | DT_NOPREFIX | DT_WORDBREAK);
	EndPaint(hwnd, &paint);
	break;
    }

    return 0;
}




LRESULT APIENTRY WndProcApp(hwnd, wm, wParam, lParam)
HWND hwnd;
UINT wm;
WPARAM wParam;
LPARAM lParam;
{
#ifdef NO_ICON /* Don't ifdef whole function 'cause it's in the .DEF file*/
    switch (wm) {
    case WM_ENDSESSION:
	if (wParam)
	    TermScrSave();
	break;

    case WM_USER:
	if (wParam) {
	    CmdBlankNow();
	} else
	 {
	    SetActiveWindow(hwndFrame);
	    ShowWindow(hwndFrame, SW_SHOWNORMAL);
	}
	break;

    case WM_DESTROY:
	WinHelp(hwndFrame, szHelpFileName, HELP_QUIT, 0);
	/*		TermScrSave();*/
	break;

    default:
	return DefWindowProc(hwnd, wm, wParam, lParam);
    }

#endif

    return 0;
}


LRESULT APIENTRY WndProcSOS(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
{
    switch (wm) {
    default:
	return DefWindowProc(hwnd, wm, wParam, lParam);

    case WM_SYSCOLORCHANGE:
	InvalidateRect(hwndInfo, NULL, TRUE);
	break;

    case WM_QUERYENDSESSION:
	WriteIniInfo();
	return TRUE;

    case WM_CLOSE:
#ifdef QUIT_ON_CLOSE
	CmdQuit();
#else
	WriteIniInfo();
#ifdef NO_ICON
	ShowWindow(hwndFrame, SW_HIDE);
#else
	SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
#endif
#endif
	break;

#ifndef NO_ICON
    case WM_USER: /* User tried to start another instance...*/
	if (wParam) {
	    CmdBlankNow();
	} else
	 {
	    if (IsIconic(hwnd)) {
		SendMessage(hwnd, WM_SYSCOMMAND, 
		    SC_RESTORE, 0);
	    }

	    BringWindowToTop(hwndDlg == NULL ? hwnd : hwndDlg);
	}
	break;
#endif

    case WM_INITMENUPOPUP:
	if (HIWORD(lParam) == 0)
	    InitMenuPopup((HMENU) wParam, LOWORD(lParam));
	break;

    case WM_SETFOCUS:
	if (hwndList != NULL && hwndDlg == NULL)
	    SetFocus(hwndList);
	break;

    case WM_KEYDOWN: /* REVIEW: why doesn't this happen?*/
	if (wParam == VK_RETURN)
	    CmdBlankNow();
	break;

    case WM_COMMAND:
	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	default:
	    ExecIdm(GET_WM_COMMAND_ID(wParam, lParam));
	    break;

	case idList:
	    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
	    case LBN_DBLCLK:
		CmdBlankNow();
		break;

	    case LBN_SELCHANGE:
		InvalidateRect(hwndInfo, NULL, TRUE);
		SelServer();
		fWriteIni = TRUE;
		break;
	    }
	    break;
	}
	break;
    }

    return 0;
}



FInitApp(hInstance, hPrevInstance, sw)
HINSTANCE hInstance, hPrevInstance;
INT sw;
{
    if (hPrevInstance == NULL) {
	WNDCLASS wndc;

	wndc.style = 0;
	wndc.lpfnWndProc = WndProcSOS;
	wndc.cbClsExtra = 0;
	wndc.cbWndExtra = 0;
	wndc.hInstance = hInstance;
	wndc.hIcon = hicon = LoadIcon(hInstance, "IWICON");
	wndc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndc.hbrBackground = IntToPtr(COLOR_APPWORKSPACE + 1);
	/*CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE));*/
	wndc.lpszMenuName = "IWMENU";
	wndc.lpszClassName = szAppName;
	if (!RegisterClass(&wndc))
	    return FALSE;

#ifdef NO_ICON
	wndc.style = 0;
	wndc.lpfnWndProc = WndProcApp;
	wndc.cbClsExtra = 0;
	wndc.cbWndExtra = 0;
	wndc.hInstance = hInstance;
	wndc.hIcon = LoadIcon(hInstance, "IWICON");
	wndc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndc.hbrBackground = NULL;
	wndc.lpszMenuName = NULL;
	wndc.lpszClassName = "IWAPP";
	if (!RegisterClass(&wndc))
	    return FALSE;
#endif

	wndc.style = CS_DBLCLKS;
	wndc.lpfnWndProc = WndProcInfo;
	wndc.cbClsExtra = 0;
	wndc.cbWndExtra = 0;
	wndc.hInstance = hInstance;
	wndc.hIcon = NULL;
	wndc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndc.hbrBackground = IntToPtr(COLOR_WINDOW + 1);
	/*CreateSolidBrush(GetSysColor(COLOR_WINDOW));*/
	wndc.lpszMenuName = NULL;
	wndc.lpszClassName = "IWINFO";
	if (!RegisterClass(&wndc)) {
#ifdef DEBUG
	    MessageBox(NULL, "Cannot register IWINFO class!", szAppName,
	         MB_OK);
#endif
	    return FALSE;
	}
    }

#ifdef NO_ICON
    if ((hwndApp = CreateWindow("IWAPP", szAppName, 0, 0, 0, 1, 1,
        NULL, NULL, hInstance, NULL)) == NULL) {
#ifdef DEBUG
	MessageBox(NULL, "Cannot create app window!", szAppName, MB_OK);
#endif
	return FALSE;
    }
#endif

    if ((hwndFrame = CreateWindow(szAppName, szAppName, 
        WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU | WS_OVERLAPPED, 
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
        NULL,
        NULL, hInstance, NULL)) == NULL) {
#ifdef DEBUG
	MessageBox(NULL, "Cannot create window!", szAppName, MB_OK);
#endif
	return FALSE;
    }

    /* BLOCK: get height of system font...*/
     {
	HDC hdc;

	if ((hdc = GetDC(hwndFrame)) == NULL)
	    return FALSE;
        //NOTE: Not a typo; dxFont is the height and dyFont is the width
        //(Hey, I didn't write this thing; I just keep it from breaking the build.)
	(VOID)MGetTextExtent(hdc, "*", 1, &dyFont, &dxFont);
	ReleaseDC(hwndFrame, hdc);
    }

    hwndList = CreateWindow("LISTBOX", NULL, 
        WS_CHILD | WS_VISIBLE | LBS_STANDARD, dyFont, dyFont, 
        dyFont * 10, dyFont * 8, hwndFrame, IntToPtr(idList), hInstance, NULL);

    hwndInfo = CreateWindow("IWINFO", NULL, 
        WS_CHILD | WS_VISIBLE | WS_BORDER, dyFont * 12, dyFont, 
        dyFont * 10, dyFont * 8, hwndFrame, NULL, hInstance, NULL);

    if (hwndList == NULL || hwndInfo == NULL) {
#ifdef DEBUG
	MessageBox(NULL, "Cannot create list or info window!", szAppName,
	     MB_OK);
#endif
	return FALSE;
    }

    UpdList();

     {
	RECT rectClient, rectFrame;
	INT dx, dy;

	GetWindowRect(hwndFrame, &rectFrame);
	GetClientRect(hwndFrame, &rectClient);
	dx = ((rectFrame.right - rectFrame.left) - rectClient.right) +
	    dyFont * 23;
	dy = ((rectFrame.bottom - rectFrame.top) - rectClient.bottom) +
	    dyFont * 10;
	SetWindowPos(hwndFrame, NULL, 
	    (GetSystemMetrics(SM_CXSCREEN) - dx) / 2, 
	    (GetSystemMetrics(SM_CYSCREEN) - dy) / 2, 
	    dx, dy, SWP_NOZORDER);
    }


    if (!FInitScrSave(hInstance, hwndFrame)) {
#ifdef DEBUG
	MessageBox(NULL, "FInitScrSave failed!", szAppName, MB_OK);
#endif
	return FALSE;
    }

    ReadIniInfo();

#ifdef NO_ICON
    if (!fAutoload)
#endif
	ShowWindow(hwndFrame, sw);

    return TRUE;
}


UpdList()
{
    CHAR szScrDir [80];
    CHAR szBuf [256];
    INT cServers;
#ifdef LATER
    struct find_t ft;
    /*  BRAD I changed the get directory to get the directory the
    application is in.  This is easier for all.  Makes less of a
    setup hassle, too.
    Chris.
    */
    getcwd(szScrDir, sizeof (szScrDir));

    SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
    cServers = 0;

    wsprintf(szBuf, "%s\\*.%s", szScrDir, szExt);
    if (!_dos_findfirst(szBuf, _A_NORMAL | _A_RDONLY | _A_ARCH, &ft)) {
	do
	 {
	    wsprintf(szBuf, "%s\\%s", szScrDir, ft.name);
	    if (ScrLoadServer(szBuf)) {
		cServers += 1;
		ScrQueryServerName(szBuf);
		SendMessage(hwndList, LB_ADDSTRING, 0, 
		    (LONG) (LPSTR) szBuf);
	    }
	} while (!_dos_findnext(&ft));
    }

    litBlackness = SendMessage(hwndList, LB_ADDSTRING, 0, 
        (LONG) (LPSTR) "Blackness");

    if (cServers > 1) {
	litRandom = SendMessage(hwndList, LB_ADDSTRING, 0, 
	    (LONG) (LPSTR) "Random");

	/* Take care of "Random" appearing BEFORE "Blackness."*/
	/* (This will happen in some non-english versions...)*/
	if (litRandom <= litBlackness)
	    litBlackness += 1;
    } else
     {
	litRandom = LB_ERR;
    }

    SendMessage(hwndList, LB_SETCURSEL, 0, 0); /* REVIEW*/
#endif /* LATER */
}



INT_PTR APIENTRY TimeoutProc(hwnd, wm, wParam, lParam)
HWND hwnd;
UINT wm;
WPARAM wParam;
LPARAM lParam;
{
    WORD	cmd;

    switch (wm) {
    case WM_INITDIALOG:
	hwndDlg = hwnd;
	SetDlgItemInt(hwnd, idTimeout, ScrGetTimeout() / 60, FALSE);
	return TRUE;

    case WM_COMMAND:
	cmd = GET_WM_COMMAND_ID(wParam, lParam);
	if (cmd == idOK || cmd == idCancel) {
	    if (cmd == idOK) {
		BOOL fOK;
		INT w;

		w = GetDlgItemInt(hwnd, idTimeout, 
		    &fOK, FALSE);
		if (!fOK) {
		    MessageBox(hwnd, "Illegal value!", 
		        szAppName, 
		        MB_OK | MB_ICONEXCLAMATION);
		    SetFocus(GetDlgItem(hwnd, idTimeout));
		    return TRUE;
		}

		ScrSetTimeout(w * 60);
		fWriteIni = TRUE;
	    }

	    hwndDlg = NULL;
	    EndDialog(hwnd, TRUE);
	    return TRUE;
	}
    }

    return FALSE;
}



/* NOTE: Really CmdDeactivate()*/
CmdQuit()
{
    WinHelp(hwndFrame, szHelpFileName, HELP_QUIT, 0);
    WriteIniInfo();
    WriteProfileString("windows", "ScreenSaveActive", "0");
    TermScrSave();
    PostQuitMessage(0);
}


CmdSetTimeout()
{
    DialogBox(hInst, "Timeout", hwndFrame, TimeoutProc);
}


CmdBlankNow()
{
    SelServer();
    ScrSetIgnore(1);
    ScrBlank(TRUE);
}



SelServer()
{
    CHAR szBuf [40];

    litCur = (WORD) SendMessage(hwndList, LB_GETCURSEL, 0, 0);
    if (litCur == litRandom)
	ScrSetServer(NULL);
    else if (litCur == litBlackness)
	ScrSetServer("");
    else
     {
	SendMessage(hwndList, LB_GETTEXT, litCur, (LPARAM) szBuf);
	if (!ScrSetServer(szBuf))
	    MessageBeep(0); /* REVIEW!*/
    }
}


#ifndef WEP_ABOUT
BOOL  APIENTRY AboutProc(hwnd, wm, wParam, lParam)
HWND hwnd;
WORD wm;
WPARAM wParam;
LONG lParam;
{
    switch (wm) {
    case WM_INITDIALOG:
	hwndDlg = hwnd;
	return TRUE;

    case WM_COMMAND:
	if (GET_WM_COMMAND_ID(wParam, lParam) == idOK || 
	    GET_WM_COMMAND_ID(wParam, lParam) == idCancel) {
	    hwndDlg = NULL;
	    EndDialog(hwnd, TRUE);
	    return TRUE;
	}
	break;
    }

    return FALSE;
}


#endif

CmdAbout()
{
#ifdef WEP_ABOUT
    AboutWEP(hwndFrame, hicon, szNameVer, szMyName);
#else
    FARPROC lpproc;

    lpproc = MakeProcInstance(AboutProc, hInst);
    DialogBox(hInst, "About", hwndFrame, lpproc);
    FreeProcInstance(lpproc);
#endif
}


CmdBlankPtr()
{
    ScrEnablePtrBlank(!ScrQueryPtrBlank());
    fWriteIni = TRUE;
}


CmdBackground()
{
    ScrSetBackground(!ScrQueryBackground());
    fWriteIni = TRUE;
}


InitMenuPopup(hmenu, iMenu)
HMENU hmenu;
INT iMenu;
{
    INT imi, cmi, idm;

    cmi = GetMenuItemCount(hmenu);
    for (imi = 0; imi < cmi; imi += 1) {
	idm = GetMenuItemID(hmenu, imi);
	switch (idm) {
	case idmBlankPtr:
	    CheckMenuItem(hmenu, imi, MF_BYPOSITION | 
	        (ScrQueryPtrBlank() ? MF_CHECKED : 
	        MF_UNCHECKED));
	    break;

	case idmBackground:
	    /*EnableMenuItem(hmenu, imi, MF_BYPOSITION | MF_GRAYED); /* REVIEW: 'cause background stuff hangs!*/
	    CheckMenuItem(hmenu, imi, MF_BYPOSITION | 
	        (ScrQueryBackground() ? MF_CHECKED : 
	        MF_UNCHECKED));
	    break;

	case idmAutoload:
	    CheckMenuItem(hmenu, imi, MF_BYPOSITION | 
	        (fAutoload ? MF_CHECKED : MF_UNCHECKED));
	    break;
	}
    }
}


VOID WriteIniInfo()
{
    CHAR szBuf [80];

    if (!fWriteIni)
	return;

    SendMessage(hwndList, LB_GETTEXT, (INT)
        SendMessage(hwndList, LB_GETCURSEL, 0, 0L), (LPARAM)szBuf);
    WriteProfileString(szAppName, "BlankWith", szBuf);

    wsprintf(szBuf, "%d", ScrQueryPtrBlank());
    WriteProfileString(szAppName, "BlankMouse", szBuf);

    wsprintf(szBuf, "%d", ScrGetTimeout());
    WriteProfileString("windows", "ScreenSaveTimeOut", szBuf);

    fWriteIni = FALSE;
}


VOID ReadIniInfo()
{
    CHAR szBuf [80];

    if (GetProfileString(szAppName, "BlankWith", "", szBuf, 
        sizeof (szBuf)) > 0) {
	SendMessage(hwndList, LB_SELECTSTRING, -1, (LPARAM) szBuf);
	SelServer();
    }

    ScrSetTimeout(GetProfileInt("windows", "ScreenSaveTimeOut", 
        ScrGetTimeout()));

    ScrEnablePtrBlank(GetProfileInt(szAppName, "BlankMouse", 
        ScrQueryPtrBlank()));

    fWriteIni = FALSE;
}



CmdIndex()
{
    WinHelp(hwndFrame, szHelpFileName, HELP_INDEX, 0L);
}



CmdCommands()
{
    WinHelp(hwndFrame, szHelpFileName, HELP_CONTEXT, 3);
}



CmdHowTo()
{
    WinHelp(hwndFrame, szHelpFileName, HELP_CONTEXT, 2);
}



CmdOverview()
{
    WinHelp(hwndFrame, szHelpFileName, HELP_CONTEXT, 1);
}



FGetAutoLoad()
{
    CHAR szBuf [256];
    CHAR szExePath [128];

    GetModuleFileName(hInst, szExePath, sizeof (szExePath));
    GetProfileString("windows", "load", "", szBuf, sizeof (szBuf));
    return strstr(szBuf, szExePath) != NULL;
}



CmdAutoload()
{
    CHAR szOld [256];
    CHAR szNew [256];
    CHAR szExePath [128];

    GetModuleFileName(hInst, szExePath, sizeof (szExePath));

    GetProfileString("windows", "load", "", szOld, sizeof (szOld));

    if (fAutoload) {
	CHAR * pch;

	/* Remove from LOAD=*/
	strcpy(szNew, szOld);
	if ((pch = strstr(szNew, szExePath)) != NULL)
	    strcpy(pch, pch + strlen(szExePath));
    } else
     {
	/* Add to LOAD=*/
	wsprintf(szNew, "%s %s", szExePath, szOld);
    }

    WriteProfileString("windows", "load", 
        szNew[0] == ' ' ? szNew + 1 : szNew);

    fAutoload = !fAutoload;
}



typedef struct _cte {
    INT idm;
    INT (*pfn)();
} CTE;

CTE rgcte [] = 
{
    idmIndex, 	CmdIndex,
        idmCommands, 	CmdCommands,
        idmHowTo, 	CmdHowTo,
        idmOverview, 	CmdOverview,
        idmAbout, 	CmdAbout,
        idmSetTimeout, 	CmdSetTimeout,
        idmBlankNow, 	CmdBlankNow,
        idmBlankPtr, 	CmdBlankPtr,
        idmBackground, 	CmdBackground,
        idmQuit, 	CmdQuit,
        idmAutoload, 	CmdAutoload
};


#define icteMax (sizeof (rgcte) / sizeof (CTE))


VOID ExecIdm(INT idm)
{
    INT icte;

    for (icte = 0; rgcte[icte].idm != idm; icte += 1) {
	if (icte == icteMax - 1) {
#ifdef DEBUG
	    MessageBox(NULL, "Illegal command!", szAppName, MB_OK);
#endif
	    return;
	}
    }

    (*rgcte[icte].pfn)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\lines\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\shuffle\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\library\library.c ===
#ifdef PM
#define CSTD_WITH_OS2
#include <cstd.h>

#define INCL_WIN
#define INCL_DOS
#include <os2.h>
#endif

#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"


#ifdef PM
#define prioNormal	PRTYC_REGULAR
#define prioIdle	PRTYC_IDLETIME
INT _acrtused = 0;  // 'cause this is a DLL
#endif
#ifdef WIN
#define prioNormal	0
#define prioIdle	1
#endif



HWND hwndHook;
BOOL fDelayAction;

// Timer identifiers...
#define tidSecond	1
#define tidAnimate	2


#ifdef WIN
HHOOK lpfnSysMsgHookNext;
#endif

#ifdef PM
MRESULT APIENTRY WinProcBlanker(HWND, USHORT, MPARAM, MPARAM);
#endif

VOID APIENTRY ScrChooseRandomServer(void);

F FSendSsm(INT, LPVOID, LONG_PTR, LONG_PTR);
BOOL FDosModeHwnd(HWND hwnd);

VOID BlankScreen(F);
VOID BlankMouse(F);
VOID QuarterSecond(void);
VOID EverySecond(void);
VOID DelayAction(void);

void MoveHwndToFront(HWND hwnd);
void ShowMouse(F fShow);
void GetMousePos(LPPOINT ppt);
void InvalHwnd(HWND hwnd);
void EraseScreen(void);
void MoveHwndToBack(HWND hwnd);
void ShowHwnd(HWND hwnd, F fShow);
void SetPrio(INT prio);
VOID CopyPszToPsz(PSZ, PSZ);
INT CchLenPsz(PSZ);
VOID APIENTRY TermScrSave(void);
void StopTimer(INT tid);
void ReleaseCvs( HWND hwnd, CVS cvs);

F FAnyMouseDown(void);
CVS CvsFromHwnd(HWND);
F FStartTimer(INT, INT);

typedef struct _ssb
	{
#ifdef PM
	struct _ssb FAR * pssbNext;
#endif
#ifdef WIN
	HANDLE hssbNext;
	HMODULE hdll;
#endif
	SCRSAVEPROC lpfnSaver;
	CHAR szName [2];
	} SSB;

#define cbSSBBase (sizeof (SSB) - 2)
	
#ifdef PM
SSB FAR * pssbList = NULL;
SSB FAR * pssbCur = NULL;
#endif
#ifdef WIN
HANDLE hssbList = NULL;
HANDLE hssbCur = NULL;
#endif
INT cssbRegistered = 0;

#ifdef PM
SSB FAR * PssbFindSz(PSZ);
#endif
#ifdef WIN
HANDLE HssbFindSz(PSZ);
#endif

SCRSAVEPROC lpfnSaver;
HWND hwnd;
HWND hwndClient;
HWND hwndApp;
CVS cvs;
HAB hab; // NOTE: really an hInstance in Windows!

#ifdef WIN
BOOL fWin30 = TRUE;
#endif

UINT wmScrSave; // REVIEW: for win 3.1


#ifdef PM
SEL selHeap;
HHEAP hheap;
#endif

POINT ptMouseOld;
INT dxScreen, dyScreen;
INT csecTilReblank = 0;
INT csecIgnoreDelay = 0;
INT csecTilBlank = 0;
F fMouseHidden = fFalse;
F fScreenHidden = fFalse;
INT csecTimeout = 60 * 5; /* 5 minutes */
F fNoBlackout = fFalse;
F fRandServer = fFalse;
F fBlankPtr = fTrue;
F fBackground = fFalse;
F fInited = fFalse;

INT csecTilMouseBlank = 5;
INT csecMouseTimeout = 5;


#ifdef WIN
#ifdef WIN32
INT  APIENTRY LibMain(HANDLE hInst, ULONG ul_reason_being_called, LPVOID lpReserved) {

	UNREFERENCED_PARAMETER(ul_reason_being_called);
	UNREFERENCED_PARAMETER(lpReserved);
	UNREFERENCED_PARAMETER(hInst);
#else
int LibMain(HMODULE hModule, WORD wDataSeg, WORD cbHeap, WORD sz) {

	if (cbHeap != 0)
		(VOID)MUnlockData(0);
	
	UNREFERENCED_PARAMETER(sz);
	UNREFERENCED_PARAMETER(cbheap);
	UNREFERENCED_PARAMETER(wDataSeg);
	UNREFERENCED_PARAMETER(hModule);
#endif /* WIN32 */

	return 1;
	}
	
VOID  APIENTRY WEP(INT fSysShutdown)
	{
	UNREFERENCED_PARAMETER(fSysShutdown);
	}
#endif



#ifdef PM
VOID SetPssbCur(SSB FAR * pssb)
#endif
#ifdef WIN
VOID SetHssbCur(HANDLE hssb)
#endif
	{
	if (fScreenHidden || fBackground)
		FSendSsm(SSM_UNBLANK, cvs, 0L, 0L);
	
#ifdef PM
	pssbCur = pssb;
#endif
#ifdef WIN
	hssbCur = hssb;
#endif


	if (fScreenHidden)
		{
		InvalHwnd(hwnd);
		fNoBlackout = FSendSsm(SSM_BLANK, cvs, 0L, 0L);
		}
	else if (fBackground)
		{
		if (!FSendSsm(SSM_BLANK, cvs, 0L, 0L))
			{
			EraseScreen();
			}
		}
	}


F FSendSsm(ssm, l1, l2, l3)
INT ssm;
LPVOID l1;
LONG_PTR l2, l3;
	{
#ifdef PM
	if (pssbCur == NULL)
		return fFalse;
	return (*pssbCur->lpfnSaver)(ssm, l1, l2, l3);
#endif
#ifdef WIN
	SCRSAVEPROC lpfn;
	
	if (hssbCur == NULL)
		return fFalse;
	
	lpfn = ((SSB *) LocalLock(hssbCur))->lpfnSaver;
	LocalUnlock(hssbCur);
	
	return (*lpfn)(ssm, l1, l2, l3);
#endif
	}

	
#ifdef PM
APIENTRY BlankerHook(HAB hab, PQMSG pqmsg)
	{
	if (hwnd == NULL)
		return;
	
	switch (pqmsg->msg)
		{
	case WM_MOUSEMOVE:
		if (fMouseHidden)
			{
			POINT pt;
			
			GetCursorPos(&pt);
		
			if (pt.x != ptMouseOld.x || pt.y != ptMouseOld.y)
				BlankMouse(fFalse);
			}
		break;
			
	case WM_BUTTON1DOWN:
	case WM_BUTTON2DOWN:
	case WM_BUTTON3DOWN:
	case WM_VIOCHAR:
	case WM_CHAR:
		WinSendMsg(hwnd, WM_USER, (MPARAM) 0, (MPARAM) 0);
		break;
		}
	}
#endif


#ifdef WIN
LRESULT APIENTRY BlankerHook(INT nCode, WPARAM wParam, LPARAM lParam)
	{
	if (csecTilBlank != csecTimeout && csecIgnoreDelay == 0)
		fDelayAction = TRUE;

	return DefHookProc(nCode, wParam, lParam, 
		&lpfnSysMsgHookNext);
	}
#endif
#ifdef WIN_JOURNAL
VOID APIENTRY BlankerHook(msgf, wParam, lParam)
LONG lParam;
	{
	if (msgf >= 0)
		{
		LPEVENTMSGMSG lpevmsg;
		
		lpevmsg = (LPEVENTMSGMSG) lParam;
		
		switch (lpevmsg->message)
			{
			static POINT pt;
			
		case WM_LBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_RBUTTONDOWN:
			BlankMouse(FALSE);
			goto LDelay;
		
		case WM_MOUSEMOVE:
			GetMousePos(&pt);
			if (pt.x == ptMouseOld.x && pt.y == ptMouseOld.y)
				break;

			ptMouseOld = pt;
				
			if (fMouseHidden)
				BlankMouse(FALSE);
			
			if (csecIgnoreDelay > 0)
				break;
			/* FALL THROUGH */
		
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
LDelay:
			PostMessage(hwnd, WM_USER, 0, 0);
			break;
			}
		}

	DefHookProc(msgf, wParam, lParam, 
		 &lpfnSysMsgHookNext);
	}
#endif


BOOL FSetHwndHook(HAB hab, HWND hwnd)
	{
#ifdef PM
	HMODULE hmodule;
	
	DosGetModHandle("sos", &hmodule);
	
	hwndHook = hwnd;
	return (hwnd != NULL ? WinSetHook : WinReleaseHook)
		(hab, NULL, HK_JOURNALRECORD, BlankerHook, hmodule);
#endif
#ifdef WIN
	lpfnSysMsgHookNext = SetWindowsHook(/*WH_JOURNALRECORD*/WH_KEYBOARD, &BlankerHook);

	return TRUE;
	UNREFERENCED_PARAMETER(hab);
	UNREFERENCED_PARAMETER(hwnd);
#endif
	}


VOID APIENTRY ScrBlank(SHORT fBlank)
	{
	BlankScreen(fBlank);
	csecTilBlank = 0;
	}


VOID APIENTRY ScrSetTimeout(INT csec)
	{
	if ((csecTimeout = csec) == 0)
		csecTimeout = 60 * 5;
	}



INT APIENTRY ScrGetTimeout()
	{
	return csecTimeout;
	}


VOID APIENTRY ScrSetIgnore(SHORT csec)
	{
	csecIgnoreDelay = csec;
	}

VOID APIENTRY ScrEnablePtrBlank(INT fEnable)
	{
	fBlankPtr = fEnable;
	}


INT APIENTRY ScrQueryPtrBlank()
	{
	return fBlankPtr;
	}


VOID APIENTRY ScrSetBackground(SHORT fOn)
	{
	if (!fBackground == !fOn)
		return;
	
	fBackground = fOn;
	
	if (fOn && !fScreenHidden)
		{
		if (cvs == NULL) // if it's not NULL, something bad happend
			{
			MoveHwndToBack(hwnd);
			ShowHwnd(hwnd, fTrue);
			if ((cvs = CvsFromHwnd(hwnd)) != NULL)
				{
				if (!FSendSsm(SSM_BLANK, cvs, 0L, 0L))
					{
					EraseScreen();
					FStartTimer(tidAnimate, 0);
					SetPrio(prioIdle);
					}
				}
			}
		}
	else if (!fOn && !fScreenHidden)
		{
		if (cvs != NULL)
			{
			FSendSsm(SSM_UNBLANK, cvs, 0L, 0L);
			ReleaseCvs(hwndClient, cvs);
			cvs = NULL;
			}
			
		StopTimer(tidAnimate);
		ShowHwnd(hwnd, fFalse);
		SetPrio(prioNormal);
		}
	}


INT APIENTRY ScrQueryBackground()
	{
	return fBackground;
	}


#ifdef PM
INIT APIENTRY FInitScrSave(HAB habExe)
	{
	ULONG flFrameFlags = 0;
	
	if (hab != NULL)
		return fFalse;

	hab = habExe;
	
	if (DosAllocSeg(256, &selHeap, SEG_NONSHARED) != 0)
		return fFalse;
	
	if ((hheap = WinCreateHeap(selHeap, 256, 256, 0, 0, 0)) == NULL)
		{
		DosFreeSeg(selHeap);
		return fFalse;
		}
	
	if (!WinRegisterClass(hab, "sos", WinProcBlanker, 0L, NULL))
		{
		WinDestroyHeap(hheap);
		return fFalse;
		}

// REVIEW: I should probably be using WinCreateWindow, but I couldn't get
// it to work...
	if ((hwnd = WinCreateStdWindow(HWND_DESKTOP, WS_VISIBLE, 
	    &flFrameFlags, "sos", NULL, 0L, NULL, 1, &hwndClient)) == NULL)
		{
		WinDestroyHeap(hheap);
		return fFalse;
		}
	

	dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
	dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);

	
	// This timer ticks every second and is used for various things
	while (!WinStartTimer(hab, hwndClient, tidSecond, 1000))
		{
		if (WinMessageBox(HWND_DESKTOP, hwnd, 
		    "Too many clocks or timers!", "Screen Saver", 0, 
		    MB_ICONEXCLAMATION | MB_RETRYCANCEL) == MBID_CANCEL)
			{
			return fFalse;
			}
		}

	if (!FSetHwndHook(hab, hwndClient))
		{
		WinDestroyWindow(hwnd);
		WinDestroyHeap(hheap);
		return fFalse;
		}
	DelayAction();
	
	fInited = fTrue;
	
	return fTrue;
	}


VOID APIENTRY TermScrSave()
	{
	if (!fInited)
		return;
	
	BlankScreen(fFalse);
	FSetHwndHook(hab, NULL);
	WinDestroyWindow(hwnd);
	WinDestroyHeap(hheap);
	DosFreeSeg(selHeap);
	hab = NULL;
	fInited = fFalse;
	}


MRESULT APIENTRY WinProcBlanker(HWND hwnd, USHORT wm, MPARAM mp1, MPARAM mp2)
	{
	switch (wm)
		{
	default:
		return WinDefWindowProc(hwnd, wm, mp1, mp2);
		
	case WM_BUTTON2DOWN:
		return WinSendMsg(HWND_DESKTOP, wm, mp1, mp2);
		
	case WM_TIMER:
		if (SHORT1FROMMP(mp1) == tidSecond)
			{
			EverySecond();
			}
		else if (cvs != NULL)
			{
			FSendSsm(SSM_ANIMATE, cvs, 0L, 0L);
			}
		break;
	
	case WM_CREATE:
		WinQueryPointerPos(HWND_DESKTOP, &ptMouseOld);
		break;
		
	case WM_PAINT:
		// BLOCK
			{
			CVS cvs;
			RECTL rectl;
			
			cvs = WinBeginPaint(hwnd, NULL, &rectl);
			if (!fNoBlackout)
				WinFillRect(cvs, &rectl, CLR_BLACK);
			WinEndPaint(cvs);
			}
		break;
		
	case WM_MOUSEMOVE:
		// BLOCK
			{
			PT pt;
	
			// WM_MOUSEMOVE does not mean the mouse has moved
			WinQueryPointerPos(HWND_DESKTOP, &pt);
		
			if (pt.x == ptMouseOld.x && pt.y == ptMouseOld.y)
				{
				break;
				}
			
			csecTilMouseBlank = csecMouseTimeout;
			}
		// FALL THROUGH
		
	case WM_USER:
		// Sent by the hook when the user does something...
		if (csecIgnoreDelay == 0)
			DelayAction();
		break;
		}
	
	return (MRESULT) 0;
	}
#endif
#ifdef WIN
LRESULT APIENTRY WinProcBlanker(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	DWORD pos;
	
	switch (wm)
		{
	case WM_PAINT:
		{
		CVS cvs;
		PAINTSTRUCT paint;
		
		cvs = BeginPaint(hwnd, &paint);
		if (!fNoBlackout)
			EraseScreen();
		EndPaint(hwnd, &paint);
		}
		break;
	
	case WM_MOUSEMOVE:
		pos = GetMessagePos();
		if (ptMouseOld.x == LOWORD(pos) && 
		    ptMouseOld.y == HIWORD(pos))
			break;
		csecTilMouseBlank = csecMouseTimeout;
		/* FALL THROUGH */
		
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_USER:
		if (csecIgnoreDelay == 0)
			DelayAction();
		break;
		
	case WM_TIMER:
		if (wParam == tidSecond)
			{
			static INT iqsec;
			iqsec += 1;
			if (iqsec == 4)
				{
				iqsec = 0;
				EverySecond();
				}
			QuarterSecond();
			}
		else if (cvs != NULL)
			{
			// Ignore events for a bit after blanking to allow 
			// for key-up, mouse jiggle, etc...
			if (csecIgnoreDelay > 0)
				csecIgnoreDelay -= 1;

			BlankMouse(TRUE);
			FSendSsm(SSM_ANIMATE, cvs, 0L, 0L);
			}
		break;
		
	default:
		return DefWindowProc(hwnd, wm, wParam, lParam);
		}
	
	return 0;
	}

BOOL APIENTRY FInitScrSave(HAB habExe, HWND hwndUI) /* NOTE: hab is hInstance for Win */
	{
	WNDCLASS wndclass;
	
	if (fInited)
		{
#ifdef DEBUG
MessageBox(NULL, "Already initialized!", "IdleWild", MB_OK);
#endif
		return FALSE;
		}
		
	fWin30 = (GETMAJORVERSION(GetVersion()) == 0x0003);
		
	hwndApp = hwndUI;
	wmScrSave = RegisterWindowMessage("SCRSAVE"); // REVIEW: for win 3.1
	
	dxScreen = GetSystemMetrics(SM_CXSCREEN);
	dyScreen = GetSystemMetrics(SM_CYSCREEN);
	
	wndclass.style = 0;
	wndclass.lpfnWndProc = WinProcBlanker;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = 0;
	wndclass.hInstance = hab;
	wndclass.hIcon = NULL;
	wndclass.hCursor = NULL;
	wndclass.hbrBackground = NULL;
	wndclass.lpszMenuName = (LPSTR) 0;
	wndclass.lpszClassName = "IWBKG";
	if (!RegisterClass(&wndclass))
		{
#ifdef DEBUG
MessageBox(NULL, "Cannot register IWBKG class!", "IdleWild", MB_OK);
#endif
		return fFalse;
		}
	
	if ((hwnd = hwndClient = CreateWindow("IWBKG", NULL, WS_POPUP, 
	    -2, 0, 1, 1, NULL, NULL, hab, NULL)) == hNil)
		{
		MessageBox(NULL, "Cannot create a window!",
			"IdleWild", MB_OK);
		return fFalse;
		}
		
	while (!SetTimer(hwnd, tidSecond, 250, hNil))
		{
		if (MessageBox(hwnd, "Too many clocks or timers!",
		    "IdleWild", MB_RETRYCANCEL) == IDCANCEL)
			{
			return FALSE;
			}
		}
		
	ShowWindow(hwnd, SW_HIDE);
	SetWindowPos(hwnd, NULL, 0, 0, dxScreen, dyScreen,
		SWP_NOACTIVATE | SWP_NOZORDER);

	if (fWin30 && !FSetHwndHook(hab, hwnd))
		{
#ifdef DEBUG
MessageBox(NULL, "Cannot set hook!", "IdleWild", MB_OK);
#endif
		return FALSE;
		}

	DelayAction();
	
	fInited = fTrue;
	
	UNREFERENCED_PARAMETER(habExe);
	return TRUE;
	}
								
VOID APIENTRY TermScrSave()
	{
	HANDLE hssb, hssbNext;
	SSB * pssb;
	
	if (!fInited)
		return;

	BlankScreen(FALSE);
	if (fWin30)
		UnhookWindowsHook(WH_KEYBOARD, BlankerHook);
	DestroyWindow(hwnd);
	UnregisterClass("IWBKG", hab);
	
	for (hssb = hssbList; hssb != NULL; hssb = hssbNext)
		{
		pssb = (SSB *) LocalLock(hssb);
		FreeLibrary(pssb->hdll);
		hssbNext = pssb->hssbNext;
		LocalUnlock(hssb);
		LocalFree(hssb);
		}

	hwnd = NULL;
	hab = NULL;
	fInited = fFalse;
	}
#endif

VOID QuarterSecond()
	{
	static POINT pt;
	
	if (fDelayAction)
		{
		fDelayAction = FALSE;
		if (csecIgnoreDelay == 0)
			DelayAction();
		}
	
	GetMousePos(&pt);
	
	// Check for mouse movement...
	if (pt.x != ptMouseOld.x || pt.y != ptMouseOld.y)
		{
		BlankMouse(FALSE);
		
		if (csecIgnoreDelay == 0)
			DelayAction();
		}

	if (pt.x == dxScreen - 1)
		{
#ifdef PM
		if (pt.y == dyScreen - 1)
#endif
#ifdef WIN
		if (pt.y == 0)
#endif
			{
			// Blank the screen if mouse is moved to the
			// upper-right corner...

			BlankScreen(fTrue);
			csecTilBlank = 0;
			}
#ifdef PM
		else if (pt.y == 0)
#endif
#ifdef WIN
		else if (pt.y == dyScreen - 1)
#endif
			{
			// Disable the blanker when the mouse is in 
			// the lower-right corner...

			BlankScreen(fFalse);
			csecTilBlank = csecTimeout;
			}
		}
	
	ptMouseOld = pt;
	}
	
	
VOID EverySecond()
	{
	// Take care of mouse blanking...
	if (fBlankPtr && csecTilMouseBlank > 0 && !FAnyMouseDown())
		{
		csecTilMouseBlank -= 1;
		if (csecTilMouseBlank == 0)
			BlankMouse(TRUE);
		}
		
	// Countdown screen blank timer or send second message to blanker...
	if (fWin30 && csecTilBlank > 0)
		{
		csecTilBlank -= 1;
		
		if (csecTilBlank == 0)
			BlankScreen(fTrue);
		}
	
	if (fScreenHidden || fBackground)
		{
		if (fScreenHidden)
			MoveHwndToFront(hwnd);
		else
			MoveHwndToBack(hwnd);

		if (csecTilReblank > 0 && --csecTilReblank == 0)
			ScrChooseRandomServer();
			
		FSendSsm(SSM_SECOND, 0L, 0L, 0L);
		}
	}


VOID DelayAction()
	{
	csecTilBlank = csecTimeout;
	
	if (fScreenHidden)
		{
		if (!fBackground)
			{
			// It *should* be safe to stop the timer even if 
			// it was never started.
			StopTimer(tidAnimate);
			}
		
		BlankScreen(fFalse);
		}
	
	GetMousePos(&ptMouseOld);
	}


VOID BlankMouse(F fBlank)
	{
	if (!fBlank)
		csecTilMouseBlank = csecMouseTimeout;
	
	if (!fBlank == !fMouseHidden)
		return;

	fMouseHidden = fBlank;
	ShowMouse(!fBlank);
	}


VOID BlankScreen(F fBlank)
	{
#ifdef WIN
	if (fBlank)
		{
		HWND hwnd;
		
		hwnd = GetActiveWindow();
		if (FDosModeHwnd(hwnd) /*&& !IsIconic(hwnd)*/ || 
		    FindWindow("CbtComm", NULL))
			{
			DelayAction();
			return;
			}
		}
#endif

	BlankMouse(fBlank);
	
	if (!fBlank == !fScreenHidden)
		return;
	
	if (fBlank)
		{
		PostMessage((HWND)0xffff, wmScrSave, 1, 0); // REVIEW: for win 3.1
		
		MoveHwndToFront(hwnd);
		ShowHwnd(hwnd, fTrue);
		GetMousePos(&ptMouseOld);
		
		// If we can't get a canvas, there will be no animation...
		if (cvs == NULL && (cvs = CvsFromHwnd(hwndClient)) == NULL)
			return;
		
		SetPrio(prioIdle);

		if (fRandServer)
			ScrChooseRandomServer();
	
		fScreenHidden = fTrue;
		fNoBlackout = FSendSsm(SSM_BLANK, cvs, 0L, 0L);
		
		// Starting that timer might fail, in which case there will
		// be no animation, but the screen will still be blank...
		if (!FStartTimer(tidAnimate, 0))
			fNoBlackout = fFalse;
		
		csecIgnoreDelay = 4;
		}
	else
		{
		PostMessage((HWND)0xffff, wmScrSave, 0, 0); // REVIEW: for win 3.1

		FSendSsm(SSM_UNBLANK, cvs, 0L, 0L);
		fScreenHidden = fFalse;
		
		if (fBackground)
			{
			MoveHwndToBack(hwnd);
/*			ShowHwnd(hwnd, fTrue); /* already shown */
			}
		else
			{
			SetPrio(prioNormal);
			ShowHwnd(hwnd, fFalse);

			if (cvs != NULL)
				{
				ReleaseCvs(hwndClient, cvs);
				cvs = NULL;
				}
			}
		}
	}





BOOL APIENTRY ScrSetServer(PSZ szName)
	{
#ifdef PM
	SSB FAR * pssb;
#endif
#ifdef WIN
	HANDLE hssb;
#endif

	csecTilReblank = 0; // Disable random re-blanker for now...
	
	// Random
	if (szName == NULL)
		{
		fRandServer = fTrue;
		return fTrue;
		}
	
	
	// Blackness
	if (szName[0] == '\0')
		{
#ifdef PM
		SetPssbCur(NULL);
#endif
#ifdef WIN
		SetHssbCur(NULL);
#endif
		fRandServer = fFalse;
		
		return fTrue;
		}
	
	
	// Named server
#ifdef PM
	if ((pssb = PssbFindSz(szName)) == NULL)
		return fFalse;
	SetPssbCur(pssb);
#endif
#ifdef WIN
	if ((hssb = HssbFindSz(szName)) == NULL)
		return FALSE;
	SetHssbCur(hssb);
#endif

	fRandServer = fFalse;
	
	return fTrue;
	}


SHORT FCompPszPsz(PSZ psz1, PSZ psz2)
	{
	CHAR FAR * lpch1, FAR * lpch2;
	
	lpch1 = psz1;
	lpch2 = psz2;
	while (*lpch1 == *lpch2 && *lpch1 != '\0')
		{
		lpch1 += 1;
		lpch2 += 1;
		}
	
	return *lpch1 == '\0' && *lpch2 == '\0';
	}


#ifdef PM
SSB FAR * PssbFindSz(PSZ sz)
	{
	SSB FAR * pssb;
	
	for (pssb = pssbList; pssb != NULL; pssb = pssb->pssbNext)
		{
		if (FCompPszPsz(pssb->szName, sz))
			return pssb;
		}
	
	return NULL;
	}
#endif
#ifdef WIN
HANDLE HssbFindSz(PSZ sz)
	{
	HANDLE hssb, hssbNext;
	SSB * pssb;
	
	for (hssb = hssbList; hssb != NULL; hssb = hssbNext)
		{
		F fSame;
		
		pssb = (SSB *) LocalLock(hssb);
		fSame = FCompPszPsz(pssb->szName, sz);
		hssbNext = pssb->hssbNext;
		LocalUnlock(hssb);
		
		if (fSame)
			return hssb;
		}
	
	return NULL;
	}
#endif

#ifdef PM
SSB FAR * PssbIssb(issb)
INT issb;
	{
	SSB FAR * pssb;
	
	for (pssb = pssbList; pssb != NULL && issb-- > 0; 
	    pssb = pssb->pssbNext)
		;
	
	return pssb;
	}
#endif
#ifdef WIN
HANDLE HssbIssb(issb)
INT issb;
	{
	HANDLE hssb, hssbNext;
	SSB * pssb;
	
	for (hssb = hssbList; hssb != NULL && issb-- > 0; hssb = hssbNext)
		{
		pssb = (SSB *) LocalLock(hssb);
		hssbNext = pssb->hssbNext;
		LocalUnlock(hssb);
		}
		
	return hssb;
	}
#endif


VOID APIENTRY ScrChooseRandomServer()
	{
	csecTilReblank = csecTimeout * 4; // REVIEW: make an option?
#ifdef PM
	SetPssbCur(PssbIssb(WRand(cssbRegistered)));
#endif
#ifdef WIN
	SetHssbCur(HssbIssb(WRand(cssbRegistered)));
#endif
	}


SHORT APIENTRY ScrLoadServer(PSZ szDllName)
	{
#ifdef PM
	NPBYTE npb;
	SSB FAR * pssb;
	HMODULE hmod;
	SCRSAVEPROC lpfnSaver;
	CHAR szFailure [80];
	CHAR szName [80];
	CHAR szDesc [256];
	
	if (DosLoadModule(szFailure, sizeof (szFailure), szDllName, &hmod) != 0)
		return fFalse;
	
	if (DosGetProcAddr(hmod, "SCRSAVEPROC", &lpfnSaver) != 0)
		{
		DosFreeModule(hmod);
		return fFalse;
		}
	
	CopyPszToPsz(szDllName, szName);
	
	(*lpfnSaver)(SSM_OPEN, szName, 
		(LONG_PTR) szDesc, ((LONG) dyScreen << 16) + dxScreen);
	
	if ((npb = WinAllocMem(hheap, 
	    cbSSBBase + CchLenPsz(szName) + 1)) == NULL)
		{
		DosFreeModule(hmod);
		return fFalse;
		}
	
	pssb = (SSB FAR *) MAKEP(selHeap, npb);
	
	pssb->lpfnSaver = lpfnSaver;
	pssb->pssbNext = pssbList;
	CopyPszToPsz(szName, pssb->szName);
	
	pssbList = pssb;
	
	cssbRegistered += 1;
	
	SetPssbCur(pssb);
	
	return fTrue;
#endif
#ifdef WIN
	HMODULE hdll;
	HANDLE hssb;
	SSB * pssb;
	SCRSAVEPROC lpfnSaver;
	CHAR szName [80];
	CHAR szDesc [256];

	if ((hdll = MLoadLibrary(szDllName)) == NULL)
		{
#ifdef DEBUG
MessageBox(NULL, szDllName, "IdleWild cannot load:", MB_OK);
#endif
		return FALSE;
		}
	
	if ((lpfnSaver = (SCRSAVEPROC)GetProcAddress(hdll, "SCRSAVEPROC")) == NULL)
		{
		MessageBox(NULL, "Invalid module!", "IdleWild", MB_OK);
		FreeLibrary(hdll);
		return FALSE;
		}
	
	CopyPszToPsz(szDllName, szName);
	szDesc[0] = '\0';
	
	(*lpfnSaver)(SSM_OPEN, szName, 
		(LONG_PTR) szDesc, ((LONG) dyScreen << 16) + dxScreen);
	
	hssb = LocalAlloc(LMEM_MOVEABLE, cbSSBBase + CchLenPsz(szName) + 1 +
		CchLenPsz(szDesc) + 1);
	if (hssb == NULL)
		{
		MessageBox(NULL, "Not enough memory!", "IdleWild", MB_OK);
		FreeLibrary(hdll);
		return FALSE;
		}
		
	pssb = (SSB *) LocalLock(hssb);
	pssb->lpfnSaver = lpfnSaver;
	pssb->hdll = hdll;
	pssb->hssbNext = hssbList;
	CopyPszToPsz(szName, pssb->szName);
	CopyPszToPsz(szDesc, pssb->szName + CchLenPsz(szName) + 1);
	LocalUnlock(hssb);
	
	hssbList = hssb;
	cssbRegistered += 1;
	SetHssbCur(hssb);
	
	return TRUE;
#endif
	}

	
VOID APIENTRY ScrQueryServerDesc(PSZ szBuf)
	{
#ifdef PM
	if (fRandServer || pssbCur == NULL)
		szBuf[0] = '\0';
	else
		{
		CopyPszToPsz(pssbCur->szName + CchLenPsz(pssbCur->szName) + 1, 
			szBuf);
		}
#endif
#ifdef WIN
	if (fRandServer || hssbCur == NULL)
		szBuf[0] = '\0';
	else
		{
		SSB * pssb;
		
		pssb = (SSB *) LocalLock(hssbCur);
		CopyPszToPsz(pssb->szName + CchLenPsz(pssb->szName) + 1, 
			szBuf);
		LocalUnlock(hssbCur);
		}
#endif
	}
	

VOID APIENTRY ScrQueryServerName(PSZ szBuf)
	{
#ifdef PM
	if (pssbCur == NULL)
		szBuf[0] = '\0';
	else
		CopyPszToPsz(pssbCur->szName, szBuf);
#endif
#ifdef WIN
	if (hssbCur == NULL)
		szBuf[0] = '\0';
	else
		{
		SSB * pssb;
		
		pssb = (SSB *) LocalLock(hssbCur);
		CopyPszToPsz(pssb->szName, szBuf);
		LocalUnlock(hssbCur);
		}
#endif
	}


VOID CopyPszToPsz(PSZ pszFrom, PSZ pszTo)
	{
	CHAR FAR * lpchFrom, FAR * lpchTo;
	
	lpchFrom = pszFrom;
	lpchTo = pszTo;
	
	while ((*lpchTo++ = *lpchFrom++) != '\0')
		;
	}



INT CchLenPsz(PSZ psz)
	{
	CHAR FAR * pch;

	for (pch = psz; *pch != '\0'; pch += 1)
		;
	
	return (INT) (pch - psz);
	}

	
void GetMousePos(ppt)
LPPOINT ppt;
	{
#ifdef PM
	WinQueryPointerPos(HWND_DESKTOP, ppt);
#endif
#ifdef WIN
	GetCursorPos(ppt);
#endif
	}

	
F FStartTimer(tid, ms)
INT tid, ms;
	{
#ifdef PM
	return WinStartTimer(hab, hwndClient, tid, ms);
#endif
#ifdef WIN
	return (F)SetTimer(hwndClient, tid, ms, NULL);
#endif
	}

	
void StopTimer(INT tid)
	{
#ifdef PM
	WinStopTimer(hab, hwndClient, tid);
#endif
#ifdef WIN
	KillTimer(hwndClient, tid);
#endif
	}

void ShowHwnd(hwnd, fShow)
HWND hwnd;
F fShow;
	{
#ifdef PM
	WinShowWindow(hwnd, fShow);
#endif
#ifdef WIN
	ShowWindow(hwnd, fShow ? SW_SHOW : SW_HIDE);
#endif
	}

	
void MoveHwndToFront(hwnd)
HWND hwnd;
	{
#ifdef PM
	WinSetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_ZORDER);
#endif
#ifdef WIN
	SetWindowPos(hwnd, (HWND) 0, 0, 0, 0, 0, 
		SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#endif
	}
	
void MoveHwndToBack(hwnd)
HWND hwnd;
	{
#ifdef PM
	WinSetWindowPos(hwnd, HWND_BOTTOM, 0, 0, 0, 0, SWP_ZORDER);
#endif
#ifdef WIN
	SetWindowPos(hwnd, (HWND) 1, 0, 0, 0, 0, 
		SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#endif
	}
	
CVS CvsFromHwnd(hwnd)
HWND hwnd;
	{
#ifdef PM
	return WinGetPS(hwnd);
#endif
#ifdef WIN
	return GetDC(hwnd);
#endif
	}

void ReleaseCvs(hwnd, cvs)
HWND hwnd;
CVS cvs;
	{
#ifdef PM
	WinReleasePS(cvs);
#endif
#ifdef WIN
	ReleaseDC(hwnd, cvs);
#endif
	}

void InvalHwnd(hwnd)
HWND hwnd;
	{
#ifdef PM
	WinInvalidateRect(hwnd, NULL, TRUE);
#endif
#ifdef WIN
	InvalidateRect(hwnd, NULL, FALSE);
#endif
	}

void EraseScreen()
	{
#ifdef PM
	RECTL rectl;

	rectl.xLeft = 0;
	rectl.yBottom = 0;
	rectl.xRight = dxScreen;
	rectl.yTop = dyScreen;
	WinFillRect(cvs, &rectl, CLR_BLACK);
#endif
#ifdef WIN
	PatBlt(cvs, 0, 0, dxScreen, dyScreen, BLACKNESS);
#endif
	}


void SetPrio(INT prio)
	{
#ifdef PM
	DosSetPrty(PRTYS_PROCESS, prio, 0, 0);
#else
	UNREFERENCED_PARAMETER(prio);
#endif
	}


F FAnyMouseDown()
	{
#ifdef PM
	return (WinGetKeyState(HWND_DESKTOP, VK_BUTTON1) & 0x8000) != 0 ||
		(WinGetKeyState(HWND_DESKTOP, VK_BUTTON2) & 0x8000) != 0 ||
		(WinGetKeyState(HWND_DESKTOP, VK_BUTTON3) & 0x8000) != 0;
#endif
#ifdef WIN
	return (GetKeyState(VK_LBUTTON) & 0x8000) != 0 ||
		(GetKeyState(VK_MBUTTON) & 0x8000) != 0 ||
		(GetKeyState(VK_RBUTTON) & 0x8000) != 0;
#endif	
	}

void ShowMouse(fShow)
	F fShow;
	{
#ifdef PM
	WinShowPointer(HWND_DESKTOP, fShow);
#endif
#ifdef WIN
	ShowCursor(fShow);
#endif
	}

	
#ifdef WIN
VOID APIENTRY ScrInvokeDlg(HANDLE hInst, HWND hwnd)
	{
	FSendSsm(SSM_DIALOG, hInst, (LONG_PTR) hwnd, 0L);
	}
#endif


#ifdef WIN
BOOL FDosModeHwnd(HWND hwnd)
	{
#ifdef YUCKY
	extern BOOL  APIENTRY IsWinOldAppTask(HANDLE);
	
	if (GETMAJORVERSION(GetVersion()) == 0x0003)
#endif
		return FALSE;
#ifdef YUCKY
	return IsWinOldAppTask(GetWindowTask(hwnd));
#endif
	
#ifdef YUCKY
	HMENU hmenu;
	INT iItem, cItems;
	BOOL fFoundPopup;
	
	hmenu = GetSystemMenu(hwnd, FALSE);
	cItems = GetMenuItemCount(hmenu);
	fFoundPopup = FALSE;
	
	for (iItem = 0; iItem < cItems; iItem += 1)
		{
		if (GetSubMenu(hmenu, iItem) != NULL)
			{
			fFoundPopup = TRUE;
			break;
			}
		}
		
	return fFoundPopup;
#endif
	UNREFERENCED_PARAMETER(hwnd);
	}
#endif


INT APIENTRY RestoreEnumProc(HWND hwnd, LPARAM lParam)
	{
	UpdateWindow(hwnd);
	UNREFERENCED_PARAMETER(lParam);
	return TRUE;
	}
	

VOID APIENTRY ScrRestoreScreen()
	{
	ShowHwnd(hwnd, fFalse);
	EnumWindows(RestoreEnumProc, 0);
	ShowHwnd(hwnd, fTrue);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\stars\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\library\rnd.c ===
#include <windows.h>
#include <port1632.h>
#include "../scrsave.h"

WORD	rand(void);

static LONG a = 1234567;



VOID  APIENTRY SeedRand(LONG l)
	{
	a = l;
	}

	
SHORT APIENTRY WRand(w)
UINT w;
	{
	WORD x = rand() & 0x7fff;

	if (w == 0)
		return 0;
	return x % w;
	}

#define m 100000000L
#define m1 10000L
#define b 31415821L


LONG mult(LONG p, LONG q)
	{
	LONG p1, p0, q1, q0;
	
	p1 = p / m1;
	p0 = p % m1;
	q1 = q / m1;
	q0 = q & m1;
	return (((p0 * q1 + p1 * q0) % m1) * m1 + p0 * q0) % m;
	}


WORD rand()
	{
	a = (mult(a, b) + 1) % m;
	return (WORD) (a >> 8);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\wipe\nulwep.c ===
#include <windows.h>
#include <port1632.h>

VOID  APIENTRY WEP(INT fSysShutdown)
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\life\life.c ===
#ifdef PM
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
INT _acrtused = 0;
#endif

#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"


#ifdef WIN
LONG mppenrgb [] =
	{
	RGB(0x00, 0x00, 0x00),
	RGB(0x00, 0x00, 0x80),
	RGB(0x00, 0x80, 0x00),
	RGB(0x00, 0x80, 0x80),
	RGB(0x80, 0x00, 0x00),
	RGB(0x80, 0x00, 0x80),
	RGB(0x80, 0x80, 0x00),
	RGB(0x80, 0x80, 0x80),
	RGB(0xc0, 0xc0, 0xc0),
	RGB(0x00, 0x00, 0xff),
	RGB(0x00, 0xff, 0x00),
	RGB(0x00, 0xff, 0xff),
	RGB(0xff, 0x00, 0x00),
	RGB(0xff, 0x00, 0xff),
	RGB(0xff, 0xff, 0x00),
	RGB(0xff, 0xff, 0xff)
	};

#define CLR_BLACK	0
#define CLR_BACKGROUND	0
#endif


#define MultDiv(a, b, c)  ((int) (((long) (a) * (long) (b)) / (c)))


INT dxScreen, dyScreen;

#define dxcMax 80
#define dycMax 50

typedef UCHAR GRID [dxcMax][dycMax];

GRID gridOld, gridNew;
BOOL fRedraw;
INT csecRandomize;


VOID SetCell(CVS hps, GRID grid, INT dxc, INT dyc, INT clr);
VOID Redraw(CVS hps);
Randomize();
Animate(CVS hps);
ClrAverage(GRID grid, INT dxc, INT dyc);


BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return FALSE;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Life";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
		lpsz = (PSZ) l2;
		lpch = "Life in Color\n\nby Brad Christian";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		// FALL THROUGH
			
	case SSM_SECOND:
		if (--csecRandomize < 0)
			{
			Randomize();
			csecRandomize = 60 + WRand(120);
			}
		break;
		
	case SSM_BLANK:
		Randomize();
		fRedraw = TRUE;
		break;
		
	case SSM_ANIMATE:
		{
		static INT foo;
		if (foo++ & 1)
			return TRUE;
		}
		
		if (GetInputState())
			return TRUE;
		
		if (fRedraw)
			{
			Redraw((CVS) l1);
			if (fRedraw)
				return TRUE;
			}
		
		Animate((CVS) l1);
		break;
		}
	
	return TRUE;
	}


Randomize()
	{
	INT dxc, dyc;
	
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
			gridOld[dxc][dyc] = CLR_BACKGROUND << 4;
			}
		}
	
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
			if (WRand(10) < 5)
				SetCell(NULL, gridOld, dxc, dyc, WRand(16));
			}
		}
	
	fRedraw = TRUE;
	}


VOID Redraw(CVS hps)
	{
	INT dxc, dyc;
		
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		if (GetInputState())
			return;
		
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
#ifdef PM
			RECTL rectl;
			LONG clr;
			
			rectl.xLeft = MultDiv(dxc, dxScreen, dxcMax);
			rectl.xRight = MultDiv(dxc + 1, dxScreen, dxcMax);
			rectl.yBottom = MultDiv(dyc, dyScreen, dycMax);
			rectl.yTop = MultDiv(dyc + 1, dyScreen, dycMax);
			
			if ((clr = gridOld[dxc][dyc] >> 4) == CLR_BACKGROUND)
				clr = CLR_BLACK;
			WinFillRect(hps, &rectl, clr);
#endif
#ifdef WIN
			HANDLE hT;
			LOGBRUSH lbrush;
			INT clr, x, y;
			
			if ((clr = gridOld[dxc][dyc] >> 4) == CLR_BACKGROUND)
				clr = CLR_BLACK;
			lbrush.lbStyle = BS_SOLID;
			lbrush.lbColor = mppenrgb[clr];
			lbrush.lbHatch = 0;
			hT = SelectObject(hps,
				CreateBrushIndirect(&lbrush));
			x = MultDiv(dxc, dxScreen, dxcMax);
			y = MultDiv(dyc, dyScreen, dycMax);
			PatBlt(hps, x, y, 
				MultDiv(dxc + 1, dxScreen, dxcMax) - x,
				MultDiv(dyc + 1, dyScreen, dycMax) - y,
				PATCOPY);
			DeleteObject(SelectObject(hps, hT));
#endif
			}
		}

	fRedraw = FALSE;
	}


Animate(CVS hps)
	{
	INT dxc, dyc;
	INT c;
	
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
			gridNew[dxc][dyc] = gridOld[dxc][dyc];
			}
		}
	
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
			c = gridOld[dxc][dyc] & 0x0f;
			
			if ((gridOld[dxc][dyc] >> 4) != CLR_BACKGROUND)
				{
				if (c < 2 || c > 3)
					{
					SetCell(hps, gridNew, dxc, dyc, 
						CLR_BACKGROUND);
					}
				}
			else
				{
				if (c == 3)
					{
					SetCell(hps, gridNew, dxc, dyc, 
						ClrAverage(gridOld, dxc, dyc));
					}
				}
			}
		}
	
	for (dyc = 0; dyc < dycMax; dyc += 1)
		{
		for (dxc = 0; dxc < dxcMax; dxc += 1)
			{
			gridOld[dxc][dyc] = gridNew[dxc][dyc];
			}
		}
	}



// Boy, this is ugly!  Find the average color around cell [dxc][dyc]...

ClrAverage(GRID grid, INT dxc, INT dyc)
	{
	INT c, clr, clrT;
	
	c = clr = 0;
	
	if (dxc > 0)
		{
		if ((clrT = grid[dxc - 1][dyc] >> 4) != 0)
			{
			clr += clrT;
			c += 1;
			}
		
		if (dyc > 0)
			{
			if ((clrT = grid[dxc - 1][dyc - 1] >> 4) != 0)
				{
				clr += clrT;
				c += 1;
				}
			}
		
		if (dyc < dycMax - 1)
			{
			if ((clrT = grid[dxc - 1][dyc + 1] >> 4) != 0)
				{
				clr += clrT;
				c += 1;
				}
			}
		}
	
	if (dyc > 0)
		{
		if ((clrT = grid[dxc][dyc - 1] >> 4) != 0)
			{
			clr += clrT;
			c += 1;
			}
		}
	
	if (dyc < dycMax - 1)
		{
		if ((clrT = grid[dxc][dyc + 1] >> 4) != 0)
			{
			clr += clrT;
			c += 1;
			}
		}
	
	if (dxc < dxcMax - 1)
		{
		if ((clrT = grid[dxc + 1][dyc] >> 4) != 0)
			{
			clr += clrT;
			c += 1;
			}
		
		if (dyc > 0)
			{
			if ((clrT = grid[dxc + 1][dyc - 1] >> 4) != 0)
				{
				clr += clrT;
				c += 1;
				}
			}
		
		if (dyc < dycMax - 1)
			{
			if ((clrT = grid[dxc + 1][dyc + 1] >> 4) != 0)
				{
				clr += clrT;
				c += 1;
				}
			}
		}
	
	return clr / c;
	}



VOID SetCell(CVS hps, GRID grid, INT dxc, INT dyc, INT clr)
	{
	INT d, clrPrev;
	
	clrPrev = grid[dxc][dyc] >> 4;
	
	if (clr == clrPrev)
		return;
	
	grid[dxc][dyc] &= 0x0f;
	grid[dxc][dyc] |= clr << 4;
	
	if (hps != NULL)
		{
#ifdef PM
		RECTL rectl;
		
		rectl.xLeft = MultDiv(dxc, dxScreen, dxcMax);
		rectl.xRight = MultDiv(dxc + 1, dxScreen, dxcMax);
		rectl.yBottom = MultDiv(dyc, dyScreen, dycMax);
		rectl.yTop = MultDiv(dyc + 1, dyScreen, dycMax);
		
		WinFillRect(hps, &rectl, 
			(clr == CLR_BACKGROUND ? CLR_BLACK : (LONG) clr));
#endif
#ifdef WIN
		HANDLE hT;
		LOGBRUSH lbrush;
		INT x, y;
		
		if (clr == CLR_BACKGROUND)
			clr = CLR_BLACK;
		lbrush.lbStyle = BS_SOLID;
		lbrush.lbColor = mppenrgb[clr];
		lbrush.lbHatch = 0;
		hT = SelectObject(hps,
			CreateBrushIndirect(&lbrush));
		x = MultDiv(dxc, dxScreen, dxcMax);
		y = MultDiv(dyc, dyScreen, dycMax);
		PatBlt(hps, x, y,
			MultDiv(dxc + 1, dxScreen, dxcMax) - x,
			MultDiv(dyc + 1, dyScreen, dycMax) - y,
			PATCOPY);
		DeleteObject(SelectObject(hps, hT));
#endif
		}

	if ((clrPrev == CLR_BACKGROUND) == (clr == CLR_BACKGROUND))
		return;
	
	d = clr > 0 ? 1 : -1;
	
	if (dxc > 0)
		{
		grid[dxc - 1][dyc] += (UCHAR)d;
		
		if (dyc > 0)
			grid[dxc - 1][dyc - 1] += (UCHAR)d;
		
		if (dyc < dycMax - 1)
			grid[dxc - 1][dyc + 1] += (UCHAR)d;
		}
	
	if (dyc > 0)
		grid[dxc][dyc - 1] += (UCHAR)d;
	
	if (dyc < dycMax - 1)
		grid[dxc][dyc + 1] += (UCHAR)d;
	
	if (dxc < dxcMax - 1)
		{
		grid[dxc + 1][dyc] += (UCHAR)d;
		
		if (dyc > 0)
			grid[dxc + 1][dyc - 1] += (UCHAR)d;
		
		if (dyc < dycMax - 1)
			grid[dxc + 1][dyc + 1] += (UCHAR)d;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\lines\lines.c ===
#ifdef PM
#include <cstd.h>
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
INT _acrtused = 0;
#endif
#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"

typedef LONG CLR;

InitLines();
Animate(CVS hps);

#ifdef WIN
LONG mppenclr [] =
	{
	RGB(0x00, 0x00, 0x00),
	RGB(0x00, 0x00, 0x80),
	RGB(0x00, 0x80, 0x00),
	RGB(0x00, 0x80, 0x80),
	RGB(0x80, 0x00, 0x00),
	RGB(0x80, 0x00, 0x80),
	RGB(0x80, 0x80, 0x00),
	RGB(0x80, 0x80, 0x80),
	RGB(0xc0, 0xc0, 0xc0),
	RGB(0x00, 0x00, 0xff),
	RGB(0x00, 0xff, 0x00),
	RGB(0x00, 0xff, 0xff),
	RGB(0xff, 0x00, 0x00),
	RGB(0xff, 0x00, 0xff),
	RGB(0xff, 0xff, 0x00),
	RGB(0xff, 0xff, 0xff)
	};

#define CLR_BLACK	0
#endif


WORD PenRand();
VOID DrawLine(CVS cvs, INT x1, INT y1, INT x2, INT y2, CLR clr);


INT dxScreen, dyScreen;
CVS cvs;


BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Dancing Lines";
		while ((*lpsz++ = *lpch++) != '\0')
			;

		lpsz = (PSZ) l2;
		lpch = "Colored line patterns\n\nby Brad Christian";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		break;
		
	case SSM_BLANK:
		InitLines();
		return fFalse;
		
	case SSM_ANIMATE:
		Animate((CVS) l1);
		break;
		}
	
	return fTrue;
	}


#define ilinMax 10

typedef struct _lin
	{
	INT x1, y1, x2, y2;
	} LIN;
	
	
typedef struct _qix
	{
	INT x, y, x2, y2;
	INT dx1, dy1, dx2, dy2;
	INT pen;
	LIN rglin [ilinMax];
	INT ilinCur;
	INT cfrCycle;
	INT ifrCycle;
	} QIX;
	

#define iqixMax 4

QIX rgqix [iqixMax];


InitLines()
	{
	QIX * pqix;
	INT iqix;
	
	for (iqix = 0; iqix < iqixMax; iqix += 1)
		{
		pqix = &rgqix[iqix];
		
		pqix->x = WRand(dxScreen);
		pqix->y = WRand(dyScreen);
		pqix->x2 = WRand(dxScreen);
		pqix->y2 = WRand(dyScreen);
		
		pqix->dx1 = 3 * (WRand(20) - 10);
		pqix->dy1 = 3 * (WRand(20) - 10);
		pqix->dx2 = 3 * (WRand(20) - 10);
		pqix->dy2 = 3 * (WRand(20) - 10);
		pqix->pen = PenRand();
		pqix->cfrCycle = WRand(100) + 1;
		pqix->ifrCycle = 0;
		pqix->ilinCur = 0;
		}
	}


Animate(CVS hps)
	{
	INT ilin;
	INT iqix;
	PT pt;
	QIX * pqix;
	
	for (iqix = 0; iqix < iqixMax; iqix += 1)
		{
		LIN * plin;
		pqix = &rgqix[iqix];
		
		ilin = (pqix->ilinCur + 1) % ilinMax;
		plin = &pqix->rglin[ilin];
		
		DrawLine(hps, plin->x1, plin->y1, plin->x2, plin->y2, 
			CLR_BLACK);

		pqix->x += pqix->dx1;
		if (pqix->x < 0 || pqix->x >= dxScreen)
			{
			pqix->dx1 = -pqix->dx1;
			pqix->x += 2 * pqix->dx1;
			}

		pqix->y += pqix->dy1;
		if (pqix->y < 0 || pqix->y >= dyScreen)
			{
			pqix->dy1 = -pqix->dy1;
			pqix->y += 2 * pqix->dy1;
			}

		pqix->x2 += pqix->dx2;
		if (pqix->x2 < 0 || pqix->x2 >= dxScreen)
			{
			pqix->dx2 = -pqix->dx2;
			pqix->x2 += 2 * pqix->dx2;
			}

		pqix->y2 += pqix->dy2;
		if (pqix->y2 < 0 || pqix->y2 >= dyScreen)
			{
			pqix->dy2 = -pqix->dy2;
			pqix->y2 += 2 * pqix->dy2;
			}
#ifdef PM
		DrawLine(hps, pqix->x, pqix->y, pqix->x2, pqix->y2, 
			pqix->pen);
#endif
#ifdef WIN
		DrawLine(hps, pqix->x, pqix->y, pqix->x2, pqix->y2, 
			mppenclr[pqix->pen]);
#endif
		pqix->rglin[pqix->ilinCur].x1 = pqix->x;
		pqix->rglin[pqix->ilinCur].y1 = pqix->y;
		pqix->rglin[pqix->ilinCur].x2 = pqix->x2;
		pqix->rglin[pqix->ilinCur].y2 = pqix->y2;

		pqix->ilinCur += 1;
		if (pqix->ilinCur == ilinMax)
			pqix->ilinCur = 0;

		if (++pqix->ifrCycle >= pqix->cfrCycle)
			{
			pqix->ifrCycle = 0;
			pqix->pen += 1;
			if (pqix->pen == 16)
				pqix->pen = 0;
			}
		}
	}



WORD PenRand()
	{
	return WRand(16);
	}


VOID DrawLine(CVS cvs, INT x1, INT y1, INT x2, INT y2, CLR clr)
	{
#ifdef PM
	PT pt;

	GpiSetColor(cvs, clr);
	pt.x = x1;
	pt.y = y1;
	GpiMove(cvs, &pt);
	pt.x = x2;
	pt.y = y2;
	GpiLine(cvs, &pt);
#endif
#ifdef WIN
	HANDLE hPrev;

	hPrev = SelectObject(cvs, CreatePen(PS_SOLID, 1, clr));
	(VOID)MMoveTo(cvs, x1, y1);
	LineTo(cvs, x2, y2);
	DeleteObject(SelectObject(cvs, hPrev));
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\wipe\wipe.c ===
#ifdef PM
#include <cstd.h>
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
INT _acrtused = 0;
#endif
#ifdef WIN
#include <windows.h>
#include <port1632.h>

#endif

#include "std.h"
#include "scrsave.h"



INT rand();

INT dxScreen, dyScreen;


#define wtDown	0
#define wtUp	1
#define wtLeft	2
#define wtRight	3
#define wtIn	4
#define wtOut	5

#define wtMax	6

INT wt;
INT x, y;


BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	BOOL fDone = FALSE;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Wipe Out";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
		lpsz = (PSZ) l2;
		lpch = "Various Wipes, then Random\n\nby Brad Christian";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		break;
		
	case SSM_BLANK:
		switch (wt = WRand(wtMax))
			{
		case wtDown:
			y = dyScreen;
			break;
			
		case wtUp:
			y = 0;
			break;
			
		case wtLeft:
			x = dxScreen;
			break;
			
		case wtRight:
			x = 0;
			break;
			
		case wtIn:
			x = 0;
			y = 0;
			break;
			
		case wtOut:
			x = dxScreen / 2;
			y = dyScreen / 2;
			break;
			}
		break;
		
	case SSM_ANIMATE:
		{
		RECT rect;
		
		switch (wt)
			{
		case wtDown:
			if (y <= 0)
				fDone = TRUE;
			
			rect.left = 0;
			rect.right = dxScreen;
			rect.top = y;
			rect.bottom = y - 16;
			y -= 16;
			break;
			
		case wtUp:
			if (y >= dyScreen - 1)
				fDone = TRUE;

			rect.left = 0;
			rect.right = dxScreen;
			rect.top = y + 16;
			rect.bottom = y;
			y += 16;
			break;
			
		case wtLeft:
			if (x <= 0)
				fDone = TRUE;

			rect.left = x;
			rect.right = x + 16;
			rect.top = dyScreen;
			rect.bottom = 0;
			x -= 16;
			break;
			
		case wtRight:
			if (x >= dxScreen - 1)
				fDone = TRUE;

			rect.left = x;
			rect.right = x + 16;
			rect.top = dyScreen;
			rect.bottom = 0;
			x += 16;
			break;
			
		case wtIn:
			fDone = fTrue; // REVIEW
			break;
			
		case wtOut:
			if (x <= 0 && y <= 0)
				fDone = TRUE;

			rect.left = x;
			rect.right = dxScreen - x;
			rect.bottom = y;
			rect.top = dyScreen - y;
			x -= 8;
			y -= 8;
			break;
			}

#ifdef PM
		WinFillRect((HPS) l1, &rect, CLR_BLACK);
#endif
#ifdef WIN
		PatBlt((HDC) l1, rect.left, rect.top, 
			rect.right - rect.left, 
			rect.bottom - rect.top, BLACKNESS);
#endif
		if (fDone)
			ScrChooseRandomServer();
		}
		break;
		}
	
	return fTrue;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\oldtp\tp.h ===
#define IDNULL        -1
/* String table constants */
#define IDSNAME     100
#define IDSTITLE    300

/* dialog box resource id's */

#define ABOUTBOX	1
#define SELECTGAME	2
#define TILEHELP	3
#define PEEK		4

/* menu values */

#define IDDNEWGAME	11
#define IDDHINT		12
#define IDDSTARTOVER	13
#define IDDBACKUP	14
#define IDDAUTOPLAY	15
#define IDDSELECTGAME	16
#define IDDHOWTOPLAY	21
#define IDDTILES	22
#define IDDSTRATEGY	23
#define IDDCOLOR	24
#define IDDSHADDUP	25
#define IDDLIGHTEN	26
#define IDDDARKEN	27
#define IDDPEEK		28
#define IDDBEGINNER	30
#define IDDINTERMEDIATE	31
#define IDDEXPERT	32
#define IDDMASTER	33
#define IDMABOUT	34

#define IDGAMENUMBER	0

/* TILEHELP dialog values */
#define	IDCRAKS		200
#define	IDDOTS		201
#define	IDBAMS		202
#define	IDDRAGONS	203
#define	IDSEASONS	204
#define	IDFLOWERS	205
#define	IDWINDS		206
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\shuffle\shuffle.c ===
// "Shuffle" module for IdleWild.
//
// Blts a pattern over the screen (to "darken" it), then
// divides the screen into blocks and shuffles them around.
//
// By Tony Krueger

#ifdef PM
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
/*int _acrtused = 0;*/
#endif
#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"


INT rand();

INT dxScreen, dyScreen;
INT xBlock, yBlock;
INT xBlockMax, yBlockMax;
INT dx, dy, dir, lastOppDirection = 0;
INT xBlockSize, yBlockSize;

#define ROP_PANDD		(DWORD)0x00A000C9	/* dest = pattern AND dest */
#define ROP_INVPANDD	(DWORD)0x000A0329	/* dest = ~pattern AND dest */

typedef WORD BMP[8];	/* Monochrome brush-sized bitmap is 8 words */

#define stdchance		2	/* One in 2 times only pick from standard bmps */
#define ibmpStdMax	5
#define ibmpMax		17
BMP rgbmp[ibmpMax] = 
	{
	{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 },	/* Dither 1x1 */
	{ 0x33, 0xCC, 0x33, 0xCC, 0x33, 0xCC, 0x33, 0xCC },	/* Dither 2x1 */
	{ 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 },	/* Horiz stripe */
	{ 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00 },	/* Vert stripe */
	{ 0x88, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44 },	/* Slash */

	{ 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC },	/* Dither 2x2 */
	{ 0xFF, 0x0C, 0x0C, 0x0C, 0xFF, 0xC0, 0xC0, 0xC0 },	/* Brick */
	{ 0x38, 0x7C, 0xEE, 0xC6, 0xEE, 0x7C, 0x38, 0x00 },	/* Small Hollow Circle */
	{ 0x38, 0x7C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x00 },	/* Small Circle */
	{ 0xF8, 0xF1, 0xE3, 0xC7, 0x8F, 0x1F, 0x3E, 0x7C },	/* Thick Slash */

	{ 0xF8, 0xF1, 0xE3, 0xC7, 0x8F, 0xC7, 0xE3, 0xF1 },	/* Thick ZigZag */
	{ 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x3F, 0x7F },	/* Tile edge */
	{ 0xF8, 0x74, 0x22, 0x47, 0x8F, 0x17, 0x22, 0x71 },	/* Thatch */
	{ 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xF0 },	/* Waffle */
	{ 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x00, 0x00 },	/* Small Solid Box */

	{ 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00 },	/* Solid Diamond */
	{ 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0, 0x0F, 0xF0 },	/* Dither 4x1 */
	};

/* Pick new direction */
/* Don't move back onto square just vacated */
/* Also don't move off screen */
VOID GetDxDy()
	{
	INT xNew, yNew, oppDir;

	do
		{
		dir = WRand(4);
		switch(dir)
			{
			case 0:	/* Left */
				dx = -1;
				dy = 0;
				oppDir = 1;
				break;
			case 1:	/* Right */
				dx = 1;
				dy = 0;
				oppDir = 0;
				break;
			case 2:	/* Up */
				dx = 0;
				dy = 1;
				oppDir = 3;
				break;
			case 3:	/* Down */
				dx = 0;
				dy = -1;
				oppDir = 2;
				break;
			}
		xNew = xBlock + dx;
		yNew = yBlock + dy;
		}
	while (dir == lastOppDirection || xNew < 0 || xNew >= xBlockMax ||
			yNew < 0 || yNew >= yBlockMax);
	lastOppDirection = oppDir;
	}

BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	static INT csecReblank;
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Shuffle";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
		lpsz = (PSZ) l2;
		lpch = "Divide and\nShuffle Screen\n\nby Tony Krueger";
		while ((*lpsz++ = *lpch++) != '\0')
			;
		
#ifdef PM
		dxScreen = WinQuerySysValue(HWND_DESKTOP, SV_CXSCREEN);
		dyScreen = WinQuerySysValue(HWND_DESKTOP, SV_CYSCREEN);
#endif
#ifdef WIN
		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
#endif
		break;
		
	case SSM_BLANK:
		{
		CVS cvs;
		HBITMAP hbmp;
		HBRUSH hbr, hbrOld;
		HPEN hpenOld;
		INT x, y;
		
		ScrRestoreScreen();

		cvs = (CVS) l1;

		csecReblank = 60 * 20;

#ifdef DARKEN
		/* Darken screen */

		hbmp = NULL;
		hbr = NULL;

		/*hbmp = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++(8, 8, 1, 1, (LPSTR) &(rgbmp[ */
		hbmp = CreateBitmap(8, 8, 1, 1, (LPSTR) &(rgbmp[
			WRand(stdchance) ? WRand(ibmpMax) : WRand(ibmpStdMax)]));
		if (hbmp == NULL)
			goto LFail;

		hbr = CreatePatternBrush(hbmp);
		if (hbr == NULL)
			goto LFail;

		hbrOld = SelectObject(cvs, hbr);
		PatBlt(cvs, 0, 0, dxScreen, dyScreen, 
			WRand(2) ? ROP_PANDD : ROP_INVPANDD);
		SelectObject(cvs, hbrOld);

LFail:
		if (hbmp != NULL)
			DeleteObject(hbmp);
		if (hbr != NULL)
			DeleteObject(hbr);
#endif

		/* Select and Blacken random block */

		xBlockSize = 24 + 8*WRand(10);
		yBlockSize = xBlockSize * GetDeviceCaps(cvs, ASPECTX) 
			/ GetDeviceCaps(cvs, ASPECTY);
		yBlockSize = ((yBlockSize + 4) / 8) * 8;	/* Round to nearest 8 */
		if (yBlockSize == 0)	/* Assure a minimum */
			yBlockSize = 8;

		xBlockMax = dxScreen / xBlockSize;
		yBlockMax = dyScreen / yBlockSize;
		xBlock = WRand(xBlockMax);
		yBlock = WRand(yBlockMax);

		PatBlt(cvs, xBlock * xBlockSize, yBlock * yBlockSize,
			xBlockSize, yBlockSize, BLACKNESS);

		/* Draw Gridlines */

		hpenOld = SelectObject(cvs, GetStockObject(BLACK_PEN));
		for (x = 0; x < dxScreen; x += xBlockSize)
			{
			(VOID)MMoveTo(cvs, x, 0);
			LineTo(cvs, x, dyScreen);
			}
		for (y = 0; y < dyScreen; y += yBlockSize)
			{
			(VOID)MMoveTo(cvs, 0, y);
			LineTo(cvs, dxScreen, y);
			}
		SelectObject(cvs, hpenOld);
		}
		break;
		
	case SSM_SECOND:
		if (csecReblank-- == 0)
			ScrChooseRandomServer();
		break;
		
	case SSM_ANIMATE:
		{
		CVS cvs;
		INT cd, step;
		INT xSrc, ySrc;
		INT xDest, yDest;
		INT xFill, yFill;
		INT dxFill, dyFill;
		
		static INT iSkip = 0;

		if (iSkip++ == 1)
			{
			iSkip = 0;
			break;
			}
			
		cvs = (CVS) l1;

		GetDxDy();

		xBlock += dx;
		yBlock += dy;

		dx *= 4;
		step = dx + dy;
		if (step < 0)
			step = -step;

		/* Source */
		xSrc = xBlock * xBlockSize;
		ySrc = yBlock * yBlockSize;

		/* Dest */
		xDest = xSrc - dx;
		yDest = ySrc - dy;

		for (cd = 0; cd < (dx == 0 ? yBlockSize : xBlockSize); cd += step)
			{
			BitBlt(cvs, xDest, yDest, xBlockSize, yBlockSize,
				cvs, xSrc, ySrc, SRCCOPY);

			xFill = xSrc;
			yFill = ySrc;
			dxFill = dx > 0 ? dx : -dx;
			dyFill = dy > 0 ? dy : -dy;

			switch (dir)
				{
				case 0:	/* Left */
					dyFill = yBlockSize;
					break;
				case 1:	/* Right */
					xFill = xDest + xBlockSize;
					dyFill = yBlockSize;
					break;
				case 2:	/* Up */
					yFill = yDest + yBlockSize;
					dxFill = xBlockSize;
					break;
				case 3:	/* Down */
					dxFill = xBlockSize;
					break;
				}
			PatBlt(cvs, xFill, yFill, dxFill, dyFill, BLACKNESS);
			xSrc -= dx;
			ySrc -= dy;
			xDest -= dx;
			yDest -= dy;
			}
		break;
		}
		}
	
	return fTrue;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\idlewild\stars\stars.c ===
#ifdef PM
#include <cstd.h>
#define INCL_WIN
#define INCL_GPI
#include <os2.h>
INT _acrtused = 0;
#endif
#ifdef WIN
#include <windows.h>
#include <port1632.h>
#endif

#include "std.h"
#include "scrsave.h"



INT rand();

INT dxScreen, dyScreen;
INT dxScreenD2, dyScreenD2;

typedef struct _str
	{
	SHORT x, y, z;
	SHORT xo, yo;
	} STR;
		
#define istrMax 64

STR rgstr [istrMax];

Animate(CVS hps);
MakeStar(STR * pstr);
SetPel(HDC hdc, INT x, INT y, INT brght);

#define dzStep 4
#define magic 256


BOOL  APIENTRY CoolProc(hwnd, wm, wParam, lParam)
HWND hwnd;
WORD wm;
WPARAM wParam;
LONG lParam;
	{
	switch (wm)
		{
	case WM_INITDIALOG:
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		return TRUE;
	
	case WM_COMMAND:
		EndDialog(hwnd, TRUE);
		return TRUE;
		}
		
	return FALSE;
	}

BOOL EXPENTRY ScrSaveProc(INT ssm, LPVOID l1, LONG_PTR l2, LONG_PTR l3)
	{
	CHAR FAR * lpsz;
	CHAR FAR * lpch;
	
	switch (ssm)
		{
	default:
		return fFalse;
		
	case SSM_DIALOG:
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
		MessageBeep(0);
/*		{
		FARPROC lpproc;

		lpproc = MakeProcInstance(CoolProc, (HANDLE) l1);
		DialogBox((HANDLE) l1, "Cool", (HWND) l2, lpproc);
		FreeProcInstance(lpproc);
		}*/
		break;
		
	case SSM_OPEN:
		lpsz = (PSZ) l1;
		lpch = "Stars";
		while ((*lpsz++ = *lpch++) != '\0')
			;

		lpsz = (PSZ) l2;
		lpch = "Drifting Through Space\n\nby Brad Christian";
		while ((*lpsz++ = *lpch++) != '\0')
			;

		dxScreen = GetSystemMetrics(SM_CXSCREEN);
		dyScreen = GetSystemMetrics(SM_CYSCREEN);
		dxScreenD2 = dxScreen / 2;
		dyScreenD2 = dyScreen / 2;
		break;
		
	case SSM_ANIMATE:
		Animate((CVS) l1);
		break;
		}
	
	return fTrue;
	}


Animate(CVS hps)
	{
	INT x, y;
	INT istr;
	STR * pstr;
	
	pstr = rgstr;
	for (istr = 0; istr < istrMax; istr += 1, pstr += 1)
		{
		if ((pstr->z -= dzStep) <= 0)
			MakeStar(pstr);
		
		x = pstr->x * magic / pstr->z + dxScreenD2;
		y = pstr->y * magic / pstr->z + dyScreenD2;
		
		SetPel(hps, pstr->xo, pstr->yo, 0);
		
		if (x < 0 || y < 0 || x >= dxScreen || y >= dyScreen)
			MakeStar(pstr);
		else
			{
			SetPel(hps, x, y, 256 - pstr->z);
			pstr->xo = (SHORT)x;
			pstr->yo = (SHORT)y;
			}
		}
	}


MakeStar(STR * pstr)
	{
	pstr->x = WRand(dxScreen) - dxScreenD2;
	pstr->y = WRand(dyScreen) - dyScreenD2;
	pstr->z = WRand(256) + 1;
	}



#ifdef PM
LONG mpbrghtclr [] =
	{
	CLR_BLACK,
	CLR_DARKGRAY,
	CLR_PALEGRAY,
	CLR_WHITE,
	CLR_YELLOW
	};
#endif
	
#ifdef PM
SetPel(HPS hps, INT x, INT y, INT brght)
	{
	RECTL rectl;
	
	rectl.xLeft = x;
	rectl.xRight = x + 1;
	rectl.yBottom = y;
	rectl.yTop = y + 1;
	
	if (brght != 0)
		{
		brght >>= 5; // 0 <= brght <= 7
	
		if (brght > 3)
			{
			rectl.xRight += 1;
			rectl.yTop += 1;
			brght >>= 1;
			}
		
		brght += 1;
		}
	else
		{
		rectl.xRight += 1;
		rectl.yTop += 1;
		}
	
	WinFillRect(hps, &rectl, mpbrghtclr[brght]);
	}
#endif
#ifdef WIN
SetPel(HDC hdc, INT x, INT y, INT brght)
	{
	SetPixel(hdc, x, y, ((LONG) brght << 16) | (brght << 8) | brght);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\pegged\pegged.c ===
/* Pegged.C -- Windows Game*/
/* (c) By Mike Blaylock - 1989, 1990 */



#include "windows.h"
#include <port1632.h>
#include "math.h"
#include "pegged.h"

#define DIVISIONS 7
#define ICON_NAME "Pegged"
#define HELP_FILE "pegged.hlp"

VOID checkfvmove();
VOID checkfanymoves();

VOID  APIENTRY AboutWEP(HWND, HICON, LPSTR, LPSTR);

RECT r;
INT prevxorg, prevyorg;
INT prevwidth, prevheight;

HWND        hWnd ;



HANDLE hAccTable;
INT m = 0, nDefault = 3;
LONG_PTR prevwarea, newarea;
INT xPrevpoint, yPrevpoint, xLeft, yTop;
WPARAM wprevmenuitem;

HANDLE hPeggedIcon;

HANDLE hBitmap, hWBitmap ,  hIntBitmap, hOldWBitmap, hOldIntBitmap,
 hBoardBitmap, hOldBoardBitmap, htmpBitmap, hWtmpBitmap ,  hInttmpBitmap,
 hOldWtmpBitmap, hOldInttmpBitmap, hBoardtmpBitmap, hOldBoardtmpBitmap;


INT icross = 1, iplus = 0, ifireplace = 0, ipyramid = 0, ilamp
= 0, idiamond = 0,  iuparrow = 0, isolitaire = 0, fanymoremoves
= 0, ntotal = 0, fignorelbutton = 0, fmousefocusd = 0;

INT ffirst = 1, foomed = 0;


LPSTR lpszCommands[10], lpszHowToPlay[10];
LONG lPrevSizeParam ;

struct {
    INT xsource;
    INT ysource;
    INT xdest;
    INT ydest;
    INT xjumped;
    INT yjumped;
}  move[34];

LRESULT APIENTRY WndProc (HWND, UINT, WPARAM, LPARAM) ;

CHAR szAppName [] = "Pegged";
static BOOL bState [DIVISIONS][DIVISIONS];

HDC hDC, hMemDC, hMemwinDC, hIntDC, hBoardDC, htmpMemDC, htmpMemwinDC,
 htmpIntDC, htmpBoardDC;
HBRUSH  hLtgrybrush, hDkgrybrush, hYbrush, hBbrush, hBlkbrush,
hGbrush, hMedgrybrush;
HPEN hWpen, hLtwpen, hBlkpen, hDkgrypen, hThkdkgrypen, hMedgrypen,
 hLtgrypen;
INT first = 1, fhitbutton = 0, fmovingchip = 0, fvalidmove = 0,
 fcanundo = 0, foom = 0, foomonsize = 0;
INT ixdownblock, iydownblock, ixupblock, iyupblock, ixkilledblock,
 iykilledblock, ixjumpedblock, iyjumpedblock, ixprevsource, iyprevsource,
 ixprevdest, iyprevdest, ixprevkilled, iyprevkilled;



MMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
/* { */
    /*     HWND        hWnd ;*/
    MSG         msg ;
    WNDCLASS    wndclass ;
    static INT xScreen, yScreen, xSize, ySize;

    /*multinst.c */

    if (hPrevInstance)
    {

	hWnd = FindWindow(szAppName, NULL);
	SendMessage(hWnd, WM_SYSCOMMAND, SC_RESTORE, (LONG) 0);
	hWnd = GetLastActivePopup(hWnd);
	BringWindowToTop(hWnd);
	return FALSE;
    }


    if (!hPrevInstance)
    {
	wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
	wndclass.lpfnWndProc   = WndProc ;
	wndclass.cbClsExtra    = 0 ;
	wndclass.cbWndExtra    = 0 ;
	wndclass.hInstance     = hInstance ;
	wndclass.hIcon = LoadIcon(hInstance, (LPSTR) ICON_NAME);
	hPeggedIcon = wndclass.hIcon;
	wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
	wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
	wndclass.lpszMenuName  = szAppName ;
	wndclass.lpszClassName = szAppName ;

	if (!RegisterClass (&wndclass))
	    return FALSE ;
    }


    xScreen = GetSystemMetrics(SM_CXSCREEN);
    yScreen = GetSystemMetrics(SM_CYSCREEN);
    if (xScreen > yScreen)
    {
	xSize = (xScreen / 8) * 3;
	ySize = xSize;
    } else
    {
	ySize = (yScreen / 8) * 3;
	xSize = ySize;
    }


    hWnd = CreateWindow (szAppName, "Pegged",
    WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX,
			     (xScreen-xSize)
     / 2, (yScreen-ySize)
     / 2,
    xSize, ySize,
    NULL, NULL, hInstance, NULL) ;

    ShowWindow (hWnd, nCmdShow) ;
    UpdateWindow (hWnd) ;
    hAccTable = LoadAccelerators(hInstance, "MainAcc");

    while (GetMessage (&msg, NULL, 0, 0)
    )
    if (!TranslateAccelerator(hWnd, hAccTable, &msg)
    )
    {
	{
	TranslateMessage (&msg) ;
	DispatchMessage (&msg) ;
    }


    }


    return (INT) msg.wParam ;
    }


LRESULT  APIENTRY WndProc (
HWND          hWnd,
UINT         iMessage,
WPARAM       wParam,
LPARAM       lParam)
{


    static INT xBlock, xsizedBlock, yBlock, ysizedBlock, xEdge,
         yEdge, xShadow, yShadow, xHalf, yHalf, winxEdge, winyEdge;
    HDC hDC;
    PAINTSTRUCT ps;
    RECT rect;
    LONG xul, yul;
    INT x, y, j, k;

    static INT  xClient, xsizedClient, yClient, ysizedClient,
         xCenter, yCenter, oldxCenter, oldyCenter, xTotal, yTotal,
        xRadius, yRadius, xMove, yMove, xPixel, yPixel, i;
    INT xPoint, yPoint, xUp, yUp;
    SHORT         nScale;
    BOOL bShow;


    MSG message;
    HMENU hMenu;


    switch (iMessage) {
    case WM_INITMENUPOPUP:
	if (m)
	    EnableMenuItem((HMENU)wParam, IDM_UNDO, MF_ENABLED);
	else
	    EnableMenuItem((HMENU)wParam, IDM_UNDO, MF_GRAYED);
	break;


    case WM_COMMAND:
	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	case IDM_NEW:
	    m = 0;
	    hDC = GetDC(hWnd);

	    if (isolitaire) {
		for (j = 0; j < 7; ++j)
		    for (k = 0; k < 7; ++k) {
			if ((j > 1 && j < 5) || (k > 1 && k < 5))
			    if (!(j == 3 && k == 3))
				bState[j][k] = 1;
			    else
				bState[j][k] = 0;
		    }
	    }

	    if (icross) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 1;
		bState[2][3] = 0;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 1;
		bState[4][3] = 0;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;
	    }

	    if (iuparrow) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 1;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 0;
		bState[2][4] = 0;
		bState[2][5] = 1;
		bState[2][6] = 1;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 1;
		bState[4][0] = 0;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 0;
		bState[4][4] = 0;
		bState[4][5] = 1;
		bState[4][6] = 1;
		bState[5][2] = 1;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;


	    }

	    if (iplus) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 1;
		bState[1][4] = 0;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 0;
		bState[2][3] = 1;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 0;
		bState[4][3] = 1;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 1;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;

	    }

	    if (ifireplace) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 0;
		bState[1][2] = 0;
		bState[1][3] = 0;
		bState[1][4] = 0;
		bState[2][0] = 1;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 0;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 0;
		bState[3][4] = 0;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 1;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 0;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 0;
		bState[5][4] = 0;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 0;



	    }



	    if (ipyramid) {
		bState[0][2] = 0;
		bState[0][3] = 0;
		bState[0][4] = 1;
		bState[1][2] = 0;
		bState[1][3] = 1;
		bState[1][4] = 1;
		bState[2][0] = 0;
		bState[2][1] = 0;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 1;
		bState[2][5] = 0;
		bState[2][6] = 0;
		bState[3][0] = 0;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 1;
		bState[3][4] = 1;
		bState[3][5] = 0;
		bState[3][6] = 0;
		bState[4][0] = 0;
		bState[4][1] = 0;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 1;
		bState[4][5] = 0;
		bState[4][6] = 0;
		bState[5][2] = 0;
		bState[5][3] = 1;
		bState[5][4] = 1;
		bState[6][2] = 0;
		bState[6][3] = 0;
		bState[6][4] = 1;




	    }

	    if (idiamond) {
		bState[0][2] = 0;
		bState[0][3] = 1;
		bState[0][4] = 0;
		bState[1][2] = 1;
		bState[1][3] = 1;
		bState[1][4] = 1;
		bState[2][0] = 0;
		bState[2][1] = 1;
		bState[2][2] = 1;
		bState[2][3] = 1;
		bState[2][4] = 1;
		bState[2][5] = 1;
		bState[2][6] = 0;
		bState[3][0] = 1;
		bState[3][1] = 1;
		bState[3][2] = 1;
		bState[3][3] = 0;
		bState[3][4] = 1;
		bState[3][5] = 1;
		bState[3][6] = 1;
		bState[4][0] = 0;
		bState[4][1] = 1;
		bState[4][2] = 1;
		bState[4][3] = 1;
		bState[4][4] = 1;
		bState[4][5] = 1;
		bState[4][6] = 0;
		bState[5][2] = 1;
		bState[5][3] = 1;
		bState[5][4] = 1;
		bState[6][2] = 0;
		bState[6][3] = 1;
		bState[6][4] = 0;


	    }


	    /******Erase all the chips *************************************/

	    for (x = 0; x < DIVISIONS; x++)
		for (y = 0; y < DIVISIONS; y++) {
		    if ((x > 1 && x < 5) || (y > 1 && y < 5)) {
			BitBlt(hDC, xBlock * x + winxEdge, yBlock
			    *y + winyEdge, xBlock, yBlock, hBoardDC,
			     xBlock * x + winxEdge, yBlock * y + winyEdge,
			     SRCCOPY);
		    }
		}
	    /*************************************************************/



	    /********* Put chips where they go *****************************/
	    for (x = 0; x < DIVISIONS; x++)
		for (y = 0; y < DIVISIONS; y++) {
		    if (bState[x][y]) {


			SelectObject(hDC, hDkgrypen);
			SelectObject(hDC, hDkgrybrush);
			Ellipse(hDC, x * xBlock + xEdge + xShadow +
			    winxEdge, y * yBlock + yEdge + yShadow +
			    winyEdge, (x + 1) * xBlock - xEdge + xShadow +
			    winxEdge,  (y + 1) * yBlock - yEdge + yShadow +
			    winyEdge);

			SelectObject(hDC, hBlkpen);
			SelectObject(hDC, hBbrush);
			Ellipse(hDC, x * xBlock + xEdge + winxEdge,
			     y * yBlock + yEdge + winyEdge, (x + 1) *
			    xBlock - xEdge + winxEdge,  (y + 1) * yBlock -
			    yEdge + winyEdge);

			SelectObject(hDC, hWpen);
			Arc(hDC, x * xBlock + xEdge + xShadow +
			    winxEdge, y * yBlock + yEdge + yShadow +
			    winyEdge, (x + 1) * xBlock - xEdge - xShadow +
			    winxEdge,  (y + 1) * yBlock - yEdge - yShadow +
			    winyEdge , x * xBlock + xHalf + winxEdge ,
			     y * yBlock + yShadow + winyEdge, x * xBlock
			    + xShadow + winxEdge, y * yBlock + yHalf +
			    winyEdge);



		    }
		}
	    /***************************************************************/

	    BitBlt(hMemwinDC, 0, 0, xClient, yClient, hDC, 0, 0,
	         SRCCOPY);


	    ReleaseDC(hWnd, hDC);

	    break;

	case IDM_UNDO:
	    if (m) {
		--m;
		/*put a chip back in the original location */
		hDC = GetDC(hWnd);
		/*erase the destination chip on screen*/
		BitBlt(hDC, move[m].xdest * xBlock + winxEdge,
		    move[m].ydest * yBlock + winyEdge, xBlock, yBlock,
		     hBoardDC, move[m].xdest * xBlock + winxEdge, move[m].ydest
		    *yBlock + winyEdge , SRCCOPY);

		/*Erase the destination chip on the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xdest * xBlock + winxEdge,
		     move[m].ydest * yBlock + winyEdge, xBlock, yBlock,
		     hBoardDC, move[m].xdest * xBlock + winxEdge, move[m].ydest
		    *yBlock + winyEdge , SRCCOPY);

		/*Put back the jumped chip on the screen*/

		x = move[m].xjumped;
		y = move[m].yjumped;

		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);
		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);




		/* Put back the jumped chip in the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xjumped * xBlock + winxEdge,
		     move[m].yjumped * yBlock + winyEdge, xBlock, yBlock,
		     hDC, move[m].xjumped * xBlock + winxEdge, move[m].yjumped
		    *yBlock + winyEdge , SRCCOPY);



		/*Put back the source chip on the screen*/

		x = move[m].xsource;
		y = move[m].ysource;


		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);
		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);



		/* Put back the source chip in the memdc */
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, move[m].xsource * xBlock + winxEdge,
		     move[m].ysource * yBlock + winyEdge, xBlock, yBlock,
		     hDC, move[m].xsource * xBlock + winxEdge, move[m].ysource
		    *yBlock + winyEdge , SRCCOPY);

		/*Restore the matrix to previous state*/

		bState[move[m].xsource][move[m].ysource] = 1;
		bState[move[m].xjumped][move[m].yjumped] = 1;
		bState[move[m].xdest][move[m].ydest] = 0;


		ReleaseDC(hWnd, hDC);


	    } else
		MessageBox(hWnd, "Can't Backup", szAppName, MB_ICONASTERISK |
		    MB_OK);
	    break;



	case IDM_CROSS:
	    icross = 1;
	    iplus = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, IDM_CROSS, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_PLUS:

	    iplus = 1;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);

	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;

	case IDM_FIREPLACE:

	    iplus = 0;
	    icross = 0;
	    ifireplace = 1;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;

	case IDM_UPARROW:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 1;
	    isolitaire = 0;

	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);



	    break;

	case IDM_DIAMOND:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 1;
	    iuparrow = 0;
	    isolitaire = 0;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_PYRAMID:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 1;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 0;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);

	    break;

	case IDM_SOLITAIRE:
	    iplus = 0;
	    icross = 0;
	    ifireplace = 0;
	    ipyramid = 0;
	    ilamp = 0;
	    idiamond = 0;
	    iuparrow = 0;
	    isolitaire = 1;
	    hMenu = GetMenu(hWnd);
	    CheckMenuItem(hMenu, (WORD)wprevmenuitem, MF_UNCHECKED);
	    CheckMenuItem(hMenu, (WORD)wParam, MF_CHECKED);


	    wprevmenuitem = wParam;
	    PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);


	    break;
	case IDM_ABOUT:
            AboutWEP(hWnd, hPeggedIcon  , "Pegged!   Version 1.0",
                 "by Mike Blaylock");

	    /*
	     MessageBox(hWnd,"Pegged\n\nA Windows Solitaire Game\n\nCopyright 1989-90\n\nby Mike Blaylock\n\nAlpha v1.011",szAppName, MB_ICONASTERISK | MB_OK);
*/
	    break;

	case IDM_INDEX:
	    WinHelp(hWnd, HELP_FILE, HELP_INDEX, (ULONG_PTR) NULL);
	    break;

	case IDM_HOWTO:
	    WinHelp(hWnd, HELP_FILE, HELP_KEY, (ULONG_PTR) "How To Play");
	    break;

	case IDM_COMMANDS:
	    WinHelp(hWnd, HELP_FILE, HELP_KEY, (ULONG_PTR) "Commands");
	    break;

	case IDM_USING:
	    WinHelp(hWnd, HELP_FILE, HELP_HELPONHELP, (ULONG_PTR) NULL);
	    break;


	case IDM_ICONIZE:
	    ShowWindow(hWnd, SW_MINIMIZE);
	    break;

	case IDM_EXIT:
	    DestroyWindow(hWnd);
	    break;


	default:
	    break;

	}
	break;


    case WM_CREATE:

	hDC = GetDC (hWnd) ;


	xPixel = GetDeviceCaps (hDC, ASPECTX) ;
	yPixel = GetDeviceCaps (hDC, ASPECTY) ;
	hWpen = CreatePen(0, 2, RGB(255, 255, 255));
	hLtwpen = CreatePen(0, 1, RGB(255, 255, 255));


	hMedgrypen = CreatePen(0, 1, RGB (128, 128, 128));

	hDkgrypen = CreatePen(0, 1, RGB (64, 64, 64));
	hThkdkgrypen = CreatePen(0, 2, RGB (64, 64, 64));
	hMedgrybrush = CreateSolidBrush(RGB (128, 128, 128));
	hDkgrybrush = CreateSolidBrush(RGB (64, 64, 64));

	hBlkpen = GetStockObject(BLACK_PEN);
	hBbrush = CreateSolidBrush (RGB (0, 0, 255));
	hBlkbrush = CreateSolidBrush(RGB (0, 0, 0));
	hGbrush = CreateSolidBrush (RGB (0, 64, 0));
	hLtgrybrush = CreateSolidBrush (RGB (192, 192, 192));
	hLtgrypen = CreatePen(0, 1, RGB (192, 192, 192));
	hYbrush = CreateSolidBrush (RGB (255, 255, 0));
	nDefault = 3;
	hMenu = GetMenu(hWnd);
	wprevmenuitem = GetPrivateProfileInt((LPSTR)"Pegged", (LPSTR)"Option",
	     nDefault, (LPSTR)"entpack.ini");
	CheckMenuItem(hMenu, (WORD)wprevmenuitem
	    , MF_CHECKED);

	icross = 0;
	iplus = 0;
	ifireplace = 0;
	ipyramid = 0;
	idiamond = 0;
	iuparrow = 0;
	isolitaire = 0;

	switch (wprevmenuitem) {

	case 3:
	    icross = 1;
	    break;

	case 4:
	    iplus = 1;
	    break;

	case 5:
	    ifireplace = 1;
	    break;

	case 6:
	    iuparrow = 1;
	    break;

	case 7:
	    ipyramid = 1;
	    break;

	case 8:
	    idiamond = 1;
	    break;

	case 9:
	    isolitaire = 1;
	    break;

	default:
	    icross = 1;
	    break;

	}

	PostMessage(hWnd, WM_COMMAND, IDM_NEW, 0L);




	ffirst = 1;

	ReleaseDC (hWnd, hDC) ;
	break ;

    case WM_SIZE:



	foom = 0;
	hDC = GetDC (hWnd) ;

        MGetViewportOrg(hDC, &xLeft, &yTop);

        newarea = (LONG)LOWORD(lParam) * (LONG)HIWORD(lParam);


	if (ffirst) {

	    xBlock = LOWORD (lParam) / (DIVISIONS + 2);
	    yBlock = HIWORD (lParam) / (DIVISIONS + 2);
	    xClient = LOWORD (lParam);
	    yClient = HIWORD (lParam);
	    xEdge = xBlock / 4;
	    yEdge = yBlock / 4;
	    xShadow = xBlock / 10;
	    yShadow = yBlock / 10;
	    xHalf = xBlock / 2;
	    yHalf = yBlock / 2;
	    winxEdge = xBlock;
	    winyEdge = yBlock;


	    if (!(hIntDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hBoardBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }



	    if (!(hIntBitmap = CreateCompatibleBitmap(hDC, xBlock
	        *4, yBlock * 4))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hMemwinDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hBoardDC = CreateCompatibleDC(hDC))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }

	    if (!(hWBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		MessageBox(hWnd, "Not Enough Memory", szAppName,
		     MB_ICONASTERISK | MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		break;

	    }


	    hOldIntBitmap = SelectObject(hIntDC, hIntBitmap);
	    hOldWBitmap = SelectObject(hMemwinDC, hWBitmap);
	    hOldBoardBitmap = SelectObject(hBoardDC, hBoardBitmap);


	}

	xsizedClient = LOWORD (lParam);
	ysizedClient = HIWORD (lParam);
	xsizedBlock = LOWORD (lParam) / (DIVISIONS + 2);
	ysizedBlock = HIWORD (lParam) / (DIVISIONS + 2);


	/*If we are actually sizing and not simply being restored from running OOM on a previous size attempt, see if there is enough memory for all the new bitmaps for the new size by trying to create temporary versions of all the bitmaps and DC's*/

	if ((!foomonsize) && (newarea > prevwarea) && (!ffirst)) {
	    if (!(hBoardtmpBitmap = CreateCompatibleBitmap(hDC,
	         xsizedClient, ysizedClient))) {
		foomonsize = 1;

	    }

	    if (!foomonsize)
		if (!(htmpBoardDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    DeleteObject(hBoardtmpBitmap);
		}

	    if (!foomonsize)
		if (!(hWtmpBitmap = CreateCompatibleBitmap(hDC,
		     xsizedClient, ysizedClient))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);

		}


	    if (!foomonsize)
		if (!(htmpMemwinDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    DeleteObject(hWtmpBitmap);
		}

	    if (!foomonsize)
		if (!(hInttmpBitmap = CreateCompatibleBitmap(hDC,
		     xsizedBlock * 4, ysizedBlock * 4))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    SelectObject(htmpMemwinDC, hWtmpBitmap);
		    DeleteDC(htmpMemwinDC);
		    DeleteObject(hWtmpBitmap);

		}

	    if (!foomonsize)
		if (!(htmpIntDC = CreateCompatibleDC(hDC))) {
		    foomonsize = 1;
		    SelectObject(htmpBoardDC, hBoardtmpBitmap);
		    DeleteDC(htmpBoardDC);
		    DeleteObject(hBoardtmpBitmap);
		    SelectObject(htmpMemwinDC, hWtmpBitmap);
		    DeleteDC(htmpMemwinDC);
		    DeleteObject(hWtmpBitmap);
		    DeleteObject(hInttmpBitmap);
		}


	    if (foomonsize)
		foomed = 1;




	    /*If there isn't enough memory do a MoveWindow to the old size, and break*/
	    if (foomonsize) {
		ReleaseDC(hWnd, hDC);
		MoveWindow(hWnd, prevxorg, prevyorg, prevwidth,
		     prevheight, TRUE);
		break;
	    }
	        /*If there IS enough memory, destroy the temp bitmaps and DC's and continue*/
	    else
	     {
		SelectObject(htmpBoardDC, hBoardtmpBitmap);
		DeleteDC(htmpBoardDC);
		DeleteObject(hBoardtmpBitmap);
		SelectObject(htmpMemwinDC, hWtmpBitmap);
		DeleteDC(htmpMemwinDC);
		DeleteObject(hWtmpBitmap);
		SelectObject(htmpIntDC, hInttmpBitmap);
		DeleteDC(htmpIntDC);
		DeleteObject(hInttmpBitmap);
	    }

	}/*End if not previous foomonsize and sizing smaller and not first time*/


	if ((!ffirst) && (!foomonsize))/*if this isn't the first start and we're not restoring from previous failed size */ {
	    SelectObject(hBoardDC, hOldBoardBitmap);
	    DeleteDC(hBoardDC);
	}

	if ((!ffirst) && (!foomonsize)) {
	    SelectObject(hIntDC, hOldIntBitmap);
	    DeleteDC(hIntDC);
	}

	if ((!ffirst) && (!foomonsize)) {
	    SelectObject(hMemwinDC, hOldWBitmap);
	    DeleteDC(hMemwinDC);
	}

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hWBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldWBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hBoardBitmap);

	if ((!ffirst) && (!foomonsize))
	    DeleteObject(hOldBoardBitmap);


	if ((!ffirst) && (!foomonsize)) /*this assumes the test for enough memory works and update the size of the client area*/ {

	    xBlock = LOWORD (lParam) / (DIVISIONS + 2);
	    yBlock = HIWORD (lParam) / (DIVISIONS + 2);
	    xClient = LOWORD (lParam);
	    yClient = HIWORD (lParam);
	    xEdge = xBlock / 4;
	    yEdge = yBlock / 4;
	    xShadow = xBlock / 10;
	    yShadow = yBlock / 10;
	    xHalf = xBlock / 2;
	    yHalf = yBlock / 2;
	    winxEdge = xBlock;
	    winyEdge = yBlock;

	}

	if ((!ffirst) && (!foomonsize))
	    if (!(hBoardBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;
	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hBoardDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hMemwinDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hWBitmap = CreateCompatibleBitmap(hDC, xClient,
	         yClient))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }


	if ((!ffirst) && (!foomonsize))
	    if (!(hIntDC = CreateCompatibleDC(hDC))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    if (!(hIntBitmap = CreateCompatibleBitmap(hDC, xBlock
	        *4, yBlock * 4))) {
		foom = 1;
		MessageBox(hWnd, "Out of Memory ", szAppName, MB_ICONASTERISK |
		    MB_OK);
		PostMessage(hWnd, WM_DESTROY, 0, 0L);
		ReleaseDC(hWnd, hDC);
		break;

	    }

	if ((!ffirst) && (!foomonsize))
	    hOldBoardBitmap = SelectObject(hBoardDC, hBoardBitmap);

	if ((!ffirst) && (!foomonsize))
	    hOldIntBitmap = SelectObject(hIntDC, hIntBitmap);

	if ((!ffirst) && (!foomonsize))
	    hOldWBitmap = SelectObject(hMemwinDC, hWBitmap);

	foomonsize = 0;

	ffirst = 0;

	/*
	** We've successfully created all the bitmaps so this size
	** can be done without running out of memory.  Therefore, we'll
	** record the current size of the window in case it has to be
	** restored on a subsequent OOM due to a sizing of the window
	*/



	GetWindowRect(hWnd, (LPRECT) & r);
	prevxorg = r.left;
	prevyorg = r.top;
	prevwidth = max(r.right, r.left) - min(r.right, r.left);
	prevheight = max(r.bottom, r.top) - min(r.bottom, r.top);
	prevwarea = (LONG)LOWORD(lParam) * (LONG)HIWORD(lParam);

	ReleaseDC(hWnd, hDC);
	break ;

    case WM_MOVE:
	GetWindowRect(hWnd, (LPRECT) & r);
	prevxorg = r.left;
	prevyorg = r.top;
	break;



    case WM_MOUSEACTIVATE:
	fmousefocusd = 1;
	break;

    case WM_ERASEBKGND:
	if (fmousefocusd)
	    fignorelbutton = 1;
	break;

    case WM_LBUTTONDOWN:
	/*If we just got the erasebackground message due to activation via a mouse click, ignore all lbuttondowns until the window is painted */
	if (fignorelbutton == 1)
	    break;
	else
	    fmousefocusd = 0;

	hDC = GetDC(hWnd);

	xPoint = LOWORD(lParam);
	yPoint = HIWORD(lParam);

	if (foom == 1) {
	    MessageBox(hWnd, "Out of Memory", szAppName, MB_ICONASTERISK |
	        MB_OK);
	} else

	 {
	    /*If the mouse is clicked in to the left or above or to the right of or below the game board, we have to ignore*/
	    if (xPoint > winxEdge && yPoint > winyEdge && xPoint
	        < xBlock * 8 && yPoint < yBlock * 8) {
		ixdownblock = (xPoint / xBlock) - 1;
		iydownblock = (yPoint / yBlock) - 1;
	    } else
	     {
		ReleaseDC(hWnd, hDC);
		break;
	    }
	    /*check to see if the mouse location is on a chip*/

	    /* if it is on a chip, allow it to be moved*/
	    if (bState[ixdownblock][iydownblock]) {

		if ((ixdownblock > 1 && ixdownblock < 5) || (iydownblock
		    > 1 && iydownblock < 5)) {

		    BitBlt(hDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, xBlock, yBlock,
		         hBoardDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, SRCCOPY);
		    SelectObject(hMemwinDC, hWBitmap);
		    BitBlt(hMemwinDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, xBlock, yBlock,
		         hBoardDC, ixdownblock * xBlock + winxEdge,
		         iydownblock * yBlock + winyEdge, SRCCOPY);


		    fmovingchip = 1;

		    /*Capture all mouse messages */
		    SetCapture(hWnd);

		    /*erase the mouse cursor too */
		    bShow = 0;
		    ShowCursor(bShow);
		    SelectObject(hIntDC, hIntBitmap);
		    BitBlt(hIntDC, 0, 0, xBlock * 4, yBlock * 4,
		        hMemwinDC, xPoint - 2 * xBlock, yPoint - 2
		        *yBlock, SRCCOPY);

		    /* commented out the use of shadow while moving chips
		    SelectObject(hIntDC,hMedgrypen);
		    SelectObject(hIntDC,hMedgrybrush);
		    Ellipse(hIntDC,xBlock+xBlock/2+xEdge+2*xShadow, yBlock+yBlock/2+yEdge+2*yShadow, 2*xBlock+xBlock/2-xEdge+2*xShadow, 2*yBlock+yBlock/2-yEdge+2*yShadow);
		    */

		    SelectObject(hIntDC, hBlkpen);
		    SelectObject(hIntDC, hBbrush);
		    Ellipse(hIntDC, xBlock + xBlock / 2 + xEdge,
		         yBlock + yBlock / 2 + yEdge, 2 * xBlock +
		        xBlock / 2 - xEdge, 2 * yBlock + yBlock / 2
		        -yEdge);


		    SelectObject(hIntDC, hWpen);
		    Arc(hIntDC, xBlock + xBlock / 2 + xEdge + xShadow,
		         yBlock + yBlock / 2 + yEdge + yShadow, 2 *
		        xBlock + xBlock / 2 - xEdge - xShadow, 2 *
		        yBlock + yBlock / 2 - yEdge - yShadow, xBlock
		        + xBlock / 2 + xHalf, yBlock + yBlock / 2 +
		        yShadow, xBlock + xBlock / 2 + xShadow, yBlock
		        + yBlock / 2 + yHalf);

		    xPrevpoint = xPoint;
		    yPrevpoint = yPoint;
		}
	    }

	}
	ReleaseDC(hWnd, hDC);


	break;

    case WM_MOUSEMOVE:
	xPoint = LOWORD(lParam);
	yPoint = HIWORD(lParam);
	if (fmovingchip) {

	    if (xPoint > xLeft + xClient || xPoint < xLeft || yPoint
	        > yClient + yTop || yPoint < yTop) {
		/*  Do what we would do if it wasn't a valid destination .  This fixes the problem where moving the mouse outside the window causes us to lose the mouse cursor forever*/
		bShow = 1;
		ShowCursor(bShow);
		fmovingchip = 0;
		ReleaseCapture();
		x = ixdownblock;
		y = iydownblock;
		SelectObject(hMemwinDC, hWBitmap);

		SelectObject(hMemwinDC, hDkgrypen);
		SelectObject(hMemwinDC, hDkgrybrush);
		Ellipse(hMemwinDC, x * xBlock + xEdge + xShadow +
		    winxEdge, y * yBlock + yEdge + yShadow + winyEdge,
		     (x + 1) * xBlock - xEdge + xShadow + winxEdge,
		      (y + 1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hMemwinDC, hBlkpen);
		SelectObject(hMemwinDC, hBbrush);
		Ellipse(hMemwinDC, x * xBlock + xEdge + winxEdge,
		     y * yBlock + yEdge + winyEdge, (x + 1) * xBlock -
		    xEdge + winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hMemwinDC, hWpen);
		Arc(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);



		hDC = GetDC(hWnd);

		BitBlt(hDC, 0, 0, xClient, yClient, hMemwinDC,
		    0, 0, SRCCOPY);
		ReleaseDC(hWnd, hDC);

	    }

	}
	/*check if a chip is in a move state */
	if (fmovingchip) {
	    /* if it is, bitblt as the mouse moves */

	    hDC = GetDC(hWnd);

	    /* if we are moving the mouse too fast, we have to erase the old ellipse manually */
	    if ((xPrevpoint > xPoint + xBlock) || (xPoint > xPrevpoint
	        + xBlock) || (yPrevpoint > yPoint + yBlock) || (yPoint
	        > yBlock + yPrevpoint)) {
                SelectObject(hIntDC, hIntBitmap);
                BitBlt(hIntDC, 0, 0, xBlock * 2, yBlock * 2, hMemwinDC,
		     xPrevpoint - xBlock, yPrevpoint - yBlock, SRCCOPY);

		BitBlt(hDC, xPrevpoint - xBlock, yPrevpoint - yBlock,
                     xBlock * 2, yBlock * 2, hIntDC, 0, 0, SRCCOPY);
            }



            SelectObject(hIntDC, hIntBitmap);
            BitBlt(hIntDC, 0, 0, xBlock * 4, yBlock * 4, hMemwinDC,
	         xPoint - 2 * xBlock, yPoint - 2 * yBlock, SRCCOPY);

	    /* Commented out shadow while moving *****
	    SelectObject(hIntDC,hmedgrypen);
	    SelectObject(hIntDC,hMedgrybrush);
	    Ellipse(hIntDC,xBlock+xBlock/2+xEdge+2*xShadow, yBlock+yBlock/2+yEdge+2*yShadow, 2*xBlock+xBlock/2-xEdge+2*xShadow, 2*yBlock+yBlock/2-yEdge+2*yShadow);

	    */

	    SelectObject(hIntDC, hBlkpen);
	    SelectObject(hIntDC, hBbrush);
	    Ellipse(hIntDC, xBlock + xBlock / 2 + xEdge, yBlock
	        + yBlock / 2 + yEdge, 2 * xBlock + xBlock / 2 - xEdge,
	         2 * yBlock + yBlock / 2 - yEdge);

	    SelectObject(hIntDC, hWpen);
	    Arc(hIntDC, xBlock + xBlock / 2 + xEdge + xShadow,
	        yBlock + yBlock / 2 + yEdge + yShadow, 2 * xBlock +
	        xBlock / 2 - xEdge - xShadow, 2 * yBlock + yBlock /
	        2 - yEdge - yShadow, xBlock + xBlock / 2 + xHalf, yBlock
	        + yBlock / 2 + yShadow, xBlock + xBlock / 2 + xShadow,
	         yBlock + yBlock / 2 + yHalf);


            BitBlt(hDC, xPoint - 2 * xBlock, yPoint - 2 * yBlock,
	         xBlock * 4, yBlock * 4, hIntDC, 0, 0, SRCCOPY);

	    ReleaseDC(hWnd, hDC);
	    xPrevpoint = xPoint;
	    yPrevpoint = yPoint;
	}

	break ;


    case WM_LBUTTONUP:
	xUp = LOWORD (lParam);
	yUp = HIWORD (lParam);


	/* if we were in a button move state */

	if (fmovingchip) {

	    ixupblock = xUp / xBlock - 1;
	    iyupblock = yUp / yBlock - 1;
	    ReleaseCapture();
	    checkfvmove();



	    /*and if it was a valid destination */

	    if ((!bState[ixupblock][iyupblock]) && (!(ixupblock
	        < 2 && iyupblock < 2)) && (!(ixupblock > 4 && iyupblock
	        > 4)) && (!(ixupblock < 2 && iyupblock > 4)) && (!(ixupblock
	        > 4 && iyupblock < 2)) && fvalidmove &&  ( xUp > winxEdge) &&
	        ( yUp > winyEdge) &&
	        ( xUp < xBlock * 8) &&
	        ( yUp < yBlock * 8)
	        ) {
		/*
		** adjust the chip in the valid destination rectangle
		** on the screen and on the memory device context, erase
		** the chip that was jumped- on the screen and in the
		** WinMemDC,set fmovingchip to false, and check to see
		** if there are any more valid moves.  If t here aren't,
		** message and show score
		*/

		hDC = GetDC(hWnd);


		/*erase the chip at its current location*/
		BitBlt(hDC, xUp - xBlock / 2 , yUp - yBlock / 2 ,
		     xBlock, yBlock, hMemwinDC, xUp - xBlock / 2 ,
		    yUp - yBlock / 2 , SRCCOPY);

		/*center the chip at the new destination */
		x = ixupblock;
		y = iyupblock;



                /* Draw the peg at its new location */
		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);




		/*erase the jumped chip */
		BitBlt(hDC, xBlock * ixkilledblock + winxEdge,
		    yBlock * iykilledblock + winyEdge, xBlock, yBlock,
		     hBoardDC, xBlock * ixkilledblock + winxEdge, yBlock
		    *iykilledblock + winyEdge , SRCCOPY);
		ReleaseDC(hWnd, hDC);



                /*center the chip in the memory dc as well*/
#ifdef OLDWAY
		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, xBlock * ixupblock + winxEdge,
		     yBlock * iyupblock + winyEdge, xBlock, yBlock,
		     hDC, xBlock * ixupblock + winxEdge, yBlock * iyupblock +
		    winyEdge , SRCCOPY);
#endif


                /* Draw the peg at its new location in the memory DC*/
                SelectObject(hMemwinDC, hDkgrypen);
                SelectObject(hMemwinDC, hDkgrybrush);
                Ellipse(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
                     y * yBlock + yEdge + yShadow + winyEdge, (x +
                    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
                    1) * yBlock - yEdge + yShadow + winyEdge);

                SelectObject(hMemwinDC, hBlkpen);
                SelectObject(hMemwinDC, hBbrush);
                Ellipse(hMemwinDC, x * xBlock + xEdge + winxEdge, y *
                    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
                    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

                SelectObject(hMemwinDC, hWpen);
                Arc(hMemwinDC, x * xBlock + xEdge + xShadow + winxEdge,
                     y * yBlock + yEdge + yShadow + winyEdge, (x +
                    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
                    1) * yBlock - yEdge - yShadow + winyEdge , x *
                    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
                    winyEdge, x * xBlock + xShadow + winxEdge, y *
                    yBlock + yHalf + winyEdge);




		/*erase the jumped chip in memory DC*/
		BitBlt(hMemwinDC, xBlock * ixkilledblock + winxEdge,
		     yBlock * iykilledblock + winyEdge, xBlock, yBlock,
		     hBoardDC, xBlock * ixkilledblock + winxEdge, yBlock
		    *iykilledblock + winyEdge , SRCCOPY);




		/*update the data structure */

		bState[ixdownblock][iydownblock] = 0;

		bState[ixupblock][iyupblock] = 1;

		bState[ixkilledblock][iykilledblock] = 0;

		/*record move in array list */
		move[m].xsource = ixdownblock;
		move[m].ysource = iydownblock;
		move[m].xdest = ixupblock;
		move[m].ydest = iyupblock;
		move[m].xjumped = ixkilledblock;
		move[m].yjumped = iykilledblock;
		++m;
		/*
		ixvdownblock=ixdownblock;
		ixvupblock=ixupblock;
		ixvkilledblock=ixkilledblock;
		*/


		/* Check if there are anymore valid moves*/
		bShow = 1;
		ShowCursor(bShow);

		fanymoremoves = 0;
		checkfanymoves();
		if (fanymoremoves == 0) {/* if there aren't - declare game at an end and score */

		    /*add up the remaining chips*/
		    ntotal = 0;
		    for (j = 0; j < 7; ++j)
			for (k = 0; k < 7; ++k)
			    ntotal += bState[j][k];

		    if (ntotal > 1)
			MessageBox(hWnd, "Game Over", szAppName,
			     MB_ICONASTERISK | MB_OK);
		    else
			MessageBox(hWnd, "You Win!", szAppName,
			     MB_ICONASTERISK | MB_OK);


		}



	    }
	        else /*it wasn't a valid destination */ {
		/*put a chip back in the original location */
		hDC = GetDC(hWnd);
		/*erase the current chip on screen*/
		BitBlt(hDC, xUp - xBlock / 2 , yUp - yBlock / 2 ,
		     xBlock, yBlock, hMemwinDC, xUp - xBlock / 2 ,
		    yUp - yBlock / 2 , SRCCOPY);

		/*Draw the chip back at the original location*/
		x = ixdownblock;
		y = iydownblock;


		SelectObject(hDC, hDkgrypen);
		SelectObject(hDC, hDkgrybrush);
		Ellipse(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge + xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge + yShadow + winyEdge);

		SelectObject(hDC, hBlkpen);
		SelectObject(hDC, hBbrush);
		Ellipse(hDC, x * xBlock + xEdge + winxEdge, y *
		    yBlock + yEdge + winyEdge, (x + 1) * xBlock - xEdge +
		    winxEdge,  (y + 1) * yBlock - yEdge + winyEdge);

		SelectObject(hDC, hWpen);
		Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		     y * yBlock + yEdge + yShadow + winyEdge, (x +
		    1) * xBlock - xEdge - xShadow + winxEdge,  (y +
		    1) * yBlock - yEdge - yShadow + winyEdge , x *
		    xBlock + xHalf + winxEdge , y * yBlock + yShadow +
		    winyEdge, x * xBlock + xShadow + winxEdge, y *
		    yBlock + yHalf + winyEdge);

		SelectObject(hMemwinDC, hWBitmap);
		BitBlt(hMemwinDC, ixdownblock * xBlock + winxEdge,
		     iydownblock * yBlock + winyEdge, xBlock, yBlock,
		     hDC, ixdownblock * xBlock + winxEdge, iydownblock
		    *yBlock + winyEdge , SRCCOPY);

		bShow = 1;
		ShowCursor(bShow);

		ReleaseDC(hWnd, hDC);
	    }

	    fmovingchip = 0;

	    fvalidmove = 0;


	}


	/*
	** if we aren't at a valid destination, take the chip back to
	** the original rectangle in the window DC, restore the original
	** whole-window-Mem-DC as well,and restore the destination area,
	** and show an error message, and set fmovingchip to false
	*/

	break;

    case WM_PAINT:

	hDC = BeginPaint (hWnd, &ps);

	/*Draw the board with holes in it in memory*/

	SelectObject(hDC, hLtgrypen);
	SelectObject(hDC, hLtgrybrush);
	Rectangle(hDC, 0, 0, xClient, yClient);

	SelectObject(hMemwinDC, hWBitmap);





	SelectObject(hMemwinDC, hBlkpen);
	SelectObject(hMemwinDC, hLtgrybrush);
	Rectangle(hMemwinDC, 0, 0, xClient, yClient);

	/*Draw shadows on playing board on right and bottom edges*/
	SelectObject(hMemwinDC, hThkdkgrypen);
	(VOID)MMoveTo(hMemwinDC, winxEdge + 1, yBlock * 5 + winyEdge
	    + 1);
	LineTo(hMemwinDC, xBlock * 2 + winxEdge - 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 + winxEdge, yBlock
	    *7 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge, yBlock * 7 + winyEdge
	    + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *7 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *5 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + winxEdge + 1, yBlock
	    *2 + winyEdge - 1);
	LineTo(hMemwinDC, xBlock * 5 + winxEdge + 1, winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock
	    *2 + winyEdge + 1);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge + 1, yBlock * 5 +
	    winyEdge + 1);

	SelectObject(hMemwinDC, hWpen);

	(VOID)MMoveTo(hMemwinDC, winxEdge - 1, yBlock * 2 + winyEdge);
	LineTo(hMemwinDC, winxEdge - 1, yBlock * 5 + winyEdge -
	    1);

	(VOID)MMoveTo(hMemwinDC, winxEdge, yBlock * 2 - 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 2
	    -1 + winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock
	    *2 + winyEdge - 1);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 0 +
	    winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 + winxEdge, winyEdge -
	    1);
	LineTo(hMemwinDC, xBlock * 5 - 1 + winxEdge, winyEdge -
	    1);

	(VOID)MMoveTo(hMemwinDC, xBlock * 5 + 2 + winxEdge, yBlock
	    *2 - 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 7 + winxEdge, yBlock * 2 - 1 +
	    winyEdge);

	(VOID)MMoveTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock
	    *5 + 1 + winyEdge);
	LineTo(hMemwinDC, xBlock * 2 - 1 + winxEdge, yBlock * 7 -
	    1 + winyEdge);

	/* Draw the holes*/

	SelectObject(hMemwinDC, hBlkpen);
	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if ((x > 1 && x < 5) || (y > 1 && y < 5)) {

		    Arc(hMemwinDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock
		        -xEdge + winxEdge, (y + 1) * yBlock - yEdge +
		        winyEdge, (x + 1) * xBlock - 3 * xEdge / 2 +
		        winxEdge, y * yBlock + 3 * yEdge / 2 + winyEdge,
		         x * xBlock + 3 * xEdge / 2 + winxEdge, (y
		        + 1) * yBlock - 3 * yEdge / 2 + winyEdge);

		}
	    }


	SelectObject(hMemwinDC, hLtwpen);

	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if ((x > 1 && x < 5) || (y > 1 && y < 5)) {
		    Arc(hMemwinDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock
		        -xEdge + winxEdge, (y + 1) * yBlock - yEdge +
		        winyEdge, x * xBlock + 3 * xEdge / 2 + winxEdge,
		         (y + 1) * yBlock - 3 * yEdge / 2 + winyEdge,
		         (x + 1) * xBlock - 3 * xEdge / 2 + winxEdge,
		         y * yBlock + 3 * yEdge / 2 + winyEdge);

		}
	    }


	BitBlt(hDC, 0, 0, xClient, yClient, hMemwinDC , 0, 0, SRCCOPY);

	/*Get a picture of an empty board*/
	SelectObject(hBoardDC, hBoardBitmap);
	BitBlt(hBoardDC, 0, 0, xClient, yClient, hMemwinDC , 0,
	     0, SRCCOPY);




	for (x = 0; x < DIVISIONS; x++)
	    for (y = 0; y < DIVISIONS; y++) {
		if (bState[x][y]) {


		    SelectObject(hDC, hDkgrypen);
		    SelectObject(hDC, hDkgrybrush);
		    Ellipse(hDC, x * xBlock + xEdge + xShadow +
		        winxEdge, y * yBlock + yEdge + yShadow + winyEdge,
		         (x + 1) * xBlock - xEdge + xShadow + winxEdge,
		          (y + 1) * yBlock - yEdge + yShadow + winyEdge);

		    SelectObject(hDC, hBlkpen);
		    SelectObject(hDC, hBbrush);
		    Ellipse(hDC, x * xBlock + xEdge + winxEdge,
		         y * yBlock + yEdge + winyEdge, (x + 1) * xBlock -
		        xEdge + winxEdge,  (y + 1) * yBlock - yEdge +
		        winyEdge);

		    SelectObject(hDC, hWpen);
		    Arc(hDC, x * xBlock + xEdge + xShadow + winxEdge,
		         y * yBlock + yEdge + yShadow + winyEdge, (x
		        + 1) * xBlock - xEdge - xShadow + winxEdge,
		          (y + 1) * yBlock - yEdge - yShadow + winyEdge ,
		         x * xBlock + xHalf + winxEdge , y * yBlock +
		        yShadow + winyEdge, x * xBlock + xShadow +
		        winxEdge, y * yBlock + yHalf + winyEdge);

		}
	    }

	BitBlt(hMemwinDC, 0, 0, xClient, yClient, hDC, 0, 0, SRCCOPY);


	EndPaint(hWnd, &ps);
	fignorelbutton = 0;
	fmousefocusd = 0;

	if (foomed) {
	    MessageBox(hWnd, "Not Enough Memory to Re-size Window",
	         szAppName, MB_ICONASTERISK | MB_OK);
	    foomed = 0;
	}

	break;

    case WM_DESTROY:
	if (hBitmap)
	    DeleteObject (hBitmap) ;
	KillTimer (hWnd, 1) ;


	SelectObject(hIntDC, hOldIntBitmap);
	DeleteDC(hIntDC);

	SelectObject(hMemwinDC, hOldWBitmap);
	DeleteDC(hMemwinDC);

	SelectObject(hBoardDC, hOldBoardBitmap);
	DeleteDC(hBoardDC);

	DeleteObject(hBoardBitmap);
	DeleteObject(hOldBoardBitmap);

	DeleteObject(hWBitmap);
	DeleteObject(hOldWBitmap);


	DeleteObject(hIntBitmap);
	DeleteObject(hOldIntBitmap);

	DeleteObject(hBbrush);
	DeleteObject(hBlkpen);
	DeleteObject(hBlkbrush);
	DeleteObject(hDkgrybrush);
	DeleteObject(hDkgrypen);
	DeleteObject(hGbrush);
	DeleteObject(hMedgrypen);
	DeleteObject(hMedgrybrush);
	DeleteObject(hLtgrybrush);
	DeleteObject(hLtgrypen);
	DeleteObject(hLtwpen);

	DeleteObject(hThkdkgrypen);
	DeleteObject(hWpen);
	DeleteObject(hYbrush);

	WinHelp(hWnd, HELP_FILE, HELP_QUIT, (ULONG_PTR) NULL);

	switch (wprevmenuitem) {
	case 3:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR) "Option",
	         (LPSTR)"3", (LPSTR)"entpack.ini"  );
	    break;

	case 4:
	    WritePrivateProfileString( (LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR) "4", (LPSTR)"entpack.ini"  );
	    break;

	case 5:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"5", (LPSTR)"entpack.ini"  );
	    break;

	case 6:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"6", (LPSTR)"entpack.ini"  );
	    break;

	case 7:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"7", (LPSTR)"entpack.ini");
	    break;

	case 8:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"8", (LPSTR)"entpack.ini");
	    break;

	case 9:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"9", (LPSTR)"entpack.ini");
	    break;

	default:
	    WritePrivateProfileString((LPSTR)"Pegged", (LPSTR)"Option",
	         (LPSTR)"3", (LPSTR)"entpack.ini"  );
	    break;
	}
	PostQuitMessage (0) ;
	break ;

    default:
	return DefWindowProc (hWnd, iMessage, wParam, lParam) ;
    }
    return 0L ;
}


VOID checkfvmove()


{
    if (ixupblock == ixdownblock)
	if ((iyupblock == iydownblock - 2) || (iyupblock == iydownblock +
	    2)) {
	    ixjumpedblock = ixupblock;
	    if (iyupblock == iydownblock - 2)
		iyjumpedblock = iydownblock - 1;
	    if (iyupblock == iydownblock + 2)
		iyjumpedblock = iydownblock + 1;

	    if (bState[ixjumpedblock][iyjumpedblock]) {
		fvalidmove = 1;
		ixkilledblock = ixupblock;
		if (iyupblock == iydownblock - 2)
		    iykilledblock = iydownblock - 1;
		if (iyupblock == iydownblock + 2)
		    iykilledblock = iydownblock + 1;
	    }
	}
    if (iyupblock == iydownblock)
	if ((ixupblock == ixdownblock - 2) || (ixupblock == ixdownblock +
	    2)) {
	    iyjumpedblock = iyupblock;
	    if (ixupblock == ixdownblock - 2)
		ixjumpedblock = ixdownblock - 1;
	    if (ixupblock == ixdownblock + 2)
		ixjumpedblock = ixdownblock + 1;


	    if (bState[ixjumpedblock][iyjumpedblock]) {
		fvalidmove = 1;
		iykilledblock = iyupblock;
		if (ixupblock == ixdownblock - 2)
		    ixkilledblock = ixdownblock - 1;
		if (ixupblock == ixdownblock + 2)
		    ixkilledblock = ixdownblock + 1;
	    }
	}
    return;


}


VOID checkfanymoves()
{
    /*corners*/
    if (bState[2][0]) {
	if (bState[3][0])
	    if (!bState[4][0])
		fanymoremoves = 1;
	if (bState[2][1])
	    if (!bState[2][2])
		fanymoremoves = 1;
    }


    if (bState[4][0]) {
	if (bState[3][0])
	    if (!bState[2][0])
		fanymoremoves = 1;
	if (bState[4][1])
	    if (!bState[4][2])
		fanymoremoves = 1;
    }

    if (bState[0][2]) {
	if (bState[1][2])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[0][3])
	    if (!bState[0][4])
		fanymoremoves = 1;
    }


    if (bState[0][4]) {
	if (bState[0][3])
	    if (!bState[0][2])
		fanymoremoves = 1;
	if (bState[1][4])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }

    if (bState[2][6]) {
	if (bState[3][6])
	    if (!bState[4][6])
		fanymoremoves = 1;
	if (bState[2][5])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }

    if (bState[4][6]) {
	if (bState[3][6])
	    if (!bState[2][6])
		fanymoremoves = 1;
	if (bState[4][5])
	    if (!bState[4][4])
		fanymoremoves = 1;
    }

    if (bState[6][4]) {
	if (bState[5][4])
	    if (!bState[4][4])
		fanymoremoves = 1;
	if (bState[6][3])
	    if (!bState[6][2])
		fanymoremoves = 1;
    }

    if (bState[6][2]) {
	if (bState[5][2])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[6][3])
	    if (!bState[6][4])
		fanymoremoves = 1;
    }

    /* center ends */

    if (bState[3][0]) {
	if (bState[3][1])
	    if (!bState[3][2])
		fanymoremoves = 1;
    }

    if (bState[0][3]) {
	if (bState[1][3])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }

    if (bState[3][6]) {
	if (bState[3][5])
	    if (!bState[3][4])
		fanymoremoves = 1;
    }

    if (bState[6][3]) {
	if (bState[5][3])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }

    /*center sides */
    if (bState[2][1]) {
	if (bState[3][1])
	    if (!bState[4][1])
		fanymoremoves = 1;
	if (bState[2][2])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }

    if (bState[1][2]) {
	if (bState[2][2])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[1][3])
	    if (!bState[1][4])
		fanymoremoves = 1;
    }
    if (bState[1][4]) {
	if (bState[2][4])
	    if (!bState[3][4])
		fanymoremoves = 1;
	if (bState[1][3])
	    if (!bState[1][2])
		fanymoremoves = 1;
    }
    if (bState[2][5]) {
	if (bState[3][5])
	    if (!bState[4][5])
		fanymoremoves = 1;
	if (bState[2][4])
	    if (!bState[2][3])
		fanymoremoves = 1;
    }
    if (bState[4][5]) {
	if (bState[3][5])
	    if (!bState[2][5])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }
    if (bState[5][4]) {
	if (bState[4][4])
	    if (!bState[3][4])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[5][2])
		fanymoremoves = 1;
    }
    if (bState[5][2]) {
	if (bState[4][2])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[5][4])
		fanymoremoves = 1;
    }
    if (bState[4][1]) {
	if (bState[3][1])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[4][3])
		fanymoremoves = 1;
    }

    /* inside center arms */

    if (bState[3][1]) {
	if (bState[3][2])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[1][3]) {
	if (bState[2][3])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[3][5]) {
	if (bState[3][4])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }

    if (bState[5][3]) {
	if (bState[4][3])
	    if (!bState[3][3])
		fanymoremoves = 1;
    }


    /*Center 9 squares */
    if (bState[2][2]) {
	if (bState[1][2])
	    if (!bState[0][2])
		fanymoremoves = 1;
	if (bState[3][2])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[2][1])
	    if (!bState[2][0])
		fanymoremoves = 1;
	if (bState[2][3])
	    if (!bState[2][4])
		fanymoremoves = 1;
    }
    if (bState[3][2]) {
	if (bState[2][2])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[5][2])
		fanymoremoves = 1;
	if (bState[3][1])
	    if (!bState[3][0])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[3][4])
		fanymoremoves = 1;
    }
    if (bState[4][2]) {
	if (bState[3][2])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[5][2])
	    if (!bState[6][2])
		fanymoremoves = 1;
	if (bState[4][1])
	    if (!bState[4][0])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[4][4])
		fanymoremoves = 1;
    }
    if (bState[2][3]) {
	if (bState[1][3])
	    if (!bState[0][3])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[4][3])
		fanymoremoves = 1;
	if (bState[2][2])
	    if (!bState[2][1])
		fanymoremoves = 1;
	if (bState[2][4])
	    if (!bState[2][5])
		fanymoremoves = 1;
    }
    if (bState[2][4]) {
	if (bState[1][4])
	    if (!bState[0][4])
		fanymoremoves = 1;
	if (bState[3][4])
	    if (!bState[4][4])
		fanymoremoves = 1;
	if (bState[2][3])
	    if (!bState[2][2])
		fanymoremoves = 1;
	if (bState[2][5])
	    if (!bState[2][6])
		fanymoremoves = 1;
    }
    if (bState[3][4]) {
	if (bState[2][4])
	    if (!bState[1][4])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[5][4])
		fanymoremoves = 1;
	if (bState[3][3])
	    if (!bState[3][2])
		fanymoremoves = 1;
	if (bState[3][5])
	    if (!bState[3][6])
		fanymoremoves = 1;
    }
    if (bState[4][4]) {
	if (bState[3][4])
	    if (!bState[2][4])
		fanymoremoves = 1;
	if (bState[5][4])
	    if (!bState[6][4])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[4][2])
		fanymoremoves = 1;
	if (bState[4][5])
	    if (!bState[4][6])
		fanymoremoves = 1;
    }
    if (bState[4][3]) {
	if (bState[3][3])
	    if (!bState[2][3])
		fanymoremoves = 1;
	if (bState[5][3])
	    if (!bState[6][3])
		fanymoremoves = 1;
	if (bState[4][2])
	    if (!bState[4][1])
		fanymoremoves = 1;
	if (bState[4][4])
	    if (!bState[4][5])
		fanymoremoves = 1;
    }
    if (bState[3][3]) {
	if (bState[2][3])
	    if (!bState[1][3])
		fanymoremoves = 1;
	if (bState[4][3])
	    if (!bState[5][3])
		fanymoremoves = 1;
	if (bState[3][2])
	    if (!bState[3][1])
		fanymoremoves = 1;
	if (bState[3][4])
	    if (!bState[3][5])
		fanymoremoves = 1;
    }







}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\oldtp\taipei.c ===
/**************************************************************************

                               T A I P E I

                           for Microsoft Windows

                     by David Norris and Hans Spiller


 Revision history:
     We do not do revision histories.
 **************************************************************************/

#include <windows.h>
#include <port1632.h>
#include <time.h>
#include <stdio.h>
#include <math.h>
#include "tp.h"

#define MAXMOVES	72

#define	RED		0x0000ffL
#define GREEN		0x00ff00L
#define BLUE		0xff0000L
#define YELLOW		(GREEN | RED)
#define CYAN		(GREEN | BLUE)
#define PURPLE		(RED | BLUE)
#define	WHITE		(BLUE | GREEN | RED)
#define BLACK		0x000000L

#define BACKGROUND	0x008000

#define TILEX		36
#define TILEY		36
#define SIDESIZE	5
#define BOTTOMSIZE	3

#define NUMTILES	144
#define TILES		42	/* 9 craks, bams, dots; 4 winds, 3 dragons, 4 seasons, 4 flowers */

/*
 *    the points in the tile structure
 *
 *            a--------*
 *           /|        |
 *          d |        |
 *          | |        |
 *          | |        |
 *          | |        |
 *          | b--------c
 *          |/        /
 *          e--------f
 *
 *     these points are filled in by the set_all_points function
 */

struct tile {
    LONG x, y, z;
    BOOL removed;
    POINT a, b, c, d, e, f;
    HBITMAP hbmtile;
    HBITMAP hbmtilebw;
} tiles[NUMTILES], random_move;

INT inverted1 = -1;
INT inverted2 = -1;
INT hint1;
INT hint2;
INT currenthint = 0;

/* variables for hint generation */

struct possible_move {		/* move list */
    DWORD value;
    DWORD tile1;
    DWORD tile2;
} possible_move[NUMTILES];
INT nmoves;			/* number of possible moves */

LONG difficulty = IDDMASTER;
BOOL peeking = FALSE;
INT peektile;
BOOL in_banner_screen = TRUE;
HBITMAP hbmtp;
RECT window;
INT tilewidth, tileheight;

CHAR szAppName[10];
CHAR szAbout[10];
CHAR szMessage[15];

INT move;
DWORD gameseed;
struct {
    INT i, j;
} moves[MAXMOVES];

INT autoplay = FALSE;
INT shaddup = FALSE;
INT color = TRUE;
LONG EdgeColor = GRAY_BRUSH;

DWORD xstart[NUMTILES] =
	{ 2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24,
	          6,  8, 10, 12, 14, 16, 18, 20,
	      4,  6,  8, 10, 12, 14, 16, 18, 20, 22,
	  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24,
      0,                       13,                       26, 28,
	  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24,
	      4,  6,  8, 10, 12, 14, 16, 18, 20, 22,
	          6,  8, 10, 12, 14, 16, 18, 20,
	  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24,

	              8, 10, 12, 14, 16, 18,
	              8, 10, 12, 14, 16, 18,
	              8, 10, 12, 14, 16, 18,
	              8, 10, 12, 14, 16, 18,
	              8, 10, 12, 14, 16, 18,
	              8, 10, 12, 14, 16, 18,

	                 10, 12, 14, 16,
	                 10, 12, 14, 16,
	                 10, 12, 14, 16,
	                 10, 12, 14, 16,

	                     12, 14,
	                     12, 14 };

DWORD ystart[NUMTILES] =
	{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	          2,  2,  2,  2,  2,  2,  2,  2,
	      4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
	  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
      7,                        7,                        7,  7,
	  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
	     10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
	         12, 12, 12, 12, 12, 12, 12, 12,
	 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,

	              2,  2,  2,  2,  2,  2,
	              4,  4,  4,  4,  4,  4,
	              6,  6,  6,  6,  6,  6,
	              8,  8,  8,  8,  8,  8,
	             10, 10, 10, 10, 10, 10,
	             12, 12, 12, 12, 12, 12,

	                  4,  4,  4,  4,
	                  6,  6,  6,  6,
	                  8,  8,  8,  8,
	                 10, 10, 10, 10,

	                      6,  6,
	                      8,  8 };

DWORD zstart[NUMTILES] =
	{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	          0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,                        4,                        0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	          0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

	              1,  1,  1,  1,  1,  1,
	              1,  1,  1,  1,  1,  1,
	              1,  1,  1,  1,  1,  1,
	              1,  1,  1,  1,  1,  1,
	              1,  1,  1,  1,  1,  1,
	              1,  1,  1,  1,  1,  1,

	                  2,  2,  2,  2,
	                  2,  2,  2,  2,
	                  2,  2,  2,  2,
	                  2,  2,  2,  2,

	                      3,  3,
	                      3,  3 };

CHAR *confucius_say[] = {
    "BFD",
    "Woman worth weight in gold probably cost as much",
    "Hope miserable yuppie lose shirt in stock market",
    "Blind elderly woman do better than you",
    "Bouncy ball is source of all goodness and light",
    "Congratulations on winning Taipei!",
    "Have you found ancient Taipei! secret?",
    "Why not try other fine Windows games?",
    "Hope player not strain eyeballs on CGA",
    "Save the Blibbet!",
    "Close female relative wear combat boots",
    "Unlucky to play leapfrog with unicorn",
    "Have you find secret magic Taipei! tile?",
    "Cannot find COURA.FON.  User bite big one!",
    "You are in a maze of twisty little messages, all different.",
    "Plugh",
    "Hello, sailor.",
    "Taipei! written in honorable Macro-80!  Only take three years!",
    "For a good time, call (206) 882-8080",
    "He's dead, Jim.",
    "Greppings!",
    "Frac hands the Glyph of Bogosity to the monk.",
    "Wherever you go, there you are.",
    "I think not (poof!)",
    "...and that, my Liege, is how we know the earth to be banana shaped.",
    "Introducing Taipei!, the first in a series of self-pimping software!",

};
#define MAXCONFUCIUSSAY	(sizeof(confucius_say) / sizeof (char *))

static HANDLE hInst;
HCURSOR hourglasscursor;
HCURSOR crosscursor;
HCURSOR arrowcursor;
HCURSOR currentcursor;

LRESULT  APIENTRY TaipeiWndProc(HWND, UINT, WPARAM, LPARAM);

extern VOID srand(LONG);
extern INT rand(VOID);
VOID set_title(HWND);
VOID evaluate_board(VOID);
VOID draw_tile(
    HDC hDC,
    HDC TileDC,
    INT i,
    INT x,
    INT y,
    HWND hwnd);

INT find_tile(
    DWORD x,
    DWORD y,
    DWORD z)
{
    register INT i;
    register struct tile *t;

    for (i = 0, t = tiles; i < NUMTILES; i++, t++) {
        if (t->x == (INT) x && t->y == (INT) y && t->z == (INT) z && !t->removed)
            return(i);
    }
    return(-1);
}

INT_PTR  APIENTRY About(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    if (message == WM_COMMAND) {
        EndDialog( hDlg, TRUE );
        return TRUE;
        }
    else if (message == WM_INITDIALOG)
        return TRUE;
    else return FALSE;
}

INT_PTR  APIENTRY TileHelpDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC TileDC;
    HDC hDC;
    static INT current_suit = IDCRAKS;
    INT i;
    PAINTSTRUCT ps;

    switch (message) {
		case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    break;

				case IDCRAKS:
				case IDBAMS:
				case IDDOTS:
				case IDDRAGONS:
				case IDSEASONS:
				case IDFLOWERS:
				case IDWINDS:
        		    CheckRadioButton(hDlg, IDCRAKS, IDWINDS,
					current_suit = GET_WM_COMMAND_ID(wParam, lParam));
				    InvalidateRect(hDlg, (LPRECT) NULL, TRUE);
		            break;

		        default:
		            return FALSE;
            }
         	break;

        case WM_INITDIALOG:
            CheckRadioButton(hDlg, IDCRAKS, IDWINDS, current_suit);
            return TRUE;

		case WM_PAINT:
		    BeginPaint( hDlg, (LPPAINTSTRUCT)&ps );
		    hDC = GetDC(hDlg);
		    TileDC = CreateCompatibleDC(hDC);
		    switch (current_suit) {
	            case IDCRAKS:
		    case IDBAMS:
		    case IDDOTS:
	            	for (i = 0; i < 5; i++)
			    draw_tile(hDC, TileDC, i + (current_suit - IDCRAKS)*36, 30 + i * 75, 25, hDlg);
		        for (i = 5; i < 9; i++)
			    draw_tile(hDC, TileDC, i + (current_suit - IDCRAKS)*36, 70 + (i-5) * 75, 80, hDlg);
		        break;

		    case IDWINDS:
        	        for (i = 0; i < 4; i++)
			    draw_tile(hDC, TileDC, i + 108, 70 + i * 75, 55, hDlg);
			break;

		    case IDDRAGONS:
	            	for (i = 0; i < 3; i++)
			    draw_tile(hDC, TileDC, i + 124, 100 + i * 75, 55, hDlg);
		        break;

		    case IDSEASONS:
	            	for (i = 0; i < 4; i++)
			    draw_tile(hDC, TileDC, i + 136, 70 + i * 75, 55, hDlg);
			break;

		    case IDFLOWERS:
	                for (i = 0; i < 4; i++)
			    draw_tile(hDC, TileDC, i + 140, 70 + i * 75, 55, hDlg);
		        break;

	    	}
		    DeleteDC(TileDC);
		    ReleaseDC(hDlg, hDC);
		    EndPaint( hDlg, (LPPAINTSTRUCT)&ps );
            return FALSE;

        default:
            return FALSE;
    }

    return FALSE;
}

INT_PTR  APIENTRY PeekDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    DWORD i;
    HDC TileDC;
    HDC hDC;
    PAINTSTRUCT ps;
    register struct tile *t;

    switch (message) {
	case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
                }
            break;

        case WM_INITDIALOG:
            return TRUE;

	case WM_PAINT:
	    BeginPaint( hDlg, (LPPAINTSTRUCT)&ps );
	    hDC = GetDC(hDlg);
	    TileDC = CreateCompatibleDC(hDC);
	    i = 0;
	    while (peektile != -1) {
		t = &tiles[peektile];
		draw_tile(hDC, TileDC, peektile, 70 + i++ * 75, 55, hDlg);
	        peektile = find_tile(t->x, t->y, t->z - 1);
	    }
	    DeleteDC(TileDC);
	    ReleaseDC(hDlg, hDC);
	    EndPaint( hDlg, (LPPAINTSTRUCT)&ps );
            return FALSE;

        default:
            return FALSE;
    }

    return FALSE;
}

INT_PTR  APIENTRY SelectGameDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fValOk;
    DWORD i;

    switch (message) {
	case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
		    i = GetDlgItemInt(hDlg, IDGAMENUMBER, (BOOL*)&fValOk, TRUE );
		    srand(gameseed = i);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return FALSE;
                }
            break;

	        case WM_INITDIALOG:
			    SetDlgItemText(hDlg, IDGAMENUMBER, (LPSTR)"1");
            	return TRUE;

	        default:
    	        return FALSE;
    }

    return FALSE;
}

/* convert tile number (0:NUMTILES-1) to bitmap number (0:41) */

INT bmtile(
    register INT x)
{
    if (x < 36)
        return (x % 9);		/* 9 craks */
    else if (x < 72)
        return (9 + x % 9);	/* 9 bams */
    else if (x < 108)
        return (18 + x % 9);	/* 9 dots */
    else if (x < 124)
        return (27 + x % 4);	/* 4 winds */
    else if (x < 136)
        return (31 + x % 3);	/* 3 dragons */
    else
        return (34 + x % 8);	/* seasons and flowers */
}

/* returns TRUE if a and b are a pair */

BOOL compare(
    register INT a,
    register INT b)
{
    a = bmtile(a);
    b = bmtile(b);

    if (a < 34)
        return (b == a);		/* exact match */
    if (a < 38)
        return (b >= 34 && b < 38);	/* any 2 seasons */
    else
        return (b >= 38);		/* any 2 flowers */
}

/* returns TRUE if tile is free */

static INT blibtab[4] = {0};

BOOL isfree(
    INT i)
{
    register struct tile *t;

    t = &tiles[i];

    if (t->z == 4)
        return(TRUE);
    else if (t->z == 3) {
        return (find_tile(13, 7, 4) == -1);
    } else {
        if (find_tile(t->x - 2, t->y, t->z) == -1 ||
            find_tile(t->x + 2, t->y, t->z) == -1) {
            if (t->x == 2) {
                if (t->y == 6 || t->y == 8) {
                    return (find_tile(0, 7, 0) == -1);
                } else {
                    return(TRUE);
                }
            } else if (t->x == 24) {
                if (t->y == 6 || t->y == 8) {
                    return (find_tile(26, 7, 0) == -1);
                } else {
                    return(TRUE);
                }
            } else if (t->x == 26) {
                return (find_tile(28, 7, 0) == -1);
            } else
                return(find_tile(t->x, t->y, t->z + 1) == -1);
        } else {
            return(FALSE);
        }
    }
}

/* convert screen x,y into tile number (-1 if no tile) */

INT xytotile(
    LONG xpos,
    LONG ypos)
{
    register struct tile *t;
    register INT i, z;

    for (z = 4; z >= 0; z--) {
        for (i = 0, t = tiles; i < NUMTILES; i++, t++) {
            if (t->z == z) {
                if (ypos >= t->a.y && ypos <= t->e.y && xpos >= t->e.x && xpos <= t->c.x && !t->removed) {
                    return(i);
                }
            }
        }
    }
    return(-1);
}

VOID pointset(
    register struct tile *t,
    INT basex,
    INT basey,
    INT z)
{
    t->a.x = t->b.x = basex + z * SIDESIZE;
    t->c.x = t->a.x + tilewidth - 1;

    t->a.y = basey - z * BOTTOMSIZE;
    t->b.y = t->c.y = t->a.y + tileheight - 1;

    t->d.y = basey - (z-1)*BOTTOMSIZE;
    t->e.y = t->f.y = t->d.y + tileheight;

    t->d.x = t->e.x = basex + (z-1)*SIDESIZE;
    t->f.x = t->e.x + tilewidth - 1;
}

VOID set_points(
    register struct tile *t)
{
    pointset(t, t->x*tilewidth/2+tilewidth*2, t->y*tileheight/2+5, t->z);
}

VOID set_all_points()
{
    register struct tile *t;
    register INT i;

    for (i = 0, t = tiles; i < NUMTILES; i++, t++) {
        if (!t->removed)
            set_points(t);
    }
}

VOID draw_side(
    HDC hDC,
    register struct tile *t)
{
    POINT side[4];

    side[0] = t->a;
    side[1] = t->d;
    side[2] = t->e;
    side[3] = t->b;
    Polygon(hDC, side, 4);
}

VOID draw_bottom(
    HDC hDC,
    register struct tile *t)
{
    POINT side[4];

    side[0] = t->b;
    side[1] = t->e;
    side[2] = t->f;
    side[3] = t->c;
    Polygon(hDC, side, 4);
}

VOID invert_tile(
    HDC hDC,
    INT i)
{
    register struct tile *t;
    RECT rect;

    t = &tiles[i];
    SetRect((LPRECT)&rect, t->a.x, t->a.y, t->c.x, t->c.y);
    InvertRect(hDC, (LPRECT)&rect);
}

VOID uninvert_all(
    HDC hDC)
{
    if (inverted1 != -1)
        invert_tile(hDC, inverted1);
    if (inverted2 != -1)
        invert_tile(hDC, inverted2);
    inverted1 = inverted2 = -1;
}

VOID draw_tile(
    HDC hDC,
    HDC TileDC,
    INT i,
    INT x,
    INT y,
    HWND hwnd)
{
    register struct tile *t;
    register z;
    struct tile loosetile;
    HBRUSH hbr, hbrold;
    HMENU hMenu;

    t = &tiles[i];

    SelectObject(TileDC, tiles[bmtile(i)].hbmtile);
    if (color) {
        if(!SelectObject(TileDC, tiles[bmtile(i)].hbmtile)) {
	    hMenu = GetMenu(hwnd);
	    CheckMenuItem(hMenu, IDDCOLOR, MF_UNCHECKED);
	    EnableMenuItem(hMenu, IDDCOLOR, MF_GRAYED);
	    SelectObject(TileDC, tiles[bmtile(i)].hbmtilebw);
	}
    } else
	SelectObject(TileDC, tiles[bmtile(i)].hbmtilebw);

    StretchBlt(hDC,
               x ? x : t->x * tilewidth / 2 + tilewidth * 2 + t->z*SIDESIZE,
               x ? y : t->y * tileheight / 2 + 5 - t->z*BOTTOMSIZE,
               tilewidth,
               tileheight,
               TileDC, 0, 0,
               TILEX,
               TILEY,
               SRCCOPY);

    hbrold = (HBRUSH)SelectObject(hDC, (HANDLE)(hbr=(HBRUSH)GetStockObject(EdgeColor)));

    /* draw left side(s) */

    if (!x) {
        if (t->z == 4) {
            draw_side(hDC, t);
        } else if (t->x == 26) {
            if (find_tile(24, t->y - 1, 0) == -1 && find_tile(24, t->y + 1, 0) == -1)
                draw_side(hDC, t);
        } else if (t->x == 28) {
            if (find_tile(26, t->y, 0) == -1)
                draw_side(hDC, t);
        } else {
            z = t->z;
            while (z >= 0 && (i = find_tile(t->x - 2, t->y, z)) == -1) {
                draw_side(hDC, &tiles[find_tile(t->x, t->y, z)]);
                z--;
            }
        }

        /* draw bottom side(s) */

        if (t->z == 4) {
            draw_bottom(hDC, t);
        } else if (t->x > 24) {
            draw_bottom(hDC, t);
        } else {
            z = t->z;
            while (z >= 0 && (i = find_tile(t->x, t->y + 2, z)) == -1) {
                draw_bottom(hDC, &tiles[find_tile(t->x, t->y, z)]);
                z--;
            }
        }
    } else {
        loosetile.x = x;
        loosetile.y = y;
        loosetile.z = 0;
        t = &loosetile;
	pointset(t, x, y, 0);
        draw_side(hDC, t);
        draw_bottom(hDC, t);
    }
    SelectObject(hDC, hbrold);
    DeleteObject(hbr);
}

VOID set_tile_status(
    HWND hWnd,
    INT i,
    INT status)
{
    register struct tile *t;
    RECT updaterect;

    t = &tiles[i];
    t->removed = status;

    updaterect.top = t->a.y - 1;
    updaterect.bottom = t->e.y + 1;
    updaterect.left = t->e.x - 1;
    updaterect.right = t->c.x + 1;
    InvalidateRect(hWnd, (LPRECT) &updaterect, TRUE);
}

VOID TaipeiPaint(
    HDC hDC,
    LPPAINTSTRUCT pps,
    HWND hwnd)
{
    register struct tile *t;
    register INT i, x, y, z;
    HDC TileDC;
    HBRUSH hbr, hbrold;

    hbrold = SelectObject(hDC, hbr = (HBRUSH)GetStockObject( WHITE_BRUSH ));
    TileDC = CreateCompatibleDC(hDC);

    if ((i = find_tile(26, 7, 0)) != -1)
        draw_tile(hDC, TileDC, i, 0, 0, hwnd);
    if ((i = find_tile(28, 7, 0)) != -1)
        draw_tile(hDC, TileDC, i, 0, 0, hwnd);
    for (y = 0; y <= 14; y += 2) {
        for (x = 24; x >= 0; x -= 2) {
            for (z = 3; z >= 0; z--) {
                if ((i = find_tile(x, y, z)) != -1) {
                    t = &tiles[i];
                    if (t->e.x > pps->rcPaint.right ||
                        t->c.x < pps->rcPaint.left ||
                        t->a.y > pps->rcPaint.bottom ||
                        t->e.y < pps->rcPaint.top)
                        break;
                    else
                        draw_tile(hDC, TileDC, i, 0, 0, hwnd);
                    break;
                }
            }
        }
    }
    if ((i = find_tile(0, 7, 0)) != -1)
        draw_tile(hDC, TileDC, i, 0, 0, hwnd);
    if ((i = find_tile(13, 7, 4)) != -1)
        draw_tile(hDC, TileDC, i, 0, 0, hwnd);

    SelectObject(hDC, hbrold);
    DeleteObject(hbr);
    DeleteDC(TileDC);
}

struct board {
    DWORD x, y, z;
    BOOL used;
} board[NUMTILES];

BOOL is_legal_backmove(
    INT i)
{
    register INT j, z;

    /* check for piece(s) underneath (they better all be there...) */
    /* except for special row */

    if (board[i].y != 7) {
        for (z = board[i].z-1; z >= 0; z--) {
            if (find_tile(board[i].x, board[i].y, z) == -1)
                return(FALSE);
        }
    }

    /* check for adjacent piece or free row */
    /* if no tile to left or right, whole row must be empty */
    /* unless it's the special row seven under special cases */

    if (find_tile(board[i].x - 2, board[i].y, board[i].z) == -1 &&
        find_tile(board[i].x + 2, board[i].y, board[i].z) == -1 &&
        board[i].y != 7) {
        for (j = 0; j < 28; j+=2) {
            if (find_tile(j, board[i].y, board[i].z) != -1)
                return(FALSE);
        }
    }

    /* special cases */

    if (board[i].y == 7) {
        switch (board[i].x) {
            case 0:
                return (find_tile(2, 6, 0) != -1 && find_tile(2, 8, 0) != -1);
            case 13:
                return (find_tile(12, 6, 3) != -1 &&
                        find_tile(12, 6, 3) != -1 &&
                        find_tile(14, 8, 3) != -1 &&
                        find_tile(14, 8, 3) != -1);
            case 26:
                return (find_tile(24, 6, 0) != -1 && find_tile(24, 8, 0) != -1);
            case 28:
                return (find_tile(26, 7, 0) != -1);
        }
    }
    return(TRUE);
}

INT num_legal_moves;

INT generate_random_move()
{
    register INT i, j;
    DWORD legal_move[NUMTILES];

    num_legal_moves = 0;
    for (i = 0; i < NUMTILES; i++) {
/*	if (legal_move[i] = (!board[i].used && is_legal_backmove(i)))*/
	if (legal_move[i] = (!board[i].used))
	    num_legal_moves++;
    }

    if (num_legal_moves) {
	i = rand() % num_legal_moves;
	for (j = 0; j < NUMTILES; j++) {
	    if (legal_move[j]) {
	        if (i)
	            i--;
	        else
	            return(j);
	    }
	}
    }
    return(-1);
}

VOID place_tile(
    INT tile,
    INT pos)
{
    register struct tile *t;

    t = &tiles[tile];
    t->x = board[pos].x;
    t->y = board[pos].y;
    t->z = board[pos].z;
    t->removed = FALSE;
    board[pos].used = TRUE;
    set_points(t);
}

VOID wipe_screen(
    HWND hWnd)
{
    register INT i;

    for (i = 0; i < NUMTILES; i++)
	tiles[i].removed = TRUE;
    InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
    UpdateWindow(hWnd);
}

/*
 *  NEW_GAME
 *
 *  To generate a new game, tiles and moves are shuffled and played
 *  backwards, thus ensuring that every board created is playable.
 */

VOID new_game(
    HWND hWnd)
{
    register INT i, j, k, laid, temp;
    register struct tile *t;
    INT backplay[NUMTILES];
    HCURSOR holdCursor;
    HDC hDC = GetDC(hWnd);

#ifdef DEBUG
    HDC TileDC = CreateCompatibleDC(hDC);
#endif

    wipe_screen(hWnd);
    holdCursor = SetCursor(hourglasscursor);

    /******************************************************/
    /* first, decide what tiles are to be played backward */
    /*        (but not where they are to be played)       */
    /******************************************************/

    /* initialize the backward play array with tiles */
    for (i = 0; i < NUMTILES; i++)
        backplay[i] = i;

    /* shuffle the backward play array around */
    for (i = 0; i < NUMTILES; i++) {
        while ((j = rand() % (NUMTILES)) == i);
        temp = backplay[j];
        backplay[j] = backplay[i];
        backplay[i] = temp;
    }

    /*****************************************************/
    /* next, decide what moves are to be played backward */
    /*****************************************************/

    /* loop until we can create a usable board */

    do {
        /* remove all tiles */

        laid = 0;
        for (i = 0, t = tiles; i < NUMTILES; i++, t++)
            t->removed = TRUE;

        /* initialize the board position array */

        for (i = 0; i < NUMTILES; i++) {
            board[i].x = xstart[i];
            board[i].y = ystart[i];
            board[i].z = zstart[i];
            board[i].used = FALSE;
        }

        /*******************************************************************/
        /* now play the tiles in backward order to create a playable board */
        /*******************************************************************/

        for (i = 0; i < NUMTILES; i++) {
            /* find a free move */

            if ((j = generate_random_move()) == -1)
                break;

            /* get next tile to place */

            while (!tiles[backplay[i]].removed) {
                i++;
                if (i >= NUMTILES)
                    goto board_done;
            }

            /* find a matching tile */

            temp = 0;
            while(!compare(backplay[i], temp) || !tiles[temp].removed || temp == backplay[i]) {
                temp++;
                if (temp >= NUMTILES)
                    goto board_done;
            }
            place_tile(backplay[i], j);

            /* find a valid move */

            k = j;
            while (j == k) {
                if ((k = generate_random_move()) == -1)
                    goto board_done;
            }
            place_tile(temp, k);

            laid += 2;
#ifdef DEBUG
            DebugBreak();
            draw_tile(hDC, TileDC, backplay[i], 0, 0, hwnd);
            draw_tile(hDC, TileDC, temp, 0, 0, hwnd);
#endif

        }
board_done:;

    } while (laid < NUMTILES);

#ifdef DEBUG
    DeleteDC(TileDC);
#endif

    move = 0;
    evaluate_board();
    currenthint = nmoves;

    SetCursor(holdCursor);
    ReleaseDC(hWnd, hDC);
    set_all_points();
    set_title(hWnd);
    in_banner_screen = FALSE;
    InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
}

INT blocks(
    register struct tile *t)
{
    if (find_tile(t->x - 2, t->y, t->z) == -1) {
	if (find_tile(t->x+2, t->y, t->z) == -1 ||
	    find_tile(t->x+4, t->y, t->z) == -1)
	    return (-5);
    } else if (find_tile(t->x + 2, t->y, t->z) == -1) {
	if (find_tile(t->x-2, t->y, t->z) == -1 ||
	    find_tile(t->x - 4, t->y, t->z) == -1)
	    return (-5);
    }
    return (0);
}

INT frees(
    register struct tile *t)
{
    if (t->z != 0) {
        if (find_tile(t->x+2, t->y, t->z-1) == -1 ||
	    find_tile(t->x-2, t->y, t->z-1) == -1)
	    return (5);
    }
    return (0);
}

/*
 *  EVALUATE_MOVE
 *
 *  This routine returns the value of a given move, based on the
 *  following criteria:
 *
 *  Other two matching tiles already removed, or
 *  Other two matching tiles also free:         100 points
 *  Tile is the top tile:                        20 points
 *  Tile is one of the end blocking tiles:       10 points
 *  Tile stands alone or next to a single tile:  -5 points
 *  Tiles are toward the end of the dragon:    0-14 points
 *  Move frees another tile                       5 points
 *  Move frees two tiles                         10 points
 */

evaluate_move(
    INT	move)
{
    register INT i;
    INT move_value = 0;

    /******************* GOOD MOVES ********************/

    /* search for four free matching tiles, or two free with the
       other two removed */
    /* has a match to a move list tile already been removed? */

    for (i = 0; i < NUMTILES; i++) {
	if (i != (INT) possible_move[move].tile1 && i != (INT) possible_move[move].tile2) {
	    if (compare(possible_move[move].tile1, i) && tiles[i].removed) {
		move_value += 100;
		break;
	    }
	}
    }

    /* are all four tiles in the move list? */

    for (i = move + 1; i < nmoves; i++) {
	if (compare(possible_move[move].tile1, possible_move[i].tile1)) {
	    move_value += 100;
	    break;
	}
    }

    /* bonus if it's the top tile */

    if (tiles[possible_move[move].tile1].z == 4 || tiles[possible_move[move].tile2].z == 4)
	move_value += 10;

    /* bonus if it's in the center (top/rightmost/leftmost tiles,
       which block many other tiles) */

    if (tiles[possible_move[move].tile1].y == 7 ||
	tiles[possible_move[move].tile2].y == 7)
	move_value += 10;

    /* generally better if tiles are on the end */

    move_value += abs(tiles[possible_move[move].tile1].x - 14)/2;
    move_value += abs(tiles[possible_move[move].tile2].x - 14)/2;

    /* good if move frees tiles */

    move_value += frees(&tiles[possible_move[move].tile1]);
    move_value += frees(&tiles[possible_move[move].tile2]);

    /******************* BAD MOVES ********************/

    /* bad if one of the tiles isn't blocking anything */

    move_value += blocks(&tiles[possible_move[move].tile1]);
    move_value += blocks(&tiles[possible_move[move].tile2]);

    return(move_value);
}

VOID swap(
    INT i,
    INT j)
{
    struct possible_move temp;

    temp = possible_move[i];
    possible_move[i] = possible_move[j];
    possible_move[j] = temp;
}

VOID quicksort(
    INT low,
    INT high)
{
    INT index, pivot, i, j;

    if (low < high) {
	if (high - low == 1) {
	    if (possible_move[low].value > possible_move[high].value)
	        swap(low, high);
	} else {
	    index = (high - low) / 2;
	    swap(high, index);
	    pivot = possible_move[high].value;
	    do {
		i = low;
		j = high;
		while (i < j && (INT) possible_move[i].value <= pivot)
		    i++;
		while (j > i && (INT) possible_move[j].value >= pivot)
		    j--;
		if (i < j)
		    swap(i, j);
	    } while (i < j);
	    swap(i, high);

	    if (i - low < high - i) {
	        quicksort(low, i-1);
	        quicksort(i+1, high);
	    } else {
	        quicksort(i+1, high);
	        quicksort(low, i-1);
	    }
	}
    }
}

/*
   improved Taipei hint mechanism.  It will try to find some smart
   moves before it reverts to the standard move.

   evaluate_board fills the possible_move array with all possible
   moves and their values given the current board position.
*/

VOID evaluate_board()
{
    register INT i, j;
    register struct tile *t, *u;
    CHAR freetiles[NUMTILES];

    /* create a "free tile" array for speedy hint processing */

    for (i = 0; i < NUMTILES; i++)
	freetiles[i] = (CHAR) isfree(i);

    /* create a list of possible moves */

    for (nmoves = 0, i = 0, t = tiles; i < NUMTILES; i++, t++) {
        if (!t->removed && freetiles[i]) {
	    j = i+1;
            for ( u = t + 1; j < NUMTILES; j++, u++) {
                if (!u->removed && freetiles[j]) {
                    if (compare(i, j)) {
                        possible_move[nmoves].tile1 = i;
                        possible_move[nmoves].tile2 = j;
                        possible_move[nmoves].value = evaluate_move(nmoves);
                        nmoves++;
                    }
                }
            }
        }
    }

    /* now, sort the possible move list */

    quicksort(0, nmoves-1);
}

BOOL find_hint()
{

    /* return best move */

    if (currenthint != 0) {
	currenthint--;
	hint1 = possible_move[currenthint].tile1;
	hint2 = possible_move[currenthint].tile2;
	return(TRUE);
    } else
	return(FALSE);
}

BOOL hint(
    HWND hWnd)
{
    if (find_hint())
	return(TRUE);

    currenthint = nmoves;

    if (!shaddup)
	MessageBeep(MB_OK);
    if (autoplay) {
        CheckMenuItem(GetMenu(hWnd), IDDAUTOPLAY, MF_UNCHECKED);
	autoplay = 0;
    }
    return(FALSE);
}

VOID backup(
    HWND hWnd)
{
    if (move == 72) {
        MessageBox(hWnd, (LPSTR)"You've already won.", (LPSTR)szMessage, MB_OK);
    } else {
	if (move) {
	    set_tile_status(hWnd, moves[--move].i, FALSE);
	    set_tile_status(hWnd, moves[move].j, FALSE);
	}
	evaluate_board();
	currenthint = nmoves;
    }
}

VOID make_move(
    HWND hWnd,
    INT i,
    INT j)
{
    set_tile_status(hWnd, i, TRUE);
    set_tile_status(hWnd, j, TRUE);
    moves[move].i = i;
    moves[move++].j = j;
    evaluate_board();
    currenthint = nmoves;
}

VOID start_over()
{
    register INT i;
    register struct tile *t;

    for (i = 0, t = tiles; i < NUMTILES; i++, t++)
        t->removed = FALSE;
    move = 0;
    evaluate_board();
    currenthint = nmoves;
}

VOID randomize()
{
    time_t ltime;

    time(&ltime);
    ltime &= 0xffff;
    srand((LONG)ltime);
    rand();
    gameseed = rand();
    srand(gameseed);
}

/* Procedure called when the application is loaded for the first time */
BOOL TaipeiInit(
    HANDLE hInstance)
{
    PWNDCLASS   pTaipeiClass;
    INT i;

    /* Load strings from resource */
    LoadString( hInstance, IDSNAME, (LPSTR)szAppName, 10 );
    LoadString( hInstance, IDSTITLE, (LPSTR)szMessage, 15 );

    pTaipeiClass = (PWNDCLASS)LocalAlloc( LPTR, sizeof(WNDCLASS) );
    if (pTaipeiClass == NULL)
	return FALSE;

    pTaipeiClass->hCursor        = NULL;
    pTaipeiClass->hIcon          = LoadIcon( hInstance, (LPSTR)szAppName );
    pTaipeiClass->lpszMenuName   = (LPSTR)szAppName;
    pTaipeiClass->lpszClassName  = (LPSTR)szAppName;
    pTaipeiClass->hbrBackground  = (HBRUSH)CreateSolidBrush(BACKGROUND);
    pTaipeiClass->hInstance      = hInstance;
    pTaipeiClass->style          = CS_HREDRAW | CS_VREDRAW;
    pTaipeiClass->lpfnWndProc    = TaipeiWndProc;

    if (!RegisterClass( (LPWNDCLASS)pTaipeiClass ) )
        /* Initialization failed.
         * Windows will automatically deallocate all allocated memory.
         */
        return FALSE;

    hourglasscursor = LoadCursor(NULL, IDC_WAIT);
    crosscursor     = LoadCursor(NULL, IDC_CROSS);
    arrowcursor     = LoadCursor(NULL, IDC_ARROW);

    /* initialize tile arrays */

    for (i = 0; i < TILES; i++)
	{
        tiles[i].hbmtile = LoadBitmap (hInstance, MAKEINTRESOURCE(i+1));
        tiles[i].hbmtilebw = LoadBitmap (hInstance, MAKEINTRESOURCE(i+1+100));
	}
    hbmtp = LoadBitmap (hInstance, MAKEINTRESOURCE(200));

    /* randomize */

    randomize();

    for (i = 0; i < NUMTILES; i++)
        tiles[i].removed = TRUE;

    LocalFree( (HANDLE)pTaipeiClass );
    return TRUE;        /* Initialization succeeded */
}

VOID set_title(
    HWND hWnd)
{
    CHAR s[30];

    sprintf(s, "Taipei!  Game #%u", gameseed);
    SetWindowText(hWnd, (LPSTR) s);
}

CHAR *banner_strings[] = {
    "Oriental Game of Skill and Chance",
    "",
    "Version 2.00"
    "",
    "by Dave Norris"
    "",
    "Copyright (C) 1988, Bogus Software",
};
#define MAXBANNERSTRINGS (sizeof(banner_strings) / sizeof (char *))

VOID display_banner_screen(
    HWND  hWnd)
{
    HDC hDC = GetDC(hWnd);
    HDC tpDC = CreateCompatibleDC(hDC);
    INT i, x, y;
    INT ydwExtent;
    INT xdwExtent;
    CHAR *s;

    GetClientRect(hWnd, (LPRECT) &window);
    x = window.right / 6;
    y = window.bottom / 6;
    SelectObject(tpDC, hbmtp);
    StretchBlt(hDC, x, y,
               window.right - x*2,
               window.bottom / 2,
               tpDC, 0, 0,
               344,
               125, /* y-1? */
               MERGEPAINT);

    DeleteDC(tpDC);

    y = y * 4;
    SetBkMode(hDC, TRANSPARENT);
    for (i = 0; i < MAXBANNERSTRINGS; i++) {
        s = banner_strings[i];
        (VOID)MGetTextExtent(hDC, s, strlen(s), &xdwExtent, &ydwExtent);
        x = (window.right - xdwExtent) / 2;
	SetTextColor(hDC, BLACK);
        TextOut(hDC, x, y, (LPSTR)s, strlen(s));
	SetTextColor(hDC, WHITE);
        TextOut(hDC, x+1, y+1, (LPSTR)s, strlen(s));
        y += ydwExtent;
    }

    ReleaseDC(hWnd, hDC);
}

MMain(hInstance, hPrevInstance, lpszCmdLine, cmdShow) /* { */
    MSG   msg;
    HWND  hWnd;
    HMENU hMenu;
    HANDLE	hAccel;

    if (!hPrevInstance) {
        /* Call initialization procedure if this is the first instance */
        if (!TaipeiInit( hInstance ))
            return FALSE;
        }

    hWnd = CreateWindow((LPSTR)szAppName,
                        (LPSTR)szMessage,
                        WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT,    /*  x - ignored for tiled windows */
                        0,    /*  y - ignored for tiled windows */
                        CW_USEDEFAULT,    /* cx - ignored for tiled windows */
                        0,    /* cy - ignored for tiled windows */
                        (HWND)NULL,        /* no parent */
                        (HMENU)NULL,       /* use class menu */
                        (HANDLE)hInstance, /* handle to window instance */
                        (LPSTR)NULL        /* no params to pass on */
                        );

    hAccel = LoadAccelerators(hInstance, szAppName);
    /* Save instance handle for DialogBox */
    hInst = hInstance;

    hMenu = GetMenu(hWnd);
    CheckMenuItem(hMenu, (UINT)difficulty, MF_CHECKED);
    CheckMenuItem(hMenu, IDDCOLOR, color ? MF_CHECKED : MF_UNCHECKED);

    SetCursor(arrowcursor);

    /* Make window visible according to the way the app is activated */
    ShowWindow( hWnd, cmdShow );
    UpdateWindow( hWnd );
    display_banner_screen(hWnd);

    /* Polling messages from event queue */
    while (GetMessage((LPMSG)&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(hWnd, hAccel, &msg)) {
	    TranslateMessage((LPMSG)&msg);
	    DispatchMessage((LPMSG)&msg);
	}
    }

    return (INT)msg.wParam;
}

VOID mouse(
    HWND hWnd,
    UINT message,
    LPARAM lParam)
{
    INT i;
//    DWORD x = LOWORD(lParam);
//    DWORD y = HIWORD(lParam);
    POINT   pt;
    static INT oldtile;
    HDC hDC = GetDC(hWnd);


    LONG2POINT(lParam, pt);

    switch (message) {
        case WM_LBUTTONDOWN:
    	    if (in_banner_screen) {
        	new_game(hWnd);
    	    } else if (peeking) {
                if ((peektile = xytotile(pt.x, pt.y)) != -1)
                    DialogBox(hInst, MAKEINTRESOURCE(PEEK), hWnd, PeekDlg);
                SetCursor(LoadCursor(NULL, IDC_ARROW));
                peeking = FALSE;
            } else if ((i = xytotile(pt.x, pt.y)) != -1) {
                if (isfree(i)) {
                    if (inverted1 == -1) {
                            invert_tile(hDC, inverted1 = i);
                    } else {
                        if (i == inverted1) {
                            invert_tile(hDC, i);
                            inverted1 = -1;
                        } else {
                            invert_tile(hDC, inverted2 = i);
                        }
                    }
                } else {
                    uninvert_all(hDC);
		    if (!shaddup)
			MessageBeep(MB_OK);
                    MessageBox(hWnd, (LPSTR)"Tile isn't free", (LPSTR)szMessage, MB_OK);
                }
            } else {
		if (!shaddup)
		    MessageBeep(MB_OK);
            }
            break;

        case WM_LBUTTONUP:
            if (inverted1 != -1 && inverted2 != -1) {
                if (compare(inverted1, inverted2)) {
                    make_move(hWnd, inverted1, inverted2);
                    inverted1 = inverted2 = -1;

                    /* let user know if he's dead */

                    if (!nmoves) {
			if (move != 72)
			    MessageBox(hWnd, (LPSTR)"No free tiles", (LPSTR)szMessage, MB_OK);
			else
			    MessageBox(hWnd, (LPSTR) (confucius_say[rand() % MAXCONFUCIUSSAY]), (LPSTR)"Confucius say", MB_OK);
		    }

                } else {
                    uninvert_all(hDC);
		    if (!shaddup)
			MessageBeep(MB_OK);
                    MessageBox(hWnd, (LPSTR)"Tiles don't match", (LPSTR)szMessage, MB_OK);
                }
            }
            break;

        case WM_MOUSEMOVE:
            i = xytotile(pt.x, pt.y);
            if (i != oldtile && !peeking) {
                oldtile = i;
                if (i != -1 && isfree(i)) {
                    if (currentcursor != crosscursor)
                        currentcursor = crosscursor;
                } else {
                    if (currentcursor != arrowcursor)
                        currentcursor = arrowcursor;
	        }
                SetCursor(currentcursor);
            }
            break;

	default:
            break;
    }
    ReleaseDC(hWnd, hDC);
}

VOID give_hint(
    HWND hWnd)
{
    HDC hDC;
    DWORD i, j;

    if (hint(hWnd)) {
        hDC = GetDC(hWnd);
        uninvert_all(hDC);
        for (j = 0; j < 5; j++) {
            invert_tile(hDC, hint1);
            invert_tile(hDC, hint2);
            GdiFlush();
            Sleep(200);
            invert_tile(hDC, hint1);
            invert_tile(hDC, hint2);
	    GdiFlush();
            Sleep(75);
        }
        ReleaseDC(hWnd, hDC);
    }
    else
	MessageBeep(MB_OK);
}

/* Procedures which make up the window class. */
LRESULT  APIENTRY TaipeiWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PAINTSTRUCT ps;
    DWORD i;
    HMENU hMenu;

    switch (message)
    {
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	    case IDMABOUT:
	        DialogBox( hInst, MAKEINTRESOURCE(ABOUTBOX), hWnd, About );
	        break;

            case IDDPEEK:
                SetCursor(LoadCursor(NULL, IDC_UPARROW));
                peeking = TRUE;
                break;

	    case IDDSELECTGAME:
                if (!DialogBox(hInst, MAKEINTRESOURCE(SELECTGAME), hWnd, SelectGameDlg))
		    break;
	
	    case IDDNEWGAME:
	        if (GET_WM_COMMAND_ID(wParam, lParam) == IDDNEWGAME)
		    randomize();
	        new_game(hWnd);
                break;

            case IDDHINT:
		give_hint(hWnd);
                break;

            case IDDSTARTOVER:
                if (moves) {
                    start_over();
                    set_all_points();
                    InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
                }
                break;

            case IDDBACKUP:
                backup(hWnd);
                break;

            case IDDAUTOPLAY:
                if (move != 72) {
    		    currenthint = nmoves; /* reset hint for best hint */
                    CheckMenuItem(GetMenu(hWnd), IDDAUTOPLAY, autoplay ? MF_UNCHECKED : MF_CHECKED);
                    if (autoplay = !autoplay)
                        if (hint(hWnd))
                            make_move(hWnd, hint1, hint2);
                }
                break;

	    case IDDCOLOR:
		hMenu = GetMenu(hWnd);
                CheckMenuItem(hMenu, IDDCOLOR, color ? MF_UNCHECKED : MF_CHECKED);
		color = !color;
                InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
		break;

	    case IDDSHADDUP:
		hMenu = GetMenu(hWnd);
                CheckMenuItem(hMenu, IDDSHADDUP, shaddup ? MF_UNCHECKED : MF_CHECKED);
		shaddup = !shaddup;
		break;

	    case IDDLIGHTEN:
		if (EdgeColor > WHITE_BRUSH)
    		    EdgeColor--;
                InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
		break;

	    case IDDDARKEN:
		if (EdgeColor < BLACK_BRUSH)
    		    EdgeColor++;
                InvalidateRect(hWnd, (LPRECT) NULL, TRUE);
		break;

	    case IDDTILES:
                DialogBox(hInst, MAKEINTRESOURCE(TILEHELP), hWnd, TileHelpDlg);
		break;

	    case IDDBEGINNER:
	    case IDDINTERMEDIATE:
    	    case IDDEXPERT:
	    case IDDMASTER:
		hMenu = GetMenu(hWnd);
		CheckMenuItem(hMenu, (UINT)difficulty, MF_UNCHECKED);
                difficulty = GET_WM_COMMAND_ID(wParam, lParam);
    		CheckMenuItem(hMenu, (UINT)difficulty, MF_CHECKED);
	    	break;
        }
        break;

    case WM_DESTROY:
        for (i = 0; i < TILES; i++) {
            DeleteObject(tiles[i].hbmtile);
            DeleteObject(tiles[i].hbmtilebw);
    	}
        PostQuitMessage( 0 );
        break;

    case WM_PAINT:
        GetClientRect(hWnd, (LPRECT) &window);
        tilewidth = ((window.right - window.left) * TILEX) / 0x282;
	if (tilewidth >= TILEX*7/8 && tilewidth <= TILEX*5/4)
	    tilewidth = TILEX;
        tileheight = ((window.bottom-window.top)*TILEY)/(TILEY*8+TILEY/2);
	if (tileheight >= TILEY-BOTTOMSIZE && tileheight <= TILEY*5/4)
	    tileheight = TILEY;
        BeginPaint( hWnd, (LPPAINTSTRUCT)&ps );
        TaipeiPaint( ps.hdc, (LPPAINTSTRUCT)&ps, hWnd);
        EndPaint( hWnd, (LPPAINTSTRUCT)&ps );
        if (autoplay && hint(hWnd))
            make_move(hWnd, hint1, hint2);
        break;

    case WM_RBUTTONDOWN:
	ShowWindow( hWnd, SW_MINIMIZE);
        break;

    case WM_MOUSEMOVE:
    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        mouse(hWnd, message, lParam);
        break;

    case WM_SIZE:
        GetClientRect(hWnd, (LPRECT) &window);
        tilewidth = ((window.right - window.left) * TILEX) / 0x282;
	if (tilewidth >= TILEX*7/8 && tilewidth <= TILEX*5/4) tilewidth = TILEX;
        tileheight = ((window.bottom - window.top) * TILEY) / (TILEY*8+TILEY/2);
	if (tileheight >= TILEY-BOTTOMSIZE && tileheight <= TILEY*5/4)
		tileheight = TILEY;
        set_all_points();
        break;

    default:
        return DefWindowProc( hWnd, message, wParam, lParam );
        break;
    }
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\context.h ===
#define HLP_INDEX     0x0000
#define HLP_HOWTOPLAY 0x0001
#define HLP_COMMANDS  0x0002
#define HLP_KEYBOARD  0x0003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\blk.h ===
/*********/
/* blk.h */
/*********/

#define coMax 5

VOID DisplayBlk(INT, INT, BLK);
VOID DisplayPos(POS);

VOID DrawGrid(VOID);
VOID SetupLevelData(VOID);

VOID DrawLevelNum(VOID);
VOID DisplayLevelNum(VOID);
VOID DrawGameOver(VOID);
VOID DisplayGameOver(VOID);

VOID SetBlkCo(LONG, LONG);

VOID WipeClear(VOID);
VOID ReWipe(VOID);
VOID SetLevelColor(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\pegged\pegged.h ===
#define	IDM_NEW	1
#define	IDM_UNDO	2
#define	IDM_CROSS	3
#define	IDM_PLUS	4
#define	IDM_FIREPLACE	5
#define	IDM_UPARROW	6
#define	IDM_PYRAMID	7
#define	IDM_DIAMOND	8
#define	IDM_SOLITAIRE	9
#define	IDM_HINT	10
#define	IDM_ABOUT	11
#define	IDM_ICONIZE	12
#define	IDM_EXIT	13
#define	IDM_INDEX	14
#define	IDM_HOWTO	15
#define	IDM_COMMANDS	16
#define	IDM_USING	17
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\grafix.h ===
/************/
/* grafix.h */
/************/

/*** Bitmaps ***/

#define dxpBlk 8
#define dypBlk 8

#define dxpNum  12
#define dypNum  17
#define dxpSpaceNum (dxpNum+1)

#define numMax 5
#define dxpNumMax (dxpSpaceNum*numMax)

#define dxpNumOff 190
#define dypNumOff 8

#define dxpTimeOff dxpBlk
#define dypTimeOff (dypNumOff+dypNum+5)
#define dxpTime    (dxpGrid-dxpBlk*2)
#define dypTime    4

#define dxpLife    8
#define dypLife    20
#define dxpLifeOff dxpBlk
#define dypLifeOff 5
#define dxpLifeSpace (dxpLife+8)

#define dxpGrid     (dxpBlk*xMax)
#define dypGrid     (dypBlk*yMax)

#define dxpGridOff  0
#define dypGridOff  (dypTimeOff + 10)



#define dxpCor 4
#define dypCor 4

#define corNE   0
#define corSE   1
#define corSW   2
#define corNW   3
#define corFNE  4
#define corFSE  5
#define corFSW  6
#define corFNW  7
#define corN    8
#define corE    9
#define corS   10
#define corW   11
#define corF   12

#define corMax 13

#define dypCorMax (dypCor*corMax)

typedef INT COR;	/* Wall corner piece */
typedef INT SUR;


/*** Macros ***/

#ifdef DEBUG

//-protect-#define Oops(szMsg)
//	MessageBox(NULL, szMsg, "Oops", MB_OK | MB_ICONHAND)

#else
#define Oops(szMsg)
#endif


/*** Routines ***/

BOOL FInitLocal(VOID);
VOID CleanUp(VOID);

VOID StartDraw(VOID);
VOID EndDraw(VOID);

VOID MoveScore(VOID);
VOID ResetScore(VOID);
VOID AddScore(INT);
VOID DisplayScore(VOID);

VOID DrawScreen(HDC);
VOID DisplayScreen(VOID);

VOID DisplayTime(VOID);
VOID UpdateTime(VOID);

VOID DrawTime(VOID);
VOID DrawLives(VOID);

BOOL FLoadBitmaps(VOID);
VOID FreeBitmaps(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\blk.c ===
/***************/
/* file: blk.c */
/***************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "snake.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "blk.h"
#include "pref.h"

#define cbDibHeader (16*4 + sizeof(BITMAPINFOHEADER))

BOOL   fWipe = fFalse;

extern PREF    Preferences;

extern LPSTR   lpDibWall;
extern LPSTR   lpDibLvl;

extern HDC     hdcBlk;
extern HDC     hdcCor;
extern HDC     hdcMain;

extern HBITMAP hbmpCor;

extern LONG coDarkGreen;
extern LONG coLiteGreen;

extern STATUS status;

#define icoDark 0
#define icoLite 1

/* CO: RESERVED RED GREEN BLUE */

DWORD rgcoDark[coMax+1] =
  {0x007F0000, 0x0000007F, 0x007F7F00, 0x007F007F, 0x00007F7F, 0x00000000};

DWORD rgcoLite[coMax+1] =
  {0x00FF0000, 0x000000FF, 0x00FFFF00, 0x00FF00FF, 0x0000FFFF, 0x00FFFFFF};

DWORD rgcoFill[coMax+1] =
  {0x0000007F, 0x007F0000, 0x00007F7F, 0x007F007F, 0x007F7F00, 0x00BFBFBF};
 


#define SurFromBlk(blk)  ((SUR) ((blk) & 0x0007))


COR rgmpsurcor[4][8] =
{
/*    000     001      010     011     100       101     110     111     */
 {corNW*4, corN*4, corNW*4, corN*4, corW*4, corFNW*4, corW*4, corF*4},	/*NW*/
 {corNE*4, corE*4, corNE*4, corE*4, corN*4, corFNE*4, corN*4, corF*4},	/*NE*/
 {corSE*4, corS*4, corSE*4, corS*4, corE*4, corFSE*4, corE*4, corF*4},	/*SE*/
 {corSW*4, corW*4, corSW*4, corW*4, corS*4, corFSW*4, corS*4, corF*4}	/*SW*/
};

BYTE rgblknum[10][7] =
{
	{0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E},  /* 0 */
	{0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E},  /* 1 */
	{0x1F, 0x01, 0x01, 0x1F, 0x10, 0x10, 0x1F},  /* 2 */
	{0x1F, 0x01, 0x01, 0x0F, 0x01, 0x01, 0x1F},  /* 3 */
	{0x11, 0x11, 0x11, 0x1F, 0x01, 0x01, 0x01},  /* 4 */
	{0x1F, 0x10, 0x10, 0x1F, 0x01, 0x01, 0x1F},  /* 5 */
	{0x1F, 0x10, 0x10, 0x1F, 0x11, 0x11, 0x1F},  /* 6 */
	{0x1F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},  /* 7 */
	{0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E},  /* 8 */
	{0x1F, 0x11, 0x11, 0x1F, 0x01, 0x01, 0x01}   /* 9 */
};



/*** External Data ***/

extern HWND   hwndMain;
extern HANDLE hInst;

extern BLK mpposblk[posMax];

extern INT cLevel;



/****** S E T  B L K  C O ******/

/* Set Block Color */

VOID SetBlkCo(LONG coDark, LONG coLite)
{

#define SetClr(clr,co) \
        {   \
        ((LPBITMAPINFO)lpDibWall)->bmiColors[clr].rgbBlue = (BYTE)(co); \
        ((LPBITMAPINFO)lpDibWall)->bmiColors[clr].rgbGreen = (BYTE)(co>>8);   \
        ((LPBITMAPINFO)lpDibWall)->bmiColors[clr].rgbRed = (BYTE)(co>>16); \
        ((LPBITMAPINFO)lpDibWall)->bmiColors[clr].rgbReserved = (BYTE)(0x00); \
        }

	SetClr(icoDark,coDark);
	SetClr(icoLite,coLite);

 	SetDIBits(hdcCor, hbmpCor, 0, dypCorMax,
		lpDibWall + 8 + sizeof(BITMAPINFOHEADER),
		(LPBITMAPINFO) lpDibWall, DIB_RGB_COLORS);
}


/****** D R A W  B L K ******/

VOID DrawBlk(INT x, INT y, BLK blk)
{
	BitBlt(hdcMain, x, y, dxpBlk, dypBlk, hdcBlk, 0, blk<<3, SRCCOPY);
}


/****** D I S P L A Y  B L K ******/

VOID DisplayBlk(INT x, INT y, BLK blk)
{
	StartDraw();
	DrawBlk(x, y, blk);
	EndDraw();
}

/****** D R A W  C O R ******/

/* cor must be a multiple of 4 */

VOID DrawCor(INT x, INT y, COR cor)
{
#ifdef DEBUG
	if (cor & 0x0003)
		OutputDebugString("Invalid Cor\r\n");
#endif
	BitBlt(hdcMain, x, y, dxpCor, dypCor, hdcCor, 0, cor, SRCCOPY);
}



/****** D R A W  W A L L ******/

VOID DrawWall(INT x, INT y, BLK blk)
{
	INT x2, y2;

	DrawCor(x,y, rgmpsurcor[0][SurFromBlk(blk)]);
	DrawCor(x2 = x+4, y, rgmpsurcor[1][SurFromBlk(blk >>= 2)]);
	DrawCor(x2,y2 = y + 4, rgmpsurcor[2][SurFromBlk(blk >>= 2)]);
	DrawCor(x,y2, rgmpsurcor[3][SurFromBlk(blk >>= 2)]);
}



/****** D I S P L A Y  P O S ******/

VOID DisplayPos(POS pos)
{
	INT x = dxpGridOff + ((pos % xMax) << 3);
	INT y = dypGridOff + ((pos / xMax) << 3);
	BLK blk;

	StartDraw();

	if ((blk = mpposblk[pos]) > blkMax)
		DrawWall(x, y, blk);
	else
		DrawBlk(x, y, blk);

	EndDraw();
}


/****** C L E A R  B O R D E R ******/

VOID ClearBorder(VOID)
{
	POS pos;

	for (pos = posMax; pos--;)		/* BLT !! */
		mpposblk[pos] = blkNull;

	for (pos = xMax; pos < (posMax-xMax); pos += xMax)
		mpposblk[pos] = mpposblk[pos+xMax-1] = blkWallNS;

	for (pos = xMax-1; --pos > 0;)
		mpposblk[pos] = mpposblk[(posMax-1)-pos] = blkWallEW;

	mpposblk[posNW] = blkWallNW;
	mpposblk[posNE] = blkWallNE;
	mpposblk[posSW] = blkWallSW;
	mpposblk[posSE] = blkWallSE;
}


/****** S E T  L E V E L  C O L O R ******/

VOID SetLevelColor(VOID)
{
	INT ico = (Preferences.fColor) ? cLevel % coMax : coMax;

	SetBlkCo(rgcoDark[ico], rgcoLite[ico]);
}

/****** S E T U P  B O R D E R ******/

/* Just draw the border pieces */

VOID SetupBorder(VOID)
{
	INT x1,x2;

	SetLevelColor();

 	DrawWall(dxpGridOff, dypGridOff, blkWallNW);
	DrawWall(dxpGridOff+dxpGrid-dxpBlk, dypGridOff, blkWallNE);
	DrawWall(dxpGridOff, dypGridOff+dypGrid-dypBlk, blkWallSW);
	DrawWall(dxpGridOff+dxpGrid-dxpBlk, dypGridOff+dypGrid-dypBlk, blkWallSE);

	for (x1 = dxpBlk, x2 = dypGrid - 2*dypBlk;
		x1 < (dxpGrid/2); x1 +=dxpBlk, x2 -= dypBlk)
		{	
		DrawWall(dxpGridOff + x1, dypGridOff, blkWallEW);
		DrawWall(dxpGridOff -dxpBlk + x2, dypGridOff, blkWallEW);
		DrawWall(dxpGridOff,      dypGridOff + x1, blkWallNS);
		DrawWall(dxpGridOff,      dypGridOff + x2, blkWallNS);
		DrawWall(dxpGridOff + x1, dypGridOff+dypGrid-dypBlk, blkWallEW);
		DrawWall(dxpGridOff -dxpBlk + x2, dypGridOff+dypGrid-dypBlk, blkWallEW);
		DrawWall(dxpGridOff+dxpGrid-dxpBlk, dypGridOff + x1, blkWallNS);
		DrawWall(dxpGridOff+dxpGrid-dxpBlk, dypGridOff + x2, blkWallNS);
		}
}


/****** D R A W  G R I D ******/

VOID DrawGrid(VOID)
{
	INT x,y;
	POS pos;
	BLK blk;

	x = dxpGridOff;
	y = dypGridOff;

	for (pos = 0; pos < posMax; pos++)
		{
		blk = mpposblk[pos];
		if (blk > blkMax)
			DrawWall(x,y, blk);
		else
			DrawBlk(x,y, blk);

		if ( (x += dxpBlk) >= (dxpGridOff+dxpGrid) )
			{
			x  = dxpGridOff;
			y += dypBlk;
			}
		}
}



/****** G E T  L E V E L  D A T A ******/

/* Get the level data from the bitmap */

VOID GetLevelData(INT lvl)
{
	LONG FAR * lpData;
	INT	x, b;
	LONG	lData;
	CHAR	bData;
	POS	pos;

	lpData = (LONG FAR * ) (lpDibLvl + (lvl * (32 * 4)) );

	pos = posMax - (xMax + xMax - 1);

	while (pos > xMax)
		{
		lData = *lpData;
		for (b = 4; b--;)
			{
			bData = (BYTE) lData;
			lData >>= 8;
			for (x = 8; x--;)
				{
				if (!(bData & 0x80))
					mpposblk[pos] = 0x1000;
				bData <<= 1;
				pos++;
				}
			}
		lpData++;
		pos -= (xMax+xMax-1);
		}
}



/****** M A K E  W A L L S ******/

VOID MakeWalls(VOID)
{
	POS pos;
	BLK blk;

	pos = posSW;
	while (pos > posNE)
		{
		if (mpposblk[--pos] != blkNull)
			{
			blk = 0x1000;
			if (mpposblk[--pos])       blk |= 0x0101;
			if (mpposblk[pos -= xMax]) blk |= 0x0002;
			if (mpposblk[++pos])       blk |= 0x0004;
			if (mpposblk[++pos])       blk |= 0x0008;
			if (mpposblk[pos += xMax]) blk |= 0x0010;
			if (mpposblk[pos += xMax]) blk |= 0x0020;
			if (mpposblk[--pos])       blk |= 0x0040;
			if (mpposblk[--pos])       blk |= 0x0080;
			mpposblk[pos -= (xMax-1)]= blk;
			}
		}

	/* Fix Border */

	for (pos = xMax; pos < (posSW-1); pos += xMax)
		{
		mpposblk[pos]       &= 0x10FE;	/* Left */
		mpposblk[pos+posNE] &= 0x11EF;	/* Right */
		}

	for (pos = posNE-1; pos > posNW;)
		{
		blk = 0x1111;
		if (mpposblk[pos += xMax+1]) blk |= 0x0020;
		if (mpposblk[--pos])        blk |= 0x0040;
		if (mpposblk[--pos])        blk |= 0x0080;
		mpposblk[pos -= (xMax-1)] = blk;				/* Top */

		blk = 0x1111;
		pos += posSW;
		if (mpposblk[pos -= (xMax-1)]) blk |= 0x0002;
		if (mpposblk[--pos])        blk |= 0x0004;
		if (mpposblk[--pos])        blk |= 0x0008;
		mpposblk[pos += (xMax+1)] = blk;	/* Bottom */
		pos -= posSW;
		pos--;
		}

	if (mpposblk[posNW +xMax+1])
		mpposblk[posNW] = blkWallNW | 0x0020;
	else
		mpposblk[posNW] = blkWallNW;

	if (mpposblk[posNE +xMax-1])
		mpposblk[posNE] = blkWallNE | 0x0080;
	else
		mpposblk[posNE] = blkWallNE;

	if (mpposblk[posSW-(xMax-1)])
		mpposblk[posSW] = blkWallSW | 0x0008;
	else
		mpposblk[posSW] = blkWallSW;

	if (mpposblk[posSE-(xMax+1)])
		mpposblk[posSE] = blkWallSE | 0x0002;
	else
		mpposblk[posSE] = blkWallSE;

}


/****** A D D  N U M ******/

VOID AddNum(POS pos, INT num)
{
	INT x,y;
	INT b;

	for (y = 0; y < 7; y++)
		{
		b = rgblknum[num][y];
		for (x = 0; x++ < 5;)
			{
			if ((b <<= 1) & 0x20)
				mpposblk[pos] = 0x1000;
			pos++;
			}
		pos += (xMax - 5);
		}
}


/****** A D D  L E V E L  N U M ******/

VOID AddLevelNum(INT lvl)
{
	AddNum(xMax*20+10, lvl/10);
	AddNum(xMax*20+18, lvl%10);
}



/****** D R A W  D A T A ******/

VOID DrawData(VOID)
{
	POS pos;
	BLK blk;
	INT x,y;

	x = dxpGridOff+dxpBlk;
	y = dypGridOff+dypBlk;

	for (pos = xMax+1; pos < posMax-xMax; pos++)
		{
		blk = mpposblk[pos];
		if (blk != blkNull)
			{
			DrawWall(x,y, blk);
			}

		if ( (x += dxpBlk) >= (dxpGridOff+dxpGrid-dxpBlk) )
			{
			x  = dxpGridOff+dxpBlk;
			y += dypBlk;
			pos += 2;
			}
		}
}


/****** W I P E  C L E A R ******/

VOID WipeClear(VOID)
{
	LONG co = rgcoFill[ Preferences.fColor ? (cLevel % coMax) : coMax];
	LONG lco = co & 0x00030303;
	INT dxp = dxpGridOff+dxpBlk;
	INT dyp = dypGridOff+dypBlk;
	INT dxp2;
	HBRUSH hbrush, hbrush2;

	fWipe = fTrue;

	SelectObject(hdcMain, GetStockObject(NULL_PEN));
	hbrush = SelectObject(hdcMain, CreateSolidBrush(co));

	for (dxp2 = dxp;
		  dxp < (dxpGridOff + dxpGrid - dxpBlk);
		  dxp = dxp2, dyp += dypBlk)
		{
		dxp2 += dxpBlk;
		hbrush2 = SelectObject(hdcMain, CreateSolidBrush(co));
                if (hbrush2)
                    DeleteObject(hbrush2);
		Rectangle(hdcMain, dxpGridOff+dxpBlk, dyp, dxp2+1, dyp + dypBlk+1);
		Rectangle(hdcMain, dxp, dypGridOff+dypBlk, dxp2+1, dyp+1);
		co -= lco;
		}
	hbrush2 = SelectObject(hdcMain, CreateSolidBrush(co));
        if (hbrush2)
            DeleteObject(hbrush2);
	Rectangle(hdcMain, dxpGridOff+dxpBlk, dyp, dxp2+1, dyp+dxpBlk+1);

	hbrush2 = SelectObject(hdcMain, hbrush);
        if (hbrush2)
            DeleteObject(hbrush2);

}



/****** S E T U P  L E V E L  D A T A ******/

VOID SetupLevelData(VOID)
{
	StartDraw();
	ClearBorder();
	SetupBorder();
	EndDraw();

	GetLevelData(cLevel % lvlMax);
	MakeWalls();
}


/****** D I S P L A Y  L E V E L  N U M ******/

VOID DrawLevelNum(VOID)
{
	if (cLevel > 98)
		cLevel = 0;
	ClearBorder();
	SetupBorder();
	WipeClear();
	GetLevelData(lvlLevel);
	AddLevelNum(cLevel+1);
	MakeWalls();
	SetBlkCo(coDarkGreen, coLiteGreen);
	DrawData();
	DrawTime();
	DrawLives();
}

VOID DisplayLevelNum(VOID)
{
	StartDraw();
	DrawLevelNum();
	EndDraw();
}


/****** D I S P L A Y  G A M E  O V E R ******/

VOID DrawGameOver(VOID)
{
	ClearBorder();
	SetupBorder();
	WipeClear();
	GetLevelData(lvlGameOver);
	MakeWalls();
	SetBlkCo(coDarkGreen, coLiteGreen);
	DrawData();
}

VOID DisplayGameOver(VOID)
{
	StartDraw();
	DrawGameOver();
	EndDraw();
}


VOID ReWipe(VOID)
{
	if (FPlay())
		{
		POS pos;
		BLK mpposblk2[posMax];	/* A copy of the playing grid */

		for (pos=posMax; --pos >= 0;)
			mpposblk2[pos] = mpposblk[pos];
		DrawLevelNum();
		for (pos=posMax; --pos >= 0;)
			mpposblk[pos] = mpposblk2[pos];
		}
	else
		DrawGameOver();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\grafix.c ===
/*******************/
/* file: grafix.c */
/*******************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "snake.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "blk.h"
#include "sound.h"
#include "pref.h"

#define cbDibHeader (16*4 + sizeof(BITMAPINFOHEADER))

HANDLE  hresWall = NULL;
LPSTR   lpDibWall;

HANDLE  hresLvl = NULL;
LPSTR   lpDibLvl;

HANDLE  hresSnk = NULL;
LPSTR   lpDibSnk;

HDC     hdcBlk;
HBITMAP hbmpBlk;
HDC     hdcCor;
HBITMAP hbmpCor;
HDC     hdcNum;
HBITMAP hbmpNum;


HDC     hdcMain;	/* DC for main window */

HPEN    hpenGray;
HBRUSH  hbrushGreen;

/* Score Stuff */

INT rgnum[numMax];
INT cMoveScore = 0;		/* 0 if not moving score */
INT inumMoveMac;			/* first number to move ( >1 if moving several 9 -> 0) */
INT score;
INT scoreCurr;				/* Current displayed score */


#define DKGREEN 0x00007F00L
#define LTGREEN 0x0000FF00L

LONG coDarkGreen;
LONG coLiteGreen;


/*** External Data ***/

extern HWND   hwndMain;
extern HANDLE hInst;
extern BOOL   fEGA;

extern POS posHead;
extern POS posTail;

extern BLK mpposblk[posMax];

extern INT cLevel;
extern INT cTimeLeft;
extern INT cLives;
extern INT ctickMove;

extern INT dypCaption;
extern INT dypMenu;
extern INT dypBorder; 
extern INT dxpBorder;

extern INT dxpWindow;
extern INT dypWindow;

extern STATUS status;
extern PREF   Preferences;

extern BOOL   fWipe;


/****** S T A R T  D R A W ******/

VOID StartDraw(VOID)
{
	hdcMain = GetDC(hwndMain);
}


/****** E N D  D R A W ******/

VOID EndDraw(VOID)
{
	ReleaseDC(hwndMain, hdcMain);
}



BOOL FLoadBitmaps(VOID)
{
	hresSnk = LoadResource(hInst,
		FindResource(hInst, MAKEINTRESOURCE(ID_BMP_SNK+(!Preferences.fColor)), RT_BITMAP));

	if (hresSnk == NULL)
		return fFalse;

	lpDibSnk  = LockResource(hresSnk);

	hbmpBlk   = LoadBitmap(hInst, MAKEINTRESOURCE(ID_BMP_BLK+(!Preferences.fColor)) );
	SelectObject(hdcBlk, hbmpBlk);

	coDarkGreen = Preferences.fColor ? DKGREEN : 0x007F7F7FL;
	coLiteGreen = Preferences.fColor ? LTGREEN : 0x00FFFFFFL;

	SetLevelColor();

	return fTrue;
}

VOID FreeBitmaps(VOID)
{
	UnlockResource(hresSnk);
}


/****** F  I N I T  L O C A L ******/

BOOL FInitLocal(VOID)
{
	hresWall  = LoadResource(hInst, FindResource(hInst, MAKEINTRESOURCE(ID_BMP_WALL), RT_BITMAP));

	hresLvl   = LoadResource(hInst, FindResource(hInst, MAKEINTRESOURCE(ID_BMP_LVL), RT_BITMAP));

	hdcNum    = CreateCompatibleDC(NULL);
	hbmpNum   = LoadBitmap(hInst, MAKEINTRESOURCE(ID_BMP_NUM));

	hdcBlk    = CreateCompatibleDC(NULL);

	StartDraw();
	hdcCor    = CreateCompatibleDC(NULL);
	hbmpCor   = CreateCompatibleBitmap(hdcMain, dxpCor, dypCorMax);
	EndDraw();

	if ((hresWall == NULL) || (hresLvl == NULL) ||
			(hdcNum == NULL) || (hbmpNum == NULL) ||
			(hdcCor == NULL) || (hbmpCor == NULL) || (hdcBlk == NULL) )
		return fFalse;

	lpDibWall = LockResource(hresWall);
	lpDibLvl  = (LPVOID) ((LPBYTE) LockResource(hresLvl)	+ sizeof(BITMAPINFOHEADER) + 8);
	SelectObject(hdcNum, hbmpNum);
	SelectObject(hdcCor, hbmpCor);

	if (fEGA)
		{
		hpenGray = CreatePen(PS_SOLID, 1, RGB(64, 64, 64));
		}
	else
		{
		hpenGray = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
		}

	hbrushGreen = CreateSolidBrush(RGB(0,128,0));

	InitTunes();

	return (FLoadBitmaps());
}


/****** C L E A N  U P ******/

VOID CleanUp(VOID)
{
	EndTunes();
	FreeBitmaps();
	UnlockResource(hresWall);
	UnlockResource(hresLvl);
	DeleteDC(hdcBlk);
	DeleteDC(hdcCor);
	DeleteDC(hdcNum);
}


/*======================== Snakes/Lives ================================*/

VOID DrawLives(VOID)
{
	INT x = dxpLifeOff;
	HBRUSH hbrush;
	INT i;

	SetROP2(hdcMain, R2_BLACK);	/* ???? */

	hbrush = SelectObject(hdcMain, hbrushGreen);
	for (i = 0; i++ < cLives;)
		{
		SetDIBitsToDevice(hdcMain, x, dypLifeOff, dxpLife, dypLife,
			0, 0, 0, dypLife,
			lpDibSnk + (Preferences.fColor ? cbDibHeader : (2*4 + sizeof(BITMAPINFOHEADER))),
			(LPBITMAPINFO) lpDibSnk, DIB_RGB_COLORS);
		x += dxpLifeSpace;
		}

	SelectObject(hdcMain, GetStockObject(LTGRAY_BRUSH));
	for (i=cLives; i++ < cLivesMax;)
		{
		PatBlt(hdcMain, x, dypLifeOff, dxpLife, dypLife, PATCOPY);
		x += dxpLifeSpace;
		}
	SelectObject(hdcMain, hbrush);
}

VOID DisplayLives(VOID)
{
	StartDraw();
	DrawLives();
	EndDraw();
}


/*============================ SCORE ROUTINES ============================*/


/****** D R A W  N U M ******/

VOID DrawNum(INT x, INT num)
{
	BitBlt(hdcMain, x, dypNumOff, dxpNum, dypNum-1, hdcNum, 0, num, SRCCOPY);
}


/****** D R A W  S C O R E ******/

VOID DrawScore(VOID)
{
	INT x;
	INT inum;

	x = dxpNumOff;
	for (inum = numMax; inum--  > 0;)
		{
		DrawNum(x, rgnum[inum]);
		x += dxpSpaceNum;
		}

	SetROP2(hdcMain, R2_BLACK);	/* ???? */

	x = dxpNumOff-1;
	for (inum = numMax+1; inum-- > 0;)
		{
		MMoveTo(hdcMain, x, dypNumOff-1);
		LineTo(hdcMain, x, dypNumOff+dypNum);
		x += dxpSpaceNum;
		}
	MMoveTo(hdcMain, dxpNumOff-1, dypNumOff-1);
	LineTo(hdcMain, dxpNumOff+dxpSpaceNum*numMax, dypNumOff-1);
	MMoveTo(hdcMain, dxpNumOff-1, dypNumOff+dypNum-1);
	LineTo(hdcMain, dxpNumOff+dxpSpaceNum*numMax, dypNumOff+dypNum-1);
}


VOID DisplayScore(VOID)
{
	StartDraw();
	DrawScore();
	EndDraw();
}


/****** I N C  S C O R E ******/

VOID IncScore(VOID)
{
	cMoveScore = dypNum/2 + 1;
	inumMoveMac = 0;

	while ((rgnum[inumMoveMac++] == 9*dypNum) && (inumMoveMac < numMax))
		;
	if ((++scoreCurr % 100) == 0)
		if (cLives < cLivesMax)
			{
			cLives++;
			DisplayLives();
			}
}


/****** M O V E  S C O R E ******/

VOID MoveScore(VOID)
{
	REGISTER INT x = dxpNumOff + dxpNumMax;
	REGISTER dy = 2;
	INT inum;

#if 0		/* More efficient to do in "DoTimer" */
	if (cMoveScore == 0)
		return;
#endif

	if (cMoveScore == 1)
		dy = 1;
	StartDraw();
	for (inum = 0; inum < inumMoveMac; inum++)
#if 1
		DrawNum(x -= dxpSpaceNum, rgnum[inum] += dy);
#else
		DrawNum(x -= dxpSpaceNum, ++(rgnum[inum]));
#endif
	EndDraw();

	if (--cMoveScore == 0)
		{
		inum = 0;
		while (rgnum[inum] >= 10*dypNum)	/* Reset number to proper zero */
			rgnum[inum++] = 0;
		if (scoreCurr != score)
			IncScore();
		}

}


/****** A D D  S C O R E ******/

VOID AddScore(INT n)
{
	score += n;
	if (score > 9999)
		ResetScore();
	if (cMoveScore == 0)
		IncScore();
}


/****** R E S E T  S C O R E ******/

VOID ResetScore(VOID)
{
	REGISTER INT i;

	scoreCurr = score = cMoveScore = 0;
	for (i = numMax; i-- > 0;)
		rgnum[i] = 0;
}




/*======================== TIMER ================================*/


VOID DrawTime(VOID)
{
	HBRUSH hbrush;

	hbrush = SelectObject(hdcMain, Preferences.fColor ? hbrushGreen : GetStockObject(GRAY_BRUSH));
	PatBlt(hdcMain, dxpTimeOff, dypTimeOff, cTimeLeft, dypTime, PATCOPY);
	PatBlt(hdcMain, dxpTimeOff+cTimeLeft, dypTimeOff, dxpTime-cTimeLeft, dypTime, BLACKNESS);
	SelectObject(hdcMain, hbrush);
}

VOID DisplayTime(VOID)
{
	StartDraw();
	DrawTime();
	EndDraw();
}

VOID UpdateTime(VOID)
{
/*	HBRUSH hbrush; */

	StartDraw();
	PatBlt(hdcMain, dxpTimeOff+cTimeLeft, dypTimeOff, 1, dypTime, BLACKNESS);
	EndDraw();
}


/*======================== Border stuff ================================*/


/****** S E T  T H E  P E N ******/

VOID SetThePen(BOOL fNormal)
{
	if (fNormal)
		SetROP2(hdcMain, R2_WHITE);
	else
		{
		SetROP2(hdcMain, R2_COPYPEN);
		SelectObject(hdcMain, hpenGray);
		}
}


/****** D R A W  B O R D E R ******/

/* 0 - white, gray
   1 - gray,  white
*/

VOID DrawBorder(INT x1, INT y1, INT x2, INT y2, INT width, BOOL fNormal)
{
	INT i = 0;

	SetThePen(fNormal);

	while (i++ < width)
		{
		MMoveTo(hdcMain, x1, --y2);
		LineTo(hdcMain, x1++, y1);
		LineTo(hdcMain, x2--, y1++);
		}

	SetThePen(!fNormal);

	while (--i)
		{
		MMoveTo(hdcMain, x1--,  ++y2);
		LineTo(hdcMain, ++x2, y2);
		LineTo(hdcMain, x2, --y1);
		}
}

VOID DrawBackground(VOID)
{
	
/* Main Raised Border */
/*	int x, y; */
/*	DrawBorder(0, 0, x = dxpWindow, y = dypWindow, 3, fTrue); */

	DrawBorder(dxpNumOff-2, dypNumOff-2,
		dxpNumOff + dxpSpaceNum*numMax, dypNumOff+dypNum, 1, fFalse);

	DrawBorder(dxpTimeOff-2, dypTimeOff-2,
		dxpTimeOff + dxpTime+1, dypTimeOff+dypTime+1, 2, fTrue);

}

/*======================== ? ? ? ================================*/


/****** D R A W  S C R E E N ******/

VOID DrawScreen(HDC hdc)
{
	hdcMain = hdc;
	if (fWipe)
		ReWipe();
	DrawBackground();
	DrawLives();
	DrawScore();
	if (!fWipe)
		DrawGrid();
	DrawTime();
}

VOID DisplayScreen(VOID)
{
	StartDraw();
	DrawScreen(hdcMain);
	EndDraw();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\pref.h ===
/* pref.h */

typedef struct
{
	INT 	xWindow;
	INT 	yWindow;
	BOOL	fMenu;
	BOOL	fSound;
	BOOL	fMouse;
	BOOL  fColor;
	INT 	skill;
	INT 	level;
	INT 	HiScore;
	INT 	HiLevel;
	CHAR	szName[16];
} PREF;


VOID ReadPreferences(VOID);
VOID WritePreferences(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\menu.inc ===
/* menu.inc */

ID_MENU MENU
BEGIN
  
 POPUP     "&Game"
 BEGIN	  
 MENUITEM  "&New\tF2",        IDM_NEW
 MENUITEM  SEPARATOR
 MENUITEM  "&Pause\tF3",      IDM_PAUSE
 MENUITEM  SEPARATOR
 MENUITEM  "&Sound\tF4",      IDM_SOUND
 MENUITEM  "&Color",          IDM_COLOR
 MENUITEM  SEPARATOR
 MENUITEM  "E&xit",	      IDM_EXIT
 END	  
 	  
 POPUP     "&Skill"
 BEGIN	  
 MENUITEM  "&Beginner",       IDM_BEGIN
 MENUITEM  "&Intermediate",   IDM_INTER
 MENUITEM  "&Expert",         IDM_EXPERT
 MENUITEM  SEPARATOR
 MENUITEM  "&Room...",        IDM_ROOM
 END	  

 POPUP     "&Help"
 BEGIN	  
 MENUITEM  "&Index\tF1",      IDM_INDEX
 MENUITEM  "&How to Play",    IDM_HOW2PLAY
 MENUITEM  "&Commands",       IDM_COMMANDS
 MENUITEM  "Using &Help",     IDM_HELP_HELP
 MENUITEM  SEPARATOR
 MENUITEM  "&About Snake...", IDM_HELP_ABOUT
 END
 
END


ID_MENU_ACCEL ACCELERATORS
BEGIN
VK_F1, IDM_INDEX, VIRTKEY
VK_F2, IDM_NEW,   VIRTKEY
VK_F3, IDM_PAUSE, VIRTKEY
VK_F4, IDM_SOUND, VIRTKEY
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\pref.c ===
/****************/
/* file: pref.c */
/****************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "snake.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "pref.h"

BOOL fUpdateIni = fFalse;
LPSTR lpIniFile = "entpack.ini";

extern CHAR szClass[];
#define lpAppName szClass

PREF Preferences;

#define iszPrefxWindow 0
#define iszPrefyWindow 1
#define iszPrefSound   2
#define iszPrefMenu    3
#define iszPrefMouse   4
#define iszPrefSkill   5
#define iszPrefLevel   6
#define iszPrefHiScore 7
#define iszPrefHiLevel 8
#define iszPrefHiID    9
#define iszPrefColor  10

#define iszPrefMax 11

CHAR * rgszPref[iszPrefMax] =
{
"Xpos"    ,
"Ypos"    ,
"Sound"   ,
"Menu"    ,
"Mouse"   ,
"Skill"   ,
"Level"   ,
"HiScore" ,
"HiLevel" ,
"HiID"    ,
"Color"
};


extern INT dypCaption;
extern INT dypMenu;



/****** PREFERENCES ******/

INT ReadInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
	return max(valMin, min(valMax,
		(INT) GetPrivateProfileInt(lpAppName, rgszPref[iszPref], valDefault, lpIniFile) ) );
}

#define ReadBool(iszPref, valDefault) ReadInt(iszPref, valDefault, 0, 1)


VOID ReadPreferences(VOID)
{
	INT dyp;
	
	Preferences.xWindow  = ReadInt(iszPrefxWindow, 160, 0, 1024);
        dyp = dypCaption + dypMenu +
              max(0,(GetSystemMetrics(SM_CYSCREEN)-(dypGridOff+dypGrid+dypCaption+dypMenu))>>1);
        Preferences.yWindow = ReadInt(iszPrefyWindow, dyp, dyp, 1024);
	Preferences.fSound  = ReadBool(iszPrefSound, fTrue);
	Preferences.fMenu   = ReadInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	Preferences.fMouse  = ReadBool(iszPrefMouse, fFalse);
	Preferences.skill   = ReadInt(iszPrefSkill, skillInter, skillBegin, skillExpert);
	Preferences.level   = ReadInt(iszPrefLevel, 0, 0, 99);
	Preferences.HiLevel = ReadInt(iszPrefHiLevel, 0, 0, 9999);
	fUpdateIni = (Preferences.HiScore = ReadInt(iszPrefHiScore, 0, 0, 9999)) == 0;

	{
	HDC hDC = GetDC(GetDesktopWindow());
	Preferences.fColor  = ReadBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
	ReleaseDC(GetDesktopWindow(),hDC);
	}

}
	

VOID WriteInt(INT iszPref, INT val)
{
	CHAR szVal[15];

	wsprintf(szVal, "%d", val);

#ifdef DEBUG2
	{
		CHAR sz[80];
		wsprintf(sz,"\r\n i=%d v=%d x=",iszPref, val);
		OutputDebugString(sz);
		OutputDebugString(szVal);
		OutputDebugString("\r\n rgszPref=");
		OutputDebugString(rgszPref[iszPref]);
	}
#endif

	WritePrivateProfileString(lpAppName, rgszPref[iszPref], szVal, lpIniFile);
}

VOID WritePreferences(VOID)
{
	WriteInt(iszPrefSound,   Preferences.fSound);
#ifdef OH_WELL
	WriteInt(iszPrefMouse,   Preferences.fMouse);
#endif
	WriteInt(iszPrefSkill,   Preferences.skill);
	WriteInt(iszPrefLevel,   Preferences.level);
	WriteInt(iszPrefHiScore, Preferences.HiScore);
	WriteInt(iszPrefHiLevel, Preferences.HiLevel);
	WriteInt(iszPrefxWindow, Preferences.xWindow);
	WriteInt(iszPrefyWindow, Preferences.yWindow);
	WriteInt(iszPrefColor,   Preferences.fColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\res.h ===
/* SNAKE Resources */

#define ID_ICON_MAIN    100
#define ID_ICON_GENERIC 101
#define ID_ICON_DOS     102

#define ID_BMP_BLK      200
#define ID_BAW_BLK      201
#define ID_BMP_SNK      202
#define ID_BAW_SNK      203

#define ID_BMP_NUM      205
#define ID_BMP_WALL     206
#define ID_BMP_LVL      207


#define ID_DLG_ABOUT    300
#define ID_DLG_HELP     301

#define ID_BTN_HELP     129

#define ID_DLG_LEVEL    170
#define ID_EDIT_LEVEL   171
#define ID_BTN_OK       256
#define ID_BTN_CANCEL   257


/* MENUS */

#define ID_MENU         500
#define ID_MENU_ACCEL   501
							 	
#define IDM_GAME        510
#define IDM_NEW         511
#define IDM_PAUSE       513
#define IDM_SCORES      515
#define IDM_EXIT        517

#define IDM_SKILL       520
#define IDM_BEGIN       521
#define IDM_INTER       522
#define IDM_EXPERT      523
#define IDM_ROOM        525

#define IDM_OPTIONS     530
#define IDM_SOUND       531
#define IDM_COLOR       532

#define IDM_HELP        590
#define IDM_INDEX       591
#define IDM_HOW2PLAY    592
#define IDM_COMMANDS    593
#define IDM_KEYBOARD    594
#define IDM_HELP_HELP   595
#define IDM_HELP_ABOUT  597

#define ID_GAMENAME       1
#define ID_ERR_TITLE      2
#define ID_ERR_TIMER      3
#define ID_ERR_MEM        4
#define ID_ERR_UNKNOWN    5

#define ID_MSG_VERSION    6
#define ID_MSG_CREDIT     7

#define ID_ERR_MAX      999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\rtns.h ===
/****************/
/* file: rtns.h */
/****************/

#define lvlLevel 20
#define lvlGameOver 21
#define lvlMax 20

#define cLivesStart 3
#define cLivesMax 9

#define xMax 33
#define yMax 34

#define posMax (xMax*yMax)

#define posNW 0
#define posNE (xMax-1)
#define posSW (posMax-xMax)
#define posSE (posMax-1)

#define posEnter (posMax - 17)		/* Entrance: Bottom Center */
#define posLeave 16						/* Exit: Top Center */


/*** Bitmaps ***/


/* Blocks */

#define blkNull     0

#define blkFood     1
#define blkPlum     2
#define blkXXXX     3

#define blkHeadN    4
#define blkHeadE    5
#define blkHeadS    6
#define blkHeadW    7

#define blkTailN    8
#define blkTailE    9
#define blkTailS   10
#define blkTailW   11

#define blkBodyNE  12
#define blkBodySE  13
#define blkBodySW  14
#define blkBodyNW  15

#define blkBodyNS  16
#define blkBodyEW  17

#define blkMax 18

#define blkWallEW  0x1111
#define blkWallNS  0x1044
#define blkWallNW  0x1050
#define blkWallNE  0x1141
#define blkWallSW  0x1014
#define blkWallSE  0x1105



/*** Keys ***/

#define keyHelp  '?'
#define keyHelp2 '/'
#define keyStart ' '
#define keyPref  'P'
#define keyPref2 'p'
#define keyPanic 27	/* esc */


#define dirN 0
#define dirE 1
#define dirS 2
#define dirW 3

#define dirLft -1
#define dirRht +1

#define skillBegin  0
#define skillInter  1
#define skillExpert 2



#define tickNil -1

typedef INT TICK;	/* Ticks (1/10 of a second) */
typedef INT BLK;	/* Block */
typedef INT DIR;	/* Direction (N,E,S,W) */
typedef INT POS;	/* Facing | display style */


/*** Routines ***/

VOID StartLevel(VOID);
VOID StartGame(INT);
VOID DoTimer(VOID);

VOID DoChangeDir(DIR);
VOID DoChangeRelDir(DIR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\snake.h ===
/***********/
/* snake.h */
/***********/

#ifdef DEBUG
#define CHEAT
#endif

#ifdef BETA_VERSION
#define NOSERVER
#define EXPIRE
#endif

#define REGISTER register
#define FAST

/*** Standard Stuff ***/

#define fTrue	TRUE
#define fFalse	FALSE

#define hNil	NULL


#define ID_TIMER 1

/*** Status Stuff ***/

typedef INT STATUS;

#define fstatusPlay      0x01		/* ON if playing game, OFF if game over */
#define fstatusDemo      0x02		/* ON if demo   */
#define fstatusPause     0x08		/* ON if paused */
#define fstatusPanic     0x10		/* ON if panic  */
#define fstatusIcon      0x20    /* ON if iconic */

#define FPlay()          (status & fstatusPlay)
#define FDemo()          (status & fstatusDemo)
#define FPause()         (status & fstatusPause)
#define FPanic()         (status & fstatusPanic)
#define FIcon()          (status & fstatusIcon)

#define SetStatusPlay()  (status |= fstatusPlay)
#define SetStatusDemo()  (status |= fstatusDemo)
#define SetStatusPause() (status |= fstatusPause)
#define SetStatusPanic() (status |= fstatusPanic)
#define SetStatusIcon()  (status |= fstatusIcon)

#define ClrStatusPlay()  (status &= ~fstatusPlay)
#define ClrStatusDemo()  (status &= ~fstatusDemo)
#define ClrStatusPause() (status &= ~fstatusPause)
#define ClrStatusPanic() (status &= ~fstatusPanic)
#define ClrStatusIcon()  (status &= ~fstatusIcon)


#define fCalc    0x01
#define fResize  0x02
#define fDisplay 0x04

#define fmenuAlwaysOn 0x00
#define fmenuOff      0x01
#define fmenuOn       0x02

#define FMenuSwitchable()   (Preferences.fMenu != fmenuAlwaysOn)
#define FMenuOn()          ((Preferences.fMenu &  0x01) == 0)

#define cchMaxPathname 250
#define cchMsgMax  128
#define cchNameMax  16


/*** Routines ***/

LRESULT APIENTRY MainWndProc(HWND,  UINT, WPARAM, LPARAM);

VOID AdjustWindow(INT);
VOID FixMenus(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\strings.inc ===
/* strings.inc */

STRINGTABLE
  BEGIN
    ID_GAMENAME     "Snake"
    ID_ERR_TITLE    "Snake Error"
    ID_ERR_TIMER,   "Unable to allocate a timer.  Please exit some of your applications and try again."
    ID_ERR_UNKNOWN, "Error: %d"
    ID_ERR_MEM,     "Out of Memory"
    ID_MSG_VERSION,  "Snake (v0.8)"
    ID_MSG_CREDIT,   "by Robert Donner"
  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\rtns.c ===
/******************/
/* SNAKE ROUTINES */
/******************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "snake.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "blk.h"
#include "pref.h"
#include "sound.h"
#include "util.h"


/*** Global/Local Variables ***/


BLK mpposblk[posMax];	/* The playing grid */


POS posHead;		/* current position of head */
POS posTail;		/* current position of tail */

BOOL fHead;			/* True if head is visible */
BOOL fTail;

BOOL fExit = fFalse;

BOOL fPlum;
POS  posPlum;
INT  offPlumNS;
INT  offPlumEW;

INT cDelayHead;	/* Delay before head shows up */
INT cDelayTail;

INT cfoodRemain;	/* Amount of food left to eat */
INT cfoodUsed;		/* Amount of food eaten */
INT cLevel = 0;		/* current level */

INT cLives = cLivesStart;			/* Count of Lives */

#define idirMax 10
DIR rgdir[idirMax];

INT idirCurr;
INT idirLast;

INT ctickMove;
INT ctickMoveMac = 4;

INT ctickTime;
INT ctickTimeMac = 1;

#define cTimeLeftMax dxpTime
INT cTimeLeft = cTimeLeftMax;

#define lenStart 7

extern INT   score;
extern BOOL  fWipe;

INT rgtickSkill[3] = {5, 3, 1};

BLK mpdirdirblk[4][4] =
{
 {blkBodyNS, blkBodySE, blkNull,   blkBodySW},	/* N */
 {blkBodyNW, blkBodyEW, blkBodySW, blkNull  },	/* E */
 {blkNull,   blkBodyNE, blkBodyNS, blkBodyNW},	/* S */
 {blkBodyNE, blkNull,   blkBodySE, blkBodyEW}	/* W */
};


#define IncIDir(idir)   (idir = (idir+1) % idirMax)

#define BlkTailFromDir(dir)  (blkTailN + (dir))
#define BlkHeadFromDir(dir)  (blkHeadN + (dir))
#define DirFromBlk(blk)      ((DIR) ((blk) & 0x0003))


/*** Global/External Variables ***/

extern STATUS status;
extern PREF Preferences;
extern BOOL fUpdateIni;
extern INT cMoveScore;




/****** C H A N G E  P O S  B L K ******/

VOID ChangePosBlk(POS pos, BLK blk)
{
	mpposblk[pos] = blk;
	DisplayPos(pos);
}


/****** D R O P  F O O D ******/

POS DropFood(VOID)
{
	POS pos;

	while (mpposblk[pos = Rnd(posMax)] != blkNull)
		;
	mpposblk[pos] = blkFood;

	return pos;
}


/****** P O S  F R O M  P O S  D I R ******/

POS PosFromPosDir(POS pos, DIR dir)
{
	switch (dir)
		{
	case dirN:
		return (pos - xMax);

	case dirE:
		return (pos + 1);

	case dirS:
		return (pos + xMax);

	case dirW:
		return (pos - 1);

#ifdef DEBUG
	default:
		Oops("PosFromPosDir: Invalid Direction");
		return pos;
#endif
		}

    // program should not reach this section of code!
    return pos;
}

/****** D I R  F R O M  P O S  P O S ******/

DIR DirFromPosPos(POS posSrc, POS posDest)
{
	INT dpos = posDest-posSrc;

	if (dpos == xMax)
		return dirS;

	else if (dpos == 1)
		return dirE;

	else if (dpos == -xMax)
		return dirN;

#ifndef DEBUG
	else
		return dirW;
#else
	else if (dpos == -1)
		return dirW;

	else
		Oops("DirFromPosPos: Invalid Direction");
		return dirN;
#endif
}


/****** B L K  T A I L  F R O M  B L K  B L K ******/

BLK BlkTailFromBlkBlk(BLK blkSrc, BLK blkDest)
{
	if (blkDest == blkBodyNS || blkDest == blkBodyEW)
		return blkSrc;

	if (blkDest == blkBodyNE)
		if (blkSrc == blkTailW)
			return blkTailN;
		else
			return blkTailE;

	else if (blkDest == blkBodySE)
		if (blkSrc == blkTailW)
			return blkTailS;
		else
			return blkTailE;

	else if (blkDest == blkBodySW)
		if (blkSrc == blkTailE)
			return blkTailS;
		else
			return blkTailW;

	else /* if (blkDest == blkBodyNW) */
		if (blkSrc == blkTailE)
			return blkTailN;
		else
			return blkTailW;
}




/****** D O  C H A N G E  D I R ******/

VOID DoChangeDir(DIR dir)
{
	if (!fHead)
		return;

	if (((dir+2) % 4) == rgdir[idirLast])	/* Don't allow about faces */
		return;

	if (IncIDir(idirLast) == idirCurr)	/* Watch for overflow */
		{
		if (--idirLast < 0)
			idirLast = idirMax-1;
		return;
		}

	rgdir[idirLast] = dir;
}


/****** D O  C H A N G E  R E L  D I R ******/

VOID DoChangeRelDir(DIR dirRel)
{
	if ( (dirRel = rgdir[idirLast] + dirRel) < 0)
		dirRel = dirW;
	else if (dirRel > dirW)
		dirRel = dirN;

	DoChangeDir(dirRel);
}


/****** K I L L  S N A K E ******/

VOID KillSnake(VOID)
{
	fHead = fTail = fFalse;
	fPlum = fFalse;

	if (cLives--)
		{
		PlayTune(TUNE_HITHEAD);
		StartLevel();
		}
	else
		{
		PlayTune(TUNE_LOSEGAME);
		cLives = 0;
		ClrStatusPlay();
		if (score > Preferences.HiScore)
			{
			/* Congrats, etc. */
			Preferences.HiScore = score;
			Preferences.HiLevel = cLevel;
			fUpdateIni = fTrue;
			}
		DisplayGameOver();
		}
}


/****** D E C  T I M E ******/

/* Decrement time left */

VOID DecTime(VOID)
{
	if (--cTimeLeft < 0)
		{
		INT i;
		for (i = 0; i < 3; i++)
			{
			DisplayPos(DropFood());
			cfoodRemain++;
			}
		cTimeLeft = cTimeLeftMax;
		DisplayTime();
		}
	else
		UpdateTime();
}



/****** D O  M O V E ******/

VOID DoMove(VOID)
{
	POS posPrev;
	BLK blkPrev;
	DIR dir;

	if (fHead)
		{
		if (posHead == posLeave && fExit)
			{
			ChangePosBlk(posHead, blkBodyNS);
			fHead = fFalse;
			}
		else
			{
			/* Check heading/direction */

			if ((idirCurr != idirLast) && (posHead != posEnter))
				IncIDir(idirCurr);

			/* Change head into body */
		
			blkPrev = mpposblk[posPrev = posHead];
			posHead = PosFromPosDir(posPrev, dir = rgdir[idirCurr]);

			if (mpposblk[posHead] != blkNull)
				{
				if (mpposblk[posHead] < blkHeadN)	/*** EAT FOOD ***/
					{
					AddScore(1);
					cTimeLeft = cTimeLeftMax;
					DisplayTime();

					if (--cfoodRemain == 0)
						{
						fExit = fTrue;
						ctickTime = tickNil;
						cTimeLeft = cTimeLeftMax;
						DisplayTime();
						ChangePosBlk(posLeave, blkNull);
						}
					fTail = fFalse;
					cDelayTail += 4;
					}
				else
					{
					KillSnake();
					return;
					}
				}

			ChangePosBlk(posPrev, mpdirdirblk[DirFromBlk(blkPrev)][dir]);
			ChangePosBlk(posHead, BlkHeadFromDir(dir));
			}

		}
	else if (cDelayHead)
		{
		if (--cDelayHead == 0)
			{
			ChangePosBlk(posHead, blkHeadN);
			fHead = fTrue;
			}
		}
	else
		{
		ctickMove = 1;		/* Must be leaving (fExit == fTrue) */
		}

	if (fTail)
		{
		if (posTail == posLeave)
			{
			ChangePosBlk(posTail, blkNull);
			fTail = fFalse;

			if ((++cLevel % lvlMax) == 0)
				{
				if (ctickMoveMac > 1)
					ctickMoveMac--;
				PlayTune(TUNE_WINGAME);
				}
			else
				PlayTune(TUNE_WINLEVEL);
				
			StartLevel();
			AddScore(10);
			}

		else
			{
			/* Remove old tail */
		
			blkPrev = mpposblk[posPrev = posTail];
			if (posTail == posEnter)
				ChangePosBlk(posPrev, blkWallEW);	/* Close entrance */
			else
				ChangePosBlk(posPrev, blkNull);

			/* Display new tail */
		
			posTail = PosFromPosDir(posPrev, DirFromBlk(blkPrev));

			ChangePosBlk(posTail, BlkTailFromBlkBlk(blkPrev, mpposblk[posTail]));
			}
		}
	else if (cDelayTail)
		{
		if (--cDelayTail == 0)
			{
			if (posTail == posEnter)
				{
				ChangePosBlk(posTail, blkTailN);
				}
			fTail = fTrue;
			}
		}


}



/****** F  K I L L  B O U N C E ******/

BOOL FKillBounce(POS pos)
{
	if (mpposblk[pos] != blkNull)
		{
		if (pos == posHead)
			KillSnake();
		return fTrue;
		}
	else
		if (pos == posLeave)	/* Don't go into exit */
			return fTrue;
		else
			return fFalse;
}


/****** D O  T I M E R ******/

VOID DoTimer(VOID)
{
	BOOL fBounce = 0;	/* Variable - there must be a better way */

	if (cMoveScore != 0)
		MoveScore();

	if (!FPlay())
		return;

	if (--ctickMove == 0)
		{
		ctickMove = ctickMoveMac;
		DoMove();

	if (fPlum)
		{
		if (FKillBounce(posPlum + offPlumNS))
			{
			offPlumNS = -offPlumNS;
			fBounce = 1;
			}
		if (FKillBounce(posPlum + offPlumEW))
			{
			offPlumEW = -offPlumEW;
			fBounce = 2;
			}

		if (!fBounce)
			{
			if (FKillBounce(posPlum + offPlumNS + offPlumEW))
				{
				offPlumNS = -offPlumNS;
				offPlumEW = -offPlumEW;
				}
			}
		else if (FKillBounce(posPlum+offPlumNS + offPlumEW))
			{
			if (fBounce == 1)
				offPlumEW = -offPlumEW;
			else
				offPlumNS = -offPlumNS;
			}

		if (fPlum && (mpposblk[posPlum + offPlumNS + offPlumEW] == blkNull))
			{
			ChangePosBlk(posPlum, blkNull);
			posPlum += offPlumNS + offPlumEW;
			ChangePosBlk(posPlum, blkPlum);
			}
		}

		}
	else if (ctickMove < -50 && (cMoveScore==0))		/* This happens at the start of a game */
		{
		fPlum = (cLevel >= lvlMax);
		ctickMove = ctickMoveMac;
		ctickTime = ctickTimeMac;
		cTimeLeft = cTimeLeftMax;
		fWipe = fFalse;
		SetLevelColor();
		DisplayScreen();
		}

	if (--ctickTime == 0)
		{
		ctickTime = ctickTimeMac;
		DecTime();
		}
}


/****** S T A R T  L E V E L *******/

VOID StartLevel(VOID)
{
	fPlum = fFalse;

	cTimeLeft = cTimeLeftMax;

	DisplayLevelNum();

	SetupLevelData();

	if (cLevel >= lvlMax)
		{
		offPlumNS = xMax;
		offPlumEW = 1;
		posPlum = 4*xMax + 3;
		while (mpposblk[posPlum] != blkNull)
			posPlum--;
		mpposblk[posPlum] = blkPlum;
		}

	/* Distribute Food */

	cfoodUsed = cfoodRemain = 10;
	while (cfoodUsed--)
		{
		DropFood();
		}


	/* Setup player position */

	fTail = fHead = fFalse;

	cDelayHead = 3;
	cDelayTail = lenStart;

	posTail = posHead = posEnter;

	ctickMove = -1;	/* Indicate Starting Level */
	ctickTime = -1;

	rgdir[idirCurr=idirLast=0] = dirN;

	ClrStatusIcon();
	SetStatusPlay();
}


/****** S T A R T  G A M E *******/

VOID StartGame(INT lvl)
{
	cLevel = lvl;
	cLives = cLivesStart;

	ctickMoveMac = max(0,rgtickSkill[Preferences.skill] - cLevel/lvlMax);
	ctickTimeMac = Preferences.skill ? 1 : 2;

	ResetScore();
	DisplayScore();
	StartLevel();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\context.h ===
#define HLP_INDEX     0x0000
#define HLP_HOWTOPLAY 0x0001
#define HLP_COMMANDS  0x0002
#define HLP_KEYBOARD  0x0003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\sound.h ===
/*****************/
/* file: sound.h */
/*****************/

#define TUNE_HITHEAD   1
#define TUNE_WINLEVEL  2
#define TUNE_WINGAME   3
#define TUNE_LOSEGAME  4

VOID InitTunes(VOID);
VOID PlayTune(INT);
VOID KillTune(VOID);
VOID EndTunes(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\sound.c ===
/******************/
/* SOUND ROUTINES */
/******************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "sound.h"
#include "pref.h"

extern PREF Preferences;


/****** I N I T  T U N E S ******/

VOID InitTunes(VOID)
{
//	OpenSound();
//	SetVoiceAccent(1, 120, 128, S_LEGATO, 0);
}


/****** K I L L  T U N E ******/

VOID KillTune(VOID)
{
//	StopSound();
}


/****** E N D  T U N E S ******/

VOID EndTunes(VOID)
{
//	KillTune();
//	CloseSound();
}



/****** P L A Y  T U N E ******/

VOID PlayTune(INT tune)
{
/*	if (!Preferences.fSound)
		return;

	switch (tune)
		{
	case TUNE_HITHEAD:
		SetVoiceNote(1, 10, 4, 1);
		break;
		
	case TUNE_WINLEVEL:
		SetVoiceNote(1, 24, 16, 1);
		SetVoiceNote(1, 36, 16, 1);
		break;
		
	case TUNE_WINGAME:
		SetVoiceNote(1, 24, 16, 1);
		SetVoiceNote(1, 26, 16, 1);
		SetVoiceNote(1, 28, 16, 1);
		SetVoiceNote(1, 29, 16, 1);
		SetVoiceNote(1, 31, 16, 1);
		SetVoiceNote(1, 33, 16, 1);
		SetVoiceNote(1, 35, 16, 1);
		SetVoiceNote(1, 36, 16, 1);
		break;
		
	case TUNE_LOSEGAME:
		SetVoiceNote(1, 36, 8, 1);
		SetVoiceNote(1, 24, 8, 1);
		SetVoiceNote(1, 36, 8, 1);
		SetVoiceNote(1, 24, 8, 1);
		SetVoiceNote(1, 36, 8, 1);
		SetVoiceNote(1, 24, 8, 1);
		break;

#ifdef DEBUG
	default:
		Oops("Invalid Tune");
		break;
#endif
		}

	StartSound();
*/
   (tune);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\snake.c ===
/****************************************************************************

    PROGRAM: Snake   (a.k.a. Centipede, Train...)

****************************************************************************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>


#include "snake.h"
#include "rtns.h"
#include "grafix.h"
#include "util.h"
#include "res.h"
#include "pref.h"
#include "blk.h"
#include "context.h"
#include "string.h"
#include "stdio.h"
#include "dos.h"


#ifndef WM_ENTERMENULOOP
#define WM_ENTERMENULOOP 0x0211
#define WM_EXITMENULOOP  0x0212
#endif

HANDLE hInst;
HWND   hwndMain;
HMENU  hMenu;

STATUS status = fstatusIcon;

INT dxpWindow;
INT dypWindow;
INT dypCaption;
INT dypMenu;
INT dypAdjust;
INT dypBorder;
INT dxpBorder;

BOOL fLocalPause = fFalse;
BOOL fEGA;

CHAR szClass[cchNameMax];
#define szWindowTitle szClass

extern INT ctickTimeMac;
extern INT ctickMoveMac;
extern INT cLevel;

extern PREF Preferences;
extern BOOL fUpdateIni;

INT_PTR  APIENTRY LevelDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);



/****** W I N  M A I N ******/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
/* { */
	MSG msg;
	HANDLE hAccel;

	hInst = hInstance;

	InitConst();

#ifdef WIN16
	if (hPrevInstance)
		{
		HWND hWnd = FindWindow(szClass, NULL);
		hWnd = GetLastActivePopup(hWnd);
		BringWindowToTop(hWnd);
		if (IsIconic(hWnd))
			ShowWindow(hWnd, SW_RESTORE);
		return fFalse;
		}
#endif
	{
	WNDCLASS  wc;

	wc.style = 0;
	wc.lpfnWndProc   = MainWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInst;
	wc.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN));
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = szClass;

	if (!RegisterClass(&wc))
		return fFalse;
	}

#ifdef NOSERVER		/* Not in final release */
	{
	CHAR  szFile[256];

	GetModuleFileName(hInst, szFile, 250);
	if (szFile[0] > 'C')
		{
		szFile[0] = 'X';
		if (!strcmp(szFile, "X:\\WINGAMES\\SNAKE\\SNAKE.EXE"))
			{
			MessageBox(GetFocus(),
				"Please copy snake to your machine and run it from there.",
				"NO NO NO NO NO",
				MB_OK);
			return fFalse;
			}
		}
	}
#endif


#ifdef EXPIRE			/*** Not in final release ***/
	{
	struct dosdate_t ddt;

	_dos_getdate(&ddt);

	if ((ddt.month + ddt.year*12) > (8 + 1990*12))
		{
		MessageBox(GetFocus(),
			"This game has expired. Please obtain an official copy from the Windows Entertainment Package.",
			"SORRY",
			MB_OK);
		return fFalse;
		}
	}
#endif


	hMenu = LoadMenu(hInst, MAKEINTRESOURCE(ID_MENU));
	hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_MENU_ACCEL));

	ReadPreferences();

	AdjustWindow(fCalc);

	hwndMain = CreateWindow(szClass, szWindowTitle,
		WS_OVERLAPPED | WS_MINIMIZE | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU,
		Preferences.xWindow-dxpBorder, Preferences.yWindow-dypAdjust,
		dxpWindow + dxpBorder, dypWindow + dypAdjust,
		NULL, NULL, hInst, NULL);

	if (!hwndMain)
		{
		ReportErr(1000);
		return fFalse;
		}
		
	if (SetTimer(hwndMain, ID_TIMER, 50 , NULL) == 0)
		{
		ReportErr(ID_ERR_TIMER);
		return fFalse;
		}

	if (!FInitLocal())
		{
		ReportErr(ID_ERR_MEM);
		return fFalse;
		}

	SetMenuBar(Preferences.fMenu);

	ShowWindow(hwndMain, SW_SHOWNORMAL);
	UpdateWindow(hwndMain);

	StartGame(cLevel);

	while (GetMessage(&msg, NULL, 0, 0))
		{
		if (!TranslateAccelerator(hwndMain, hAccel, &msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}

	CleanUp();

	if (fUpdateIni)
		WritePreferences();

	return (INT)(msg.wParam);
}



/****** F I X  M E N U S ******/

VOID FixMenus(VOID)
{
	CheckEm(IDM_SOUND,  Preferences.fSound);
	CheckEm(IDM_COLOR,  Preferences.fColor);

	CheckEm(IDM_BEGIN,  Preferences.skill == skillBegin);
	CheckEm(IDM_INTER,  Preferences.skill == skillInter);
	CheckEm(IDM_EXPERT, Preferences.skill == skillExpert);
}



/****** D O  G E T  R O O M ******/

VOID DoGetRoom(VOID)
{

	fLocalPause = fTrue;

	DialogBox(hInst, MAKEINTRESOURCE(ID_DLG_LEVEL), hwndMain, LevelDlgProc);
	fLocalPause = fFalse;
	StartGame(cLevel);
}

	
/****** M A I N  W N D  P R O C ******/

LRESULT APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

	switch (message)
    {

//	case WM_QUERYENDSESSION:
	case WM_DESTROY:
//LExit:
		KillTimer(hwndMain, ID_TIMER);
        DoHelp(HELP_QUIT, 0L);
		PostQuitMessage(0);
		break;

	case WM_SYSCOMMAND:
		switch (wParam & 0xFFF0)
			{
		case SC_MINIMIZE:
			SetStatusPause();
			SetStatusIcon();
			break;
			
		case SC_RESTORE:
			ClrStatusPause();
			ClrStatusIcon();
			break;

		default:
			break;
			}
			
		break;


	case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam))
			{

/** GAME **/

		case IDM_NEW:
			StartGame(cLevel);
			break;

		case IDM_PAUSE:
			if (FPause())
				ClrStatusPause();
			else
				SetStatusPause();
			CheckEm(IDM_PAUSE, FPause());
			break;
				 	 	
		case IDM_ROOM:
			DoGetRoom();
			break;

		case IDM_EXIT:
			ShowWindow(hwndMain, SW_HIDE);
#ifdef ORGCODE
			goto LExit;
#else
            SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
            return(0);
#endif

//			break;

/** SKILL **/

		case IDM_BEGIN:
		case IDM_INTER:
		case IDM_EXPERT:
			Preferences.skill = (INT) wParam - IDM_BEGIN;
			StartGame(cLevel);
			goto LUpdateMenu;
	
/** OPTIONS **/
		case IDM_COLOR:
			Preferences.fColor = !Preferences.fColor;
			FreeBitmaps();
			if (!FLoadBitmaps())
				{
				ReportErr(ID_ERR_MEM);
#ifdef ORGCODE
				goto LExit;
#else
                SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
                return(0);
#endif
				}
			DisplayScreen();
			goto LUpdateMenu;

		case IDM_SOUND:
			Preferences.fSound = !Preferences.fSound;
/* IE		goto LUpdateMenu; */

LUpdateMenu:
			fUpdateIni = fTrue;
			FixMenus();
			break;


/** HELP **/
		case IDM_INDEX:
			DoHelp(HELP_INDEX, 0L);
			break;

		case IDM_HOW2PLAY:
			DoHelp(HELP_CONTEXT, HLP_HOWTOPLAY);
			break;

		case IDM_COMMANDS:
			DoHelp(HELP_CONTEXT, HLP_COMMANDS);
			break;

		case IDM_HELP_HELP:
			DoHelp(HELP_HELPONHELP, 0L);
			break;

		case IDM_HELP_ABOUT:
			DoAbout();
			return 0;

		default:
			break;
			}	

/*** KEYS ***/

	case WM_KEYDOWN:
		switch (wParam)
			{
		case VK_ESCAPE:
			PostMessage(hwndMain, WM_SYSCOMMAND, SC_MINIMIZE, 0L);
			break;
			
		case VK_UP:
			DoChangeDir(dirN);
			break;

		case VK_DOWN:
			DoChangeDir(dirS);
			break;

		case VK_LEFT:
			DoChangeDir(dirW);
			break;

		case VK_RIGHT:
			DoChangeDir(dirE);
			break;

		case VK_F5:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOff);
			break;

		case VK_F6:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOn);
			break;

		default:
			break;
			}	

		break;


	case WM_CHAR:
			switch (wParam)
				{
			case 'A':
			case 'a':
			case '8':
			case 'i':
			case 'I':
				DoChangeDir(dirN);
				break;

			case 'Z':
			case 'z':
			case '2':
			case '5':
			case 'k':
			case 'K':
				DoChangeDir(dirS);
				break;

			case ',':
			case '4':
			case 'j':
			case 'J':
				DoChangeDir(dirW);
				break;

			case '.':
			case '6':
			case 'l':
			case 'L':
				DoChangeDir(dirE);
				break;

#ifdef DEBUG
			case '+':
			case '=':
				if (ctickMoveMac > 1)
					ctickMoveMac--;
				break;

			case '-':
			case '_':
				ctickMoveMac++;
				break;

			case ';':
				cLevel++;
				StartLevel();
				break;
#endif

			default:
				break;
				}
		break;

	case WM_LBUTTONDOWN:
		if (Preferences.fMouse)
			DoChangeRelDir(dirLft);
		break;

	case WM_RBUTTONDOWN:
		if (Preferences.fMouse)
			DoChangeRelDir(dirRht);
		break;

	case WM_TIMER:
		if (!FPause() && !fLocalPause)
			DoTimer();
		return 0;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hwnd,&ps);

		DrawScreen(hDC);

		EndPaint(hwnd, &ps);
		}
		return 0;

	case WM_ENTERMENULOOP:
		fLocalPause = fTrue;
		break;

	case WM_EXITMENULOOP:
		fLocalPause = fFalse;
		break;

	case WM_ACTIVATE:
		if (GET_WM_ACTIVATE_STATE(wParam, lParam) == 0)
			fLocalPause = fTrue;
		else
			fLocalPause = fFalse;
		break;

	case WM_MOVE:
		if (!FIcon())
			{
			Preferences.xWindow = 1+LOWORD(lParam);
			Preferences.yWindow = 1+HIWORD(lParam);
			}	
		break;

	default:
		break;

    }

	return (DefWindowProc(hwnd, message, wParam, lParam));
}




/*** L E V E L  D L G  P R O C ***/

INT_PTR  APIENTRY LevelDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
		{
	case WM_INITDIALOG:
		SetDlgItemInt(hDlg, ID_EDIT_LEVEL,  10, fFalse);
		return (fTrue);

	case WM_COMMAND:
		switch(GET_WM_COMMAND_ID(wParam, lParam))
			{
		case ID_BTN_OK:
		case IDOK:
			cLevel = GetDlgInt(hDlg, ID_EDIT_LEVEL, 1, 50) -1;

			/* Fall Through & Exit */

		case ID_BTN_CANCEL:
		case IDCANCEL:
			EndDialog(hDlg, fTrue);	      /* Exits the dialog box	     */
			return fTrue;

		default:
			break;
			}
		}

	return (fFalse);			/* Didn't process a message    */
      (lParam);
}



/****** A D J U S T  W I N D O W ******/

VOID AdjustWindow(INT fAdjust)
{

	dypAdjust = dypCaption;

	if (FMenuOn())
		dypAdjust += dypMenu;

	dxpWindow = dxpGridOff + dxpGrid;
	dypWindow = dypGridOff + dypGrid;

	if (fAdjust & fResize)
		{
		MoveWindow(hwndMain, Preferences.xWindow - dxpBorder,
			Preferences.yWindow - dypAdjust,
			dxpWindow+dxpBorder, dypWindow + dypAdjust, fTrue);
		}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\util.h ===
/**********/
/* util.h */
/**********/

VOID InitConst(VOID);
VOID LoadSz(WORD, CHAR *);
VOID ReportErr(WORD);
INT  Rnd(INT);

INT  GetDlgInt(HWND, INT, INT, INT);

VOID DoHelp(UINT, ULONG_PTR);
VOID DoAbout(VOID);

VOID CheckEm(WORD, BOOL);
VOID SetMenuBar(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\snake\util.c ===
/**********/
/* util.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "snake.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "dos.h"

extern INT dypBorder; 
extern INT dxpBorder;
extern INT dypCaption;
extern INT dypMenu;

extern CHAR szClass[cchNameMax];

extern HANDLE hInst;
extern HWND   hwndMain;
extern HMENU  hMenu;

extern BOOL fEGA;
extern PREF Preferences;



VOID  APIENTRY AboutWEP(HWND hwnd, HICON hicon, LPSTR lpTitle, LPSTR lpCredit);


/****** R N D ******/

/* Return a random number between 0 and rndMax */

INT Rnd(INT rndMax)
{
	return (rand() % rndMax);
}



/****** R E P O R T  E R R ******/

/* Report and error and exit */

VOID ReportErr(WORD idErr)
{
	CHAR szMsg[cchMsgMax];
	CHAR szMsgTitle[cchMsgMax];

	if (idErr < ID_ERR_MAX)
		LoadString(hInst, idErr, szMsg, cchMsgMax);
	else
		{
		LoadString(hInst, ID_ERR_UNKNOWN, szMsgTitle, cchMsgMax);
		wsprintf(szMsg, szMsgTitle, idErr);
		}

	LoadString(hInst, ID_ERR_TITLE, szMsgTitle, cchMsgMax);

	MessageBox(NULL, szMsg, szMsgTitle, MB_OK | MB_ICONHAND);
}


/****** L O A D  S Z ******/

VOID LoadSz(WORD id, CHAR * sz)
{
	if (LoadString(hInst, id, (LPSTR) sz, cchMsgMax) == 0)
		ReportErr(1001);
}



/****** I N I T  C O N S T ******/

VOID InitConst(VOID)
{
	srand(LOWORD(GetCurrentTime()));

	LoadSz(ID_GAMENAME, szClass);
	
	fEGA = GetSystemMetrics(SM_CYSCREEN) == 350;

	dypCaption = GetSystemMetrics(SM_CYCAPTION) + 1;
	dypMenu    = GetSystemMetrics(SM_CYMENU)    + 1;
	dypBorder  = GetSystemMetrics(SM_CYBORDER)  + 1;
	dxpBorder  = GetSystemMetrics(SM_CXBORDER)  + 1;
}



/* * * * * *  M E N U S  * * * * * */

/****** C H E C K  E M ******/

VOID CheckEm(WORD idm, BOOL fCheck)
{
	CheckMenuItem(hMenu, idm, fCheck ? MF_CHECKED : MF_UNCHECKED);
}

/****** S E T  M E N U  B A R ******/

VOID SetMenuBar(INT fActive)
{
	Preferences.fMenu = fActive;
	FixMenus();
	SetMenu(hwndMain, FMenuOn() ? hMenu : NULL);
 	AdjustWindow(fResize);
}


/****** D O  A B O U T ******/

VOID DoAbout(VOID)
{
	CHAR szVersion[cchMsgMax];
	CHAR szCredit[cchMsgMax];

	LoadSz(ID_MSG_VERSION, szVersion);
	LoadSz(ID_MSG_CREDIT,  szCredit);

	AboutWEP(hwndMain, LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN)),
	  szVersion, szCredit);
}


/****** D O  H E L P ******/

VOID DoHelp(UINT wCommand, ULONG_PTR lParam)
{
   CHAR szHelpFile[cchMaxPathname];
	CHAR * pch;

   pch = szHelpFile + GetModuleFileName(hInst, szHelpFile, cchMaxPathname);
	if ( ((pch-szHelpFile) > 4) && (*(pch-4) == '.') )
		pch -= 4;
	lstrcpy((LPSTR) pch, (LPSTR) ".HLP");

	WinHelp(hwndMain, szHelpFile, wCommand, lParam);
}



/****** G E T  D L G  I N T ******/

INT GetDlgInt(HWND hDlg, INT dlgID, INT numLo, INT numHi)
{
	INT num;
	BOOL fFlag;

	num = GetDlgItemInt(hDlg, dlgID, &fFlag, fFalse);

	if (num < numLo)
		num = numLo;
	else if (num > numHi)
		num = numHi;

	return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\main.h ===
/* main.h */

#ifdef DEBUG
#define CHEAT
#endif

#ifdef BETA_VERSION
#define NOSERVER
#define EXPIRE
#endif

/*** Standard Stuff ***/

#define fTrue	TRUE
#define fFalse	FALSE

#define hNil	NULL

#define REGISTER register

/*** Status Stuff ***/

typedef INT STATUS;

#define fstatusPlay      0x01		/* ON if playing game, OFF if game over */
#define fstatusDemo      0x02		/* ON if demo   */
#define fstatusPause     0x08		/* ON if paused */
#define fstatusPanic     0x10		/* ON if panic  */
#define fstatusIcon      0x20    /* ON if iconic */

#define FPlay()          (status & fstatusPlay)
#define FDemo()          (status & fstatusDemo)
#define FPause()         (status & fstatusPause)
#define FPanic()         (status & fstatusPanic)
#define FIcon()          (status & fstatusIcon)

#define SetStatusPlay()  (status |= fstatusPlay)
#define SetStatusDemo()  (status |= fstatusDemo)
#define SetStatusPause() (status |= fstatusPause)
#define SetStatusPanic() (status |= fstatusPanic)
#define SetStatusIcon()  (status |= fstatusIcon)

#define ClrStatusPlay()  (status &= ~fstatusPlay)
#define ClrStatusDemo()  (status &= ~fstatusDemo)
#define ClrStatusPause() (status &= ~fstatusPause)
#define ClrStatusPanic() (status &= ~fstatusPanic)
#define ClrStatusIcon()  (status &= ~fstatusIcon)


#define fCalc    0x01
#define fResize  0x02
#define fDisplay 0x04

#define fmenuAlwaysOn  0x00
#define fmenuOff       0x01
#define fmenuOn        0x02

#define FMenuSwitchable()   (Preferences.fMenu != fmenuAlwaysOn)
#define FMenuOn()          ((Preferences.fMenu &  0x01) == 0)

#define cchMaxPathname 250
#define cchMsgMax  128
#define cchNameMax  16


/*** Routines ***/

LRESULT APIENTRY MainWndProc(HWND,  UINT, WPARAM, LPARAM);

VOID AdjustWindow(INT);
VOID FixMenus(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\grafix.c ===
/************/
/* grafix.c */				/* WARNING: The following code ain't pretty */
/************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "grafix.h"
#include "rtns.h"
#include "pref.h"
#include "sound.h"

HDC     hDCTemp;
HDC     hDCBall;
HDC     hDCBack;
HBITMAP hbmTemp;
HBITMAP hbmBall;
HBITMAP hbmBack;

HPEN hPenLtGray;
HPEN hPenGray;

INT rgXBlk[cBlkMax];		/* Positions of squares on screen */
INT rgYBlk[cBlkMax];

INT rgBallOff[iBallMax];	/* Offsets into the ball bitmap */


/*** External Data ***/

extern HWND   hwndMain;
extern HANDLE hInst;

extern INT dyBlkPlane;
extern INT dypPlane;
extern INT dxpPlane;

extern INT dxpGrid;
extern INT dypGrid;
extern INT dxpWindow;
extern INT dypWindow;
extern INT dxpGridOff;

extern INT cBlkRow;
extern INT cBlkPlane;
extern INT cPlane;
extern INT cBlkMac;

extern rgBlk[cBlkMax];
extern rgFlash[cDimMax];

extern INT iPlayer;
extern BOOL f4;
extern PREF Preferences;



/****** F I N I T  L O C A L ******/

BOOL FInitLocal(VOID)
{
	INT y;
	
	HDC hDCScrn;

	hPenLtGray = CreatePen(PS_SOLID, 1, RGB_LTGRAY);
	hPenGray   = CreatePen(PS_SOLID, 1, RGB_GRAY);

	hDCScrn  = GetDC(hwndMain);

	hDCTemp  = CreateCompatibleDC(NULL);
	hbmTemp  = CreateCompatibleBitmap(hDCScrn, dxpGridMax, dypGridMax);
	SelectObject(hDCTemp, hbmTemp);

	hDCBack  = CreateCompatibleDC(NULL);
	hbmBack  = CreateCompatibleBitmap(hDCScrn, dxpGridMax, dypGridMax);
	SelectObject(hDCBack, hbmBack);

	hDCBall  = CreateCompatibleDC(NULL);

	ReleaseDC(hwndMain, hDCScrn);

	GetTheBitmap();

	for (y = 0; y < iBallMax; y++)
		rgBallOff[y] = y*dyBall;

	return ((hDCTemp != NULL) && (hbmTemp != NULL) &&
		     (hDCBack != NULL) && (hbmBack != NULL) &&
		     (hDCBall != NULL) && (hbmBall != NULL) );
}


VOID GetTheBitmap(VOID)
{
HBITMAP hbm;

	hbmBall  = LoadBitmap(hInst, MAKEINTRESOURCE(ID_BMP_BALL+(!Preferences.fColor)));
	if (hDCBall != NULL)
        {		
                hbm = SelectObject(hDCBall, hbmBall);
                if (hbm)
                    DeleteObject(hbm);
        }
}




/****** C L E A N  U P ******/

VOID CleanUp(VOID)
{
	EndTunes();
	
	DeleteDC(hDCBall);
	DeleteDC(hDCBack);
	DeleteDC(hDCTemp);

	DeleteObject(hbmBall);
	DeleteObject(hbmBack);
	DeleteObject(hbmTemp);

	DeleteObject(hPenGray);
	DeleteObject(hPenLtGray);
}



/****** S E T U P  B O A R D ******/

VOID SetupBoard(VOID)
{
	INT x,y,z;
	INT dx,dy;
	INT i = 0;

	PatBlt(hDCBack, 0, 0, dxpGridMax, dypGridMax, BLACKNESS);

	for (z = 0; z < cPlane; z++)
		{
		dy = z * (dypPlane + dyLevel);
		for (y = 0; y < cBlkRow; y++, dy += dyBlk)
			{
			dx = ((cBlkRow-1)-y)*dxSlant;
			for (x = 0; x < cBlkRow; x++, dx += (dxBlk-1))
				{
				rgXBlk[i] = dx;
				rgYBlk[i] = dy;
				i++;
				}
			}
		}

	/* Just plot squares back to front  *** CHANGE TO DRAW LINES */

	for (i = 0; i < cBlkMac; i++)
		BitBlt(hDCBack, rgXBlk[i], rgYBlk[i], dxBall, dyBall,
			hDCBall, 0, 0, SRCPAINT);
			
	BitBlt(hDCTemp, 0, 0, dxpGridMax, dypGridMax, hDCBack, 0, 0, SRCCOPY);
}


/****** D I S P L A Y  B A L L ******/

VOID DisplayBall(BLK blkFix, BALL ballFix)
{
	HDC  hDC;
	INT  dx,dy;
	INT  dyFix;
	BLK  blk,blkStart, blkEnd;
	BALL iBall;

#if DEBUG > 1
	CHAR sz[80];
	wsprintf(sz,"Disp blk=%d ball=%d\r\n",blkFix,ballFix);
	OutputDebugString(sz);
#endif

	
#ifdef DEBUG
	if (blkFix < 0)
		{
		Oops("DisplayBall: Invalid blk");
		return;
		}
	else if (ballFix >= iBallMax)
		{
		Oops("DisplayBall: Invalid iBall");
		return;
		}
#endif

	hDC = GetDC(hwndMain);

	blkEnd = cBlkPlane + (blkStart = cBlkPlane * (blkFix/cBlkPlane));

        dyFix = rgYBlk[blkStart];
        BitBlt(hDCTemp, 0, dyFix, dxpPlane, dypPlane,
		hDCBack, 0, dyFix, SRCCOPY);

	iBall = rgBlk[blkFix];
	rgBlk[blkFix] = ballFix;
	ballFix = iBall;

	for (blk = blkStart; blk < blkEnd; blk++)
		{
		if ((iBall = rgBlk[blk]) != iBallBlank)
			{
			BitBlt(hDCTemp, dx = rgXBlk[blk], dy = rgYBlk[blk], dxBall, dyBall,
				hDCBall, 0, rgBallOff[iBallMask], SRCAND);
			BitBlt(hDCTemp, dx, dy, dxBall, dyBall,
				hDCBall, 0, rgBallOff[iBall], SRCPAINT);
			}
		}

	rgBlk[blkFix] = ballFix;

	BitBlt(hDC, dxpGridOff, (dyFix + dypGridOff), dxpPlane, dypPlane,
		hDCTemp, 0, dyFix, SRCCOPY);

	ReleaseDC(hwndMain, hDC);
}


/****** D R A W  G R I D ******/

VOID DrawGrid(HDC hDC)
{
	BitBlt(hDC, dxpGridOff, dypGridOff, dxpGrid, dypGrid, hDCTemp, 0, 0, SRCCOPY);
}

VOID DisplayGrid(VOID)
{
	HDC hDC = GetDC(hwndMain);
	DrawGrid(hDC);
	ReleaseDC(hwndMain, hDC);
}


/****** R E  D O  D I S P L A Y ******/

VOID ReDoDisplay()
{
	REGISTER INT i;
	REGISTER INT iBall;

	BitBlt(hDCTemp, 0, 0, dxpGrid, dypGrid, hDCBack, 0, 0, SRCCOPY);

	/* Place balls back to front */

	for (i = 0; i < cBlkMac; i++)
		{
		if ((iBall = rgBlk[i]) != iBallBlank)
			{
			BitBlt(hDCTemp, rgXBlk[i], rgYBlk[i], dxBall, dyBall,
				hDCBall, 0, rgBallOff[iBallMask], SRCAND);
			BitBlt(hDCTemp, rgXBlk[i], rgYBlk[i], dxBall, dyBall,
				hDCBall, 0, rgBallOff[iBall], SRCPAINT);
			}
		}

}


/****** P L A C E  B A L L ******/

VOID PlaceBall(BLK blk, BALL iBall)
{
	HDC hDC = GetDC(hwndMain);

#ifdef DEBUG
	if (blk < 0 || blk >= cBlkMac)
		Oops("PlaceBlk: Blk out of range");
	else if (iBall < iBallBlank || iBall >= iBallMax)
		Oops("PlaceBall: Ball out of range");
#endif

	rgBlk[blk] = iBall;

	ReDoDisplay();

	DrawGrid(hDC);
	ReleaseDC(hwndMain, hDC);
}


VOID DrawRect(HDC hDC, INT x1, INT y1, INT x2, INT y2, HPEN hPen)
{
	SelectObject(hDC, hPen);
	(VOID)MMoveTo(hDC, x1, y1);
	LineTo(hDC, x1, y2);
	LineTo(hDC, x2, y2);
	LineTo(hDC, x2, y1);
	LineTo(hDC, x1, y1);
}


VOID DrawBorder(HDC hDC)
{
	REGISTER INT x;
	REGISTER INT y;

	x = dxpWindow-1;
	y = dypWindow-1;

	SetROP2(hDC, R2_COPYPEN);
	DrawRect(hDC, 0, 0, x, y, hPenGray);
	DrawRect(hDC, 1, 1, --x, --y, hPenLtGray);
	DrawRect(hDC, 2, 2, --x, --y, hPenLtGray);
	DrawRect(hDC, 3, 3, --x, --y, hPenGray);
}



/****** D R A W  S C R E E N ******/

VOID DrawScreen(HDC hDC)
{
	DrawBorder(hDC);
	DrawGrid(hDC);
}

VOID DisplayScreen(VOID)
{
	HDC hDC = GetDC(hwndMain);
	DrawScreen(hDC);
	ReleaseDC(hwndMain, hDC);
}


/****** D O  F L A S H ******/

VOID DoFlash(BOOL fOn)
{
	REGISTER INT i;
	HDC hDC = GetDC(hwndMain);

	for (i = 0; i < cBlkRow; i++)
		rgBlk[rgFlash[i]] = fOn ? iPlayer :iBallGrey;

	ReDoDisplay();
	DrawGrid(hDC);

	ReleaseDC(hwndMain, hDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\grafix.h ===
/************/
/* grafix.h */
/************/

/*** Bitmaps ***/

#define dxBlk 22
#define dyBlk 15

#define dxBall 37
#define dyBall 18

#define dxEdge 12
#define dyEdge 12

#define dypGridOff dyEdge

#define dyLevel    4 /* 10 */
#define dxSlant    dyBlk
#define dyBlkDiff  (dyBall-dyBlk)

#define dxGridOff  dxEdge
#define dyGridOff  dyEdge

#define dxpGridMax ((dxBall-1)<<2)
#define dypGridMax (((dyBall<<2) + dyLevel) << 2)

#define RGB_WHITE   0x00FFFFFF
#define RGB_LTGRAY  0x00C0C0C0
#define RGB_GRAY    0x00808080
#define RGB_BLACK   0x00000000



/*** Macros ***/

#ifdef DEBUG

//-protect-#define Oops(szMsg)
//	MessageBox(NULL, szMsg, "Oops", MB_OK | MB_ICONHAND)

#else
#define Oops(szMsg)
#endif



/*** Routines ***/

BOOL FInitLocal(VOID);
VOID CleanUp(VOID);

VOID DisplayBall(INT, INT);
VOID DrawScreen(HDC);
VOID DisplayScreen(VOID);
VOID DisplayBoard(VOID);
VOID DisplayGrid(VOID);

VOID DoFlash(BOOL);

VOID SetupBoard(VOID);

VOID PlaceBall(INT, INT);
VOID ReDoDisplay(VOID);
VOID GetTheBitmap(VOID);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\pref.h ===
/**********/
/* pref.h */
/**********/

/*** Game Types ***/

#define iGame3x3   0
#define iGame3x3x3 1
#define iGame4x4x4 2

#define skillBegin   0
#define skillInter  49
#define skillExpert 99

#define iStartRnd  0
#define iStartRed  iComputer
#define iStartBlue iHuman

#define intlMax   99


typedef struct
{
	INT 	xWindow;
	INT 	yWindow;
	INT	fSound;
	BOOL	fMenu;
	INT 	iGameType;
	BOOL	fComputer;
	BOOL  fColor;
	INT	skill;
	INT   iStart;
} PREF;


VOID ReadPreferences(VOID);
VOID WritePreferences(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\res.h ===
/* TIC Resources */

#define ID_BMP_BALL    100
#define ID_BAW_BALL    101

#define ID_MENU        101
#define ID_MENU_ACCEL  102

#define IDM_GAME       100
#define IDM_NEW        101
#define IDM_3x3        103
#define IDM_3x3x3      104
#define IDM_4x4x4      105
#define IDM_EXIT       107

#define IDM_OPTIONS    110
#define IDM_RND        111
#define IDM_RED        112
#define IDM_BLUE       113
#define IDM_SOUND      115
#define IDM_COLOR      116
#define IDM_BEGIN      117
#define IDM_INTER      118
#define IDM_EXPERT     119

#define IDM_HELP        190
#define IDM_INDEX       191
#define IDM_HOW2PLAY    192
#define IDM_COMMANDS    193
#define IDM_HELP_HELP   195
#define IDM_HELP_ABOUT  196



#define ID_TIME_FLASH  507


#define ID_ICON_MAIN   ID_ICON_TIC2

#define ID_ICON_TIC2   201
#define ID_ICON_TIC3   202
#define ID_ICON_TIC4   203

#define ID_ICON_DUNCE  210
#define ID_ICON_GENIUS 211


/* Preferences */

#define ID_DLG_PREF       500

#define ID_BTN_OK         101
#define ID_BTN_CANCEL     102
#define ID_BTN_HELP       103
#define ID_TXT_INTL       104
#define ID_TXT_PREF       105
#define ID_ICON_CURR      106
#define ID_GRP_GAME       107
#define ID_SRL_INTL       108
#define ID_ICON_INTLMAX   109
#define ID_ICON_INTLMIN   110
#define ID_CHK_COMP       111

#define ID_RAD_3X3        920
#define ID_RAD_3X3X3      921
#define ID_RAD_4X4X4      922

#define ID_GAMENAME       1
#define ID_ERR_TITLE      2
#define ID_ERR_TIMER      3
#define ID_ERR_UNKNOWN    4
#define ID_ERR_MEM        5
#define ID_MSG_VERSION    6
#define ID_MSG_CREDIT     7

#define ID_ERR_MAX      999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\pref.c ===
/**********/
/* pref.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "pref.h"
#include "sound.h"

BOOL    fUpdateIni  = fFalse;
CHAR    szIniFile[] = "entpack.ini";

extern CHAR szClass[];
#define lpAppName szClass


PREF Preferences;

#define iszPrefxWindow     0
#define iszPrefyWindow     1
#define iszPrefSound       2
#define iszPrefMenu        3
#define iszPrefGame        4
#define iszPrefComputer    5
#define iszPrefSkill       6
#define iszPrefStart       7
#define iszPrefColor       8

#define iszPrefMax 9

CHAR * rgszPref[iszPrefMax] =
{
"Xpos"    ,
"Ypos"    ,
"Sound"   ,
"Menu"    ,
"Game"    ,
"Computer",
"Skill"   ,
"Start"   ,
"Color"
};


extern INT dypCaption;
extern INT dypMenu;

extern INT dypGrid;
extern INT dxpGrid;
extern INT dxpWindow;
extern INT dypWindow;

extern BOOL fEGA;


/****** PREFERENCES ******/

INT ReadInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
	return max(valMin, min(valMax,
		(INT) GetPrivateProfileInt(lpAppName, rgszPref[iszPref], valDefault, (LPSTR) szIniFile) ) );
}

#define ReadBool(iszPref, valDefault) ReadInt(iszPref, valDefault, 0, 1)



VOID ReadPreferences(VOID)
{

	Preferences.xWindow    = ReadInt(iszPrefxWindow, 160, 0, 1024);
	Preferences.yWindow    = ReadInt(iszPrefyWindow,
				dypCaption+dypMenu + (fEGA ? 0 : 30), dypCaption+dypMenu, 1024);
	Preferences.fSound     = ReadInt(iszPrefSound, 0, 0, fsoundOn);
	Preferences.fMenu      = ReadInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	Preferences.fComputer  = ReadBool(iszPrefComputer, fTrue);
	Preferences.iGameType  = ReadInt(iszPrefGame, iGame4x4x4, iGame3x3, iGame4x4x4);
	Preferences.skill      = ReadInt(iszPrefSkill, skillExpert, skillBegin, skillExpert);
	Preferences.iStart     = ReadInt(iszPrefStart, iStartRnd, iStartRnd, iStartBlue);

	{
	HDC hDC = GetDC(GetDesktopWindow());
	Preferences.fColor  = ReadBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
	ReleaseDC(GetDesktopWindow(),hDC);
	}

	if (FSoundOn())
		Preferences.fSound = FInitTunes();
}
	

VOID WriteInt(INT iszPref, INT val)
{
	CHAR szVal[15];

	wsprintf(szVal, "%d", val);

#ifdef DEBUG2
	{
		CHAR sz[80];
		wsprintf(sz,"\r\n i=%d v=%d x=",iszPref, val);
		OutputDebugString(sz);
		OutputDebugString(szVal);
		OutputDebugString("\r\n rgszPref=");
		OutputDebugString(rgszPref[iszPref]);
	}
#endif

	WritePrivateProfileString(lpAppName, rgszPref[iszPref], szVal, (LPSTR) szIniFile);
}


VOID WritePreferences(VOID)
{
	WriteInt(iszPrefxWindow, Preferences.xWindow);
	WriteInt(iszPrefyWindow, Preferences.yWindow);
	WriteInt(iszPrefGame,    Preferences.iGameType);
	WriteInt(iszPrefComputer,    Preferences.fComputer);
	WriteInt(iszPrefSkill,   Preferences.skill);
	WriteInt(iszPrefStart,   Preferences.iStart);
	WriteInt(iszPrefColor,   Preferences.fColor);

	if (FSoundSwitchable())
		WriteInt(iszPrefSound,   Preferences.fSound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\menu.inc ===
/* TicTactics Menus */

ID_MENU MENU
BEGIN
  
 POPUP     "&Game"
 BEGIN	  
 MENUITEM  "New\tF2",              IDM_NEW
 MENUITEM  SEPARATOR
 MENUITEM  "3 x 3",                IDM_3x3
 MENUITEM  "3 x 3 x 3",            IDM_3x3x3
 MENUITEM  "4 x 4 x 4",            IDM_4x4x4
 MENUITEM  SEPARATOR
 MENUITEM  "E&xit",	           IDM_EXIT
 END	  
 	  
 POPUP     "&Options"
 BEGIN	  
 MENUITEM  "&Beginner",            IDM_BEGIN
 MENUITEM  "&Intermediate",        IDM_INTER
 MENUITEM  "&Expert",              IDM_EXPERT
 MENUITEM  SEPARATOR
 MENUITEM  "&Color",               IDM_COLOR
 MENUITEM  SEPARATOR
 MENUITEM  "Random player starts", IDM_RND
 MENUITEM  "Red always starts",    IDM_RED
 MENUITEM  "Blue always starts",   IDM_BLUE
 END	  


 POPUP     "&Help"
 BEGIN	  
 MENUITEM  "&Index\tF1",      IDM_INDEX
 MENUITEM  "&How to Play",    IDM_HOW2PLAY
 MENUITEM  "&Commands",       IDM_COMMANDS
 MENUITEM  "Using &Help",     IDM_HELP_HELP
 MENUITEM  SEPARATOR
 MENUITEM  "&About TicTactics...", IDM_HELP_ABOUT
 END
 
END


ID_MENU_ACCEL ACCELERATORS
BEGIN
VK_F1, IDM_INDEX, VIRTKEY
VK_F2, IDM_NEW,   VIRTKEY
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\rtns.h ===
/****************/
/* file: rtns.h */
/****************/

/* A ball is a ball, a blk is where you put a ball */

/*** Bitmaps ***/


/* Blocks */

#define iBallBlank    0
#define iBallBlue     1
#define iBallRed      2
#define iBallGrey     3
#define iBallMask     4

#define iBallMax 5


#define iComputer  1
#define iHuman     2

#define cDimMax    4	               	/* Maximum Number of dimensions */
#define cBlkMax   64	   /* total number of possible squares     */

#define iBlkNil   -1


typedef INT POS;
typedef INT BALL;
typedef INT BLK;


/*** Routines ***/

VOID SetupData(VOID);

VOID StartGame(VOID);
VOID StopGame(VOID);
VOID DoTimer(VOID);

VOID DoMove(BLK);
VOID UnDoMove(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\sound.c ===
/***********/
/* sound.c */
/***********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "sound.h"
#include "pref.h"
#include "rtns.h"

extern PREF Preferences;

extern INT blkCurr;


/****** F I N I T  T U N E S ******/

INT FInitTunes(VOID)
{
	// if (OpenSound() < 1)
		return fsoundOff;

	// SetVoiceAccent(1, 120, 128, S_LEGATO, 0);
	return fsoundOn;
}


/****** K I L L  T U N E ******/

VOID KillTune(VOID)
{
	// if (FSoundOn())
		// StopSound();
}


/****** E N D  T U N E S ******/

VOID EndTunes(VOID)
{
	if (FSoundOn())
		{
		KillTune();
		// CloseSound();
		}
}



/****** P L A Y  T U N E ******/

VOID PlayTune(INT tune)
{
	if (!FSoundOn())
		return;

	// StopSound();
	switch (tune)
		{
	case TUNE_DROP:
	case TUNE_MOVE:
		// if (blkCurr >= 0)
			// SetVoiceNote(1, 10+blkCurr, 16, 1);
		break;

	case TUNE_WINGAME:
		// SetVoiceNote(1, 24, 16, 1);
		// SetVoiceNote(1, 26, 16, 1);
		// SetVoiceNote(1, 28, 16, 1);
		// SetVoiceNote(1, 29, 16, 1);
		// SetVoiceNote(1, 31, 16, 1);
		// SetVoiceNote(1, 33, 16, 1);
		// SetVoiceNote(1, 35, 16, 1);
		// SetVoiceNote(1, 36, 16, 1);
		break;
		
	case TUNE_LOSEGAME:
		// SetVoiceNote(1, 36, 8, 1);
		// SetVoiceNote(1, 24, 8, 1);
		// SetVoiceNote(1, 36, 8, 1);
		// SetVoiceNote(1, 24, 8, 1);
		// SetVoiceNote(1, 36, 8, 1);
		// SetVoiceNote(1, 24, 8, 1);
		break;

#ifdef DEBUG
	default:
		Oops("Invalid Tune");
		break;
#endif
		}

	// StartSound();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\rtns.c ===
/************/
/* ROUTINES */
/************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "pref.h"
#include "sound.h"
#include "util.h"


/*** Global/Local Variables ***/

INT  iPlayer;

BOOL fFlash = fFalse;	/* Integerate these ! */
BOOL fFlashOnOff;

BOOL f4;		/* TRUE if need 4 in a row */

INT  cPlane;		/* Number of planes */
INT  cBlkRow;	/* Number of balls in a row */
INT  cBlkPlane;	/* Number of positions in a single plane */
INT  cBlkMac;	/* Total number of available positions */


/* Computer stuff */

INT  iBlkLose;	/* Place to put if about to lose */
INT  iMoveCurr;

BLK  rgBlk[cBlkMax];		/* The main grid data       */
BLK  rgFlash[cDimMax];		/* list of balls to flash   */
BLK  rgMove[cBlkMax];		/* list of moves (for UNDO) */
BLK  rgBest[cBlkMax];		/* count of times "best"    */

#include "tbls.inc"	


#define cChkMax k4x4x4
INT cChkMac;

INT rgChk[cChkMax][cDimMax];


/*** Global/External Variables ***/

extern STATUS status;
extern PREF   Preferences;

extern blkCurr;

BLK ComputerMove(VOID);



/****** F  C H E C K  W I N ******/

/* Return TRUE if anyone won */
/* rgFlash contains winning set */

BOOL FCheckWin(VOID)
{
	REGISTER INT x;
	REGISTER INT y;
	INT c;

	if (f4)
		{
		for (y = 0; y < cChkMac; y++)
			{
			if (c = rgBlk[rgChk[y][0]])
				if (c == rgBlk[rgChk[y][1]])
					if (c == rgBlk[rgChk[y][2]])
						if (c == rgBlk[rgChk[y][3]])
						{
						for (x = 0; x < cBlkRow; x++)
							rgFlash[x] = rgChk[y][x];

						return (fFlash = fTrue);
						}
			}
		}
	else
		{
		for (y = 0; y < cChkMac; y++)
			{
			if (c = rgBlk[rgChk[y][0]])
				if (c == rgBlk[rgChk[y][1]])
					if (c == rgBlk[rgChk[y][2]])
						{
						for (x = 0; x < cBlkRow; x++)
							rgFlash[x] = rgChk[y][x];

						return (fFlash = fTrue);
						}
			}
		}

	return fFalse;
}




/****** D O  M O V E ******/

VOID DoMove(BLK blk)
{
#ifdef DEBUG3
	CHAR sz[80];
LMove:
	wsprintf(sz,"Move=%d Player=%d\r\n",blk,iPlayer);
	OutputDebugString(sz);

	if (blk < 0 || blk >= cBlkMac)
		{
		Oops("Invalid blk");
		return;
		}
	else if (rgBlk[blk])
		{
		Oops("Invalid Move!");
		return;
		}
#else
LMove:
#endif

	rgMove[iMoveCurr++] = blk;	/* Remember move */
	PlaceBall(blk, iPlayer);

	if (FCheckWin())
		{
		ClrStatusPlay();
		fFlashOnOff = fTrue;
		fFlash = fTrue;
		PlayTune(iPlayer == iComputer ? TUNE_LOSEGAME : TUNE_WINGAME);
		}
	else if (iMoveCurr == cBlkMac)
		ClrStatusPlay();

	else 
		{
		blkCurr = blk;
		if ((iPlayer ^= 3) == iComputer)
			{
			blk = ComputerMove();
			goto LMove;
			}
		else
			PlayTune(TUNE_DROP);	/* Computer makes noise too */
		}
}


/****** U N  D O  M O V E ******/

VOID UnDoMove(VOID)
{
	if (iMoveCurr)
		{
		rgBlk[rgMove[--iMoveCurr]] = iBallBlank;	/* Undo Computer move */
		if (iMoveCurr)
			{
			rgBlk[rgMove[--iMoveCurr]] = iBallBlank;	/* Undo Human move */
			ReDoDisplay();
			DisplayGrid();
			}
		else
			{
			iPlayer = iComputer;
			DoMove(ComputerMove());
			}
		}
	else
		MessageBeep(0);		/* Should be a sound !!! */
}


/****** G E T  B E S T  B L K ******/

BLK GetBestBlk(VOID)
{
	INT  cMac;
	BLK  blkBest;
	BLK  iBlk;
	INT  cBlk;

/* Future: If f4 & we have a set of corners, try recursion */


	/* Find most promising position */

	cMac = 0;
	cBlk = 0;
	blkBest = 0;

	for (iBlk = 0; iBlk < cBlkMac; iBlk++)
		if (rgBest[iBlk] != 0)
			{
			if (rgBest[iBlk] > cMac)
				{
				cBlk = 1;
				blkBest = iBlk;
				cMac = rgBest[iBlk];
				}
			else if (rgBest[iBlk] == cMac)
				{
				if (Rnd(++cBlk) == 0)
					blkBest = iBlk;
				}
			}
	
	if (blkBest != 0)
		return blkBest;


	switch (Preferences.iGameType)
		{
	case iGame3x3:
		if (rgBlk[4] == iBallBlank)
			return 4;
		break;

	case iGame3x3x3:
		if (rgBlk[13] == iBallBlank)
			return 13;
		break;

	default:
		break;
		}

	/* Find an empty corner */

	iBlk = Rnd(8);
	for (cMac = 0; cMac++ < 8;)
		{
		if (rgBlk[blkBest = rgCorner[Preferences.iGameType][iBlk]] == iBallBlank)
			return blkBest;
		iBlk = (iBlk+1) % 8;
		}

	return iBlkNil;
}


/****** B L K  C H K  3 ******/

BLK BlkChk3(INT b1, INT b2, INT b3)
{
#ifdef DEBUG
	CHAR sz[80];
	wsprintf(sz,"BlkChk3=%d %d %d  v=%d\r\n",b1,b2,b3,rgBlk[b1]+rgBlk[b2]*3+rgBlk[b3]*9);
	OutputDebugString(sz);
#endif	

	switch (rgBlk[b1] + rgBlk[b2]*3 + rgBlk[b3]*9)
		{
	case 4:
		return b3;
	case 10:
		return b2;
	case 12:
		return b1;

	case 8:
		iBlkLose = b3;
		break;
	case 20:
		iBlkLose = b2;
		break;
	case 24:
		iBlkLose = b1;
		break;

	case 1:
		rgBest[b3]++;
		break;
	case 9:
		rgBest[b1]++;
		break;
		}

	return iBlkNil;
}


/****** B L K  C H K  4 ******/

BLK BlkChk4(INT b1, INT b2, INT b3, INT b4)
{
	switch (rgBlk[b1] + rgBlk[b2]*3 + rgBlk[b3]*9 + rgBlk[b4]*27)
		{
	case 13:
		return b4;
	case 31:
		return b3;
	case 37:
		return b2;
	case 39:
		return b1;

	case 26:
		iBlkLose = b4;
		break;
	case 62:
		iBlkLose = b3;
		break;
	case 74:
		iBlkLose = b2;
		break;
	case 78:
		iBlkLose = b1;
		break;

	case 1:
		rgBest[b4]++;
		break;
	case 27:
		rgBest[b1]++;
		break;

	case 28:
		rgBest[b2] += 4;
		rgBest[b3] += 4;
		break;
		}

	return iBlkNil;
}


/****** S K I L L ******/

BOOL Skill(INT intel, INT chance)
{
	if (Preferences.skill > intel)
		return fTrue;
		
	return  (Rnd(100) < chance);
}


/****** C O M P U T E R  M O V E ******/

BLK ComputerMove(VOID)
{
	REGISTER INT iBlk;
	REGISTER INT y;

	iBlkLose = iBlkNil;

	for (iBlk = 0; iBlk < cBlkMac; iBlk++)	/** USE A BLT !!! **/
		rgBest[iBlk] = 0;

	if (Skill(10, 10))
		{
		if (Skill(10, 50))
		/* Search for winning location */
		{
		if (f4)
			{
			for (y = 0; y < cChkMac; y++)
				if ((iBlk = BlkChk4(rgChk[y][0], rgChk[y][1], rgChk[y][2], rgChk[y][3])) != iBlkNil)
					return iBlk;
			}
		else
			{
			for (y = 0; y < cChkMac; y++)
				if ((iBlk = BlkChk3(rgChk[y][0], rgChk[y][1], rgChk[y][2])) != iBlkNil)
					return iBlk;
			}
		}

		/* Is there a losing location ? */

		if ((iBlkLose != iBlkNil) && Skill(50, 50))
			return iBlkLose;


		/* Is there a best spot ? */

		if (Skill(70, 80) && ((iBlk = GetBestBlk()) != iBlkNil))
			return iBlk;
			
		}

	/* Random search for a valid spot */

	while (rgBlk[iBlk = Rnd(cBlkMac)] != iBallBlank)
			;

	return iBlk;

}




/****** D O  T I M E R ******/

VOID DoTimer(VOID)
{
	if (fFlash)
		DoFlash(fFlashOnOff ^= 1);
}



/****** S E T U P  D A T A */

VOID SetupData(VOID)
{
#ifdef DEBUG2
	CHAR sz[80];
#endif

	INT c,c2,c3;
	POS pos;
	INT iTbl = 0;
	INT cTblMac = 0;

	switch (Preferences.iGameType)
		{
	case iGame3x3:
		f4 = fFalse;
		cBlkRow = 3;
		cPlane  = 1;
		iTbl    = i3x3;
		cTblMac = c3x3;
		break;
		
	case iGame3x3x3:
		f4 = fFalse;
		cBlkRow = 3;
		cPlane  = 3;
		iTbl    = i3x3x3;
		cTblMac = c3x3x3;
		break;
		
	case iGame4x4x4:
		f4 = fTrue;
		cBlkRow = 4;
		cPlane  = 4;
		iTbl    = i4x4x4;
		cTblMac = c4x4x4;
		break;
		}
		
	cBlkPlane = cBlkRow   * cBlkRow;
	cBlkMac   = cBlkPlane * cPlane;

#ifdef DEBUG3
wsprintf(sz,"Game=%d cBlkRow=%d cPlane=%d\r\n",Preferences.iGameType, cBlkRow, cPlane);
OutputDebugString(sz);
wsprintf(sz,"cBlkPlane=%d cBlkMac=%d cTblMac=%d\r\n",cBlkPlane, cBlkMac, cTblMac);
OutputDebugString(sz);
#endif

	cChkMac = 0;

	c3 = 0;
	while (c3++ < cTblMac)
		{
		pos = rgtbl[iTbl][iposStart];
		c2 = 0;
		while (c2 < cBlkRow)
			{
			for (c=0; c < cBlkRow; c++)
				{
				rgChk[cChkMac][c] = pos;
#ifdef DEBUG2
wsprintf(sz," %d",pos);
OutputDebugString(sz);
#endif
				pos = (pos + rgtbl[iTbl][iposOff]) % cBlkMac;
				}
			cChkMac++;
			c2++;
			if (rgtbl[iTbl][iposLine] == (BYTE) -1)
				c2 = cBlkRow;
			else
				pos = (pos + rgtbl[iTbl][iposLine] - rgtbl[iTbl][iposOff]) % cBlkMac;
#ifdef DEBUG2
OutputDebugString("\r\n");
#endif
			}
		iTbl++;
#ifdef DEBUG2
OutputDebugString("------\r\n");
#endif
		}


#ifdef DEBUG2
wsprintf(sz,"cChkMac=%d",cChkMac);
OutputDebugString(sz);
#endif
}


/****** S T A R T  G A M E *******/

VOID StartGame(VOID)
{
	REGISTER i;

	fFlash = fFalse;

	ClrStatusIcon();
	SetStatusPlay();
	iMoveCurr = 0;

#ifdef DEBUG3
	OutputDebugString("*** New Game ***\r\n");
#endif

	for (i = 0; i < cBlkMac; i++)		/* USE A BLT ! */
		rgBlk[i] = iBallBlank;

	ReDoDisplay();
	DisplayGrid();

	if (Preferences.iStart == iStartRnd)
		iPlayer = 1 + Rnd(2);
	else
		iPlayer = Preferences.iStart;

	if (iPlayer == iComputer)
		{
		iPlayer = iComputer;
		DoMove(ComputerMove());
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\tbls.inc ===
/* Tables to generate Tables */

/* Each row of rgChk contains the positions for a line (tictactoe)

   Each row of rgtbl contains a set of data to generate a sequence of lines.
   Normally a set of data contains cBlkRow lines, but -1 indicates only 1 line.
*/

#define iposStart  0	/* Starting Position */
#define iposOff    1	/* Offset between positions in a line */
#define iposLine   2	/* Offset to first position in next line */

#define i3x3       0
#define i3x3x3     4
#define i4x4x4    23

#define c3x3       4
#define c3x3x3    19
#define c4x4x4    22

#define k3x3       8
#define k3x3x3    49
#define k4x4x4    76


BYTE rgtbl[c3x3 + c3x3x3 + c4x4x4][3] = {

/*** 3 x 3 = 9 ***/

{0, 1,  1},
{0, 3,  4},
{0, 4, -1},
{2, 2, -1},


/*** 3 x 3 x 3 = 27 ***/

{ 0,  1,  1},	/* X Plane */
{ 9,  1,  1},
{18,  1,  1},

{ 0,  3, 22},	/* Y Plane */
{ 9,  3, 22},
{18,  3, 22},

{ 0,  9, 12},	/* Z Plane */
{ 1,  9, 12},
{ 2,  9, 12},

{ 0,  4,  1},	/* X Diagonal */
{ 2,  2,  5},

{ 0, 10, 10},	/* Y Diagonal */
{ 2,  8, 14},

{ 0, 12,  4},	/* Z Diagonal */
{ 6,  6, 16},

{ 0, 13, -1},	/* Through Center */
{ 2, 11, -1},
{ 6,  7, -1},
{ 8,  5, -1},



/*** 4 x 4 x 4 = 64 ***/

{ 0,  1,  1},	/* X Plane */
{16,  1,  1},
{32,  1,  1},
{48,  1,  1},

{ 0,  4, 53},	/* Y Plane */
{16,  4, 53},
{32,  4, 53},
{48,  4, 53},

{ 0, 16, 20},	/* Z Plane */
{ 1, 16, 20},
{ 2, 16, 20},
{ 3, 16, 20},

{ 0, 17, 17},	/* X Diagonal */
{ 3, 15, 23},

{ 0, 20,  5},	/* Y Diagonal */
{12, 12, 29},

{ 0,  5,  1},	/* Z Diagonal */
{ 3,  3,  7},

{ 0, 21, -1},	/* Through center */
{ 3, 19, -1},
{12, 13, -1},
{15, 11, -1},
};



POS rgCorner[3][8] = {
{0, 2,  6,  8,  0,  2,  6,  8},
{0, 2,  6,  8, 18, 20, 24, 26},
{0, 3, 12, 15, 48, 51, 60, 63}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\sound.h ===
/*****************/
/* file: sound.h */
/*****************/

#define TUNE_DROP      1
#define TUNE_MOVE      2
#define TUNE_WINGAME   3
#define TUNE_LOSEGAME  4

#define fsoundOn  3
#define fsoundOff 2

#define FSoundSwitchable()  (Preferences.fSound > 1)
#define FSoundOn()          (Preferences.fSound == fsoundOn)

INT  FInitTunes(VOID);
VOID PlayTune(INT);
VOID KillTune(VOID);
VOID EndTunes(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\strings.inc ===
/* strings.inc */

STRINGTABLE
  BEGIN
    ID_GAMENAME     "TicTactics"
    ID_ERR_TITLE    "TicTactics Error"
    ID_ERR_TIMER,   "Unable to allocate a timer.  Please exit some of your applications and try again."
    ID_ERR_UNKNOWN, "Error: %d"
    ID_ERR_MEM,     "Out of Memory"
    ID_MSG_VERSION, "TicTactics (1.0a)"
    ID_MSG_CREDIT,  "by Robert Donner"
  END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\context.h ===
#define HLP_INDEX     0x0000
#define HLP_HOWTOPLAY 0x0001
#define HLP_COMMANDS  0x0002
#define HLP_KEYBOARD  0x0003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\util.h ===
/**********/
/* util.h */
/**********/

VOID InitConst(VOID);
VOID LoadSz(INT, CHAR *);
VOID ReportErr(INT);
INT  Rnd(INT);

VOID DoHelp(UINT, ULONG_PTR);
VOID DoAbout(VOID);

VOID CheckEm(INT, BOOL);
VOID SetMenuBar(INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\tictac.c ===
/****************************************************************************

    PROGRAM: 3-D TicTacToe   (a.k.a. Qubic, TicTactics)

****************************************************************************/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "rtns.h"
#include "grafix.h"
#include "util.h"
#include "res.h"
#include "pref.h"
#include "sound.h"
#include "string.h"
#include "context.h"
#include "dos.h"


HANDLE hInst;
HWND   hwndMain;
HMENU  hMenu;

STATUS status = fstatusIcon;
BOOL   fEGA;

extern fUpdateIni;

BOOL   fButton1Down = fFalse;

extern BLK rgBlk[cBlkMax];

INT dxpWindow;
INT dypWindow;
INT dypCaption;
INT dypMenu;
INT dypAdjust;
INT dypBorder;
INT dxpBorder;
INT dxpGridOff;

INT dyBlkPlane;
INT dypPlane;
INT dxpPlane;

INT dxpGrid;
INT dypGrid;


BLK  blkCurr;

CHAR szClass[cchNameMax];
#define szWindowTitle szClass

extern INT cBlkRow;
extern INT cBlkPlane;
extern INT cBlkMac;
extern INT cPlane;

extern BOOL f4;

extern PREF Preferences;
extern BOOL fUpdateIni;



/****** W I N  M A I N ******/

MMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
/* { */
	MSG msg;
	HANDLE hAccel;

	hInst = hInstance;

	InitConst();

	if (hPrevInstance)
		{
		HWND hwnd = FindWindow(szClass, NULL);
		hwnd = GetLastActivePopup(hwnd);
		BringWindowToTop(hwnd);
		if (IsIconic(hwnd))
			ShowWindow(hwnd, SW_RESTORE);
		return fFalse;
		}


#ifdef NOSERVER		/* Not in final version */
	{
	CHAR  szFile[256];

	GetModuleFileName(hInst, szFile, 250);
	if (szFile[0] > 'C')
		{
		szFile[0] = 'X';
		if (!strcmp(szFile, "X:\\WINGAMES\\TICTACTO\\TIC.EXE"))
			{
			MessageBox(GetFocus(),
				"Please copy tic.exe and aboutwep.dll to your machine and run it from there.",
				"NO NO NO NO NO",
				MB_OK);
			return fFalse;
			}
		}
	}
#endif

#ifdef EXPIRE			/*** Not in final release ***/
	{
	struct dosdate_t ddt;

	_dos_getdate(&ddt);

	if ((ddt.month + ddt.year*12) > (10 + 1990*12))
		{
		MessageBox(GetFocus(),
			"This game has expired. Please obtain an official copy from the Windows Entertainment Package.",
			"SORRY",
			MB_OK);
		return fFalse;
		}
	}
#endif

	{
	WNDCLASS  wc;

	wc.style = 0;
	wc.lpfnWndProc   = MainWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInst;
	wc.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_TIC2));
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(BLACK_BRUSH);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = szClass;

	if (!RegisterClass(&wc))
		return fFalse;
	}

	hMenu = LoadMenu(hInst, MAKEINTRESOURCE(ID_MENU));
	hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_MENU_ACCEL));

	ReadPreferences();

	AdjustWindow(fCalc);
	
	hwndMain = CreateWindow(szClass, szWindowTitle,
		WS_OVERLAPPED | WS_MINIMIZE | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU,
		Preferences.xWindow-dxpBorder, Preferences.yWindow-dypAdjust,
		dxpWindow+dxpBorder, dypWindow+dypAdjust,
		NULL, NULL, hInst, NULL);

	if (!hwndMain)
		{
		ReportErr(1000);
		return (fFalse);
		}
		
	if (SetTimer(hwndMain, ID_TIME_FLASH, 500 , NULL) == 0)
		{
		ReportErr(ID_ERR_TIMER);
		return fFalse;
		}

	if (!FInitLocal())
		{
		ReportErr(ID_ERR_MEM);
		return fFalse;
		}

	SetMenuBar(Preferences.fMenu);

	ShowWindow(hwndMain, SW_SHOWNORMAL);
	UpdateWindow(hwndMain);

	StartGame();

	while (GetMessage(&msg, NULL, 0, 0))
		{
		if (!TranslateAccelerator(hwndMain, hAccel, &msg))
			{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			}
		}

	CleanUp();

	if (fUpdateIni)
		WritePreferences();

	return (INT)(msg.wParam);
}


/****** B L K  F R O M  X Y ******/

/* Rewrite !  - just one return */

BLK BlkFromXY(INT x, INT y)
{
	BLK blk = 0;

	if (((x-=dxpGridOff) >= 0) &&
		  (x < dxpGrid) &&
		  ((y-=(dypGridOff+dyBlkDiff-2)) >= 0) &&
		  (y < dypGrid) )
		{
		while (y >= dyBlkPlane)
			{
			if ((y -= (dyLevel+dypPlane)) < 0)
				return iBlkNil;	/* No allow hits between levels */
			blk++;
			}

		x -= (dyBlkPlane-y);
		if ((x >= 0) && (x < (cBlkRow*(dxBlk-1))) )
			return (blk*cBlkPlane + cBlkRow*(y/dyBlk) + (x/(dxBlk-1)) );
		}

	return iBlkNil;
}


/****** F  V A L I D  M O V E ******/

BOOL FValidMove(BLK blk)
{
	if (blk != iBlkNil)
		if (rgBlk[blk] == iBallBlank)
			return fTrue;
	return fFalse;
}


/****** F I X  M E N U S ******/

VOID FixMenus(VOID)
{
	CheckEm(IDM_3x3,   Preferences.iGameType == iGame3x3);
	CheckEm(IDM_3x3x3, Preferences.iGameType == iGame3x3x3);
	CheckEm(IDM_4x4x4, Preferences.iGameType == iGame4x4x4);
	
#ifdef NOISEY
	CheckEm(IDM_SOUND,  Preferences.fSound);
#endif
	CheckEm(IDM_COLOR,  Preferences.fColor);
	
	CheckEm(IDM_RND,  Preferences.iStart == iStartRnd);
	CheckEm(IDM_RED,  Preferences.iStart == iStartRed);
	CheckEm(IDM_BLUE, Preferences.iStart == iStartBlue);
	
	CheckEm(IDM_BEGIN,  Preferences.skill == skillBegin);
	CheckEm(IDM_INTER,  Preferences.skill == skillInter);
	CheckEm(IDM_EXPERT, Preferences.skill == skillExpert);
}





/****** M A I N  W N D  P R O C ******/

LRESULT  APIENTRY MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
		{

	case WM_SYSCOMMAND:
		switch (wParam & 0xFFF0)
			{
		case SC_MINIMIZE:
			SetStatusPause();
			SetStatusIcon();
			break;
			
		case SC_RESTORE:
			ClrStatusPause();
			ClrStatusIcon();
			break;

		default:
			break;
			}
			
		break;



	case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam)) {

/** GAME **/

		case IDM_NEW:
			StartGame();
			break;

		case IDM_3x3:
		case IDM_3x3x3:
		case IDM_4x4x4:
			Preferences.iGameType = GET_WM_COMMAND_ID(wParam, lParam) - IDM_3x3;
		
			AdjustWindow(fCalc | fResize);
			StartGame();
			goto LUpdateMenu;

		case IDM_EXIT:
			ShowWindow(hwndMain, SW_HIDE);
#ifdef ORGCODE
			goto LExit;
#else
            SendMessage(hwndMain, WM_SYSCOMMAND, SC_CLOSE, 0);
            return(0);
#endif

/** SKILL **/

		case IDM_BEGIN:
			Preferences.skill = skillBegin;
			goto LUpdateMenu;
		case IDM_INTER:
			Preferences.skill = skillInter;
			goto LUpdateMenu;
		case IDM_EXPERT:
			Preferences.skill = skillExpert;
			goto LUpdateMenu;
	
/** OPTIONS **/
#ifdef NOISEY
		case IDM_SOUND:
			if (Preferences.fSound)
				{
				EndTunes();
				Preferences.fSound = fFalse;
				}
			else
				{
				Preferences.fSound = FInitTunes();
				}
			goto LUpdateMenu;
#endif
			
		case IDM_COLOR:
			Preferences.fColor = !Preferences.fColor;
			GetTheBitmap();
			ReDoDisplay();
			DisplayScreen();
			goto LUpdateMenu;

		case IDM_RND:
		case IDM_RED:
		case IDM_BLUE:
			Preferences.iStart = GET_WM_COMMAND_ID(wParam, lParam) - IDM_RND;
			StartGame();
/* IE		goto LUpdateMenu; */

LUpdateMenu:
			fUpdateIni = fTrue;
			FixMenus();
			break;


/** HELP **/
		case IDM_INDEX:
			DoHelp(HELP_INDEX, 0L);
			break;

		case IDM_HOW2PLAY:
			DoHelp(HELP_CONTEXT, HLP_HOWTOPLAY);
			break;

		case IDM_COMMANDS:
			DoHelp(HELP_CONTEXT, HLP_COMMANDS);
			break;

		case IDM_HELP_HELP:
			DoHelp(HELP_HELPONHELP, 0L);
			break;

	
		case IDM_HELP_ABOUT:
			DoAbout();
			return 0;

		default:
			break;
			}	

	case WM_KEYDOWN:
		switch (wParam)
			{
		case VK_ESCAPE:
			PostMessage(hwndMain, WM_SYSCOMMAND, SC_MINIMIZE, 0L);
			break;

#if 0
		case VK_F1:
			DoHelp(HELP_INDEX, 0L);
			break;

		case VK_F2:
			StartGame();
			break;

#endif
		case VK_F4:
			if (FSoundSwitchable())
				if (FSoundOn())
					{
					EndTunes();
					Preferences.fSound = fsoundOff;
					}
				else
					Preferences.fSound = FInitTunes();
			break;

		case VK_F5:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOff);
			break;

		case VK_F6:
			if (FMenuSwitchable())
				SetMenuBar(fmenuOn);
			break;

		default:
			break;
			}	

		break;


//	case WM_QUERYENDSESSION:
	case WM_DESTROY:
//LExit:	
		KillTimer(hwndMain,ID_TIME_FLASH);
      DoHelp(HELP_QUIT, 0L);
		PostQuitMessage(0);
		break;

	case WM_CHAR:
		break;

	case WM_LBUTTONDOWN:
		if (!FPlay())
			{
			return 0;
			}

		fButton1Down = fTrue;
		blkCurr = iBlkNil;
		SetCapture(hwndMain);

	case WM_MOUSEMOVE:
		if (fButton1Down)
			{
			BLK blk = BlkFromXY(LOWORD(lParam), HIWORD(lParam));
			if ((blk != blkCurr) && FValidMove(blk))
				{
				if (FValidMove(blkCurr))
					DisplayBall(blkCurr, iBallBlank);
				blkCurr = blk;
				PlayTune(TUNE_MOVE);
				DisplayBall(blk, iBallGrey);
				}
			}
		break;

	case WM_LBUTTONUP:
		if (fButton1Down)
			{
			fButton1Down = fFalse;
			ReleaseCapture();
			if (FValidMove(blkCurr))
				DoMove(blkCurr);
			}
		break;

	case WM_RBUTTONDOWN:
		if (FPlay())
			UnDoMove();
		else
			StartGame();
		break;

	case WM_TIMER:
		DoTimer();
		return 0;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hwnd,&ps);

		DrawScreen(hDC);

		EndPaint(hwnd, &ps);
		}
		return 0;
		
	case WM_MOVE:
		if (!FIcon())
			{
			Preferences.xWindow = 1+LOWORD(lParam);
			Preferences.yWindow = 1+HIWORD(lParam);
			}	
		break;

	default:
		break;

    }

	return (DefWindowProc(hwnd, message, wParam, lParam));
}


/****** A D J U S T  W I N D O W ******/

VOID AdjustWindow(INT fAdjust)
{
	SetupData();
	
	dypAdjust = dypCaption;

	if (FMenuOn())
		dypAdjust += dypMenu;

	if (GetSystemMetrics(SM_CYSCREEN) >= 480)	/* Is display 8514 ? */
		{
#define stupid8514 40

		dxpWindow = 180 + stupid8514;
		if (f4)
			dxpGridOff = 16 + stupid8514/2;
		else
			dxpGridOff = 34 + stupid8514/2;
		}
	else
		{
		dxpWindow = 180;			/* Aren't constants fun ? */
		if (f4)
			dxpGridOff = 16;
		else
			dxpGridOff = 34;
		}

	dyBlkPlane = dyBlk * cBlkRow;
	dxpGrid    = dxpPlane = (dxBall-1)*cBlkRow;
	dypPlane   = dyBlkPlane + dyLevel;
	dypGrid    = (((dyBlk * cBlkRow) + dyLevel+dyBlkDiff) * cPlane);
	
	dypWindow = dypGridOff + dypGrid + dyEdge;

	if (fAdjust & fResize)
		{
		SetupBoard();

		InvalidateRect(hwndMain, NULL, fTrue);
		
		MoveWindow(hwndMain, Preferences.xWindow - dxpBorder,
			Preferences.yWindow - dypAdjust,
			dxpWindow+dxpBorder, dypWindow + dypAdjust, fTrue);
		}
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\tictac\util.c ===
/**********/
/* util.c */
/**********/

#define  _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "pref.h"
#include "util.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "dos.h"

extern INT dypBorder; 
extern INT dxpBorder;
extern INT dypCaption;
extern INT dypMenu;

extern CHAR szClass[cchNameMax];

extern HANDLE hInst;
extern HWND   hwndMain;
extern HMENU  hMenu;

extern BOOL fEGA;
extern PREF Preferences;



VOID  APIENTRY AboutWEP(HWND hwnd, HICON hicon, LPSTR lpTitle, LPSTR lpCredit);


/****** R N D ******/

/* Return a random number between 0 and rndMax */

INT Rnd(INT rndMax)
{
	return (rand() % rndMax);
}



/****** R E P O R T  E R R ******/

/* Report and error and exit */

VOID ReportErr(INT idErr)
{
	CHAR szMsg[cchMsgMax];
	CHAR szMsgTitle[cchMsgMax];

	if (idErr < ID_ERR_MAX)
		LoadString(hInst, (WORD)idErr, szMsg, cchMsgMax);
	else
		{
		LoadString(hInst, ID_ERR_UNKNOWN, szMsgTitle, cchMsgMax);
		wsprintf(szMsg, szMsgTitle, idErr);
		}

	LoadString(hInst, ID_ERR_TITLE, szMsgTitle, cchMsgMax);

	MessageBox(NULL, szMsg, szMsgTitle, MB_OK | MB_ICONHAND);
}


/****** L O A D  S Z ******/

VOID LoadSz(INT id, CHAR * sz)
{
	if (LoadString(hInst, (WORD)id, (LPSTR) sz, cchMsgMax) == 0)
		ReportErr(1001);
}



/****** I N I T  C O N S T ******/

VOID InitConst(VOID)
{
	srand(LOWORD(GetCurrentTime()));

	LoadSz(ID_GAMENAME, szClass);
	
	fEGA = GetSystemMetrics(SM_CYSCREEN) < 351;

	dypCaption = GetSystemMetrics(SM_CYCAPTION) + 1;
	dypMenu    = GetSystemMetrics(SM_CYMENU)    + 1;
	dypBorder  = GetSystemMetrics(SM_CYBORDER)  + 1;
	dxpBorder  = GetSystemMetrics(SM_CXBORDER)  + 1;
}



/* * * * * *  M E N U S  * * * * * */

/****** C H E C K  E M ******/

VOID CheckEm(INT idm, BOOL fCheck)
{
	/*JAP fix 7/25/91)*/
	CheckMenuItem(hMenu, (WORD)idm, (DWORD) (fCheck ? MF_CHECKED : MF_UNCHECKED));
}

/****** S E T  M E N U  B A R ******/

VOID SetMenuBar(INT fActive)
{
	Preferences.fMenu = fActive;
	FixMenus();
	SetMenu(hwndMain, FMenuOn() ? hMenu : NULL);
 	AdjustWindow(fResize);
}


/****** D O  A B O U T ******/

VOID DoAbout(VOID)
{
	CHAR szVersion[cchMsgMax];
	CHAR szCredit[cchMsgMax];

	LoadSz(ID_MSG_VERSION, szVersion);
	LoadSz(ID_MSG_CREDIT,  szCredit);

	AboutWEP(hwndMain, LoadIcon(hInst, MAKEINTRESOURCE(ID_ICON_MAIN)),
	  szVersion, szCredit);
}


/****** D O  H E L P ******/

VOID DoHelp(UINT wCommand, ULONG_PTR lParam)
{
   CHAR szHelpFile[cchMaxPathname];
	CHAR * pch;

   pch = szHelpFile + GetModuleFileName(hInst, szHelpFile, cchMaxPathname);
	if ( ((pch-szHelpFile) > 4) && (*(pch-4) == '.') )
		pch -= 4;
	lstrcpy((LPSTR) pch, (LPSTR) ".HLP");

	WinHelp(hwndMain, szHelpFile, wCommand, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\main.h ===
/* MINE HEADER FILE */

#ifdef DEBUG
#define CHEAT
#endif

#ifdef BETA_VERSION
#define NOSERVER
#define EXPIRE
#endif

#define FAST

/*** Standard Stuff ***/

#define REGISTER register

#define fTrue	TRUE
#define fFalse	FALSE

#define hNil	NULL

#define cchMsgMax  128
#define cchMaxPathname 250


#define ID_TIMER 1


#define fmenuAlwaysOn 0x00
#define fmenuOff      0x01
#define fmenuOn       0x02

#define FMenuSwitchable()   (Preferences.fMenu != fmenuAlwaysOn)
#define FMenuOn()          ((Preferences.fMenu &  0x01) == 0)

#define fCalc    0x01
#define fResize  0x02
#define fDisplay 0x04


#define xBoxFromXpos(x) ( ((x)-(dxGridOff-dxBlk)) >> 4)
#define yBoxFromYpos(y) ( ((y)-(dyGridOff-dyBlk)) >> 4)

// This is the place where the winmine info gets stored in registry.
#define SZWINMINEREG   TEXT("Software\\Microsoft\\winmine")


/* if we have too few boxes, the title gets clipped */
#define MINWIDTH 9  
#define DEFWIDTH 9
#define MINHEIGHT 9
#define DEFHEIGHT 9


VOID AdjustWindow(INT);
VOID FixMenus(VOID);
VOID DoEnterName(VOID);
VOID DoDisplayBest(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\menu.inc ===
/* WinMine Menus */

ID_MENU MENU
BEGIN

 POPUP     "&Game"
 BEGIN	
 MENUITEM  "&New\tF2",        IDM_NEW
 MENUITEM  SEPARATOR
 MENUITEM  "&Beginner",       IDM_BEGIN
 MENUITEM  "&Intermediate",   IDM_INTER
 MENUITEM  "&Expert",         IDM_EXPERT
 MENUITEM  "&Custom..."       IDM_CUSTOM
 MENUITEM  SEPARATOR
 MENUITEM  "&Marks (?)",      IDM_MARK
 MENUITEM  "Co&lor",          IDM_COLOR
 MENUITEM  "&Sound",          IDM_SOUND
 MENUITEM  SEPARATOR
 MENUITEM  "Best &Times..."   IDM_BEST
 MENUITEM  SEPARATOR
 MENUITEM  "E&xit",           IDM_EXIT
 END	
 	
 POPUP     "&Help"
 BEGIN	
 MENUITEM  "&Contents\tF1",             IDM_HELP
 MENUITEM  "&Search for Help on..."     IDM_HOW2PLAY
 MENUITEM  "Using &Help",               IDM_HELP_HELP
 MENUITEM  SEPARATOR
 MENUITEM  "&About Minesweeper...",     IDM_HELP_ABOUT
 END

END


ID_MENU_ACCEL ACCELERATORS
BEGIN
VK_F1, IDM_HELP,  VIRTKEY
VK_F2, IDM_NEW,   VIRTKEY
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\grafix.c ===
/*************/
/* grafwin.c */
/*************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "grafix.h"
#include "rtns.h"
#include "sound.h"
#include "pref.h"


INT rgDibOff[iBlkMax];
INT rgDibLedOff[iLedMax];
INT rgDibButton[iButtonMax];

LPSTR  lpDibBlks;
LPSTR  lpDibLed;
LPSTR  lpDibButton;

HANDLE hResBlks;
HANDLE hResLed;
HANDLE hResButton;

HPEN hGrayPen = NULL;

//
//   MEM: make an array of memory bitmaps for storing DIBs
//

HDC          MemBlkDc[iBlkMax];
HBITMAP      MemBlkBitmap[iBlkMax];

//
//   end MEM:
//

extern INT dypCaption;
extern INT dypMenu;
extern INT dypBorder;
extern INT dxpBorder;


/*** External Data ***/

extern HWND   hwndMain;
extern HANDLE hInst;

extern PREF   Preferences;
extern CHAR   rgBlk[cBlkMax];

extern INT dxWindow;
extern INT dyWindow;
extern INT fStatus;

extern INT cSec;
extern INT cBombLeft;
extern INT cBoxVisit;
extern INT xBoxMac;
extern INT yBoxMac;

extern INT iButtonCur;



/****** F I N I T  L O C A L ******/

BOOL FInitLocal(VOID)
{
        if (!FLoadBitmaps())
                return fFalse;

        ClearField();

        return fTrue;
}



HANDLE HFindBitmap(INT id)
{
        return FindResource(hInst, MAKEINTRESOURCE(id+(!Preferences.fColor)), RT_BITMAP);
}

INT CbBitmap(INT x, INT y)
{
        x *= (Preferences.fColor ? 4 : 1);              /* Convert pixels to bits */
        return (y * ( ((x+31) >> 5) << 2));             /* Bytes on 32 byte boundary */
}


/****** F L O A D  B I T M A P S ******/

BOOL FLoadBitmaps(VOID)
{
        HANDLE hResInfo;
        REGISTER INT i;
        INT cbDibHeader;
        INT cb;

        HDC hDC;

        // initialize all the bitmaps to NULL.
        hResBlks = hResLed = hResButton = NULL;

        hResInfo   = HFindBitmap(ID_BMP_BLOCKS);
        if (hResInfo)
            hResBlks   = LoadResource(hInst, hResInfo);

        hResInfo   = HFindBitmap(ID_BMP_LED);
        if (hResInfo)
            hResLed    = LoadResource(hInst, hResInfo);

        hResInfo   = HFindBitmap(ID_BMP_BUTTON);
        if (hResInfo)
            hResButton = LoadResource(hInst, hResInfo);

        if (hResBlks == NULL || hResLed == NULL || hResButton == NULL)
                return fFalse;

        lpDibBlks  = LockResource(hResBlks);
        lpDibLed   = LockResource(hResLed);
        lpDibButton= LockResource(hResButton);

        if (!Preferences.fColor)
                hGrayPen = GetStockObject(BLACK_PEN);
        else
                hGrayPen = CreatePen(PS_SOLID, 1, RGB(128, 128, 128));

        cbDibHeader = sizeof(BITMAPINFOHEADER) + (Preferences.fColor ? 16*4 : 2*4);

        cb = CbBitmap(dxBlk, dyBlk);
        for (i = 0 ; i < iBlkMax; i++)
                rgDibOff[i]    = cbDibHeader + (i * cb);

        cb = CbBitmap(dxLed, dyLed);
        for (i = 0 ; i < iLedMax; i++)
                rgDibLedOff[i] = cbDibHeader + (i * cb);

        cb = CbBitmap(dxButton, dyButton);
        for (i = 0 ; i < iButtonMax; i++)
                rgDibButton[i] = cbDibHeader + (i * cb);


        //
        //   MEM: move each Blk DIB to a memory BitMap
        //

        hDC = GetDC(hwndMain);

        for (i = 0 ; i < iBlkMax; i++) {

           //
           // Create a device context compatible with the device's active
           // display for each of these bitmaps.
           //

           MemBlkDc[i] = CreateCompatibleDC(hDC);
           if (MemBlkDc[i] == (HDC)NULL) {
              OutputDebugStringA("FLoad failed to create compatible dc\n");
           }

           //
           // create the bitmap for the above memory DC and selct this bitmap.
           //
           // we really only need 1 bitmap and 1 dc as they have done before!
           //

           MemBlkBitmap[i] = CreateCompatibleBitmap(hDC,dxBlk,dxBlk);
           if (MemBlkBitmap[i] == (HBITMAP)NULL) {
              OutputDebugStringA("Failed to create Bitmap\n");
           }

           SelectObject(MemBlkDc[i],MemBlkBitmap[i]);

           //
           //   copy the bits from the DIB into this bitmap
           //

           SetDIBitsToDevice(MemBlkDc[i],
                             0,
                             0,
                             dxBlk,
                             dyBlk,
                             0,
                             0,
                             0,
                             dyBlk,
                             lpDibBlks + rgDibOff[i],
                             (LPBITMAPINFO) lpDibBlks,
                             DIB_RGB_COLORS);

        }

        ReleaseDC(hwndMain, hDC);
        return fTrue;

}

VOID FreeBitmaps(VOID)
{
        int i;
        if (hGrayPen != NULL)
                DeleteObject(hGrayPen);

        UnlockResource(hResBlks);
        UnlockResource(hResLed);
        UnlockResource(hResButton);

        for (i = 0 ; i < iBlkMax; i++) {
           DeleteDC(MemBlkDc[i]);
           DeleteObject(MemBlkBitmap[i]);
        }


}


/****** C L E A N  U P ******/

VOID CleanUp(VOID)
{
        FreeBitmaps();
        EndTunes();
}



/****** D R A W  B L K ******/

VOID DrawBlk(HDC hDC, INT x, INT y)
{
        BitBlt(hDC,
               (x<<4)+(dxGridOff-dxBlk),
               (y<<4)+(dyGridOff-dyBlk),
               dxBlk,
               dyBlk,
               MemBlkDc[iBLK(x,y)],
               0,
               0,
               SRCCOPY);
}


VOID DisplayBlk(INT x, INT y)
{
        HDC hDC = GetDC(hwndMain);
        BitBlt(hDC,
               (x<<4)+(dxGridOff-dxBlk),
               (y<<4)+(dyGridOff-dyBlk),
               dxBlk,
               dyBlk,
               MemBlkDc[iBLK(x,y)],
               0,
               0,
               SRCCOPY);

        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  G R I D ******/

VOID DrawGrid(HDC hDC)
{
                REGISTER        INT   x;
                REGISTER        INT   y;
                INT dx;
                INT dy;

                dy = dyGridOff;

                for (y=1; y <= yBoxMac; y++, dy += dyBlk)
                        {
                        dx = dxGridOff;
                        for (x=1; x <= xBoxMac; x++, dx += dxBlk)
                                {
                                   BitBlt(hDC,
                                          dx,
                                          dy,
                                          dxBlk,
                                          dyBlk,
                                          MemBlkDc[iBLK(x,y)],
                                          0,
                                          0,
                                          SRCCOPY);
                                }
                        }
}

VOID DisplayGrid(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawGrid(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  L E D ******/

VOID DrawLed(HDC hDC, INT x, INT iLed)
{
        SetDIBitsToDevice(hDC, x, dyTopLed, dxLed, dyLed, 0, 0, 0, dyLed,
                lpDibLed + rgDibLedOff[iLed], (LPBITMAPINFO) lpDibLed, DIB_RGB_COLORS);
}


/****** D R A W  B O M B  C O U N T ******/

VOID DrawBombCount(HDC hDC)
{
        INT iLed;
        INT cBombs;

        DWORD dwDCLayout = GetLayout(hDC);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , 0); // Turn off mirroring before painting.
        }

        if (cBombLeft < 0)
                {
                iLed = iLedNegative;
                cBombs = (-cBombLeft) % 100;
                }
        else
                {
                iLed = cBombLeft / 100;
                cBombs = cBombLeft % 100;
                }

        DrawLed(hDC, dxLeftBomb, iLed);
        DrawLed(hDC, dxLeftBomb+dxLed, cBombs/10);
        DrawLed(hDC, dxLeftBomb+dxLed+dxLed, cBombs % 10);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , dwDCLayout); // Turn on the mirroring again.
        }
}

VOID DisplayBombCount(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawBombCount(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  T I M E ******/

VOID DrawTime(HDC hDC)
{
        INT iLed = cSec;
        DWORD dwDCLayout = GetLayout(hDC);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , 0); // Turn off mirroring before painting.
        }

        DrawLed(hDC, dxWindow-(dxRightTime+3*dxLed+dxpBorder), iLed/100);       /* OverFlow ? */
        DrawLed(hDC, dxWindow-(dxRightTime+2*dxLed+dxpBorder),(iLed %= 100)/10 );
        DrawLed(hDC, dxWindow-(dxRightTime+  dxLed+dxpBorder), iLed % 10);

        if (dwDCLayout & LAYOUT_RTL) {
           SetLayout(hDC , dwDCLayout); // Turn on the mirroring again.
        }
}

VOID DisplayTime(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawTime(hDC);
        ReleaseDC(hwndMain, hDC);
}


/****** D R A W  B U T T O N ******/

VOID DrawButton(HDC hDC, INT iButton)
{
        SetDIBitsToDevice(hDC, (dxWindow-dxButton)>>1, dyTopLed, dxButton, dyButton, 0, 0, 0, dyButton,
                lpDibButton + rgDibButton[iButton], (LPBITMAPINFO) lpDibButton, DIB_RGB_COLORS);
}

VOID DisplayButton(INT iButton)
{
        HDC hDC = GetDC(hwndMain);
        DrawButton(hDC, iButton);
        ReleaseDC(hwndMain, hDC);
}



/****** S E T  T H E  P E N ******/

VOID SetThePen(HDC hDC, INT fNormal)
{
        if (fNormal & 1)
                SetROP2(hDC, R2_WHITE);
        else
                {
                SetROP2(hDC, R2_COPYPEN);
                SelectObject(hDC, hGrayPen);
                }
}


/****** D R A W  B O R D E R ******/

/* 0 - white, gray
   1 - gray,  white
        2 - white, white
        3 - grey,  grey
*/

VOID DrawBorder(HDC hDC, INT x1, INT y1, INT x2, INT y2, INT width, INT fNormal)
{
        INT i = 0;

        SetThePen(hDC, fNormal);

        while (i++ < width)
                {
                (VOID)MMoveTo(hDC, x1, --y2);
                LineTo(hDC, x1++, y1);
                LineTo(hDC, x2--, y1++);
                }

        if (fNormal < 2)
                SetThePen(hDC, fNormal ^ 1);

        while (--i)
                {
                (VOID)MMoveTo(hDC, x1--,  ++y2);
                LineTo(hDC, ++x2, y2);
                LineTo(hDC, x2, --y1);
                }
}

VOID DrawBackground(HDC hDC)
{
        INT x, y;

        x = dxWindow-1;
        y = dyWindow-1;
        DrawBorder(hDC, 0, 0, x, y, 3, 1);

        x -= (dxRightSpace -3);
        y -= (dyBottomSpace-3);
        DrawBorder(hDC, dxGridOff-3, dyGridOff-3, x, y, 3, 0);
        DrawBorder(hDC, dxGridOff-3, dyTopSpace-3, x, dyTopLed+dyLed+(dyBottomSpace-6), 2, 0);

        x = dxLeftBomb+dxLed*3;
        y = dyTopLed+dyLed;
        DrawBorder(hDC, dxLeftBomb-1, dyTopLed-1, x, y, 1, 0);

        x = dxWindow-(dxRightTime+3*dxLed+dxpBorder+1);
        DrawBorder(hDC, x, dyTopLed-1, x+(dxLed*3+1), y, 1, 0);

        x = ((dxWindow-dxButton)>>1)-1;
        DrawBorder(hDC, x, dyTopLed-1, x+dxButton+1, dyTopLed+dyButton, 1, 2);
}


/****** D R A W  S C R E E N ******/

VOID DrawScreen(HDC hDC)
{
        DrawBackground(hDC);
        DrawBombCount(hDC);
        DrawButton(hDC, iButtonCur);
        DrawTime(hDC);
        DrawGrid(hDC);
}

VOID DisplayScreen(VOID)
{
        HDC hDC = GetDC(hwndMain);
        DrawScreen(hDC);
        ReleaseDC(hwndMain, hDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\grafix.h ===
/******************/
/* file: grafix.h */
/******************/

/*** Bitmaps ***/

#define dxBlk 16
#define dyBlk 16

#define dxLed 13
#define dyLed 23

#define dxButton 24
#define dyButton 24

#define dxFudge 2

#define dxLeftSpace 12
#define dxRightSpace 12
#define dyTopSpace 12
#define dyBottomSpace 12

#define dxGridOff dxLeftSpace
#define dyGridOff (dyTopLed+dyLed+16)

#define dxLeftBomb  (dxLeftSpace + 5)
#define dxRightTime (dxRightSpace + 5)
#define dyTopLed    (dyTopSpace + 4)


/*** Macros ***/

#ifdef DEBUG

//-protect-#define Oops(szMsg)
//	MessageBox(NULL, szMsg, "Oops", MB_OK | MB_ICONHAND)

#else
#define Oops(szMsg)
#endif



/*** Routines ***/

BOOL FInitLocal(VOID);
VOID CleanUp(VOID);

VOID DrawBlk(HDC, INT, INT);
VOID DisplayBlk(INT, INT);

VOID DrawButton(HDC, INT);
VOID DisplayButton(INT);
VOID DrawGrid(HDC);
VOID DisplayGrid(VOID);
VOID DrawBombCount(HDC);
VOID DisplayBombCount(VOID);
VOID DrawTime(HDC);
VOID DisplayTime(VOID);
VOID DrawScreen(HDC);
VOID DisplayScreen(VOID);

BOOL FLoadBitmaps(VOID);
VOID FreeBitmaps(VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\pref.h ===
/**********/
/* pref.h */
/**********/

#define cchNameMax 32

typedef struct
{
	WORD  wGameType;
	INT   Mines;
	INT   Height;
	INT   Width;
	INT   xWindow;
	INT   yWindow;
	INT   fSound;
	BOOL  fMark;
	BOOL  fTick;
	BOOL  fMenu;
	BOOL  fColor;
	INT   rgTime[3];
	TCHAR szBegin[cchNameMax];
	TCHAR szInter[cchNameMax];
	TCHAR szExpert[cchNameMax];
} PREF;


#define iszPrefGame    0
#define iszPrefMines   1
#define iszPrefHeight  2
#define iszPrefWidth   3
#define iszPrefxWindow 4
#define iszPrefyWindow 5
#define iszPrefSound   6
#define iszPrefMark    7
#define iszPrefMenu    8
#define iszPrefTick    9
#define iszPrefColor   10
#define iszPrefBeginTime   11
#define iszPrefBeginName   12
#define iszPrefInterTime   13
#define iszPrefInterName   14
#define iszPrefExpertTime  15
#define iszPrefExpertName  16
#define iszPrefAlreadyPlayed 17


#define iszPrefMax 18


VOID ReadPreferences(VOID);
VOID WritePreferences(VOID);
INT  ReadInt(INT, INT, INT, INT);
VOID ReadSz(INT, TCHAR FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\pref.c ===
/****************/
/* file: pref.c */
/****************/

#define _WINDOWS
#include <windows.h>
#include <port1632.h>

#include "main.h"
#include "res.h"
#include "rtns.h"
#include "grafix.h"
#include "pref.h"
#include "sound.h"

BOOL fUpdateIni = fFalse;
HKEY g_hReg;

extern TCHAR szDefaultName[];
extern INT xBoxMac;
extern INT yBoxMac;

extern PREF Preferences;

TCHAR * rgszPref[iszPrefMax] =
{
TEXT("Difficulty"),
TEXT("Mines"     ),
TEXT("Height"    ),
TEXT("Width"     ),
TEXT("Xpos"      ),
TEXT("Ypos"      ),
TEXT("Sound"     ),
TEXT("Mark"      ),
TEXT("Menu"      ),
TEXT("Tick"      ),
TEXT("Color"     ),
TEXT("Time1"     ),
TEXT("Name1"     ),
TEXT("Time2"     ),
TEXT("Name2"     ),
TEXT("Time3"     ),
TEXT("Name3"     ),
TEXT("AlreadyPlayed")
};


/****** PREFERENCES ******/

INT ReadInt(INT iszPref, INT valDefault, INT valMin, INT valMax)
{
DWORD dwIntRead;
DWORD dwSizeOfData = sizeof(INT);


    // If value not present, return default value.
    if (RegQueryValueEx(g_hReg, rgszPref[iszPref], NULL, NULL, (LPBYTE) &dwIntRead, 
                        &dwSizeOfData) != ERROR_SUCCESS)
        return valDefault;

    return max(valMin, min(valMax, (INT) dwIntRead));
}

#define ReadBool(iszPref, valDefault) ReadInt(iszPref, valDefault, 0, 1)


VOID ReadSz(INT iszPref, TCHAR FAR * szRet)
{
DWORD dwSizeOfData = cchNameMax * sizeof(TCHAR);

    // If string not present, return default string.
    if (RegQueryValueEx(g_hReg, rgszPref[iszPref], NULL, NULL, (LPBYTE) szRet, 
                        &dwSizeOfData) != ERROR_SUCCESS)
        lstrcpy(szRet, szDefaultName) ;

    return;
}


VOID ReadPreferences(VOID)
{
DWORD dwDisposition;


	// Open the registry key; if it fails, there is not much we can do about it.
	RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_READ, NULL, 
				   &g_hReg, &dwDisposition);
  
	yBoxMac= Preferences.Height= ReadInt(iszPrefHeight,MINHEIGHT,DEFHEIGHT,25);

	xBoxMac= Preferences.Width= ReadInt(iszPrefWidth,MINWIDTH,DEFWIDTH,30);

	Preferences.wGameType = (WORD)ReadInt(iszPrefGame,wGameBegin, wGameBegin, wGameExpert+1);
	Preferences.Mines    = ReadInt(iszPrefMines, 10, 10, 999);
	Preferences.xWindow  = ReadInt(iszPrefxWindow, 80, 0, 1024);
	Preferences.yWindow  = ReadInt(iszPrefyWindow, 80, 0, 1024);

	Preferences.fSound = ReadInt(iszPrefSound, 0, 0, fsoundOn);
	Preferences.fMark  = ReadBool(iszPrefMark,  fTrue);
	Preferences.fTick  = ReadBool(iszPrefTick,  fFalse);
	Preferences.fMenu  = ReadInt(iszPrefMenu,  fmenuAlwaysOn, fmenuAlwaysOn, fmenuOn);
	
	Preferences.rgTime[wGameBegin]  = ReadInt(iszPrefBeginTime, 999, 0, 999);
	Preferences.rgTime[wGameInter]  = ReadInt(iszPrefInterTime, 999, 0, 999);
	Preferences.rgTime[wGameExpert] = ReadInt(iszPrefExpertTime, 999, 0, 999);

	ReadSz(iszPrefBeginName, Preferences.szBegin);
	ReadSz(iszPrefInterName, Preferences.szInter);
	ReadSz(iszPrefExpertName, Preferences.szExpert);

    // set the color preference so we will use the right bitmaps
    // numcolors may return -1 on true color devices
	{
	HDC hDC = GetDC(GetDesktopWindow());
	Preferences.fColor  = ReadBool(iszPrefColor, (GetDeviceCaps(hDC, NUMCOLORS) != 2));
	ReleaseDC(GetDesktopWindow(),hDC);
	}

	if (FSoundOn())
		Preferences.fSound = FInitTunes();

	RegCloseKey(g_hReg);

}
	

VOID WriteInt(INT iszPref, INT val)
{

    // No check for return value for if it fails, can't do anything
    // to rectify the situation.
    RegSetValueEx(g_hReg, rgszPref[iszPref], 0, REG_DWORD, (LPBYTE) &val, sizeof(val));

    return;

}


VOID WriteSz(INT iszPref, TCHAR FAR * sz)
{
    // No check for return value for if it fails, can't do anything
    // to rectify the situation.
    RegSetValueEx(g_hReg, rgszPref[iszPref], 0, REG_SZ, (LPBYTE) sz, 
                  sizeof(TCHAR) * (lstrlen(sz)+1));

    return;
}


VOID WritePreferences(VOID)
{
DWORD dwDisposition;

	// Open the registry key; if it fails, there is not much we can do about it.
	RegCreateKeyEx(HKEY_CURRENT_USER, SZWINMINEREG, 0, NULL, 0, KEY_WRITE, NULL, 
				   &g_hReg, &dwDisposition);


	WriteInt(iszPrefGame,   Preferences.wGameType);
	WriteInt(iszPrefHeight, Preferences.Height);
	WriteInt(iszPrefWidth,  Preferences.Width);
	WriteInt(iszPrefMines,  Preferences.Mines);
	WriteInt(iszPrefMark,   Preferences.fMark);
	WriteInt(iszPrefAlreadyPlayed, 1);

#ifdef WRITE_HIDDEN
	WriteInt(iszPrefMenu,   Preferences.fMenu);
	WriteInt(iszPrefTick,   Preferences.fTick);
#endif
	WriteInt(iszPrefColor,  Preferences.fColor);
	WriteInt(iszPrefSound,  Preferences.fSound);
	WriteInt(iszPrefxWindow,Preferences.xWindow);
	WriteInt(iszPrefyWindow,Preferences.yWindow);

	WriteInt(iszPrefBeginTime,  Preferences.rgTime[wGameBegin]);
	WriteInt(iszPrefInterTime,  Preferences.rgTime[wGameInter]);
	WriteInt(iszPrefExpertTime, Preferences.rgTime[wGameExpert]);

	WriteSz(iszPrefBeginName,   Preferences.szBegin);
	WriteSz(iszPrefInterName,   Preferences.szInter);
	WriteSz(iszPrefExpertName,  Preferences.szExpert);

	RegCloseKey(g_hReg);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\res.h ===
/* MINE Resources */

#define ID_ICON_MAIN    100

#define ID_BMP_BLOCKS   410
#define ID_BAW_BLOCKS   411
#define ID_BMP_LED      420
#define ID_BAW_LED      421
#define ID_BMP_BUTTON   430
#define ID_BAW_BUTTON   431

#define ID_TUNE_TICK    432
#define ID_TUNE_WON     433  
#define ID_TUNE_LOST    434


/* Preferences Dialog */

#define ID_DLG_PREF     80

#define ID_BTN_OK       100
#define ID_BTN_CANCEL   109

#define ID_TXT_MINES    111
#define ID_TXT_HEIGHT   112
#define ID_TXT_WIDTH    113

#define ID_EDIT_HEIGHT  141
#define ID_EDIT_WIDTH   142
#define ID_EDIT_MINES   143

#define ID_TXT_CUST     151


#define ID_DLG_ENTER    600
#define ID_TEXT_BEST    601
#define ID_EDIT_NAME    602

#define ID_DLG_BEST     700
#define ID_TIME_BEGIN   701
#define ID_NAME_BEGIN   702
#define ID_TIME_INTER   703
#define ID_NAME_INTER   704
#define ID_TIME_EXPERT  705
#define ID_NAME_EXPERT  706
#define ID_BTN_RESET    707
#define ID_STEXT1       708
#define ID_STEXT2       709
#define ID_STEXT3       710


/* Menus */

#define ID_MENU         500
#define ID_MENU_ACCEL   501
							 	
#define IDM_NEW         510
#define IDM_EXIT        512

#define IDM_SKILL       520
#define IDM_BEGIN       521
#define IDM_INTER       522
#define IDM_EXPERT      523
#define IDM_CUSTOM      524
#define IDM_SOUND       526
#define IDM_MARK        527
#define IDM_BEST        528
#define IDM_COLOR       529

#define IDM_HELP        590
#define IDM_HOW2PLAY    591
#define IDM_HELP_HELP   592
#define IDM_HELP_ABOUT  593

#define ID_GAMENAME       1
#define ID_ERR_TITLE      3
#define ID_ERR_TIMER      4
#define ID_ERR_MEM        5
#define ID_ERR_UNKNOWN    6
#define ID_NAME_DEFAULT   8
#define ID_MSG_SEC        7
#define ID_MSG_BEGIN      9
#define ID_MSG_INTER     10
#define ID_MSG_EXPERT    11
#define ID_MSG_VERSION   12
#define ID_MSG_CREDIT    13

#define ID_ERR_MAX      999

// for context sensitive help
#define IDH_PREF_EDIT_HEIGHT 1000
#define IDH_PREF_EDIT_WIDTH  1001
#define IDH_PREF_EDIT_MINES  1002
#define IDH_BEST_BTN_RESET   1003
#define IDH_STEXT            1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\osshell\ep\winmine\rtns.h ===
/****************/
/* file: rtns.h */
/****************/

/*** Bitmaps ***/


/* Blocks */

#define iBlkBlank    0
#define iBlk1        1
#define iBlk2        2
#define iBlk8        8
#define iBlkGuessDn  9
#define iBlkBombDn  10
#define iBlkWrong   11
#define iBlkExplode 12
#define iBlkGuessUp 13
#define iBlkBombUp  14
#define iBlkBlankUp 15

#define