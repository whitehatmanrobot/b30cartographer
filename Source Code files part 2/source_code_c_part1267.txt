         Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                ToplpIterAdvance(VertexIterator) ) {

        ASSERT( ToplpIsVertex( Vertex ) );

        if ( Vertex == RootVertex )
        {
            ToplpVertexSetId( RootVertex, 0 );
        }
        else
        {
            ToplpVertexSetId( Vertex, DWORD_INFINITY );
        }

        ToplpVertexSetParent( Vertex, NULL );

        ToplHeapInsert( &Q, Vertex );

    }
    ToplpIterFree( VertexIterator );

    //
    // Set up the components structure
    //
    pComponents = InitComponents();
    curComponent = AddNewComponent( pComponents );

    //
    // Find the minimum spanning tree
    //
    while ( !ToplHeapIsEmpty( &Q ) )
    {
        PVERTEX     u, v;
        PEDGE       e;
        DWORD       w;
        ULONG       iEdge, cEdge;
        
        u = ToplHeapExtractMin( &Q );
        ASSERT( u );

        if( ToplpVertexGetId(u)==DWORD_INFINITY ) {
            // u has infinite cost, indicating that it could not be connected to
            // any existing components. Start a new component
            curComponent = AddNewComponent( pComponents );
        }
        AddVertexToComponent( curComponent, u );

        for ( iEdge = 0, cEdge = ToplpVertexNumberOfOutEdges( u ); 
                iEdge < cEdge; 
                    iEdge++) {

            e = ToplpVertexGetOutEdge( u, iEdge );

            ASSERT( ToplpIsEdge( e ) );
            ASSERT( ToplpEdgeGetFromVertex( e ) == u );
    
            v = ToplpEdgeGetToVertex( e );
            w = ToplpEdgeGetWeight( e );

            if ( ToplHeapIsElementOf( &Q, v )
              && w < ToplpVertexGetId( v )  )
            {
                ToplpVertexSetParent( v, u );

                ToplpVertexSetId( v, w );
            }
        }
    }

    ToplHeapDestroy( &Q );

    return pComponents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplheap.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplheap.c

Abstract:

    This files exports the simple ADT of a heap.
    
    This implementation is based on the heap definition in 
    
    _Introduction To Algorithms_ by Cormen, Leiserson, Rivest 1993.
    
    Chapter 7.
    
    The implmentation in the book is a heap for extracting maximum values; 
    the implementation in this module is for extracting minimum values.

Author:

    Colin Brace    (ColinBr)
    
Revision History

    12-5-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <w32topl.h>
#include <w32toplp.h>

#include <toplheap.h>


#define PARENT(i)  ((i) >> 1)           // floor (i/2)
#define LEFT(i)    ((i) << 1)           // i * 2
#define RIGHT(i)   (((i) << 1) | 0x1)   // (i * 2) + 1


BOOLEAN
ToplHeapIsValid(
    IN PTOPL_HEAP_INFO Heap
    )
//
// This tests the heap property invariant
//
//
// N.B. Only call this routine when the heap has been heapified
//      It is possible to change the "key" values on the nodes
//      with callling heapify, thus breaking the heap invariant.
//      The corollary of this is to heapify before doing any 
//      heap operations.
//
{

#define KEY_VALUE(x)  ( Heap->pfnKey( Heap->Array[(x)] ) )

    ULONG i;

    if ( !Heap )
    {
        return FALSE;
    }

    for ( i = 0; i < Heap->cArray; i++)
    {
        if ( !( KEY_VALUE( PARENT(i) ) <= KEY_VALUE( i ) ) ) 
        {
            return FALSE;
        }
    }

    return TRUE;

}

VOID
Heapify(
    IN PTOPL_HEAP_INFO Heap,
    IN ULONG           Index
    )
//
// Used to create a heap; places Index in the correct place
// in the heap.
//
{

#define KEY_VALUE(x)  ( Heap->pfnKey( Heap->Array[(x)] ) )

    ULONG Left, Right, Smallest;

    ASSERT( Heap );

    Left = LEFT( Index );
    Right = RIGHT( Index );

    if ( Left < Heap->cArray && KEY_VALUE(Left) < KEY_VALUE(Index) ) 
        Smallest = Left;
    else
        Smallest = Index;

    if ( Right < Heap->cArray && KEY_VALUE(Right) < KEY_VALUE(Smallest) ) 
        Smallest = Right;

    if ( Smallest != Index )
    {
        PVOID Temp;

        Temp = Heap->Array[Smallest];
        Heap->Array[Smallest] = Heap->Array[Index];
        Heap->Array[Index] = Temp;

        Heapify( Heap, Smallest );
    }

}

BOOLEAN
ToplHeapCreate(
    OUT PTOPL_HEAP_INFO Heap,
    IN  ULONG           MaxElements,
    IN  DWORD          (*pfnKey)( VOID *p )
    )
/*++                                                                           

Routine Description:

    This routine prepares a heap structure.

Parameters:

    Heap        - pointer to be used in subsequent operations
    
    MaxElements - number of elements in Array
    
    Key         - a function that associates a value with an element from Array

Returns:

    TRUE if function succeeded; FALSE otherwise

--*/
{

    ASSERT( Heap );
    ASSERT( pfnKey );

    if ( MaxElements > 0 )
    {
        //
        // ToplAlloc will throw an exception on failure
        //
        Heap->Array = (PVOID*) ToplAlloc( MaxElements * sizeof(PVOID) );
    }
    else
    {
        Heap->Array = NULL;
    }

    Heap->MaxElements = MaxElements;
    Heap->cArray = 0;
    Heap->pfnKey = pfnKey;


    ASSERT( ToplHeapIsValid( Heap ) );

    return TRUE;
}

VOID
Build_Heap(
    IN PTOPL_HEAP_INFO Heap
    )
//
// Builds a heap
//
{

    int i;

    ASSERT( Heap );

    for ( i = ( (Heap->cArray-1) / 2); i >= 0; i-- )
    {
        Heapify( Heap, i );
    }

    ASSERT( ToplHeapIsValid( Heap ) );

}

PVOID
ToplHeapExtractMin(
    IN PTOPL_HEAP_INFO Heap
    )
//
// Removes the smallest element in the heap
//
{
    PVOID Min;

    ASSERT( Heap );
    ASSERT( Heap->pfnKey );

    if ( Heap->cArray < 1 )
    {
        return NULL;
    }

    //
    // This call to Build_Heap denegrates our performance but is nessecary
    // since clients could have changed the values of the heap keys between
    // heap operations.  This call ensures the heap is valid before removing
    // the minimim value
    //
    // [nickhar] Calling Build_Heap here makes the heap completely useless.
    // With this implementation:
    //  - Inserting the elements takes O(n log n)
    //  - ExtractMin takes O(n)
    // Therefore this heap is worse than an unsorted array. The correct solution
    // is to use a heap which supports the 'decrease key' operation, like the
    // one in 'stheap.c'.
    //
    Build_Heap( Heap );

    ASSERT( ToplHeapIsValid( Heap ) );

    Min = Heap->Array[0];
    Heap->Array[0] = Heap->Array[Heap->cArray - 1];
    Heap->cArray--;

    Heapify( Heap, 0 );

    ASSERT( ToplHeapIsValid( Heap ) );

    return Min;

}


VOID
ToplHeapInsert(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
//
// Inserts an element into the heap - space should already be allocated
// for it
//
{

    ULONG i;

    ASSERT( ToplHeapIsValid( Heap ) );

    Heap->cArray++;

    if ( Heap->cArray > Heap->MaxElements )
    {
        ASSERT( !"W32TOPL: Heap Overflow" );
        return;
    }

    i = Heap->cArray - 1;
    while ( i > 0 && Heap->pfnKey(Heap->Array[PARENT(i)]) > Heap->pfnKey( Element ) )
    {
        Heap->Array[i] = Heap->Array[PARENT(i)];
        i = PARENT(i); 
    }

    Heap->Array[i] = Element;


    ASSERT( ToplHeapIsValid( Heap ) );

    return;
}

BOOLEAN
ToplHeapIsEmpty(
    IN PTOPL_HEAP_INFO Heap
    )
{
    return ( Heap->cArray == 0 );
}


BOOLEAN
ToplHeapIsElementOf(
    IN PTOPL_HEAP_INFO Heap,
    IN PVOID           Element
    )
{
    ULONG   i;

    ASSERT( Element );

    for ( i = 0; i < Heap->cArray; i++ )
    {
        if ( Heap->Array[i] == Element )
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
ToplHeapDestroy(
    IN OUT PTOPL_HEAP_INFO Heap
    )
{

    if ( Heap )
    {
        if ( Heap->Array )
        {
            RtlZeroMemory( Heap->Array, Heap->MaxElements*sizeof(PVOID) );
            ToplFree( Heap->Array );
        }

        RtlZeroMemory( Heap, sizeof(TOPL_HEAP_INFO) );

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\topllist.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    topllist.c

Abstract:
    
    This files contains the routines to manipulate the list and iterator
    object.

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <stddef.h>

typedef unsigned long DWORD;

#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

PLIST
ToplpListCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a List object and returns a pointer to it.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{   

    PLIST pList;

    pList = ToplAlloc(sizeof(LIST));
    memset(pList, 0, sizeof(LIST));

    pList->ObjectType = eList;

    return pList;

}

VOID 
ToplpListFree(
    PLIST     pList,
    BOOLEAN   fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a list object

Parameters:

    pList      - non-NULL PLIST object
    fRecursive - TRUE implies that elements in the list will be freed, too
    
Throws:

    TOPL_EX_WRONG_OBJECT    

--*/
{   
    if (fRecursive) {

        PLIST_ELEMENT pElement;
    
        while (pElement = ToplpListRemoveElem(pList, NULL)) {
            ToplpListFreeElem(pElement);
        }
    }

    //
    // Mark the object to prevent accidental reuse
    //
    pList->ObjectType = eInvalidObject;
    ToplFree(pList);

    return;
}

VOID
ToplpListFreeElem(
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine frees an element that was containing in a list. 

Parameters:

    pElem  - non-NULL pointer to either a VERTEX or PEDGE object

Return Values:

--*/
{
    switch (pElem->ObjectType) {
        
        case eVertex:
            ToplpVertexDestroy((PVERTEX)pElem, TRUE);
            break;

        case eEdge:
            ToplpEdgeDestroy((PEDGE)pElem, TRUE);
            break;

        default:
            ASSERT(FALSE);
    }

}

VOID
ToplpListSetIter(
    PLIST     pList,
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine sets Iterator to point to the head of List.

Parameters:

    pList      - non-NULL PLIST object
    pIter      - non-NULL PITERATOR object
    
--*/
{   
    pIter->pLink = pList->Head.Next;

    return;
}


PLIST_ELEMENT
ToplpListRemoveElem(
    PLIST         pList,
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine removes Elem from List if it exists in the list; NULL otherwise.
    If Elem is NULL then the first element in the list, if any, is returned.

Parameters:

    pList      - non-NULL PLIST object
    pElem      - if non-NULL, a PLIST_ELEMENT object

Returns:

    PLIST_ELEMENT if found; NULL otherwise
    
--*/
{

    PLIST_ELEMENT       ReturnedObject = NULL;
    PSINGLE_LIST_ENTRY  Curr, Prev;
 
    if (pElem) {
        //
        // Search linked list for object
        // 
        Prev = &(pList->Head);
        Curr = pList->Head.Next;
        while (Curr 
            && Curr != &(pElem->Link) ) {
            Prev = Curr;
            Curr = Curr->Next;
        }
        if (Curr) {
            //
            // Found it !
            //
            Prev->Next = Curr->Next;
            Curr->Next = NULL;
        }

        ReturnedObject = CAST_TO_LIST_ELEMENT(Curr);

    } else {
        //
        // Take the first element off
        //
        Curr = PopEntryList(&(pList->Head));
        if (Curr) {
            Curr->Next = NULL;
        }
        
        ReturnedObject = CAST_TO_LIST_ELEMENT(Curr);
        
    }

    if (ReturnedObject) {
        pList->NumberOfElements--;
    }
    ASSERT((signed)(pList->NumberOfElements) >= 0);
    
    return ReturnedObject;

}


VOID
ToplpListAddElem(
    PLIST         pList,
    PLIST_ELEMENT pElem
    )
/*++                                                                           

Routine Description:

    This routine adds Elem to List.  Elem should not be part of another list -
    currently there is no checking for this.

Parameters:

    pList is a PLIST object
    pElem is a PLIST_ELEMENT


--*/
{

    PushEntryList(&(pList->Head), &(pElem->Link));
    pList->NumberOfElements++;

    return;
}

DWORD
ToplpListNumberOfElements(
    PLIST        pList
    )
/*++                                                                           

Routine Description:

    This routine returns the number of elements in List

Parameters:

    List : a non-NULL PLIST object

--*/
{
    return pList->NumberOfElements;
}

//
// Iterator object routines
//
PITERATOR
ToplpIterCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This creates an iterator object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    

    PITERATOR pIter;

    pIter = ToplAlloc(sizeof(ITERATOR));
    memset(pIter, 0, sizeof(ITERATOR));

    pIter->ObjectType = eIterator;

    return pIter;
    
}

VOID 
ToplpIterFree(
    PITERATOR pIter
    )

/*++                                                                           

Routine Description:

    This routine free an iterator object.

Parameters:

    pIter : a non-NULL PITERATOR object

--*/
{   

    //
    // Mark the object to prevent accidental reuse
    //
    pIter->ObjectType = eInvalidObject;
    ToplFree(pIter);

    return;
}

PLIST_ELEMENT
ToplpIterGetObject(
    PITERATOR pIter
    )

/*++                                                                           

Routine Description:

    This routine returns the current object pointer to by the iterator.

Parameters:

    pIter : a non-NULL PITERATOR object
    
Return Values:

    A pointer to the current object - NULL if there are no more objects

--*/
{    
    return CAST_TO_LIST_ELEMENT(pIter->pLink);
}

VOID
ToplpIterAdvance(
    PITERATOR pIter
    )
/*++                                                                           

Routine Description:

    This routine advances the iterator by one object if it is not at the
    end.

Parameters:

    pIter : a non-NULL PITERATOR object

--*/
{   

    if (pIter->pLink) {
        pIter->pLink = pIter->pLink->Next;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplring.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplring.h

Abstract:

    This file contains the function declaration for the ring manipulation
    routines.

Author:

    Colin Brace   (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __TOPLRING_H
#define __TOPLRING_H

VOID
ToplpGraphMakeRing(
    PGRAPH     pGraph,
    DWORD      Flags,
    PLIST      VerticesToAdd,
    PEDGE      **EdgesToKeep,
    PULONG     cEdgesToKeep
    );


#endif // __TOPLRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplring.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplring.c

Abstract:

    This file contains the definition for ToplGraphMakeRing            
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stdio.h>

typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>
#include <topllist.h>
#include <toplgrph.h>

int 
__cdecl compareVertices( const void *arg1, const void *arg2 )
{
    PVERTEX pV1  = *((PVERTEX*)arg1);
    PVERTEX pV2  = *((PVERTEX*)arg2);

    ASSERT(ToplpIsVertex(pV1));
    ASSERT(ToplpIsVertex(pV2));

    if ( ToplpVertexGetId(pV1) < ToplpVertexGetId(pV2) ) {
        return -1;
    } else if ( ToplpVertexGetId(pV1) > ToplpVertexGetId(pV2)) {
        return 1;
    } else {
        return 0;
    }
}

//
// These two functions help build a dynamically growing list
// of PEDGE's
//
static ULONG ElementsAllocated;

void EdgeArrayInit(
    PEDGE **array,
    ULONG *count
    )
/*++                                                                           

Routine Description:

    This routine inits array, count, and ElementsAllocated so 
    they can be used in EdgeArrayAdd.

Parameters:

    array : is a pointer to an array of PEDGES
    count : the number of elements in the array

--*/
{
    *array  = NULL;
    *count  = 0;
    ElementsAllocated = 0;
}

void
EdgeArrayAdd(
    PEDGE **array,
    ULONG *count,
    PEDGE edge
    )
/*++                                                                           

Routine Description:

    This routine adds edge to array and increments count.  If there is not
    enough space in array more space is allocated.  If there is no more
    memory, an exception is raised.

Parameters:

    array : is a pointer to an array of PEDGES
    count : the number of elements in the array
    edge  : the new element to add

--*/
{
    #define CHUNK_SIZE               100  // this is the number of elements

    if (*count >= ElementsAllocated) {
        ElementsAllocated += CHUNK_SIZE;
        if ((*array)) {
            (*array) = (PEDGE*) ToplReAlloc(*array, ElementsAllocated * sizeof(PEDGE));
        } else {
            (*array) = (PEDGE*) ToplAlloc(ElementsAllocated * sizeof(PEDGE));
        }
    }
    (*array)[(*count)] = edge;
    (*count)++;

}


VOID
ToplpGraphMakeRing(
    PGRAPH     Graph,
    DWORD      Flags,
    PLIST      EdgesToAdd,
    PEDGE**    EdgesToKeep,
    ULONG*     cEdgesToKeep
    )
/*++                                                                           

Routine Description:

    This routine take Graph and determines what edges are necessary to 
    be created to make Graph into a ring, where vertices are connected in 
    ascending order, according to thier id.  In addition, existing edges
    necessary for the ring are recorded.

Parameters:

    Graph           should refer to a PGRAPH object
    
    Flags           can indicate whether the ring should be one-way or two way
    
    EdgesToAdd      should refer to a PLIST object.  All edges that need to 
                    be added will be placed in this list
                    
    EdgesToKeep     is an array of edges that exist in Graph. Edges that
                    that are needed to make a ring will be recorded in this
                    array. The caller must free this array with ToplFree. Note
                    that the edges object themselves still are contained within
                    the vertices they belong to and should be removed from there
                    before deleting.
                    
    cEdgesToKeep    is the number of elements in EdgesToKeep

Raises:

    TOPL_OUT_OF_MEMORY, TOPL_WRONG_OBJECT
        
--*/
{

    PVERTEX    Vertex;
    PEDGE      Edge;
    ULONG      VertexCount, Index, EdgeIndex;
    BOOLEAN    fMakeTwoWay = (BOOLEAN)(Flags & TOPL_RING_TWO_WAY);
    BOOLEAN    fSuccess   = FALSE;

    //
    // These resources must be released before exited
    //
    PVERTEX   *VertexArray = NULL;
    PITERATOR  VertexIterator = NULL;
    PITERATOR  EdgeIterator = NULL;
    
    __try
    {
        //
        // If the caller has specified that they want an array of vertices
        // to keep, init the array
        //
        if (EdgesToKeep) {
            EdgeArrayInit(EdgesToKeep, cEdgesToKeep);
        }
    
        //
        // Create an array of pointers to the vertices in graph so
        // they can be sorted
        //
        VertexArray = (PVERTEX*)ToplAlloc(ToplGraphNumberOfVertices(Graph) * sizeof(PVERTEX));
    
        VertexIterator = ToplpIterCreate();
        for ( ToplpGraphSetVertexIter(Graph, VertexIterator), VertexCount = 0; 
                Vertex = (PVERTEX) ToplpIterGetObject(VertexIterator);
                    ToplpIterAdvance(VertexIterator), VertexCount++) {
    
            ASSERT(ToplpIsVertex(Vertex));
    
            VertexArray[VertexCount] = Vertex;
    
        }
    
        qsort(VertexArray, VertexCount, sizeof(PVERTEX), compareVertices);
        
        //
        // Now iterate through each the vertices 1) creating edges that are
        // are needed to make a ring and 2) recording which edges are not
        // needed.
        //
        for (Index = 0; Index < VertexCount; Index++) {
    
            ULONG   ForwardVertexIndex, BackwardVertexIndex;
            BOOLEAN fFoundForwardEdge, fFoundBackwardEdge;
            PEDGE   Edge;
    
            fFoundForwardEdge = FALSE;
            fFoundBackwardEdge = FALSE;
    
            ForwardVertexIndex = Index + 1;
            BackwardVertexIndex = Index - 1;
            if (Index == 0) {
                BackwardVertexIndex =  VertexCount - 1;
            }
    
            if (Index == (VertexCount - 1)) {
                ForwardVertexIndex =  0;
            } 
    
            for (EdgeIndex = 0; 
                    EdgeIndex < ToplVertexNumberOfOutEdges(VertexArray[Index]); 
                        EdgeIndex++) {

                Edge = ToplVertexGetOutEdge(VertexArray[Index], EdgeIndex);

                ASSERT(ToplpIsEdge(Edge));
                ASSERT(ToplpEdgeGetFromVertex(Edge) == VertexArray[Index]);
    
                if (ToplpEdgeGetToVertex(Edge) == VertexArray[ForwardVertexIndex]) {
    
                    if(EdgesToKeep)
                        EdgeArrayAdd(EdgesToKeep, cEdgesToKeep, Edge);
                    fFoundForwardEdge = TRUE;
    
                } else if (ToplpEdgeGetToVertex(Edge) == VertexArray[BackwardVertexIndex]) {
    
                    if (fMakeTwoWay) {
    
                        if(EdgesToKeep)
                            EdgeArrayAdd(EdgesToKeep, cEdgesToKeep, Edge);
                        fFoundBackwardEdge = TRUE;
    
                    }
                }

            }


            //
            // Now create the edges as needed
            //
            if (Index == ForwardVertexIndex) {
                ASSERT(Index == BackwardVertexIndex);
                // There is just one vertex
                break;
            }
    
            if (!fFoundForwardEdge) {
    
                Edge = ToplpEdgeCreate(NULL);
    
                ToplpEdgeSetFromVertex(Edge, VertexArray[Index]);
                ToplpEdgeSetToVertex(Edge, VertexArray[ForwardVertexIndex]);
    
                ToplpListAddElem(EdgesToAdd, Edge);
    
            }
    
            if (  fMakeTwoWay
               && VertexArray[BackwardVertexIndex] != VertexArray[ForwardVertexIndex]
               && !fFoundBackwardEdge) {
    
                //
                // The caller wanted a two way ring & there is more than 2 vertices
                // and no backward edge was found
                //
    
                Edge = ToplpEdgeCreate(NULL);
    
                ToplpEdgeSetFromVertex(Edge, VertexArray[Index]);
                ToplpEdgeSetToVertex(Edge, VertexArray[BackwardVertexIndex]);
    
                ToplpListAddElem(EdgesToAdd, Edge);
            }
    
        }

        fSuccess = TRUE;
    }
    __finally
    {
        if (VertexArray) {
            ToplFree(VertexArray);
        }

        if (VertexIterator) {
            ToplIterFree(VertexIterator);
        }

        if (EdgeIterator) {
            ToplIterFree(EdgeIterator);
        }

        if (!fSuccess) {
            //
            // We must have bailed due to an exception - release resources
            // that normally the user would have freed
            //
            if (EdgesToKeep && *EdgesToKeep) {
                ToplFree(*EdgesToKeep);
            }

            while( (Edge=ToplpListRemoveElem(EdgesToAdd, NULL)) ) {
                ToplpEdgeDestroy(Edge, TRUE);
            }
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\w32toplp.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32toplp.h

Abstract:

    This file contains the private definitions of the core data structures
    and functions for w32topl.dll

Author:

    Colin Brace ColinBr
    
Revision History

    3-12-97   ColinBr    Created
    
--*/

#ifndef __W32TOPLP_H
#define __W32TOPLP_H

#define ToplpIsListElement(Elem)  ((Elem)   ? ( ((PLIST_ELEMENT)(Elem))->ObjectType == eEdge || \
                                                ((PLIST_ELEMENT)(Elem))->ObjectType == eVertex) : 0)
#define ToplpIsList(List)         ((List)   ? (((PLIST)(List))->ObjectType == eList) : 0)
#define ToplpIsIterator(Iter)     ((Iter)   ? (((PITERATOR)(Iter))->ObjectType == eIterator) :0)
#define ToplpIsEdge(Edge)         ((Edge)   ? (((PEDGE)(Edge))->ObjectType == eEdge) : 0)
#define ToplpIsVertex(Vertex)     ((Vertex) ? (((PVERTEX)(Vertex))->ObjectType == eVertex) : 0)
#define ToplpIsGraph(Graph)       ((Graph)  ? (((PGRAPH)(Graph))->ObjectType == eGraph) : 0)

#define CAST_TO_LIST_ELEMENT(pLink) (pLink ? (PLIST_ELEMENT) ((UCHAR*)(pLink) - offsetof(LIST_ELEMENT, Link)) : 0)

// Thread-local storage for memory allocation functions.
typedef struct _TOPL_TLS {
    TOPL_ALLOC *    pfAlloc;
    TOPL_REALLOC *  pfReAlloc;
    TOPL_FREE *     pfFree;
} TOPL_TLS;

extern DWORD gdwTlsIndex;

//
// Memory Routines
//
VOID*
ToplAlloc(
    ULONG size
    );

VOID*
ToplReAlloc(
    PVOID p,
    ULONG size
    );

//
// ToplFree is exported and can be found in w32topl.h
//

//
// Exception routines
//
void 
ToplRaiseException(
    DWORD ErrorCode
    );

#endif // __W32TOPLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\toplutil.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    toplutil.c

Abstract:

    This file contains helper routines for w32topl.dll

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <search.h>
#include <stddef.h>           // for offsetof()

#include <windows.h>
#include <winerror.h>


typedef unsigned long DWORD;


#include <w32topl.h>
#include <w32toplp.h>

//
// For the CAST_TO_LIST_ELEMENT macro
//
LIST_ELEMENT DummyListElement;

//
// Allocator routines
//
DWORD
ToplSetAllocator(
    IN  TOPL_ALLOC *    pfAlloc     OPTIONAL,
    IN  TOPL_REALLOC *  pfReAlloc   OPTIONAL,
    IN  TOPL_FREE *     pfFree      OPTIONAL
    )
/*++                                                                           

Routine Description:

    Sets the memory allocate/free routines to those specified.  If NULL, the
    default routines will be used.
    
    These routines are set on a per-thread basis.

Parameters:

    pfAlloc (IN) - Pointer to memory allocation function.
    
    pfReAlloc (IN) - Pointer to memory re-allocation function.
    
    pfFree (IN) - Pointer to memory free function.

Return Values:

    Win32 error.

--*/
{
    TOPL_TLS * pTLS;
    BOOL ok;
    
    // If one is NULL, all must be NULL.
    if ((!!pfAlloc != !!pfFree) || (!!pfAlloc != !!pfReAlloc)) {
        return ERROR_INVALID_PARAMETER;
    }

    pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    
    if (NULL == pfAlloc) {
        // Reset to default allocator.
        if (NULL != pTLS) {
            // Free the allocator info in thread local storage.
            (*pTLS->pfFree)(pTLS);
            
            ok = TlsSetValue(gdwTlsIndex, NULL);
            ASSERT(ok);
            if (!ok) {
                return GetLastError();
            }
        }
    }
    else {
        if (NULL == pTLS) {
            // Thread local storage block not yet allocated -- do so.
            pTLS = (*pfAlloc)(sizeof(*pTLS));
            if (NULL == pTLS) {
                return ERROR_OUTOFMEMORY;
            }

            ok = TlsSetValue(gdwTlsIndex, pTLS);
            ASSERT(ok);
            if (!ok) {
                (*pfFree)(pTLS);
                return GetLastError();
            }
        }

        // Save new non-default allocator info.
        pTLS->pfAlloc   = pfAlloc;
        pTLS->pfReAlloc = pfReAlloc;
        pTLS->pfFree    = pfFree;
    }

    return 0;
}


VOID*
ToplAlloc(
    ULONG size
    )
/*++                                                                           

Routine Description:

    This function allocates size bytes and returns a pointer to that chunk
    of memory.

Parameters:

    size : the number of bytes to be allocates

Return Values:

    A pointer to a block of memory; this function never returns NULL
    since an exception is raised if the allocation fails.

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    PVOID ret;

    if (NULL == pTLS) {
        ret = RtlAllocateHeap(RtlProcessHeap(), 0, size);
    }
    else {
        ret = (*pTLS->pfAlloc)(size);
    }

    if (!ret) {
        ToplRaiseException(TOPL_EX_OUT_OF_MEMORY);
    }

    return ret;
}


VOID*
ToplReAlloc(
    PVOID p,
    ULONG size
    )
/*++                                                                           

Routine Description:

    This function reallocates a chunk of memory allocated from 
    ToplAlloc

Parameters:

    p    the block of memory to reallocate
    size the new size of the block

Return Values:

    A pointer to a block of memory; this function never returns NULL
    since an exception is raised if the allocation fails.

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);
    PVOID ret;

    ASSERT(p);

    if (NULL == pTLS) {
        ret = RtlReAllocateHeap(RtlProcessHeap(), 0, p, size);
    }
    else {
        ret = (*pTLS->pfReAlloc)(p, size);
    }

    if (!ret) {
        ToplRaiseException(TOPL_EX_OUT_OF_MEMORY);
    }

    return ret;
}


VOID
ToplFree(
    VOID *p
    )
/*++                                                                           

Routine Description:

    This routine frees a block of memory allocated by a Topl*Alloc routine.

Parameters:

    p : a pointer to the block to release

Return Values:

--*/
{
    TOPL_TLS * pTLS = (TOPL_TLS *) TlsGetValue(gdwTlsIndex);

    ASSERT(p);

    if (NULL == pTLS) {
        RtlFreeHeap(RtlProcessHeap(), 0, p);
    }
    else {
        (*pTLS->pfFree)(p);
    }
}

//
// Exception handling routines
//

void 
ToplRaiseException(
    DWORD ErrorCode
    )
/*++                                                                           

Routine Description:

    This routine is a small wrapper for the RaiseException() function

Parameters:

    ErrorCode to throw.

Return Values:

    Does not return.

--*/
{
    RaiseException(ErrorCode, 
                   EXCEPTION_NONCONTINUABLE,
                   0,
                   NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\w32topl.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32topl.c

Abstract:

    This routine contains the dll entrypoint definitions for the w32topl.dll

Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <w32topl.h>
#include <w32toplp.h>

#include <topllist.h>
#include <toplgrph.h>
#include <toplring.h>
#include <dynarray.h>

// Index to be used for thread local storage.
DWORD gdwTlsIndex = 0;

//
// Entrypoint definitions
//

ULONG
NTAPI
DllEntry(
    HANDLE Module,
    ULONG Reason,
    PVOID Context
    )
{
    if (DLL_PROCESS_ATTACH == Reason) {
        // Prepare for thread local storage (see toplutil.c).
        gdwTlsIndex = TlsAlloc();
        if (0xFFFFFFFF == gdwTlsIndex) {
            ASSERT(!"TlsAlloc() failed!");
            return FALSE;
        }

        DisableThreadLibraryCalls(Module);
    }

    return TRUE ;
}

    


//
// List manipulation routines
//

TOPL_LIST
ToplListCreate(
    VOID
    )

/*++                                                                           

Routine Description:

    This routine creates a List object and returns a pointer to it.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpListCreate();
}


VOID 
ToplListFree(
    TOPL_LIST List,
    BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                           // in the list
    )
/*++                                                                           

Routine Description:

    This routine frees a list object

Parameters:

    List       - should refer to PLIST object
    fRecursive - TRUE implies that elements in the list will be freed, too
    
Throws:

    TOPL_EX_WRONG_OBJECT    

--*/
{    
    PLIST pList = (PLIST)List;

    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListFree(pList, fRecursive);

    return;
}


VOID
ToplListSetIter(
    TOPL_LIST     List,
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine sets Iterator to point to the head of List.

Parameters:

    List     should refer to a PLIST object
    Iterator should refer to a PITERATOR object
    
--*/
{    

    PLIST pList     = (PLIST)List;
    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsList(pList) || !ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListSetIter(pList, pIter);

    return;
}


TOPL_LIST_ELEMENT
ToplListRemoveElem(
    TOPL_LIST         List,
    TOPL_LIST_ELEMENT Elem
    )
/*++                                                                           

Routine Description:

    This routine removes Elem from List if it exists in the list; NULL otherwise.
    If Elem is NULL then the first element in the list, if any, is returned.

Parameters:

    List should refer to a PLIST object
    Elem if non-NULL should refer to a PLIST_ELEMENT
    
Returns:

    TOPL_LIST_ELEMENT if found; NULL otherwise

--*/
{    

    PLIST pList         = (PLIST)List;
    PLIST_ELEMENT pElem = (PLIST_ELEMENT)Elem;


    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pElem) {
        if (!ToplpIsListElement(pElem)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    return ToplpListRemoveElem(pList, pElem);

}


VOID
ToplListAddElem(
    TOPL_LIST         List,
    TOPL_LIST_ELEMENT Elem
    )
/*++                                                                           

Routine Description:

    This routine adds Elem to List.  Elem should not be part of another list -
    currently there is no checking for this.

Parameters:

    List should refer to a PLIST object
    Elem should refer to a PLIST_ELEMENT


--*/
{    

    PLIST pList     = (PLIST)List;
    PLIST_ELEMENT pElem = (PLIST_ELEMENT)Elem;

    if (!ToplpIsList(pList) || !ToplpIsListElement(pElem)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpListAddElem(pList, pElem);

    return;
}



DWORD
ToplListNumberOfElements(
    TOPL_LIST         List
    )
/*++                                                                           

Routine Description:

    This routine returns the number of elements in List

Parameters:

    List should refer to a PLIST object

--*/
{    

    PLIST pList     = (PLIST)List;

    if (!ToplpIsList(pList)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpListNumberOfElements(pList);

}


//
// Iterator object routines
//
TOPL_ITERATOR
ToplIterCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This creates an iterator object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    
    return ToplpIterCreate();
}


VOID 
ToplIterFree(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine free an iterator object.

Parameters:

    Iterator should refer to a PITERATOR object

--*/
{    

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpIterFree(pIter);

    return;
}


TOPL_LIST_ELEMENT
ToplIterGetObject(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine returns the current object pointer to by the iterator.

Parameters:

    Iterator should refer to a PITERATOR object
    
Return Values:

    A pointer to the current object - NULL if there are no more objects

--*/
{    

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpIterGetObject(pIter);
    
}

VOID
ToplIterAdvance(
    TOPL_ITERATOR Iterator
    )
/*++                                                                           

Routine Description:

    This routine advances the iterator by one object if it is not at the
    end.

Parameters:

    Iterator should refer to a PITERATOR object
    
--*/
{   

    PITERATOR pIter = (PITERATOR)Iterator;

    if (!ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpIterAdvance(pIter);

    return;
}

TOPL_EDGE
ToplEdgeCreate(
    VOID
    )        
/*++                                                                           

Routine Description:

    This routine creates an edge object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpEdgeCreate(NULL);
}

VOID
ToplEdgeFree(
    TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine frees an edge object.

Parameters:

    Edge should refer to a PEDGE object

--*/
{    

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDestroy(pEdge, 
                     TRUE);  // free the Edge

    return;
}


VOID
ToplEdgeInit(
    PEDGE E
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be an edge structure.  This is used by the c++ classes.

Parameters:

    E  : a pointer to an uninitialized edge object

--*/
{

    if (!E) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeCreate(E);

}

VOID
ToplEdgeDestroy(
    PEDGE  E
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by E but does not free
    E.

Parameters:

    E  : a pointer to an edge object

--*/
{

    if (!ToplpIsEdge(E)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDestroy(E, FALSE); // Don't free the object
}

VOID
ToplEdgeSetToVertex(
    TOPL_EDGE   Edge,
    TOPL_VERTEX ToVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the ToVertex field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object
    ToVertex if non-NULL should refer to a PVERTEX object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;
    PVERTEX pVertex = (PVERTEX)ToVertex;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    ToplpEdgeSetToVertex(pEdge, pVertex);
    
    return;
}

TOPL_VERTEX
ToplEdgeGetToVertex(
    TOPL_EDGE   Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the ToVertex

Parameters:
    
    Edge should refer to a PDGE object.

--*/
{    
    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpEdgeGetToVertex(pEdge);
}

VOID
ToplEdgeSetFromVertex(
    TOPL_EDGE   Edge,
    TOPL_VERTEX FromVertex
    )
/*++                                                                           

Routine Description:

    This routine sets the FromVertex of the Edge. 

Parameters:


    Edge should refer to a PEDGE object
    FromVertex if non-NULL should refer to a PVERTEX object
    

--*/
{    
    PEDGE   pEdge =   (PEDGE)Edge;
    PVERTEX pVertex = (PVERTEX)FromVertex;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    ToplpEdgeSetFromVertex(pEdge, pVertex);

    return;
}


TOPL_VERTEX
ToplEdgeGetFromVertex(
    TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the from vertex associated with Edge.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    A vertex object or NULL

--*/
{    
    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpEdgeGetFromVertex(pEdge);
}


VOID
ToplEdgeAssociate(
    IN TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routines adds the edges in question to edge lists of the 
    To and From vertices.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

    None.
    
Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices


--*/
{

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeAssociate(pEdge);

    return;

}

VOID
ToplEdgeDisassociate(
    IN TOPL_EDGE Edge
    )
/*++                                                                           

Routine Description:

    This routine removes the edge from the To and From vertex's edge list.

Parameters:

    Edge should refer to a PEDGE object

Return Values:

Throws:

    TOPL_EX_INVALID_VERTEX if either of the vertices don't point to valid
    vertices

--*/
{

    PEDGE pEdge = (PEDGE)Edge;

    if (!ToplpIsEdge(pEdge)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpEdgeDisassociate(pEdge);

    return;

}



VOID
ToplEdgeSetWeight(
    TOPL_EDGE   Edge,
    DWORD       Weight
    )
/*++                                                                           

Routine Description:

    This routine sets the weight field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;
    DWORD   ValidWeight = Weight;

    if ( !ToplpIsEdge(pEdge) )
    {
        ToplRaiseException( TOPL_EX_WRONG_OBJECT );
    }

    //
    // The minimum spanning tree algorithm needs to use DWORD_INFINITY
    // as a sentinel
    //
    if ( ValidWeight == DWORD_INFINITY )
    {
        ValidWeight--;
    }

    ToplpEdgeSetWeight( pEdge, ValidWeight );
    
    return;
}

DWORD
ToplEdgeGetWeight(
    TOPL_EDGE   Edge
    )
/*++                                                                           

Routine Description:

    This routine returns the weight field of the edge.

Parameters:
    
    Edge should refer to a PEDGE object

--*/
{    

    PEDGE   pEdge = (PEDGE)Edge;

    if ( !ToplpIsEdge(pEdge) )
    {
        ToplRaiseException( TOPL_EX_WRONG_OBJECT );
    }

    return ToplpEdgeGetWeight( pEdge );

}

//
// Vertex object routines
//
TOPL_VERTEX
ToplVertexCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a vertex object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.


--*/
{    
    return ToplpVertexCreate(NULL);
}

VOID
ToplVertexFree(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine releases the resources of a vertex object.

Parameters:

    Vertex should refer to a PVERTEX object

--*/
{    

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexDestroy(pVertex,
                       TRUE);  // free the vertex

    return;
}


VOID
ToplVertexInit(
    PVERTEX V
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be a vertex structure.  This is used by the c++ classes.

Parameters:

    V  : a pointer to an uninitialized vertex object

--*/
{

    if (!V) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexCreate(V);

}

VOID
ToplVertexDestroy(
    PVERTEX  V
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by V but does not free
    V

Parameters:

    V  : a pointer to  vertex object

--*/
{

    if (!ToplpIsVertex(V)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexDestroy(V, FALSE); // Don't free the object
}

VOID
ToplVertexSetId(
    TOPL_VERTEX Vertex,
    DWORD       Id
    )
/*++                                                                           

Routine Description:

    This routine sets the Id of Vertex

Parameters:

    Vertex should refer to a PVERTEX object

--*/
{   

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexSetId(pVertex, Id);

    return;
}

DWORD
ToplVertexGetId(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine returns the Id associated with this vertex.

Parameters:

    Vertex should refer to a PVERTEX object

Returns:

    The id of the vertex

--*/
{  

    PVERTEX   pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetId(pVertex);
}

DWORD
ToplVertexNumberOfInEdges(
    IN TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }
    
    return ToplpVertexNumberOfInEdges(pVertex);
}

TOPL_EDGE
ToplVertexGetInEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetInEdge(pVertex, Index);
}

DWORD
ToplVertexNumberOfOutEdges(
    IN TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexNumberOfOutEdges(pVertex);
}

TOPL_EDGE
ToplVertexGetOutEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    )
/*++                                                                           

Routine Description:


Parameters:

    Vertex       should refer to a PVERTEX object

Returns:

Raises:

--*/
{

    PVERTEX pVertex = (PVERTEX)Vertex;

    if (!ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetOutEdge(pVertex, Index);
}

VOID
ToplVertexSetParent(
    TOPL_VERTEX Vertex,
    TOPL_VERTEX Parent
    )
/*++                                                                           

Routine Description:

    This routine sets the parent of Vertex

Parameters:

    Vertex should refer to a PVERTEX object
    Parent should refer to a PVERTEX object

--*/
{   

    PVERTEX   pVertex = (PVERTEX)Vertex;
    PVERTEX   pParent  = (PVERTEX)Parent;

    if (!ToplpIsVertex(pVertex))
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if ( Parent && !ToplpIsVertex(pVertex) )
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpVertexSetParent( pVertex, pParent );

    return;
}

TOPL_VERTEX
ToplVertexGetParent(
    TOPL_VERTEX Vertex
    )
/*++                                                                           

Routine Description:

    This routine returns the parent associated with this vertex.

Parameters:

    Vertex should refer to a PVERTEX object

Returns:

    The parent of the vertex

--*/
{  

    PVERTEX   pVertex = (PVERTEX) Vertex;

    if ( !ToplpIsVertex( pVertex ) )
    {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return ToplpVertexGetParent( pVertex );
}


//
// Graph object routines
//

TOPL_GRAPH
ToplGraphCreate(
    VOID
    )
/*++                                                                           

Routine Description:

    This routine creates a graph object.  This function will always return
    a pointer to a valid object; an exception is thrown in the case
    of memory allocation failure.

--*/
{    
    return ToplpGraphCreate(NULL);
}

VOID
ToplGraphFree(
    TOPL_GRAPH Graph,
    BOOLEAN    fRecursive
    )
/*++                                                                           

Routine Description:

    This routine frees a graph object.

Parameters:

    Graph should refer to a PGRAPH object
    fRecursive : TRUE implies to free all edges and vertices associated with
                 the graph

--*/
{   

    PGRAPH   pGraph = (PGRAPH)Graph;

    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphDestroy(pGraph, 
                      TRUE,   //  free the objects
                      fRecursive);

    return;
}


VOID
ToplGraphInit(
    PGRAPH G
    )
/*++                                                                           

Routine Description:

    This routine initializes an already allocated piece of memory to 
    be an graph structure.  This is used by the c++ classes.

Parameters:

    G  : a pointer to an uninitialized graph object

--*/
{

    if (!G) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphCreate(G);

}

VOID
ToplGraphDestroy(
    PGRAPH  G
    )
/*++                                                                           

Routine Description:

    This routine cleans up any resources kept by G but does not free
    G.

Parameters:

    G  : a pointer to an graph object

--*/
{

    if (!ToplpIsGraph(G)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphDestroy(G, 
                      FALSE,  // Don't recursivly delete the vertices
                      FALSE); // Don't free the object
}

VOID
ToplGraphAddVertex(
    TOPL_GRAPH  Graph,
    TOPL_VERTEX VertexToAdd,
    PVOID       VertexName
    )
/*++                                                                           

Routine Description:

    This routine adds VertexToAdd to Graph.

Parameters:

    Graph should refer to a PGRAPH object
    VertexToAdd should refer to a PVERTEX object

Return Values:

--*/
{    

    PGRAPH   pGraph = (PGRAPH)Graph;
    PVERTEX  pVertex = (PVERTEX)VertexToAdd;

    if (!ToplpIsGraph(pGraph) || !ToplpIsVertex(pVertex)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    pVertex->VertexData.VertexName = VertexName;
    ToplpGraphAddVertex(pGraph, pVertex);
    
    return;
}

TOPL_VERTEX
ToplGraphRemoveVertex(
    TOPL_GRAPH  Graph,
    TOPL_VERTEX VertexToRemove
    )
/*++                                                                           

Routine Description:

    This routine removes and returns VertexToRemove from Graph if VertexToRemove
    is in Graph; returns NULL otherwise.
    If VertexToRemove is NULL, the first vertex in Graph's vertex list is
    removed.

Parameters:

    Graph should refer to a PGRAPH object
    VertexToRemove should be NULL or refer to a PVERTEX object

--*/
{   

    PGRAPH   pGraph = (PGRAPH)Graph;
    PVERTEX  pVertex = (PVERTEX)VertexToRemove;

    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    if (pVertex) {
        if (!ToplpIsVertex(pVertex)) {
            ToplRaiseException(TOPL_EX_WRONG_OBJECT);
        }
    }

    return ToplpGraphRemoveVertex(pGraph, pVertex);

}
      
VOID
ToplGraphSetVertexIter(
    TOPL_GRAPH    Graph,
    TOPL_ITERATOR Iter
    )
/*++                                                                           

Routine Description:

    This routine sets Iter to point to the beginning of Graph's vertex list.

Parameters:

    Graph should refer to a PGRAPH object
    Iter  should refer to a PITERATOR object

--*/
{   

    PGRAPH     pGraph = (PGRAPH)Graph;
    PITERATOR  pIter  = (PITERATOR)Iter;

    if (!ToplpIsGraph(pGraph) || !ToplpIsIterator(pIter)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ToplpGraphSetVertexIter(pGraph, pIter);

    return;
}


DWORD
ToplGraphNumberOfVertices(
    TOPL_GRAPH    Graph
)
/*++                                                                           

Routine Description:

    This routine returns the number of vertices in Graph's vertex list.

Parameters:

    Graph should refer to a PGRAPH object

--*/
{   

    PGRAPH     pGraph = (PGRAPH)Graph;
    
    if (!ToplpIsGraph(pGraph)) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    return  ToplpGraphNumberOfVertices(pGraph);
}


VOID
ToplGraphMakeRing(
    IN TOPL_GRAPH Graph,
    IN DWORD      Flags,
    OUT TOPL_LIST  EdgesToAdd,
    OUT TOPL_EDGE  **EdgesToKeep,
    OUT PULONG     cEdgesToKeep
    )
/*++                                                                           

Routine Description:

    This routine take Graph and determines what edges are necessary to 
    be created to make Graph into a ring, where vertices are connected in 
    ascending order, according to thier id.  In addition, edges superfluous
    to this ring are recorded.


Parameters:

    Graph           should refer to a PGRAPH object
    
    Flags           can indicate whether the ring should be one-way or two way
    
    EdgesToAdd      should refer to a PLIST object.  All edges that need to 
                    be added will be placed in this list
                    
    EdgesToKeep     is an array of edges that exist in Graph. Edges that
                    that are needed to make a ring will be recorded in this
                    array. The caller must free this array with ToplFree. Note
                    that the edges object themselves still are contained within
                    the vertices they belong to and should be removed from there
                    before deleting.
                    
    cEdgesToKeep  is the number of elements in EdgesToKeep

Raises:

    TOPL_EX_OUT_OF_MEMORY, TOPL_EX_WRONG_OBJECT
        
--*/
{
    PGRAPH pGraph = (PGRAPH)Graph;
    PLIST  pEdgesToAdd = (PLIST)EdgesToAdd;
    PEDGE  **pEdgesToKeep = (PEDGE**)EdgesToKeep;

    if (!ToplpIsGraph(pGraph) || !ToplpIsList(pEdgesToAdd) ) {
        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ASSERT(Flags & TOPL_RING_ONE_WAY
        || Flags & TOPL_RING_TWO_WAY);

    ToplpGraphMakeRing(pGraph, 
                       Flags, 
                       pEdgesToAdd, 
                       pEdgesToKeep, 
                       cEdgesToKeep);

    return;

}

TOPL_COMPONENTS*
ToplGraphFindEdgesForMST(
    IN  TOPL_GRAPH  Graph,
    IN  TOPL_VERTEX RootVertex,
    IN  TOPL_VERTEX VertexOfInterest,
    OUT TOPL_EDGE  **EdgesNeeded,
    OUT ULONG*      cEdgesNeeded
    )
/*++                                                                           

Routine Description:

    This routine makes a minimum cost spanning tree out of the edges and
    vertices in Graph and the determines what edges are connected to
    VertexOfInterest.

Parameters:

    Graph : an initialized graph object
    
    RootVertex : the vertex to start the mst from
    
    VertexOfInterest : the vertex to based EdgesNeeded on
    
    EdgesNeeded: the edges needed to be created by VertexOfInterest
                 to make the mst
                 
    cEdgesNeeded: the nummber of EdgesNeeded                 

Raises:

    TOPL_EX_OUT_OF_MEMORY, TOPL_EX_WRONG_OBJECT
        
--*/
{

    TOPL_COMPONENTS *pComponents;
    PGRAPH  pGraph = (PGRAPH)Graph;
    PVERTEX pRootVertex = (PVERTEX) RootVertex;
    PVERTEX pVertexOfInterest = (PVERTEX) VertexOfInterest;
    PEDGE  **pEdgesNeeded = (PEDGE**)EdgesNeeded;

    if ( !ToplpIsGraph( pGraph ) 
     ||  !ToplpIsVertex( pRootVertex )
     ||  !ToplpIsVertex( pVertexOfInterest ) ) {

        ToplRaiseException(TOPL_EX_WRONG_OBJECT);
    }

    ASSERT( EdgesNeeded );
    ASSERT( cEdgesNeeded );

    pComponents = ToplpGraphFindEdgesForMST( pGraph, 
                                         pRootVertex,
                                         pVertexOfInterest,
                                         pEdgesNeeded,
                                         cEdgesNeeded );

    ASSERT( pComponents!=NULL );
    return pComponents;

}

int
ToplIsToplException(
    DWORD ErrorCode
    )
/*++                                                                           

Routine Description:

    This routine is to be used in an exception filter to determine if the
    exception that was raised was generated by w32topl.dll

Parameters:

    ErrorCode   : the error code of the exception - ususually the value
                  returned from GetExceptionCode

Returns:

    EXCEPTION_EXECUTE_HANDLER, EXCEPTION_CONTINUE_SEARCH
        
--*/
{

    switch (ErrorCode) {
        
        case TOPL_EX_OUT_OF_MEMORY:
        case TOPL_EX_WRONG_OBJECT:
        case TOPL_EX_INVALID_EDGE:
        case TOPL_EX_INVALID_VERTEX:
        case TOPL_EX_INVALID_INDEX:
        case TOPL_EX_NULL_POINTER:
        case TOPL_EX_SCHEDULE_ERROR:
        case TOPL_EX_CACHE_ERROR:
        case TOPL_EX_NEVER_SCHEDULE:
        case TOPL_EX_GRAPH_STATE_ERROR:
        case TOPL_EX_INVALID_EDGE_TYPE:
        case TOPL_EX_INVALID_EDGE_SET:
        case TOPL_EX_COLOR_VTX_ERROR:
        case TOPL_EX_ADD_EDGE_AFTER_SET:
        case TOPL_EX_TOO_FEW_VTX:
        case TOPL_EX_TOO_FEW_EDGES:
        case TOPL_EX_NONINTERSECTING_SCHEDULES:

            return EXCEPTION_EXECUTE_HANDLER;

        default:

            return EXCEPTION_CONTINUE_SEARCH;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\exe\main.c ===
/*++              

Copyright (C) 1997 Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file contains unit test for the w32topl dll
    
    This program will return 0 if success; !0 otherwise
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <w32topl.h>

//
// Small utilities
//
BOOLEAN fVerbose = FALSE;

#define Output(x)          if (fVerbose) printf x;
#define NELEMENTS(x)        (sizeof(x)/sizeof(x[0]))

// defined in apitest.c
int     
TestAPI(VOID);

// defined in heaptest.c
int
TestNewHeap(VOID);
        
// defined in sttest.c
int
TestNewSpanTree(VOID);
        
// defined in schedtest.c
int
TestSched(VOID);
        
void    
PrintGraph(TOPL_GRAPH Graph);
        
void    
HandleToplException(DWORD ErrorCode)
//      
// This routine prints out what error occured within the w32topl dll
//
{

    switch (ErrorCode)
    {
        
        case TOPL_EX_OUT_OF_MEMORY:
            printf("w32topl: out of memory exception.\n");
            break;

        case TOPL_EX_WRONG_OBJECT:

            printf("w32topl: wrong object.\n");
            break;

        case TOPL_EX_INVALID_EDGE:

            printf("w32topl: an invalid edge was added to a vertex.\n");
            break;

        default:

            printf("w32topl unknown exception.\n");

    }
}

int
TestExceptions()
//
// The basic premise here is to set the return code to 0 just before
// the exception should occur.
//
{
    
    TOPL_EDGE   Edge;
    TOPL_VERTEX Vertex1, Vertex2;

    DWORD ErrorCode;
    int   ret;

    //
    // Test passing in a wrong object
    //
    __try
    {
        ret = 1;
        Edge = ToplEdgeCreate();

        ret = 0;
        ToplVertexSetId(Edge, 0);
        ret = 1;
    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        if (ErrorCode != TOPL_EX_WRONG_OBJECT) {
            HandleToplException(ErrorCode);
            ret = 1;
        }
    }
    ToplEdgeFree(Edge);

    if (ret) {
        return ret;
    }

    //
    // Test passing in a deleted object
    // 
    __try
    {
        ret = 1;

        Edge = ToplEdgeCreate();

        // Should be able to set a NULL vertex 
        ToplEdgeSetToVertex(Edge, 0);
        ToplEdgeSetFromVertex(Edge, 0);

        ToplEdgeFree(Edge);

        ret = 0;
    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        if (ErrorCode != TOPL_EX_WRONG_OBJECT) {
            HandleToplException(ErrorCode);
            ret = 1;
        }
    }

    if (ret) {
        return ret;
    }



    return ret;

}


#include "..\toplheap.h"

DWORD
Key( VOID *p )
{
    DWORD *pdw = (DWORD*) p;

    return *pdw;
}

int
TestHeap(
    VOID
    )
{

    TOPL_HEAP_INFO H;
    DWORD          dw[1000];
    DWORD          Last = 0;
    int            i, ret = 0;

    ToplHeapCreate( &H,
                    1000,
                    Key );

    srand( (unsigned)time( NULL ) );

    for ( i = 0; i < 1000; i++ )
    {
        dw[i] = (DWORD) (rand());

        ToplHeapInsert( &H, &dw[i] );
    }

    for ( i = 0; i < 1000; i++ )
    {
        DWORD *pdw;

        pdw = ToplHeapExtractMin( &H );
        printf( "%d ", *pdw );

        if ( i > 0 )
        {
            if ( Last > *pdw )
            {
                ret = !0;
            }
        }
        Last = *pdw;
    }

    printf( "\n" );

    return ret;

}


int
TestNxNMST(
    int Value
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX   *VertexArray = NULL;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesNeeded = NULL;
    ULONG          cEdgesNeeded = 0;
    DWORD          ErrorCode;

    TOPL_COMPONENTS *pComponents;
    
    ULONG         i, j;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {

        //
        // Make a graph
        //
        Graph         = ToplGraphCreate();

        //
        // Insert the vertices
        //
        VertexArray = (TOPL_VERTEX*)malloc(NumberOfVertices * sizeof(TOPL_VERTEX));
        if (!VertexArray) {
            Output(("Out of memory.\n"));
            ret = !0;
            __leave;
        }
        
        for (i = 0; i < NumberOfVertices; i++) {
            VertexArray[i] = ToplVertexCreate();
            ToplGraphAddVertex(Graph, VertexArray[i], VertexArray[i]);
        }

        //
        // Add the edges, to make an NxN graph
        //
        for (i = 0; i < NumberOfVertices; i++) {
            for (j = 0; j < NumberOfVertices; j++) {
                if (i != j) {

                    Edge = ToplEdgeCreate();

                    ToplEdgeSetWeight( Edge, rand() );
                    ToplEdgeSetFromVertex( Edge, VertexArray[i] );
                    ToplEdgeSetToVertex( Edge, VertexArray[j] );
                    ToplEdgeAssociate( Edge);
                }
            }
        }

        Output(("Here is the NxN graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make a ring and remove the edges
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                 VertexArray[0],
                                 VertexArray[0],
                                 &EdgesNeeded,
                                 &cEdgesNeeded
                                 );
        ToplDeleteComponents( pComponents );


        Output(("Here is the ring graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestExampleMST(
    VOID
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    a=NULL, b=NULL, c=NULL, d=NULL, e=NULL, f=NULL, g=NULL, h=NULL, i=NULL;
    TOPL_EDGE      ab, ah, bh, bc, cd, cf, ci, de, df, ef, fg, gh, gi, hi;
    TOPL_EDGE      ba, ha, hb, cb, dc, fc, ic, ed, fd, fe, gf, hg, ig, ih;

    TOPL_ITERATOR  VertexIterator;
    TOPL_VERTEX    Vertex;


    TOPL_VERTEX    VertexArray[] = { a, b, c, d, e, f, g, h, i };


    TOPL_EDGE      *EdgesNeeded;
    ULONG          cEdgesNeeded;

    TOPL_COMPONENTS *pComponents;

    int            ret, index1, index2;

    DWORD          ErrorCode;

    __try {
    __try {

        //
        // Make a graph
        //
        Graph = ToplGraphCreate();

        //
        // Create and insert the vertices
        //
        a = ToplVertexCreate();
        b = ToplVertexCreate();
        c = ToplVertexCreate();
        d = ToplVertexCreate();
        e = ToplVertexCreate();
        f = ToplVertexCreate();
        g = ToplVertexCreate();
        h = ToplVertexCreate();
        i = ToplVertexCreate();

        ToplGraphAddVertex( Graph, a , a );
        ToplGraphAddVertex( Graph, b , b );
        ToplGraphAddVertex( Graph, c , c );
        ToplGraphAddVertex( Graph, d , d );
        ToplGraphAddVertex( Graph, e , e );
        ToplGraphAddVertex( Graph, f , f );
        ToplGraphAddVertex( Graph, g , g );
        ToplGraphAddVertex( Graph, h , h );
        ToplGraphAddVertex( Graph, i , i );

        VertexArray[0] = a;
        VertexArray[1] = b;
        VertexArray[2] = c;
        VertexArray[3] = d;
        VertexArray[4] = e;
        VertexArray[5] = f;
        VertexArray[6] = g;
        VertexArray[7] = h;
        VertexArray[8] = i;

        //
        // With no edges we should not find a spanning tree
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                               a,
                                               a,
                                               &EdgesNeeded,
                                               &cEdgesNeeded
                                              );

        if ( pComponents->numComponents != 9 )
        {
            //
            // ToplGraphFindEdgesForMST did not work correctly
            //
            return !0;

        }

        ToplDeleteComponents( pComponents );


        //
        // Create the edges
        //
        ab = ToplEdgeCreate(); ToplEdgeSetToVertex(ab, b); ToplEdgeSetFromVertex(ab, a);
        ah = ToplEdgeCreate(); ToplEdgeSetToVertex(ah, h); ToplEdgeSetFromVertex(ah, a);
        bh = ToplEdgeCreate(); ToplEdgeSetToVertex(bh, h); ToplEdgeSetFromVertex(bh, b);
        bc = ToplEdgeCreate(); ToplEdgeSetToVertex(bc, c); ToplEdgeSetFromVertex(bc, b);
        cd = ToplEdgeCreate(); ToplEdgeSetToVertex(cd, d); ToplEdgeSetFromVertex(cd, c);
        cf = ToplEdgeCreate(); ToplEdgeSetToVertex(cf, f); ToplEdgeSetFromVertex(cf, c);
        ci = ToplEdgeCreate(); ToplEdgeSetToVertex(ci, i); ToplEdgeSetFromVertex(ci, c);
        de = ToplEdgeCreate(); ToplEdgeSetToVertex(de, e); ToplEdgeSetFromVertex(de, d);
        df = ToplEdgeCreate(); ToplEdgeSetToVertex(df, f); ToplEdgeSetFromVertex(df, d);
        ef = ToplEdgeCreate(); ToplEdgeSetToVertex(ef, f); ToplEdgeSetFromVertex(ef, e);
        fg = ToplEdgeCreate(); ToplEdgeSetToVertex(fg, g); ToplEdgeSetFromVertex(fg, f);
        gh = ToplEdgeCreate(); ToplEdgeSetToVertex(gh, h); ToplEdgeSetFromVertex(gh, g);
        gi = ToplEdgeCreate(); ToplEdgeSetToVertex(gi, i); ToplEdgeSetFromVertex(gi, g);
        hi = ToplEdgeCreate(); ToplEdgeSetToVertex(hi, i); ToplEdgeSetFromVertex(hi, h);

        ba = ToplEdgeCreate(); ToplEdgeSetToVertex(ba, a); ToplEdgeSetFromVertex(ba, b);
        ha = ToplEdgeCreate(); ToplEdgeSetToVertex(ha, a); ToplEdgeSetFromVertex(ha, h);
        hb = ToplEdgeCreate(); ToplEdgeSetToVertex(hb, b); ToplEdgeSetFromVertex(hb, h);
        cb = ToplEdgeCreate(); ToplEdgeSetToVertex(cb, b); ToplEdgeSetFromVertex(cb, c);
        dc = ToplEdgeCreate(); ToplEdgeSetToVertex(dc, c); ToplEdgeSetFromVertex(dc, d);
        fc = ToplEdgeCreate(); ToplEdgeSetToVertex(fc, c); ToplEdgeSetFromVertex(fc, f);
        ic = ToplEdgeCreate(); ToplEdgeSetToVertex(ic, c); ToplEdgeSetFromVertex(ic, i);
        ed = ToplEdgeCreate(); ToplEdgeSetToVertex(ed, d); ToplEdgeSetFromVertex(ed, e);
        fd = ToplEdgeCreate(); ToplEdgeSetToVertex(fd, d); ToplEdgeSetFromVertex(fd, f);
        fe = ToplEdgeCreate(); ToplEdgeSetToVertex(fe, e); ToplEdgeSetFromVertex(fe, f);
        gf = ToplEdgeCreate(); ToplEdgeSetToVertex(gf, f); ToplEdgeSetFromVertex(gf, g);
        hg = ToplEdgeCreate(); ToplEdgeSetToVertex(hg, g); ToplEdgeSetFromVertex(hg, h);
        ig = ToplEdgeCreate(); ToplEdgeSetToVertex(ig, g); ToplEdgeSetFromVertex(ig, i);
        ih = ToplEdgeCreate(); ToplEdgeSetToVertex(ih, h); ToplEdgeSetFromVertex(ih, i);

        //
        // Set the weights
        //
        ToplEdgeSetWeight( ab, 4 );
        ToplEdgeSetWeight( ah, 9 );
        ToplEdgeSetWeight( bh, 11 );
        ToplEdgeSetWeight( bc, 8 );
        ToplEdgeSetWeight( cd, 7 );
        ToplEdgeSetWeight( cf, 4 );
        ToplEdgeSetWeight( ci, 2 );
        ToplEdgeSetWeight( de, 9 );
        ToplEdgeSetWeight( df, 14 );
        ToplEdgeSetWeight( ef, 10 );
        ToplEdgeSetWeight( fg, 2 );
        ToplEdgeSetWeight( gh, 1 );
        ToplEdgeSetWeight( gi, 6 );
        ToplEdgeSetWeight( hi, 7 );


        ToplEdgeSetWeight( ba, 4 );
        ToplEdgeSetWeight( ha, 9 );
        ToplEdgeSetWeight( hb, 11 );
        ToplEdgeSetWeight( cb, 8 );
        ToplEdgeSetWeight( dc, 7 );
        ToplEdgeSetWeight( fc, 4 );
        ToplEdgeSetWeight( ic, 2 );
        ToplEdgeSetWeight( ed, 9 );
        ToplEdgeSetWeight( fd, 14 );
        ToplEdgeSetWeight( fe, 10 );
        ToplEdgeSetWeight( gf, 2 );
        ToplEdgeSetWeight( hg, 1 );
        ToplEdgeSetWeight( ig, 6 );
        ToplEdgeSetWeight( ih, 7 );

        //
        // Associate the edges with thier vertices
        //
        ToplEdgeAssociate( ab );
        ToplEdgeAssociate( ah );
        ToplEdgeAssociate( bh );
        ToplEdgeAssociate( bc );
        ToplEdgeAssociate( cd );
        ToplEdgeAssociate( cf );
        ToplEdgeAssociate( ci );
        ToplEdgeAssociate( de );
        ToplEdgeAssociate( df );
        ToplEdgeAssociate( ef );
        ToplEdgeAssociate( fg );
        ToplEdgeAssociate( gh );
        ToplEdgeAssociate( gi );
        ToplEdgeAssociate( hi );


        ToplEdgeAssociate( ba );
        ToplEdgeAssociate( ha );
        ToplEdgeAssociate( hb );
        ToplEdgeAssociate( cb );
        ToplEdgeAssociate( dc );
        ToplEdgeAssociate( fc );
        ToplEdgeAssociate( ic );
        ToplEdgeAssociate( ed );
        ToplEdgeAssociate( fd );
        ToplEdgeAssociate( fe );
        ToplEdgeAssociate( gf );
        ToplEdgeAssociate( hg );
        ToplEdgeAssociate( ig );
        ToplEdgeAssociate( ih );


        //
        // Now find a minimum spanning tree!
        //
        for ( index1 = 0; index1 < NELEMENTS(VertexArray); index1++)
        {
            for ( index2 = 0; index2 < NELEMENTS(VertexArray); index2++)
            {

                printf("New iteration\n\n");

                pComponents = ToplGraphFindEdgesForMST( Graph,
                                                      VertexArray[index1],
                                                      VertexArray[index2],
                                                      &EdgesNeeded,
                                                      &cEdgesNeeded );
        
                if ( pComponents->numComponents == 1 )
                {
                    CHAR c1;
                    CHAR c2;

                    ToplDeleteComponents( pComponents );
                    ret = 0;

                    VertexIterator = ToplIterCreate();
                    for ( ToplGraphSetVertexIter(Graph, VertexIterator);
                            Vertex = (TOPL_VERTEX) ToplIterGetObject(VertexIterator);
                                ToplIterAdvance(VertexIterator) ) {

                       c1 = '\0';
                       c2 = '\0';
                
                       if ( Vertex == VertexArray[0] ) c1 =  'a';
                       if ( Vertex == VertexArray[1] ) c1 =  'b';
                       if ( Vertex == VertexArray[2] ) c1 =  'c';
                       if ( Vertex == VertexArray[3] ) c1 =  'd';
                       if ( Vertex == VertexArray[4] ) c1 =  'e';
                       if ( Vertex == VertexArray[5] ) c1 =  'f';
                       if ( Vertex == VertexArray[6] ) c1 =  'g';
                       if ( Vertex == VertexArray[7] ) c1 =  'h';
                       if ( Vertex == VertexArray[8] ) c1 =  'i';

                       Vertex = ToplVertexGetParent( Vertex );


                       if ( Vertex == VertexArray[0] ) c2 =  'a';
                       if ( Vertex == VertexArray[1] ) c2 =  'b';
                       if ( Vertex == VertexArray[2] ) c2 =  'c';
                       if ( Vertex == VertexArray[3] ) c2 =  'd';
                       if ( Vertex == VertexArray[4] ) c2 =  'e';
                       if ( Vertex == VertexArray[5] ) c2 =  'f';
                       if ( Vertex == VertexArray[6] ) c2 =  'g';
                       if ( Vertex == VertexArray[7] ) c2 =  'h';
                       if ( Vertex == VertexArray[8] ) c2 =  'i';


                       if ( c1 && c2 )
                       {
                           if ( c1 < c2)
                           {
                               printf( "(%c,%c) \n", c1, c2 );
                           }
                           else 
                           {
                               printf( "(%c,%c) \n", c2, c1 );
                           }
                       }
                
                    }
                    ToplIterFree( VertexIterator );

                }
                else 
                {
                    ret  = !0;
                    break;
                }
            }

            if ( ret )
            {
                 break;
            }
        }

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestComponents(
    VOID
    )
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    A, B, C, D, E, F, G, H, I;
    const DWORD       NUM_VTX=9;
    TOPL_VERTEX     **VertexArray;
    char            *MarkArray, *MarkArray2;
    DWORD           cVtxArray=0;

    //
    // Graph looks like this:
    // A--G--B  C--H  F--E
    //          |  |
    //          D--I
    //
    // Root Vtx: D
    // Vtx of Interest: E
    // 

    TOPL_EDGE      AG, GB, CH, HI, ID, DC, FE;
    TOPL_EDGE      GA, BG, HC, IH, DI, CD, EF;

    TOPL_ITERATOR  VertexIterator;
    TOPL_VERTEX    Vertex;

    TOPL_EDGE      *EdgesNeeded;
    ULONG          cEdgesNeeded;

    TOPL_COMPONENTS *pComponents;
    TOPL_COMPONENT  *pComponent;

    DWORD           i, j, k, ret;
    DWORD          ErrorCode;

    __try {
    __try {

        VertexArray = calloc( NUM_VTX, sizeof(TOPL_VERTEX*) );
        MarkArray = calloc( NUM_VTX, sizeof(char) );
        MarkArray2 = calloc( NUM_VTX, sizeof(char) );

        //
        // Make a graph
        //
        Graph = ToplGraphCreate();

        //
        // Create and insert the vertices
        //
        #define MAKE_VTX(v) \
            v=ToplVertexCreate(); \
            ToplGraphAddVertex(Graph,v,v); \
            VertexArray[cVtxArray++]=v;
        MAKE_VTX(A)
        MAKE_VTX(B)
        MAKE_VTX(C)
        MAKE_VTX(D)
        MAKE_VTX(E)
        MAKE_VTX(F)
        MAKE_VTX(G)
        MAKE_VTX(H)
        MAKE_VTX(I)

#ifdef DBG
        #define RETURN_ERROR  {ASSERT(0); return !0;}
#else
        #define RETURN_ERROR  {return !0;}
#endif

        //
        // With no edges we should not find a spanning tree
        //
        pComponents = ToplGraphFindEdgesForMST(Graph,
                                               A,
                                               A,
                                               &EdgesNeeded,
                                               &cEdgesNeeded
                                              );

        if ( pComponents->numComponents != 9 )
        {
            //
            // ToplGraphFindEdgesForMST did not work correctly
            //
            RETURN_ERROR
        }

        // Check the components; mark each vertex in the components structure
        memset(MarkArray,0,NUM_VTX);
        for(i=0;i<pComponents->numComponents;i++) {
            for(j=0;j<NUM_VTX;j++) {
                if(pComponents->pComponent[i].numVertices!=1) {
                    RETURN_ERROR
                }
                if(pComponents->pComponent[i].vertexNames[0]==VertexArray[j]) {
                    MarkArray[j]=1;
                    break;
                }
            }
        }
        // Check that all vertices were marked
        for(i=0;i<NUM_VTX;i++) if(!MarkArray[i]) RETURN_ERROR
        // Clear the marks
        memset(MarkArray,0,NUM_VTX);
        
        ToplDeleteComponents( pComponents );

        //
        // Create the edges
        //
        #define MAKE_EDGE_HELP(u,v) \
            u##v=ToplEdgeCreate(); \
            ToplEdgeSetToVertex(u##v,v); \
            ToplEdgeSetFromVertex(u##v,u); \
            ToplEdgeSetWeight(u##v,NUM_VTX); \
            ToplEdgeAssociate(u##v);
        #define MAKE_EDGE(u,v) \
            MAKE_EDGE_HELP(u,v) \
            MAKE_EDGE_HELP(v,u)

        MAKE_EDGE(A,G)
        MAKE_EDGE(G,B)
        MAKE_EDGE(C,H)
        MAKE_EDGE(H,I)
        MAKE_EDGE(I,D)
        MAKE_EDGE(D,C)
        MAKE_EDGE(F,E)

        pComponents = ToplGraphFindEdgesForMST( Graph,
                                                VertexArray[3],
                                                VertexArray[4],
                                                &EdgesNeeded,
                                                &cEdgesNeeded );
        
        if( pComponents->numComponents != 3 )
            RETURN_ERROR

        for(i=0;i<pComponents->numComponents;i++) {
           pComponent = &pComponents->pComponent[i];
           if(pComponent->numVertices==0) RETURN_ERROR
           if(   A==pComponent->vertexNames[0]
              || G==pComponent->vertexNames[0]
              || B==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=3) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[0]) RETURN_ERROR
                if(!MarkArray2[1]) RETURN_ERROR
                if(!MarkArray2[6]) RETURN_ERROR
           }
           if(   C==pComponent->vertexNames[0]
              || D==pComponent->vertexNames[0]
              || H==pComponent->vertexNames[0]
              || I==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=4) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[2]) RETURN_ERROR
                if(!MarkArray2[3]) RETURN_ERROR
                if(!MarkArray2[7]) RETURN_ERROR
                if(!MarkArray2[8]) RETURN_ERROR
           }
           if(   E==pComponent->vertexNames[0]
              || F==pComponent->vertexNames[0]
           ) {
                if(pComponent->numVertices!=2) RETURN_ERROR
                memset(MarkArray2,0,NUM_VTX);
                for(j=0;j<pComponent->numVertices;j++) for(k=0;k<NUM_VTX;k++)
                    if(pComponent->vertexNames[j]==VertexArray[k]) {
                        MarkArray[k]=1;
                        MarkArray2[k]=1;
                    }
                if(!MarkArray2[4]) RETURN_ERROR
                if(!MarkArray2[5]) RETURN_ERROR
           }
        }
        for(i=0;i<NUM_VTX;i++) if(!MarkArray[i]) RETURN_ERROR

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        RETURN_ERROR
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return 0;
}


int
TestNxNIntoRing(Value)
//
// Create an nxn graph and turn it into a ring
//
{


    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX   *VertexArray = NULL;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesToRemove = NULL;
    ULONG          cEdgesToRemove = 0;
    DWORD          ErrorCode;
    
    ULONG         i, j;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {

        //
        // Make a graph
        //
        Graph         = ToplGraphCreate();

        //
        // Insert the vertices
        //
        VertexArray = (TOPL_VERTEX*)malloc(NumberOfVertices * sizeof(TOPL_VERTEX));
        if (!VertexArray) {
            Output(("Out of memory.\n"));
            ret = !0;
            __leave;
        }

        for (i = 0; i < NumberOfVertices; i++) {
            VertexArray[i] = ToplVertexCreate();

            //
            // Really, we should verify that each rand() is unique for
            // for this graph, too.
            //
            ToplVertexSetId(VertexArray[i], rand());
            ToplGraphAddVertex(Graph, VertexArray[i], VertexArray[i]);
        }

        //
        // Add the edges, to make an NxN graph
        //
        for (i = 0; i < NumberOfVertices; i++) {
            for (j = 0; j < NumberOfVertices; j++) {
                if (i != j) {
                    Edge = ToplEdgeCreate();
                    ToplEdgeSetFromVertex(Edge, VertexArray[i]);
                    ToplEdgeSetToVertex(Edge, VertexArray[j]);
                    ToplEdgeAssociate(Edge);
                }
            }
        }

        Output(("Here is the NxN graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make a ring and remove the edges
        //

        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, 
                          TOPL_RING_TWO_WAY, 
                          EdgesToAdd, 
                          &EdgesToRemove, 
                          &cEdgesToRemove);

        //
        // Remove the edges
        //
        for (i = 0; i < cEdgesToRemove; i++) {
            ToplEdgeDisassociate(EdgesToRemove[i]);
        }
        if (EdgesToRemove) {
            ToplFree(EdgesToRemove);
        }

        //
        // There should be no edges to add
        //
        ASSERT(ToplListRemoveElem(EdgesToAdd, NULL) == NULL);
        ToplListFree(EdgesToAdd, FALSE);

        Output(("Here is the ring graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;
}

int
TestRing(int Value)
//
//  This routine makes a one-way ring from a graph with no vertices
//  then a two-ring, then a one-way ring
// 
{

    TOPL_GRAPH     Graph = NULL;
    TOPL_VERTEX    Vertex;
    TOPL_EDGE      Edge = NULL;
    TOPL_LIST      EdgesToAdd = NULL;
    TOPL_ITERATOR  EdgeIterator = NULL;
    TOPL_EDGE      *EdgesToRemove = NULL;
    ULONG          cEdgesToRemove = 0;
    DWORD          ErrorCode;
    
    ULONG         i;
    int           ret = 0;
    ULONG         NumberOfVertices = Value;

    srand( (unsigned)time( NULL ) );


    __try {
    __try {


        //
        // Create the graph and vertices to into the graph
        //
        Graph         = ToplGraphCreate();

        for (i = 0; i < NumberOfVertices; i++) {
            Vertex = ToplVertexCreate();
            ToplVertexSetId(Vertex, rand());
            ToplGraphAddVertex(Graph, Vertex, Vertex);
        }

        //
        // Create the list to hold the edges to add
        //
        EdgesToAdd    = ToplListCreate();

        //
        // Make a one-way ring
        //
        ToplGraphMakeRing(Graph, TOPL_RING_ONE_WAY, EdgesToAdd, NULL, NULL);

        //
        // Add the edges to the graph so we can print it out
        //
        while (Edge = ToplListRemoveElem(EdgesToAdd, NULL)) {
            ToplEdgeAssociate(Edge);
        }
        ToplListFree(EdgesToAdd, FALSE);
        EdgesToAdd = NULL;


        Output(("First graph ...\n"));
        PrintGraph(Graph);

        //
        // Now find the edges to make the graph a two-way ring
        //
        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, TOPL_RING_TWO_WAY, EdgesToAdd, NULL, NULL);

        while (Edge = ToplListRemoveElem(EdgesToAdd, NULL)) {
            ToplEdgeAssociate(Edge);
        }
        ToplListFree(EdgesToAdd, FALSE);
        EdgesToAdd = NULL;

        Output(("Second graph ...\n"));
        PrintGraph(Graph);

        //
        // Now make the graph a one way ring and remove the edges
        //
        EdgesToAdd = ToplListCreate();

        ToplGraphMakeRing(Graph, 
                          TOPL_RING_ONE_WAY, 
                          EdgesToAdd, 
                          &EdgesToRemove, 
                          &cEdgesToRemove);

        //
        // Remove the edges
        //
        for (i = 0; i < cEdgesToRemove; i++) {
            ToplEdgeDisassociate(EdgesToRemove[i]);
        }

        Output(("Third graph ...\n"));
        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);

        if (EdgesToRemove) {
            ToplFree(EdgesToRemove);
        }

        if (EdgesToAdd) {
            ToplListFree(EdgesToAdd, FALSE);
        }

    }

    return ret;

}

int
CreateAndPrintSimpleGraph()
//
// This function creates a number of vertices and edges and then 
// prints them out. Tests base functionality.
//
{
    TOPL_GRAPH    Graph = NULL;

    #define NUMBER_OF_VERTICES 100
    TOPL_VERTEX   VertexArray[NUMBER_OF_VERTICES];
    TOPL_EDGE     EdgeArray[NUMBER_OF_VERTICES*2];
    DWORD         ErrorCode;

    ULONG         VertexCount, EdgeCount;
    int           ret = 0;

    memset(VertexArray, 0, sizeof(VertexArray));
    memset(EdgeArray, 0, sizeof(EdgeArray));

    __try {
    __try {

        Graph = ToplGraphCreate();
    
        for (VertexCount = 0; 
                VertexCount < NELEMENTS(VertexArray);
                    VertexCount++) {

            VertexArray[VertexCount] = ToplVertexCreate();
            ToplVertexSetId(VertexArray[VertexCount], VertexCount);

            ToplGraphAddVertex(Graph, VertexArray[VertexCount], VertexArray[VertexCount]);

        }


        for (EdgeCount = 0, VertexCount = 0; 
                EdgeCount < (NELEMENTS(EdgeArray) - 1);
                    EdgeCount += 2, VertexCount++) {

            ULONG ForwardVertexIndex, BackwardVertexIndex;

            EdgeArray[EdgeCount] = ToplEdgeCreate();
            EdgeArray[EdgeCount+1] = ToplEdgeCreate();

            ForwardVertexIndex = VertexCount + 1;
            BackwardVertexIndex = VertexCount - 1;
            if (VertexCount == 0) {
                BackwardVertexIndex =  NELEMENTS(VertexArray) - 1;
            }
            if (VertexCount == NELEMENTS(VertexArray) - 1) {
                ForwardVertexIndex =  0;
            } 

            ToplEdgeSetFromVertex(EdgeArray[EdgeCount], VertexArray[VertexCount]);
            ToplEdgeSetToVertex(EdgeArray[EdgeCount], VertexArray[BackwardVertexIndex]);
            ToplEdgeAssociate(EdgeArray[EdgeCount]);

            ToplEdgeSetFromVertex(EdgeArray[EdgeCount+1], VertexArray[VertexCount]);
            ToplEdgeSetToVertex(EdgeArray[EdgeCount+1], VertexArray[ForwardVertexIndex]);
            ToplEdgeAssociate(EdgeArray[EdgeCount+1]);

        }

        PrintGraph(Graph);

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
        ret = !0;
    }
    }
    __finally
    {
        // Release memory resources
        ToplGraphFree(Graph, TRUE);
    }

    return ret;

}

void 
PrintGraph(TOPL_GRAPH Graph)
{
    DWORD ErrorCode;
    TOPL_ITERATOR VertexIter = NULL;
    TOPL_VERTEX   Vertex;
    TOPL_EDGE     Edge;
    ULONG         EdgeIndex;

    __try 
    {
    __try
    {

        VertexIter = ToplIterCreate();
    
        for (Vertex = NULL, ToplGraphSetVertexIter(Graph, VertexIter);
                (Vertex = ToplIterGetObject(VertexIter)) != NULL;
                    ToplIterAdvance(VertexIter)) {


            Output(("Vertex %d:\n", ToplVertexGetId(Vertex)));

            for (EdgeIndex = 0; 
                    EdgeIndex < ToplVertexNumberOfOutEdges(Vertex); 
                        EdgeIndex++) {

                Edge = ToplVertexGetOutEdge(Vertex, EdgeIndex);

                Output(("Edge (%d -> %d)\n", ToplVertexGetId((ToplEdgeGetFromVertex(Edge))),
                                            ToplVertexGetId((ToplEdgeGetToVertex(Edge)))));
            }
        }

    }
    __except( ToplIsToplException( (ErrorCode=GetExceptionCode()) ) )
    {
        HandleToplException(ErrorCode);
    }
    }
    __finally 
    {
        if (VertexIter) {
            ToplIterFree(VertexIter);
        }
    }

}

void
Usage(char *name)
{
    fprintf(stderr, "Usage: %s <options>\n\n", name);
    fprintf(stderr, "This executable returns 0 on success; !0 otherwise\n\n");
    fprintf(stderr, "/?      : this message\n");
    fprintf(stderr, "/a      : tests the api set\n");
    fprintf(stderr, "/c:<n>  : complex ring test with n vertices\n");
    fprintf(stderr, "/e      : test exception handling\n");
    fprintf(stderr, "/m:<n> : minimum spanning tree test. (Try n>0 and n<0).\n");
    fprintf(stderr, "/o      : new heap test\n");
    fprintf(stderr, "/p      : new spanning tree algorithm test\n");
    fprintf(stderr, "/q      : schedule manager test\n");
    fprintf(stderr, "/r:<n>  : simple ring test with n vertices\n");
    fprintf(stderr, "/s      : simple manipulation test\n");
    fprintf(stderr, "/t      : old heap test\n");
    fprintf(stderr, "/u      : test components\n");
    fprintf(stderr, "/v      : sets the verbose mode for options set after\n");


    return;
}

int 
__cdecl main(int argc, char *argv[])
{
    int count, index;
    int ret;

    if ( argc < 2) {
        Usage(argv[0]);
        exit(!0);
    }

    //
    // Loop through parameters
    //

    count = 1; // skip the program name
    while (count < argc) {

        index = 0;
        if (argv[count][index] != '/' && argv[count][index] != '-') {
            Usage(argv[0]);
            exit(!0);
        }
        index++;

        argv[count][index] = (CHAR)tolower(argv[count][index]);

        switch (argv[count][index]) {

            case 'a':

                ret = TestAPI();
                if (ret) {
                    printf("API Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("API Test: PASSED\n");
                }
                    
                count++;
                break;

            case 'e':

                ret = TestExceptions();
                if (ret) {
                    printf("Exception Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("Exception Test: PASSED\n");
                }
                    
                count++;
                break;


            case 's':

                ret = CreateAndPrintSimpleGraph();
                if (ret) {
                    printf("Simple Test: FAILED\n");
                    exit(!0);
                } else {
                    printf("Simple Test: PASSED\n");
                }
                    
                count++;
                break;

            case 'r':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));
                    if (Value < 0 ) {
                        printf("Number of vertices must be positive\n");
                    }

                    ret = TestRing(Value);
                    if (ret) {
                        printf("Simple Ring Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Simple Ring Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;


            case 'c':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));
                    if (Value < 0 ) {
                        printf("Number of vertices must be positive\n");
                        exit(!0);
                    }

                    ret = TestNxNIntoRing(Value);
                    if (ret) {
                        printf("Complex Ring Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Complex Ring Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'm':

                {
                    int Value;
                    index++;
    
                    if (argv[count][index] == ':') {
                        index++;
                    }
    
                    Value = atoi(&(argv[count][index]));

                    if ( Value < 0 )
                    {
                        ret = TestExampleMST();
                    }
                    else 
                    {
                        ret = TestNxNMST(Value);

                    }

                    if (ret) {
                        printf("Minimum Spanning Tree Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Minimum Spanning Tree Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 't':

                {
                    ret = TestHeap();

                    if (ret) {
                        printf("Heap Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Heap Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'o':
                {
                    ret = TestNewHeap();

                    if (ret) {
                        printf("New Heap Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("New Heap Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'p':
                {
                    ret = TestNewSpanTree();

                    if (ret) {
                        printf("New Spanning Tree Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("New Spanning Tree Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'q':
                {
                    ret = TestSched();

                    if (ret) {
                        printf("Schedule Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Schedule Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;
            
            case 'u':
                {
                    ret = TestComponents();
                    if (ret) {
                        printf("Components Test: FAILED\n");
                        exit(!0);
                    } else {
                        printf("Components Test: PASSED\n");
                    }
                        
                    count++;
                }
                break;

            case 'v':

                fVerbose = TRUE;
                count++;
                break;

            default:

                Usage(argv[0]);
                exit(!0);
        }

    }

    printf("%s PASSED\n", argv[0]);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\exe\schedtest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include <stdio.h>
#include <stdlib.h>


/********************************************************************************
 Schedule Manager Tests:

 Test 1: Create and destroy a cache
 Test 2: Pass a NULL pointer to the destroy cache function
 Test 3: Insert one schedule into cache, retrieve it, and see if its the same
 Test 4: Insert two copies of same schedule, see if exported schedules are same
 Test 5: Insert two copies of same schedule, see if memory is shared
 Test 6: Pass null and caches, null and invalid schedules to ToplScheduleExportReadonly()
 Test 7: Pass unsupported schedules and invalid cache to ToplScheduleImport()
 Test 8: Load same schedule into cache 100000 times to ensure schedules are shared
 Test 9: Load 10000 different schedules into cache 10 times each, then check
         that the schedules are correct and the number of unique schedules is also correct
 Test 10: Use ToplScheduleIsEqual() function to ensure schedules are equal
 Test 11: Test ToplScheduleNumEntries
 Test 12: Test various invalid parameters to ToplScheduleIsEqual()
 Test 13: Test ToplScheduleDuration()  (with a manually created schedule)
 Test 14: ToplScheduleMerge() test -- typical schedules
 Test 15: ToplScheduleMerge() test -- non-intersecting schedules returns NULL
 Test 16: ToplScheduleMaxUnavailable() test
 
 ********************************************************************************/


/***** AcceptNullPointer *****/
LONG AcceptNullPointer( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_NULL_POINTER )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** AcceptCacheError *****/
LONG AcceptCacheError( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_CACHE_ERROR )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** AcceptScheduleError *****/
LONG AcceptScheduleError( PEXCEPTION_POINTERS pep )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==TOPL_EX_SCHEDULE_ERROR )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}


/***** Error *****/
#define TEST_ERROR Error(__LINE__);
static void Error(int lineNum) {
    printf("Error on line %d\n",lineNum);
    exit(-1);
}


/***** EqualPschedule *****/
char EqualPschedule( PSCHEDULE p1, PSCHEDULE p2 )
{
    if(0==memcmp(p1,p2,sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES))
        return 1;
    return 0;
}

#define NUM_UNIQ    10000
#define NUM_SCHED    100000
PSCHEDULE  uniqSched[NUM_UNIQ];
TOPL_SCHEDULE toplSched[NUM_SCHED];

/***** TestSched *****/
int
TestSched( VOID )
{
    TOPL_SCHEDULE_CACHE cache;
    PSCHEDULE  psched1, psched2;
    unsigned char* dataPtr;
    int i,j,cbSched,numSched=0;


    __try {

        /* Test 1 */
        cache = ToplScheduleCacheCreate();
        ToplScheduleCacheDestroy( cache );
        printf("Test 1 passed\n");

        /* Test 2 */
        __try {
            ToplScheduleCacheDestroy( NULL );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleCacheDestroy( cache );
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        printf("Test 2 passed\n");

        /* First create a whole pile of random, hopefully unique, schedules */
        cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
        for(i=0;i<NUM_UNIQ;i++) {
            uniqSched[i] = (PSCHEDULE) malloc(cbSched);
            uniqSched[i]->Size = cbSched;
            uniqSched[i]->NumberOfSchedules = 1;
            uniqSched[i]->Schedules[0].Type = SCHEDULE_INTERVAL;
            uniqSched[i]->Schedules[0].Offset = sizeof(SCHEDULE);
            dataPtr = ((unsigned char*) uniqSched[i]) + sizeof(SCHEDULE);
            for(j=0;j<SCHEDULE_DATA_ENTRIES;j++)
                dataPtr[j] = rand()%16;
        }

        /* Test 3 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[0] );
        psched1 = ToplScheduleExportReadonly( cache, toplSched[0] );
        if( ! EqualPschedule(uniqSched[0],psched1) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 3 passed\n");

        /* Test 4 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[1] );
        toplSched[1] = ToplScheduleImport( cache, uniqSched[1] );
        psched1 = ToplScheduleExportReadonly( cache, toplSched[0] );
        psched2 = ToplScheduleExportReadonly( cache, toplSched[1] );
        if( ! EqualPschedule(psched1,psched2) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 4 passed\n");

        /* Test 5 */
        cache = ToplScheduleCacheCreate();
        toplSched[0] = ToplScheduleImport( cache, uniqSched[2] );
        toplSched[1] = ToplScheduleImport( cache, uniqSched[2] );
        if( toplSched[0] != toplSched[1] )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 5 passed\n");

        /* Test 6 */
        __try {
            ToplScheduleExportReadonly( NULL, toplSched[1] );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        __try {
            ToplScheduleExportReadonly( cache, NULL );
        } __except( EXCEPTION_EXECUTE_HANDLER )
        {
            return -1;
        }
        __try {
            ToplScheduleExportReadonly( cache, cache );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        ToplScheduleCacheDestroy( cache );
        printf("Test 6 passed\n");

        /* Test 7 */
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleImport( NULL, uniqSched[0] );
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        uniqSched[0]->Size--;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Size = cbSched;
        uniqSched[0]->NumberOfSchedules = 2;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->NumberOfSchedules = 1;
        uniqSched[0]->Schedules[0].Type = SCHEDULE_BANDWIDTH;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Schedules[0].Type = SCHEDULE_INTERVAL;
        uniqSched[0]->Schedules[0].Offset++;
        __try {
            ToplScheduleImport( cache, uniqSched[0] );
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        uniqSched[0]->Schedules[0].Offset--;
        if( 0 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 7 passed\n");


        /* Test 8 */
        cache = ToplScheduleCacheCreate();
        for( i=0; i<NUM_SCHED; i++) {
            ToplScheduleImport(cache,uniqSched[3]);
        }
        if( 1 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 8 passed\n");

        /* Test 9 */
        cache = ToplScheduleCacheCreate();
        numSched=0;
        for(j=0;j<10;j++) {
            for(i=0;i<NUM_UNIQ;i++) {
                toplSched[numSched++] = ToplScheduleImport( cache, uniqSched[i] );
            }
        }
        for(i=0;i<10*NUM_UNIQ;i++) {
            psched1 = ToplScheduleExportReadonly( cache, toplSched[i] );
            if( ! EqualPschedule(uniqSched[i%NUM_UNIQ],psched1) )
                return -1;
        }
        if( NUM_UNIQ != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 9 passed\n");

        /* Test 10 */
        cache = ToplScheduleCacheCreate();
        for(i=0;i<NUM_UNIQ;i++) {
            toplSched[0] = ToplScheduleImport(cache,uniqSched[i]);
            for(j=0;j<10;j++) {
                toplSched[1] = ToplScheduleImport( cache, uniqSched[i] );
                if( ! ToplScheduleIsEqual(cache,toplSched[0],toplSched[1]) )
                    return -1;
            }
        }
        ToplScheduleCacheDestroy( cache );
        printf("Test 10 passed\n");

        /* Test 11 */
        __try {
            ToplScheduleNumEntries(cache);
            return -1;
        } __except( AcceptCacheError(GetExceptionInformation()) )
        {}
        __try {
            ToplScheduleNumEntries(NULL);
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        cache = ToplScheduleCacheCreate();
        if( 0 != ToplScheduleNumEntries(cache) )
            return -1;
        ToplScheduleCacheDestroy( cache );
        printf("Test 11 passed\n");

        /* Test 12 */
        cache = ToplScheduleCacheCreate();
        __try {
            /* Stale schedules from previous cache */
            ToplScheduleIsEqual(cache,toplSched[0],toplSched[0]);
            return -1;
        } __except( AcceptScheduleError(GetExceptionInformation()) )
        {}
        toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
        __try {
            /* Stale schedules from previous cache */
            ToplScheduleIsEqual(NULL,toplSched[0],toplSched[0]);
            return -1;
        } __except( AcceptNullPointer(GetExceptionInformation()) )
        {}
        if( ToplScheduleIsEqual(cache,NULL,NULL) != TRUE ) {
            return -1;
        }
        ToplScheduleCacheDestroy( cache );
        printf("Test 12 passed\n");

        /* Test 13 */
        {
            char data[] = { 0x08, 0x03, 0x04, 0x00, 0x01, 0x0F, 0x00,
                0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
            /* Number of 15-minute chunks should be:
                               1 +   2 +   1  +  0 +   1 +   4 + 0
               + 1    +  1   + 2  + 1  +  2  +   2  +  3  + 1  + 2
               + 2    +  3   + 2  + 3   +  3  + 4  =  9+15+17 = 41
               So that should be 615 minutes */
            int dur1, dur2;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data, sizeof(data) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            dur1 = ToplScheduleDuration(toplSched[0]);
            dur2 = ToplScheduleDuration(NULL);
            if( dur1!=615 || dur2!=10080 )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 13 passed\n");

        /* Test 14 */
        {
            char data1[] = {
                0xDF, 0xE1, 0xAE, 0xD2, 0xBD, 0xE3, 0xEC, 0xF4 };
            char data2[] = {
                0x0A, 0x16, 0x29, 0x37, 0x48, 0x58, 0x6B, 0x75 };
            char data3[] = {
                0xDA, 0xE0, 0xA8, 0xD2, 0xB8, 0xE0, 0xE8, 0xF4 };
            char fIsNever;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            toplSched[2] = ToplScheduleMerge(cache,toplSched[0],toplSched[1],&fIsNever);
            if(fIsNever)
                return -1;
            psched1 = ToplScheduleExportReadonly(cache,toplSched[2]);
            dataPtr = ((unsigned char*) psched1) + sizeof(SCHEDULE);
            if( 0!=memcmp(data3,dataPtr,sizeof(data3)) )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 14 passed\n");

        /* Test 15 */
        {
            char data1[] = {
                0xDF, 0xE1, 0xAE, 0xD2, 0xBD, 0xE3, 0xEC, 0xF4 };
            char data2[] = {
                0x00, 0x1E, 0x20, 0x3C, 0x42, 0x50, 0x63, 0x7B };
            char fIsNever;
            cache = ToplScheduleCacheCreate();
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            toplSched[2] = ToplScheduleMerge(cache,toplSched[0],toplSched[1],&fIsNever);
            if( !fIsNever )
                return -1;
            if( NULL==toplSched[2] )
                return -1;
            if( 3 != ToplScheduleNumEntries(cache) )
                return -1;
            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 15 passed\n");

        /* Test 16 */
        {
            char data1[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data2[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15, 0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data3[] = {
                 0,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 0,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15, 0 };
            char data4[] = {
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15 };
            char data5[] = {
                01,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15, 9,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00 };
            char data6[] = {
                 8,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15, 9,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15, 7,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
                15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,00 };
            char data7[] = {
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
            DWORD uLen;
            cache = ToplScheduleCacheCreate();

            // Schedule 0
            dataPtr = ((unsigned char*) uniqSched[0]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            toplSched[0] = ToplScheduleImport(cache,uniqSched[0]);
            uLen = ToplScheduleMaxUnavailable(toplSched[0]);
            if( 60*24*7!=uLen ) TEST_ERROR;

            // Schedule 1
            dataPtr = ((unsigned char*) uniqSched[1]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data1, sizeof(data1) ); 
            toplSched[1] = ToplScheduleImport(cache,uniqSched[1]);
            uLen = ToplScheduleMaxUnavailable(toplSched[1]);
            if( 0!=uLen ) TEST_ERROR;

            // Schedule 2
            dataPtr = ((unsigned char*) uniqSched[2]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data2, sizeof(data2) ); 
            toplSched[2] = ToplScheduleImport(cache,uniqSched[2]);
            uLen = ToplScheduleMaxUnavailable(toplSched[2]);
            if( 60!=uLen ) TEST_ERROR;

            // Schedule 3
            dataPtr = ((unsigned char*) uniqSched[3]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data3, sizeof(data3) ); 
            toplSched[3] = ToplScheduleImport(cache,uniqSched[3]);
            uLen = ToplScheduleMaxUnavailable(toplSched[3]);
            if(120!=uLen ) TEST_ERROR;

            // Schedule 4
            dataPtr = ((unsigned char*) uniqSched[4]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data4, sizeof(data4) ); 
            toplSched[4] = ToplScheduleImport(cache,uniqSched[4]);
            uLen = ToplScheduleMaxUnavailable(toplSched[4]);
            if( 15!=uLen ) TEST_ERROR;

            // Schedule 5
            dataPtr = ((unsigned char*) uniqSched[5]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data5, sizeof(data5) ); 
            toplSched[5] = ToplScheduleImport(cache,uniqSched[5]);
            uLen = ToplScheduleMaxUnavailable(toplSched[5]);
            if( 60!=uLen ) TEST_ERROR;

            // Schedule 6
            dataPtr = ((unsigned char*) uniqSched[6]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data6, sizeof(data6) ); 
            toplSched[6] = ToplScheduleImport(cache,uniqSched[6]);
            uLen = ToplScheduleMaxUnavailable(toplSched[6]);
            if(105!=uLen ) TEST_ERROR;

            // Schedule 7
            dataPtr = ((unsigned char*) uniqSched[7]) + sizeof(SCHEDULE);
            memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
            memcpy( dataPtr, data7, sizeof(data7) ); 
            toplSched[7] = ToplScheduleImport(cache,uniqSched[7]);
            uLen = ToplScheduleMaxUnavailable(toplSched[7]);
            if(45!=uLen ) TEST_ERROR;

            ToplScheduleCacheDestroy( cache );
        }
        printf("Test 16 passed\n");

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        /* Failure! */
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\exe\heaptest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "..\stheap.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/********************************************************************************
 Heap Stress:

 Randomly attack stheap.c. We mimick a heap using RTL's AVL tree. This begs
 the question: Why did we write stheap in the first place -- we could have just
 used RTL?

 ********************************************************************************/

typedef struct {
    int     d, uniq;
    int     locn;
} Node;

static int NodeCmp( Node* a, Node* b, void* v ) {
    if( a->d<b->d ) return -1;
    if( a->d>b->d ) return 1;
    return a->uniq-b->uniq;
}
static int GetLocn( Node* a, void* v ) { return a->locn; }
static void SetLocn( Node* a, int l, void* v ) { a->locn=l; }

/***** TableCmp *****/
RTL_GENERIC_COMPARE_RESULTS
NTAPI TableCmp( RTL_GENERIC_TABLE *Table, PVOID a, PVOID b ) {
    int r = NodeCmp( (Node*) a, (Node*) b, NULL );
    if(r<0) return GenericLessThan;
    if(r>0) return GenericGreaterThan;
    return GenericEqual;
}

/***** TableAlloc *****/
PVOID
NTAPI TableAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize ) {
    return malloc( ByteSize );
}

/***** TableFree *****/
VOID
NTAPI TableFree( RTL_GENERIC_TABLE *Table, PVOID Buffer ) {
    free( Buffer );
}

#define Rand(x) (((rand()<<16)|(rand()&0xFFFF))%x)
#define Error   { DebugBreak(); return -1; }

#define NOPRINT

/***** TestRandHeap *****/
int TestRandHeap( int size )
{
    RTL_GENERIC_TABLE table;
    PSTHEAP heap;
    Node *nodes, temp, *n, *n2;
    BOOLEAN newElement;
    int i, j, next, r, r2, r3, beta, nextAdd, nextRemove;

    /* Create a randomized permutation of {0,..,size-1} */
    nodes = (Node*) malloc( size*sizeof(Node) );
    for( i=0; i<size; i++) {
        nodes[i].d=i+1000000;
        nodes[i].uniq=i;
        nodes[i].locn=STHEAP_NOT_IN_HEAP;
    }
    for( i=0; i<size-1; i++ ) {
        j=i+Rand(size-i);
        memcpy(&temp,&nodes[i],sizeof(Node));
        memcpy(&nodes[i],&nodes[j],sizeof(Node));
        memcpy(&nodes[j],&temp,sizeof(Node));
    }
    heap = ToplSTHeapInit( size, NodeCmp, GetLocn, SetLocn, NULL );
    RtlInitializeGenericTable( &table, TableCmp, TableAlloc, TableFree, NULL );

    /* Try inserting an element, then removing an element with probability beta */
    for( beta=0; beta<500; beta+=50 ) {
        #ifndef NOPRINT
            printf("add/remove test: beta=%d\n",beta);
        #endif
        nextAdd=nextRemove=0;
        while( nextRemove<size ) {
            r=Rand(1000);
            if( (nextAdd==nextRemove||r>beta) && (nextAdd<size) ) {
                ToplSTHeapAdd( heap, &nodes[nextAdd] );
                RtlInsertElementGenericTable(&table,&nodes[nextAdd],sizeof(Node),&newElement);
                if(!newElement) {
                    printf("Err: element already in table\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d add=%d\n",r,nodes[nextAdd].d);
                #endif
                nextAdd++;
            }
            else if( nextAdd==size || r<=beta ) {
                n=ToplSTHeapExtractMin(heap);
                n2=(Node*) RtlEnumerateGenericTable(&table,TRUE);
                if(n==NULL||n2==NULL) {
                    printf("Err: got null pointer\n");
                    Error;
                }
                if(n->locn!=STHEAP_NOT_IN_HEAP) {
                    printf("Err: location value not reset\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d remove=%d %d\n",r,n->d,n2->d);
                #endif
                if(n->d!=n2->d) {
                    printf("Err: heap doesn't match AVL (beta=%d)\n", beta);
                    Error;
                }
                nextRemove++;
                RtlDeleteElementGenericTable( &table, n2 );
            }
        }
        if(ToplSTHeapExtractMin(heap)!=NULL) {
            printf("Err: heap not fully emptied\n");
            Error
        }
    }

    /* Try inserting an element, then decreasing the key with probability beta */
    for( beta=0; beta<500; beta+=50 ) {
        #ifndef NOPRINT
            printf("decrease key test: beta=%d\n",beta);
        #endif
        nextAdd=0;
        for(i=0;i<size;) {
            r=Rand(1000); 
            if( r>beta && nextAdd<size ) {
                ToplSTHeapAdd( heap, &nodes[nextAdd] );
                RtlInsertElementGenericTable(&table,&nodes[nextAdd],sizeof(Node),&newElement);
                if(!newElement) {
                    printf("Err: element already in table\n");
                    Error;
                }
                #ifndef NOPRINT
                    printf("%4d add=%d\n",r,nodes[nextAdd].d);
                #endif
                nextAdd++;
            } else {
                if( nextAdd>0 ) {
                    /* Decrease key */
                    r2=Rand(nextAdd);       /* How much to decrease key by */
                    r3=Rand(nextAdd);       /* Which key */
                    #ifndef NOPRINT
                        printf("%4d reduce key %d by %d\n",r,r3,r2);
                    #endif
                    if( RtlDeleteElementGenericTable(&table, &nodes[r3])==FALSE ) {
                        printf("Err: Couldn't delete from RTL\n");
                        Error;
                    }
                    nodes[r3].d-=r2;
                    RtlInsertElementGenericTable(&table,&nodes[r3],sizeof(Node),&newElement);
                    if(!newElement) {
                        printf("Err: element already in table\n");
                        Error;
                    }
                    ToplSTHeapCostReduced(heap,&nodes[r3]);
                }
            }
            if( nextAdd==size ) i++;
        }
        /* Remove elements */
        for(i=0;i<size;i++) {
            n=ToplSTHeapExtractMin(heap);
            n2=(Node*) RtlEnumerateGenericTable(&table,TRUE);
            if(n==NULL||n2==NULL) {
                printf("Err: got null pointer\n");
                Error;
            }
            if(n->locn!=STHEAP_NOT_IN_HEAP) {
                printf("Err: location value not reset\n");
                Error;
            }
            #ifndef NOPRINT
                printf("%4d remove=%d %d\n",r,n->d,n2->d);
            #endif
            if(n->d!=n2->d || n->uniq!=n2->uniq) {
                printf("Err: heap doesn't match AVL (beta=%d)\n", beta);
                Error;
            }
            RtlDeleteElementGenericTable( &table, n2 );
        }
        if(ToplSTHeapExtractMin(heap)!=NULL) {
            printf("Err: heap not fully emptied\n");
            Error
        }
    }

    ToplSTHeapDestroy( heap );
    free( nodes );
    return 0;
}

/***** TestNewHeap *****/
int TestNewHeap( void )
{
    unsigned seed;


    seed = (unsigned) time(NULL);
    srand(seed);
    printf("Starting heap stress... seed=%d\n",seed);

    __try {
        int  i, j;

        if(TestRandHeap(1)) return -1;
        for( i=3; i<=10; i++) {
            printf("Testing a heap with %d entries\n",i);
            for(j=0;j<40*i;j++) {
                if(TestRandHeap(i)) {
                    printf("Iteration %d failed\n",j);
                    return -1;
                }
            }
        }
        for( i=10; i<=200000; i=(int)(((float)i)*1.5) ) {
            printf("Testing a heap with %d entries\n",i);
            for(j=0;j<100;j++) {
                if(TestRandHeap(i)) {
                    printf("Iteration %d failed\n",j);
                    return -1;
                }
            }
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\exe\apitest.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    This file contains a function that methodically tests every api in 
    w32topl
    
Author:

    Colin Brace    (ColinBr)
    
Revision History

    3-12-97   ColinBr   Created
    
                       
--*/

#include <nt.h>
#include <ntrtl.h>

typedef unsigned long DWORD;

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <w32topl.h>

//
// Small utilities
//
extern BOOLEAN fVerbose;

#define Output(x)          if (fVerbose) printf x;
#define NELEMENTS(x)        (sizeof(x)/sizeof(x[0]))


int
TestAPI(
    VOID
    )
//
// This function methodically calls every api in w32topl.dll
// 0 is returned on success; !0 otherwise
//
{
    int               ret;
    DWORD             ErrorCode;
    TOPL_LIST         List = NULL;
    TOPL_ITERATOR     Iter = NULL;
    TOPL_EDGE         Edge = NULL;
    TOPL_VERTEX       Vertex = NULL, Vertex2 = NULL;
    TOPL_GRAPH        Graph = NULL;
    TOPL_LIST_ELEMENT Elem = NULL;
    

    __try
    {
        //
        // First list and iterator routines
        //
        List  =  ToplListCreate();
        Edge  =  ToplEdgeCreate();
        Vertex = ToplVertexCreate();
    
        if (ToplListNumberOfElements(List) != 0) {
            Output(("ToplList api broken\n"));
            return !0;
        }
    
        ToplListAddElem(List, Edge);
        ToplListAddElem(List, Vertex);
    
        if (ToplListNumberOfElements(List) != 2) {
            Output(("ToplList api broken\n"));
            return !0;
        }
        //
        // Iterator routines
        //
        Iter = ToplIterCreate();
    
        ToplListSetIter(List, Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem != Vertex && Elem != Edge) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
        ToplIterAdvance(Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem != Vertex && Elem != Edge) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
    
        ToplIterAdvance(Iter);
    
        Elem = ToplIterGetObject(Iter);
        if (Elem) {
            Output(("ToplIterGetObject failed\n"));
            return !0;
        }
    
        ToplIterFree(Iter);
    
        //
        // Iterator is done, continue with list routines
        //
        if (Edge != ToplListRemoveElem(List, Edge)) {
            Output(("ToplListRemove failed\n"));
            return !0;
        }
    
        //
        // There is only one element left now
        //
        if (Vertex != ToplListRemoveElem(List, NULL)) {
            Output(("ToplListRemove failed\n"));
            return !0;
        }
    

        //
        // Test the non-recursive delete
        //
        ToplListFree(List, FALSE);
    
        //
        // Test the recursive delete
        //
        List = ToplListCreate();
    
        ToplListAddElem(List, Edge);
        ToplListAddElem(List, Vertex);
    
        ToplListFree(List, TRUE);
    
        //
        // Now test the vertex and edge api
        //
        Edge     = ToplEdgeCreate();
        Vertex   = ToplVertexCreate();
        Vertex2  = ToplVertexCreate();
    
        ToplEdgeSetFromVertex(Edge, Vertex);
        if (Vertex != ToplEdgeGetFromVertex(Edge)) {
            Output(("ToplEdge api broken.\n"));
            return !0;
        }
    
        ToplEdgeSetToVertex(Edge, Vertex2);
        if (Vertex2 != ToplEdgeGetToVertex(Edge)) {
            Output(("ToplEdge api broken.\n"));
            return !0;
        }
    
        ToplVertexSetId(Vertex, 123);
        if (123 != ToplVertexGetId(Vertex)) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexNumberOfOutEdges(Vertex) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexNumberOfInEdges(Vertex2) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplEdgeAssociate(Edge);
    
        if (ToplVertexNumberOfOutEdges(Vertex) != 1) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexGetOutEdge(Vertex, 0) != Edge) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexNumberOfInEdges(Vertex2) != 1) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        if (ToplVertexGetInEdge(Vertex2, 0) != Edge) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplEdgeDisassociate(Edge);

        if (ToplVertexNumberOfOutEdges(Vertex) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplVertexNumberOfInEdges(Vertex2) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }

        ToplVertexFree(Vertex);
        ToplVertexFree(Vertex2);
        ToplEdgeFree(Edge);
    

        //
        // Edges and vertices done, move on to graph
        //
        Graph = ToplGraphCreate();
        Vertex = ToplVertexCreate();
    
    
        if (ToplGraphNumberOfVertices(Graph) != 0) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        ToplGraphAddVertex(Graph, Vertex, Vertex);
    
        if (ToplGraphNumberOfVertices(Graph) != 1) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        Iter = ToplIterCreate();
    
        ToplGraphSetVertexIter(Graph, Iter);
    
        if (Vertex != ToplIterGetObject(Iter)) {
            Output(("ToplGraph api broken.\n"));
            return !0;
        }
    
        ToplIterFree(Iter);
    
        if (Vertex != ToplGraphRemoveVertex(Graph, NULL)) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        if (ToplGraphNumberOfVertices(Graph) != 0) {
            Output(("ToplVertex api broken.\n"));
            return !0;
        }
    
        //
        // Test single free
        //
        ToplGraphFree(Graph, FALSE);
        ToplVertexFree(Vertex);
    
        //
        // Test recursive free
        //
        Graph = ToplGraphCreate();
        Vertex = ToplVertexCreate();

        ToplGraphAddVertex(Graph, Vertex, Vertex);
        ToplGraphFree(Graph, TRUE);
    
        //
        // ToplFree and ToplGraphMakeRing are tested more effectively
        // elsewhere
        //
        ret = 0;

    }
    __except( ToplIsToplException((ErrorCode=GetExceptionCode())) )
    {
        fprintf(stderr, "Topl exception 0x%x occured\n", ErrorCode);
        ret = !0;

    }

    return ret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\common\w32topl\exe\sttest.c ===
/***** Header Files *****/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <w32topl.h>
#include "w32toplp.h"
#include "..\stheap.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


/********************************************************************************
 Spanning-Tree Tests:

 Test 1: Try creating/deleting topl graph state many times. Can manually check
         for memory leaks.
 Test 2: Try adding a bunch of edges to a graph state one with a NULL vertex
         name. 
 Test 3: Try adding a bunch of edges to a graph state one with an invalid
         vertex name.
 Test 4: Try adding a bunch of edges to a graph state, one with an invalid
         number of vertices.
 Test 5: Try adding a bunch of edges to a graph state, one with an invalid
         edge type.
 Test 6: Create a graph state with a bunch of good edges. Try adding multi-edge
         sets and adding them to the graph state.
 Test 7: Create a small valid topology and build a spanning tree. See if the
         output edges are what we expect.
 Test 8: Create a small valid topology which uses lots of hyper-edges and a
         multi-edge. See if the output edge is what we expect.
 Test 9: Create a graph with no white vertices, a very large number of colored
         vertices, and one large hyper-edge connecting them. No edge set is
         used, since only one edge exists.
 Test 10: Test a graph with many edge sets.
 Test 11: Large Hub-spoke performance and accuracy test
 Test 12: Cost overflow testing by using a long chain. Also tests performance
          of deep shortest-path trees in Dijkstra. 
 Test 13: Test edge types and vertices' ability to deny certain types of edges
 Test 14: A very simple test which checks schedules, options and replication intervals
 Test 15: Longest schedule duration wins
 Test 16: Longest schedule duration wins 2; Self-loop test
 Test 17: Non-intersecting schedules along shortest path throws exception
 Test 18: Check for site-failover (routing through sites which don't accept edges)

 Please contact nickhar for some hand-drawn diagrams of these tests.

 ********************************************************************************/

int Test7( void );
int Test8( void );
int Test9( void );
int Test10( void );
int Test11( DWORD );
int Test12( DWORD );
int Test13( VOID );
int Test14( VOID );
int Test15( VOID );
int Test16( VOID );
int Test17( VOID );
int Test18( VOID );

/***** AcceptOnlyFunc *****/
static LONG AcceptOnlyFunc( PEXCEPTION_POINTERS pep, int code )
{
    EXCEPTION_RECORD *per=pep->ExceptionRecord;

    if( per->ExceptionCode==code )
        return EXCEPTION_EXECUTE_HANDLER;
    return EXCEPTION_CONTINUE_SEARCH;
}

#define AcceptOnly(x)       AcceptOnlyFunc(GetExceptionInformation(),x)

int __cdecl VtxNameCmpFunc( const VOID *aa, const VOID *bb )
{
    DWORD *a=*((DWORD**)aa), *b=*((DWORD**)bb);
    return *a-*b;
}

void Error() {
#ifdef DBG
    DebugBreak();
#endif
}

#define NUM_VTX     10000
#define NUM_EDGE    10000
#define NUM_EDGE_SET  100

/***** TestNewSpanTree *****/
int TestNewSpanTree( void )
{
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges;
    PTOPL_MULTI_EDGE_SET    *edgeSets;
    TOPL_REPL_INFO          ri;
    DWORD                   i, j, **names, dummy;

    printf("Starting spanning tree tests...\n");

    __try {
    
    names = (DWORD**) malloc( NUM_VTX * sizeof(DWORD*) );
    for( i=0; i<NUM_VTX; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }

    edges = (PTOPL_MULTI_EDGE*) malloc( NUM_EDGE * sizeof(PTOPL_MULTI_EDGE) );
    ri.cost = 100;
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;

    /* Test 1 */
    cache = ToplScheduleCacheCreate();
    for( i=0; i<100; i++ ) {
        g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
        ToplDeleteGraphState( g );
    }
    ToplScheduleCacheDestroy( cache );
    printf("Test 1 Passed\n");

    /* Test 2 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        ToplEdgeSetVtx( g, edges[NUM_EDGE-1], 0, NULL );
        return -1;
    } __except( AcceptOnly(TOPL_EX_NULL_POINTER) )
    {}
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 2 Passed\n");

    /* Test 3 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        ToplEdgeSetVtx( g, edges[NUM_EDGE-1], 1, &dummy );
        return -1;
    } __except( AcceptOnly(TOPL_EX_INVALID_VERTEX) )
    {}
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 3 Passed\n");

    /* Test 4 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 0, 0, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_TOO_FEW_VTX) )
    {}
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 1, 0, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_TOO_FEW_VTX) )
    {}
    edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 0, &ri );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 4 Passed\n");

    /* Test 5 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE-1; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    __try {
        edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 32, &ri );
        return -1;
    } __except( AcceptOnly(TOPL_EX_INVALID_EDGE_TYPE) )
    {}
    edges[NUM_EDGE-1] = ToplAddEdgeToGraph( g, 2, 31, &ri );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 5 Passed\n");

    /* Test 6 */
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, NUM_VTX, VtxNameCmpFunc, cache );
    for( j=0; j<NUM_EDGE; j++ ) {
        edges[j] = ToplAddEdgeToGraph( g, 2, 31, &ri );
        ToplEdgeSetVtx( g, edges[j], 0, names[j%NUM_VTX] );
        ToplEdgeSetVtx( g, edges[j], 1, names[(j+1)%NUM_VTX] );
    }
    edgeSets = (PTOPL_MULTI_EDGE_SET*) malloc( NUM_EDGE_SET*sizeof(PTOPL_MULTI_EDGE_SET));
    for(i=0;i<NUM_EDGE_SET;i++) {
        DWORD cnt;
        edgeSets[i] = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
        edgeSets[i]->numMultiEdges = cnt = (rand()%(NUM_EDGE/100)) + 2;
        edgeSets[i]->multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cnt*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cnt;j++) {
            edgeSets[i]->multiEdgeList[j] = edges[(j*cnt)%NUM_EDGE];
        }
        ToplAddEdgeSetToGraph( g, edgeSets[i] );
    }
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    for(i=0;i<NUM_EDGE_SET;i++)
        free( edgeSets[i] );
    free( edgeSets );
    printf("Test 6 Passed\n");


    if( Test7() ) return -1;
    if( Test8() ) return -1;
    if( Test9() ) return -1;
    if( Test10() ) return -1;
    if( Test11(100000) ) return -1;
    if( Test12(100000) ) return -1;
    if( Test13() ) return -1;
    if( Test14() ) return -1;
    if( Test15() ) return -1;
    if( Test16() ) return -1;
    if( Test17() ) return -1;
    if( Test18() ) return -1;

    printf("Now on to performance tests...\n");
    for(;;) {
        int size;
        printf("Enter size: ");
        scanf("%d",&size);
        if(size==0) break;
        if( Test11(size) ) return -1;
    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        printf("Caught unhandled exception\n");
        return -1;
    }

    return 0;
}


/***** VtxNameStructCmpFunc *****/
int __cdecl VtxNameStructCmpFunc( const VOID *aa, const VOID *bb )
{
    TOPL_NAME_STRUCT *a=(TOPL_NAME_STRUCT*)aa, *b=(TOPL_NAME_STRUCT*)bb;
    return VtxNameCmpFunc( &a->name, &b->name );
}

/***** EdgeExists *****/
char EdgeExists( PTOPL_MULTI_EDGE e, PTOPL_MULTI_EDGE *edgeList,
    DWORD cEdge, TOPL_SCHEDULE_CACHE cache )
{
    DWORD iEdge,iVtx;

    if( !e->fDirectedEdge ) {
        qsort( &e->vertexNames[0], e->numVertices, sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
    }
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        NextEdge:;
        if(edgeList[iEdge]->fDirectedEdge!=e->fDirectedEdge) continue;
        if(edgeList[iEdge]->numVertices!=e->numVertices) continue;
        if(edgeList[iEdge]->edgeType!=e->edgeType) continue;
        if(edgeList[iEdge]->ri.cost!=e->ri.cost) continue;
        if(edgeList[iEdge]->ri.repIntvl!=e->ri.repIntvl) continue;
        if(edgeList[iEdge]->ri.options!=e->ri.options) continue;
        if(!ToplScheduleIsEqual(cache,edgeList[iEdge]->ri.schedule,e->ri.schedule))
            continue;
        /* Match vertex names */
        if( !edgeList[iEdge]->fDirectedEdge ) {
            qsort( &edgeList[iEdge]->vertexNames[0], edgeList[iEdge]->numVertices,
                sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
        }
        for( iVtx=0; iVtx<e->numVertices; iVtx++ ) {
            if( VtxNameStructCmpFunc(
                    &e->vertexNames[iVtx],
                    &(edgeList[iEdge]->vertexNames[iVtx])
                ) != 0 )
            {
                goto NextEdge;
            }
        }
        return 1;
    }
    return 0;
}


/***** FixEdges *****/
int __cdecl EdgeCmp( const void *aa, const void *bb ) {
    PTOPL_MULTI_EDGE a=*((PTOPL_MULTI_EDGE*)aa);
    PTOPL_MULTI_EDGE b=*((PTOPL_MULTI_EDGE*)bb);
    DWORD i; int r;
    if( a->numVertices != b->numVertices )
        return ((int) a->numVertices) - ((int) b->numVertices);
    for(i=0;i<a->numVertices;i++) {
        r = VtxNameStructCmpFunc( &a->vertexNames[i], &b->vertexNames[i] );
        if(r!=0) return r;
    }
    return 0;
}
void FixEdges( PTOPL_MULTI_EDGE *edgeList, DWORD cEdge )
{
    DWORD iEdge;
    for( iEdge=0; iEdge<cEdge; iEdge++ ) {
        if( ! edgeList[iEdge]->fDirectedEdge ) {
            qsort( &edgeList[iEdge]->vertexNames[0], edgeList[iEdge]->numVertices,
                sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
        }
    }
    qsort( edgeList, cEdge, sizeof(PTOPL_MULTI_EDGE), EdgeCmp );
}


/***** EdgeExists2 *****/
char EdgeExists2( PTOPL_MULTI_EDGE e, PTOPL_MULTI_EDGE *edgeList,
    DWORD cEdge, TOPL_SCHEDULE_CACHE cache )
{
    PTOPL_MULTI_EDGE *foundE;
    DWORD iEdge,iVtx;

    if( ! e->fDirectedEdge ) {
        qsort( e->vertexNames, e->numVertices, sizeof(TOPL_NAME_STRUCT), VtxNameStructCmpFunc );
    }

    foundE = bsearch( &e, edgeList, cEdge, sizeof(PTOPL_MULTI_EDGE), EdgeCmp );
    if( foundE==NULL )
        return 0;

    if(foundE[0]->fDirectedEdge!=e->fDirectedEdge) return 0;
    if(foundE[0]->edgeType!=e->edgeType) return 0;
    if(foundE[0]->ri.cost!=e->ri.cost) return 0;
    if(foundE[0]->ri.repIntvl!=e->ri.repIntvl) return 0;
    if(foundE[0]->ri.options!=e->ri.options) return 0;
    if(!ToplScheduleIsEqual(cache,foundE[0]->ri.schedule,e->ri.schedule))
        return 0;

    return 1;
}


/***** Test7 *****/
int Test7( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       colorVtx[3];
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    TOPL_COMPONENTS         compInfo;

                            /* ID      0  1  2  3  4  5  6   7   8   9  10  11  12  13  14 */
    const DWORD             Vtx1[] = { 0, 0, 1, 2, 1, 1, 3,  4,  5,  6,  7,  8,  9,  4,  5 };
    const DWORD             Vtx2[] = { 2, 1, 2, 3, 3, 4, 4,  5,  6,  7,  8,  9, 10, 10, 10 };
    const DWORD             Cost[] = { 3, 4, 2, 6, 5,17, 6, 10, 14,  5,  2,  9, 28,200, 40 };

    numVtx = 11;
    numEdge = 15;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++) {
        edgeSet->multiEdgeList[j] = edges[j];
    }
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_RED;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[6];
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;
    colorVtx[2].name = names[8];
    colorVtx[2].color = COLOR_RED;
    colorVtx[2].acceptRedRed = colorVtx[2].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, 3, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=2 || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    outEdge->vertexNames[0].name = names[0];
    outEdge->vertexNames[1].name = names[8];
    outEdge->edgeType = 0;
    outEdge->ri.cost = 46;
    outEdge->ri.repIntvl = 30;
    outEdge->ri.options = 0;
    outEdge->ri.schedule = NULL;
    outEdge->fDirectedEdge = FALSE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }
    outEdge->vertexNames[0].name = names[8];
    outEdge->vertexNames[1].name = names[6];
    outEdge->ri.cost = 7;
    outEdge->fDirectedEdge = TRUE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 7 (Simple) Passed\n");

    return 0;
}


/***** Test8 *****/
/* Test a graph with many hyper-edges and a couple multi-edges */
int Test8( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       colorVtx[2];
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /* ID      0  1  2  3  4  5  6   7   8   9  10 */
    Vtx1[] = {18, 0, 0, 2, 4, 8, 8,  9, 10, 11,  4 },
    Vtx2[] = {14, 1, 3, 4, 8,15,12, 10, 12, 13,  8 },
    Vtx3[] = {-1, 2, 6, 5,-1,16,13, 11, 13, 14, -1 },
    Vtx4[] = {-1, 3, 7,-1,-1,17,15, -1, -1, -1, -1 },
    Vtx5[] = {-1,-1,-1,-1,-1,18,-1, -1, -1, -1, -1 },
    NumVtx[]={ 2, 4, 4, 3, 2, 5, 4,  3,  3,  3,  2 },
    Cost[] = {50, 6,10, 3, 8, 1,50,  1,  1,  1,  7 };

    numVtx = 19;
    numEdge = 11;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, NumVtx[i], 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
        switch( NumVtx[i] ) {
            case 5: ToplEdgeSetVtx( g, edges[i], 4, names[Vtx5[i]] );
            case 4: ToplEdgeSetVtx( g, edges[i], 3, names[Vtx4[i]] );
            case 3: ToplEdgeSetVtx( g, edges[i], 2, names[Vtx3[i]] );
        }
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++) {
        edgeSet->multiEdgeList[j] = edges[j];
    }
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_RED;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[9];
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, 2, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=1 || compInfo.numComponents!=1 )
        return -1;
    outEdge->vertexNames[0].name = names[0];
    outEdge->vertexNames[1].name = names[9];
    outEdge->edgeType = 0;
    outEdge->ri.cost = 68;
    outEdge->ri.repIntvl = 30;
    outEdge->ri.options = 0;
    outEdge->ri.schedule = NULL;
    outEdge->fDirectedEdge = TRUE;
    if(! EdgeExists(outEdge, stEdgeList, numStEdges, cache) )
        return -1;

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 8 (Many Hyper-Edges) Passed\n");

    return 0;
}


/***** Test9 *****/
/* Test a graph with no white vertices, a large number of colored vertices,
 * and one large hyper-edge connecting them. */
int Test9( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges;
    DWORD                   i, j, **names, numVtx, numEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;
    char                    *inTree;

    numVtx = 10000;
    numEdge = 1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    ri.cost = 625;
    ri.repIntvl = 30;
    ri.options = 0;
    ri.schedule = NULL;
    edges[0] = ToplAddEdgeToGraph( g, numVtx, 17, &ri );
    for(i=0;i<numVtx;i++)
        ToplEdgeSetVtx( g, edges[0], i, names[i] );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numVtx * sizeof(TOPL_COLOR_VERTEX) );
    for(i=0;i<numVtx;i++) {
        colorVtx[i].name = names[i];
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numVtx-1 || compInfo.numComponents!=1 )
        return -1;
    inTree = (char*) malloc( numVtx );
    for( i=0; i<numVtx; i++ )
        inTree[i]=0;
    for( i=0; i<numStEdges; i++ ) {
        if( stEdgeList[i]->numVertices!=2 )
            return -1;
        if( stEdgeList[i]->edgeType!=17 )
            return -1;
        if( stEdgeList[i]->ri.cost!=625 )
            return -1;
        if( stEdgeList[i]->fDirectedEdge )
            return -1;
        if( *((DWORD*) stEdgeList[i]->vertexNames[0].name) >= numVtx )
            return -1;
        inTree[ *((DWORD*) stEdgeList[i]->vertexNames[0].name) ] = 1;
        inTree[ *((DWORD*) stEdgeList[i]->vertexNames[1].name) ] = 1;
    }
    for( i=0; i<numVtx; i++ )
        if( inTree[i]==0 )
            return -1;
    
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 9 (Large Hyper-Edge) Passed\n");

    return 0;
}


/***** Test10 *****/
/* Test a graph with many edge-sets */
int Test10( void ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6   7   8   9  10  11  12  13  14  15  */
    Vtx1[] = { 2, 0, 2, 5, 3, 0, 1,  3,  6,  1,  5,  2,  2,  6,  9,  8 },
    Vtx2[] = { 9, 1, 3, 6, 5, 6, 5,  4,  8,  6,  9,  8,  5, 10, 10, 10 },
    Vtx3[] = {-1, 2, 4,-1,-1,-1,-1,  7, -1,  5, -1, -1, -1, -1, 11, -1 },
    Vtx4[] = {-1,-1,-1,-1,-1,-1,-1,  8, -1, -1, -1, -1, -1, -1, -1, -1 },
    NumVtx[]={ 2, 3, 3, 2, 2, 2, 2,  4,  2,  3,  2,  2,  2,  2,  3,  2 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1 };

    const DWORD EdgeSet[][10] = { { 3, 1, 3, 8 },
                                  { 3, 2, 5, 4 },
                                  { 6, 7, 8, 9, 10, 11, 12 },
                                  { 4, 1, 6, 3, 13 } };

    const DWORD ColorVtx[] = { 0, 4, 9, 10 };

    const DWORD OutputEdge[][3] = { { 9, 10, 1 },
                                   { 4, 9, 4 },
                                   { 0, 10, 4 } };

    numVtx = 12;
    numEdge = 16;
    numEdgeSet = 4;
    numColorVtx = 4;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 30;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, NumVtx[i], 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
        switch( NumVtx[i] ) {
            case 4:     ToplEdgeSetVtx( g, edges[i], 3, names[Vtx4[i]] );
            case 3:     ToplEdgeSetVtx( g, edges[i], 2, names[Vtx3[i]] );
        }
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    for( i=0; i<numEdgeSet; i++ ) {
        edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
        edgeSet->numMultiEdges = EdgeSet[i][0];
        edgeSet->multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( EdgeSet[i][0]*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<EdgeSet[i][0];j++) {
            edgeSet->multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        }
        ToplAddEdgeSetToGraph( g, edgeSet );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[ ColorVtx[i] ];
        colorVtx[i].color = COLOR_RED;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[ OutputEdge[i][0] ];
        outEdge->vertexNames[1].name = names[ OutputEdge[i][1] ];
        outEdge->edgeType = 0;
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 30;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = FALSE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 10 (Edge sets) Passed\n");

    return 0;
}


/***** Test11 *****/
/* Hub-spoke configuration test */
int Test11( DWORD numVtx ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    numEdge = numVtx-1;
    numEdgeSet = 1;
    numColorVtx = numVtx;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = 100;
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[0] );
        ToplEdgeSetVtx( g, edges[i], 1, names[i+1] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++)
        edgeSet->multiEdgeList[j] = edges[j];
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].color = i==0 ? COLOR_RED : COLOR_BLACK;
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    {
        DWORD time1, time2;
        printf("Num Vtx: %d   Elapsed time: ", numVtx );
        time1 = (DWORD) time( NULL );
        stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        time2 = (DWORD) time( NULL );
        printf("%d\n", time2-time1);
    }


    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[0];
        outEdge->vertexNames[1].name = names[i+1];
        outEdge->edgeType = 0;
        outEdge->ri.cost = 100;
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = TRUE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 11 (Hub & Spoke) Passed\n");

    free( colorVtx );
    free( edgeSet->multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ ) {
        free( names[i] );
    }
    free( names );

    return 0;
}


/***** Test12 *****/
/* Cost overflow testing by using a long chain. Also tests performance of deep
 * shortest-path trees in Dijkstra (but the heap size is always small). */
int Test12( DWORD numVtx ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    PTOPL_MULTI_EDGE_SET    edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges, edgeCost;

    numEdge = numVtx-1;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    edgeCost=0xFFFFFFFF/numEdge; edgeCost*=2;
    for( i=0; i<numEdge; i++ ) {
        ri.cost = edgeCost;
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, 0, &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[i] );
        ToplEdgeSetVtx( g, edges[i], 1, names[i+1] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( sizeof(TOPL_MULTI_EDGE_SET) );
    edgeSet->numMultiEdges = numEdge;
    edgeSet->multiEdgeList =
        (PTOPL_MULTI_EDGE*) malloc( numEdge*sizeof(PTOPL_MULTI_EDGE) );
    for(j=0;j<numEdge;j++)
        edgeSet->multiEdgeList[j] = edges[j];
    ToplAddEdgeSetToGraph( g, edgeSet );

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    colorVtx[0].name = names[0];
    colorVtx[0].color = COLOR_BLACK;
    colorVtx[0].acceptRedRed = colorVtx[0].acceptBlack = 0xFFFFFFFF;
    colorVtx[1].name = names[numVtx-1];
    colorVtx[1].color = COLOR_RED;
    colorVtx[1].acceptRedRed = colorVtx[1].acceptBlack = 0xFFFFFFFF;

    /* Run algorithm */
    {
        DWORD time1, time2;
        printf("Num Vtx: %d   Elapsed time: ", numVtx );
        time1 = (DWORD) time( NULL );
        stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        time2 = (DWORD) time( NULL );
        printf("%d\n", time2-time1);
    }


    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 )
        return -1;
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[numVtx-1];
        outEdge->vertexNames[1].name = names[0];
        outEdge->edgeType = 0;
        outEdge->ri.cost = 0xFFFFFFFF;
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->fDirectedEdge = TRUE;
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) )
            return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 12 (Long Chain) Passed\n");

    free( colorVtx );
    free( edgeSet->multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ ) {
        free( names[i] );
    }
    free( names );

    return 0;
}


/***** Test13 *****/
/* Test the ability of vertices to reject edges of a certain type. */
int Test13( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6  7  8  9 10 */
    Vtx1[] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 1 },
    Vtx2[] = { 1, 1, 2, 3, 2, 2, 4, 4, 4, 4, 3 },
    Type[] = { 0, 1, 1, 3, 1, 0, 0, 1, 1, 0, 3 },
    Cost[] = { 5, 5, 6,99,10,20, 1, 1, 1, 1, 5 };

    const DWORD EdgeSet[][10] = { { 2, 6, 9 },
                                  { 2, 7, 8 } };

    const DWORD ColorVtx[] = { 0, 1, 2, 3 };

    const DWORD OutputEdge[][5] = { { 1, 0, 5, 0, 1 },
                                   { 1, 2, 20, 0, 0 },
                                   { 0, 3, 99, 3, 1 } };

    numVtx = 5;
    numEdge = 11;
    numEdgeSet = 2;
    numColorVtx = 4;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }
    colorVtx[0].color = COLOR_BLACK;
    colorVtx[1].color = COLOR_RED;
    colorVtx[1].acceptRedRed = 0x00000001;
    colorVtx[1].acceptBlack =  0x00000003;
    colorVtx[2].color = COLOR_RED;
    colorVtx[2].acceptRedRed = 0x00000001;
    colorVtx[2].acceptBlack =  0x00000000;
    colorVtx[3].color = COLOR_BLACK;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->fDirectedEdge = (BOOLEAN) OutputEdge[i][4];
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 13 (Denying Edge Types) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test14 *****/
/* Simple Merge, Options, Interval Test */
int Test14( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1 */
    Vtx1[] = { 0, 1 },
    Vtx2[] = { 1, 2 },
    Type[] = { 0, 0 },
    Cost[] = { 1, 1 };

    const DWORD EdgeSet[][10] = { { 2, 0, 1 } };

    const DWORD ColorVtx[] = { 0, 2 };

    const DWORD OutputEdge[][4] = { { 0, 2, 2, 0 } };

    numVtx = 3;
    numEdge = 2;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( i==0 ) {
            ri.repIntvl = 4;
            ri.options = 3;
            for(j=0;j<112;j++) dataPtr[j] = 0x0F;
        } else {
            ri.repIntvl = 17;
            ri.options = 5;
            for(j=56;j<168;j++) dataPtr[j] = 0x0F;
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->ri.repIntvl = 17;
        outEdge->ri.options = 1;
        outEdge->fDirectedEdge = FALSE;

        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        for(j=56;j<112;j++) dataPtr[j] = 0x0F;
        outEdge->ri.schedule = ToplScheduleImport( cache, s );

        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    if( 3 != ToplScheduleNumEntries(cache) ) {
        Error();
        return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 14 (Simple Schedule,Options,ReplIntvl) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test15 *****/
/* Schedules: Longest Duration Wins */
int Test15( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6 */
    Vtx1[] = { 3, 0, 0, 1, 1, 4, 0 },
    Vtx2[] = { 4, 1, 4, 2, 4, 2, 3 },
    Type[] = { 0, 0, 0, 0, 0, 0, 0 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1 },
    Sched[]= { 0x000F000F,
               0x08000000,
               0x08000000,
               0x06000000,
               0x07000000,
               0xFFFFFFFF,
               0x0F0F0F0F };

    const DWORD EdgeSet[][10] = { {1} };
    const DWORD ColorVtx[] = { 0, 1, 2, 3, 4 };
    const DWORD OutputEdge[] = { 0, 4, 5, 6 };

    numVtx = 5;
    numEdge = 7;
    numEdgeSet = 0;
    numColorVtx = 5;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        edges[OutputEdge[i]]->fDirectedEdge = FALSE;
        if(! EdgeExists2(edges[OutputEdge[i]], stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 15 (Longest Schedule Wins) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test16 *****/
/* Schedules: Longest Duration Wins 2 */
int Test16( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  4  5  6  7  8  9*/
    Vtx1[] = { 0, 0, 0, 3, 4, 2, 3, 1, 1, 1 },
    Vtx2[] = { 2, 3, 4, 3, 4, 1, 1, 4, 1, 5 },
    Type[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    Cost[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1,20 },
    Sched[]= { 0x0F0F0000,  /*0*/
               0x0F0F0F0F,  /*1*/
               0x00070007,  /*2*/
               0xFFFFFFFF,  /*3*/
               0xFFFFFFFF,  /*4*/
               0xFFFFFFFF,  /*5*/
               0xFFFFFFFF,  /*6*/
               0x0F0F0F0F,  /*7*/
               0xFFFFFFFF,  /*8*/
               0xFFFFFFFF };/*9*/

    const DWORD EdgeSet[][20] = { {10,0,1,2,3,4,5,6,7,8,9} };
    const DWORD ColorVtx[] = { 0, 5 };
    const DWORD OutputEdge[][5] = { {0,5,22,0,0x0F0F0F0F} };

    numVtx = 6;
    numEdge = 10;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    outEdge->vertexNames[0].name = names[OutputEdge[0][0]];
    outEdge->vertexNames[1].name = names[OutputEdge[0][1]];
    outEdge->ri.cost = OutputEdge[0][2];
    outEdge->edgeType = OutputEdge[0][3];
    outEdge->ri.repIntvl = 0;
    outEdge->ri.options = 0;
    outEdge->fDirectedEdge = FALSE;

    s = (PSCHEDULE) malloc(cbSched);
    s->Size = cbSched;
    s->NumberOfSchedules = 1;
    s->Schedules[0].Type = SCHEDULE_INTERVAL;
    s->Schedules[0].Offset = sizeof(SCHEDULE);
    dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
    memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
    memcpy( dataPtr, &OutputEdge[0][4], sizeof(DWORD) );
    outEdge->ri.schedule = ToplScheduleImport( cache, s );

    if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
        Error();
        return -1;
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 16 (Longest Schedule Wins 2) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test17 *****/
/* Non-intersecting schedules */
int Test17( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    DWORD                   numStEdges;
    const int               cbSched = sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES;
    PSCHEDULE               s;
    TOPL_COMPONENTS         compInfo;
    unsigned char*          dataPtr;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3  */
    Vtx1[] = { 0, 0, 1, 2 },
    Vtx2[] = { 2, 1, 3, 3 },
    Type[] = { 0, 0, 0, 0 },
    Cost[] = { 1,99,99, 1 },
    Sched[]= { 0x07070707,  /*0*/
               0xFFFFFFFF,  /*1*/
               0xFFFFFFFF,  /*2*/
               0x08080808 };/*3*/

    const DWORD EdgeSet[][20] = { {4,0,1,2,3} };
    const DWORD ColorVtx[] = { 0, 3 };

    numVtx = 4;
    numEdge = 4;
    numEdgeSet = 1;
    numColorVtx = 2;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        s = (PSCHEDULE) malloc(cbSched);
        s->Size = cbSched;
        s->NumberOfSchedules = 1;
        s->Schedules[0].Type = SCHEDULE_INTERVAL;
        s->Schedules[0].Offset = sizeof(SCHEDULE);
        dataPtr = ((unsigned char*) s) + sizeof(SCHEDULE);
        memset( dataPtr, 0, SCHEDULE_DATA_ENTRIES );
        if( Sched[i]==0xFFFFFFFF ) {
            memset( dataPtr, 0x0F, SCHEDULE_DATA_ENTRIES );
        } else {
            memcpy( dataPtr, &Sched[i], sizeof(DWORD) );
        }
        ri.schedule = ToplScheduleImport( cache, s );
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    /* Used for comparing the output spanning-tree edges with what we expect */
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].color = COLOR_BLACK;
        colorVtx[i].name = names[ColorVtx[i]];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }

    /* Run algorithm */
    __try {
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );
        return -1;
    } except( AcceptOnly(TOPL_EX_NONINTERSECTING_SCHEDULES) )
    { }


    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 17 (Non-intersecting schedules) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}


/***** Test18 *****/
/* Test the ability of vertices to reject edges of a certain type. */
int Test18( VOID ) {
    PTOPL_GRAPH_STATE       g;
    TOPL_SCHEDULE_CACHE     cache;
    PTOPL_MULTI_EDGE        *edges, outEdge;
    TOPL_MULTI_EDGE_SET     *edgeSet;
    DWORD                   i, j, **names;
    DWORD                   numVtx, numEdge, numEdgeSet, numColorVtx, numOutEdge;
    TOPL_COLOR_VERTEX       *colorVtx;
    PTOPL_MULTI_EDGE        *stEdgeList;
    TOPL_REPL_INFO          ri;
    TOPL_COMPONENTS         compInfo;
    DWORD                   numStEdges;

    const DWORD 
    
    /*** Edge Descriptions ***/
    /* ID      0  1  2  3 */
    Vtx1[] = { 0, 0, 1, 1 },
    Vtx2[] = { 1, 1, 2, 2 },
    Type[] = { 0, 1, 0, 1 },
    Cost[] = {10, 5,10,99 };

    const DWORD EdgeSet[][10] = { { 2, 0, 2}, {2, 1, 3} };

    const DWORD ColorVtx[] = { 0, 1, 2 };

    const DWORD OutputEdge[][5] = { { 0, 1, 5, 1, 1 },
                                   { 0, 2, 20, 0, 1 } };

    numVtx = 3;
    numEdge = 4;
    numEdgeSet = 2;
    numColorVtx = 3;
    numOutEdge = numColorVtx-1;

    /* Make names and graph */
    names = (DWORD**) malloc( numVtx * sizeof(DWORD*) );
    for( i=0; i<numVtx; i++ ) {
        names[i] = (DWORD*) malloc( sizeof(DWORD) );
        *(names[i]) = i;
    }
    cache = ToplScheduleCacheCreate();
    g = ToplMakeGraphState( names, numVtx, VtxNameCmpFunc, cache );

    /* Make edges */
    edges = (PTOPL_MULTI_EDGE*) malloc( numEdge * sizeof(PTOPL_MULTI_EDGE) );
    for( i=0; i<numEdge; i++ ) {
        ri.cost = Cost[i];
        ri.repIntvl = 0;
        ri.options = 0;
        ri.schedule = NULL;
        edges[i] = ToplAddEdgeToGraph( g, 2, Type[i], &ri );
        ToplEdgeSetVtx( g, edges[i], 0, names[Vtx1[i]] );
        ToplEdgeSetVtx( g, edges[i], 1, names[Vtx2[i]] );
    }
    outEdge = (PTOPL_MULTI_EDGE) malloc( sizeof(TOPL_MULTI_EDGE) + 2*sizeof(TOPL_NAME_STRUCT) );
    outEdge->numVertices = 2;

    /* Build edge set */
    edgeSet = (PTOPL_MULTI_EDGE_SET) malloc( numEdgeSet * sizeof(TOPL_MULTI_EDGE_SET) );
    for( i=0; i<numEdgeSet; i++ ) {
        DWORD cEdge=EdgeSet[i][0];
        edgeSet[i].numMultiEdges = cEdge;
        edgeSet[i].multiEdgeList =
            (PTOPL_MULTI_EDGE*) malloc( cEdge*sizeof(PTOPL_MULTI_EDGE) );
        for(j=0;j<cEdge;j++)
            edgeSet[i].multiEdgeList[j] = edges[ EdgeSet[i][j+1] ];
        ToplAddEdgeSetToGraph( g, &edgeSet[i] );
    }

    /* Make color vertices */
    colorVtx = (TOPL_COLOR_VERTEX*) malloc( numColorVtx * sizeof(TOPL_COLOR_VERTEX) );
    for( i=0; i<numColorVtx; i++ ) {
        colorVtx[i].name = names[i];
        colorVtx[i].acceptRedRed = colorVtx[i].acceptBlack = 0xFFFFFFFF;
    }
    colorVtx[0].color = COLOR_RED;
    colorVtx[1].color = COLOR_BLACK;
    colorVtx[1].acceptRedRed = 0x00000000;
    colorVtx[1].acceptBlack =  0x00000002;
    colorVtx[2].color = COLOR_BLACK;

    /* Run algorithm */
    stEdgeList = ToplGetSpanningTreeEdgesForVtx( g, NULL, colorVtx, numColorVtx, &numStEdges, &compInfo );

    /* Analyze output edges */
    if( numStEdges!=numOutEdge || compInfo.numComponents!=1 ) {
        Error();
        return -1;
    }
    FixEdges( stEdgeList, numStEdges );
    for( i=0; i<numOutEdge; i++ ) {
        outEdge->vertexNames[0].name = names[OutputEdge[i][0]];
        outEdge->vertexNames[1].name = names[OutputEdge[i][1]];
        outEdge->ri.cost = OutputEdge[i][2];
        outEdge->ri.repIntvl = 0;
        outEdge->ri.options = 0;
        outEdge->ri.schedule = NULL;
        outEdge->edgeType = OutputEdge[i][3];
        outEdge->fDirectedEdge = (BOOLEAN) OutputEdge[i][4];
        if(! EdgeExists2(outEdge, stEdgeList, numStEdges, cache) ) {
            Error();
            return -1;
        }
    }

    ToplDeleteSpanningTreeEdges( stEdgeList, numStEdges );
    ToplDeleteGraphState( g );
    ToplScheduleCacheDestroy( cache );
    printf("Test 18 (Bridgehead Failover) Passed\n");

    free( colorVtx );
    for( i=0; i<numEdgeSet; i++ )
        free( edgeSet[i].multiEdgeList );
    free( edgeSet );
    free( outEdge );
    free( edges );
    for( i=0; i<numVtx; i++ )
        free( names[i] );
    free( names );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\idl\abprops.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       abprops.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines MAPI prop types in a format that may be used by .idl
    files.  It is expected to be included by nspi.idl and msds.idl only.

Author:

    Tim Williams (timwi) 1990-1995

Revision History:
    
    9-May-1996 Pulled thse definitions out of nspi.idl for use by nspi.idl and
    msds.idl.
    
--*/

#define MV_FLAG         ((ULONG) 0x1000)// Multi-value flag
#define PT_UNSPECIFIED  ((ULONG)  0)    // Type doesn't matter to caller
#define PT_NULL         ((ULONG)  1)    // NULL property value
#define PT_I2           ((ULONG)  2)    // Signed 16-bit value
#define PT_LONG         ((ULONG)  3)    // Signed 32-bit value
#define PT_R4           ((ULONG)  4)    // 4-byte floating point
#define PT_DOUBLE       ((ULONG)  5)    // Floating point double
#define PT_CURRENCY     ((ULONG)  6)    // Signed 64-bit int (decimal w/4 digits
                                        // right of decimal) 
#define PT_APPTIME      ((ULONG)  7)    // Application time
#define PT_ERROR        ((ULONG) 10)    // 32-bit error value
#define PT_BOOLEAN      ((ULONG) 11)    // 16-bit boolean (non-zero true)
#define PT_OBJECT       ((ULONG) 13)    // Embedded object in a property
#define PT_I8           ((ULONG) 20)    // 8-byte signed integer
#define PT_STRING8      ((ULONG) 30)    // Null terminated 8-bit char string 
#define PT_UNICODE      ((ULONG) 31)    // Null terminated Unicode string
#define PT_SYSTIME      ((ULONG) 64)    // FILETIME 64-bit int w/number of 100ns
                                        // periods since Jan 1,1601
#define PT_CLSID        ((ULONG) 72)    // OLE GUID
#define PT_BINARY       ((ULONG) 258)   // Uninterpreted (counted byte array)

#define PT_MV_I2        ((ULONG) 4098)
#define PT_MV_LONG      ((ULONG) 4099)
#define PT_MV_R4        ((ULONG) 4100)
#define PT_MV_DOUBLE    ((ULONG) 4101)
#define PT_MV_CURRENCY  ((ULONG) 4102)
#define PT_MV_APPTIME   ((ULONG) 4103)
#define PT_MV_SYSTIME   ((ULONG) 4160)
#define PT_MV_STRING8   ((ULONG) 4126)
#define PT_MV_BINARY    ((ULONG) 4354)
#define PT_MV_UNICODE   ((ULONG) 4127)
#define PT_MV_CLSID     ((ULONG) 4168)
#define PT_MV_I8        ((ULONG) 4116)

#define PROP_TYPE_MASK  ((ULONG)0x0000FFFF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\idl\preidl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//--------------------------------------------------------------------------

////////////////////// ADDED TO AVOID BUILD ERROR[RajNath]//////////////
#include <NTDSpch.h>
#pragma  hdrstop
////////////////////// ADDED TO AVOID BUILD ERROR[RajNath]//////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\idl\preidl1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//--------------------------------------------------------------------------

////////////////////// ADDED TO AVOID BUILD WARNINGS [DaveStr] //////////////

// See comments in ntdsimp.idl as to why any #include of drs.h needs
// to be preceeded by a #include of ntdsapi.h

#include <ntdsapi.h>

////////////////////// ADDED TO AVOID BUILD WARNINGS [DaveStr] //////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\allocaln.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocaln.h
//
//--------------------------------------------------------------------------


#ifndef _ALLOCALN_H
#define _ALLOCALN_H

// This macro front ends alloca so that the stack is still properly
// aligned after the allocation.

#ifdef WIN32
#define allocalign(x) alloca((x+3)&(~3))
#else
#define allocalign(x) alloca((x+1)&(~1))
#endif

//
// 64 bit padding
//

#define ALIGN64_ADDR(_addr)     (((DWORD_PTR)(_addr) + 7) & ~7)
#define IS_ALIGNED64(_addr)     (((DWORD_PTR)(_addr) & 7) == 0)
#define PAD64(_size)            ((_size) + sizeof(ULONGLONG))

#endif // _ALLOCALN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#

!include $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

UNICODE=1

INCS = -I..\inc -I$(DS_INC_PATH) -I$(SDK_INC_PATH) -I$(CRT_INC_PATH)

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"

DRS_DEPENDS = .\drs.idl .\drs.acf .\ntdsimp.idl ..\inc\ntdsimp.h \
              $(NTDS_INC)\ntdsa.h ..\inc\draasync.h $(SDK_INC_PATH)\ntdsapi.h \
              $(EXTRN_DEPENDS)

#
# MIDL COMPILE
#

# nt ntdsa client stub -- uses -robust, alternate client stub prefix since
# server stubs are in the same binary, and the async acf

$(O)\drs_w.c : drsasync.acf $(DRS_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext $(CPP) -prefix client "_"  -server none -header drs_w.h -out .\$(O) -cstub drs_w.c -acf drsasync.acf $(INCS) .\drs.idl

# nt ntdsapi client and ntdsa server stubs -- use -robust

$(O)\drs.h $(O)\drs_c.c $(O)\drs_s.c : $(DRS_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext $(CPP) -out .\$(O) $(INCS) drs.idl


$(O)\nspi.h $(O)\nspi_s.c : nspi.idl nspi.acf $(EXTRN_DEPENDS)
    midl -Oicf -robust -error ref -ms_ext -c_ext $(CPP) -client none -out .\$(O) $(INCS) nspi.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\idl\preidl2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\attignor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       attignor.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines all attributes that can be ignored
    while comparing objects from two replicas. This header
    meant for use by our test tools that do object comparisons
    from different replicas. 

Author:

    R.S. Raghavan (rsraghav)	

Revision History:
    
    Created     <02/07/97>  rsraghav

--*/

#ifndef _ATTIGNOR_H_
#define _ATTIGNOR_H_


// Following is the array of ldap display name strings of
// the attributes which can be ignored while comparing objects
// from different replicas

LPTSTR rIgnorableAttr[] = {
    TEXT( "badPasswordTime" ),
    TEXT( "badPwdCount" ),
    TEXT( "instanceType" ),
    TEXT( "lastLogoff" ),
    TEXT( "lastLogon" ),
    TEXT( "logonCount" ),
    TEXT( "replPropertyMetaData" ),
    TEXT( "replUpToDateVector" ),
    TEXT( "repsFrom" ),
    TEXT( "repsTo" ),
    TEXT( "repsToExt" ),
    TEXT( "schemaUpdate" ),
    TEXT( "schemaUpdateNow" ),
    TEXT( "serverRole" ),
    TEXT( "serverState" ),
    TEXT( "usnChanged" ),
    TEXT( "usnCreated" ),
    TEXT( "usnLastObjRem" ),
    TEXT( "usnSource" ),
    TEXT( "whenChanged" )
    // KEEP THESE SORTED!
};

#define cIgnorableAttr (sizeof(rIgnorableAttr) / sizeof(rIgnorableAttr[0]))


#endif // _ATTIGNOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\base64.h ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.h

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#ifndef _BASE64_H_
#define _BASE64_H_

#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    );

NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pbDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // _BASE64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\attids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       attids.h
//
//--------------------------------------------------------------------------



/*++
 File:    ATTIDS.H
 Purpose: ATTRID & CLASSID DEFINITION .
 Creator: Automatically generated on
 Date:    Sat May 12 11:41:44 2001

 ** This is a Generated File From Schema.INI **

--*/
#ifndef _ATTIDS_
#define _ATTIDS_



//--------------------------------------
// ATTRIBUTE MAPPINGS
//--------------------------------------
#define  ATT_ACCOUNT_EXPIRES                0x9009f    // ATTq589983   (\x2A864886F7140104811F)
#define  ATT_ACCOUNT_NAME_HISTORY           0x9051b    // ATTm591131   (\x2A864886F71401048A1B)
#define  ATT_ACS_AGGREGATE_TOKEN_RATE_PER_USER 0x902f8    // ATTq590584   (\x2A864886F71401048578)
#define  ATT_ACS_ALLOCABLE_RSVP_BANDWIDTH   0x902fe    // ATTq590590   (\x2A864886F7140104857E)
#define  ATT_ACS_CACHE_TIMEOUT              0x9030b    // ATTj590603   (\x2A864886F7140104860B)
#define  ATT_ACS_DIRECTION                  0x902f5    // ATTj590581   (\x2A864886F71401048575)
#define  ATT_ACS_DSBM_DEADTIME              0x9030a    // ATTj590602   (\x2A864886F7140104860A)
#define  ATT_ACS_DSBM_PRIORITY              0x90308    // ATTj590600   (\x2A864886F71401048608)
#define  ATT_ACS_DSBM_REFRESH               0x90309    // ATTj590601   (\x2A864886F71401048609)
#define  ATT_ACS_ENABLE_ACS_SERVICE         0x90302    // ATTi590594   (\x2A864886F71401048602)
#define  ATT_ACS_ENABLE_RSVP_ACCOUNTING     0x90383    // ATTi590723   (\x2A864886F71401048703)
#define  ATT_ACS_ENABLE_RSVP_MESSAGE_LOGGING 0x90300    // ATTi590592   (\x2A864886F71401048600)
#define  ATT_ACS_EVENT_LOG_LEVEL            0x90301    // ATTj590593   (\x2A864886F71401048601)
#define  ATT_ACS_IDENTITY_NAME              0x90310    // ATTm590608   (\x2A864886F71401048610)
#define  ATT_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER 0x90381    // ATTq590721   (\x2A864886F71401048701)
#define  ATT_ACS_MAX_DURATION_PER_FLOW      0x902f9    // ATTj590585   (\x2A864886F71401048579)
#define  ATT_ACS_MAX_NO_OF_ACCOUNT_FILES    0x90385    // ATTj590725   (\x2A864886F71401048705)
#define  ATT_ACS_MAX_NO_OF_LOG_FILES        0x90306    // ATTj590598   (\x2A864886F71401048606)
#define  ATT_ACS_MAX_PEAK_BANDWIDTH         0x902ff    // ATTq590591   (\x2A864886F7140104857F)
#define  ATT_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW 0x902f7    // ATTq590583   (\x2A864886F71401048577)
#define  ATT_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE 0x90386    // ATTj590726   (\x2A864886F71401048706)
#define  ATT_ACS_MAX_SIZE_OF_RSVP_LOG_FILE  0x90307    // ATTj590599   (\x2A864886F71401048607)
#define  ATT_ACS_MAX_TOKEN_BUCKET_PER_FLOW  0x90521    // ATTq591137   (\x2A864886F71401048A21)
#define  ATT_ACS_MAX_TOKEN_RATE_PER_FLOW    0x902f6    // ATTq590582   (\x2A864886F71401048576)
#define  ATT_ACS_MAXIMUM_SDU_SIZE           0x90522    // ATTq591138   (\x2A864886F71401048A22)
#define  ATT_ACS_MINIMUM_DELAY_VARIATION    0x90525    // ATTq591141   (\x2A864886F71401048A25)
#define  ATT_ACS_MINIMUM_LATENCY            0x90524    // ATTq591140   (\x2A864886F71401048A24)
#define  ATT_ACS_MINIMUM_POLICED_SIZE       0x90523    // ATTq591139   (\x2A864886F71401048A23)
#define  ATT_ACS_NON_RESERVED_MAX_SDU_SIZE  0x90528    // ATTq591144   (\x2A864886F71401048A28)
#define  ATT_ACS_NON_RESERVED_MIN_POLICED_SIZE 0x90529    // ATTq591145   (\x2A864886F71401048A29)
#define  ATT_ACS_NON_RESERVED_PEAK_RATE     0x90526    // ATTq591142   (\x2A864886F71401048A26)
#define  ATT_ACS_NON_RESERVED_TOKEN_SIZE    0x90527    // ATTq591143   (\x2A864886F71401048A27)
#define  ATT_ACS_NON_RESERVED_TX_LIMIT      0x9030c    // ATTq590604   (\x2A864886F7140104860C)
#define  ATT_ACS_NON_RESERVED_TX_SIZE       0x90382    // ATTq590722   (\x2A864886F71401048702)
#define  ATT_ACS_PERMISSION_BITS            0x902fd    // ATTq590589   (\x2A864886F7140104857D)
#define  ATT_ACS_POLICY_NAME                0x90304    // ATTm590596   (\x2A864886F71401048604)
#define  ATT_ACS_PRIORITY                   0x902fc    // ATTj590588   (\x2A864886F7140104857C)
#define  ATT_ACS_RSVP_ACCOUNT_FILES_LOCATION 0x90384    // ATTm590724   (\x2A864886F71401048704)
#define  ATT_ACS_RSVP_LOG_FILES_LOCATION    0x90305    // ATTm590597   (\x2A864886F71401048605)
#define  ATT_ACS_SERVICE_TYPE               0x902fa    // ATTj590586   (\x2A864886F7140104857A)
#define  ATT_ACS_TIME_OF_DAY                0x902f4    // ATTm590580   (\x2A864886F71401048574)
#define  ATT_ACS_TOTAL_NO_OF_FLOWS          0x902fb    // ATTj590587   (\x2A864886F7140104857B)
#define  ATT_ACS_SERVER_LIST                0x90520    // ATTm591136   (\x2A864886F71401048A20)
#define  ATT_ADDITIONAL_INFORMATION         0x90109    // ATTm590089   (\x2A864886F71401048209)
#define  ATT_ADDITIONAL_TRUSTED_SERVICE_NAMES 0x90379    // ATTm590713   (\x2A864886F71401048679)
#define  ATT_ADDRESS                        0x20100    // ATTm131328   (\x2A864886F71401028200)
#define  ATT_ADDRESS_BOOK_ROOTS             0x904dc    // ATTb591068   (\x2A864886F7140104895C)
#define  ATT_ADDRESS_ENTRY_DISPLAY_TABLE    0x20144    // ATTk131396   (\x2A864886F71401028244)
#define  ATT_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS 0x20190    // ATTk131472   (\x2A864886F71401028310)
#define  ATT_ADDRESS_HOME                   0x20269    // ATTm131689   (\x2A864886F71401028469)
#define  ATT_ADDRESS_SYNTAX                 0x200ff    // ATTk131327   (\x2A864886F7140102817F)
#define  ATT_ADDRESS_TYPE                   0x2015e    // ATTe131422   (\x2A864886F7140102825E)
#define  ATT_ADMIN_CONTEXT_MENU             0x90266    // ATTm590438   (\x2A864886F71401048466)
#define  ATT_ADMIN_COUNT                    0x90096    // ATTj589974   (\x2A864886F71401048116)
#define  ATT_ADMIN_DESCRIPTION              0x200e2    // ATTm131298   (\x2A864886F71401028162)
#define  ATT_ADMIN_DISPLAY_NAME             0x200c2    // ATTm131266   (\x2A864886F71401028142)
#define  ATT_ADMIN_MULTISELECT_PROPERTY_PAGES 0x9069a    // ATTm591514   (\x2A864886F71401048D1A)
#define  ATT_ADMIN_PROPERTY_PAGES           0x90232    // ATTm590386   (\x2A864886F71401048432)
#define  ATT_ALLOWED_ATTRIBUTES             0x90391    // ATTc590737   (\x2A864886F71401048711)
#define  ATT_ALLOWED_ATTRIBUTES_EFFECTIVE   0x90392    // ATTc590738   (\x2A864886F71401048712)
#define  ATT_ALLOWED_CHILD_CLASSES          0x9038f    // ATTc590735   (\x2A864886F7140104870F)
#define  ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE 0x90390    // ATTc590736   (\x2A864886F71401048710)
#define  ATT_ALT_SECURITY_IDENTITIES        0x90363    // ATTm590691   (\x2A864886F71401048663)
#define  ATT_ANR                            0x904b8    // ATTm591032   (\x2A864886F71401048938)
#define  ATT_APP_SCHEMA_VERSION             0x90350    // ATTj590672   (\x2A864886F71401048650)
#define  ATT_APPLICATION_NAME               0x900da    // ATTm590042   (\x2A864886F7140104815A)
#define  ATT_APPLIES_TO                     0x90155    // ATTm590165   (\x2A864886F71401048255)
#define  ATT_ASSET_NUMBER                   0x9011b    // ATTm590107   (\x2A864886F7140104821B)
#define  ATT_ASSISTANT                      0x9028c    // ATTb590476   (\x2A864886F7140104850C)
#define  ATT_ASSOC_NT_ACCOUNT               0x904bd    // ATTk591037   (\x2A864886F7140104893D)
#define  ATT_ATTRIBUTECERTIFICATEATTRIBUTE  0x3a       // ATTk58       (\x55043A)
#define  ATT_ATTRIBUTE_DISPLAY_NAMES        0x902ec    // ATTm590572   (\x2A864886F7140104856C)
#define  ATT_ATTRIBUTE_ID                   0x2001e    // ATTc131102   (\x2A864886F71401021E)
#define  ATT_ATTRIBUTE_SECURITY_GUID        0x90095    // ATTk589973   (\x2A864886F71401048115)
#define  ATT_ATTRIBUTE_SYNTAX               0x20020    // ATTc131104   (\x2A864886F714010220)
#define  ATT_ATTRIBUTE_TYPES                0x180005   // ATTm1572869  (\x551505)
#define  ATT_AUDIO                          0x150037   // ATTk1376311  (\x0992268993F22C640137)
#define  ATT_AUDITING_POLICY                0x900ca    // ATTk590026   (\x2A864886F7140104814A)
#define  ATT_AUTHENTICATION_OPTIONS         0x9000b    // ATTj589835   (\x2A864886F71401040B)
#define  ATT_AUTHORITY_REVOCATION_LIST      0x26       // ATTk38       (\x550426)
#define  ATT_AUXILIARY_CLASS                0x2015f    // ATTc131423   (\x2A864886F7140102825F)
#define  ATT_BAD_PASSWORD_TIME              0x90031    // ATTq589873   (\x2A864886F714010431)
#define  ATT_BAD_PWD_COUNT                  0x9000c    // ATTj589836   (\x2A864886F71401040C)
#define  ATT_BIRTH_LOCATION                 0x9014c    // ATTk590156   (\x2A864886F7140104824C)
#define  ATT_BRIDGEHEAD_SERVER_LIST_BL      0x90334    // ATTb590644   (\x2A864886F71401048634)
#define  ATT_BRIDGEHEAD_TRANSPORT_LIST      0x90333    // ATTb590643   (\x2A864886F71401048633)
#define  ATT_BUILTIN_CREATION_TIME          0x9000d    // ATTq589837   (\x2A864886F71401040D)
#define  ATT_BUILTIN_MODIFIED_COUNT         0x9000e    // ATTq589838   (\x2A864886F71401040E)
#define  ATT_BUSINESS_CATEGORY              0xf        // ATTm15       (\x55040F)
#define  ATT_BYTES_PER_MINUTE               0x9011c    // ATTj590108   (\x2A864886F7140104821C)
#define  ATT_CA_CERTIFICATE                 0x25       // ATTk37       (\x550425)
#define  ATT_CA_CERTIFICATE_DN              0x902b9    // ATTm590521   (\x2A864886F71401048539)
#define  ATT_CA_CONNECT                     0x902af    // ATTm590511   (\x2A864886F7140104852F)
#define  ATT_CA_USAGES                      0x902b2    // ATTm590514   (\x2A864886F71401048532)
#define  ATT_CA_WEB_URL                     0x902b0    // ATTm590512   (\x2A864886F71401048530)
#define  ATT_CAN_UPGRADE_SCRIPT             0x9032f    // ATTm590639   (\x2A864886F7140104862F)
#define  ATT_CANONICAL_NAME                 0x90394    // ATTm590740   (\x2A864886F71401048714)
#define  ATT_CARLICENSE                     0x160001   // ATTm1441793  (\x6086480186F842030101)
#define  ATT_CATALOGS                       0x902a3    // ATTm590499   (\x2A864886F71401048523)
#define  ATT_CATEGORIES                     0x902a0    // ATTm590496   (\x2A864886F71401048520)
#define  ATT_CATEGORY_ID                    0x90142    // ATTk590146   (\x2A864886F71401048242)
#define  ATT_CERTIFICATE_AUTHORITY_OBJECT   0x902ac    // ATTb590508   (\x2A864886F7140104852C)
#define  ATT_CERTIFICATE_REVOCATION_LIST    0x27       // ATTk39       (\x550427)
#define  ATT_CERTIFICATE_TEMPLATES          0x90337    // ATTm590647   (\x2A864886F71401048637)
#define  ATT_CLASS_DISPLAY_NAME             0x90262    // ATTm590434   (\x2A864886F71401048462)
#define  ATT_CODE_PAGE                      0x90010    // ATTj589840   (\x2A864886F714010410)
#define  ATT_COM_CLASSID                    0x90013    // ATTm589843   (\x2A864886F714010413)
#define  ATT_COM_CLSID                      0x900f9    // ATTm590073   (\x2A864886F71401048179)
#define  ATT_COM_INTERFACEID                0x90014    // ATTm589844   (\x2A864886F714010414)
#define  ATT_COM_OTHER_PROG_ID              0x900fd    // ATTm590077   (\x2A864886F7140104817D)
#define  ATT_COM_PROGID                     0x90015    // ATTm589845   (\x2A864886F714010415)
#define  ATT_COM_TREAT_AS_CLASS_ID          0x900fb    // ATTm590075   (\x2A864886F7140104817B)
#define  ATT_COM_TYPELIB_ID                 0x900fe    // ATTm590078   (\x2A864886F7140104817E)
#define  ATT_COM_UNIQUE_LIBID               0x900fa    // ATTm590074   (\x2A864886F7140104817A)
#define  ATT_COMMENT                        0x20051    // ATTm131153   (\x2A864886F714010251)
#define  ATT_COMMON_NAME                    0x3        // ATTm3        (\x550403)
#define  ATT_COMPANY                        0x20092    // ATTm131218   (\x2A864886F71401028112)
#define  ATT_CONTENT_INDEXING_ALLOWED       0x90018    // ATTi589848   (\x2A864886F714010418)
#define  ATT_CONTEXT_MENU                   0x901f3    // ATTm590323   (\x2A864886F71401048373)
#define  ATT_CONTROL_ACCESS_RIGHTS          0x900c8    // ATTk590024   (\x2A864886F71401048148)
#define  ATT_COST                           0x20087    // ATTj131207   (\x2A864886F71401028107)
#define  ATT_COUNTRY_CODE                   0x90019    // ATTj589849   (\x2A864886F714010419)
#define  ATT_COUNTRY_NAME                   0x6        // ATTm6        (\x550406)
#define  ATT_CREATE_DIALOG                  0x9032a    // ATTm590634   (\x2A864886F7140104862A)
#define  ATT_CREATE_TIME_STAMP              0x190001   // ATTl1638401  (\x551201)
#define  ATT_CREATE_WIZARD_EXT              0x9032c    // ATTm590636   (\x2A864886F7140104862C)
#define  ATT_CREATION_TIME                  0x9001a    // ATTq589850   (\x2A864886F71401041A)
#define  ATT_CREATION_WIZARD                0x901f2    // ATTm590322   (\x2A864886F71401048372)
#define  ATT_CREATOR                        0x902a7    // ATTm590503   (\x2A864886F71401048527)
#define  ATT_CRL_OBJECT                     0x902b1    // ATTb590513   (\x2A864886F71401048531)
#define  ATT_CRL_PARTITIONED_REVOCATION_LIST 0x902ab    // ATTk590507   (\x2A864886F7140104852B)
#define  ATT_CROSS_CERTIFICATE_PAIR         0x28       // ATTk40       (\x550428)
#define  ATT_CURR_MACHINE_ID                0x90151    // ATTk590161   (\x2A864886F71401048251)
#define  ATT_CURRENT_LOCATION               0x9014f    // ATTk590159   (\x2A864886F7140104824F)
#define  ATT_CURRENT_PARENT_CA              0x902b8    // ATTb590520   (\x2A864886F71401048538)
#define  ATT_CURRENT_VALUE                  0x9001b    // ATTk589851   (\x2A864886F71401041B)
#define  ATT_DBCS_PWD                       0x90037    // ATTk589879   (\x2A864886F714010437)
#define  ATT_DEFAULT_CLASS_STORE            0x900d5    // ATTb590037   (\x2A864886F71401048155)
#define  ATT_DEFAULT_GROUP                  0x901e0    // ATTb590304   (\x2A864886F71401048360)
#define  ATT_DEFAULT_HIDING_VALUE           0x90206    // ATTi590342   (\x2A864886F71401048406)
#define  ATT_DEFAULT_LOCAL_POLICY_OBJECT    0x90039    // ATTb589881   (\x2A864886F714010439)
#define  ATT_DEFAULT_OBJECT_CATEGORY        0x9030f    // ATTb590607   (\x2A864886F7140104860F)
#define  ATT_DEFAULT_PRIORITY               0x900e8    // ATTj590056   (\x2A864886F71401048168)
#define  ATT_DEFAULT_SECURITY_DESCRIPTOR    0x900e0    // ATTm590048   (\x2A864886F71401048160)
#define  ATT_DELTA_REVOCATION_LIST          0x35       // ATTk53       (\x550435)
#define  ATT_DEPARTMENT                     0x2008d    // ATTm131213   (\x2A864886F7140102810D)
#define  ATT_DEPARTMENTNUMBER               0x160002   // ATTm1441794  (\x6086480186F842030102)
#define  ATT_DESCRIPTION                    0xd        // ATTm13       (\x55040D)
#define  ATT_DESKTOP_PROFILE                0x9015a    // ATTm590170   (\x2A864886F7140104825A)
#define  ATT_DESTINATION_INDICATOR          0x1b       // ATTf27       (\x55041B)
#define  ATT_DHCP_CLASSES                   0x902cb    // ATTk590539   (\x2A864886F7140104854B)
#define  ATT_DHCP_FLAGS                     0x902bc    // ATTq590524   (\x2A864886F7140104853C)
#define  ATT_DHCP_IDENTIFICATION            0x902bd    // ATTm590525   (\x2A864886F7140104853D)
#define  ATT_DHCP_MASK                      0x902c2    // ATTf590530   (\x2A864886F71401048542)
#define  ATT_DHCP_MAXKEY                    0x902cf    // ATTq590543   (\x2A864886F7140104854F)
#define  ATT_DHCP_OBJ_DESCRIPTION           0x902bf    // ATTm590527   (\x2A864886F7140104853F)
#define  ATT_DHCP_OBJ_NAME                  0x902be    // ATTm590526   (\x2A864886F7140104853E)
#define  ATT_DHCP_OPTIONS                   0x902ca    // ATTk590538   (\x2A864886F7140104854A)
#define  ATT_DHCP_PROPERTIES                0x902ce    // ATTk590542   (\x2A864886F7140104854E)
#define  ATT_DHCP_RANGES                    0x902c3    // ATTf590531   (\x2A864886F71401048543)
#define  ATT_DHCP_RESERVATIONS              0x902c5    // ATTf590533   (\x2A864886F71401048545)
#define  ATT_DHCP_SERVERS                   0x902c0    // ATTf590528   (\x2A864886F71401048540)
#define  ATT_DHCP_SITES                     0x902c4    // ATTf590532   (\x2A864886F71401048544)
#define  ATT_DHCP_STATE                     0x902cd    // ATTf590541   (\x2A864886F7140104854D)
#define  ATT_DHCP_SUBNETS                   0x902c1    // ATTf590529   (\x2A864886F71401048541)
#define  ATT_DHCP_TYPE                      0x902bb    // ATTj590523   (\x2A864886F7140104853B)
#define  ATT_DHCP_UNIQUE_KEY                0x902ba    // ATTq590522   (\x2A864886F7140104853A)
#define  ATT_DHCP_UPDATE_TIME               0x902d0    // ATTq590544   (\x2A864886F71401048550)
#define  ATT_DISPLAY_NAME                   0x2000d    // ATTm131085   (\x2A864886F71401020D)
#define  ATT_DISPLAY_NAME_PRINTABLE         0x20161    // ATTf131425   (\x2A864886F71401028261)
#define  ATT_DIT_CONTENT_RULES              0x180002   // ATTm1572866  (\x551502)
#define  ATT_DIVISION                       0x90105    // ATTm590085   (\x2A864886F71401048205)
#define  ATT_DMD_LOCATION                   0x20024    // ATTb131108   (\x2A864886F714010224)
#define  ATT_DMD_NAME                       0x20256    // ATTm131670   (\x2A864886F71401028456)
#define  ATT_DN_REFERENCE_UPDATE            0x904da    // ATTb591066   (\x2A864886F7140104895A)
#define  ATT_DNS_ALLOW_DYNAMIC              0x9017a    // ATTi590202   (\x2A864886F7140104827A)
#define  ATT_DNS_ALLOW_XFR                  0x9017b    // ATTi590203   (\x2A864886F7140104827B)
#define  ATT_DNS_HOST_NAME                  0x9026b    // ATTm590443   (\x2A864886F7140104846B)
#define  ATT_DNS_NOTIFY_SECONDARIES         0x9017d    // ATTj590205   (\x2A864886F7140104827D)
#define  ATT_DNS_PROPERTY                   0x9051a    // ATTk591130   (\x2A864886F71401048A1A)
#define  ATT_DNS_RECORD                     0x9017e    // ATTk590206   (\x2A864886F7140104827E)
#define  ATT_DNS_ROOT                       0x9001c    // ATTm589852   (\x2A864886F71401041C)
#define  ATT_DNS_SECURE_SECONDARIES         0x9017c    // ATTj590204   (\x2A864886F7140104827C)
#define  ATT_DNS_TOMBSTONED                 0x90586    // ATTi591238   (\x2A864886F71401048B06)
#define  ATT_DOMAIN_CERTIFICATE_AUTHORITIES 0x9029c    // ATTb590492   (\x2A864886F7140104851C)
#define  ATT_DOMAIN_COMPONENT               0x150019   // ATTm1376281  (\x0992268993F22C640119)
#define  ATT_DOMAIN_CROSS_REF               0x901d8    // ATTb590296   (\x2A864886F71401048358)
#define  ATT_DOMAIN_ID                      0x902ae    // ATTb590510   (\x2A864886F7140104852E)
#define  ATT_DOMAIN_IDENTIFIER              0x902f3    // ATTj590579   (\x2A864886F71401048573)
#define  ATT_DOMAIN_POLICY_OBJECT           0x90020    // ATTb589856   (\x2A864886F714010420)
#define  ATT_DOMAIN_POLICY_REFERENCE        0x901a6    // ATTb590246   (\x2A864886F71401048326)
#define  ATT_DOMAIN_REPLICA                 0x9009e    // ATTm589982   (\x2A864886F7140104811E)
#define  ATT_DOMAIN_WIDE_POLICY             0x901a5    // ATTk590245   (\x2A864886F71401048325)
#define  ATT_DRIVER_NAME                    0x900e5    // ATTm590053   (\x2A864886F71401048165)
#define  ATT_DRIVER_VERSION                 0x90114    // ATTj590100   (\x2A864886F71401048214)
#define  ATT_DS_CORE_PROPAGATION_DATA       0x9054d    // ATTl591181   (\x2A864886F71401048A4D)
#define  ATT_DS_HEURISTICS                  0x200d4    // ATTm131284   (\x2A864886F71401028154)
#define  ATT_DS_UI_ADMIN_MAXIMUM            0x90540    // ATTj591168   (\x2A864886F71401048A40)
#define  ATT_DS_UI_ADMIN_NOTIFICATION       0x9053f    // ATTm591167   (\x2A864886F71401048A3F)
#define  ATT_DS_UI_SHELL_MAXIMUM            0x90541    // ATTj591169   (\x2A864886F71401048A41)
#define  ATT_DSA_SIGNATURE                  0x2004a    // ATTk131146   (\x2A864886F71401024A)
#define  ATT_DYNAMIC_LDAP_SERVER            0x90219    // ATTb590361   (\x2A864886F71401048419)
#define  ATT_E_MAIL_ADDRESSES               0x150003   // ATTm1376259  (\x0992268993F22C640103)
#define  ATT_EFSPOLICY                      0x9010c    // ATTk590092   (\x2A864886F7140104820C)
#define  ATT_EMPLOYEE_ID                    0x90023    // ATTm589859   (\x2A864886F714010423)
#define  ATT_EMPLOYEE_NUMBER                0x20262    // ATTm131682   (\x2A864886F71401028462)
#define  ATT_EMPLOYEE_TYPE                  0x20265    // ATTm131685   (\x2A864886F71401028465)
#define  ATT_ENABLED                        0x2022d    // ATTi131629   (\x2A864886F7140102842D)
#define  ATT_ENABLED_CONNECTION             0x90024    // ATTi589860   (\x2A864886F714010424)
#define  ATT_ENROLLMENT_PROVIDERS           0x90339    // ATTm590649   (\x2A864886F71401048639)
#define  ATT_EXTENDED_ATTRIBUTE_INFO        0x9038d    // ATTm590733   (\x2A864886F7140104870D)
#define  ATT_EXTENDED_CHARS_ALLOWED         0x2017c    // ATTi131452   (\x2A864886F7140102827C)
#define  ATT_EXTENDED_CLASS_INFO            0x9038c    // ATTm590732   (\x2A864886F7140104870C)
#define  ATT_EXTENSION_NAME                 0x200e3    // ATTm131299   (\x2A864886F71401028163)
#define  ATT_EXTRA_COLUMNS                  0x90697    // ATTm591511   (\x2A864886F71401048D17)
#define  ATT_FACSIMILE_TELEPHONE_NUMBER     0x17       // ATTm23       (\x550417)
#define  ATT_FILE_EXT_PRIORITY              0x90330    // ATTm590640   (\x2A864886F71401048630)
#define  ATT_FLAGS                          0x90026    // ATTj589862   (\x2A864886F714010426)
#define  ATT_FLAT_NAME                      0x901ff    // ATTm590335   (\x2A864886F7140104837F)
#define  ATT_FORCE_LOGOFF                   0x90027    // ATTq589863   (\x2A864886F714010427)
#define  ATT_FOREIGN_IDENTIFIER             0x90164    // ATTk590180   (\x2A864886F71401048264)
#define  ATT_FRIENDLY_NAMES                 0x902aa    // ATTm590506   (\x2A864886F7140104852A)
#define  ATT_FROM_ENTRY                     0x9038e    // ATTi590734   (\x2A864886F7140104870E)
#define  ATT_FROM_SERVER                    0x90028    // ATTb589864   (\x2A864886F714010428)
#define  ATT_FRS_COMPUTER_REFERENCE         0x90365    // ATTb590693   (\x2A864886F71401048665)
#define  ATT_FRS_COMPUTER_REFERENCE_BL      0x90366    // ATTb590694   (\x2A864886F71401048666)
#define  ATT_FRS_CONTROL_DATA_CREATION      0x90367    // ATTm590695   (\x2A864886F71401048667)
#define  ATT_FRS_CONTROL_INBOUND_BACKLOG    0x90368    // ATTm590696   (\x2A864886F71401048668)
#define  ATT_FRS_CONTROL_OUTBOUND_BACKLOG   0x90369    // ATTm590697   (\x2A864886F71401048669)
#define  ATT_FRS_DIRECTORY_FILTER           0x901e4    // ATTm590308   (\x2A864886F71401048364)
#define  ATT_FRS_DS_POLL                    0x901ea    // ATTj590314   (\x2A864886F7140104836A)
#define  ATT_FRS_EXTENSIONS                 0x90218    // ATTk590360   (\x2A864886F71401048418)
#define  ATT_FRS_FAULT_CONDITION            0x901eb    // ATTm590315   (\x2A864886F7140104836B)
#define  ATT_FRS_FILE_FILTER                0x901e3    // ATTm590307   (\x2A864886F71401048363)
#define  ATT_FRS_FLAGS                      0x9036a    // ATTj590698   (\x2A864886F7140104866A)
#define  ATT_FRS_LEVEL_LIMIT                0x90216    // ATTj590358   (\x2A864886F71401048416)
#define  ATT_FRS_MEMBER_REFERENCE           0x9036b    // ATTb590699   (\x2A864886F7140104866B)
#define  ATT_FRS_MEMBER_REFERENCE_BL        0x9036c    // ATTb590700   (\x2A864886F7140104866C)
#define  ATT_FRS_PARTNER_AUTH_LEVEL         0x9036d    // ATTj590701   (\x2A864886F7140104866D)
#define  ATT_FRS_PRIMARY_MEMBER             0x9036e    // ATTb590702   (\x2A864886F7140104866E)
#define  ATT_FRS_REPLICA_SET_GUID           0x90215    // ATTk590357   (\x2A864886F71401048415)
#define  ATT_FRS_REPLICA_SET_TYPE           0x9001f    // ATTj589855   (\x2A864886F71401041F)
#define  ATT_FRS_ROOT_PATH                  0x901e7    // ATTm590311   (\x2A864886F71401048367)
#define  ATT_FRS_ROOT_SECURITY              0x90217    // ATTp590359   (\x2A864886F71401048417)
#define  ATT_FRS_SERVICE_COMMAND            0x901f4    // ATTm590324   (\x2A864886F71401048374)
#define  ATT_FRS_SERVICE_COMMAND_STATUS     0x9036f    // ATTm590703   (\x2A864886F7140104866F)
#define  ATT_FRS_STAGING_PATH               0x901e8    // ATTm590312   (\x2A864886F71401048368)
#define  ATT_FRS_TIME_LAST_COMMAND          0x90370    // ATTl590704   (\x2A864886F71401048670)
#define  ATT_FRS_TIME_LAST_CONFIG_CHANGE    0x90371    // ATTl590705   (\x2A864886F71401048671)
#define  ATT_FRS_UPDATE_TIMEOUT             0x901e5    // ATTj590309   (\x2A864886F71401048365)
#define  ATT_FRS_VERSION                    0x90372    // ATTm590706   (\x2A864886F71401048672)
#define  ATT_FRS_VERSION_GUID               0x9002b    // ATTk589867   (\x2A864886F71401042B)
#define  ATT_FRS_WORKING_PATH               0x901e6    // ATTm590310   (\x2A864886F71401048366)
#define  ATT_FSMO_ROLE_OWNER                0x90171    // ATTb590193   (\x2A864886F71401048271)
#define  ATT_GARBAGE_COLL_PERIOD            0x2012d    // ATTj131373   (\x2A864886F7140102822D)
#define  ATT_GENERATED_CONNECTION           0x90029    // ATTi589865   (\x2A864886F714010429)
#define  ATT_GENERATION_QUALIFIER           0x2c       // ATTm44       (\x55042C)
#define  ATT_GIVEN_NAME                     0x2a       // ATTm42       (\x55042A)
#define  ATT_GLOBAL_ADDRESS_LIST            0x904dd    // ATTb591069   (\x2A864886F7140104895D)
#define  ATT_GOVERNS_ID                     0x20016    // ATTc131094   (\x2A864886F714010216)
#define  ATT_GP_LINK                        0x9037b    // ATTm590715   (\x2A864886F7140104867B)
#define  ATT_GP_OPTIONS                     0x9037c    // ATTj590716   (\x2A864886F7140104867C)
#define  ATT_GPC_FILE_SYS_PATH              0x9037e    // ATTm590718   (\x2A864886F7140104867E)
#define  ATT_GPC_FUNCTIONALITY_VERSION      0x9037d    // ATTj590717   (\x2A864886F7140104867D)
#define  ATT_GPC_MACHINE_EXTENSION_NAMES    0x90544    // ATTm591172   (\x2A864886F71401048A44)
#define  ATT_GPC_USER_EXTENSION_NAMES       0x90545    // ATTm591173   (\x2A864886F71401048A45)
#define  ATT_GPC_WQL_FILTER                 0x9069e    // ATTm591518   (\x2A864886F71401048D1E)
#define  ATT_GROUP_ATTRIBUTES               0x90098    // ATTj589976   (\x2A864886F71401048118)
#define  ATT_GROUP_MEMBERSHIP_SAM           0x900a6    // ATTk589990   (\x2A864886F71401048126)
#define  ATT_GROUP_PRIORITY                 0x90159    // ATTm590169   (\x2A864886F71401048259)
#define  ATT_GROUP_TYPE                     0x902ee    // ATTj590574   (\x2A864886F7140104856E)
#define  ATT_GROUPS_TO_IGNORE               0x90158    // ATTm590168   (\x2A864886F71401048258)
#define  ATT_HAS_MASTER_NCS                 0x2000e    // ATTb131086   (\x2A864886F71401020E)
#define  ATT_HAS_PARTIAL_REPLICA_NCS        0x2000f    // ATTb131087   (\x2A864886F71401020F)
#define  ATT_HELP_DATA16                    0x20192    // ATTk131474   (\x2A864886F71401028312)
#define  ATT_HELP_DATA32                    0x20009    // ATTk131081   (\x2A864886F714010209)
#define  ATT_HELP_FILE_NAME                 0x20147    // ATTm131399   (\x2A864886F71401028247)
#define  ATT_HIDE_FROM_AB                   0x906f4    // ATTi591604   (\x2A864886F71401048D74)
#define  ATT_HOME_DIRECTORY                 0x9002c    // ATTm589868   (\x2A864886F71401042C)
#define  ATT_HOME_DRIVE                     0x9002d    // ATTm589869   (\x2A864886F71401042D)
#define  ATT_ICON_PATH                      0x900db    // ATTm590043   (\x2A864886F7140104815B)
#define  ATT_IMPLEMENTED_CATEGORIES         0x90140    // ATTk590144   (\x2A864886F71401048240)
#define  ATT_INDEXEDSCOPES                  0x902a9    // ATTm590505   (\x2A864886F71401048529)
#define  ATT_INITIAL_AUTH_INCOMING          0x9021b    // ATTm590363   (\x2A864886F7140104841B)
#define  ATT_INITIAL_AUTH_OUTGOING          0x9021c    // ATTm590364   (\x2A864886F7140104841C)
#define  ATT_INITIALS                       0x2b       // ATTm43       (\x55042B)
#define  ATT_INSTALL_UI_LEVEL               0x9034f    // ATTj590671   (\x2A864886F7140104864F)
#define  ATT_INSTANCE_TYPE                  0x20001    // ATTj131073   (\x2A864886F714010201)
#define  ATT_INTER_SITE_TOPOLOGY_FAILOVER   0x904e0    // ATTj591072   (\x2A864886F71401048960)
#define  ATT_INTER_SITE_TOPOLOGY_GENERATOR  0x904de    // ATTb591070   (\x2A864886F7140104895E)
#define  ATT_INTER_SITE_TOPOLOGY_RENEW      0x904df    // ATTj591071   (\x2A864886F7140104895F)
#define  ATT_INTERNATIONAL_ISDN_NUMBER      0x19       // ATTg25       (\x550419)
#define  ATT_INVOCATION_ID                  0x20073    // ATTk131187   (\x2A864886F714010273)
#define  ATT_IPSEC_DATA                     0x9026f    // ATTk590447   (\x2A864886F7140104846F)
#define  ATT_IPSEC_DATA_TYPE                0x9026e    // ATTj590446   (\x2A864886F7140104846E)
#define  ATT_IPSEC_FILTER_REFERENCE         0x90275    // ATTb590453   (\x2A864886F71401048475)
#define  ATT_IPSEC_ID                       0x9026d    // ATTm590445   (\x2A864886F7140104846D)
#define  ATT_IPSEC_ISAKMP_REFERENCE         0x90272    // ATTb590450   (\x2A864886F71401048472)
#define  ATT_IPSEC_NAME                     0x9026c    // ATTm590444   (\x2A864886F7140104846C)
#define  ATT_IPSEC_NEGOTIATION_POLICY_ACTION 0x90378    // ATTm590712   (\x2A864886F71401048678)
#define  ATT_IPSEC_NEGOTIATION_POLICY_REFERENCE 0x90274    // ATTb590452   (\x2A864886F71401048474)
#define  ATT_IPSEC_NEGOTIATION_POLICY_TYPE  0x90377    // ATTm590711   (\x2A864886F71401048677)
#define  ATT_IPSEC_NFA_REFERENCE            0x90273    // ATTb590451   (\x2A864886F71401048473)
#define  ATT_IPSEC_OWNERS_REFERENCE         0x90270    // ATTb590448   (\x2A864886F71401048470)
#define  ATT_IPSEC_POLICY_REFERENCE         0x90205    // ATTb590341   (\x2A864886F71401048405)
#define  ATT_IS_CRITICAL_SYSTEM_OBJECT      0x90364    // ATTi590692   (\x2A864886F71401048664)
#define  ATT_IS_DEFUNCT                     0x90295    // ATTi590485   (\x2A864886F71401048515)
#define  ATT_IS_DELETED                     0x20030    // ATTi131120   (\x2A864886F714010230)
#define  ATT_IS_EPHEMERAL                   0x904bc    // ATTi591036   (\x2A864886F7140104893C)
#define  ATT_IS_MEMBER_OF_DL                0x20066    // ATTb131174   (\x2A864886F714010266)
#define  ATT_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET 0x9027f    // ATTi590463   (\x2A864886F7140104847F)
#define  ATT_IS_PRIVILEGE_HOLDER            0x9027e    // ATTb590462   (\x2A864886F7140104847E)
#define  ATT_IS_SINGLE_VALUED               0x20021    // ATTi131105   (\x2A864886F714010221)
#define  ATT_JPEGPHOTO                      0x15003c   // ATTk1376316  (\x0992268993F22C64013C)
#define  ATT_KEYWORDS                       0x90030    // ATTm589872   (\x2A864886F714010430)
#define  ATT_KNOWLEDGE_INFORMATION          0x2        // ATTe2        (\x550402)
#define  ATT_LAST_BACKUP_RESTORATION_TIME   0x90207    // ATTq590343   (\x2A864886F71401048407)
#define  ATT_LAST_CONTENT_INDEXED           0x90032    // ATTq589874   (\x2A864886F714010432)
#define  ATT_LAST_KNOWN_PARENT              0x9030d    // ATTb590605   (\x2A864886F7140104860D)
#define  ATT_LAST_LOGOFF                    0x90033    // ATTq589875   (\x2A864886F714010433)
#define  ATT_LAST_LOGON                     0x90034    // ATTq589876   (\x2A864886F714010434)
#define  ATT_LAST_LOGON_TIMESTAMP           0x906a0    // ATTq591520   (\x2A864886F71401048D20)
#define  ATT_LAST_SET_TIME                  0x90035    // ATTq589877   (\x2A864886F714010435)
#define  ATT_LAST_UPDATE_SEQUENCE           0x9014a    // ATTm590154   (\x2A864886F7140104824A)
#define  ATT_LDAP_ADMIN_LIMITS              0x9034b    // ATTm590667   (\x2A864886F7140104864B)
#define  ATT_LDAP_DISPLAY_NAME              0x201cc    // ATTm131532   (\x2A864886F7140102834C)
#define  ATT_LDAP_IPDENY_LIST               0x9034c    // ATTk590668   (\x2A864886F7140104864C)
#define  ATT_LEGACY_EXCHANGE_DN             0x9028f    // ATTe590479   (\x2A864886F7140104850F)
#define  ATT_LINK_ID                        0x20032    // ATTj131122   (\x2A864886F714010232)
#define  ATT_LINK_TRACK_SECRET              0x9010d    // ATTk590093   (\x2A864886F7140104820D)
#define  ATT_LM_PWD_HISTORY                 0x900a0    // ATTk589984   (\x2A864886F71401048120)
#define  ATT_LOCAL_POLICY_FLAGS             0x90038    // ATTj589880   (\x2A864886F714010438)
#define  ATT_LOCAL_POLICY_REFERENCE         0x901c9    // ATTb590281   (\x2A864886F71401048349)
#define  ATT_LOCALE_ID                      0x9003a    // ATTj589882   (\x2A864886F71401043A)
#define  ATT_LOCALITY_NAME                  0x7        // ATTm7        (\x550407)
#define  ATT_LOCALIZED_DESCRIPTION          0x90331    // ATTm590641   (\x2A864886F71401048631)
#define  ATT_LOCALIZATION_DISPLAY_ID        0x90549    // ATTj591177   (\x2A864886F71401048A49)
#define  ATT_LOCATION                       0x900de    // ATTm590046   (\x2A864886F7140104815E)
#define  ATT_LOCK_OUT_OBSERVATION_WINDOW    0x9003d    // ATTq589885   (\x2A864886F71401043D)
#define  ATT_LOCKOUT_DURATION               0x9003c    // ATTq589884   (\x2A864886F71401043C)
#define  ATT_LOCKOUT_THRESHOLD              0x90049    // ATTj589897   (\x2A864886F714010449)
#define  ATT_LOCKOUT_TIME                   0x90296    // ATTq590486   (\x2A864886F71401048516)
#define  ATT_LOGO                           0x160024   // ATTk1441828  (\x6086480186F842030124)
#define  ATT_LOGON_COUNT                    0x900a9    // ATTj589993   (\x2A864886F71401048129)
#define  ATT_LOGON_HOURS                    0x90040    // ATTk589888   (\x2A864886F714010440)
#define  ATT_LOGON_WORKSTATION              0x90041    // ATTk589889   (\x2A864886F714010441)
#define  ATT_LSA_CREATION_TIME              0x90042    // ATTq589890   (\x2A864886F714010442)
#define  ATT_LSA_MODIFIED_COUNT             0x90043    // ATTq589891   (\x2A864886F714010443)
#define  ATT_MACHINE_ARCHITECTURE           0x90044    // ATTj589892   (\x2A864886F714010444)
#define  ATT_MACHINE_PASSWORD_CHANGE_INTERVAL 0x90208    // ATTq590344   (\x2A864886F71401048408)
#define  ATT_MACHINE_ROLE                   0x90047    // ATTj589895   (\x2A864886F714010447)
#define  ATT_MACHINE_WIDE_POLICY            0x901cb    // ATTk590283   (\x2A864886F7140104834B)
#define  ATT_MANAGED_BY                     0x9028d    // ATTb590477   (\x2A864886F7140104850D)
#define  ATT_MANAGED_OBJECTS                0x9028e    // ATTb590478   (\x2A864886F7140104850E)
#define  ATT_MANAGER                        0x15000a   // ATTb1376266  (\x0992268993F22C64010A)
#define  ATT_MAPI_ID                        0x20031    // ATTj131121   (\x2A864886F714010231)
#define  ATT_MARSHALLED_INTERFACE           0x90048    // ATTk589896   (\x2A864886F714010448)
#define  ATT_MASTERED_BY                    0x90581    // ATTb591233   (\x2A864886F71401048B01)
#define  ATT_MAX_PWD_AGE                    0x9004a    // ATTq589898   (\x2A864886F71401044A)
#define  ATT_MAX_RENEW_AGE                  0x9004b    // ATTq589899   (\x2A864886F71401044B)
#define  ATT_MAX_STORAGE                    0x9004c    // ATTq589900   (\x2A864886F71401044C)
#define  ATT_MAX_TICKET_AGE                 0x9004d    // ATTq589901   (\x2A864886F71401044D)
#define  ATT_MAY_CONTAIN                    0x20019    // ATTc131097   (\x2A864886F714010219)
#define  ATT_MEETINGADVERTISESCOPE          0x90246    // ATTm590406   (\x2A864886F71401048446)
#define  ATT_MEETINGAPPLICATION             0x9023d    // ATTm590397   (\x2A864886F7140104843D)
#define  ATT_MEETINGBANDWIDTH               0x9024d    // ATTj590413   (\x2A864886F7140104844D)
#define  ATT_MEETINGBLOB                    0x9024e    // ATTk590414   (\x2A864886F7140104844E)
#define  ATT_MEETINGCONTACTINFO             0x90242    // ATTm590402   (\x2A864886F71401048442)
#define  ATT_MEETINGDESCRIPTION             0x90237    // ATTm590391   (\x2A864886F71401048437)
#define  ATT_MEETINGENDTIME                 0x9024c    // ATTl590412   (\x2A864886F7140104844C)
#define  ATT_MEETINGID                      0x90235    // ATTm590389   (\x2A864886F71401048435)
#define  ATT_MEETINGIP                      0x90244    // ATTm590404   (\x2A864886F71401048444)
#define  ATT_MEETINGISENCRYPTED             0x90249    // ATTm590409   (\x2A864886F71401048449)
#define  ATT_MEETINGKEYWORD                 0x90238    // ATTm590392   (\x2A864886F71401048438)
#define  ATT_MEETINGLANGUAGE                0x9023e    // ATTm590398   (\x2A864886F7140104843E)
#define  ATT_MEETINGLOCATION                0x90239    // ATTm590393   (\x2A864886F71401048439)
#define  ATT_MEETINGMAXPARTICIPANTS         0x90240    // ATTj590400   (\x2A864886F71401048440)
#define  ATT_MEETINGNAME                    0x90236    // ATTm590390   (\x2A864886F71401048436)
#define  ATT_MEETINGORIGINATOR              0x90241    // ATTm590401   (\x2A864886F71401048441)
#define  ATT_MEETINGOWNER                   0x90243    // ATTm590403   (\x2A864886F71401048443)
#define  ATT_MEETINGPROTOCOL                0x9023a    // ATTm590394   (\x2A864886F7140104843A)
#define  ATT_MEETINGRATING                  0x90248    // ATTm590408   (\x2A864886F71401048448)
#define  ATT_MEETINGRECURRENCE              0x9024a    // ATTm590410   (\x2A864886F7140104844A)
#define  ATT_MEETINGSCOPE                   0x90245    // ATTm590405   (\x2A864886F71401048445)
#define  ATT_MEETINGSTARTTIME               0x9024b    // ATTl590411   (\x2A864886F7140104844B)
#define  ATT_MEETINGTYPE                    0x9023b    // ATTm590395   (\x2A864886F7140104843B)
#define  ATT_MEETINGURL                     0x90247    // ATTm590407   (\x2A864886F71401048447)
#define  ATT_MEMBER                         0x1f       // ATTb31       (\x55041F)
#define  ATT_MHS_OR_ADDRESS                 0x9028a    // ATTm590474   (\x2A864886F7140104850A)
#define  ATT_MIN_PWD_AGE                    0x9004e    // ATTq589902   (\x2A864886F71401044E)
#define  ATT_MIN_PWD_LENGTH                 0x9004f    // ATTj589903   (\x2A864886F71401044F)
#define  ATT_MIN_TICKET_AGE                 0x90050    // ATTq589904   (\x2A864886F714010450)
#define  ATT_MODIFIED_COUNT                 0x900a8    // ATTq589992   (\x2A864886F71401048128)
#define  ATT_MODIFIED_COUNT_AT_LAST_PROM    0x90051    // ATTq589905   (\x2A864886F714010451)
#define  ATT_MODIFY_TIME_STAMP              0x190002   // ATTl1638402  (\x551202)
#define  ATT_MONIKER                        0x90052    // ATTk589906   (\x2A864886F714010452)
#define  ATT_MONIKER_DISPLAY_NAME           0x90053    // ATTm589907   (\x2A864886F714010453)
#define  ATT_MOVE_TREE_STATE                0x90519    // ATTk591129   (\x2A864886F71401048A19)
#define  ATT_MS_COM_DEFAULTPARTITIONLINK    0x90593    // ATTb591251   (\x2A864886F71401048B13)
#define  ATT_MS_COM_OBJECTID                0x90594    // ATTk591252   (\x2A864886F71401048B14)
#define  ATT_MS_COM_PARTITIONLINK           0x9058f    // ATTb591247   (\x2A864886F71401048B0F)
#define  ATT_MS_COM_PARTITIONSETLINK        0x90590    // ATTb591248   (\x2A864886F71401048B10)
#define  ATT_MS_COM_USERLINK                0x90591    // ATTb591249   (\x2A864886F71401048B11)
#define  ATT_MS_COM_USERPARTITIONSETLINK    0x90592    // ATTb591250   (\x2A864886F71401048B12)
#define  ATT_MS_DS_ADDITIONAL_DNS_HOST_NAME 0x906b5    // ATTm591541   (\x2A864886F71401048D35)
#define  ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME 0x906b6    // ATTm591542   (\x2A864886F71401048D36)
#define  ATT_MS_DS_ALL_USERS_TRUST_QUOTA    0x906fd    // ATTj591613   (\x2A864886F71401048D7D)
#define  ATT_MS_DS_ALLOWED_DNS_SUFFIXES     0x906ae    // ATTm591534   (\x2A864886F71401048D2E)
#define  ATT_MS_DS_ALLOWED_TO_DELEGATE_TO   0x906fb    // ATTm591611   (\x2A864886F71401048D7B)
#define  ATT_MS_DS_AUXILIARY_CLASSES        0x905b2    // ATTc591282   (\x2A864886F71401048B32)
#define  ATT_MS_DS_APPROX_IMMED_SUBORDINATES 0x90685    // ATTj591493   (\x2A864886F71401048D05)
#define  ATT_MS_DS_BEHAVIOR_VERSION         0x905b3    // ATTj591283   (\x2A864886F71401048B33)
#define  ATT_MS_DS_CACHED_MEMBERSHIP        0x905a1    // ATTk591265   (\x2A864886F71401048B21)
#define  ATT_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP 0x905a2    // ATTq591266   (\x2A864886F71401048B22)
#define  ATT_MS_DS_CONSISTENCY_GUID         0x90550    // ATTk591184   (\x2A864886F71401048A50)
#define  ATT_MS_DS_CONSISTENCY_CHILD_COUNT  0x90551    // ATTj591185   (\x2A864886F71401048A51)
#define  ATT_MS_DS_CREATOR_SID              0x90582    // ATTr591234   (\x2A864886F71401048B02)
#define  ATT_MS_DS_DNSROOTALIAS             0x906b7    // ATTm591543   (\x2A864886F71401048D37)
#define  ATT_MS_DS_ENTRY_TIME_TO_DIE        0x90656    // ATTl591446   (\x2A864886F71401048C56)
#define  ATT_MS_DS_EXECUTESCRIPTPASSWORD    0x906f7    // ATTk591607   (\x2A864886F71401048D77)
#define  ATT_MS_DS_FILTER_CONTAINERS        0x906a7    // ATTm591527   (\x2A864886F71401048D27)
#define  ATT_MS_DS_HAS_INSTANTIATED_NCS     0x906ad    // ATTh591533   (\x2A864886F71401048D2D)
#define  ATT_MS_DS_INTID                    0x906b4    // ATTj591540   (\x2A864886F71401048D34)
#define  ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL 0x906f8    // ATTj591608   (\x2A864886F71401048D78)
#define  ATT_MS_DS_TRUST_FOREST_TRUST_INFO  0x906a6    // ATTk591526   (\x2A864886F71401048D26)
#define  ATT_MS_DS_MACHINE_ACCOUNT_QUOTA    0x90583    // ATTj591235   (\x2A864886F71401048B03)
#define  ATT_MS_DS_OTHER_SETTINGS           0x90655    // ATTm591445   (\x2A864886F71401048C55)
#define  ATT_MS_DS_NC_REPL_CURSORS          0x906a8    // ATTm591528   (\x2A864886F71401048D28)
#define  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS 0x906a9    // ATTm591529   (\x2A864886F71401048D29)
#define  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS 0x906aa    // ATTm591530   (\x2A864886F71401048D2A)
#define  ATT_MS_DS_NC_REPLICA_LOCATIONS     0x9067d    // ATTb591485   (\x2A864886F71401048C7D)
#define  ATT_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES 0x90699    // ATTm591513   (\x2A864886F71401048D19)
#define  ATT_MS_DS_PER_USER_TRUST_QUOTA     0x906fc    // ATTj591612   (\x2A864886F71401048D7C)
#define  ATT_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA 0x906fe    // ATTj591614   (\x2A864886F71401048D7E)
#define  ATT_MS_DS_PREFERRED_GC_SITE        0x905a4    // ATTb591268   (\x2A864886F71401048B24)
#define  ATT_MS_DS_REPL_ATTRIBUTE_META_DATA 0x906ab    // ATTm591531   (\x2A864886F71401048D2B)
#define  ATT_MS_DS_REPL_VALUE_META_DATA     0x906ac    // ATTm591532   (\x2A864886F71401048D2C)
#define  ATT_MS_DS_REPLICATES_NC_REASON     0x90580    // ATTh591232   (\x2A864886F71401048B00)
#define  ATT_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY 0x9067f    // ATTj591487   (\x2A864886F71401048C7F)
#define  ATT_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY 0x90680    // ATTj591488   (\x2A864886F71401048D00)
#define  ATT_MS_DS_REPLICATIONEPOCH         0x906b8    // ATTj591544   (\x2A864886F71401048D38)
#define  ATT_MS_DS_SCHEMA_EXTENSIONS        0x905a0    // ATTk591264   (\x2A864886F71401048B20)
#define  ATT_MS_DS_SD_REFERENCE_DOMAIN      0x906af    // ATTb591535   (\x2A864886F71401048D2F)
#define  ATT_MS_DS_SECURITY_GROUP_EXTRA_CLASSES 0x90698    // ATTm591512   (\x2A864886F71401048D18)
#define  ATT_MS_DS_SETTINGS                 0x906a1    // ATTm591521   (\x2A864886F71401048D21)
#define  ATT_MS_DS_SITE_AFFINITY            0x905a3    // ATTk591267   (\x2A864886F71401048B23)
#define  ATT_MS_DS_SPN_SUFFIXES             0x906b3    // ATTm591539   (\x2A864886F71401048D33)
#define  ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED 0x905b4    // ATTj591284   (\x2A864886F71401048B34)
#define  ATT_MS_DS_UPDATESCRIPT             0x906b9    // ATTm591545   (\x2A864886F71401048D39)
#define  ATT_MS_EXCH_ASSISTANT_NAME         0x201bc    // ATTm131516   (\x2A864886F7140102833C)
#define  ATT_MS_EXCH_LABELEDURI             0x20251    // ATTm131665   (\x2A864886F71401028451)
#define  ATT_MS_EXCH_OWNER_BL               0x20068    // ATTb131176   (\x2A864886F714010268)
#define  ATT_MS_FRS_HUB_MEMBER              0x9069d    // ATTb591517   (\x2A864886F71401048D1D)
#define  ATT_MS_FRS_TOPOLOGY_PREF           0x9069c    // ATTm591516   (\x2A864886F71401048D1C)
#define  ATT_MS_IIS_FTP_DIR                 0x906fa    // ATTm591610   (\x2A864886F71401048D7A)
#define  ATT_MS_IIS_FTP_ROOT                0x906f9    // ATTm591609   (\x2A864886F71401048D79)
#define  ATT_MS_MMS_DATA                    0x906bc    // ATTk591548   (\x2A864886F71401048D3C)
#define  ATT_MS_MMS_INDEX                   0x906bd    // ATTk591549   (\x2A864886F71401048D3D)
#define  ATT_MS_MMS_INDICE                  0x906be    // ATTk591550   (\x2A864886F71401048D3E)
#define  ATT_MS_MMS_XML                     0x906bf    // ATTm591551   (\x2A864886F71401048D3F)
#define  ATT_MS_MMS_JOIN_LINK               0x906c0    // ATTb591552   (\x2A864886F71401048D40)
#define  ATT_MS_MMS_LINEAGE                 0x906c1    // ATTk591553   (\x2A864886F71401048D41)
#define  ATT_MS_MMS_PROV_STATUS             0x906c2    // ATTm591554   (\x2A864886F71401048D42)
#define  ATT_MS_MMS_SYNC_STATUS             0x906c3    // ATTk591555   (\x2A864886F71401048D43)
#define  ATT_MS_MMS_PARTITION               0x906c4    // ATTm591556   (\x2A864886F71401048D44)
#define  ATT_MS_MMS_MA_STAGING_LINK         0x906c5    // ATTb591557   (\x2A864886F71401048D45)
#define  ATT_MS_MMS_MA_STAGING_BL           0x906c6    // ATTb591558   (\x2A864886F71401048D46)
#define  ATT_MS_MMS_PROVISIONING_LINK       0x906c7    // ATTb591559   (\x2A864886F71401048D47)
#define  ATT_MS_MMS_PROVISIONING_BL         0x906c8    // ATTb591560   (\x2A864886F71401048D48)
#define  ATT_MS_MMS_ASSOCIATED_LINK         0x906c9    // ATTb591561   (\x2A864886F71401048D49)
#define  ATT_MS_MMS_ASSOCIATED_BL           0x906ca    // ATTb591562   (\x2A864886F71401048D4A)
#define  ATT_MS_MMS_SCOPE_LINK              0x906cb    // ATTb591563   (\x2A864886F71401048D4B)
#define  ATT_MS_MMS_SCOPE_BL                0x906cc    // ATTb591564   (\x2A864886F71401048D4C)
#define  ATT_MS_MMS_CRITERIA                0x906cd    // ATTm591565   (\x2A864886F71401048D4D)
#define  ATT_MS_MMS_DOMAIN_CONTROLLER       0x906ce    // ATTb591566   (\x2A864886F71401048D4E)
#define  ATT_MS_MMS_SERVICE_NAME            0x906cf    // ATTm591567   (\x2A864886F71401048D4F)
#define  ATT_MS_MMS_INSTANCE_CONFIGURATION  0x906d0    // ATTm591568   (\x2A864886F71401048D50)
#define  ATT_MS_MMS_TOOLS_CONFIGURATION     0x906d1    // ATTm591569   (\x2A864886F71401048D51)
#define  ATT_MS_MMS_INSTANCE_RULE           0x906d2    // ATTm591570   (\x2A864886F71401048D52)
#define  ATT_MS_MMS_INSTALL_STATUS          0x906d3    // ATTm591571   (\x2A864886F71401048D53)
#define  ATT_MS_MMS_VERSION                 0x906d4    // ATTm591572   (\x2A864886F71401048D54)
#define  ATT_MS_MMS_CONNECTOR_SPACE         0x906d5    // ATTb591573   (\x2A864886F71401048D55)
#define  ATT_MS_MMS_SCOPE                   0x906d6    // ATTb591574   (\x2A864886F71401048D56)
#define  ATT_MS_MMS_INSTANCE_SCHEDULE       0x906d7    // ATTm591575   (\x2A864886F71401048D57)
#define  ATT_MS_MMS_INSTANCE_INFO           0x906d8    // ATTk591576   (\x2A864886F71401048D58)
#define  ATT_MS_MMS_MA_CONFIGURATION        0x906d9    // ATTm591577   (\x2A864886F71401048D59)
#define  ATT_MS_MMS_MA_CONFIGURATION_PRIVATE 0x906da    // ATTk591578   (\x2A864886F71401048D5A)
#define  ATT_MS_MMS_MA_SCHEMA               0x906db    // ATTm591579   (\x2A864886F71401048D5B)
#define  ATT_MS_MMS_MA_MAP                  0x906dc    // ATTm591580   (\x2A864886F71401048D5C)
#define  ATT_MS_MMS_MA_CAPABILITY           0x906dd    // ATTm591581   (\x2A864886F71401048D5D)
#define  ATT_MS_MMS_MA_EXECUTION_HISTORY    0x906de    // ATTm591582   (\x2A864886F71401048D5E)
#define  ATT_MS_MMS_MA_CATEGORY             0x906df    // ATTm591583   (\x2A864886F71401048D5F)
#define  ATT_MS_MMS_MA_AD_INFO              0x906e0    // ATTk591584   (\x2A864886F71401048D60)
#define  ATT_MS_MMS_MA_CD_INFO              0x906e1    // ATTk591585   (\x2A864886F71401048D61)
#define  ATT_MS_MMS_MA_PROCESS_INFO         0x906e2    // ATTk591586   (\x2A864886F71401048D62)
#define  ATT_MS_MMS_MA_SCRIPT_INFO          0x906e3    // ATTk591587   (\x2A864886F71401048D63)
#define  ATT_MS_MMS_MA_SYSTEM               0x906e4    // ATTk591588   (\x2A864886F71401048D64)
#define  ATT_MS_MMS_MA_SYNCHRONIZATION      0x906e5    // ATTk591589   (\x2A864886F71401048D65)
#define  ATT_MS_MMS_JOIN_BL                 0x906e6    // ATTb591590   (\x2A864886F71401048D66)
#define  ATT_MS_MMS_ANCHOR                  0x906e7    // ATTk591591   (\x2A864886F71401048D67)
#define  ATT_MS_MMS_EXPORT_KEY              0x906e8    // ATTk591592   (\x2A864886F71401048D68)
#define  ATT_MS_MMS_IMPORT_KEY              0x906e9    // ATTk591593   (\x2A864886F71401048D69)
#define  ATT_MS_MMS_STATE                   0x906ea    // ATTk591594   (\x2A864886F71401048D6A)
#define  ATT_MS_MMS_HOLOGRAM                0x906eb    // ATTk591595   (\x2A864886F71401048D6B)
#define  ATT_MS_MMS_DELTA_HOLOGRAM          0x906ec    // ATTk591596   (\x2A864886F71401048D6C)
#define  ATT_MS_MMS_PROVISIONING_CONFIGURATION 0x906ed    // ATTm591597   (\x2A864886F71401048D6D)
#define  ATT_MS_MMS_PROVISIONING_CONFIGURATION_PRIVATE 0x906ee    // ATTk591598   (\x2A864886F71401048D6E)
#define  ATT_MS_MMS_PROVISIONING_AD_INFO    0x906ef    // ATTk591599   (\x2A864886F71401048D6F)
#define  ATT_MS_MMS_PROVISIONING_SYSTEM     0x906f0    // ATTm591600   (\x2A864886F71401048D70)
#define  ATT_MS_MMS_PROVISIONING_STATUS_XML 0x906f1    // ATTm591601   (\x2A864886F71401048D71)
#define  ATT_MS_MMS_PROVISIONING_STATUS_BINARY 0x906f2    // ATTk591602   (\x2A864886F71401048D72)
#define  ATT_MS_PKI_CERT_TEMPLATE_OID       0x9059c    // ATTm591260   (\x2A864886F71401048B1C)
#define  ATT_MS_PKI_CERTIFICATE_APPLICATION_POLICY 0x9068a    // ATTm591498   (\x2A864886F71401048D0A)
#define  ATT_MS_PKI_CERTIFICATE_NAME_FLAG   0x90598    // ATTj591256   (\x2A864886F71401048B18)
#define  ATT_MS_PKI_CERTIFICATE_POLICY      0x9059f    // ATTm591263   (\x2A864886F71401048B1F)
#define  ATT_MS_PKI_ENROLLMENT_FLAG         0x90596    // ATTj591254   (\x2A864886F71401048B16)
#define  ATT_MS_PKI_MINIMAL_KEY_SIZE        0x90599    // ATTj591257   (\x2A864886F71401048B19)
#define  ATT_MS_PKI_OID_ATTRIBUTE           0x90687    // ATTj591495   (\x2A864886F71401048D07)
#define  ATT_MS_PKI_OID_CPS                 0x90688    // ATTm591496   (\x2A864886F71401048D08)
#define  ATT_MS_PKI_OID_LOCALIZEDNAME       0x906b0    // ATTm591536   (\x2A864886F71401048D30)
#define  ATT_MS_PKI_OID_USER_NOTICE         0x90689    // ATTm591497   (\x2A864886F71401048D09)
#define  ATT_MS_PKI_PRIVATE_KEY_FLAG        0x90597    // ATTj591255   (\x2A864886F71401048B17)
#define  ATT_MS_PKI_SUPERSEDE_TEMPLATES     0x9059d    // ATTm591261   (\x2A864886F71401048B1D)
#define  ATT_MS_PKI_TEMPLATE_MINOR_REVISION 0x9059b    // ATTj591259   (\x2A864886F71401048B1B)
#define  ATT_MS_PKI_TEMPLATE_SCHEMA_VERSION 0x9059a    // ATTj591258   (\x2A864886F71401048B1A)
#define  ATT_MS_PKI_RA_APPLICATION_POLICIES 0x9068b    // ATTm591499   (\x2A864886F71401048D0B)
#define  ATT_MS_PKI_RA_POLICIES             0x9059e    // ATTm591262   (\x2A864886F71401048B1E)
#define  ATT_MS_PKI_RA_SIGNATURE            0x90595    // ATTj591253   (\x2A864886F71401048B15)
#define  ATT_MS_RRAS_ATTRIBUTE              0x90374    // ATTm590708   (\x2A864886F71401048674)
#define  ATT_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY 0x90373    // ATTm590707   (\x2A864886F71401048673)
#define  ATT_MS_SQL_NAME                    0x90553    // ATTm591187   (\x2A864886F71401048A53)
#define  ATT_MS_SQL_REGISTEREDOWNER         0x90554    // ATTm591188   (\x2A864886F71401048A54)
#define  ATT_MS_SQL_CONTACT                 0x90555    // ATTm591189   (\x2A864886F71401048A55)
#define  ATT_MS_SQL_LOCATION                0x90556    // ATTm591190   (\x2A864886F71401048A56)
#define  ATT_MS_SQL_MEMORY                  0x90557    // ATTq591191   (\x2A864886F71401048A57)
#define  ATT_MS_SQL_BUILD                   0x90558    // ATTj591192   (\x2A864886F71401048A58)
#define  ATT_MS_SQL_SERVICEACCOUNT          0x90559    // ATTm591193   (\x2A864886F71401048A59)
#define  ATT_MS_SQL_CHARACTERSET            0x9055a    // ATTj591194   (\x2A864886F71401048A5A)
#define  ATT_MS_SQL_SORTORDER               0x9055b    // ATTm591195   (\x2A864886F71401048A5B)
#define  ATT_MS_SQL_UNICODESORTORDER        0x9055c    // ATTj591196   (\x2A864886F71401048A5C)
#define  ATT_MS_SQL_CLUSTERED               0x9055d    // ATTi591197   (\x2A864886F71401048A5D)
#define  ATT_MS_SQL_NAMEDPIPE               0x9055e    // ATTm591198   (\x2A864886F71401048A5E)
#define  ATT_MS_SQL_MULTIPROTOCOL           0x9055f    // ATTm591199   (\x2A864886F71401048A5F)
#define  ATT_MS_SQL_SPX                     0x90560    // ATTm591200   (\x2A864886F71401048A60)
#define  ATT_MS_SQL_TCPIP                   0x90561    // ATTm591201   (\x2A864886F71401048A61)
#define  ATT_MS_SQL_APPLETALK               0x90562    // ATTm591202   (\x2A864886F71401048A62)
#define  ATT_MS_SQL_VINES                   0x90563    // ATTm591203   (\x2A864886F71401048A63)
#define  ATT_MS_SQL_STATUS                  0x90564    // ATTq591204   (\x2A864886F71401048A64)
#define  ATT_MS_SQL_LASTUPDATEDDATE         0x90565    // ATTm591205   (\x2A864886F71401048A65)
#define  ATT_MS_SQL_INFORMATIONURL          0x90566    // ATTm591206   (\x2A864886F71401048A66)
#define  ATT_MS_SQL_CONNECTIONURL           0x90567    // ATTm591207   (\x2A864886F71401048A67)
#define  ATT_MS_SQL_PUBLICATIONURL          0x90568    // ATTm591208   (\x2A864886F71401048A68)
#define  ATT_MS_SQL_GPSLATITUDE             0x90569    // ATTm591209   (\x2A864886F71401048A69)
#define  ATT_MS_SQL_GPSLONGITUDE            0x9056a    // ATTm591210   (\x2A864886F71401048A6A)
#define  ATT_MS_SQL_GPSHEIGHT               0x9056b    // ATTm591211   (\x2A864886F71401048A6B)
#define  ATT_MS_SQL_VERSION                 0x9056c    // ATTm591212   (\x2A864886F71401048A6C)
#define  ATT_MS_SQL_LANGUAGE                0x9056d    // ATTm591213   (\x2A864886F71401048A6D)
#define  ATT_MS_SQL_DESCRIPTION             0x9056e    // ATTm591214   (\x2A864886F71401048A6E)
#define  ATT_MS_SQL_TYPE                    0x9056f    // ATTm591215   (\x2A864886F71401048A6F)
#define  ATT_MS_SQL_INFORMATIONDIRECTORY    0x90570    // ATTi591216   (\x2A864886F71401048A70)
#define  ATT_MS_SQL_DATABASE                0x90571    // ATTm591217   (\x2A864886F71401048A71)
#define  ATT_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION 0x90572    // ATTi591218   (\x2A864886F71401048A72)
#define  ATT_MS_SQL_ALIAS                   0x90573    // ATTm591219   (\x2A864886F71401048A73)
#define  ATT_MS_SQL_SIZE                    0x90574    // ATTq591220   (\x2A864886F71401048A74)
#define  ATT_MS_SQL_CREATIONDATE            0x90575    // ATTm591221   (\x2A864886F71401048A75)
#define  ATT_MS_SQL_LASTBACKUPDATE          0x90576    // ATTm591222   (\x2A864886F71401048A76)
#define  ATT_MS_SQL_LASTDIAGNOSTICDATE      0x90577    // ATTm591223   (\x2A864886F71401048A77)
#define  ATT_MS_SQL_APPLICATIONS            0x90578    // ATTm591224   (\x2A864886F71401048A78)
#define  ATT_MS_SQL_KEYWORDS                0x90579    // ATTm591225   (\x2A864886F71401048A79)
#define  ATT_MS_SQL_PUBLISHER               0x9057a    // ATTm591226   (\x2A864886F71401048A7A)
#define  ATT_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION 0x9057b    // ATTi591227   (\x2A864886F71401048A7B)
#define  ATT_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION 0x9057c    // ATTi591228   (\x2A864886F71401048A7C)
#define  ATT_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION 0x9057d    // ATTi591229   (\x2A864886F71401048A7D)
#define  ATT_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING 0x9057e    // ATTi591230   (\x2A864886F71401048A7E)
#define  ATT_MS_SQL_THIRDPARTY              0x9057f    // ATTi591231   (\x2A864886F71401048A7F)
#define  ATT_MS_TAPI_CONFERENCE_BLOB        0x906a4    // ATTk591524   (\x2A864886F71401048D24)
#define  ATT_MS_TAPI_IP_ADDRESS             0x906a5    // ATTm591525   (\x2A864886F71401048D25)
#define  ATT_MS_TAPI_PROTOCOL_ID            0x906a3    // ATTm591523   (\x2A864886F71401048D23)
#define  ATT_MS_TAPI_UNIQUE_IDENTIFIER      0x906a2    // ATTm591522   (\x2A864886F71401048D22)
#define  ATT_MS_WMI_AUTHOR                  0x90657    // ATTm591447   (\x2A864886F71401048C57)
#define  ATT_MS_WMI_CHANGEDATE              0x90658    // ATTm591448   (\x2A864886F71401048C58)
#define  ATT_MS_WMI_CLASS                   0x9068c    // ATTm591500   (\x2A864886F71401048D0C)
#define  ATT_MS_WMI_CLASSDEFINITION         0x90659    // ATTm591449   (\x2A864886F71401048C59)
#define  ATT_MS_WMI_CREATIONDATE            0x9065a    // ATTm591450   (\x2A864886F71401048C5A)
#define  ATT_MS_WMI_GENUS                   0x9068d    // ATTj591501   (\x2A864886F71401048D0D)
#define  ATT_MS_WMI_ID                      0x9065b    // ATTm591451   (\x2A864886F71401048C5B)
#define  ATT_MS_WMI_INTDEFAULT              0x9065c    // ATTj591452   (\x2A864886F71401048C5C)
#define  ATT_MS_WMI_INTFLAGS1               0x9068e    // ATTj591502   (\x2A864886F71401048D0E)
#define  ATT_MS_WMI_INTFLAGS2               0x9068f    // ATTj591503   (\x2A864886F71401048D0F)
#define  ATT_MS_WMI_INTFLAGS3               0x90690    // ATTj591504   (\x2A864886F71401048D10)
#define  ATT_MS_WMI_INTFLAGS4               0x90691    // ATTj591505   (\x2A864886F71401048D11)
#define  ATT_MS_WMI_INTMAX                  0x9065d    // ATTj591453   (\x2A864886F71401048C5D)
#define  ATT_MS_WMI_INTMIN                  0x9065e    // ATTj591454   (\x2A864886F71401048C5E)
#define  ATT_MS_WMI_INTVALIDVALUES          0x9065f    // ATTj591455   (\x2A864886F71401048C5F)
#define  ATT_MS_WMI_INT8DEFAULT             0x90660    // ATTq591456   (\x2A864886F71401048C60)
#define  ATT_MS_WMI_INT8MAX                 0x90661    // ATTq591457   (\x2A864886F71401048C61)
#define  ATT_MS_WMI_INT8MIN                 0x90662    // ATTq591458   (\x2A864886F71401048C62)
#define  ATT_MS_WMI_INT8VALIDVALUES         0x90663    // ATTq591459   (\x2A864886F71401048C63)
#define  ATT_MS_WMI_MOF                     0x90666    // ATTm591462   (\x2A864886F71401048C66)
#define  ATT_MS_WMI_NAME                    0x90667    // ATTm591463   (\x2A864886F71401048C67)
#define  ATT_MS_WMI_NORMALIZEDCLASS         0x90668    // ATTm591464   (\x2A864886F71401048C68)
#define  ATT_MS_WMI_PARM1                   0x90692    // ATTm591506   (\x2A864886F71401048D12)
#define  ATT_MS_WMI_PARM2                   0x90693    // ATTm591507   (\x2A864886F71401048D13)
#define  ATT_MS_WMI_PARM3                   0x90694    // ATTm591508   (\x2A864886F71401048D14)
#define  ATT_MS_WMI_PARM4                   0x90695    // ATTm591509   (\x2A864886F71401048D15)
#define  ATT_MS_WMI_PROPERTYNAME            0x90669    // ATTm591465   (\x2A864886F71401048C69)
#define  ATT_MS_WMI_QUERY                   0x9066a    // ATTm591466   (\x2A864886F71401048C6A)
#define  ATT_MS_WMI_QUERYLANGUAGE           0x9066b    // ATTm591467   (\x2A864886F71401048C6B)
#define  ATT_MS_WMI_SCOPEGUID               0x90696    // ATTm591510   (\x2A864886F71401048D16)
#define  ATT_MS_WMI_SOURCEORGANIZATION      0x9066c    // ATTm591468   (\x2A864886F71401048C6C)
#define  ATT_MS_WMI_STRINGDEFAULT           0x90664    // ATTm591460   (\x2A864886F71401048C64)
#define  ATT_MS_WMI_STRINGVALIDVALUES       0x90665    // ATTm591461   (\x2A864886F71401048C65)
#define  ATT_MS_WMI_TARGETCLASS             0x9066d    // ATTm591469   (\x2A864886F71401048C6D)
#define  ATT_MS_WMI_TARGETNAMESPACE         0x9066e    // ATTm591470   (\x2A864886F71401048C6E)
#define  ATT_MS_WMI_TARGETOBJECT            0x9066f    // ATTk591471   (\x2A864886F71401048C6F)
#define  ATT_MS_WMI_TARGETPATH              0x90670    // ATTm591472   (\x2A864886F71401048C70)
#define  ATT_MS_WMI_TARGETTYPE              0x90671    // ATTm591473   (\x2A864886F71401048C71)
#define  ATT_MSCOPE_ID                      0x902cc    // ATTf590540   (\x2A864886F7140104854C)
#define  ATT_MSI_FILE_LIST                  0x9029f    // ATTm590495   (\x2A864886F7140104851F)
#define  ATT_MSI_SCRIPT                     0x9032e    // ATTk590638   (\x2A864886F7140104862E)
#define  ATT_MSI_SCRIPT_NAME                0x9034d    // ATTm590669   (\x2A864886F7140104864D)
#define  ATT_MSI_SCRIPT_PATH                0x9000f    // ATTm589839   (\x2A864886F71401040F)
#define  ATT_MSI_SCRIPT_SIZE                0x9034e    // ATTj590670   (\x2A864886F7140104864E)
#define  ATT_MSMQ_AUTHENTICATE              0x9039b    // ATTi590747   (\x2A864886F7140104871B)
#define  ATT_MSMQ_BASE_PRIORITY             0x90398    // ATTj590744   (\x2A864886F71401048718)
#define  ATT_MSMQ_COMPUTER_TYPE             0x903a5    // ATTe590757   (\x2A864886F71401048725)
#define  ATT_MSMQ_COMPUTER_TYPE_EX          0x90589    // ATTm591241   (\x2A864886F71401048B09)
#define  ATT_MSMQ_COST                      0x903b2    // ATTj590770   (\x2A864886F71401048732)
#define  ATT_MSMQ_CSP_NAME                  0x903ac    // ATTe590764   (\x2A864886F7140104872C)
#define  ATT_MSMQ_DEPENDENT_CLIENT_SERVICE  0x904d7    // ATTi591063   (\x2A864886F71401048957)
#define  ATT_MSMQ_DEPENDENT_CLIENT_SERVICES 0x904ca    // ATTi591050   (\x2A864886F7140104894A)
#define  ATT_MSMQ_DIGESTS                   0x903b4    // ATTk590772   (\x2A864886F71401048734)
#define  ATT_MSMQ_DIGESTS_MIG               0x903c6    // ATTk590790   (\x2A864886F71401048746)
#define  ATT_MSMQ_DS_SERVICE                0x904d6    // ATTi591062   (\x2A864886F71401048956)
#define  ATT_MSMQ_DS_SERVICES               0x904cc    // ATTi591052   (\x2A864886F7140104894C)
#define  ATT_MSMQ_ENCRYPT_KEY               0x903a8    // ATTk590760   (\x2A864886F71401048728)
#define  ATT_MSMQ_FOREIGN                   0x903a6    // ATTi590758   (\x2A864886F71401048726)
#define  ATT_MSMQ_IN_ROUTING_SERVERS        0x903a1    // ATTb590753   (\x2A864886F71401048721)
#define  ATT_MSMQ_INTERVAL1                 0x9051c    // ATTj591132   (\x2A864886F71401048A1C)
#define  ATT_MSMQ_INTERVAL2                 0x9051d    // ATTj591133   (\x2A864886F71401048A1D)
#define  ATT_MSMQ_JOURNAL                   0x90396    // ATTi590742   (\x2A864886F71401048716)
#define  ATT_MSMQ_JOURNAL_QUOTA             0x90399    // ATTj590745   (\x2A864886F71401048719)
#define  ATT_MSMQ_LABEL                     0x9039a    // ATTe590746   (\x2A864886F7140104871A)
#define  ATT_MSMQ_LABEL_EX                  0x90587    // ATTm591239   (\x2A864886F71401048B07)
#define  ATT_MSMQ_LONG_LIVED                0x903ad    // ATTj590765   (\x2A864886F7140104872D)
#define  ATT_MSMQ_MIGRATED                  0x903b8    // ATTi590776   (\x2A864886F71401048738)
#define  ATT_MSMQ_MULTICAST_ADDRESS         0x906b2    // ATTm591538   (\x2A864886F71401048D32)
#define  ATT_MSMQ_NAME_STYLE                0x903ab    // ATTi590763   (\x2A864886F7140104872B)
#define  ATT_MSMQ_NT4_FLAGS                 0x903c4    // ATTj590788   (\x2A864886F71401048744)
#define  ATT_MSMQ_NT4_STUB                  0x903c0    // ATTj590784   (\x2A864886F71401048740)
#define  ATT_MSMQ_OS_TYPE                   0x903a7    // ATTj590759   (\x2A864886F71401048727)
#define  ATT_MSMQ_OUT_ROUTING_SERVERS       0x903a0    // ATTb590752   (\x2A864886F71401048720)
#define  ATT_MSMQ_OWNER_ID                  0x9039d    // ATTk590749   (\x2A864886F7140104871D)
#define  ATT_MSMQ_PREV_SITE_GATES           0x904c9    // ATTb591049   (\x2A864886F71401048949)
#define  ATT_MSMQ_PRIVACY_LEVEL             0x9039c    // ATTj590748   (\x2A864886F7140104871C)
#define  ATT_MSMQ_QM_ID                     0x903b7    // ATTk590775   (\x2A864886F71401048737)
#define  ATT_MSMQ_QUEUE_JOURNAL_QUOTA       0x903c3    // ATTj590787   (\x2A864886F71401048743)
#define  ATT_MSMQ_QUEUE_NAME_EXT            0x904db    // ATTm591067   (\x2A864886F7140104895B)
#define  ATT_MSMQ_QUEUE_QUOTA               0x903c2    // ATTj590786   (\x2A864886F71401048742)
#define  ATT_MSMQ_QUEUE_TYPE                0x90395    // ATTk590741   (\x2A864886F71401048715)
#define  ATT_MSMQ_QUOTA                     0x90397    // ATTj590743   (\x2A864886F71401048717)
#define  ATT_MSMQ_RECIPIENT_FORMATNAME      0x9069f    // ATTm591519   (\x2A864886F71401048D1F)
#define  ATT_MSMQ_ROUTING_SERVICE           0x904d5    // ATTi591061   (\x2A864886F71401048955)
#define  ATT_MSMQ_ROUTING_SERVICES          0x904cb    // ATTi591051   (\x2A864886F7140104894B)
#define  ATT_MSMQ_SECURED_SOURCE            0x906b1    // ATTi591537   (\x2A864886F71401048D31)
#define  ATT_MSMQ_SERVICE_TYPE              0x903a2    // ATTj590754   (\x2A864886F71401048722)
#define  ATT_MSMQ_SERVICES                  0x903b6    // ATTj590774   (\x2A864886F71401048736)
#define  ATT_MSMQ_SIGN_CERTIFICATES         0x903b3    // ATTk590771   (\x2A864886F71401048733)
#define  ATT_MSMQ_SIGN_CERTIFICATES_MIG     0x903c7    // ATTk590791   (\x2A864886F71401048747)
#define  ATT_MSMQ_SIGN_KEY                  0x903a9    // ATTk590761   (\x2A864886F71401048729)
#define  ATT_MSMQ_SITE_1                    0x903af    // ATTb590767   (\x2A864886F7140104872F)
#define  ATT_MSMQ_SITE_2                    0x903b0    // ATTb590768   (\x2A864886F71401048730)
#define  ATT_MSMQ_SITE_FOREIGN              0x903c1    // ATTi590785   (\x2A864886F71401048741)
#define  ATT_MSMQ_SITE_GATES                0x903b1    // ATTb590769   (\x2A864886F71401048731)
#define  ATT_MSMQ_SITE_GATES_MIG            0x9051e    // ATTb591134   (\x2A864886F71401048A1E)
#define  ATT_MSMQ_SITE_ID                   0x903b9    // ATTk590777   (\x2A864886F71401048739)
#define  ATT_MSMQ_SITE_NAME                 0x903c5    // ATTe590789   (\x2A864886F71401048745)
#define  ATT_MSMQ_SITE_NAME_EX              0x90588    // ATTm591240   (\x2A864886F71401048B08)
#define  ATT_MSMQ_SITES                     0x9039f    // ATTk590751   (\x2A864886F7140104871F)
#define  ATT_MSMQ_TRANSACTIONAL             0x9039e    // ATTi590750   (\x2A864886F7140104871E)
#define  ATT_MSMQ_USER_SID                  0x90539    // ATTk591161   (\x2A864886F71401048A39)
#define  ATT_MSMQ_VERSION                   0x903ae    // ATTj590766   (\x2A864886F7140104872E)
#define  ATT_MSNPALLOWDIALIN                0x9045f    // ATTi590943   (\x2A864886F7140104885F)
#define  ATT_MSNPCALLEDSTATIONID            0x90463    // ATTf590947   (\x2A864886F71401048863)
#define  ATT_MSNPCALLINGSTATIONID           0x90464    // ATTf590948   (\x2A864886F71401048864)
#define  ATT_MSNPSAVEDCALLINGSTATIONID      0x9046a    // ATTf590954   (\x2A864886F7140104886A)
#define  ATT_MSRADIUSCALLBACKNUMBER         0x90479    // ATTf590969   (\x2A864886F71401048879)
#define  ATT_MSRADIUSFRAMEDIPADDRESS        0x90481    // ATTj590977   (\x2A864886F71401048901)
#define  ATT_MSRADIUSFRAMEDROUTE            0x90486    // ATTf590982   (\x2A864886F71401048906)
#define  ATT_MSRADIUSSERVICETYPE            0x90493    // ATTj590995   (\x2A864886F71401048913)
#define  ATT_MSRASSAVEDCALLBACKNUMBER       0x904a5    // ATTf591013   (\x2A864886F71401048925)
#define  ATT_MSRASSAVEDFRAMEDIPADDRESS      0x904a6    // ATTj591014   (\x2A864886F71401048926)
#define  ATT_MSRASSAVEDFRAMEDROUTE          0x904a7    // ATTf591015   (\x2A864886F71401048927)
#define  ATT_MUST_CONTAIN                   0x20018    // ATTc131096   (\x2A864886F714010218)
#define  ATT_NAME_SERVICE_FLAGS             0x902f1    // ATTj590577   (\x2A864886F71401048571)
#define  ATT_NC_NAME                        0x20010    // ATTb131088   (\x2A864886F714010210)
#define  ATT_NETBIOS_NAME                   0x90057    // ATTm589911   (\x2A864886F714010457)
#define  ATT_NETBOOT_ALLOW_NEW_CLIENTS      0x90351    // ATTi590673   (\x2A864886F71401048651)
#define  ATT_NETBOOT_ANSWER_ONLY_VALID_CLIENTS 0x90356    // ATTi590678   (\x2A864886F71401048656)
#define  ATT_NETBOOT_ANSWER_REQUESTS        0x90355    // ATTi590677   (\x2A864886F71401048655)
#define  ATT_NETBOOT_CURRENT_CLIENT_COUNT   0x90354    // ATTj590676   (\x2A864886F71401048654)
#define  ATT_NETBOOT_GUID                   0x90167    // ATTk590183   (\x2A864886F71401048267)
#define  ATT_NETBOOT_INITIALIZATION         0x90166    // ATTm590182   (\x2A864886F71401048266)
#define  ATT_NETBOOT_INTELLIMIRROR_OSES     0x90359    // ATTm590681   (\x2A864886F71401048659)
#define  ATT_NETBOOT_LIMIT_CLIENTS          0x90352    // ATTi590674   (\x2A864886F71401048652)
#define  ATT_NETBOOT_LOCALLY_INSTALLED_OSES 0x9035b    // ATTm590683   (\x2A864886F7140104865B)
#define  ATT_NETBOOT_MACHINE_FILE_PATH      0x90169    // ATTm590185   (\x2A864886F71401048269)
#define  ATT_NETBOOT_MAX_CLIENTS            0x90353    // ATTj590675   (\x2A864886F71401048653)
#define  ATT_NETBOOT_MIRROR_DATA_FILE       0x904d9    // ATTm591065   (\x2A864886F71401048959)
#define  ATT_NETBOOT_NEW_MACHINE_NAMING_POLICY 0x90357    // ATTm590679   (\x2A864886F71401048657)
#define  ATT_NETBOOT_NEW_MACHINE_OU         0x90358    // ATTb590680   (\x2A864886F71401048658)
#define  ATT_NETBOOT_SCP_BL                 0x90360    // ATTb590688   (\x2A864886F71401048660)
#define  ATT_NETBOOT_SERVER                 0x9035c    // ATTb590684   (\x2A864886F7140104865C)
#define  ATT_NETBOOT_SIF_FILE               0x904d8    // ATTm591064   (\x2A864886F71401048958)
#define  ATT_NETBOOT_TOOLS                  0x9035a    // ATTm590682   (\x2A864886F7140104865A)
#define  ATT_NETWORK_ADDRESS                0x201cb    // ATTe131531   (\x2A864886F7140102834B)
#define  ATT_NEXT_LEVEL_STORE               0x900d6    // ATTb590038   (\x2A864886F71401048156)
#define  ATT_NEXT_RID                       0x90058    // ATTj589912   (\x2A864886F714010458)
#define  ATT_NON_SECURITY_MEMBER            0x90212    // ATTb590354   (\x2A864886F71401048412)
#define  ATT_NON_SECURITY_MEMBER_BL         0x90213    // ATTb590355   (\x2A864886F71401048413)
#define  ATT_NOTIFICATION_LIST              0x9012f    // ATTb590127   (\x2A864886F7140104822F)
#define  ATT_NT_GROUP_MEMBERS               0x90059    // ATTk589913   (\x2A864886F714010459)
#define  ATT_NT_MIXED_DOMAIN                0x90165    // ATTj590181   (\x2A864886F71401048265)
#define  ATT_NT_PWD_HISTORY                 0x9005e    // ATTk589918   (\x2A864886F71401045E)
#define  ATT_NT_SECURITY_DESCRIPTOR         0x20119    // ATTp131353   (\x2A864886F71401028219)
#define  ATT_OBJ_DIST_NAME                  0x31       // ATTb49       (\x550431)
#define  ATT_OBJECT_CATEGORY                0x9030e    // ATTb590606   (\x2A864886F7140104860E)
#define  ATT_OBJECT_CLASS                   0x0        // ATTc0        (\x550400)
#define  ATT_OBJECT_CLASS_CATEGORY          0x20172    // ATTj131442   (\x2A864886F71401028272)
#define  ATT_OBJECT_CLASSES                 0x180006   // ATTm1572870  (\x551506)
#define  ATT_OBJECT_COUNT                   0x901fa    // ATTj590330   (\x2A864886F7140104837A)
#define  ATT_OBJECT_GUID                    0x90002    // ATTk589826   (\x2A864886F714010402)
#define  ATT_OBJECT_SID                     0x90092    // ATTr589970   (\x2A864886F71401048112)
#define  ATT_OBJECT_VERSION                 0x2004c    // ATTj131148   (\x2A864886F71401024C)
#define  ATT_OEM_INFORMATION                0x90097    // ATTm589975   (\x2A864886F71401048117)
#define  ATT_OM_OBJECT_CLASS                0x200da    // ATTk131290   (\x2A864886F7140102815A)
#define  ATT_OM_SYNTAX                      0x200e7    // ATTj131303   (\x2A864886F71401028167)
#define  ATT_OMT_GUID                       0x901f9    // ATTk590329   (\x2A864886F71401048379)
#define  ATT_OMT_INDX_GUID                  0x9014d    // ATTk590157   (\x2A864886F7140104824D)
#define  ATT_OPERATING_SYSTEM               0x9016b    // ATTm590187   (\x2A864886F7140104826B)
#define  ATT_OPERATING_SYSTEM_HOTFIX        0x9019f    // ATTm590239   (\x2A864886F7140104831F)
#define  ATT_OPERATING_SYSTEM_SERVICE_PACK  0x9016d    // ATTm590189   (\x2A864886F7140104826D)
#define  ATT_OPERATING_SYSTEM_VERSION       0x9016c    // ATTm590188   (\x2A864886F7140104826C)
#define  ATT_OPERATOR_COUNT                 0x90090    // ATTj589968   (\x2A864886F71401048110)
#define  ATT_OPTION_DESCRIPTION             0x902c8    // ATTm590536   (\x2A864886F71401048548)
#define  ATT_OPTIONS                        0x90133    // ATTj590131   (\x2A864886F71401048233)
#define  ATT_OPTIONS_LOCATION               0x902c9    // ATTf590537   (\x2A864886F71401048549)
#define  ATT_ORGANIZATION_NAME              0xa        // ATTm10       (\x55040A)
#define  ATT_ORGANIZATIONAL_UNIT_NAME       0xb        // ATTm11       (\x55040B)
#define  ATT_ORIGINAL_DISPLAY_TABLE         0x201bd    // ATTk131517   (\x2A864886F7140102833D)
#define  ATT_ORIGINAL_DISPLAY_TABLE_MSDOS   0x200d6    // ATTk131286   (\x2A864886F71401028156)
#define  ATT_OTHER_LOGIN_WORKSTATIONS       0x9005b    // ATTm589915   (\x2A864886F71401045B)
#define  ATT_OTHER_MAILBOX                  0x9028b    // ATTm590475   (\x2A864886F7140104850B)
#define  ATT_OTHER_NAME                     0x160022   // ATTm1441826  (\x6086480186F842030122)
#define  ATT_OTHER_WELL_KNOWN_OBJECTS       0x9054f    // ATTh591183   (\x2A864886F71401048A4F)
#define  ATT_OWNER                          0x20       // ATTb32       (\x550420)
#define  ATT_PACKAGE_FLAGS                  0x90147    // ATTj590151   (\x2A864886F71401048247)
#define  ATT_PACKAGE_NAME                   0x90146    // ATTm590150   (\x2A864886F71401048246)
#define  ATT_PACKAGE_TYPE                   0x90144    // ATTj590148   (\x2A864886F71401048244)
#define  ATT_PARENT_CA                      0x9022d    // ATTb590381   (\x2A864886F7140104842D)
#define  ATT_PARENT_CA_CERTIFICATE_CHAIN    0x902ad    // ATTk590509   (\x2A864886F7140104852D)
#define  ATT_PARENT_GUID                    0x904c8    // ATTk591048   (\x2A864886F71401048948)
#define  ATT_PARTIAL_ATTRIBUTE_DELETION_LIST 0x90297    // ATTk590487   (\x2A864886F71401048517)
#define  ATT_PARTIAL_ATTRIBUTE_SET          0x90280    // ATTk590464   (\x2A864886F71401048500)
#define  ATT_PEK_KEY_CHANGE_INTERVAL        0x90362    // ATTq590690   (\x2A864886F71401048662)
#define  ATT_PEK_LIST                       0x90361    // ATTk590689   (\x2A864886F71401048661)
#define  ATT_PENDING_CA_CERTIFICATES        0x902b5    // ATTk590517   (\x2A864886F71401048535)
#define  ATT_PENDING_PARENT_CA              0x902b7    // ATTb590519   (\x2A864886F71401048537)
#define  ATT_PER_MSG_DIALOG_DISPLAY_TABLE   0x20145    // ATTk131397   (\x2A864886F71401028245)
#define  ATT_PER_RECIP_DIALOG_DISPLAY_TABLE 0x20146    // ATTk131398   (\x2A864886F71401028246)
#define  ATT_PERSONAL_TITLE                 0x20267    // ATTm131687   (\x2A864886F71401028467)
#define  ATT_PHONE_FAX_OTHER                0x90286    // ATTm590470   (\x2A864886F71401048506)
#define  ATT_PHONE_HOME_OTHER               0x20115    // ATTm131349   (\x2A864886F71401028215)
#define  ATT_PHONE_HOME_PRIMARY             0x150014   // ATTm1376276  (\x0992268993F22C640114)
#define  ATT_PHONE_IP_OTHER                 0x902d2    // ATTm590546   (\x2A864886F71401048552)
#define  ATT_PHONE_IP_PRIMARY               0x902d1    // ATTm590545   (\x2A864886F71401048551)
#define  ATT_PHONE_ISDN_PRIMARY             0x90289    // ATTm590473   (\x2A864886F71401048509)
#define  ATT_PHONE_MOBILE_OTHER             0x90287    // ATTm590471   (\x2A864886F71401048507)
#define  ATT_PHONE_MOBILE_PRIMARY           0x150029   // ATTm1376297  (\x0992268993F22C640129)
#define  ATT_PHONE_OFFICE_OTHER             0x20012    // ATTm131090   (\x2A864886F714010212)
#define  ATT_PHONE_PAGER_OTHER              0x20076    // ATTm131190   (\x2A864886F714010276)
#define  ATT_PHONE_PAGER_PRIMARY            0x15002a   // ATTm1376298  (\x0992268993F22C64012A)
#define  ATT_PHOTO                          0x150007   // ATTk1376263  (\x0992268993F22C640107)
#define  ATT_PHYSICAL_DELIVERY_OFFICE_NAME  0x13       // ATTm19       (\x550413)
#define  ATT_PHYSICAL_LOCATION_OBJECT       0x90202    // ATTb590338   (\x2A864886F71401048402)
#define  ATT_PICTURE                        0x160023   // ATTk1441827  (\x6086480186F842030123)
#define  ATT_PKI_CRITICAL_EXTENSIONS        0x90532    // ATTm591154   (\x2A864886F71401048A32)
#define  ATT_PKI_DEFAULT_CSPS               0x90536    // ATTm591158   (\x2A864886F71401048A36)
#define  ATT_PKI_DEFAULT_KEY_SPEC           0x9052f    // ATTj591151   (\x2A864886F71401048A2F)
#define  ATT_PKI_ENROLLMENT_ACCESS          0x90537    // ATTp591159   (\x2A864886F71401048A37)
#define  ATT_PKI_EXPIRATION_PERIOD          0x90533    // ATTk591155   (\x2A864886F71401048A33)
#define  ATT_PKI_EXTENDED_KEY_USAGE         0x90535    // ATTm591157   (\x2A864886F71401048A35)
#define  ATT_PKI_KEY_USAGE                  0x90530    // ATTk591152   (\x2A864886F71401048A30)
#define  ATT_PKI_MAX_ISSUING_DEPTH          0x90531    // ATTj591153   (\x2A864886F71401048A31)
#define  ATT_PKI_OVERLAP_PERIOD             0x90534    // ATTk591156   (\x2A864886F71401048A34)
#define  ATT_PKT                            0x900ce    // ATTk590030   (\x2A864886F7140104814E)
#define  ATT_PKT_GUID                       0x900cd    // ATTk590029   (\x2A864886F7140104814D)
#define  ATT_POLICY_REPLICATION_FLAGS       0x90279    // ATTj590457   (\x2A864886F71401048479)
#define  ATT_PORT_NAME                      0x900e4    // ATTm590052   (\x2A864886F71401048164)
#define  ATT_POSS_SUPERIORS                 0x20008    // ATTc131080   (\x2A864886F714010208)
#define  ATT_POSSIBLE_INFERIORS             0x90393    // ATTc590739   (\x2A864886F71401048713)
#define  ATT_POST_OFFICE_BOX                0x12       // ATTm18       (\x550412)
#define  ATT_POSTAL_ADDRESS                 0x10       // ATTm16       (\x550410)
#define  ATT_POSTAL_CODE                    0x11       // ATTm17       (\x550411)
#define  ATT_PREFERRED_DELIVERY_METHOD      0x1c       // ATTj28       (\x55041C)
#define  ATT_PREFERREDLANGUAGE              0x160027   // ATTm1441831  (\x6086480186F842030127)
#define  ATT_PREFERRED_OU                   0x90061    // ATTb589921   (\x2A864886F714010461)
#define  ATT_PREFIX_MAP                     0x9021a    // ATTk590362   (\x2A864886F7140104841A)
#define  ATT_PRESENTATION_ADDRESS           0x1d       // ATTn29       (\x55041D)
#define  ATT_PREVIOUS_CA_CERTIFICATES       0x902b4    // ATTk590516   (\x2A864886F71401048534)
#define  ATT_PREVIOUS_PARENT_CA             0x902b6    // ATTb590518   (\x2A864886F71401048536)
#define  ATT_PRIMARY_GROUP_ID               0x90062    // ATTj589922   (\x2A864886F714010462)
#define  ATT_PRIMARY_GROUP_TOKEN            0x90584    // ATTj591236   (\x2A864886F71401048B04)
#define  ATT_PRINT_ATTRIBUTES               0x900f7    // ATTj590071   (\x2A864886F71401048177)
#define  ATT_PRINT_BIN_NAMES                0x900ed    // ATTm590061   (\x2A864886F7140104816D)
#define  ATT_PRINT_COLLATE                  0x900f2    // ATTi590066   (\x2A864886F71401048172)
#define  ATT_PRINT_COLOR                    0x900f3    // ATTi590067   (\x2A864886F71401048173)
#define  ATT_PRINT_DUPLEX_SUPPORTED         0x9051f    // ATTi591135   (\x2A864886F71401048A1F)
#define  ATT_PRINT_END_TIME                 0x900ea    // ATTj590058   (\x2A864886F7140104816A)
#define  ATT_PRINT_FORM_NAME                0x900eb    // ATTm590059   (\x2A864886F7140104816B)
#define  ATT_PRINT_KEEP_PRINTED_JOBS        0x90113    // ATTi590099   (\x2A864886F71401048213)
#define  ATT_PRINT_LANGUAGE                 0x900f6    // ATTm590070   (\x2A864886F71401048176)
#define  ATT_PRINT_MAC_ADDRESS              0x90120    // ATTm590112   (\x2A864886F71401048220)
#define  ATT_PRINT_MAX_COPIES               0x900f1    // ATTj590065   (\x2A864886F71401048171)
#define  ATT_PRINT_MAX_RESOLUTION_SUPPORTED 0x900ee    // ATTj590062   (\x2A864886F7140104816E)
#define  ATT_PRINT_MAX_X_EXTENT             0x90115    // ATTj590101   (\x2A864886F71401048215)
#define  ATT_PRINT_MAX_Y_EXTENT             0x90116    // ATTj590102   (\x2A864886F71401048216)
#define  ATT_PRINT_MEDIA_READY              0x90121    // ATTm590113   (\x2A864886F71401048221)
#define  ATT_PRINT_MEDIA_SUPPORTED          0x9012b    // ATTm590123   (\x2A864886F7140104822B)
#define  ATT_PRINT_MEMORY                   0x9011a    // ATTj590106   (\x2A864886F7140104821A)
#define  ATT_PRINT_MIN_X_EXTENT             0x90117    // ATTj590103   (\x2A864886F71401048217)
#define  ATT_PRINT_MIN_Y_EXTENT             0x90118    // ATTj590104   (\x2A864886F71401048218)
#define  ATT_PRINT_NETWORK_ADDRESS          0x9011f    // ATTm590111   (\x2A864886F7140104821F)
#define  ATT_PRINT_NOTIFY                   0x90110    // ATTm590096   (\x2A864886F71401048210)
#define  ATT_PRINT_NUMBER_UP                0x90122    // ATTj590114   (\x2A864886F71401048222)
#define  ATT_PRINT_ORIENTATIONS_SUPPORTED   0x900f0    // ATTm590064   (\x2A864886F71401048170)
#define  ATT_PRINT_OWNER                    0x9010f    // ATTm590095   (\x2A864886F7140104820F)
#define  ATT_PRINT_PAGES_PER_MINUTE         0x90277    // ATTj590455   (\x2A864886F71401048477)
#define  ATT_PRINT_RATE                     0x9011d    // ATTj590109   (\x2A864886F7140104821D)
#define  ATT_PRINT_RATE_UNIT                0x9011e    // ATTm590110   (\x2A864886F7140104821E)
#define  ATT_PRINT_SEPARATOR_FILE           0x900e6    // ATTm590054   (\x2A864886F71401048166)
#define  ATT_PRINT_SHARE_NAME               0x9010e    // ATTm590094   (\x2A864886F7140104820E)
#define  ATT_PRINT_SPOOLING                 0x90112    // ATTm590098   (\x2A864886F71401048212)
#define  ATT_PRINT_STAPLING_SUPPORTED       0x90119    // ATTi590105   (\x2A864886F71401048219)
#define  ATT_PRINT_START_TIME               0x900e9    // ATTj590057   (\x2A864886F71401048169)
#define  ATT_PRINT_STATUS                   0x90111    // ATTm590097   (\x2A864886F71401048211)
#define  ATT_PRINTER_NAME                   0x9012c    // ATTm590124   (\x2A864886F7140104822C)
#define  ATT_PRIOR_SET_TIME                 0x90063    // ATTq589923   (\x2A864886F714010463)
#define  ATT_PRIOR_VALUE                    0x90064    // ATTk589924   (\x2A864886F714010464)
#define  ATT_PRIORITY                       0x900e7    // ATTj590055   (\x2A864886F71401048167)
#define  ATT_PRIVATE_KEY                    0x90065    // ATTk589925   (\x2A864886F714010465)
#define  ATT_PRIVILEGE_ATTRIBUTES           0x9027c    // ATTj590460   (\x2A864886F7140104847C)
#define  ATT_PRIVILEGE_DISPLAY_NAME         0x9027a    // ATTm590458   (\x2A864886F7140104847A)
#define  ATT_PRIVILEGE_HOLDER               0x9027d    // ATTb590461   (\x2A864886F7140104847D)
#define  ATT_PRIVILEGE_VALUE                0x9027b    // ATTq590459   (\x2A864886F7140104847B)
#define  ATT_PRODUCT_CODE                   0x90332    // ATTk590642   (\x2A864886F71401048632)
#define  ATT_PROFILE_PATH                   0x9008b    // ATTm589963   (\x2A864886F7140104810B)
#define  ATT_PROXIED_OBJECT_NAME            0x904e1    // ATTh591073   (\x2A864886F71401048961)
#define  ATT_PROXY_ADDRESSES                0x200d2    // ATTm131282   (\x2A864886F71401028152)
#define  ATT_PROXY_GENERATION_ENABLED       0x2020b    // ATTi131595   (\x2A864886F7140102840B)
#define  ATT_PROXY_LIFETIME                 0x90067    // ATTq589927   (\x2A864886F714010467)
#define  ATT_PUBLIC_KEY_POLICY              0x901a4    // ATTk590244   (\x2A864886F71401048324)
#define  ATT_PURPORTED_SEARCH               0x90376    // ATTm590710   (\x2A864886F71401048676)
#define  ATT_PWD_HISTORY_LENGTH             0x9005f    // ATTj589919   (\x2A864886F71401045F)
#define  ATT_PWD_LAST_SET                   0x90060    // ATTq589920   (\x2A864886F714010460)
#define  ATT_PWD_PROPERTIES                 0x9005d    // ATTj589917   (\x2A864886F71401045D)
#define  ATT_QUALITY_OF_SERVICE             0x901ca    // ATTj590282   (\x2A864886F7140104834A)
#define  ATT_QUERY_FILTER                   0x9054b    // ATTm591179   (\x2A864886F71401048A4B)
#define  ATT_QUERY_POLICY_BL                0x90260    // ATTb590432   (\x2A864886F71401048460)
#define  ATT_QUERY_POLICY_OBJECT            0x9025f    // ATTb590431   (\x2A864886F7140104845F)
#define  ATT_QUERYPOINT                     0x902a8    // ATTm590504   (\x2A864886F71401048528)
#define  ATT_RANGE_LOWER                    0x20022    // ATTj131106   (\x2A864886F714010222)
#define  ATT_RANGE_UPPER                    0x20023    // ATTj131107   (\x2A864886F714010223)
#define  ATT_RDN                            0x90001    // ATTm589825   (\x2A864886F714010401)
#define  ATT_RDN_ATT_ID                     0x2001a    // ATTc131098   (\x2A864886F71401021A)
#define  ATT_REGISTERED_ADDRESS             0x1a       // ATTk26       (\x55041A)
#define  ATT_REMOTE_SERVER_NAME             0x90069    // ATTm589929   (\x2A864886F714010469)
#define  ATT_REMOTE_SOURCE                  0x9006b    // ATTm589931   (\x2A864886F71401046B)
#define  ATT_REMOTE_SOURCE_TYPE             0x9006c    // ATTj589932   (\x2A864886F71401046C)
#define  ATT_REMOTE_STORAGE_GUID            0x90329    // ATTm590633   (\x2A864886F71401048629)
#define  ATT_REPL_PROPERTY_META_DATA        0x90003    // ATTk589827   (\x2A864886F714010403)
#define  ATT_REPL_TOPOLOGY_STAY_OF_EXECUTION 0x902a5    // ATTj590501   (\x2A864886F71401048525)
#define  ATT_REPL_UPTODATE_VECTOR           0x90004    // ATTk589828   (\x2A864886F714010404)
#define  ATT_REPLICA_SOURCE                 0x9006d    // ATTm589933   (\x2A864886F71401046D)
#define  ATT_REPORTS                        0x201b4    // ATTb131508   (\x2A864886F71401028334)
#define  ATT_REPL_INTERVAL                  0x90538    // ATTj591160   (\x2A864886F71401048A38)
#define  ATT_REPS_FROM                      0x2005b    // ATTk131163   (\x2A864886F71401025B)
#define  ATT_REPS_TO                        0x20053    // ATTk131155   (\x2A864886F714010253)
#define  ATT_REQUIRED_CATEGORIES            0x90141    // ATTk590145   (\x2A864886F71401048241)
#define  ATT_RETIRED_REPL_DSA_SIGNATURES    0x902a1    // ATTk590497   (\x2A864886F71401048521)
#define  ATT_TOKEN_GROUPS                   0x90515    // ATTr591125   (\x2A864886F71401048A15)
#define  ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL 0x9058a    // ATTr591242   (\x2A864886F71401048B0A)
#define  ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE  0x90517    // ATTr591127   (\x2A864886F71401048A17)
#define  ATT_REVISION                       0x90091    // ATTj589969   (\x2A864886F71401048111)
#define  ATT_RID                            0x90099    // ATTj589977   (\x2A864886F71401048119)
#define  ATT_RID_ALLOCATION_POOL            0x90173    // ATTq590195   (\x2A864886F71401048273)
#define  ATT_RID_AVAILABLE_POOL             0x90172    // ATTq590194   (\x2A864886F71401048272)
#define  ATT_RID_MANAGER_REFERENCE          0x90170    // ATTb590192   (\x2A864886F71401048270)
#define  ATT_RID_NEXT_RID                   0x90176    // ATTj590198   (\x2A864886F71401048276)
#define  ATT_RID_PREVIOUS_ALLOCATION_POOL   0x90174    // ATTq590196   (\x2A864886F71401048274)
#define  ATT_RID_SET_REFERENCES             0x9029d    // ATTb590493   (\x2A864886F7140104851D)
#define  ATT_RID_USED_POOL                  0x90175    // ATTq590197   (\x2A864886F71401048275)
#define  ATT_RIGHTS_GUID                    0x90154    // ATTm590164   (\x2A864886F71401048254)
#define  ATT_ROLE_OCCUPANT                  0x21       // ATTb33       (\x550421)
#define  ATT_ROOMNUMBER                     0x150006   // ATTm1376262  (\x0992268993F22C640106)
#define  ATT_ROOT_TRUST                     0x902a2    // ATTb590498   (\x2A864886F71401048522)
#define  ATT_RPC_NS_ANNOTATION              0x9016e    // ATTm590190   (\x2A864886F7140104826E)
#define  ATT_RPC_NS_BINDINGS                0x90071    // ATTm589937   (\x2A864886F714010471)
#define  ATT_RPC_NS_CODESET                 0x9016f    // ATTm590191   (\x2A864886F7140104826F)
#define  ATT_RPC_NS_ENTRY_FLAGS             0x902f2    // ATTj590578   (\x2A864886F71401048572)
#define  ATT_RPC_NS_GROUP                   0x90072    // ATTm589938   (\x2A864886F714010472)
#define  ATT_RPC_NS_INTERFACE_ID            0x90073    // ATTm589939   (\x2A864886F714010473)
#define  ATT_RPC_NS_OBJECT_ID               0x90138    // ATTm590136   (\x2A864886F71401048238)
#define  ATT_RPC_NS_PRIORITY                0x90075    // ATTj589941   (\x2A864886F714010475)
#define  ATT_RPC_NS_PROFILE_ENTRY           0x90076    // ATTm589942   (\x2A864886F714010476)
#define  ATT_RPC_NS_TRANSFER_SYNTAX         0x9013a    // ATTm590138   (\x2A864886F7140104823A)
#define  ATT_SAM_ACCOUNT_NAME               0x900dd    // ATTm590045   (\x2A864886F7140104815D)
#define  ATT_SAM_ACCOUNT_TYPE               0x9012e    // ATTj590126   (\x2A864886F7140104822E)
#define  ATT_SCHEDULE                       0x900d3    // ATTk590035   (\x2A864886F71401048153)
#define  ATT_SCHEMA_FLAGS_EX                0x90078    // ATTj589944   (\x2A864886F714010478)
#define  ATT_SCHEMA_ID_GUID                 0x90094    // ATTk589972   (\x2A864886F71401048114)
#define  ATT_SCHEMA_INFO                    0x9054e    // ATTk591182   (\x2A864886F71401048A4E)
#define  ATT_SCHEMA_UPDATE                  0x901e1    // ATTl590305   (\x2A864886F71401048361)
#define  ATT_SCHEMA_VERSION                 0x201d7    // ATTj131543   (\x2A864886F71401028357)
#define  ATT_SCOPE_FLAGS                    0x9054a    // ATTj591178   (\x2A864886F71401048A4A)
#define  ATT_SCRIPT_PATH                    0x9003e    // ATTm589886   (\x2A864886F71401043E)
#define  ATT_SD_RIGHTS_EFFECTIVE            0x90518    // ATTj591128   (\x2A864886F71401048A18)
#define  ATT_SEARCH_FLAGS                   0x2014e    // ATTj131406   (\x2A864886F7140102824E)
#define  ATT_SEARCH_GUIDE                   0xe        // ATTk14       (\x55040E)
#define  ATT_SECRETARY                      0x150015   // ATTb1376277  (\x0992268993F22C640115)
#define  ATT_SECURITY_IDENTIFIER            0x90079    // ATTr589945   (\x2A864886F714010479)
#define  ATT_SEE_ALSO                       0x22       // ATTb34       (\x550422)
#define  ATT_SEQ_NOTIFICATION               0x901f8    // ATTj590328   (\x2A864886F71401048378)
#define  ATT_SERIAL_NUMBER                  0x5        // ATTf5        (\x550405)
#define  ATT_SERVER_NAME                    0x900df    // ATTm590047   (\x2A864886F7140104815F)
#define  ATT_SERVER_REFERENCE               0x90203    // ATTb590339   (\x2A864886F71401048403)
#define  ATT_SERVER_REFERENCE_BL            0x90204    // ATTb590340   (\x2A864886F71401048404)
#define  ATT_SERVER_ROLE                    0x9009d    // ATTj589981   (\x2A864886F7140104811D)
#define  ATT_SERVER_STATE                   0x9009a    // ATTj589978   (\x2A864886F7140104811A)
#define  ATT_SERVICE_BINDING_INFORMATION    0x901fe    // ATTm590334   (\x2A864886F7140104837E)
#define  ATT_SERVICE_CLASS_ID               0x9007a    // ATTk589946   (\x2A864886F71401047A)
#define  ATT_SERVICE_CLASS_INFO             0x9007b    // ATTk589947   (\x2A864886F71401047B)
#define  ATT_SERVICE_CLASS_NAME             0x901fd    // ATTm590333   (\x2A864886F7140104837D)
#define  ATT_SERVICE_DNS_NAME               0x90291    // ATTm590481   (\x2A864886F71401048511)
#define  ATT_SERVICE_DNS_NAME_TYPE          0x90293    // ATTm590483   (\x2A864886F71401048513)
#define  ATT_SERVICE_INSTANCE_VERSION       0x900c7    // ATTk590023   (\x2A864886F71401048147)
#define  ATT_SERVICE_PRINCIPAL_NAME         0x90303    // ATTm590595   (\x2A864886F71401048603)
#define  ATT_SETUP_COMMAND                  0x90145    // ATTm590149   (\x2A864886F71401048245)
#define  ATT_SHELL_CONTEXT_MENU             0x90267    // ATTm590439   (\x2A864886F71401048467)
#define  ATT_SHELL_PROPERTY_PAGES           0x90233    // ATTm590387   (\x2A864886F71401048433)
#define  ATT_SHORT_SERVER_NAME              0x904b9    // ATTm591033   (\x2A864886F71401048939)
#define  ATT_SHOW_IN_ADDRESS_BOOK           0x90284    // ATTb590468   (\x2A864886F71401048504)
#define  ATT_SHOW_IN_ADVANCED_VIEW_ONLY     0x200a9    // ATTi131241   (\x2A864886F71401028129)
#define  ATT_SID_HISTORY                    0x90261    // ATTr590433   (\x2A864886F71401048461)
#define  ATT_SIGNATURE_ALGORITHMS           0x90338    // ATTm590648   (\x2A864886F71401048638)
#define  ATT_SITE_GUID                      0x9016a    // ATTk590186   (\x2A864886F7140104826A)
#define  ATT_SITE_LINK_LIST                 0x90336    // ATTb590646   (\x2A864886F71401048636)
#define  ATT_SITE_LIST                      0x90335    // ATTb590645   (\x2A864886F71401048635)
#define  ATT_SITE_OBJECT                    0x90200    // ATTb590336   (\x2A864886F71401048400)
#define  ATT_SITE_OBJECT_BL                 0x90201    // ATTb590337   (\x2A864886F71401048401)
#define  ATT_SITE_SERVER                    0x901ee    // ATTb590318   (\x2A864886F7140104836E)
#define  ATT_SMTP_MAIL_ADDRESS              0x90312    // ATTm590610   (\x2A864886F71401048612)
#define  ATT_SPN_MAPPINGS                   0x90543    // ATTm591171   (\x2A864886F71401048A43)
#define  ATT_STATE_OR_PROVINCE_NAME         0x8        // ATTm8        (\x550408)
#define  ATT_STREET_ADDRESS                 0x9        // ATTm9        (\x550409)
#define  ATT_STRUCTURAL_OBJECT_CLASS        0x180009   // ATTc1572873  (\x551509)
#define  ATT_SUB_CLASS_OF                   0x20015    // ATTc131093   (\x2A864886F714010215)
#define  ATT_SUB_REFS                       0x20007    // ATTb131079   (\x2A864886F714010207)
#define  ATT_SUBSCHEMASUBENTRY              0x19000a   // ATTb1638410  (\x55120A)
#define  ATT_SUPER_SCOPE_DESCRIPTION        0x902c7    // ATTm590535   (\x2A864886F71401048547)
#define  ATT_SUPER_SCOPES                   0x902c6    // ATTf590534   (\x2A864886F71401048546)
#define  ATT_SUPERIOR_DNS_ROOT              0x90214    // ATTm590356   (\x2A864886F71401048414)
#define  ATT_SUPPLEMENTAL_CREDENTIALS       0x9007d    // ATTk589949   (\x2A864886F71401047D)
#define  ATT_SUPPORTED_APPLICATION_CONTEXT  0x1e       // ATTk30       (\x55041E)
#define  ATT_SURNAME                        0x4        // ATTm4        (\x550404)
#define  ATT_SYNC_ATTRIBUTES                0x9029a    // ATTj590490   (\x2A864886F7140104851A)
#define  ATT_SYNC_MEMBERSHIP                0x90299    // ATTb590489   (\x2A864886F71401048519)
#define  ATT_SYNC_WITH_OBJECT               0x90298    // ATTb590488   (\x2A864886F71401048518)
#define  ATT_SYNC_WITH_SID                  0x9029b    // ATTr590491   (\x2A864886F7140104851B)
#define  ATT_SYSTEM_AUXILIARY_CLASS         0x900c6    // ATTc590022   (\x2A864886F71401048146)
#define  ATT_SYSTEM_FLAGS                   0x90177    // ATTj590199   (\x2A864886F71401048277)
#define  ATT_SYSTEM_MAY_CONTAIN             0x900c4    // ATTc590020   (\x2A864886F71401048144)
#define  ATT_SYSTEM_MUST_CONTAIN            0x900c5    // ATTc590021   (\x2A864886F71401048145)
#define  ATT_SYSTEM_ONLY                    0x900aa    // ATTi589994   (\x2A864886F7140104812A)
#define  ATT_SYSTEM_POSS_SUPERIORS          0x900c3    // ATTc590019   (\x2A864886F71401048143)
#define  ATT_TELEPHONE_NUMBER               0x14       // ATTm20       (\x550414)
#define  ATT_TELETEX_TERMINAL_IDENTIFIER    0x16       // ATTk22       (\x550416)
#define  ATT_TELEX_NUMBER                   0x15       // ATTk21       (\x550415)
#define  ATT_TELEX_PRIMARY                  0x90288    // ATTm590472   (\x2A864886F71401048508)
#define  ATT_TEMPLATE_ROOTS                 0x90542    // ATTb591170   (\x2A864886F71401048A42)
#define  ATT_TERMINAL_SERVER                0x90375    // ATTk590709   (\x2A864886F71401048675)
#define  ATT_TEXT_COUNTRY                   0x20083    // ATTm131203   (\x2A864886F71401028103)
#define  ATT_TEXT_ENCODED_OR_ADDRESS        0x150002   // ATTm1376258  (\x0992268993F22C640102)
#define  ATT_TIME_REFRESH                   0x901f7    // ATTq590327   (\x2A864886F71401048377)
#define  ATT_TIME_VOL_CHANGE                0x901f6    // ATTq590326   (\x2A864886F71401048376)
#define  ATT_TITLE                          0xc        // ATTm12       (\x55040C)
#define  ATT_TOMBSTONE_LIFETIME             0x20036    // ATTj131126   (\x2A864886F714010236)
#define  ATT_TRANSPORT_ADDRESS_ATTRIBUTE    0x9037f    // ATTc590719   (\x2A864886F7140104867F)
#define  ATT_TRANSPORT_DLL_NAME             0x90315    // ATTm590613   (\x2A864886F71401048615)
#define  ATT_TRANSPORT_TYPE                 0x90317    // ATTb590615   (\x2A864886F71401048617)
#define  ATT_TREAT_AS_LEAF                  0x90326    // ATTi590630   (\x2A864886F71401048626)
#define  ATT_TREE_NAME                      0x90294    // ATTm590484   (\x2A864886F71401048514)
#define  ATT_TRUST_ATTRIBUTES               0x901d6    // ATTj590294   (\x2A864886F71401048356)
#define  ATT_TRUST_AUTH_INCOMING            0x90081    // ATTk589953   (\x2A864886F71401048101)
#define  ATT_TRUST_AUTH_OUTGOING            0x90087    // ATTk589959   (\x2A864886F71401048107)
#define  ATT_TRUST_DIRECTION                0x90084    // ATTj589956   (\x2A864886F71401048104)
#define  ATT_TRUST_PARENT                   0x901d7    // ATTb590295   (\x2A864886F71401048357)
#define  ATT_TRUST_PARTNER                  0x90085    // ATTm589957   (\x2A864886F71401048105)
#define  ATT_TRUST_POSIX_OFFSET             0x90086    // ATTj589958   (\x2A864886F71401048106)
#define  ATT_TRUST_TYPE                     0x90088    // ATTj589960   (\x2A864886F71401048108)
#define  ATT_UAS_COMPAT                     0x9009b    // ATTj589979   (\x2A864886F7140104811B)
#define  ATT_UID                            0x150001   // ATTm1376257  (\x0992268993F22C640101)
#define  ATT_UNC_NAME                       0x90089    // ATTm589961   (\x2A864886F71401048109)
#define  ATT_UNICODE_PWD                    0x9005a    // ATTk589914   (\x2A864886F71401045A)
#define  ATT_UNIQUEMEMBER                   0x32       // ATTb50       (\x550432)
#define  ATT_UPGRADE_PRODUCT_CODE           0x9032d    // ATTk590637   (\x2A864886F7140104862D)
#define  ATT_UPN_SUFFIXES                   0x9037a    // ATTm590714   (\x2A864886F7140104867A)
#define  ATT_USER_ACCOUNT_CONTROL           0x90008    // ATTj589832   (\x2A864886F714010408)
#define  ATT_USER_CERT                      0x90285    // ATTk590469   (\x2A864886F71401048505)
#define  ATT_USER_COMMENT                   0x9009c    // ATTm589980   (\x2A864886F7140104811C)
#define  ATT_USER_PARAMETERS                0x9008a    // ATTm589962   (\x2A864886F7140104810A)
#define  ATT_USER_PASSWORD                  0x23       // ATTk35       (\x550423)
#define  ATT_USERPKCS12                     0x1600d8   // ATTk1442008  (\x6086480186F84203018158)
#define  ATT_USER_PRINCIPAL_NAME            0x90290    // ATTm590480   (\x2A864886F71401048510)
#define  ATT_USER_SHARED_FOLDER             0x902ef    // ATTm590575   (\x2A864886F7140104856F)
#define  ATT_USER_SHARED_FOLDER_OTHER       0x902f0    // ATTm590576   (\x2A864886F71401048570)
#define  ATT_USER_SMIME_CERTIFICATE         0x14008c   // ATTk1310860  (\x6086480186F84203810C)
#define  ATT_USER_WORKSTATIONS              0x90056    // ATTm589910   (\x2A864886F714010456)
#define  ATT_USN_CHANGED                    0x20078    // ATTq131192   (\x2A864886F714010278)
#define  ATT_USN_CREATED                    0x20013    // ATTq131091   (\x2A864886F714010213)
#define  ATT_USN_DSA_LAST_OBJ_REMOVED       0x2010b    // ATTq131339   (\x2A864886F7140102820B)
#define  ATT_USN_INTERSITE                  0x201d5    // ATTj131541   (\x2A864886F71401028355)
#define  ATT_USN_LAST_OBJ_REM               0x20079    // ATTq131193   (\x2A864886F714010279)
#define  ATT_USN_SOURCE                     0x90380    // ATTq590720   (\x2A864886F71401048700)
#define  ATT_VALID_ACCESSES                 0x9054c    // ATTj591180   (\x2A864886F71401048A4C)
#define  ATT_VENDOR                         0x900ff    // ATTm590079   (\x2A864886F7140104817F)
#define  ATT_VERSION_NUMBER                 0x9008d    // ATTj589965   (\x2A864886F7140104810D)
#define  ATT_VERSION_NUMBER_HI              0x90148    // ATTj590152   (\x2A864886F71401048248)
#define  ATT_VERSION_NUMBER_LO              0x90149    // ATTj590153   (\x2A864886F71401048249)
#define  ATT_VOL_TABLE_GUID                 0x90150    // ATTk590160   (\x2A864886F71401048250)
#define  ATT_VOL_TABLE_IDX_GUID             0x9014e    // ATTk590158   (\x2A864886F7140104824E)
#define  ATT_VOLUME_COUNT                   0x901fb    // ATTj590331   (\x2A864886F7140104837B)
#define  ATT_WBEM_PATH                      0x9012d    // ATTm590125   (\x2A864886F7140104822D)
#define  ATT_WELL_KNOWN_OBJECTS             0x9026a    // ATTh590442   (\x2A864886F7140104846A)
#define  ATT_WHEN_CHANGED                   0x20003    // ATTl131075   (\x2A864886F714010203)
#define  ATT_WHEN_CREATED                   0x20002    // ATTl131074   (\x2A864886F714010202)
#define  ATT_WINSOCK_ADDRESSES              0x9008e    // ATTk589966   (\x2A864886F7140104810E)
#define  ATT_WWW_HOME_PAGE                  0x201d0    // ATTm131536   (\x2A864886F71401028350)
#define  ATT_WWW_PAGE_OTHER                 0x902ed    // ATTm590573   (\x2A864886F7140104856D)
#define  ATT_X121_ADDRESS                   0x18       // ATTg24       (\x550418)
#define  ATT_X500UNIQUEIDENTIFIER           0x2d       // ATTk45       (\x55042D)
#define  ATT_X509_CERT                      0x24       // ATTk36       (\x550424)


//--------------------------------------
// CLASS MAPPINGS
//--------------------------------------
#define CLASS_ACS_POLICY                       655497 // 0xa0089    (\x2A864886F71401058109)
#define CLASS_ACS_RESOURCE_LIMITS              655551 // 0xa00bf    (\x2A864886F7140105813F)
#define CLASS_ACS_SUBNET                       655498 // 0xa008a    (\x2A864886F7140105810A)
#define CLASS_ADDRESS_BOOK_CONTAINER           655485 // 0xa007d    (\x2A864886F71401057D)
#define CLASS_ADDRESS_TEMPLATE                 196666 // 0x3003a    (\x2A864886F71401033A)
#define CLASS_APPLICATION_ENTITY                65548 // 0x1000c    (\x55060C)
#define CLASS_APPLICATION_PROCESS               65547 // 0x1000b    (\x55060B)
#define CLASS_APPLICATION_SETTINGS            1507377 // 0x170031   (\x2A864886F7140105B65831)
#define CLASS_APPLICATION_SITE_SETTINGS        655428 // 0xa0044    (\x2A864886F714010544)
#define CLASS_APPLICATION_VERSION              655576 // 0xa00d8    (\x2A864886F71401058158)
#define CLASS_ATTRIBUTE_SCHEMA                 196622 // 0x3000e    (\x2A864886F71401030E)
#define CLASS_BUILTIN_DOMAIN                   655364 // 0xa0004    (\x2A864886F714010504)
#define CLASS_CATEGORY_REGISTRATION            655434 // 0xa004a    (\x2A864886F71401054A)
#define CLASS_CERTIFICATION_AUTHORITY           65552 // 0x10010    (\x550610)
#define CLASS_CLASS_REGISTRATION               655370 // 0xa000a    (\x2A864886F71401050A)
#define CLASS_CLASS_SCHEMA                     196621 // 0x3000d    (\x2A864886F71401030D)
#define CLASS_CLASS_STORE                      655404 // 0xa002c    (\x2A864886F71401052C)
#define CLASS_COM_CONNECTION_POINT             655371 // 0xa000b    (\x2A864886F71401050B)
#define CLASS_COMPUTER                         196638 // 0x3001e    (\x2A864886F71401031E)
#define CLASS_CONFIGURATION                    655372 // 0xa000c    (\x2A864886F71401050C)
#define CLASS_CONNECTION_POINT                 655374 // 0xa000e    (\x2A864886F71401050E)
#define CLASS_CONTACT                          655375 // 0xa000f    (\x2A864886F71401050F)
#define CLASS_CONTAINER                        196631 // 0x30017    (\x2A864886F714010317)
#define CLASS_CONTROL_ACCESS_RIGHT             655437 // 0xa004d    (\x2A864886F71401054D)
#define CLASS_COUNTRY                           65538 // 0x10002    (\x550602)
#define CLASS_CRL_DISTRIBUTION_POINT            65555 // 0x10013    (\x550613)
#define CLASS_CROSS_REF                        196619 // 0x3000b    (\x2A864886F71401030B)
#define CLASS_CROSS_REF_CONTAINER             1507381 // 0x170035   (\x2A864886F7140105B65835)
#define CLASS_DEVICE                            65550 // 0x1000e    (\x55060E)
#define CLASS_DFS_CONFIGURATION                655402 // 0xa002a    (\x2A864886F71401052A)
#define CLASS_DHCP_CLASS                       655492 // 0xa0084    (\x2A864886F71401058104)
#define CLASS_DISPLAY_SPECIFIER                655444 // 0xa0054    (\x2A864886F714010554)
#define CLASS_DISPLAY_TEMPLATE                 196667 // 0x3003b    (\x2A864886F71401033B)
#define CLASS_DMD                              196617 // 0x30009    (\x2A864886F714010309)
#define CLASS_DNS_NODE                         655446 // 0xa0056    (\x2A864886F714010556)
#define CLASS_DNS_ZONE                         655445 // 0xa0055    (\x2A864886F714010555)
#define CLASS_DOMAIN                           655426 // 0xa0042    (\x2A864886F714010542)
#define CLASS_DOMAIN_DNS                       655427 // 0xa0043    (\x2A864886F714010543)
#define CLASS_DOMAIN_POLICY                    655378 // 0xa0012    (\x2A864886F714010512)
#define CLASS_DS_UI_SETTINGS                   655543 // 0xa00b7    (\x2A864886F71401058137)
#define CLASS_DSA                               65549 // 0x1000d    (\x55060D)
#define CLASS_FILE_LINK_TRACKING               655412 // 0xa0034    (\x2A864886F714010534)
#define CLASS_FILE_LINK_TRACKING_ENTRY         655419 // 0xa003b    (\x2A864886F71401053B)
#define CLASS_FOREIGN_SECURITY_PRINCIPAL       655436 // 0xa004c    (\x2A864886F71401054C)
#define CLASS_FT_DFS                           655403 // 0xa002b    (\x2A864886F71401052B)
#define CLASS_GROUP                            655368 // 0xa0008    (\x2A864886F714010508)
#define CLASS_GROUP_OF_NAMES                    65545 // 0x10009    (\x550609)
#define CLASS_GROUPOFUNIQUENAMES                65553 // 0x10011    (\x550611)
#define CLASS_GROUP_POLICY_CONTAINER           655517 // 0xa009d    (\x2A864886F7140105811D)
#define CLASS_INDEX_SERVER_CATALOG             655490 // 0xa0082    (\x2A864886F71401058102)
#define CLASS_INFRASTRUCTURE_UPDATE            655535 // 0xa00af    (\x2A864886F7140105812F)
#define CLASS_INTELLIMIRROR_GROUP              655512 // 0xa0098    (\x2A864886F71401058118)
#define CLASS_INTELLIMIRROR_SCP                655511 // 0xa0097    (\x2A864886F71401058117)
#define CLASS_INTER_SITE_TRANSPORT             655501 // 0xa008d    (\x2A864886F7140105810D)
#define CLASS_INTER_SITE_TRANSPORT_CONTAINER   655500 // 0xa008c    (\x2A864886F7140105810C)
#define CLASS_IPSEC_BASE                      1507384 // 0x170038   (\x2A864886F7140105B65838)
#define CLASS_IPSEC_FILTER                     655478 // 0xa0076    (\x2A864886F714010576)
#define CLASS_IPSEC_ISAKMP_POLICY              655480 // 0xa0078    (\x2A864886F714010578)
#define CLASS_IPSEC_NEGOTIATION_POLICY         655479 // 0xa0077    (\x2A864886F714010577)
#define CLASS_IPSEC_NFA                        655481 // 0xa0079    (\x2A864886F714010579)
#define CLASS_IPSEC_POLICY                     655458 // 0xa0062    (\x2A864886F714010562)
#define CLASS_LEAF                             655380 // 0xa0014    (\x2A864886F714010514)
#define CLASS_LICENSING_SITE_SETTINGS          655438 // 0xa004e    (\x2A864886F71401054E)
#define CLASS_LINK_TRACK_OBJECT_MOVE_TABLE     655451 // 0xa005b    (\x2A864886F71401055B)
#define CLASS_LINK_TRACK_OMT_ENTRY             655453 // 0xa005d    (\x2A864886F71401055D)
#define CLASS_LINK_TRACK_VOL_ENTRY             655452 // 0xa005c    (\x2A864886F71401055C)
#define CLASS_LINK_TRACK_VOLUME_TABLE          655450 // 0xa005a    (\x2A864886F71401055A)
#define CLASS_LOCALITY                          65539 // 0x10003    (\x550603)
#define CLASS_LOST_AND_FOUND                   655499 // 0xa008b    (\x2A864886F7140105810B)
#define CLASS_MAIL_RECIPIENT                   196654 // 0x3002e    (\x2A864886F71401032E)
#define CLASS_MEETING                          655464 // 0xa0068    (\x2A864886F714010568)
#define CLASS_MS_COM_PARTITION                 655553 // 0xa00c1    (\x2A864886F71401058141)
#define CLASS_MS_COM_PARTITIONSET              655554 // 0xa00c2    (\x2A864886F71401058142)
#define CLASS_MS_DS_APP_CONFIGURATION          655580 // 0xa00dc    (\x2A864886F7140105815C)
#define CLASS_MS_EXCH_CONFIGURATION_CONTAINER   655536 // 0xa00b0    (\x2A864886F71401058130)
#define CLASS_MS_MMS_MANAGEMENT_AGENT          655586 // 0xa00e2    (\x2A864886F71401058162)
#define CLASS_MS_MMS_INSTANCE                  655585 // 0xa00e1    (\x2A864886F71401058161)
#define CLASS_MS_MMS_OBJECT                    655584 // 0xa00e0    (\x2A864886F71401058160)
#define CLASS_MS_MMS_MANAGEMENT_AGENT_HISTORY   655587 // 0xa00e3    (\x2A864886F71401058163)
#define CLASS_MS_MMS_CONNECTOR                 655588 // 0xa00e4    (\x2A864886F71401058164)
#define CLASS_MS_MMS_PROVISIONING_SERVICE      655589 // 0xa00e5    (\x2A864886F71401058165)
#define CLASS_MS_MMS_PROVISIONING_SERVICE_HISTORY   655590 // 0xa00e6    (\x2A864886F71401058166)
#define CLASS_MS_MMS_WORKFLOW                  655591 // 0xa00e7    (\x2A864886F71401058167)
#define CLASS_MS_MMS_PROVISIONING_STATUS       655592 // 0xa00e8    (\x2A864886F71401058168)
#define CLASS_MS_MMS_EVENT_ASSOCIATION         655593 // 0xa00e9    (\x2A864886F71401058169)
#define CLASS_MS_PKI_ENTERPRISE_OID            655556 // 0xa00c4    (\x2A864886F71401058144)
#define CLASS_MS_PKI_KEY_RECOVERY_AGENT        655555 // 0xa00c3    (\x2A864886F71401058143)
#define CLASS_MS_SQL_SQLSERVER                 655544 // 0xa00b8    (\x2A864886F71401058138)
#define CLASS_MS_SQL_OLAPSERVER                655545 // 0xa00b9    (\x2A864886F71401058139)
#define CLASS_MS_SQL_SQLREPOSITORY             655546 // 0xa00ba    (\x2A864886F7140105813A)
#define CLASS_MS_SQL_SQLPUBLICATION            655547 // 0xa00bb    (\x2A864886F7140105813B)
#define CLASS_MS_SQL_SQLDATABASE               655548 // 0xa00bc    (\x2A864886F7140105813C)
#define CLASS_MS_SQL_OLAPDATABASE              655549 // 0xa00bd    (\x2A864886F7140105813D)
#define CLASS_MS_SQL_OLAPCUBE                  655550 // 0xa00be    (\x2A864886F7140105813E)
#define CLASS_MS_TAPI_RT_CONFERENCE            655581 // 0xa00dd    (\x2A864886F7140105815D)
#define CLASS_MS_TAPI_RT_PERSON                655582 // 0xa00de    (\x2A864886F7140105815E)
#define CLASS_MS_WMI_INTRANGEPARAM             655565 // 0xa00cd    (\x2A864886F7140105814D)
#define CLASS_MS_WMI_INTSETPARAM               655566 // 0xa00ce    (\x2A864886F7140105814E)
#define CLASS_MS_WMI_MERGEABLEPOLICYTEMPLATE   655562 // 0xa00ca    (\x2A864886F7140105814A)
#define CLASS_MS_WMI_OBJECTENCODING            655577 // 0xa00d9    (\x2A864886F71401058159)
#define CLASS_MS_WMI_POLICYTEMPLATE            655560 // 0xa00c8    (\x2A864886F71401058148)
#define CLASS_MS_WMI_POLICYTYPE                655571 // 0xa00d3    (\x2A864886F71401058153)
#define CLASS_MS_WMI_RANGEPARAM                655563 // 0xa00cb    (\x2A864886F7140105814B)
#define CLASS_MS_WMI_REALRANGEPARAM            655569 // 0xa00d1    (\x2A864886F71401058151)
#define CLASS_MS_WMI_RULE                      655574 // 0xa00d6    (\x2A864886F71401058156)
#define CLASS_MS_WMI_SHADOWOBJECT              655572 // 0xa00d4    (\x2A864886F71401058154)
#define CLASS_MS_WMI_SIMPLEPOLICYTEMPLATE      655561 // 0xa00c9    (\x2A864886F71401058149)
#define CLASS_MS_WMI_SOM                       655573 // 0xa00d5    (\x2A864886F71401058155)
#define CLASS_MS_WMI_STRINGSETPARAM            655570 // 0xa00d2    (\x2A864886F71401058152)
#define CLASS_MS_WMI_UINTRANGEPARAM            655567 // 0xa00cf    (\x2A864886F7140105814F)
#define CLASS_MS_WMI_UINTSETPARAM              655568 // 0xa00d0    (\x2A864886F71401058150)
#define CLASS_MS_WMI_UNKNOWNRANGEPARAM         655564 // 0xa00cc    (\x2A864886F7140105814C)
#define CLASS_MS_WMI_WMIGPO                    655575 // 0xa00d7    (\x2A864886F71401058157)
#define CLASS_MSMQ_CONFIGURATION               655522 // 0xa00a2    (\x2A864886F71401058122)
#define CLASS_MSMQ_CUSTOM_RECIPIENT            655578 // 0xa00da    (\x2A864886F7140105815A)
#define CLASS_MSMQ_ENTERPRISE_SETTINGS         655523 // 0xa00a3    (\x2A864886F71401058123)
#define CLASS_MSMQ_GROUP                       655579 // 0xa00db    (\x2A864886F7140105815B)
#define CLASS_MSMQ_MIGRATED_USER               655539 // 0xa00b3    (\x2A864886F71401058133)
#define CLASS_MSMQ_QUEUE                       655521 // 0xa00a1    (\x2A864886F71401058121)
#define CLASS_MSMQ_SETTINGS                    655525 // 0xa00a5    (\x2A864886F71401058125)
#define CLASS_MSMQ_SITE_LINK                   655524 // 0xa00a4    (\x2A864886F71401058124)
#define CLASS_NTDS_CONNECTION                  655431 // 0xa0047    (\x2A864886F714010547)
#define CLASS_NTDS_DSA                        1507375 // 0x17002f   (\x2A864886F7140105B6582F)
#define CLASS_NTDS_SERVICE                     655432 // 0xa0048    (\x2A864886F714010548)
#define CLASS_NTDS_SITE_SETTINGS               655429 // 0xa0045    (\x2A864886F714010545)
#define CLASS_NTFRS_MEMBER                     655513 // 0xa0099    (\x2A864886F71401058119)
#define CLASS_NTFRS_REPLICA_SET                655462 // 0xa0066    (\x2A864886F714010566)
#define CLASS_NTFRS_SETTINGS                   655449 // 0xa0059    (\x2A864886F714010559)
#define CLASS_NTFRS_SUBSCRIBER                 655515 // 0xa009b    (\x2A864886F7140105811B)
#define CLASS_NTFRS_SUBSCRIPTIONS              655514 // 0xa009a    (\x2A864886F7140105811A)
#define CLASS_ORGANIZATION                      65540 // 0x10004    (\x550604)
#define CLASS_ORGANIZATIONAL_PERSON             65543 // 0x10007    (\x550607)
#define CLASS_ORGANIZATIONAL_ROLE               65544 // 0x10008    (\x550608)
#define CLASS_ORGANIZATIONAL_UNIT               65541 // 0x10005    (\x550605)
#define CLASS_PACKAGE_REGISTRATION             655409 // 0xa0031    (\x2A864886F714010531)
#define CLASS_PERSON                            65542 // 0x10006    (\x550606)
#define CLASS_PHYSICAL_LOCATION                655457 // 0xa0061    (\x2A864886F714010561)
#define CLASS_PKI_CERTIFICATE_TEMPLATE         655537 // 0xa00b1    (\x2A864886F71401058131)
#define CLASS_PKI_ENROLLMENT_SERVICE           655538 // 0xa00b2    (\x2A864886F71401058132)
#define CLASS_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT   655583 // 0xa00df    (\x2A864886F7140105815F)
#define CLASS_PRINT_QUEUE                      655383 // 0xa0017    (\x2A864886F714010517)
#define CLASS_QUERY_POLICY                     655466 // 0xa006a    (\x2A864886F71401056A)
#define CLASS_REMOTE_MAIL_RECIPIENT            655384 // 0xa0018    (\x2A864886F714010518)
#define CLASS_REMOTE_STORAGE_SERVICE_POINT     655506 // 0xa0092    (\x2A864886F71401058112)
#define CLASS_RESIDENTIAL_PERSON                65546 // 0x1000a    (\x55060A)
#define CLASS_RID_MANAGER                      655443 // 0xa0053    (\x2A864886F714010553)
#define CLASS_RID_SET                          655489 // 0xa0081    (\x2A864886F71401058101)
#define CLASS_RPC_CONTAINER                    655496 // 0xa0088    (\x2A864886F71401058108)
#define CLASS_RPC_ENTRY                        655387 // 0xa001b    (\x2A864886F71401051B)
#define CLASS_RPC_GROUP                        655440 // 0xa0050    (\x2A864886F714010550)
#define CLASS_RPC_PROFILE                      655442 // 0xa0052    (\x2A864886F714010552)
#define CLASS_RPC_PROFILE_ELEMENT              655386 // 0xa001a    (\x2A864886F71401051A)
#define CLASS_RPC_SERVER                       655441 // 0xa0051    (\x2A864886F714010551)
#define CLASS_RPC_SERVER_ELEMENT               655433 // 0xa0049    (\x2A864886F714010549)
#define CLASS_RRAS_ADMINISTRATION_CONNECTION_POINT   655510 // 0xa0096    (\x2A864886F71401058116)
#define CLASS_RRAS_ADMINISTRATION_DICTIONARY   655516 // 0xa009c    (\x2A864886F7140105811C)
#define CLASS_SAM_DOMAIN                       655363 // 0xa0003    (\x2A864886F714010503)
#define CLASS_SAM_DOMAIN_BASE                  655362 // 0xa0002    (\x2A864886F714010502)
#define CLASS_SAM_SERVER                       655365 // 0xa0005    (\x2A864886F714010505)
#define CLASS_SECRET                           655388 // 0xa001c    (\x2A864886F71401051C)
#define CLASS_SECURITY_OBJECT                  655361 // 0xa0001    (\x2A864886F714010501)
#define CLASS_SECURITY_PRINCIPAL               655366 // 0xa0006    (\x2A864886F714010506)
#define CLASS_SERVER                           655377 // 0xa0011    (\x2A864886F714010511)
#define CLASS_SERVERS_CONTAINER               1507376 // 0x170030   (\x2A864886F7140105B65830)
#define CLASS_SERVICE_ADMINISTRATION_POINT     655454 // 0xa005e    (\x2A864886F71401055E)
#define CLASS_SERVICE_CLASS                    655389 // 0xa001d    (\x2A864886F71401051D)
#define CLASS_SERVICE_CONNECTION_POINT         655486 // 0xa007e    (\x2A864886F71401057E)
#define CLASS_SERVICE_INSTANCE                 655390 // 0xa001e    (\x2A864886F71401051E)
#define CLASS_SITE                             655391 // 0xa001f    (\x2A864886F71401051F)
#define CLASS_SITE_LINK                        655507 // 0xa0093    (\x2A864886F71401058113)
#define CLASS_SITE_LINK_BRIDGE                 655508 // 0xa0094    (\x2A864886F71401058114)
#define CLASS_SITES_CONTAINER                  655467 // 0xa006b    (\x2A864886F71401056B)
#define CLASS_STORAGE                          655393 // 0xa0021    (\x2A864886F714010521)
#define CLASS_SUBNET                           655456 // 0xa0060    (\x2A864886F714010560)
#define CLASS_SUBNET_CONTAINER                 655455 // 0xa005f    (\x2A864886F71401055F)
#define CLASS_SUBSCHEMA                       1703937 // 0x1a0001   (\x551401)
#define CLASS_TOP                               65536 // 0x10000    (\x550600)
#define CLASS_TRUSTED_DOMAIN                   655394 // 0xa0022    (\x2A864886F714010522)
#define CLASS_TYPE_LIBRARY                     655413 // 0xa0035    (\x2A864886F714010535)
#define CLASS_USER                             655369 // 0xa0009    (\x2A864886F714010509)
#define CLASS_VOLUME                           655396 // 0xa0024    (\x2A864886F714010524)


//--------------------------------------
// ATTRIBUTE Syntax
//--------------------------------------
#define  SYNTAX_ID_ACCOUNT_EXPIRES                      16 // 0x41      
#define  SYNTAX_ID_ACCOUNT_NAME_HISTORY                 12 // 0x40      
#define  SYNTAX_ID_ACS_AGGREGATE_TOKEN_RATE_PER_USER       16 // 0x41      
#define  SYNTAX_ID_ACS_ALLOCABLE_RSVP_BANDWIDTH         16 // 0x41      
#define  SYNTAX_ID_ACS_CACHE_TIMEOUT                     9 // 0x2       
#define  SYNTAX_ID_ACS_DIRECTION                         9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_DEADTIME                     9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_PRIORITY                     9 // 0x2       
#define  SYNTAX_ID_ACS_DSBM_REFRESH                      9 // 0x2       
#define  SYNTAX_ID_ACS_ENABLE_ACS_SERVICE                8 // 0x1       
#define  SYNTAX_ID_ACS_ENABLE_RSVP_ACCOUNTING            8 // 0x1       
#define  SYNTAX_ID_ACS_ENABLE_RSVP_MESSAGE_LOGGING        8 // 0x1       
#define  SYNTAX_ID_ACS_EVENT_LOG_LEVEL                   9 // 0x2       
#define  SYNTAX_ID_ACS_IDENTITY_NAME                    12 // 0x40      
#define  SYNTAX_ID_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER       16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_DURATION_PER_FLOW             9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_NO_OF_ACCOUNT_FILES           9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_NO_OF_LOG_FILES               9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_PEAK_BANDWIDTH               16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW       16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_SIZE_OF_RSVP_LOG_FILE         9 // 0x2       
#define  SYNTAX_ID_ACS_MAX_TOKEN_BUCKET_PER_FLOW        16 // 0x41      
#define  SYNTAX_ID_ACS_MAX_TOKEN_RATE_PER_FLOW          16 // 0x41      
#define  SYNTAX_ID_ACS_MAXIMUM_SDU_SIZE                 16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_DELAY_VARIATION          16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_LATENCY                  16 // 0x41      
#define  SYNTAX_ID_ACS_MINIMUM_POLICED_SIZE             16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_MAX_SDU_SIZE        16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_MIN_POLICED_SIZE       16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_PEAK_RATE           16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TOKEN_SIZE          16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TX_LIMIT            16 // 0x41      
#define  SYNTAX_ID_ACS_NON_RESERVED_TX_SIZE             16 // 0x41      
#define  SYNTAX_ID_ACS_PERMISSION_BITS                  16 // 0x41      
#define  SYNTAX_ID_ACS_POLICY_NAME                      12 // 0x40      
#define  SYNTAX_ID_ACS_PRIORITY                          9 // 0x2       
#define  SYNTAX_ID_ACS_RSVP_ACCOUNT_FILES_LOCATION       12 // 0x40      
#define  SYNTAX_ID_ACS_RSVP_LOG_FILES_LOCATION          12 // 0x40      
#define  SYNTAX_ID_ACS_SERVICE_TYPE                      9 // 0x2       
#define  SYNTAX_ID_ACS_TIME_OF_DAY                      12 // 0x40      
#define  SYNTAX_ID_ACS_TOTAL_NO_OF_FLOWS                 9 // 0x2       
#define  SYNTAX_ID_ACS_SERVER_LIST                      12 // 0x40      
#define  SYNTAX_ID_ADDITIONAL_INFORMATION               12 // 0x40      
#define  SYNTAX_ID_ADDITIONAL_TRUSTED_SERVICE_NAMES       12 // 0x40      
#define  SYNTAX_ID_ADDRESS                              12 // 0x40      
#define  SYNTAX_ID_ADDRESS_BOOK_ROOTS                    1 // 0x7f      
#define  SYNTAX_ID_ADDRESS_ENTRY_DISPLAY_TABLE          10 // 0x4       
#define  SYNTAX_ID_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS       10 // 0x4       
#define  SYNTAX_ID_ADDRESS_HOME                         12 // 0x40      
#define  SYNTAX_ID_ADDRESS_SYNTAX                       10 // 0x4       
#define  SYNTAX_ID_ADDRESS_TYPE                          4 // 0x14      
#define  SYNTAX_ID_ADMIN_CONTEXT_MENU                   12 // 0x40      
#define  SYNTAX_ID_ADMIN_COUNT                           9 // 0x2       
#define  SYNTAX_ID_ADMIN_DESCRIPTION                    12 // 0x40      
#define  SYNTAX_ID_ADMIN_DISPLAY_NAME                   12 // 0x40      
#define  SYNTAX_ID_ADMIN_MULTISELECT_PROPERTY_PAGES       12 // 0x40      
#define  SYNTAX_ID_ADMIN_PROPERTY_PAGES                 12 // 0x40      
#define  SYNTAX_ID_ALLOWED_ATTRIBUTES                    2 // 0x6       
#define  SYNTAX_ID_ALLOWED_ATTRIBUTES_EFFECTIVE          2 // 0x6       
#define  SYNTAX_ID_ALLOWED_CHILD_CLASSES                 2 // 0x6       
#define  SYNTAX_ID_ALLOWED_CHILD_CLASSES_EFFECTIVE        2 // 0x6       
#define  SYNTAX_ID_ALT_SECURITY_IDENTITIES              12 // 0x40      
#define  SYNTAX_ID_ANR                                  12 // 0x40      
#define  SYNTAX_ID_APP_SCHEMA_VERSION                    9 // 0x2       
#define  SYNTAX_ID_APPLICATION_NAME                     12 // 0x40      
#define  SYNTAX_ID_APPLIES_TO                           12 // 0x40      
#define  SYNTAX_ID_ASSET_NUMBER                         12 // 0x40      
#define  SYNTAX_ID_ASSISTANT                             1 // 0x7f      
#define  SYNTAX_ID_ASSOC_NT_ACCOUNT                     10 // 0x4       
#define  SYNTAX_ID_ATTRIBUTECERTIFICATEATTRIBUTE        10 // 0x4       
#define  SYNTAX_ID_ATTRIBUTE_DISPLAY_NAMES              12 // 0x40      
#define  SYNTAX_ID_ATTRIBUTE_ID                          2 // 0x6       
#define  SYNTAX_ID_ATTRIBUTE_SECURITY_GUID              10 // 0x4       
#define  SYNTAX_ID_ATTRIBUTE_SYNTAX                      2 // 0x6       
#define  SYNTAX_ID_ATTRIBUTE_TYPES                      12 // 0x40      
#define  SYNTAX_ID_AUDIO                                10 // 0x4       
#define  SYNTAX_ID_AUDITING_POLICY                      10 // 0x4       
#define  SYNTAX_ID_AUTHENTICATION_OPTIONS                9 // 0x2       
#define  SYNTAX_ID_AUTHORITY_REVOCATION_LIST            10 // 0x4       
#define  SYNTAX_ID_AUXILIARY_CLASS                       2 // 0x6       
#define  SYNTAX_ID_BAD_PASSWORD_TIME                    16 // 0x41      
#define  SYNTAX_ID_BAD_PWD_COUNT                         9 // 0x2       
#define  SYNTAX_ID_BIRTH_LOCATION                       10 // 0x4       
#define  SYNTAX_ID_BRIDGEHEAD_SERVER_LIST_BL             1 // 0x7f      
#define  SYNTAX_ID_BRIDGEHEAD_TRANSPORT_LIST             1 // 0x7f      
#define  SYNTAX_ID_BUILTIN_CREATION_TIME                16 // 0x41      
#define  SYNTAX_ID_BUILTIN_MODIFIED_COUNT               16 // 0x41      
#define  SYNTAX_ID_BUSINESS_CATEGORY                    12 // 0x40      
#define  SYNTAX_ID_BYTES_PER_MINUTE                      9 // 0x2       
#define  SYNTAX_ID_CA_CERTIFICATE                       10 // 0x4       
#define  SYNTAX_ID_CA_CERTIFICATE_DN                    12 // 0x40      
#define  SYNTAX_ID_CA_CONNECT                           12 // 0x40      
#define  SYNTAX_ID_CA_USAGES                            12 // 0x40      
#define  SYNTAX_ID_CA_WEB_URL                           12 // 0x40      
#define  SYNTAX_ID_CAN_UPGRADE_SCRIPT                   12 // 0x40      
#define  SYNTAX_ID_CANONICAL_NAME                       12 // 0x40      
#define  SYNTAX_ID_CARLICENSE                           12 // 0x40      
#define  SYNTAX_ID_CATALOGS                             12 // 0x40      
#define  SYNTAX_ID_CATEGORIES                           12 // 0x40      
#define  SYNTAX_ID_CATEGORY_ID                          10 // 0x4       
#define  SYNTAX_ID_CERTIFICATE_AUTHORITY_OBJECT          1 // 0x7f      
#define  SYNTAX_ID_CERTIFICATE_REVOCATION_LIST          10 // 0x4       
#define  SYNTAX_ID_CERTIFICATE_TEMPLATES                12 // 0x40      
#define  SYNTAX_ID_CLASS_DISPLAY_NAME                   12 // 0x40      
#define  SYNTAX_ID_CODE_PAGE                             9 // 0x2       
#define  SYNTAX_ID_COM_CLASSID                          12 // 0x40      
#define  SYNTAX_ID_COM_CLSID                            12 // 0x40      
#define  SYNTAX_ID_COM_INTERFACEID                      12 // 0x40      
#define  SYNTAX_ID_COM_OTHER_PROG_ID                    12 // 0x40      
#define  SYNTAX_ID_COM_PROGID                           12 // 0x40      
#define  SYNTAX_ID_COM_TREAT_AS_CLASS_ID                12 // 0x40      
#define  SYNTAX_ID_COM_TYPELIB_ID                       12 // 0x40      
#define  SYNTAX_ID_COM_UNIQUE_LIBID                     12 // 0x40      
#define  SYNTAX_ID_COMMENT                              12 // 0x40      
#define  SYNTAX_ID_COMMON_NAME                          12 // 0x40      
#define  SYNTAX_ID_COMPANY                              12 // 0x40      
#define  SYNTAX_ID_CONTENT_INDEXING_ALLOWED              8 // 0x1       
#define  SYNTAX_ID_CONTEXT_MENU                         12 // 0x40      
#define  SYNTAX_ID_CONTROL_ACCESS_RIGHTS                10 // 0x4       
#define  SYNTAX_ID_COST                                  9 // 0x2       
#define  SYNTAX_ID_COUNTRY_CODE                          9 // 0x2       
#define  SYNTAX_ID_COUNTRY_NAME                         12 // 0x40      
#define  SYNTAX_ID_CREATE_DIALOG                        12 // 0x40      
#define  SYNTAX_ID_CREATE_TIME_STAMP                    11 // 0x18      
#define  SYNTAX_ID_CREATE_WIZARD_EXT                    12 // 0x40      
#define  SYNTAX_ID_CREATION_TIME                        16 // 0x41      
#define  SYNTAX_ID_CREATION_WIZARD                      12 // 0x40      
#define  SYNTAX_ID_CREATOR                              12 // 0x40      
#define  SYNTAX_ID_CRL_OBJECT                            1 // 0x7f      
#define  SYNTAX_ID_CRL_PARTITIONED_REVOCATION_LIST       10 // 0x4       
#define  SYNTAX_ID_CROSS_CERTIFICATE_PAIR               10 // 0x4       
#define  SYNTAX_ID_CURR_MACHINE_ID                      10 // 0x4       
#define  SYNTAX_ID_CURRENT_LOCATION                     10 // 0x4       
#define  SYNTAX_ID_CURRENT_PARENT_CA                     1 // 0x7f      
#define  SYNTAX_ID_CURRENT_VALUE                        10 // 0x4       
#define  SYNTAX_ID_DBCS_PWD                             10 // 0x4       
#define  SYNTAX_ID_DEFAULT_CLASS_STORE                   1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_GROUP                         1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_HIDING_VALUE                  8 // 0x1       
#define  SYNTAX_ID_DEFAULT_LOCAL_POLICY_OBJECT           1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_OBJECT_CATEGORY               1 // 0x7f      
#define  SYNTAX_ID_DEFAULT_PRIORITY                      9 // 0x2       
#define  SYNTAX_ID_DEFAULT_SECURITY_DESCRIPTOR          12 // 0x40      
#define  SYNTAX_ID_DELTA_REVOCATION_LIST                10 // 0x4       
#define  SYNTAX_ID_DEPARTMENT                           12 // 0x40      
#define  SYNTAX_ID_DEPARTMENTNUMBER                     12 // 0x40      
#define  SYNTAX_ID_DESCRIPTION                          12 // 0x40      
#define  SYNTAX_ID_DESKTOP_PROFILE                      12 // 0x40      
#define  SYNTAX_ID_DESTINATION_INDICATOR                 5 // 0x13      
#define  SYNTAX_ID_DHCP_CLASSES                         10 // 0x4       
#define  SYNTAX_ID_DHCP_FLAGS                           16 // 0x41      
#define  SYNTAX_ID_DHCP_IDENTIFICATION                  12 // 0x40      
#define  SYNTAX_ID_DHCP_MASK                             5 // 0x13      
#define  SYNTAX_ID_DHCP_MAXKEY                          16 // 0x41      
#define  SYNTAX_ID_DHCP_OBJ_DESCRIPTION                 12 // 0x40      
#define  SYNTAX_ID_DHCP_OBJ_NAME                        12 // 0x40      
#define  SYNTAX_ID_DHCP_OPTIONS                         10 // 0x4       
#define  SYNTAX_ID_DHCP_PROPERTIES                      10 // 0x4       
#define  SYNTAX_ID_DHCP_RANGES                           5 // 0x13      
#define  SYNTAX_ID_DHCP_RESERVATIONS                     5 // 0x13      
#define  SYNTAX_ID_DHCP_SERVERS                          5 // 0x13      
#define  SYNTAX_ID_DHCP_SITES                            5 // 0x13      
#define  SYNTAX_ID_DHCP_STATE                            5 // 0x13      
#define  SYNTAX_ID_DHCP_SUBNETS                          5 // 0x13      
#define  SYNTAX_ID_DHCP_TYPE                             9 // 0x2       
#define  SYNTAX_ID_DHCP_UNIQUE_KEY                      16 // 0x41      
#define  SYNTAX_ID_DHCP_UPDATE_TIME                     16 // 0x41      
#define  SYNTAX_ID_DISPLAY_NAME                         12 // 0x40      
#define  SYNTAX_ID_DISPLAY_NAME_PRINTABLE                5 // 0x13      
#define  SYNTAX_ID_DIT_CONTENT_RULES                    12 // 0x40      
#define  SYNTAX_ID_DIVISION                             12 // 0x40      
#define  SYNTAX_ID_DMD_LOCATION                          1 // 0x7f      
#define  SYNTAX_ID_DMD_NAME                             12 // 0x40      
#define  SYNTAX_ID_DN_REFERENCE_UPDATE                   1 // 0x7f      
#define  SYNTAX_ID_DNS_ALLOW_DYNAMIC                     8 // 0x1       
#define  SYNTAX_ID_DNS_ALLOW_XFR                         8 // 0x1       
#define  SYNTAX_ID_DNS_HOST_NAME                        12 // 0x40      
#define  SYNTAX_ID_DNS_NOTIFY_SECONDARIES                9 // 0x2       
#define  SYNTAX_ID_DNS_PROPERTY                         10 // 0x4       
#define  SYNTAX_ID_DNS_RECORD                           10 // 0x4       
#define  SYNTAX_ID_DNS_ROOT                             12 // 0x40      
#define  SYNTAX_ID_DNS_SECURE_SECONDARIES                9 // 0x2       
#define  SYNTAX_ID_DNS_TOMBSTONED                        8 // 0x1       
#define  SYNTAX_ID_DOMAIN_CERTIFICATE_AUTHORITIES        1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_COMPONENT                     12 // 0x40      
#define  SYNTAX_ID_DOMAIN_CROSS_REF                      1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_ID                             1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_IDENTIFIER                     9 // 0x2       
#define  SYNTAX_ID_DOMAIN_POLICY_OBJECT                  1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_POLICY_REFERENCE               1 // 0x7f      
#define  SYNTAX_ID_DOMAIN_REPLICA                       12 // 0x40      
#define  SYNTAX_ID_DOMAIN_WIDE_POLICY                   10 // 0x4       
#define  SYNTAX_ID_DRIVER_NAME                          12 // 0x40      
#define  SYNTAX_ID_DRIVER_VERSION                        9 // 0x2       
#define  SYNTAX_ID_DS_CORE_PROPAGATION_DATA             11 // 0x18      
#define  SYNTAX_ID_DS_HEURISTICS                        12 // 0x40      
#define  SYNTAX_ID_DS_UI_ADMIN_MAXIMUM                   9 // 0x2       
#define  SYNTAX_ID_DS_UI_ADMIN_NOTIFICATION             12 // 0x40      
#define  SYNTAX_ID_DS_UI_SHELL_MAXIMUM                   9 // 0x2       
#define  SYNTAX_ID_DSA_SIGNATURE                        10 // 0x4       
#define  SYNTAX_ID_DYNAMIC_LDAP_SERVER                   1 // 0x7f      
#define  SYNTAX_ID_E_MAIL_ADDRESSES                     12 // 0x40      
#define  SYNTAX_ID_EFSPOLICY                            10 // 0x4       
#define  SYNTAX_ID_EMPLOYEE_ID                          12 // 0x40      
#define  SYNTAX_ID_EMPLOYEE_NUMBER                      12 // 0x40      
#define  SYNTAX_ID_EMPLOYEE_TYPE                        12 // 0x40      
#define  SYNTAX_ID_ENABLED                               8 // 0x1       
#define  SYNTAX_ID_ENABLED_CONNECTION                    8 // 0x1       
#define  SYNTAX_ID_ENROLLMENT_PROVIDERS                 12 // 0x40      
#define  SYNTAX_ID_ENTRY_TTL                             9 // 0x2       
#define  SYNTAX_ID_EXTENDED_ATTRIBUTE_INFO              12 // 0x40      
#define  SYNTAX_ID_EXTENDED_CHARS_ALLOWED                8 // 0x1       
#define  SYNTAX_ID_EXTENDED_CLASS_INFO                  12 // 0x40      
#define  SYNTAX_ID_EXTENSION_NAME                       12 // 0x40      
#define  SYNTAX_ID_EXTRA_COLUMNS                        12 // 0x40      
#define  SYNTAX_ID_FACSIMILE_TELEPHONE_NUMBER           12 // 0x40      
#define  SYNTAX_ID_FILE_EXT_PRIORITY                    12 // 0x40      
#define  SYNTAX_ID_FLAGS                                 9 // 0x2       
#define  SYNTAX_ID_FLAT_NAME                            12 // 0x40      
#define  SYNTAX_ID_FORCE_LOGOFF                         16 // 0x41      
#define  SYNTAX_ID_FOREIGN_IDENTIFIER                   10 // 0x4       
#define  SYNTAX_ID_FRIENDLY_NAMES                       12 // 0x40      
#define  SYNTAX_ID_FROM_ENTRY                            8 // 0x1       
#define  SYNTAX_ID_FROM_SERVER                           1 // 0x7f      
#define  SYNTAX_ID_FRS_COMPUTER_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_FRS_COMPUTER_REFERENCE_BL             1 // 0x7f      
#define  SYNTAX_ID_FRS_CONTROL_DATA_CREATION            12 // 0x40      
#define  SYNTAX_ID_FRS_CONTROL_INBOUND_BACKLOG          12 // 0x40      
#define  SYNTAX_ID_FRS_CONTROL_OUTBOUND_BACKLOG         12 // 0x40      
#define  SYNTAX_ID_FRS_DIRECTORY_FILTER                 12 // 0x40      
#define  SYNTAX_ID_FRS_DS_POLL                           9 // 0x2       
#define  SYNTAX_ID_FRS_EXTENSIONS                       10 // 0x4       
#define  SYNTAX_ID_FRS_FAULT_CONDITION                  12 // 0x40      
#define  SYNTAX_ID_FRS_FILE_FILTER                      12 // 0x40      
#define  SYNTAX_ID_FRS_FLAGS                             9 // 0x2       
#define  SYNTAX_ID_FRS_LEVEL_LIMIT                       9 // 0x2       
#define  SYNTAX_ID_FRS_MEMBER_REFERENCE                  1 // 0x7f      
#define  SYNTAX_ID_FRS_MEMBER_REFERENCE_BL               1 // 0x7f      
#define  SYNTAX_ID_FRS_PARTNER_AUTH_LEVEL                9 // 0x2       
#define  SYNTAX_ID_FRS_PRIMARY_MEMBER                    1 // 0x7f      
#define  SYNTAX_ID_FRS_REPLICA_SET_GUID                 10 // 0x4       
#define  SYNTAX_ID_FRS_REPLICA_SET_TYPE                  9 // 0x2       
#define  SYNTAX_ID_FRS_ROOT_PATH                        12 // 0x40      
#define  SYNTAX_ID_FRS_ROOT_SECURITY                    15 // 0x42      
#define  SYNTAX_ID_FRS_SERVICE_COMMAND                  12 // 0x40      
#define  SYNTAX_ID_FRS_SERVICE_COMMAND_STATUS           12 // 0x40      
#define  SYNTAX_ID_FRS_STAGING_PATH                     12 // 0x40      
#define  SYNTAX_ID_FRS_TIME_LAST_COMMAND                11 // 0x17      
#define  SYNTAX_ID_FRS_TIME_LAST_CONFIG_CHANGE          11 // 0x17      
#define  SYNTAX_ID_FRS_UPDATE_TIMEOUT                    9 // 0x2       
#define  SYNTAX_ID_FRS_VERSION                          12 // 0x40      
#define  SYNTAX_ID_FRS_VERSION_GUID                     10 // 0x4       
#define  SYNTAX_ID_FRS_WORKING_PATH                     12 // 0x40      
#define  SYNTAX_ID_FSMO_ROLE_OWNER                       1 // 0x7f      
#define  SYNTAX_ID_GARBAGE_COLL_PERIOD                   9 // 0x2       
#define  SYNTAX_ID_GENERATED_CONNECTION                  8 // 0x1       
#define  SYNTAX_ID_GENERATION_QUALIFIER                 12 // 0x40      
#define  SYNTAX_ID_GIVEN_NAME                           12 // 0x40      
#define  SYNTAX_ID_GLOBAL_ADDRESS_LIST                   1 // 0x7f      
#define  SYNTAX_ID_GOVERNS_ID                            2 // 0x6       
#define  SYNTAX_ID_GP_LINK                              12 // 0x40      
#define  SYNTAX_ID_GP_OPTIONS                            9 // 0x2       
#define  SYNTAX_ID_GPC_FILE_SYS_PATH                    12 // 0x40      
#define  SYNTAX_ID_GPC_FUNCTIONALITY_VERSION             9 // 0x2       
#define  SYNTAX_ID_GPC_MACHINE_EXTENSION_NAMES          12 // 0x40      
#define  SYNTAX_ID_GPC_USER_EXTENSION_NAMES             12 // 0x40      
#define  SYNTAX_ID_GPC_WQL_FILTER                       12 // 0x40      
#define  SYNTAX_ID_GROUP_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_GROUP_MEMBERSHIP_SAM                 10 // 0x4       
#define  SYNTAX_ID_GROUP_PRIORITY                       12 // 0x40      
#define  SYNTAX_ID_GROUP_TYPE                            9 // 0x2       
#define  SYNTAX_ID_GROUPS_TO_IGNORE                     12 // 0x40      
#define  SYNTAX_ID_HAS_MASTER_NCS                        1 // 0x7f      
#define  SYNTAX_ID_HAS_PARTIAL_REPLICA_NCS               1 // 0x7f      
#define  SYNTAX_ID_HELP_DATA16                          10 // 0x4       
#define  SYNTAX_ID_HELP_DATA32                          10 // 0x4       
#define  SYNTAX_ID_HELP_FILE_NAME                       12 // 0x40      
#define  SYNTAX_ID_HIDE_FROM_AB                          8 // 0x1       
#define  SYNTAX_ID_HOME_DIRECTORY                       12 // 0x40      
#define  SYNTAX_ID_HOME_DRIVE                           12 // 0x40      
#define  SYNTAX_ID_ICON_PATH                            12 // 0x40      
#define  SYNTAX_ID_IMPLEMENTED_CATEGORIES               10 // 0x4       
#define  SYNTAX_ID_INDEXEDSCOPES                        12 // 0x40      
#define  SYNTAX_ID_INITIAL_AUTH_INCOMING                12 // 0x40      
#define  SYNTAX_ID_INITIAL_AUTH_OUTGOING                12 // 0x40      
#define  SYNTAX_ID_INITIALS                             12 // 0x40      
#define  SYNTAX_ID_INSTALL_UI_LEVEL                      9 // 0x2       
#define  SYNTAX_ID_INSTANCE_TYPE                         9 // 0x2       
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_FAILOVER          9 // 0x2       
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_GENERATOR         1 // 0x7f      
#define  SYNTAX_ID_INTER_SITE_TOPOLOGY_RENEW             9 // 0x2       
#define  SYNTAX_ID_INTERNATIONAL_ISDN_NUMBER             6 // 0x12      
#define  SYNTAX_ID_INVOCATION_ID                        10 // 0x4       
#define  SYNTAX_ID_IPSEC_DATA                           10 // 0x4       
#define  SYNTAX_ID_IPSEC_DATA_TYPE                       9 // 0x2       
#define  SYNTAX_ID_IPSEC_FILTER_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_ID                             12 // 0x40      
#define  SYNTAX_ID_IPSEC_ISAKMP_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_NAME                           12 // 0x40      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_ACTION       12 // 0x40      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_REFERENCE        1 // 0x7f      
#define  SYNTAX_ID_IPSEC_NEGOTIATION_POLICY_TYPE        12 // 0x40      
#define  SYNTAX_ID_IPSEC_NFA_REFERENCE                   1 // 0x7f      
#define  SYNTAX_ID_IPSEC_OWNERS_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IPSEC_POLICY_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_IS_CRITICAL_SYSTEM_OBJECT             8 // 0x1       
#define  SYNTAX_ID_IS_DEFUNCT                            8 // 0x1       
#define  SYNTAX_ID_IS_DELETED                            8 // 0x1       
#define  SYNTAX_ID_IS_EPHEMERAL                          8 // 0x1       
#define  SYNTAX_ID_IS_MEMBER_OF_DL                       1 // 0x7f      
#define  SYNTAX_ID_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET        8 // 0x1       
#define  SYNTAX_ID_IS_PRIVILEGE_HOLDER                   1 // 0x7f      
#define  SYNTAX_ID_IS_SINGLE_VALUED                      8 // 0x1       
#define  SYNTAX_ID_JPEGPHOTO                            10 // 0x4       
#define  SYNTAX_ID_KEYWORDS                             12 // 0x40      
#define  SYNTAX_ID_KNOWLEDGE_INFORMATION                 4 // 0x14      
#define  SYNTAX_ID_LABELEDURI                           12 // 0x40      
#define  SYNTAX_ID_LAST_BACKUP_RESTORATION_TIME         16 // 0x41      
#define  SYNTAX_ID_LAST_CONTENT_INDEXED                 16 // 0x41      
#define  SYNTAX_ID_LAST_KNOWN_PARENT                     1 // 0x7f      
#define  SYNTAX_ID_LAST_LOGOFF                          16 // 0x41      
#define  SYNTAX_ID_LAST_LOGON                           16 // 0x41      
#define  SYNTAX_ID_LAST_LOGON_TIMESTAMP                 16 // 0x41      
#define  SYNTAX_ID_LAST_SET_TIME                        16 // 0x41      
#define  SYNTAX_ID_LAST_UPDATE_SEQUENCE                 12 // 0x40      
#define  SYNTAX_ID_LDAP_ADMIN_LIMITS                    12 // 0x40      
#define  SYNTAX_ID_LDAP_DISPLAY_NAME                    12 // 0x40      
#define  SYNTAX_ID_LDAP_IPDENY_LIST                     10 // 0x4       
#define  SYNTAX_ID_LEGACY_EXCHANGE_DN                    4 // 0x14      
#define  SYNTAX_ID_LINK_ID                               9 // 0x2       
#define  SYNTAX_ID_LINK_TRACK_SECRET                    10 // 0x4       
#define  SYNTAX_ID_LM_PWD_HISTORY                       10 // 0x4       
#define  SYNTAX_ID_LOCAL_POLICY_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_LOCAL_POLICY_REFERENCE                1 // 0x7f      
#define  SYNTAX_ID_LOCALE_ID                             9 // 0x2       
#define  SYNTAX_ID_LOCALITY_NAME                        12 // 0x40      
#define  SYNTAX_ID_LOCALIZED_DESCRIPTION                12 // 0x40      
#define  SYNTAX_ID_LOCALIZATION_DISPLAY_ID               9 // 0x2       
#define  SYNTAX_ID_LOCATION                             12 // 0x40      
#define  SYNTAX_ID_LOCK_OUT_OBSERVATION_WINDOW          16 // 0x41      
#define  SYNTAX_ID_LOCKOUT_DURATION                     16 // 0x41      
#define  SYNTAX_ID_LOCKOUT_THRESHOLD                     9 // 0x2       
#define  SYNTAX_ID_LOCKOUT_TIME                         16 // 0x41      
#define  SYNTAX_ID_LOGO                                 10 // 0x4       
#define  SYNTAX_ID_LOGON_COUNT                           9 // 0x2       
#define  SYNTAX_ID_LOGON_HOURS                          10 // 0x4       
#define  SYNTAX_ID_LOGON_WORKSTATION                    10 // 0x4       
#define  SYNTAX_ID_LSA_CREATION_TIME                    16 // 0x41      
#define  SYNTAX_ID_LSA_MODIFIED_COUNT                   16 // 0x41      
#define  SYNTAX_ID_MACHINE_ARCHITECTURE                  9 // 0xa       
#define  SYNTAX_ID_MACHINE_PASSWORD_CHANGE_INTERVAL       16 // 0x41      
#define  SYNTAX_ID_MACHINE_ROLE                          9 // 0xa       
#define  SYNTAX_ID_MACHINE_WIDE_POLICY                  10 // 0x4       
#define  SYNTAX_ID_MANAGED_BY                            1 // 0x7f      
#define  SYNTAX_ID_MANAGED_OBJECTS                       1 // 0x7f      
#define  SYNTAX_ID_MANAGER                               1 // 0x7f      
#define  SYNTAX_ID_MAPI_ID                               9 // 0x2       
#define  SYNTAX_ID_MARSHALLED_INTERFACE                 10 // 0x4       
#define  SYNTAX_ID_MASTERED_BY                           1 // 0x7f      
#define  SYNTAX_ID_MAX_PWD_AGE                          16 // 0x41      
#define  SYNTAX_ID_MAX_RENEW_AGE                        16 // 0x41      
#define  SYNTAX_ID_MAX_STORAGE                          16 // 0x41      
#define  SYNTAX_ID_MAX_TICKET_AGE                       16 // 0x41      
#define  SYNTAX_ID_MAY_CONTAIN                           2 // 0x6       
#define  SYNTAX_ID_MEETINGADVERTISESCOPE                12 // 0x40      
#define  SYNTAX_ID_MEETINGAPPLICATION                   12 // 0x40      
#define  SYNTAX_ID_MEETINGBANDWIDTH                      9 // 0x2       
#define  SYNTAX_ID_MEETINGBLOB                          10 // 0x4       
#define  SYNTAX_ID_MEETINGCONTACTINFO                   12 // 0x40      
#define  SYNTAX_ID_MEETINGDESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_MEETINGENDTIME                       11 // 0x17      
#define  SYNTAX_ID_MEETINGID                            12 // 0x40      
#define  SYNTAX_ID_MEETINGIP                            12 // 0x40      
#define  SYNTAX_ID_MEETINGISENCRYPTED                   12 // 0x40      
#define  SYNTAX_ID_MEETINGKEYWORD                       12 // 0x40      
#define  SYNTAX_ID_MEETINGLANGUAGE                      12 // 0x40      
#define  SYNTAX_ID_MEETINGLOCATION                      12 // 0x40      
#define  SYNTAX_ID_MEETINGMAXPARTICIPANTS                9 // 0x2       
#define  SYNTAX_ID_MEETINGNAME                          12 // 0x40      
#define  SYNTAX_ID_MEETINGORIGINATOR                    12 // 0x40      
#define  SYNTAX_ID_MEETINGOWNER                         12 // 0x40      
#define  SYNTAX_ID_MEETINGPROTOCOL                      12 // 0x40      
#define  SYNTAX_ID_MEETINGRATING                        12 // 0x40      
#define  SYNTAX_ID_MEETINGRECURRENCE                    12 // 0x40      
#define  SYNTAX_ID_MEETINGSCOPE                         12 // 0x40      
#define  SYNTAX_ID_MEETINGSTARTTIME                     11 // 0x17      
#define  SYNTAX_ID_MEETINGTYPE                          12 // 0x40      
#define  SYNTAX_ID_MEETINGURL                           12 // 0x40      
#define  SYNTAX_ID_MEMBER                                1 // 0x7f      
#define  SYNTAX_ID_MHS_OR_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_MIN_PWD_AGE                          16 // 0x41      
#define  SYNTAX_ID_MIN_PWD_LENGTH                        9 // 0x2       
#define  SYNTAX_ID_MIN_TICKET_AGE                       16 // 0x41      
#define  SYNTAX_ID_MODIFIED_COUNT                       16 // 0x41      
#define  SYNTAX_ID_MODIFIED_COUNT_AT_LAST_PROM          16 // 0x41      
#define  SYNTAX_ID_MODIFY_TIME_STAMP                    11 // 0x18      
#define  SYNTAX_ID_MONIKER                              10 // 0x4       
#define  SYNTAX_ID_MONIKER_DISPLAY_NAME                 12 // 0x40      
#define  SYNTAX_ID_MOVE_TREE_STATE                      10 // 0x4       
#define  SYNTAX_ID_MS_COM_DEFAULTPARTITIONLINK           1 // 0x7f      
#define  SYNTAX_ID_MS_COM_OBJECTID                      10 // 0x4       
#define  SYNTAX_ID_MS_COM_PARTITIONLINK                  1 // 0x7f      
#define  SYNTAX_ID_MS_COM_PARTITIONSETLINK               1 // 0x7f      
#define  SYNTAX_ID_MS_COM_USERLINK                       1 // 0x7f      
#define  SYNTAX_ID_MS_COM_USERPARTITIONSETLINK           1 // 0x7f      
#define  SYNTAX_ID_MS_DS_ADDITIONAL_DNS_HOST_NAME       12 // 0x40      
#define  SYNTAX_ID_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME       12 // 0x40      
#define  SYNTAX_ID_MS_DS_ALL_USERS_TRUST_QUOTA           9 // 0x2       
#define  SYNTAX_ID_MS_DS_ALLOWED_DNS_SUFFIXES           12 // 0x40      
#define  SYNTAX_ID_MS_DS_ALLOWED_TO_DELEGATE_TO         12 // 0x40      
#define  SYNTAX_ID_MS_DS_AUXILIARY_CLASSES               2 // 0x6       
#define  SYNTAX_ID_MS_DS_APPROX_IMMED_SUBORDINATES        9 // 0x2       
#define  SYNTAX_ID_MS_DS_BEHAVIOR_VERSION                9 // 0x2       
#define  SYNTAX_ID_MS_DS_CACHED_MEMBERSHIP              10 // 0x4       
#define  SYNTAX_ID_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       16 // 0x41      
#define  SYNTAX_ID_MS_DS_CONSISTENCY_GUID               10 // 0x4       
#define  SYNTAX_ID_MS_DS_CONSISTENCY_CHILD_COUNT         9 // 0x2       
#define  SYNTAX_ID_MS_DS_CREATOR_SID                    17 // 0x4       
#define  SYNTAX_ID_MS_DS_DNSROOTALIAS                   12 // 0x40      
#define  SYNTAX_ID_MS_DS_ENTRY_TIME_TO_DIE              11 // 0x18      
#define  SYNTAX_ID_MS_DS_EXECUTESCRIPTPASSWORD          10 // 0x4       
#define  SYNTAX_ID_MS_DS_FILTER_CONTAINERS              12 // 0x40      
#define  SYNTAX_ID_MS_DS_HAS_INSTANTIATED_NCS            7 // 0x7f      
#define  SYNTAX_ID_MS_DS_INTID                           9 // 0x2       
#define  SYNTAX_ID_MS_DS_LOGON_TIME_SYNC_INTERVAL        9 // 0x2       
#define  SYNTAX_ID_MS_DS_TRUST_FOREST_TRUST_INFO        10 // 0x4       
#define  SYNTAX_ID_MS_DS_MACHINE_ACCOUNT_QUOTA           9 // 0x2       
#define  SYNTAX_ID_MS_DS_OTHER_SETTINGS                 12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPL_CURSORS                12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPL_INBOUND_NEIGHBORS       12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS       12 // 0x40      
#define  SYNTAX_ID_MS_DS_NC_REPLICA_LOCATIONS            1 // 0x7f      
#define  SYNTAX_ID_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES       12 // 0x40      
#define  SYNTAX_ID_MS_DS_PER_USER_TRUST_QUOTA            9 // 0x2       
#define  SYNTAX_ID_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA        9 // 0x2       
#define  SYNTAX_ID_MS_DS_PREFERRED_GC_SITE               1 // 0x7f      
#define  SYNTAX_ID_MS_DS_REPL_ATTRIBUTE_META_DATA       12 // 0x40      
#define  SYNTAX_ID_MS_DS_REPL_VALUE_META_DATA           12 // 0x40      
#define  SYNTAX_ID_MS_DS_REPLICATES_NC_REASON            7 // 0x7f      
#define  SYNTAX_ID_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY        9 // 0x2       
#define  SYNTAX_ID_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY        9 // 0x2       
#define  SYNTAX_ID_MS_DS_REPLICATIONEPOCH                9 // 0x2       
#define  SYNTAX_ID_MS_DS_SCHEMA_EXTENSIONS              10 // 0x4       
#define  SYNTAX_ID_MS_DS_SD_REFERENCE_DOMAIN             1 // 0x7f      
#define  SYNTAX_ID_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       12 // 0x40      
#define  SYNTAX_ID_MS_DS_SETTINGS                       12 // 0x40      
#define  SYNTAX_ID_MS_DS_SITE_AFFINITY                  10 // 0x4       
#define  SYNTAX_ID_MS_DS_SPN_SUFFIXES                   12 // 0x40      
#define  SYNTAX_ID_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED        9 // 0x2       
#define  SYNTAX_ID_MS_DS_UPDATESCRIPT                   12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_ASSISTANT_NAME               12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_LABELEDURI                   12 // 0x40      
#define  SYNTAX_ID_MS_EXCH_OWNER_BL                      1 // 0x7f      
#define  SYNTAX_ID_MS_FRS_HUB_MEMBER                     1 // 0x7f      
#define  SYNTAX_ID_MS_FRS_TOPOLOGY_PREF                 12 // 0x40      
#define  SYNTAX_ID_MS_IIS_FTP_DIR                       12 // 0x40      
#define  SYNTAX_ID_MS_IIS_FTP_ROOT                      12 // 0x40      
#define  SYNTAX_ID_MS_MMS_DATA                          10 // 0x4       
#define  SYNTAX_ID_MS_MMS_INDEX                         10 // 0x4       
#define  SYNTAX_ID_MS_MMS_INDICE                        10 // 0x4       
#define  SYNTAX_ID_MS_MMS_XML                           12 // 0x40      
#define  SYNTAX_ID_MS_MMS_JOIN_LINK                      1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_LINEAGE                       10 // 0x4       
#define  SYNTAX_ID_MS_MMS_PROV_STATUS                   12 // 0x40      
#define  SYNTAX_ID_MS_MMS_SYNC_STATUS                   10 // 0x4       
#define  SYNTAX_ID_MS_MMS_PARTITION                     12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_STAGING_LINK                1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_MA_STAGING_BL                  1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_PROVISIONING_LINK              1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_PROVISIONING_BL                1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_ASSOCIATED_LINK                1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_ASSOCIATED_BL                  1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_SCOPE_LINK                     1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_SCOPE_BL                       1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_CRITERIA                      12 // 0x40      
#define  SYNTAX_ID_MS_MMS_DOMAIN_CONTROLLER              1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_SERVICE_NAME                  12 // 0x40      
#define  SYNTAX_ID_MS_MMS_INSTANCE_CONFIGURATION        12 // 0x40      
#define  SYNTAX_ID_MS_MMS_TOOLS_CONFIGURATION           12 // 0x40      
#define  SYNTAX_ID_MS_MMS_INSTANCE_RULE                 12 // 0x40      
#define  SYNTAX_ID_MS_MMS_INSTALL_STATUS                12 // 0x40      
#define  SYNTAX_ID_MS_MMS_VERSION                       12 // 0x40      
#define  SYNTAX_ID_MS_MMS_CONNECTOR_SPACE                1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_SCOPE                          1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_INSTANCE_SCHEDULE             12 // 0x40      
#define  SYNTAX_ID_MS_MMS_INSTANCE_INFO                 10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_CONFIGURATION              12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_CONFIGURATION_PRIVATE       10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_SCHEMA                     12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_MAP                        12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_CAPABILITY                 12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_EXECUTION_HISTORY          12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_CATEGORY                   12 // 0x40      
#define  SYNTAX_ID_MS_MMS_MA_AD_INFO                    10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_CD_INFO                    10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_PROCESS_INFO               10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_SCRIPT_INFO                10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_SYSTEM                     10 // 0x4       
#define  SYNTAX_ID_MS_MMS_MA_SYNCHRONIZATION            10 // 0x4       
#define  SYNTAX_ID_MS_MMS_JOIN_BL                        1 // 0x7f      
#define  SYNTAX_ID_MS_MMS_ANCHOR                        10 // 0x4       
#define  SYNTAX_ID_MS_MMS_EXPORT_KEY                    10 // 0x4       
#define  SYNTAX_ID_MS_MMS_IMPORT_KEY                    10 // 0x4       
#define  SYNTAX_ID_MS_MMS_STATE                         10 // 0x4       
#define  SYNTAX_ID_MS_MMS_HOLOGRAM                      10 // 0x4       
#define  SYNTAX_ID_MS_MMS_DELTA_HOLOGRAM                10 // 0x4       
#define  SYNTAX_ID_MS_MMS_PROVISIONING_CONFIGURATION       12 // 0x40      
#define  SYNTAX_ID_MS_MMS_PROVISIONING_CONFIGURATION_PRIVATE       10 // 0x4       
#define  SYNTAX_ID_MS_MMS_PROVISIONING_AD_INFO          10 // 0x4       
#define  SYNTAX_ID_MS_MMS_PROVISIONING_SYSTEM           12 // 0x40      
#define  SYNTAX_ID_MS_MMS_PROVISIONING_STATUS_XML       12 // 0x40      
#define  SYNTAX_ID_MS_MMS_PROVISIONING_STATUS_BINARY       10 // 0x4       
#define  SYNTAX_ID_MS_PKI_CERT_TEMPLATE_OID             12 // 0x40      
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_APPLICATION_POLICY       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_NAME_FLAG          9 // 0x2       
#define  SYNTAX_ID_MS_PKI_CERTIFICATE_POLICY            12 // 0x40      
#define  SYNTAX_ID_MS_PKI_ENROLLMENT_FLAG                9 // 0x2       
#define  SYNTAX_ID_MS_PKI_MINIMAL_KEY_SIZE               9 // 0x2       
#define  SYNTAX_ID_MS_PKI_OID_ATTRIBUTE                  9 // 0x2       
#define  SYNTAX_ID_MS_PKI_OID_CPS                       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_OID_LOCALIZEDNAME             12 // 0x40      
#define  SYNTAX_ID_MS_PKI_OID_USER_NOTICE               12 // 0x40      
#define  SYNTAX_ID_MS_PKI_PRIVATE_KEY_FLAG               9 // 0x2       
#define  SYNTAX_ID_MS_PKI_SUPERSEDE_TEMPLATES           12 // 0x40      
#define  SYNTAX_ID_MS_PKI_TEMPLATE_MINOR_REVISION        9 // 0x2       
#define  SYNTAX_ID_MS_PKI_TEMPLATE_SCHEMA_VERSION        9 // 0x2       
#define  SYNTAX_ID_MS_PKI_RA_APPLICATION_POLICIES       12 // 0x40      
#define  SYNTAX_ID_MS_PKI_RA_POLICIES                   12 // 0x40      
#define  SYNTAX_ID_MS_PKI_RA_SIGNATURE                   9 // 0x2       
#define  SYNTAX_ID_MS_RRAS_ATTRIBUTE                    12 // 0x40      
#define  SYNTAX_ID_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_NAME                          12 // 0x40      
#define  SYNTAX_ID_MS_SQL_REGISTEREDOWNER               12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CONTACT                       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LOCATION                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_MEMORY                        16 // 0x41      
#define  SYNTAX_ID_MS_SQL_BUILD                          9 // 0x2       
#define  SYNTAX_ID_MS_SQL_SERVICEACCOUNT                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CHARACTERSET                   9 // 0x2       
#define  SYNTAX_ID_MS_SQL_SORTORDER                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_UNICODESORTORDER               9 // 0x2       
#define  SYNTAX_ID_MS_SQL_CLUSTERED                      8 // 0x1       
#define  SYNTAX_ID_MS_SQL_NAMEDPIPE                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_MULTIPROTOCOL                 12 // 0x40      
#define  SYNTAX_ID_MS_SQL_SPX                           12 // 0x40      
#define  SYNTAX_ID_MS_SQL_TCPIP                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_APPLETALK                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_VINES                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_STATUS                        16 // 0x41      
#define  SYNTAX_ID_MS_SQL_LASTUPDATEDDATE               12 // 0x40      
#define  SYNTAX_ID_MS_SQL_INFORMATIONURL                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_CONNECTIONURL                 12 // 0x40      
#define  SYNTAX_ID_MS_SQL_PUBLICATIONURL                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSLATITUDE                   12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSLONGITUDE                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_GPSHEIGHT                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_VERSION                       12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LANGUAGE                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_DESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_MS_SQL_TYPE                          12 // 0x40      
#define  SYNTAX_ID_MS_SQL_INFORMATIONDIRECTORY           8 // 0x1       
#define  SYNTAX_ID_MS_SQL_DATABASE                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALIAS                         12 // 0x40      
#define  SYNTAX_ID_MS_SQL_SIZE                          16 // 0x41      
#define  SYNTAX_ID_MS_SQL_CREATIONDATE                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LASTBACKUPDATE                12 // 0x40      
#define  SYNTAX_ID_MS_SQL_LASTDIAGNOSTICDATE            12 // 0x40      
#define  SYNTAX_ID_MS_SQL_APPLICATIONS                  12 // 0x40      
#define  SYNTAX_ID_MS_SQL_KEYWORDS                      12 // 0x40      
#define  SYNTAX_ID_MS_SQL_PUBLISHER                     12 // 0x40      
#define  SYNTAX_ID_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING        8 // 0x1       
#define  SYNTAX_ID_MS_SQL_THIRDPARTY                     8 // 0x1       
#define  SYNTAX_ID_MS_TAPI_CONFERENCE_BLOB              10 // 0x4       
#define  SYNTAX_ID_MS_TAPI_IP_ADDRESS                   12 // 0x40      
#define  SYNTAX_ID_MS_TAPI_PROTOCOL_ID                  12 // 0x40      
#define  SYNTAX_ID_MS_TAPI_UNIQUE_IDENTIFIER            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_AUTHOR                        12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CHANGEDATE                    12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CLASS                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CLASSDEFINITION               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_CREATIONDATE                  12 // 0x40      
#define  SYNTAX_ID_MS_WMI_GENUS                          9 // 0x2       
#define  SYNTAX_ID_MS_WMI_ID                            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_INTDEFAULT                     9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS1                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS2                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS3                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTFLAGS4                      9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTMAX                         9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTMIN                         9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INTVALIDVALUES                 9 // 0x2       
#define  SYNTAX_ID_MS_WMI_INT8DEFAULT                   16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8MAX                       16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8MIN                       16 // 0x41      
#define  SYNTAX_ID_MS_WMI_INT8VALIDVALUES               16 // 0x41      
#define  SYNTAX_ID_MS_WMI_MOF                           12 // 0x40      
#define  SYNTAX_ID_MS_WMI_NAME                          12 // 0x40      
#define  SYNTAX_ID_MS_WMI_NORMALIZEDCLASS               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM1                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM2                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM3                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PARM4                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_PROPERTYNAME                  12 // 0x40      
#define  SYNTAX_ID_MS_WMI_QUERY                         12 // 0x40      
#define  SYNTAX_ID_MS_WMI_QUERYLANGUAGE                 12 // 0x40      
#define  SYNTAX_ID_MS_WMI_SCOPEGUID                     12 // 0x40      
#define  SYNTAX_ID_MS_WMI_SOURCEORGANIZATION            12 // 0x40      
#define  SYNTAX_ID_MS_WMI_STRINGDEFAULT                 12 // 0x40      
#define  SYNTAX_ID_MS_WMI_STRINGVALIDVALUES             12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETCLASS                   12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETNAMESPACE               12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETOBJECT                  10 // 0x4       
#define  SYNTAX_ID_MS_WMI_TARGETPATH                    12 // 0x40      
#define  SYNTAX_ID_MS_WMI_TARGETTYPE                    12 // 0x40      
#define  SYNTAX_ID_MSCOPE_ID                             5 // 0x13      
#define  SYNTAX_ID_MSI_FILE_LIST                        12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT                           10 // 0x4       
#define  SYNTAX_ID_MSI_SCRIPT_NAME                      12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT_PATH                      12 // 0x40      
#define  SYNTAX_ID_MSI_SCRIPT_SIZE                       9 // 0x2       
#define  SYNTAX_ID_MSMQ_AUTHENTICATE                     8 // 0x1       
#define  SYNTAX_ID_MSMQ_BASE_PRIORITY                    9 // 0x2       
#define  SYNTAX_ID_MSMQ_COMPUTER_TYPE                    4 // 0x14      
#define  SYNTAX_ID_MSMQ_COMPUTER_TYPE_EX                12 // 0x40      
#define  SYNTAX_ID_MSMQ_COST                             9 // 0x2       
#define  SYNTAX_ID_MSMQ_CSP_NAME                         4 // 0x14      
#define  SYNTAX_ID_MSMQ_DEPENDENT_CLIENT_SERVICE         8 // 0x1       
#define  SYNTAX_ID_MSMQ_DEPENDENT_CLIENT_SERVICES        8 // 0x1       
#define  SYNTAX_ID_MSMQ_DIGESTS                         10 // 0x4       
#define  SYNTAX_ID_MSMQ_DIGESTS_MIG                     10 // 0x4       
#define  SYNTAX_ID_MSMQ_DS_SERVICE                       8 // 0x1       
#define  SYNTAX_ID_MSMQ_DS_SERVICES                      8 // 0x1       
#define  SYNTAX_ID_MSMQ_ENCRYPT_KEY                     10 // 0x4       
#define  SYNTAX_ID_MSMQ_FOREIGN                          8 // 0x1       
#define  SYNTAX_ID_MSMQ_IN_ROUTING_SERVERS               1 // 0x7f      
#define  SYNTAX_ID_MSMQ_INTERVAL1                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_INTERVAL2                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_JOURNAL                          8 // 0x1       
#define  SYNTAX_ID_MSMQ_JOURNAL_QUOTA                    9 // 0x2       
#define  SYNTAX_ID_MSMQ_LABEL                            4 // 0x14      
#define  SYNTAX_ID_MSMQ_LABEL_EX                        12 // 0x40      
#define  SYNTAX_ID_MSMQ_LONG_LIVED                       9 // 0x2       
#define  SYNTAX_ID_MSMQ_MIGRATED                         8 // 0x1       
#define  SYNTAX_ID_MSMQ_MULTICAST_ADDRESS               12 // 0x40      
#define  SYNTAX_ID_MSMQ_NAME_STYLE                       8 // 0x1       
#define  SYNTAX_ID_MSMQ_NT4_FLAGS                        9 // 0x2       
#define  SYNTAX_ID_MSMQ_NT4_STUB                         9 // 0x2       
#define  SYNTAX_ID_MSMQ_OS_TYPE                          9 // 0x2       
#define  SYNTAX_ID_MSMQ_OUT_ROUTING_SERVERS              1 // 0x7f      
#define  SYNTAX_ID_MSMQ_OWNER_ID                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_PREV_SITE_GATES                  1 // 0x7f      
#define  SYNTAX_ID_MSMQ_PRIVACY_LEVEL                    9 // 0xa       
#define  SYNTAX_ID_MSMQ_QM_ID                           10 // 0x4       
#define  SYNTAX_ID_MSMQ_QUEUE_JOURNAL_QUOTA              9 // 0x2       
#define  SYNTAX_ID_MSMQ_QUEUE_NAME_EXT                  12 // 0x40      
#define  SYNTAX_ID_MSMQ_QUEUE_QUOTA                      9 // 0x2       
#define  SYNTAX_ID_MSMQ_QUEUE_TYPE                      10 // 0x4       
#define  SYNTAX_ID_MSMQ_QUOTA                            9 // 0x2       
#define  SYNTAX_ID_MSMQ_RECIPIENT_FORMATNAME            12 // 0x40      
#define  SYNTAX_ID_MSMQ_ROUTING_SERVICE                  8 // 0x1       
#define  SYNTAX_ID_MSMQ_ROUTING_SERVICES                 8 // 0x1       
#define  SYNTAX_ID_MSMQ_SECURED_SOURCE                   8 // 0x1       
#define  SYNTAX_ID_MSMQ_SERVICE_TYPE                     9 // 0x2       
#define  SYNTAX_ID_MSMQ_SERVICES                         9 // 0x2       
#define  SYNTAX_ID_MSMQ_SIGN_CERTIFICATES               10 // 0x4       
#define  SYNTAX_ID_MSMQ_SIGN_CERTIFICATES_MIG           10 // 0x4       
#define  SYNTAX_ID_MSMQ_SIGN_KEY                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_SITE_1                           1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_2                           1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_FOREIGN                     8 // 0x1       
#define  SYNTAX_ID_MSMQ_SITE_GATES                       1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_GATES_MIG                   1 // 0x7f      
#define  SYNTAX_ID_MSMQ_SITE_ID                         10 // 0x4       
#define  SYNTAX_ID_MSMQ_SITE_NAME                        4 // 0x14      
#define  SYNTAX_ID_MSMQ_SITE_NAME_EX                    12 // 0x40      
#define  SYNTAX_ID_MSMQ_SITES                           10 // 0x4       
#define  SYNTAX_ID_MSMQ_TRANSACTIONAL                    8 // 0x1       
#define  SYNTAX_ID_MSMQ_USER_SID                        10 // 0x4       
#define  SYNTAX_ID_MSMQ_VERSION                          9 // 0x2       
#define  SYNTAX_ID_MSNPALLOWDIALIN                       8 // 0x1       
#define  SYNTAX_ID_MSNPCALLEDSTATIONID                   5 // 0x16      
#define  SYNTAX_ID_MSNPCALLINGSTATIONID                  5 // 0x16      
#define  SYNTAX_ID_MSNPSAVEDCALLINGSTATIONID             5 // 0x16      
#define  SYNTAX_ID_MSRADIUSCALLBACKNUMBER                5 // 0x16      
#define  SYNTAX_ID_MSRADIUSFRAMEDIPADDRESS               9 // 0x2       
#define  SYNTAX_ID_MSRADIUSFRAMEDROUTE                   5 // 0x16      
#define  SYNTAX_ID_MSRADIUSSERVICETYPE                   9 // 0x2       
#define  SYNTAX_ID_MSRASSAVEDCALLBACKNUMBER              5 // 0x16      
#define  SYNTAX_ID_MSRASSAVEDFRAMEDIPADDRESS             9 // 0x2       
#define  SYNTAX_ID_MSRASSAVEDFRAMEDROUTE                 5 // 0x16      
#define  SYNTAX_ID_MUST_CONTAIN                          2 // 0x6       
#define  SYNTAX_ID_NAME_SERVICE_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_NC_NAME                               1 // 0x7f      
#define  SYNTAX_ID_NETBIOS_NAME                         12 // 0x40      
#define  SYNTAX_ID_NETBOOT_ALLOW_NEW_CLIENTS             8 // 0x1       
#define  SYNTAX_ID_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        8 // 0x1       
#define  SYNTAX_ID_NETBOOT_ANSWER_REQUESTS               8 // 0x1       
#define  SYNTAX_ID_NETBOOT_CURRENT_CLIENT_COUNT          9 // 0x2       
#define  SYNTAX_ID_NETBOOT_GUID                         10 // 0x4       
#define  SYNTAX_ID_NETBOOT_INITIALIZATION               12 // 0x40      
#define  SYNTAX_ID_NETBOOT_INTELLIMIRROR_OSES           12 // 0x40      
#define  SYNTAX_ID_NETBOOT_LIMIT_CLIENTS                 8 // 0x1       
#define  SYNTAX_ID_NETBOOT_LOCALLY_INSTALLED_OSES       12 // 0x40      
#define  SYNTAX_ID_NETBOOT_MACHINE_FILE_PATH            12 // 0x40      
#define  SYNTAX_ID_NETBOOT_MAX_CLIENTS                   9 // 0x2       
#define  SYNTAX_ID_NETBOOT_MIRROR_DATA_FILE             12 // 0x40      
#define  SYNTAX_ID_NETBOOT_NEW_MACHINE_NAMING_POLICY       12 // 0x40      
#define  SYNTAX_ID_NETBOOT_NEW_MACHINE_OU                1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SCP_BL                        1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SERVER                        1 // 0x7f      
#define  SYNTAX_ID_NETBOOT_SIF_FILE                     12 // 0x40      
#define  SYNTAX_ID_NETBOOT_TOOLS                        12 // 0x40      
#define  SYNTAX_ID_NETWORK_ADDRESS                       4 // 0x14      
#define  SYNTAX_ID_NEXT_LEVEL_STORE                      1 // 0x7f      
#define  SYNTAX_ID_NEXT_RID                              9 // 0x2       
#define  SYNTAX_ID_NON_SECURITY_MEMBER                   1 // 0x7f      
#define  SYNTAX_ID_NON_SECURITY_MEMBER_BL                1 // 0x7f      
#define  SYNTAX_ID_NOTIFICATION_LIST                     1 // 0x7f      
#define  SYNTAX_ID_NT_GROUP_MEMBERS                     10 // 0x4       
#define  SYNTAX_ID_NT_MIXED_DOMAIN                       9 // 0x2       
#define  SYNTAX_ID_NT_PWD_HISTORY                       10 // 0x4       
#define  SYNTAX_ID_NT_SECURITY_DESCRIPTOR               15 // 0x42      
#define  SYNTAX_ID_OBJ_DIST_NAME                         1 // 0x7f      
#define  SYNTAX_ID_OBJECT_CATEGORY                       1 // 0x7f      
#define  SYNTAX_ID_OBJECT_CLASS                          2 // 0x6       
#define  SYNTAX_ID_OBJECT_CLASS_CATEGORY                 9 // 0xa       
#define  SYNTAX_ID_OBJECT_CLASSES                       12 // 0x40      
#define  SYNTAX_ID_OBJECT_COUNT                          9 // 0x2       
#define  SYNTAX_ID_OBJECT_GUID                          10 // 0x4       
#define  SYNTAX_ID_OBJECT_SID                           17 // 0x4       
#define  SYNTAX_ID_OBJECT_VERSION                        9 // 0x2       
#define  SYNTAX_ID_OEM_INFORMATION                      12 // 0x40      
#define  SYNTAX_ID_OM_OBJECT_CLASS                      10 // 0x4       
#define  SYNTAX_ID_OM_SYNTAX                             9 // 0x2       
#define  SYNTAX_ID_OMT_GUID                             10 // 0x4       
#define  SYNTAX_ID_OMT_INDX_GUID                        10 // 0x4       
#define  SYNTAX_ID_OPERATING_SYSTEM                     12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_HOTFIX              12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_SERVICE_PACK        12 // 0x40      
#define  SYNTAX_ID_OPERATING_SYSTEM_VERSION             12 // 0x40      
#define  SYNTAX_ID_OPERATOR_COUNT                        9 // 0x2       
#define  SYNTAX_ID_OPTION_DESCRIPTION                   12 // 0x40      
#define  SYNTAX_ID_OPTIONS                               9 // 0x2       
#define  SYNTAX_ID_OPTIONS_LOCATION                      5 // 0x13      
#define  SYNTAX_ID_ORGANIZATION_NAME                    12 // 0x40      
#define  SYNTAX_ID_ORGANIZATIONAL_UNIT_NAME             12 // 0x40      
#define  SYNTAX_ID_ORIGINAL_DISPLAY_TABLE               10 // 0x4       
#define  SYNTAX_ID_ORIGINAL_DISPLAY_TABLE_MSDOS         10 // 0x4       
#define  SYNTAX_ID_OTHER_LOGIN_WORKSTATIONS             12 // 0x40      
#define  SYNTAX_ID_OTHER_MAILBOX                        12 // 0x40      
#define  SYNTAX_ID_OTHER_NAME                           12 // 0x40      
#define  SYNTAX_ID_OTHER_WELL_KNOWN_OBJECTS              7 // 0x7f      
#define  SYNTAX_ID_OWNER                                 1 // 0x7f      
#define  SYNTAX_ID_PACKAGE_FLAGS                         9 // 0x2       
#define  SYNTAX_ID_PACKAGE_NAME                         12 // 0x40      
#define  SYNTAX_ID_PACKAGE_TYPE                          9 // 0x2       
#define  SYNTAX_ID_PARENT_CA                             1 // 0x7f      
#define  SYNTAX_ID_PARENT_CA_CERTIFICATE_CHAIN          10 // 0x4       
#define  SYNTAX_ID_PARENT_GUID                          10 // 0x4       
#define  SYNTAX_ID_PARTIAL_ATTRIBUTE_DELETION_LIST       10 // 0x4       
#define  SYNTAX_ID_PARTIAL_ATTRIBUTE_SET                10 // 0x4       
#define  SYNTAX_ID_PEK_KEY_CHANGE_INTERVAL              16 // 0x41      
#define  SYNTAX_ID_PEK_LIST                             10 // 0x4       
#define  SYNTAX_ID_PENDING_CA_CERTIFICATES              10 // 0x4       
#define  SYNTAX_ID_PENDING_PARENT_CA                     1 // 0x7f      
#define  SYNTAX_ID_PER_MSG_DIALOG_DISPLAY_TABLE         10 // 0x4       
#define  SYNTAX_ID_PER_RECIP_DIALOG_DISPLAY_TABLE       10 // 0x4       
#define  SYNTAX_ID_PERSONAL_TITLE                       12 // 0x40      
#define  SYNTAX_ID_PHONE_FAX_OTHER                      12 // 0x40      
#define  SYNTAX_ID_PHONE_HOME_OTHER                     12 // 0x40      
#define  SYNTAX_ID_PHONE_HOME_PRIMARY                   12 // 0x40      
#define  SYNTAX_ID_PHONE_IP_OTHER                       12 // 0x40      
#define  SYNTAX_ID_PHONE_IP_PRIMARY                     12 // 0x40      
#define  SYNTAX_ID_PHONE_ISDN_PRIMARY                   12 // 0x40      
#define  SYNTAX_ID_PHONE_MOBILE_OTHER                   12 // 0x40      
#define  SYNTAX_ID_PHONE_MOBILE_PRIMARY                 12 // 0x40      
#define  SYNTAX_ID_PHONE_OFFICE_OTHER                   12 // 0x40      
#define  SYNTAX_ID_PHONE_PAGER_OTHER                    12 // 0x40      
#define  SYNTAX_ID_PHONE_PAGER_PRIMARY                  12 // 0x40      
#define  SYNTAX_ID_PHOTO                                10 // 0x4       
#define  SYNTAX_ID_PHYSICAL_DELIVERY_OFFICE_NAME        12 // 0x40      
#define  SYNTAX_ID_PHYSICAL_LOCATION_OBJECT              1 // 0x7f      
#define  SYNTAX_ID_PICTURE                              10 // 0x4       
#define  SYNTAX_ID_PKI_CRITICAL_EXTENSIONS              12 // 0x40      
#define  SYNTAX_ID_PKI_DEFAULT_CSPS                     12 // 0x40      
#define  SYNTAX_ID_PKI_DEFAULT_KEY_SPEC                  9 // 0x2       
#define  SYNTAX_ID_PKI_ENROLLMENT_ACCESS                15 // 0x42      
#define  SYNTAX_ID_PKI_EXPIRATION_PERIOD                10 // 0x4       
#define  SYNTAX_ID_PKI_EXTENDED_KEY_USAGE               12 // 0x40      
#define  SYNTAX_ID_PKI_KEY_USAGE                        10 // 0x4       
#define  SYNTAX_ID_PKI_MAX_ISSUING_DEPTH                 9 // 0x2       
#define  SYNTAX_ID_PKI_OVERLAP_PERIOD                   10 // 0x4       
#define  SYNTAX_ID_PKT                                  10 // 0x4       
#define  SYNTAX_ID_PKT_GUID                             10 // 0x4       
#define  SYNTAX_ID_POLICY_REPLICATION_FLAGS              9 // 0x2       
#define  SYNTAX_ID_PORT_NAME                            12 // 0x40      
#define  SYNTAX_ID_POSS_SUPERIORS                        2 // 0x6       
#define  SYNTAX_ID_POSSIBLE_INFERIORS                    2 // 0x6       
#define  SYNTAX_ID_POST_OFFICE_BOX                      12 // 0x40      
#define  SYNTAX_ID_POSTAL_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_POSTAL_CODE                          12 // 0x40      
#define  SYNTAX_ID_PREFERRED_DELIVERY_METHOD             9 // 0xa       
#define  SYNTAX_ID_PREFERREDLANGUAGE                    12 // 0x40      
#define  SYNTAX_ID_PREFERRED_OU                          1 // 0x7f      
#define  SYNTAX_ID_PREFIX_MAP                           10 // 0x4       
#define  SYNTAX_ID_PRESENTATION_ADDRESS                 13 // 0x7f      
#define  SYNTAX_ID_PREVIOUS_CA_CERTIFICATES             10 // 0x4       
#define  SYNTAX_ID_PREVIOUS_PARENT_CA                    1 // 0x7f      
#define  SYNTAX_ID_PRIMARY_GROUP_ID                      9 // 0x2       
#define  SYNTAX_ID_PRIMARY_GROUP_TOKEN                   9 // 0x2       
#define  SYNTAX_ID_PRINT_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_PRINT_BIN_NAMES                      12 // 0x40      
#define  SYNTAX_ID_PRINT_COLLATE                         8 // 0x1       
#define  SYNTAX_ID_PRINT_COLOR                           8 // 0x1       
#define  SYNTAX_ID_PRINT_DUPLEX_SUPPORTED                8 // 0x1       
#define  SYNTAX_ID_PRINT_END_TIME                        9 // 0x2       
#define  SYNTAX_ID_PRINT_FORM_NAME                      12 // 0x40      
#define  SYNTAX_ID_PRINT_KEEP_PRINTED_JOBS               8 // 0x1       
#define  SYNTAX_ID_PRINT_LANGUAGE                       12 // 0x40      
#define  SYNTAX_ID_PRINT_MAC_ADDRESS                    12 // 0x40      
#define  SYNTAX_ID_PRINT_MAX_COPIES                      9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_RESOLUTION_SUPPORTED        9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_X_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MAX_Y_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MEDIA_READY                    12 // 0x40      
#define  SYNTAX_ID_PRINT_MEDIA_SUPPORTED                12 // 0x40      
#define  SYNTAX_ID_PRINT_MEMORY                          9 // 0x2       
#define  SYNTAX_ID_PRINT_MIN_X_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_MIN_Y_EXTENT                    9 // 0x2       
#define  SYNTAX_ID_PRINT_NETWORK_ADDRESS                12 // 0x40      
#define  SYNTAX_ID_PRINT_NOTIFY                         12 // 0x40      
#define  SYNTAX_ID_PRINT_NUMBER_UP                       9 // 0x2       
#define  SYNTAX_ID_PRINT_ORIENTATIONS_SUPPORTED         12 // 0x40      
#define  SYNTAX_ID_PRINT_OWNER                          12 // 0x40      
#define  SYNTAX_ID_PRINT_PAGES_PER_MINUTE                9 // 0x2       
#define  SYNTAX_ID_PRINT_RATE                            9 // 0x2       
#define  SYNTAX_ID_PRINT_RATE_UNIT                      12 // 0x40      
#define  SYNTAX_ID_PRINT_SEPARATOR_FILE                 12 // 0x40      
#define  SYNTAX_ID_PRINT_SHARE_NAME                     12 // 0x40      
#define  SYNTAX_ID_PRINT_SPOOLING                       12 // 0x40      
#define  SYNTAX_ID_PRINT_STAPLING_SUPPORTED              8 // 0x1       
#define  SYNTAX_ID_PRINT_START_TIME                      9 // 0x2       
#define  SYNTAX_ID_PRINT_STATUS                         12 // 0x40      
#define  SYNTAX_ID_PRINTER_NAME                         12 // 0x40      
#define  SYNTAX_ID_PRIOR_SET_TIME                       16 // 0x41      
#define  SYNTAX_ID_PRIOR_VALUE                          10 // 0x4       
#define  SYNTAX_ID_PRIORITY                              9 // 0x2       
#define  SYNTAX_ID_PRIVATE_KEY                          10 // 0x4       
#define  SYNTAX_ID_PRIVILEGE_ATTRIBUTES                  9 // 0x2       
#define  SYNTAX_ID_PRIVILEGE_DISPLAY_NAME               12 // 0x40      
#define  SYNTAX_ID_PRIVILEGE_HOLDER                      1 // 0x7f      
#define  SYNTAX_ID_PRIVILEGE_VALUE                      16 // 0x41      
#define  SYNTAX_ID_PRODUCT_CODE                         10 // 0x4       
#define  SYNTAX_ID_PROFILE_PATH                         12 // 0x40      
#define  SYNTAX_ID_PROXIED_OBJECT_NAME                   7 // 0x7f      
#define  SYNTAX_ID_PROXY_ADDRESSES                      12 // 0x40      
#define  SYNTAX_ID_PROXY_GENERATION_ENABLED              8 // 0x1       
#define  SYNTAX_ID_PROXY_LIFETIME                       16 // 0x41      
#define  SYNTAX_ID_PUBLIC_KEY_POLICY                    10 // 0x4       
#define  SYNTAX_ID_PURPORTED_SEARCH                     12 // 0x40      
#define  SYNTAX_ID_PWD_HISTORY_LENGTH                    9 // 0x2       
#define  SYNTAX_ID_PWD_LAST_SET                         16 // 0x41      
#define  SYNTAX_ID_PWD_PROPERTIES                        9 // 0x2       
#define  SYNTAX_ID_QUALITY_OF_SERVICE                    9 // 0x2       
#define  SYNTAX_ID_QUERY_FILTER                         12 // 0x40      
#define  SYNTAX_ID_QUERY_POLICY_BL                       1 // 0x7f      
#define  SYNTAX_ID_QUERY_POLICY_OBJECT                   1 // 0x7f      
#define  SYNTAX_ID_QUERYPOINT                           12 // 0x40      
#define  SYNTAX_ID_RANGE_LOWER                           9 // 0x2       
#define  SYNTAX_ID_RANGE_UPPER                           9 // 0x2       
#define  SYNTAX_ID_RDN                                  12 // 0x40      
#define  SYNTAX_ID_RDN_ATT_ID                            2 // 0x6       
#define  SYNTAX_ID_REGISTERED_ADDRESS                   10 // 0x4       
#define  SYNTAX_ID_REMOTE_SERVER_NAME                   12 // 0x40      
#define  SYNTAX_ID_REMOTE_SOURCE                        12 // 0x40      
#define  SYNTAX_ID_REMOTE_SOURCE_TYPE                    9 // 0x2       
#define  SYNTAX_ID_REMOTE_STORAGE_GUID                  12 // 0x40      
#define  SYNTAX_ID_REPL_PROPERTY_META_DATA              10 // 0x4       
#define  SYNTAX_ID_REPL_TOPOLOGY_STAY_OF_EXECUTION        9 // 0x2       
#define  SYNTAX_ID_REPL_UPTODATE_VECTOR                 10 // 0x4       
#define  SYNTAX_ID_REPLICA_SOURCE                       12 // 0x40      
#define  SYNTAX_ID_REPORTS                               1 // 0x7f      
#define  SYNTAX_ID_REPL_INTERVAL                         9 // 0x2       
#define  SYNTAX_ID_REPS_FROM                            10 // 0x7f      
#define  SYNTAX_ID_REPS_TO                              10 // 0x7f      
#define  SYNTAX_ID_REQUIRED_CATEGORIES                  10 // 0x4       
#define  SYNTAX_ID_RETIRED_REPL_DSA_SIGNATURES          10 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS                         17 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL       17 // 0x4       
#define  SYNTAX_ID_TOKEN_GROUPS_NO_GC_ACCEPTABLE        17 // 0x4       
#define  SYNTAX_ID_REVISION                              9 // 0x2       
#define  SYNTAX_ID_RID                                   9 // 0x2       
#define  SYNTAX_ID_RID_ALLOCATION_POOL                  16 // 0x41      
#define  SYNTAX_ID_RID_AVAILABLE_POOL                   16 // 0x41      
#define  SYNTAX_ID_RID_MANAGER_REFERENCE                 1 // 0x7f      
#define  SYNTAX_ID_RID_NEXT_RID                          9 // 0x2       
#define  SYNTAX_ID_RID_PREVIOUS_ALLOCATION_POOL         16 // 0x41      
#define  SYNTAX_ID_RID_SET_REFERENCES                    1 // 0x7f      
#define  SYNTAX_ID_RID_USED_POOL                        16 // 0x41      
#define  SYNTAX_ID_RIGHTS_GUID                          12 // 0x40      
#define  SYNTAX_ID_ROLE_OCCUPANT                         1 // 0x7f      
#define  SYNTAX_ID_ROOMNUMBER                           12 // 0x40      
#define  SYNTAX_ID_ROOT_TRUST                            1 // 0x7f      
#define  SYNTAX_ID_RPC_NS_ANNOTATION                    12 // 0x40      
#define  SYNTAX_ID_RPC_NS_BINDINGS                      12 // 0x40      
#define  SYNTAX_ID_RPC_NS_CODESET                       12 // 0x40      
#define  SYNTAX_ID_RPC_NS_ENTRY_FLAGS                    9 // 0x2       
#define  SYNTAX_ID_RPC_NS_GROUP                         12 // 0x40      
#define  SYNTAX_ID_RPC_NS_INTERFACE_ID                  12 // 0x40      
#define  SYNTAX_ID_RPC_NS_OBJECT_ID                     12 // 0x40      
#define  SYNTAX_ID_RPC_NS_PRIORITY                       9 // 0x2       
#define  SYNTAX_ID_RPC_NS_PROFILE_ENTRY                 12 // 0x40      
#define  SYNTAX_ID_RPC_NS_TRANSFER_SYNTAX               12 // 0x40      
#define  SYNTAX_ID_SAM_ACCOUNT_NAME                     12 // 0x40      
#define  SYNTAX_ID_SAM_ACCOUNT_TYPE                      9 // 0x2       
#define  SYNTAX_ID_SCHEDULE                             10 // 0x4       
#define  SYNTAX_ID_SCHEMA_FLAGS_EX                       9 // 0x2       
#define  SYNTAX_ID_SCHEMA_ID_GUID                       10 // 0x4       
#define  SYNTAX_ID_SCHEMA_INFO                          10 // 0x4       
#define  SYNTAX_ID_SCHEMA_UPDATE                        11 // 0x18      
#define  SYNTAX_ID_SCHEMA_VERSION                        9 // 0x2       
#define  SYNTAX_ID_SCOPE_FLAGS                           9 // 0x2       
#define  SYNTAX_ID_SCRIPT_PATH                          12 // 0x40      
#define  SYNTAX_ID_SD_RIGHTS_EFFECTIVE                   9 // 0x2       
#define  SYNTAX_ID_SEARCH_FLAGS                          9 // 0xa       
#define  SYNTAX_ID_SEARCH_GUIDE                         10 // 0x4       
#define  SYNTAX_ID_SECRETARY                             1 // 0x7f      
#define  SYNTAX_ID_SECURITY_IDENTIFIER                  17 // 0x4       
#define  SYNTAX_ID_SEE_ALSO                              1 // 0x7f      
#define  SYNTAX_ID_SEQ_NOTIFICATION                      9 // 0x2       
#define  SYNTAX_ID_SERIAL_NUMBER                         5 // 0x13      
#define  SYNTAX_ID_SERVER_NAME                          12 // 0x40      
#define  SYNTAX_ID_SERVER_REFERENCE                      1 // 0x7f      
#define  SYNTAX_ID_SERVER_REFERENCE_BL                   1 // 0x7f      
#define  SYNTAX_ID_SERVER_ROLE                           9 // 0x2       
#define  SYNTAX_ID_SERVER_STATE                          9 // 0x2       
#define  SYNTAX_ID_SERVICE_BINDING_INFORMATION          12 // 0x40      
#define  SYNTAX_ID_SERVICE_CLASS_ID                     10 // 0x4       
#define  SYNTAX_ID_SERVICE_CLASS_INFO                   10 // 0x4       
#define  SYNTAX_ID_SERVICE_CLASS_NAME                   12 // 0x40      
#define  SYNTAX_ID_SERVICE_DNS_NAME                     12 // 0x40      
#define  SYNTAX_ID_SERVICE_DNS_NAME_TYPE                12 // 0x40      
#define  SYNTAX_ID_SERVICE_INSTANCE_VERSION             10 // 0x4       
#define  SYNTAX_ID_SERVICE_PRINCIPAL_NAME               12 // 0x40      
#define  SYNTAX_ID_SETUP_COMMAND                        12 // 0x40      
#define  SYNTAX_ID_SHELL_CONTEXT_MENU                   12 // 0x40      
#define  SYNTAX_ID_SHELL_PROPERTY_PAGES                 12 // 0x40      
#define  SYNTAX_ID_SHORT_SERVER_NAME                    12 // 0x40      
#define  SYNTAX_ID_SHOW_IN_ADDRESS_BOOK                  1 // 0x7f      
#define  SYNTAX_ID_SHOW_IN_ADVANCED_VIEW_ONLY            8 // 0x1       
#define  SYNTAX_ID_SID_HISTORY                          17 // 0x4       
#define  SYNTAX_ID_SIGNATURE_ALGORITHMS                 12 // 0x40      
#define  SYNTAX_ID_SITE_GUID                            10 // 0x4       
#define  SYNTAX_ID_SITE_LINK_LIST                        1 // 0x7f      
#define  SYNTAX_ID_SITE_LIST                             1 // 0x7f      
#define  SYNTAX_ID_SITE_OBJECT                           1 // 0x7f      
#define  SYNTAX_ID_SITE_OBJECT_BL                        1 // 0x7f      
#define  SYNTAX_ID_SITE_SERVER                           1 // 0x7f      
#define  SYNTAX_ID_SMTP_MAIL_ADDRESS                    12 // 0x40      
#define  SYNTAX_ID_SPN_MAPPINGS                         12 // 0x40      
#define  SYNTAX_ID_STATE_OR_PROVINCE_NAME               12 // 0x40      
#define  SYNTAX_ID_STREET_ADDRESS                       12 // 0x40      
#define  SYNTAX_ID_STRUCTURAL_OBJECT_CLASS               2 // 0x6       
#define  SYNTAX_ID_SUB_CLASS_OF                          2 // 0x6       
#define  SYNTAX_ID_SUB_REFS                              1 // 0x7f      
#define  SYNTAX_ID_SUBSCHEMASUBENTRY                     1 // 0x7f      
#define  SYNTAX_ID_SUPER_SCOPE_DESCRIPTION              12 // 0x40      
#define  SYNTAX_ID_SUPER_SCOPES                          5 // 0x13      
#define  SYNTAX_ID_SUPERIOR_DNS_ROOT                    12 // 0x40      
#define  SYNTAX_ID_SUPPLEMENTAL_CREDENTIALS             10 // 0x4       
#define  SYNTAX_ID_SUPPORTED_APPLICATION_CONTEXT        10 // 0x4       
#define  SYNTAX_ID_SURNAME                              12 // 0x40      
#define  SYNTAX_ID_SYNC_ATTRIBUTES                       9 // 0x2       
#define  SYNTAX_ID_SYNC_MEMBERSHIP                       1 // 0x7f      
#define  SYNTAX_ID_SYNC_WITH_OBJECT                      1 // 0x7f      
#define  SYNTAX_ID_SYNC_WITH_SID                        17 // 0x4       
#define  SYNTAX_ID_SYSTEM_AUXILIARY_CLASS                2 // 0x6       
#define  SYNTAX_ID_SYSTEM_FLAGS                          9 // 0x2       
#define  SYNTAX_ID_SYSTEM_MAY_CONTAIN                    2 // 0x6       
#define  SYNTAX_ID_SYSTEM_MUST_CONTAIN                   2 // 0x6       
#define  SYNTAX_ID_SYSTEM_ONLY                           8 // 0x1       
#define  SYNTAX_ID_SYSTEM_POSS_SUPERIORS                 2 // 0x6       
#define  SYNTAX_ID_TELEPHONE_NUMBER                     12 // 0x40      
#define  SYNTAX_ID_TELETEX_TERMINAL_IDENTIFIER          10 // 0x4       
#define  SYNTAX_ID_TELEX_NUMBER                         10 // 0x4       
#define  SYNTAX_ID_TELEX_PRIMARY                        12 // 0x40      
#define  SYNTAX_ID_TEMPLATE_ROOTS                        1 // 0x7f      
#define  SYNTAX_ID_TERMINAL_SERVER                      10 // 0x4       
#define  SYNTAX_ID_TEXT_COUNTRY                         12 // 0x40      
#define  SYNTAX_ID_TEXT_ENCODED_OR_ADDRESS              12 // 0x40      
#define  SYNTAX_ID_TIME_REFRESH                         16 // 0x41      
#define  SYNTAX_ID_TIME_VOL_CHANGE                      16 // 0x41      
#define  SYNTAX_ID_TITLE                                12 // 0x40      
#define  SYNTAX_ID_TOMBSTONE_LIFETIME                    9 // 0x2       
#define  SYNTAX_ID_TRANSPORT_ADDRESS_ATTRIBUTE           2 // 0x6       
#define  SYNTAX_ID_TRANSPORT_DLL_NAME                   12 // 0x40      
#define  SYNTAX_ID_TRANSPORT_TYPE                        1 // 0x7f      
#define  SYNTAX_ID_TREAT_AS_LEAF                         8 // 0x1       
#define  SYNTAX_ID_TREE_NAME                            12 // 0x40      
#define  SYNTAX_ID_TRUST_ATTRIBUTES                      9 // 0x2       
#define  SYNTAX_ID_TRUST_AUTH_INCOMING                  10 // 0x4       
#define  SYNTAX_ID_TRUST_AUTH_OUTGOING                  10 // 0x4       
#define  SYNTAX_ID_TRUST_DIRECTION                       9 // 0x2       
#define  SYNTAX_ID_TRUST_PARENT                          1 // 0x7f      
#define  SYNTAX_ID_TRUST_PARTNER                        12 // 0x40      
#define  SYNTAX_ID_TRUST_POSIX_OFFSET                    9 // 0x2       
#define  SYNTAX_ID_TRUST_TYPE                            9 // 0x2       
#define  SYNTAX_ID_UAS_COMPAT                            9 // 0x2       
#define  SYNTAX_ID_UID                                  12 // 0x40      
#define  SYNTAX_ID_UNC_NAME                             12 // 0x40      
#define  SYNTAX_ID_UNICODE_PWD                          10 // 0x4       
#define  SYNTAX_ID_UNIQUEMEMBER                          1 // 0x7f      
#define  SYNTAX_ID_UNSTRUCTUREDADDRESS                  12 // 0x40      
#define  SYNTAX_ID_UNSTRUCTUREDNAME                      5 // 0x16      
#define  SYNTAX_ID_UPGRADE_PRODUCT_CODE                 10 // 0x4       
#define  SYNTAX_ID_UPN_SUFFIXES                         12 // 0x40      
#define  SYNTAX_ID_USER_ACCOUNT_CONTROL                  9 // 0x2       
#define  SYNTAX_ID_USER_CERT                            10 // 0x4       
#define  SYNTAX_ID_USER_COMMENT                         12 // 0x40      
#define  SYNTAX_ID_USER_PARAMETERS                      12 // 0x40      
#define  SYNTAX_ID_USER_PASSWORD                        10 // 0x4       
#define  SYNTAX_ID_USERPKCS12                           10 // 0x4       
#define  SYNTAX_ID_USER_PRINCIPAL_NAME                  12 // 0x40      
#define  SYNTAX_ID_USER_SHARED_FOLDER                   12 // 0x40      
#define  SYNTAX_ID_USER_SHARED_FOLDER_OTHER             12 // 0x40      
#define  SYNTAX_ID_USER_SMIME_CERTIFICATE               10 // 0x4       
#define  SYNTAX_ID_USER_WORKSTATIONS                    12 // 0x40      
#define  SYNTAX_ID_USN_CHANGED                          16 // 0x41      
#define  SYNTAX_ID_USN_CREATED                          16 // 0x41      
#define  SYNTAX_ID_USN_DSA_LAST_OBJ_REMOVED             16 // 0x41      
#define  SYNTAX_ID_USN_INTERSITE                         9 // 0x2       
#define  SYNTAX_ID_USN_LAST_OBJ_REM                     16 // 0x41      
#define  SYNTAX_ID_USN_SOURCE                           16 // 0x41      
#define  SYNTAX_ID_VALID_ACCESSES                        9 // 0x2       
#define  SYNTAX_ID_VENDOR                               12 // 0x40      
#define  SYNTAX_ID_VERSION_NUMBER                        9 // 0x2       
#define  SYNTAX_ID_VERSION_NUMBER_HI                     9 // 0x2       
#define  SYNTAX_ID_VERSION_NUMBER_LO                     9 // 0x2       
#define  SYNTAX_ID_VOL_TABLE_GUID                       10 // 0x4       
#define  SYNTAX_ID_VOL_TABLE_IDX_GUID                   10 // 0x4       
#define  SYNTAX_ID_VOLUME_COUNT                          9 // 0x2       
#define  SYNTAX_ID_WBEM_PATH                            12 // 0x40      
#define  SYNTAX_ID_WELL_KNOWN_OBJECTS                    7 // 0x7f      
#define  SYNTAX_ID_WHEN_CHANGED                         11 // 0x18      
#define  SYNTAX_ID_WHEN_CREATED                         11 // 0x18      
#define  SYNTAX_ID_WINSOCK_ADDRESSES                    10 // 0x4       
#define  SYNTAX_ID_WWW_HOME_PAGE                        12 // 0x40      
#define  SYNTAX_ID_WWW_PAGE_OTHER                       12 // 0x40      
#define  SYNTAX_ID_X121_ADDRESS                          6 // 0x12      
#define  SYNTAX_ID_X500UNIQUEIDENTIFIER                 10 // 0x4       
#define  SYNTAX_ID_X509_CERT                            10 // 0x4       


#endif \\_ATTIDS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dbopen.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbopen.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file function prototypes that clients of the dbopen library can use
    to open/close a DS Jet database.

Environment:

    User Mode - Win32

Notes:

--*/

#ifndef __DBOPEN_H
#define __DBOPEN_H

#ifdef __cplusplus
extern "C" {
#endif

#include <esent.h>


extern INT
DBInitializeJetDatabase(
    IN JET_INSTANCE* JetInst,
    IN JET_SESID* SesId,
    IN JET_DBID* DbId,
    IN const char *szDBPath,
    IN BOOL bLogSeverity
    );


extern void
DBSetRequiredDatabaseSystemParameters (
    JET_INSTANCE *jInstance
    );


extern void 
DBSetDatabaseSystemParameters ( 
    JET_INSTANCE *jInstance, 
    unsigned fInitAdvice 
    );


// Never, ever, change this.  see remarks in dbinit.c
//
#define JET_LOG_FILE_SIZE (10 * 1024)

// 8K pages.
//
#define JET_PAGE_SIZE     (8 * 1024)


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dnsresl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dnsresl.h
//
//--------------------------------------------------------------------------


#ifndef __DSLIB_H
#define __DSLIB_H

#define IPADDRSTR_SIZE 16

typedef struct _DNSRESL_GET_DNS_PD {
    INT                                iQueryBufferSize;
    PWSAQUERYSETW                      pQuery;
    HANDLE                             hWsaLookup;
} DNSRESL_GET_DNS_PD, *PDNSRESL_GET_DNS_PD;

DWORD GetIpAddrByDnsNameW(
    IN      LPWSTR                     pszHostName,
    OUT     LPWSTR                     pszIP);

DWORD GetDnsHostNameW(
    IN OUT  VOID **                    ppPrivData,
    IN      LPWSTR                     pszNameToLookup,
    OUT     LPWSTR *                   ppszDnsHostName);

DWORD GetDnsAliasNamesW(
    IN OUT  VOID **                    ppPrivData,
    OUT     LPWSTR *                   ppszDnsHostName);

VOID GetDnsFreeW(
    IN      VOID **                    ppPrivData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dbglobal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbglobal.h
//
//--------------------------------------------------------------------------


// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

#ifndef _dbglobal_h_
#define _dbglobal_h_

#define MAXSYNTAX           18      // The largest number of att syntaxes.
#define INBUF_INITIAL       256     // The initial input buffer size
#define VALBUF_INITIAL      512     // The initial value work buffer size

#define DB_CB_MAX_KEY       255     // Maximum size of a JET key.

// Tuple index related defines.
#define DB_TUPLES_LEN_MIN        0x3     // The minimum length tuple to index in characters
#define DB_TUPLES_LEN_MAX        0xa     // The maximum length tuple to index in characters
#define DB_TUPLES_TO_INDEX_MAX   0x7fff  // The maximum number of tuples in a single
                                         // key, to index.

//
// Comment this line out if the check for loss of administrator
// group membership is not needed. THis is to track down a self host
// corruption problem where the NTWKSTA domain loss all its admin
// group memberships
//

#define CHECK_FOR_ADMINISTRATOR_LOSS 1



// This structure is used to internally represent a Distname-String syntax
// and the Distname-Binary syntax

typedef struct {
   ULONG              tag;              // Internal distname
   STRING_LENGTH_PAIR data;             // data
} INTERNAL_SYNTAX_DISTNAME_STRING;

// This structure holds data about pending security descriptor propagation
// information
typedef struct _SDPropInfo {
    DWORD index;
    DWORD beginDNT;
    DWORD clientID;
    DWORD flags;
} SDPropInfo;

// The following structure is used to maintain a list of NCDNTs for notification
// after the current transaction completes.

typedef struct _NCnotification {
    ULONG ulNCDNT;
    BOOL fUrgent;
    struct _NCnotification *pNext;
} NCnotification, *PNCnotification;

//
// The following structure allows for maintaining linked lists of DNs being
// added. One global list, guaranteeing that 2 identical entries aren't being
// added simultaneously. Each DBPOS contains a list of DNs added using it. This
// list is cleared and removed from the global list at transaction end
// time. From then on, the responsibility of disallowing duplicates is in the
// hands of the database
//

#pragma warning (disable: 4200)
typedef struct _DNLIST
{
    struct _DNLIST *pNext;
    DWORD          dwFlags;
    DWORD          dwTid;
    BYTE           rgb[];
} DNList;
// Flags for DBLockDN.
// This flag means to lock the whole tree under the given DN.
#define DB_LOCK_DN_WHOLE_TREE        1
// Normal behaviour for locked DNs is that they are released automatically when
// the DBPOS they were locked on is DBClosed.  This flags means that the DN
// should remain locked on the global locked DN list until explicitly freed via
// DBUnlockStickyDN()
#define DB_LOCK_DN_STICKY            2

#pragma warning (default: 4200)

typedef struct _KEY_INDEX {
    ULONG    ulEstimatedRecsInRange; // for the particular index
    BOOL     bIsSingleValued;        // Is this a single valued index?
    BOOL     bIsEqualityBased;       // Are we walking this index for an
                                     // equality test?
    BOOL     bIsForSort;             // Is this index here to satisfy a sorted
                                     // search?
    UCHAR    *szIndexName;           // jet index name
    BOOL     bIsPDNTBased;           // Index first column PDNT?
    BYTE     *rgbDBKeyLower;         // lower limit for jetkey in this query
    ULONG    cbDBKeyLower;           // size of the above (max DB_CB_MAX_KEY )
    BYTE     *rgbDBKeyUpper;         // Upper limit for jetkey in this query
    ULONG    cbDBKeyUpper;           // size of the above (max DB_CB_MAX_KEY )

    BOOL     bIsTupleIndex;          // whether this is a tuple index
    ATTCACHE *pAC;                   // possible ATTCACHE for the index

    BOOL        bIsIntersection;     // flag whether this is an intersection index
    JET_TABLEID tblIntersection;     // the temp table used in the intersection
    JET_COLUMNID columnidBookmark;   // the column id that idendifies the bookmark in the intersect table

    struct _KEY_INDEX *pNext;
} KEY_INDEX;

// What kind of duplicate detection algorithm are we using?
#define DUP_NEVER       0
#define DUP_HASH_TABLE  1
#define DUP_MEMORY      2

// Index types
#define INVALID_INDEX_TYPE     0
#define UNSET_INDEX_TYPE       1
#define GENERIC_INDEX_TYPE     2
#define TEMP_TABLE_INDEX_TYPE  3
#define ANCESTORS_INDEX_TYPE   4
#define INTERSECT_INDEX_TYPE   5
#define TEMP_TABLE_MEMORY_ARRAY_TYPE  6
#define TUPLE_INDEX_TYPE       7

// For the in-memory duplicate detection, how many DNTs will we hold
#define DUP_BLOCK_SIZE 64

#define VLV_MOVE_FIRST     0x80000000
#define VLV_MOVE_LAST      0x7FFFFFFF
#define VLV_CALC_POSITION  1

typedef struct _VLV_SEARCH {
    VLV_REQUEST *pVLVRequest;           // VLV ARGUMENT supplied by client

    ULONG       positionOp;             // Position Operator for Fractional Positioning
                                        // VLV_MOVE_FIRST, VLV_MOVE_LAST, VLV_CALC_POSITION

    ULONG       clnCurrPos;             // client Current Position (Ci)
    ULONG       clnContentCount;        // client Estimate of Content Count (Cc)

    ULONG       currPosition;           // server Currect Position (Si)
    ULONG       contentCount;           // actual ContentCount (Sc)

    ULONG       requestedEntries;       // total Number Req Entries

    ATTRTYP     SortAttr;               // the sort attr of this VLV search
    DWORD       Err;                    // the VLV specific error code to return

    DWORD       cbCurrPositionKey;
    BYTE        rgbCurrPositionKey[DB_CB_MAX_KEY];

    BOOL        bUsingMAPIContainer;    // TRUE whether we are doing VLV on a MAPI container
    DWORD       MAPIContainerDNT;       // the DNT of the ABView container

} VLV_SEARCH;

// info about a search
typedef struct _KEY {
    FILTER                *pFilter;
    POBJECT_TYPE_LIST     pFilterSecurity;
    DWORD                 *pFilterResults;
    ULONG                 FilterSecuritySize;
    BOOL                  *pbSortSkip;
    // the following fields restrict the range of JET keys on searche (or list)

    DWORD    dupDetectionType;       // What kind of duplicate detection
                                     // algorithm are we using
    DWORD    cDupBlock;              // For the in-memory dup detection, how
                                     // many objects have we found?
    DWORD   *pDupBlock;              // Memory block for in-memory dup detection
    struct _LHT *plhtDup;            // Hash table for dup detection

    BOOL     fSearchInProgress;
    BOOL     bOnCandidate;           // Used to create restarts and for
                                     // repositioning after a timelimit has been
                                     // hit.  Is a marker for wether we are
                                     // positioned on an object that will match
                                     // the search if it matches the filter.

    // pointer to the first index info for this search key
    KEY_INDEX *pIndex;

    // The following fields specify the search type
    ULONG   ulSearchType;            // SE_CHOICE_BASE_ONLY
                                     // SE_CHOICE_IMMED_CHILDREN
                                     // SE_CHOICE_WHOLE_SUBTREE

    ULONG   ulSearchRootDnt;         // Dnt of the root of the search
    ULONG   ulSearchRootPDNT;        // PDNT of the root of the search
    ULONG   ulSearchRootNcdnt;       // Ncdnt of the root of the search

    ULONG   ulSorted;                // Does this key describe a sorted search?
    BOOL    bOneNC;                  // Is the search limited to one NC?

    DWORD   indexType;

    ULONG   ulEntriesInTempTable;    // If this describes a TempTable,
                                     // the number of entries in this table
                                     // zero if not known

    // the following fields describe a VLV search
    VLV_SEARCH   *pVLV;

    // the following fields describe an ASQ search
    ASQ_REQUEST asqRequest;
    DWORD       asqMode;                // the ASQ mode (simple, sorted, paged, vlv)

    ULONG       ulASQLastUpperBound;    // the last entry retrieved from
                                        // the attribute specified in the ASQ
                                        // request
    ULONG       ulASQSizeLimit;         // number of entries requested


    // the following are used for VLV and ASQ searches
    DWORD        cdwCountDNTs;          // Number of entries in the DNT array
    DWORD        *pDNTs;                // all the entries in sorted order
    DWORD        currRecPos;            // the current position in the array
                                        // like a database cursor
                                        // valid values 1..cdwCountDNTs
                                        // 0 = BOF
                                        // cdwCountDNTs + 1 = EOF

    BOOL         fDontFreeFilter;       // flag whether to free the filter
                                        // needed if it is an ANR
} KEY;

// what kind of ASQ mode we are doing
#define ASQ_SIMPLE 0
#define ASQ_SORTED 1
#define ASQ_PAGED  2
#define ASQ_VLV    4

// The database anchor data structure pointed to by a database handle.
typedef struct DBPOS{
   struct _THSTATE *pTHS;               // Our thread state
   ULONG        valBufSize;
   UCHAR       *pValBuf;                // used when the att val is translated
   ULONG        DNT;                    // The current objects DNT
   ULONG        PDNT;                   // The current objects parent DNT
                    // (only if not root)
   ULONG        SDNT;                   // The current DNT for JetSearchTbl
   ULONG        NCDNT;                  // The NC master DNT
                    // This field has specialized use and
                    // is not generally maintained
   JET_DBID     JetDBID;
   JET_SESID    JetSessID;
   JET_TABLEID  JetSDPropTbl;           // Table for SD propagation events.
   JET_TABLEID  JetObjTbl;              // Main table ID
   JET_TABLEID  JetSearchTbl;           // Table id used with dbsubj.c
   JET_TABLEID  JetLinkTbl;             // Table for links and backlinks
   JET_TABLEID  JetSDTbl;               // Table for security descriptors
   JET_TABLEID  JetSortTbl;             // Temp table for sorting
   JET_COLUMNID SortColumns[3];         // ColumnIDs for the two columns in the
                    // sort table.
   JET_GRBIT    JetRetrieveBits;        // grbits for JetRetrieve Column
   int          SDEvents;               // Number of events queued/dequeued in
                                        // this dbpos.
   unsigned     transType:2;            // read, writ, or exclusive write
   BOOL         root:1;                 // indicates if the object is the root
   BOOL         JetCacheRec:1;          // indicates if the current record is cached in Jet
   BOOL         JetNewRec:1;            // Indicates if this is an insert
   BOOL         fIsMetaDataCached:1;    // Has pMetaDataVec been cached for this
                                        //   object?
   BOOL         fIsLinkMetaDataCached:1;  // Has pLinkMetaData been cached for this
                                        //   object?
   BOOL         fMetaDataWriteOptimizable:1; // Indicates if the meta data write
                                             // can be optimized; A meta data write
                                             // can be explicitly optimized only if
                                             // the meta data changes are in-place
                                             // (i.e. no inserts or deletes)
                                             // This flag is meaningful only if
                                             // fIsMetaDataCached is TRUE.
   BOOL         fHidden:1 ;             // Is this the Hidden record PDB. The hidden
                                        // record pDB is based on an  independant
                                        // jet session, that is unrelated to the
                                        // jet session on pTHStls. Therefore this
                                        // state needs to be maintained so that a
                                        // proper transaction level count can be
                                        // maintained.
   BOOL         fFlushCacheOnUpdate:1;  // Set when the update in progress in
                                        //   JetObjTbl includes a name, objflag,
                                        //   or other change that affects the
                                        //   DN read cache.  Forces a flush of
                                        //   the DNT from the read cache on
                                        //   DBUpdateRec().
   BOOL         fScopeLegacyLinks:1;    // When this flag is set, search for links
                                        // on special index that excludes metadata
   BOOL         fSkipMetadataUpdate:1;  // when this is set, we skip metadata update
                                        // this should olnly be set during 
                                        // domain rename operation

   KEY          Key;                    // Search key associated with this pDB

   DNList  *pDNsAdded;                  // List of DNs added using this DBPOS

   DWORD        cbMetaDataVecAlloced;   // Allocated meta data vector size in
                                        //   bytes (if fIsMetaDataCached).
   PROPERTY_META_DATA_VECTOR *          // Per-property replication meta data
                pMetaDataVec;           //   for the object with currency (if
                                        //   fIsMetaDataCached).  Can be NULL.
   VALUE_META_DATA *pLinkMetaData;      // Maximal value metadata for this object.
   ULONG        transincount;           // Current nesting level of DBtransIns
                                        // on this pDB.

   DWORD       *pAncestorsBuff;         // Buffer used to hold ancestors during
                                        // WHOLE_SUBTREE searches.  It's here
                                        // because down in the core of the
                                        // whole_subtree search, we read the
                                        // ancestors of search candidates.
                                        // Allocating and freeing a buff for
                                        // each one of these reads is really
                                        // painful. This is the only lasting
                                        // place to hang this buffer, without
                                        // forcing routines like LocalSearch to
                                        // be aware of this buffer.  This buffer
                                        // is not generally maintained; that is,
                                        // don't read the ancestors from here
                                        // unless you just put them there or you
                                        // will probably get some other objects
                                        // ancestors.
                                        // When allocated, it is THAllocOrg'ed
   DWORD        cbAncestorsBuff;        // Size in bytes of pAncestorsBuff


   DWORD       SearchEntriesVisited;    // number of entries visited during a search operation
   DWORD       SearchEntriesReturned;   // number of entries returned during a search operation
   ULONG       NewlyCreatedDNT;         // Last new row created in this transaction

   // NOTE: If you add new elements to this structure after the last non-DBG
   // element, you'll need to change the non-DBG DBPOS size calculation in
   // Dump_DBPOS() in dsexts\md.c.

   // Put all DBG components at end of structure so that dsexts routines
   // can easily ignore them (and get all other fields right) in both
   // debug and free builds.

#if DBG
   ULONG        TransactionLevelAtOpen; // This is the transaction level in the
                                        // thread state when the DBOpen was done.
                                        // DBTransOut's assert that the commit is always
                                        // to a level less than this transaction level.

   DWORD       numTempTablesOpened;     // count number of temporary tables opened
                                        // (used for sorting, intersecting)
#endif

}DBPOS, *PDBPOS;


extern BOOL  gfDoingABRef;


extern BOOL IsValidDBPOS(DBPOS * pDB);

#if DBG

#define VALID_DBPOS(pDB) IsValidDBPOS(pDB)

#else

#define VALID_DBPOS(pDB) (TRUE)

#endif

#if DBG

#define VALID_TRIBOOL(retval) \
        (( (retval) >= eFALSE) && ( (retval) <= eUNDEFINED))

#else

#define VALID_TRIBOOL(retval) (TRUE)

#endif


// Typedef for return codes.
typedef long DB_ERR;                    // same as JET_ERR

// Structure for composite index values
typedef struct {
    void *pvData;
    ULONG cbData;
} INDEX_VALUE;

// Some globals that define how we do ANR.  Default value of these is FALSE.
extern BOOL gfSupressFirstLastANR;
extern BOOL gfSupressLastFirstANR;

// Index ids for DBSetCurrentIndex.
typedef enum _eIndexId {
    Idx_Proxy = 1,
    Idx_MapiDN,
    Idx_Dnt,
    Idx_Pdnt,
    Idx_Rdn,
    Idx_DraUsn,
    Idx_DsaUsn,
    Idx_ABView,
    Idx_Phantom,
    Idx_Sid,
    Idx_Del,
    Idx_NcAccTypeName,
    Idx_NcAccTypeSid,
    Idx_LinkDraUsn,
    Idx_DraUsnCritical,
    Idx_LinkDel,
    Idx_Clean,
    Idx_InvocationId,
    Idx_ObjectGuid,
    Idx_NcGuid
  } eIndexId;

// The DNT of the root object
#define ROOTTAG 2

// DNT of the place holder "NOT AN OBJECT" object.
#define NOTOBJECTTAG 1

// An invalid DNT
#define INVALIDDNT 0xFFFFFFFF

//
// Some error returns
#define DB_success                       0
#define DB_ERR_UNKNOWN_ERROR             1 // catch those return 1;'s
#define DB_ERR_NO_CHILD                  2
#define DB_ERR_NEXTCHILD_NOTFOUND        3
#define DB_ERR_CANT_SORT                 4
#define DB_ERR_TIMELIMIT                 5
#define DB_ERR_NO_VALUE                  6
#define DB_ERR_BUFFER_INADEQUATE         7
//unused                                 8
#define DB_ERR_VALUE_TRUNCATED           9
#define DB_ERR_ATTRIBUTE_EXISTS         10
#define DB_ERR_ATTRIBUTE_DOESNT_EXIST   11
#define DB_ERR_VALUE_EXISTS             12
#define DB_ERR_SYNTAX_CONVERSION_FAILED 13
#define DB_ERR_NOT_ON_BACKLINK          14
#define DB_ERR_VALUE_DOESNT_EXIST       15
#define DB_ERR_NO_PROPAGATIONS          16
#define DB_ERR_DATABASE_ERROR           17
#define DB_ERR_CANT_ADD_DEL_KEY         18
#define DB_ERR_DSNAME_LOOKUP_FAILED     19
#define DB_ERR_NO_MORE_DEL_RECORD       20
#define DB_ERR_NO_SORT_TABLE            21
#define DB_ERR_NOT_OPTIMIZABLE          22
#define DB_ERR_BAD_INDEX                23
//unused                                24
#define DB_ERR_TOO_MANY                 25
#define DB_ERR_SYSERROR                 26
#define DB_ERR_BAD_SYNTAX               27
//unused                                28
#define DB_ERR_NOT_ON_CORRECT_VALUE     29
#define DB_ERR_ONLY_ON_LINKED_ATTRIBUTE 30
#define DB_ERR_EXCEPTION                31 // something blew up
#define DB_ERR_SHUTTING_DOWN            32
#define DB_ERR_WRITE_CONFLICT           33
#define DB_ERR_VLV_CONTROL              34
#define DB_ERR_NOT_AN_OBJECT            35
#define DB_ERR_ALREADY_INSERTED         JET_errKeyDuplicate
#define DB_ERR_NO_CURRENT_RECORD        JET_errNoCurrentRecord
#define DB_ERR_RECORD_NOT_FOUND         JET_errRecordNotFound
// NOTE: If you add an error to this list, you MUST add a corresponding
// DIRMSG_DB_ERR_* in mdcodes.mc.

DB_ERR
DBErrFromJetErr(
    IN  DWORD   jetErr
    );

extern DWORD
DBRenameInstallDIT (
    DBPOS *pDB,
    BOOL fAddWhenCreated,
    SZ   szEnterpriseName,
    SZ   szSiteName,
    SZ   szServerName
    );


extern int
DBInit ( void );

extern void
DBEnd (
       void
       );

extern USHORT
DBTransIn(
    DBPOS FAR *pDB
    );

extern USHORT
DBTransOut(DBPOS FAR *pDB,
       BOOL fCommit,
       BOOL fLazy
       );

extern USN
DBGetLowestUncommittedUSN (
    void
    );

extern USN
DBGetHighestCommittedUSN (
    void
    );

//
// Setting Flags stored in the database
//
extern CHAR gdbFlags[200];
// indexes used into this array
#define DBFLAGS_AUXCLASS 0

// flag that is set if the SDs need to be updated
// it is only set when an old DIT is detected (without SD table)
#define DBFLAGS_SD_CONVERSION_REQUIRED 1

ULONG DBUpdateHiddenFlags();


extern USHORT
DBGetHiddenRec (
    DSNAME **ppDSA,
    USN *pusnInit
    );

extern ULONG
DBReplaceHiddenDSA (
    DSNAME *pDSA
    );

extern ULONG
DBReplaceHiddenUSN (
    USN usnInit
    );

typedef enum
{
    eInitialDit,
    eBootDit,
    eInstalledDit,
    eRunningDit,
    eBackedupDit,
    eErrorDit,
    eMaxDit
}DITSTATE;

extern ULONG
DBGetHiddenState(
    DITSTATE* pState
    );

extern ULONG
DBSetHiddenState(
    DITSTATE State
    );

// GetSecondsSince1601 defined in taskq.lib.
extern DSTIME
GetSecondsSince1601();

#define DBTime GetSecondsSince1601

void
DBOpen2 (
    BOOL fNewTransaction,
    DBPOS FAR **ppDB
    );

#define DBOpen(ppDB) DBOpen2(TRUE, ppDB)

extern DWORD
DBClose (
    DBPOS *pDB,
    BOOL fCommit
    );


// DBCloseSafe is the same as DBClose, except that it is guaranteed never to
// raise an exception (more precisely, that it will catch any that are raised
// and convert them to error codes.)
extern DWORD
DBCloseSafe (
    DBPOS *pDB,
    BOOL fCommit
    );


// this is the number of entries to be sorted for which it is economical to use
// a forward-only sort table.  forward-only sorts allocate large chunks of
// virtual address space during processing while normal sorts only use space
// in the database cache like any other table
#define MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT 100

// Some flags for sort table creation.
#define DB_SORT_DESCENDING 0x1
#define DB_SORT_ASCENDING  0x0
#define DB_SORT_FORWARDONLY 0x2
extern DB_ERR
DBOpenSortTable (DBPOS *pDB,
                 ULONG SortLocale,
                 DWORD flags,
                 ATTCACHE *pAC);

extern DB_ERR
DBCloseSortTable (DBPOS *pDB);

extern DB_ERR
DBInsertSortTable (DBPOS *pDB,
           CHAR * TextBuff,
           DWORD cb,
           DWORD DNT);

DB_ERR
DBDeleteFromSortTable (
        DBPOS *pDB
        );

extern DB_ERR
DBGetDNTSortTable (
        DBPOS *pDB,
        DWORD *pvData
        );

extern DWORD
DBPositionVLVSearch (
    DBPOS *pDB,
    SEARCHARG *pSearchArg,
    PSECURITY_DESCRIPTOR *ppSecurity
    );

// Some flags for DBMove
#define DB_MoveNext     0x00000001
#define DB_MovePrevious 0xFFFFFFFF
#define DB_MoveFirst    0x80000000
#define DB_MoveLast     0x7FFFFFFF
extern DB_ERR
DBMove (
    DBPOS * pDB,
    BOOL UseSortTable,
    LONG Distance
    );

DB_ERR
DBMoveEx (
       DBPOS * pDB,
       JET_TABLEID Cursor,
       LONG Distance
       );

extern DB_ERR
DBMovePartial (
       DBPOS * pDB,
       LONG Distance
       );

DWORD __fastcall
DBMakeCurrent(DBPOS *pDB);

extern DB_ERR
DBSetFractionalPosition(DBPOS *pDB,
            DWORD Numerator,
            DWORD Denominator);

extern void
DBGetFractionalPosition (DBPOS * pDB,
             DWORD * Numerator,
             DWORD * Denominator);

extern DB_ERR
DBSetCurrentIndex(DBPOS *pDB,
                  eIndexId indexid,
                  ATTCACHE * pAC,
                  BOOL MaintainCurrency);

DB_ERR
DBSetLocalizedIndex(
        DBPOS *pDB,
        eIndexId IndexId,
        unsigned long ulLangId,
        BOOL MaintainCurrency);

typedef struct _DBBOOKMARK {
    DWORD cb;
    void *pv;
} DBBOOKMARK;

extern void
DBGetBookMark (
        DBPOS *pDB,
        DBBOOKMARK *pBookMark);

extern void
DBGotoBookMark (
        DBPOS *pDB,
        DBBOOKMARK BookMark
        );

void
DBGetBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark);

void
DBGotoBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark
        );

#define DBFreeBookMark(X,Y) { THFreeEx(X, Y.pv); Y.pv = NULL; Y.cb=0;}

// Some flags for DBSeek
#define DB_SeekLT       0x00000001
#define DB_SeekLE       0x00000002
#define DB_SeekEQ       0x00000004
#define DB_SeekGE       0x00000008
#define DB_SeekGT       0x00000010
extern DB_ERR
DBSeek (
    DBPOS *pDB,
    INDEX_VALUE *pIV,
    DWORD nVals,
    DWORD SeekType
    );

DB_ERR
DBSeekEx (
       DBPOS *pDB,
       JET_TABLEID Cursor,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      );

DWORD
DBGetNCSizeEx(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    );

DWORD
DBGetEstimatedNCSizeEx(
    IN DBPOS *pDB,
    IN ULONG dntNC
    );


typedef enum
{
    eFALSE = 2,
    eTRUE = 3,
    eUNDEFINED = 4,
} TRIBOOL;


extern TRIBOOL
DBEval (
    DBPOS FAR *pDB,
    UCHAR Operation,
    ATTCACHE *pAC,
    ULONG valLenFilter,
    UCHAR *pValFilter
    );


extern DWORD
DBCompareDNTs(DBPOS *pDB,
              eIndexId idIndex,
              ATTCACHE *pAC,
              DWORD DNT1,
              DWORD DNT2,
              DWORD *pResult);

extern DWORD
DBSetIndexRange (
    DBPOS *pDB,
    INDEX_VALUE *pIV,
    DWORD nVals);

extern void
DBGetIndexSize(DBPOS *pDB,
           ULONG *pSIze);

DWORD
DBFindComputerObj(
        DBPOS *pDB,
        DWORD cchComputerName,
        WCHAR *pComputerName
        );

// In flag
#define DBCHOOSEINDEX_fUSEFILTER             0x01
#define DBCHOOSEINDEX_fREVERSE_SORT          0x02
#define DBCHOOSEINDEX_fPAGED_SEARCH          0x04
#define DBCHOOSEINDEX_fUSETEMPSORTEDTABLE    0x08
#define DBCHOOSEINDEX_fVLV_SEARCH            0x10
#define DBCHOOSEINDEX_fDELETIONS_VISIBLE     0x20

extern void
DBSetVLVArgs (
    DBPOS        *pDB,
    VLV_REQUEST  *pVLVrequest,
    ATTRTYP       SortAtt
    );

extern void
DBSetVLVResult (
        DBPOS       *pDB,
        VLV_REQUEST *pVLVRequest,
        PRESTART     pResRestart
    );

extern void
DBSetASQArgs (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest,
    COMMARG     *pCommArg
    );

extern void
DBSetASQResult (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest
    );


extern DWORD
DBChooseIndex (
    IN DBPOS  *pDB,
    IN DWORD   StartTick,
    IN DWORD   DeltaTick,
    IN ATTRTYP SortAttr,
    IN ULONG   SortType,
    IN DWORD   Flags,
    IN DWORD   MaxTempTableSize
    );

extern void
DBSetFilter (
    DBPOS FAR *pDB,
    FILTER *pFil,
    POBJECT_TYPE_LIST pFilSec,
    DWORD *pResults,
    ULONG FilSecSize,
    BOOL *pbSortSkip
    );

extern DWORD
DBRepositionSearch (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        DWORD StartTick,
        DWORD DeltaTick,
    PSECURITY_DESCRIPTOR *pSecurity,
        ULONG Flags
        );

extern DWORD
DBMakeFilterInternal (
    DBPOS FAR *pDB,
    FILTER *pFil,
        PFILTER *pOutFil
    );

extern TRIBOOL
DBEvalFilter(
    IN  DBPOS *   pDB,
    IN  BOOL      fUseObjTbl,
    IN  FILTER *  pFil
    );

extern void
DBGetKeyFromObjTable (
    DBPOS *pDB,
    BYTE  *ppb,
    ULONG *pcb
    );



// Some flags for DBGetNextSearchObject
#define DB_SEARCH_DELETIONS_VISIBLE  1
#define DB_SEARCH_FORWARD            2

extern DWORD
DBGetNextSearchObject (
    DBPOS *pDB,
    DWORD StartTick,
    DWORD DeltaTick,
    PSECURITY_DESCRIPTOR *pSecurity,
    ULONG Flags
    );


extern DWORD
DBSetSearchScope (
    DBPOS *pDB,
    ULONG ulSearchType,
    BOOL  bOneNC,
struct _RESOBJ *pResRoot
    );




DWORD
DBFindChildAnyRDNType (
        DBPOS *pDB,
        DWORD PDNT,
        WCHAR *pRDN,
        DWORD ccRDN
        );

// Return Values for DBFind are from direrr.h
extern DWORD
DBFindDSNameAnyRDNType (
        DBPOS FAR *pDB,
        const DSNAME *pDN
        );

extern DWORD
DBFindDSName (
    DBPOS FAR *pDB,
    const DSNAME *pDN
    );

extern DWORD
DBFindObjectWithSid(
    DBPOS FAR *pDB,
    DSNAME * pDN,
    DWORD iObject
    );

extern DWORD
DBFindDNT (
    DBPOS FAR *pDB,
    ULONG Tag
    );

extern DWORD
DBTryToFindDNT (
    DBPOS FAR *pDB,
    ULONG Tag
    );

extern DWORD
DBFindBestMatch(
    DBPOS FAR *pDB,
    DSNAME *pDN,
        DSNAME **ppDN
    );



extern BOOL
DBHasValues(DBPOS *pDB,
        ATTRTYP Att
        );

extern BOOL
DBHasValues_AC(DBPOS *pDB,
           ATTCACHE *pAC
           );


extern DWORD
DBGetValueCount_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    );

// Flags for DBGetMultipleAtts
#define DBGETMULTIPLEATTS_fGETVALS     0x1
// The fEXTERNAL flag implies fGETVALS
#define DBGETMULTIPLEATTS_fEXTERNAL    0x3
#define DBGETMULTIPLEATTS_fREPLICATION 0x4
#define DBGETMULTIPLEATTS_fSHORTNAMES  0x8
#define DBGETMULTIPLEATTS_fMAPINAMES   0x10
#define DBGETMULTIPLEATTS_fREPLICATION_PUBLIC 0x20
#define DBGETMULTIPLEATTS_fOriginalValues 0x40

VOID
DBFreeMultipleAtts (
    DBPOS *pDB,
    ULONG *attrCount,
    ATTR **ppAttr
    );

DWORD
DBGetMultipleAtts (
    DBPOS *pDB,
    ULONG cReqAtts,
    ATTCACHE *pReqAtts[],
        RANGEINFSEL *pRangeSel,
        RANGEINF *pRangeInf,
    ULONG *attrCount,
    ATTR **ppAttr,
    DWORD Flags,
        ULONG SecurityDescriptorFlags
    );

extern DWORD
DBFillGuidAndSid (
        DBPOS *pDB,
        DSNAME *pDN
        );


#define DBGETATTVAL_fINTERNAL   1       // Want data in internal format
#define DBGETATTVAL_fCONSTANT   2       // Caller is supplying a constant buf
#define DBGETATTVAL_fREALLOC    4       // Caller gives a THReallocable  bu
#define DBGETATTVAL_fSHORTNAME  8       // Caller wants names without strings
#define DBGETATTVAL_fMAPINAME  0x10     // Caller wants names in mapi format
#define DBGETATTVAL_fUSESEARCHTABLE 0x20 // Caller wants value read from search
                                         // table
#define DBGETATTVAL_fDONT_FIX_MISSING_SD 0x40 // Caller does not want to fix SD
                                              // if found missing
#define DBGETATTVAL_fINCLUDE_ABSENT_VALUES  0x80     // Include absent values

// Default is for return of value in external format in a freshly THAlloced buf
extern DWORD
DBGetAttVal (
    DBPOS FAR *pDB,
    ULONG N,
    ATTRTYP  aType,
    DWORD Flags,
    ULONG InBufSize,
    ULONG *pLen,
    UCHAR **pVal
    );

extern DWORD
DBGetAttVal_AC (
    DBPOS FAR *pDB,
    ULONG N,
    ATTCACHE *pAC,
    DWORD Flags,
    ULONG InBufSize,
    ULONG *pLen,
    UCHAR **pVal
    );

extern DB_ERR
DBGetNextLinkVal_AC (
        DBPOS FAR *pDB,
        BOOL bFirst,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        );

extern DB_ERR
DBGetNextLinkValEx_AC (
    DBPOS FAR *pDB,
    BOOL bFirst,
    DWORD Sequence,
    ATTCACHE **pAC,
    DWORD Flags,
    ULONG InBuffSize,
    ULONG *pLen,
    UCHAR **ppVal
    );

extern DB_ERR
DBGetNextLinkValForLogon(
        DBPOS   FAR * pDB,
        BOOL    bFirst,
        ATTCACHE * pAC,
        PULONG  pulDNTNext
        );

extern DB_ERR
DBGetSingleValue(DBPOS *pDB,
         ATTRTYP Att,
         void * pvData,
         DWORD cbData,
         DWORD *pReturnedSize);
extern DB_ERR
DBGetSingleValueFromIndex (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pReturnedSize);


extern DWORD
DBResetRDN (
    DBPOS *pDB,
    ATTRVAL *pAVal
    );

DB_ERR
DBMangleRDN(
        IN OUT  DBPOS * pDB,
        IN      GUID *  pGuid
        );

int
ExtIntDist (
        DBPOS FAR *pDB,
        USHORT extTableOp,
        ULONG extLen,
        UCHAR *pExtVal,
        ULONG *pIntLen,
        UCHAR **ppIntVal,
        ULONG ulUpdateDnt,
        JET_TABLEID jTbl,
        ULONG flags
        );

// Flags for DBResetParent().
#define DBRESETPARENT_CreatePhantomParent   ( 1 )
#define DBRESETPARENT_SetNullNCDNT          ( 2 )

extern DWORD
DBResetParent (
    DBPOS *pDB,
    DSNAME *pName,
        ULONG ulFlags
    );

ULONG
DBResetDN(
    IN  DBPOS *     pDB,
    IN  DSNAME *    pParentDN,
    IN  ATTRVAL *   pAttrValRDN
    );

void
DBCoalescePhantoms(
    IN OUT  DBPOS * pDB,
    IN      ULONG   dntRefPhantom,
    IN      ULONG   dntStructPhantom
    );

extern DWORD
DBAddAtt (
    DBPOS FAR *pDB,
    ATTRTYP aType,
    UCHAR syntax
    );

extern DWORD
DBAddAtt_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    UCHAR syntax
    );

extern DWORD
DBAddAttVal(
    DBPOS FAR *pDB,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBAddAttVal_AC(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBAddAttValEx_AC(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal,
    VALUE_META_DATA *pRemoteValueMetaData
    );

extern DWORD
DBRemAtt(
    DBPOS FAR *pDB,
    ATTRTYP aType
    );

extern DWORD
DBRemAtt_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC
    );


extern DWORD
DBRemAttVal (
    DBPOS FAR *pDB,
    ATTRTYP aType,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBRemAttVal_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal
    );

extern DWORD
DBRemAttValEx_AC (
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal,
    VALUE_META_DATA *pRemoteValueMetaData
    );

extern DWORD
DBReplaceAttVal (
    DBPOS FAR *pDB,
    ULONG N,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal);

extern DWORD
DBReplaceAttVal_AC (
    DBPOS FAR *pDB,
    ULONG N,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal);

extern DWORD
DBReplaceAtt_AC(
        PDBPOS  pDB,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal,
        BOOL         *pfChanged
        );

DWORD
DBFindAttLinkVal_AC(
    IN  DBPOS FAR *pDB,
    IN  ATTCACHE *pAC,
    IN  ULONG extLen,
    IN  void *pExtVal,
    OUT BOOL *pfPresent
    );

// Flags for DBRepl
#define DBREPL_fADD                     0x1
#define DBREPL_fROOT                    0x2
#define DBREPL_fRESET_DEL_TIME          0x4
#define DBREPL_fKEEP_WAIT               0x8     // Don't awaken ds_waiters
extern DWORD
DBRepl(
       DBPOS FAR *pDB,
       BOOL fDRA,
       DWORD fAddFlags,
       PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
       DWORD dwMetaDataFlags
       );

extern VOID
DBResetAtt (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG len,
    void *pVal,
    UCHAR syntax
    );

extern DWORD
DBResetAttLVOptimized (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG ulOffset,
    ULONG lenSegment,
    void *pValSegment,
    UCHAR syntax
    );

extern DWORD
DBPhysDel (
    DBPOS FAR *pDB,
    BOOL fGarbCollectASAP,
    ATTCACHE *pACDel
    );

DWORD
DBPhysDelLinkVal(
    IN DBPOS *pDB,
    IN ULONG ulObjectDnt,
    IN ULONG ulValueDnt
    );

extern BOOL
DBCheckToGarbageCollect (
    DBPOS FAR *pDB,
    ATTCACHE *pAC
    );

extern USHORT
DBUpdateRec (
    DBPOS FAR *pDB
    );

extern DWORD
DBInitObj (
    DBPOS FAR *pDB
    );

#define DB_LOCK_DN_CONFLICT_NODE       1
#define DB_LOCK_DN_CONFLICT_TREE_ABOVE 2
#define DB_LOCK_DN_CONFLICT_TREE_BELOW 4
#define DB_LOCK_DN_CONFLICT_STICKY     8
#define DB_LOCK_DN_CONFLICT_UNKNOWN    16
extern DWORD
DBLockDN (
    DBPOS  *pDB,
    DWORD   dwFlags,
    DSNAME *pDN
    );

DWORD
DBUnlockStickyDN (
        PDSNAME pObj
        );

extern USN
DBGetNewUsn (
    void
    );


extern DWORD
DBAddDelIndex(
    DBPOS *pDB,
        BOOL fGarbCollectASAP
    );

extern void
DBGetAncestors(
        IN      DBPOS *  pDB,
        IN OUT  DWORD *  pcbAncestorsSize,
        IN OUT  ULONG ** ppdntAncestors,
        OUT     DWORD *  pcNumAncestors
        );

#define DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE   0
#define DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE   1
#define DBGETOBJECTSECURITYINFO_fSEEK_ROW           2

extern DWORD
DBGetObjectSecurityInfo(
    PDBPOS pDB,
    DWORD dnt,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *ppNTSD,
    CLASSCACHE **ppCC,
    PDSNAME pDN,
    char    *pObjFlag,
    DWORD   flags
    );

extern DWORD
DBGetParentSecurityInfo (
    PDBPOS pDB,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *pNTSD,
    CLASSCACHE **ppCC,
    PDSNAME *ppDN
    );

extern DWORD
DBAddSDPropTime (
     DBPOS * pDB,
     BYTE flags
     );

#define DBEnqueueSDPropagation(pDB, bTrimmable) DBEnqueueSDPropagationEx(pDB, bTrimmable, 0)

// SD prop flags
// force SD update even if it seems the SD data has not changed
#define SD_PROP_FLAG_FORCEUPDATE 1

extern DWORD
DBEnqueueSDPropagationEx(
        DBPOS * pDB,
        BOOL bTrimmable,
        DWORD dwFlags
        );

extern DWORD
DBGetNextPropEvent(
        DBPOS * pDB,
        SDPropInfo *pInfo
        );

extern DWORD
DBGetLastPropIndex(
        DBPOS * pDB,
        DWORD *pdwIndex
        );

extern DWORD
DBThinPropQueue (
        DBPOS * pDB,
        DWORD   DNT
        );

extern DWORD
DBPopSDPropagation (
        DBPOS * pDB,
        DWORD index
        );

DWORD
DBSDPropagationInfo (
        DBPOS * pDB,
        DWORD dwClientID,
        DWORD *pdwSize,
        SDPropInfo **ppInfo
        );

extern  DWORD
DBSDPropInitClientIDs (
        DBPOS * pDB
        );

// This is the count of the number of links that must be able to be
// removed immediately when an object is deleted.  We want to set this
// conservatively so that it isn't an impediment under low-memory/
// high load conditions.

#define DB_COUNT_LINKS_PROCESSED_IMMEDIATELY 1000

extern DWORD
DBRemoveLinks(
    DBPOS *pDB
    );

DWORD APIENTRY
DBRemoveLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    );

DWORD
DBRemoveAllLinksHelp_AC(
        DBPOS *pDB,
        DWORD DNT,
        ATTCACHE *pAC,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        );

DWORD APIENTRY
DBTouchLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC,
    BOOL fIsBacklink
    );

DWORD
DBTouchAllLinksHelp_AC(
        DBPOS *pDB,
        ATTCACHE *pAC,
        USN usnEarliest,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        );

extern DWORD
DBGetNextDelRecord (
    DBPOS FAR *pDB,
    DSTIME ageOutDate,
    DSNAME **ppRetBuf,
    DSTIME *pulLastTime,
    ULONG *pulTag,
    BOOL  *pfObject
    );

DWORD DBGetNextEntryTTLRecord(
    IN  DBPOS       *pDB,
    IN  DSTIME      ageOutDate,
    IN  ATTCACHE    *pAC,
    IN  ULONG       ulNoDelDnt,
    OUT DSNAME      **ppRetBuf,
    OUT DSTIME      *pulLastTime,
    OUT BOOL        *pfObject,
    OUT ULONG       *pulNextSecs
    );

DWORD
DBGetNextDelLinkVal(
    IN DBPOS FAR *pDB,
    IN DSTIME ageOutDate,
    IN OUT DSTIME *ptLastTime,
    IN OUT ULONG *pulObjectDnt,
    IN OUT ULONG *pulValueDnt
    );

DWORD
DBGetNextObjectNeedingCleaning(
    DBPOS FAR *pDB,
    ULONG *pulTag
    );

void
DBNotifyReplicasCurrDbObj (
                           DBPOS *pDB,
                           BOOL fUrgent
                           );
void
DBNotifyReplicas (
                  DSNAME *pObj,
                  BOOL fUrgent
                  );

BOOL DBGetIndexName (ATTCACHE *pAC,
                     DWORD flags,
                     DWORD dwLcid,
                     CHAR *szIndexName,
                     DWORD cchIndexName);

VOID
DBSetObjectNeedsCleaning(
    DBPOS *pDB,
    BOOL fNeedsCleaning
    );



// Debugging routines
#if DBG
void DprintName(DSNAME  *pN);
void DprintAddr(UNALIGNED SYNTAX_ADDRESS *pAddr);

#define DPRINTNAME(pN) DprintName(pN)
#define DPRINTADDR(pAddr) DprintAddr(pAddr)

#else

#define DPRINTNAME(pN)
#define DPRINTADDR(pAddr)

#endif

// Useful macros for looking at link/backlink attributes
// Warning: The code for AutoLinkId assumes forward
// links are even and the corresponding backlink is (+1)
// and the next forward link is (+2).
#define FIsBacklink(linkid)             ((linkid) & 1)
#define FIsLink(linkid)                 ((linkid) && !FIsBacklink(linkid))
#define MakeLinkBase(linkid)            ((linkid) >> 1)
#define MakeLinkId(linkbase)            ((linkbase) << 1)
#define MakeBacklinkId(linkbase)        (((linkbase) << 1) | 1)

// AutoLinkId
// Automatically generate a linkid when the user specifies a special,
// reserved linkid value.  The only interoperability issue with existing
// schemas is that a user cannot define a backlink for an existing
// forward link whose id is RESERVED_AUTO_LINK_ID. Considered not a problem
// because 1) microsoft has not allocated linkid -2 to anyone and
// 2) practically and by convention, forward links and back links
// are created at the same time. If a user did generate this unsupported
// config, then the user must create a new link/backlink pair and fix
// up the affected objects.
//
// The ldap head cooperates in this venture by translating the ldapDisplayName
// or OID for a LinkId attribute into the corresponding schema cache entry
// and:
//      1) If the schema cache entry is for ATT_LINK_ID, then the caller's
//      linkid is set to RESERVED_AUTO_LINK_ID. Later, underlying code
//      automatically generates a linkid in the range
//      MIN_RESERVED_AUTO_LINK_ID to MAX_RESERVED_AUTO_LINK_ID.
//
//      2) If the schema cache entry is for a for an existing forward link,
//      then the caller's linkid is set to the corresponding backlink value.
//
//      3) Otherwise, the caller's linkid is set to RESERVED_AUTO_NO_LINK_ID
//      and later, underlying code generates a ERROR_DS_BACKLINK_WITHOUT_LINK
//      error.
//
// An error ERROR_DS_RESERVED_LINK_ID is returned if the user specifies
// linkid in the reserved range MIN... to MAX... The range reserves 1G-2
// linkids. Should be enough. At whistler, less than 200 linkids are in use.
// Existing schemas, or schemas modified on W2K DCs, may use linkids in
// this range without affecting the functionality except as noted above.
#define MIN_RESERVED_AUTO_LINK_ID       ((ULONG)0xc0000000)
#define MAX_RESERVED_AUTO_LINK_ID       ((ULONG)0xFFFFFFFC)
#define RESERVED_AUTO_LINK_ID           ((ULONG)0xFFFFFFFE)
#define RESERVED_AUTO_NO_LINK_ID        ((ULONG)0xFFFFFFFF)

// These are only used by scache.c
#define SZDATATABLE     "datatable"      // name of JET data table
#define SZLCLINDEXPREFIX "LCL_"
#define SZATTINDEXPREFIX "INDEX_"

typedef struct _INDEX_INFO {
    DWORD attrType;
    int   syntax;
    DWORD indexType;
}  INDEX_INFO;
extern INDEX_INFO IndicesToKeep[];
extern DWORD cIndicesToKeep;

#define MAX_NO_OF_INDICES_IN_BATCH 16

extern BOOL
AttInIndicesToKeep (
    ULONG id
    );

extern int
DBAddColIndex (
    ATTCACHE *pAC,
    DWORD eSearchFlags,
    JET_GRBIT CommonGrbit
    );

extern int
DBDeleteColIndex (
    ATTRTYP aid,
    DWORD eSearchFlags
    );

extern int
DBRecreateFixedIndices(JET_SESID sesid,
                       JET_DBID dbid);

extern int
DBAddCol (
    ATTCACHE *pAC
    );

extern int
DBDeleteCol (
    ATTRTYP aid,
    unsigned syntax
    );

extern void
DBCreateRestart(
        DBPOS *pDB,
        PRESTART *ppRestart,
        DWORD SearchFlags,
        DWORD problem,
        struct _RESOBJ   *pResObj
        );

DWORD
DBCreateRestartForSAM(
        DBPOS    *pDB,
        PRESTART *ppRestart,
        eIndexId  idIndexForRestart,
        struct _RESOBJ  *pResObj,
        DWORD     SamAccountType
        );

struct _RESOBJ *
ResObjFromRestart(
        struct _THSTATE  *pTHS,
        DSNAME   *pDN,
        RESTART  *pRestart
        );

void
DBTouchMetaData(
        DBPOS * pDB,
        ATTCACHE * pAC
        );

extern
VOID
DBAdjustRefCount(
        DBPOS *pDB,
        DWORD DNT,
        long  delta);

extern
VOID
DBAdjustABRefCount(
        DBPOS *pDB,
        DWORD DNT,
        long  delta);

extern USHORT
DBCancelRec(
        DBPOS * pDB
        );

extern char
DBCheckObj(
        DBPOS FAR *pDB
        );

extern DWORD
DBMapiNameFromGuid_W (
        wchar_t *pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        );

extern DWORD
DBMapiNameFromGuid_A (
        PUCHAR pStringDN,
        DWORD  countChars,
        GUID *pGuidObj,
        GUID *pGuidNC,
        DWORD *pSize
        );

extern DWORD
DBGetGuidFromMAPIDN (
        PUCHAR pStringDN,
        GUID *pGuid
        );

extern BOOL
DBIsObjDeleted(DBPOS *pDB);

extern void
DBDefrag(DBPOS * pDB);

#ifdef  CHECK_FOR_ADMINISTRATOR_LOSS
VOID
DBCheckForAdministratorLoss(
     ULONG ulDNTObject,
     ULONG ulDNTAttribute
     );


VOID
DBGetAdministratorAndAdministratorsDNT();
#endif


DWORD
DBGetChildrenDNTs(
        DBPOS *pDB,
        DWORD ParentDNT,
        DWORD **ppDNTs,
        DWORD *pBeginDNTIndex,
        DWORD *pEndDNTIndex,
        DWORD *pArraySize
        );

DWORD
DBGetDepthFirstChildren (
        DBPOS   *pDB,
        PDSNAME **ppNames,
        DWORD   *iLastName,
        DWORD   *cMaxNames,
        BOOL    *fWrapped,
        BOOL    fPhantomizeSemantics
        );


ULONG
DBMetaDataModifiedList(
    DBPOS *pDB,
    ULONG *pCount,
    ATTRTYP **ppAttList);

DWORD
MakeInternalValue (
        DBPOS *pDB,
        int syntax,
        ATTRVAL *pInAVal,
        ATTRVAL *pOutAVal
        );

void
DBFlushSessionCache( void );


extern HANDLE hevDBLayerClear;
DWORD
DBCreatePhantomIndex(
        DBPOS *pDB
        );

DWORD
DBUpdateUsnChanged(
        DBPOS *pDB
        );


PDSNAME
DBGetCurrentDSName(
        DBPOS *pDB
        );

PDSNAME
DBGetDSNameFromDnt(
        DBPOS *pDB,
        ULONG ulDnt
        );
void
DBReleaseSession(DBPOS *pDB);

void
DBClaimSession(DBPOS *pDB);

ULONG
DBClaimReadLock(DBPOS *pDB);

ULONG
DBClaimWriteLock(DBPOS *pDB);

void
InPlaceSwapSid(PSID pSid);

BOOL
DBIsSecretData(ATTRTYP attrType);

DWORD
DBGetExtraHackyFlags(ATTRTYP attrType);

DWORD
DBResetParentByDNT (
        DBPOS *pDB,
        DWORD  dwNewParentDNT,
        BOOL  fTouchMetadata
        );

DWORD
DBFindBestProxy(
    DBPOS   *pDB,
    BOOL    *pfFound,
    DWORD   *pdwEpoch);

DWORD
DBGetIndexHint(
    IN  char * pszIndexName,
    OUT struct tagJET_INDEXID **ppidxHint);

void
DBGetLinkValueMetaData(
    IN  DBPOS *pDB,
    ATTCACHE *pAC,
    OUT VALUE_META_DATA *pMetaDataLocal
    );

// Determine if this value metadata was derived from a legacy value
#define IsLegacyValueMetaData( p ) ((p)->MetaData.dwVersion == 0)

void
DBSetDelTimeTo(
    DBPOS *             pDB,
    LONGLONG            llDelTime
    );

void
DBGetLinkTableData(
    PDBPOS           pDB,
    DWORD           *pulObjectDnt,
    DWORD           *pulValueDnt,
    DWORD           *pulRecLinkBase
    );

void
DBGetLinkTableDataDel (
        PDBPOS           pDB,
        DSTIME          *ptimeDeleted
        );

void
DBGetLinkTableDataUsn (
        PDBPOS           pDB,
        DWORD           *pulNcDnt,
        USN             *pusnChanged,
        DWORD           *pulDnt
        );

UCHAR *
DBGetExtDnFromDnt(
    DBPOS *pDB,
    ULONG ulDnt
    );

void
DBLogLinkValueMetaData(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN USN *pUsn,
    IN VALUE_META_DATA_EXT *pMetaDataExt
    );

VOID
DBSearchCriticalByDnt(
    DBPOS *pDB,
    DWORD dntObject,
    BOOL *pCritical
    );

BOOL
DBSearchHasValuesByDnt(
    IN DBPOS        *pDB,
    IN DWORD        DNT,
    IN JET_COLUMNID jColid
    );

void
DBGetObjectTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt,
    USN             *pusnChanged,
    DWORD           *pulDnt
    );

VOID
DBImproveAttrMetaDataFromLinkMetaData(
    IN DBPOS *pDB,
    IN OUT PROPERTY_META_DATA_VECTOR ** ppMetaDataVec,
    IN OUT DWORD * pcbMetaDataVecAlloced
    );

DWORD
DBMoveObjectDeletionTimeToInfinite(
    DSNAME * pdsa
    );

// buffer size used for dumping FILTERs in readable ldp like form
#define DBFILTER_DUMP_SIZE 512

void
DBCreateSearchPerfLogFilter (
    DBPOS *pDB,
    FILTER *pFilter,
    LPSTR buff,
    DWORD buffSize);

void DBGenerateLogOfSearchOperation (DBPOS *pDB);

VOID
DBGetValueLimits (
        ATTCACHE *pAC,
        RANGEINFSEL *pRangeSel,
        DWORD *pStartIndex,
        DWORD *pNumValues,
        BOOL  *pDefault
        );

DB_ERR
DBMatchSearchCriteria (
        DBPOS FAR *pDB,
        PSECURITY_DESCRIPTOR *ppSecurity,
        BOOL *pbIsMatch);

#endif  // _db_global_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\draadmin.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draadmin.h
//
//--------------------------------------------------------------------------

// Prototype for setup to DRA call ServerInstall

USHORT __stdcall ServerInstall (char * pszServerName,
			char * pszOrgName,
                        char * pszOrgUnitName,
                        ULONG ulOptions);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\bootopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       bootopt.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module proto-types the functions exported by bootopt.lib

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

typedef enum
{
    eAddBootOption,
    eRemoveBootOption

} NTDS_BOOTOPT_MODTYPE;


DWORD
NtdspModifyDsRepairBootOption( 
    NTDS_BOOTOPT_MODTYPE Modification
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

/*  Debug output macros

    This is a simple debugging package for generating conditional
    printf output.

    AT RUN-TIME

    There are 2 run-time options:

    1 - A list of subsystems to be debugged.  Either a list of subsystem
        names delimited by a ":" or an "*" which means debug all
        (e.g. sub1:sub2: Sub3:).  (Names are case sensitive and spaces
        between names are ignored.)

    2 - A severity level (1-5) that indicates the level of detailed
        information to be produced.  (The higher the level, the more
        data produced.


    AT COMPILE-TIME

    Compile with the /DDBG=1 option to define the preprocessor variable
    DBG to 1.  This will generate debug source code.  For customer shipment,
    set /DDBG=0 and all debug code will be removed.  (Actually a
    ";" will be generated.)


    AT CODE-TIME

    1 - Include the DEBUG.H header at the top of your source listing.

    2 - #DEFINE DEBSUB to contain the name (a string delimited by a ":") of
        the software subsystem contained in this source (e.g. #define DEBSUB
        "MySub:") (You could optionally redefine DEBSUB for each function in
        your source to give you function-level debugging.)

    3 - Invoke the DEBUGINIT macro that calls the Debug function before any
        source debug statements are executed.  This funciton prompts STDIN for
        the user specified run-time options.  (Alternatively you could
        hardcode your own assignment of the DebugInfo data structure which
        holds the run-time options.)

    4 - Everywhere you want to a printf for debugging, put a DPRINT statement
        instead and specify a severity level with the statement.  The
        statement will be printed if the severity is this level or higher
        (assuming that the subsystem is to be debugged).  The severity level
        allows for different amounts of output to be generated if problem
        is very bad.

    For example, a severity of 1 DPRINT statement might just indicate that
    a certain function was entered while a severity of 5 might print
    information that is inside a tight loop.

    (Actually there are 6 DPRINT statements provided depending on the
    number of printf arguments.)


    NOTE

    All printf's are surrounded by semaphores.  Be careful not to invoke
    routines as parms to printf because you can have a deadlock situation.


    EXAMPLE PROGRAM

    **   include "debug.h"
    **   include "string.h"
    **
    **   #define DEBSUB "sub1:"
    **
    **   main()
    **   {
    **       DEBUGINIT;
    **
    **       DPRINT(4,"this is a sub1 debug of 4\n");
    **       DPRINT(1,"this is a sub1 debug of 1\n");
    **   }

*/


#ifndef _debug_h_
#define _debug_h_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LOADDS
# ifdef WIN32
#  define _LOADDS
# else
#  define _LOADDS _loadds
# endif
#endif



/* <DebugInfo>, of type DEBUGARG, contains the debug run-time settings.

   DebSubSystems contains a list of subsystem names to be debugged
   delimited by ":".  An "*" found in this array indicates that all
   subsystems are to be debugged.

   The severity indicates the amount of debug information to be produced.
   The higher the severity the more data that will be dumped.

   A specific thread can be traced by entering its ID.  An id of 0 means all.
*/

/* values for <DEBUGARG.scope> */
#define DEBUG_LOCAL     1
#define DEBUG_REMOTE    2
#define DEBUG_ALL       3

typedef struct
{
    unsigned short scope;           /* when changing values, change local? */
    int severity;                   /* 1 - 5, (low - high) - on stdout */
    CRITICAL_SECTION sem;           /* single thread semaphore*/
    unsigned long  threadId;        /* a thread id to debug (0 - All)*/
    char DebSubSystems[144];        /* the list of subsystem to debug */
    CHAR LogFileName[MAX_PATH+1];   // name of the log file
} DEBUGARG;

// This table tracks what asserts we have disabled
// We store the filenames in the structure so we can read them easily
// in the debugger extension.

#define MAX_DISABLED_ASSERTIONS 20
#define MAX_ASSERT_FILE_SIZE 128

typedef struct {
    CHAR szFile[MAX_ASSERT_FILE_SIZE];
    ULONG dwLine;
} ASSERT_ENTRY;

typedef struct {
    DWORD dwCount;
    ASSERT_ENTRY Entry[MAX_DISABLED_ASSERTIONS];
} ASSERTARG;

#if DBG

extern DEBUGARG DebugInfo;
extern ASSERTARG AssertInfo;
extern BOOL     fProfiling;
extern BOOL     fEarlyXDS;

#define DEBUGTEST(sev)      DebugTest( sev, DEBSUB, DEBALL )

char *asciiz(char *var, unsigned short len);


#endif /* DBG */

// Free builds break if CreateErrorString is inside the #if block.

BOOL    CreateErrorString(UCHAR **ppBuf, DWORD *pcbBuf );

#if ( DBG  && (! defined(NONDEBUG)) && !defined(WIN16))

/*
**      forward declare actual functions used by DPRINT's
*/
void    DebPrint( USHORT, UCHAR *, CHAR *, unsigned, ... );
USHORT  DebugTest( USHORT, CHAR * );
void    DumpErrorInfo(UCHAR *, unsigned);
VOID    TerminateDebug(VOID);

/* These are used instead of printf statements.  Semaphores surround the
   printf and all output is proceeded by the subsystem.*/

// The DPRINT macros perform the output test in the macro in order to
// avoid costly and unnecessary evaluation of the arguments. They include
// the braces so that "if (a) MACRO(x, y); else b" will work correctly.

#define DPRINT(severity,str)              \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( (int)(severity), (PUCHAR)str, DEBSUB, __LINE__); \
}

#define DPRINT1(severity, str,p1)        \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1 ); \
}

#define DPRINT2(severity, str,p1,p2)   \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2 ); \
}

#define DPRINT3(severity, str,p1,p2,p3)     \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3 ); \
}

#define DPRINT4(severity, str,p1,p2,p3,p4)  \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4 ); \
}

#define DPRINT5(severity, str,p1,p2,p3,p4,p5)   \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5 ); \
}

#define DPRINT6(severity, str,p1,p2,p3,p4,p5,p6) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6 ); \
}

#define DPRINT7(severity, str,p1,p2,p3,p4,p5,p6,p7) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6, p7 ); \
}

#define DPRINT8(severity, str,p1,p2,p3,p4,p5,p6,p7,p8) \
{ \
   if (DebugTest(severity,DEBSUB)) \
       DebPrint( severity, (PUCHAR)str, DEBSUB, __LINE__, p1, p2, p3, p4, p5, p6, p7, p8 ); \
}

#define DUMP_ERROR_INFO() \
    DumpErrorInfo((PUCHAR)DEBSUB, __LINE__)

#else
#define DPRINT(severity, str)
#define DPRINT1(severity, str,p1)
#define DPRINT2(severity, str,p1,p2)
#define DPRINT3(severity, str,p1,p2,p3)
#define DPRINT4(severity, str,p1,p2,p3,p4)
#define DPRINT5(severity, str,p1,p2,p3,p4,p5)
#define DPRINT6(severity, str,p1,p2,p3,p4,p5,p6)
#define DPRINT7(severity, str,p1,p2,p3,p4,p5,p6,p7)
#define DPRINT8(severity, str,p1,p2,p3,p4,p5,p6,p7,p8)
#define DUMP_ERROR_INFO()
#endif


/* Define the debug initialization routine */

#if  DBG
void Debug(int argc, char *argv[], PCHAR Module );

#define DEBUGINIT(argc, argv, mod) Debug(argc, argv, mod)
#define DEBUGTERM() TerminateDebug()
#else
#define DEBUGINIT(argc, argv, mod)
#define DEBUGTERM()
#endif


/*  The following function is an additional debug-only DUAPI call which
    can be used to modify the debug settings at run-time.  The <scope>
    field in the <pDebugArg> parameter can be used to specify resetting
    the debug values on either the client or the server!
*/

#if  DBG

#ifdef PARANOID
// this is *really* slow, and should be turned on only in private builds

#define HEAPVALIDATE {                          \
    int __heaperr;                              \
    __heaperr = RtlValidateHeap(pTHStls->hHeap,0,NULL); \
    if (!__heaperr) {                           \
        DebugBreak();                           \
    }                                           \
    __heaperr = _heapchk();                     \
    if (__heaperr != _HEAPOK) {                 \
        DebugBreak();                           \
    }                                           \
}
#else // not paranoid
#define HEAPVALIDATE
#endif

#else // not debug
#define HEAPVALIDATE
#endif



/*
 * There are some conditions that the DS, as a loosely consistent system,
 * can only loosely guarantee. This LooseAssert will not fire if a global-knowledge
 * modifying operation (such as an NC or CR catalog update) has been recently
 * run. It is considered acceptable that the in-memory structures remain
 * out-of-sync with the DB for a short period of time after such an operation
 * has commited
 * Another kind of LooseAssert is related to replication delays. For example,
 * a subref can be replicated before a corresponding cross-ref is replicated
 * in the configuration container (see the LooseAssert in GeneratePOQ)
 */

// this is the period of time (in sec) after a global-knowledge modifying
// operation when the global caches are allowed to be inconsistent with the DB
#define GlobalKnowledgeCommitDelay 25

// a period of time (in sec) allowed for crossref/subref replication to complete
#define SubrefReplicationDelay (3*3600)

#if  DBG

extern void DoAssert( char *, char *, int );
extern DWORD gdwLastGlobalKnowledgeOperationTime; // in ticks

#ifndef Assert
#define Assert( exp )   { if (!(exp)) DoAssert(#exp, __FILE__, __LINE__ ); }

// allowedDelay is the time (in seconds) that is allowed since
// the last global knowledge modifying operation
#define LooseAssert(exp, allowedDelay) { \
    if ((GetTickCount() - gdwLastGlobalKnowledgeOperationTime > (allowedDelay)*1000) && !(exp)) { \
        DoAssert(#exp, __FILE__, __LINE__ ); \
    } \
}

#endif

#else

#ifndef Assert
#define Assert( exp )
#define LooseAssert( exp, allowedDelay )
#endif

#endif

#define OWN_CRIT_SEC(x) \
    (GetCurrentThreadId() == HandleToUlong((x).OwningThread))
#define OWN_RESOURCE_EXCLUSIVE(x) (((x)->NumberOfActive == -1) &&              \
                                   (GetCurrentThreadId() ==                    \
                                    HandleToUlong((x)->ExclusiveOwnerThread)))
// This is a weak test, since it just tests if ANYONE owns the resource in a
// shared manner, not that the calling thread does so.
#define OWN_RESOURCE_SHARED(x) ((x)->NumberOfActive > 0)

#ifdef __cplusplus
}
#endif

// This provides a macro that will declare a local variable equal to
// pTHStls, since thread local variables can't be accessed by debuggers
#if DBG
#define DEBUGTHS THSTATE * _pTHS = pTHStls;
#else
#define DEBUGTHS
#endif

// A convenient expression that is true iff a block is allocated from
// the specified heap
#define IsAllocatedFrom(hHeap, pBlock) (0xffffffff != RtlSizeHeap((hHeap),0,(pBlock)))


// Routine to validate memory.
BOOL
IsValidReadPointer(
        IN PVOID pv,
        IN DWORD cb
        );

#endif /* _debug_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\draatt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       draatt.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Replication flag definitions.

DETAILS:

These flags are passed in the options parameter to the RPC replica functions,
and are thus part of the formal interface between DSAs. Do not change these
values.

These flags are for internal use only. For most of these functions, there is
a corresponding public version of the option flag.  If you add new options
that would be relevant to public calls, please add the tranlation in
sdk\public\inc\ntdsapi.h and ds\src\ntdsapi\replica.c.

Documentation for many of these flags can be found in
ds\src\dsamain\dra\dradir.c.  When adding new flags, please update the
commentary in dradir.c, as well as other modules where the flag is used.

CREATED:

REVISION HISTORY:

--*/

// general
#define DRS_ASYNC_OP                   (0x0001L)

// Replica option flags
#define DRS_WRIT_REP                   (0x0010L)       // Writeable replica
#define DRS_INIT_SYNC                  (0x0020L)       // Sync replica at startup
#define DRS_PER_SYNC                   (0x0040L)       // Sync replica periodically
#define DRS_MAIL_REP                   (0x0080L)       // Mail replica
#define DRS_ASYNC_REP                  (0x0100L)       // Complete replica asyncly
#define DRS_TWOWAY_SYNC                (0x0200L)       // At end of sync, force sync
                                                       //   in opposite direction
#define DRS_CRITICAL_ONLY              (0x0400L)       // Sync critical objects
#define DRS_NEVER_SYNCED             (0x200000L)       // Sync from this source
                                                       //   never completed
                                                       //   successfully
                             // Shared by ReplicaAdd and ReplicaSync

// Replica deletion flags
#define DRS_IGNORE_ERROR               (0x0100L)       // Ignore error if replica
                                                       // source DSA unvaialable
#define DRS_LOCAL_ONLY                 (0x1000L)       // Don't try and contact
                                                       // other DRA
#define DRS_DEL_SUBREF                 (0x2000L)       // Delete subref (nw replicas
                                                       // only)
#define DRS_REF_OK                     (0x4000L)       // Allow deletion even if
                                                       // NC has repsto
#define DRS_NO_SOURCE                  (0x8000L)       // Replica has no repsfrom


// syncing flags (also passed to GetNcChanges)
//above DRS_ASYNC_OP                   (0x0001L)
#define DRS_UPDATE_NOTIFICATION	       (0x0002L) // set by notify caller
//below DRS_ADD_REF                    (0x0004L) // Add a reference on source
#define DRS_SYNC_ALL                   (0x0008L) // sync replica from all sources
//above DRS_WRIT_REP                   (0x0010L) // Writeable replica
//above DRS_INIT_SYNC                  (0x0020L) // Sync replica at startup
//above DRS_PER_SYNC                   (0x0040L) // Sync replica periodically
//above DRS_MAIL_REP                   (0x0080L) // Mail replica
//above DRS_ASYNC_REP                  (0x0100L) // Complete replica asyncly
//above DRS_TWOWAY_SYNC                (0x0200L) // At end of sync, force sync in opp dir
//above DRS_CRITICAL_ONLY              (0x0400L) // Sync critical objects
//below DRS_GET_ANC                    (0x0800L) // Include ancestors
//below DRS_GET_NC_SIZE                (0x1000L) // Return size of NC
//OPEN                                 (0x2000L)
#define DRS_SYNC_BYNAME                (0x4000L) // Sync by name, not UUID
#define DRS_FULL_SYNC_NOW              (0x8000L) // Sync from scratch.
#define DRS_FULL_SYNC_IN_PROGRESS     (0x10000L) // Full sync is in progress,
#define DRS_FULL_SYNC_PACKET          (0x20000L) // temp mode to req all attr
#define DRS_SYNC_REQUEUE              (0x40000L) // requeued sync request of any type
#define DRS_SYNC_URGENT               (0x80000L) // Sync repsto immediately
#define DRS_NO_DISCARD               (0x100000L) // Always q, never discard.
//above DRS_NEVER_SYNCED             (0x200000L) // Sync never completed successfully
#define DRS_ABAN_SYNC                (0x400000L) // Sync abandoned due to lack of progress
#define DRS_INIT_SYNC_NOW            (0x800000L) // Performing initial sync now.
#define DRS_PREEMPTED               (0x1000000L) // Sync attempt was preempted
#define DRS_SYNC_FORCED             (0x2000000L) // Force the sync even if repl disabled
#define DRS_DISABLE_AUTO_SYNC       (0x4000000L) // Disable notification-triggered syncs
#define DRS_DISABLE_PERIODIC_SYNC   (0x8000000L) // Disable periodic syncs
#define DRS_USE_COMPRESSION        (0x10000000L) // Compress repl messages when possible
#define DRS_NEVER_NOTIFY           (0x20000000L) // Don't use change notifications
#define DRS_SYNC_PAS               (0x40000000L) // Marks PAS replication (PAS - Partial Attribute Set)
//OPEN                             (0x80000000L)

// flags to UpdateRefs when replicas added or deleted
#define DRS_ADD_REF                    (0x0004L) // when nc replicated
#define DRS_DEL_REF                    (0x0008L) // when replica nc deleted
#define DRS_GETCHG_CHECK               (0x0002L) // when done as a result of servicing
                                                 // a GetNCChanges request

// GetNcChanges flags
// Any flag valid for ReplicaSync may be passed to GetNcChanges
// DRS_CRITICAL_ONLY
// DRS_SYNC_FORCED
#define DRS_GET_ANC                    (0x0800L)       // Include ancestors
#define DRS_GET_NC_SIZE                (0x1000L)       // Return size of NC


// DirSync control flags
// These are passed separate from the replication flags
#define DRS_DIRSYNC_OBJECT_SECURITY             (0x1)
#define DRS_DIRSYNC_ANCESTORS_FIRST_ORDER    (0x0800)
#define DRS_DIRSYNC_PUBLIC_DATA_ONLY         (0x2000)
#define DRS_DIRSYNC_INCREMENTAL_VALUES   (0x80000000)

// [wlees] The state of options in the system is a real mess. In the future we
// ought to consider dividing the options into groups, as follows:
//
// o The mechanics of the operation request
// (ASYNC_OP, NO_DISCARD)
//
// o Flags that are stored on the persistent state of the replica
//   (use compression) See RFR_FLAGS
//   These are divided into static descriptive flags (write, periodic, etc)
//   and internal state flags that describe a mode across a series of calls
//   (FULL_SYNC_IN_PROGRESS, SYNC_PAS, INIT_SYNC_NOW, SYNC_REQUEUE)
//   The former may generally be set by the user, while the latter may not.
//
// o Flags that are operation specific and are single-shot modifiers
//   to the current request but are not persistant.
//   (critical only, ignore error)

// These are the flags that are used in calculating queue priority
#define AO_PRIORITY_FLAGS ( DRS_WRIT_REP \
                            | DRS_NEVER_SYNCED \
                            | DRS_NEVER_NOTIFY )

// These are the flags that may be set on the repsfromref attribute
// Note, any restartable (persistent) state bits that need to be preserved
// across a reboot need to be part of this mask.
#define RFR_FLAGS (RFR_SYSTEM_FLAGS | RFR_USER_FLAGS)

// This is the subset of the RFR_FLAGS that may only be set or cleared
// by the system.  Obviously this should not appears in REPADD_OPTIONS
// or REPMOD_REPLICA_FLAGS.
// Note that
// DRS_INIT_SYNC_NOW
// DRS_ABAN_SYNC
// DRS_SYNC_REQUEUE
// would fit the category, but do not need to be persisted
#define RFR_SYSTEM_FLAGS ( DRS_WRIT_REP          \
                   | DRS_FULL_SYNC_IN_PROGRESS  \
                   | DRS_FULL_SYNC_PACKET       \
                   | DRS_NEVER_SYNCED           \
                   | DRS_SYNC_PAS )

// This is the subset of the RFR_FLAGS that may be set by a user
#define RFR_USER_FLAGS (DRS_INIT_SYNC                \
                   | DRS_PER_SYNC               \
                   | DRS_MAIL_REP               \
                   | DRS_DISABLE_AUTO_SYNC      \
                   | DRS_DISABLE_PERIODIC_SYNC  \
                   | DRS_USE_COMPRESSION        \
                   | DRS_NEVER_NOTIFY           \
                   | DRS_TWOWAY_SYNC)



// These are the valid flags for the ReplicateNC call
#define REPNC_FLAGS ( DRS_CRITICAL_ONLY  \
                      | DRS_ASYNC_REP     \
                      | RFR_FLAGS )

// These are the valid options for the DirReplicaAdd call
// We add in DRS_WRIT_REP here since it is permitted on add.
#define REPADD_OPTIONS ( DRS_ASYNC_OP   \
                         | DRS_CRITICAL_ONLY          \
                         | DRS_ASYNC_REP              \
                         | DRS_WRIT_REP               \
                         | RFR_USER_FLAGS )

// These are the valid options for the DirReplicaModify call
#define REPMOD_OPTIONS ( DRS_ASYNC_OP )

// These are the valid options for the DirReplicaDelete call
// WRIT_REP and MAIL_REP are not read, but are permitted because
// legacy clients still pass them in.
#define REPDEL_OPTIONS (  DRS_ASYNC_OP                 \
                          | DRS_WRIT_REP               \
                          | DRS_MAIL_REP               \
                          | DRS_ASYNC_REP              \
                          | DRS_IGNORE_ERROR           \
                          | DRS_LOCAL_ONLY             \
                          | DRS_NO_SOURCE              \
                          | DRS_REF_OK)

// These are the valid options for the DirReplicaUpdateRef call
#define REPUPDREF_OPTIONS (  DRS_ASYNC_OP              \
                             | DRS_GETCHG_CHECK        \
                             | DRS_WRIT_REP            \
                             | DRS_DEL_REF             \
                             | DRS_ADD_REF)

// These are the valid options for the IDL_DRSReplicaSync RPC call
#define REPSYNC_RPC_OPTIONS ( DRS_ASYNC_OP             \
                              | RFR_USER_FLAGS         \
                              | DRS_WRIT_REP           \
                              | DRS_CRITICAL_ONLY      \
                              | DRS_UPDATE_NOTIFICATION \
                              | DRS_ADD_REF             \
                              | DRS_SYNC_ALL            \
                              | DRS_SYNC_BYNAME         \
                              | DRS_FULL_SYNC_NOW       \
                              | DRS_SYNC_URGENT         \
                              | DRS_SYNC_FORCED )

// Flags preserved when DRA_ReplicaSync() reenqueues the sync operation due to
// schema mismatch, preemption, etc.
// The flag DRS_INIT_SYNC_NOW is handled specially by the caller if needed
#define REPSYNC_REENQUEUE_FLAGS (DRS_SYNC_BYNAME        \
                                 | DRS_FULL_SYNC_NOW    \
                                 | DRS_NO_DISCARD       \
                                 | DRS_WRIT_REP         \
                                 | DRS_PER_SYNC         \
                                 | DRS_ADD_REF          \
                                 | DRS_NEVER_SYNCED     \
                                 | DRS_TWOWAY_SYNC      \
                                 | DRS_SYNC_PAS         \
                                 | DRS_SYNC_REQUEUE     \
                                 | DRS_SYNC_FORCED)

// Same as above, but allow for the init sync in progress indicator
// to be preserved because an init sync is being requeued
#define REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED \
    ( DRS_INIT_SYNC_NOW | REPSYNC_REENQUEUE_FLAGS )

// On a ReplicaSync doing a sync-all operation, this mask defines the flags
// that are kept that the requestor passed in.
#define REPSYNC_SYNC_ALL_FLAGS (DRS_FULL_SYNC_NOW \
                                | DRS_PER_SYNC \
                                | DRS_NO_DISCARD \
                                | DRS_SYNC_FORCED \
                                | DRS_SYNC_URGENT \
                                | DRS_ADD_REF)

// On a ReplicaSync doing a normal rpc-based sync using ReplicateNC.
// This mask defines the flags that are kept that the requestor passed in.
// Long-lived descriptive flags that are peristed in the reps-from, such
// as RFR_USER_FLAGS, should not be included here. They will always come
// from the reps-from which is added separately.
#define REPSYNC_REPLICATE_FLAGS (DRS_ABAN_SYNC \
                                 | DRS_INIT_SYNC_NOW \
                                 | DRS_ASYNC_OP \
                                 | DRS_FULL_SYNC_NOW \
                                 | DRS_SYNC_FORCED \
                                 | DRS_SYNC_URGENT \
                                 | DRS_ADD_REF )

// This is the filter on the options which go in a mail request to get changes
// Some extra may be or'd in after the fact in draConstructGetChgReq
#define GETCHG_REQUEST_FLAGS (DRS_ABAN_SYNC           \
                              | DRS_INIT_SYNC_NOW     \
                              | DRS_ASYNC_OP          \
                              | DRS_PER_SYNC          \
                              | DRS_FULL_SYNC_NOW     \
                              | DRS_SYNC_FORCED       \
                              | DRS_SYNC_URGENT       \
                              | DRS_FULL_SYNC_PACKET  \
                              | DRS_SYNC_PAS         \
                              | DRS_USE_COMPRESSION)

// Option translation table entry
typedef struct _OPTION_TRANSLATION {
    DWORD PublicOption;
    DWORD InternalOption;
    LPWSTR pwszPublicOption;
} OPTION_TRANSLATION, *POPTION_TRANSLATION;

#ifdef INCLUDE_OPTION_TRANSLATION_TABLES

#ifndef _MAKE_WIDE
#define _MAKE_WIDE(x)  L ## x
#endif

// Macros to make entering option name entries easier
#define REPSYNC_OPTION( x, y ) { DS_REPSYNC_##x,   DRS_##y, _MAKE_WIDE( #x ) }
#define REPADD_OPTION( x, y )  { DS_REPADD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPDEL_OPTION( x, y )  { DS_REPDEL_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPMOD_OPTION( x, y )  { DS_REPMOD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPUPD_OPTION( x, y )  { DS_REPUPD_##x,    DRS_##y, _MAKE_WIDE( #x ) }
#define REPNBR_OPTION( x, y )  { DS_REPL_NBR_##x,  DRS_##y, _MAKE_WIDE( #x ) }

// Note that these option translation tables are used for option conversion,
// not for validation of which options are permissible.  Also note that these
// tables are used for the setting and displaying of operation states.  Thus
// while a subset of these options may be specified when the operation is
// requested, they all may be needed when showing an operation request in the
// queue.

//*******************
// ReplicaSync options
//*******************
OPTION_TRANSLATION RepSyncOptionToDra[] = {
    REPSYNC_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP      ),
    REPSYNC_OPTION( WRITEABLE             , WRIT_REP      ),
    REPSYNC_OPTION( PERIODIC              , PER_SYNC      ),
    REPSYNC_OPTION( INTERSITE_MESSAGING   , MAIL_REP      ),
    REPSYNC_OPTION( ALL_SOURCES           , SYNC_ALL      ),
    REPSYNC_OPTION( FULL                  , FULL_SYNC_NOW ),
    REPSYNC_OPTION( URGENT                , SYNC_URGENT   ),
    REPSYNC_OPTION( NO_DISCARD            , NO_DISCARD    ),
    REPSYNC_OPTION( FORCE                 , SYNC_FORCED   ),
    REPSYNC_OPTION( ADD_REFERENCE         , ADD_REF       ),
    REPSYNC_OPTION( TWO_WAY               , TWOWAY_SYNC   ),
    REPSYNC_OPTION( NEVER_COMPLETED       , NEVER_SYNCED  ),
    REPSYNC_OPTION( NEVER_NOTIFY          , NEVER_NOTIFY  ),
    REPSYNC_OPTION( INITIAL               , INIT_SYNC     ),
    REPSYNC_OPTION( USE_COMPRESSION       , USE_COMPRESSION  ),
    REPSYNC_OPTION( ABANDONED             , ABAN_SYNC     ),
    REPSYNC_OPTION( INITIAL_IN_PROGRESS   , INIT_SYNC_NOW ),
    REPSYNC_OPTION( PARTIAL_ATTRIBUTE_SET , SYNC_PAS      ),
    REPSYNC_OPTION( REQUEUE               , SYNC_REQUEUE  ),
    REPSYNC_OPTION( NOTIFICATION          , UPDATE_NOTIFICATION ),
    REPSYNC_OPTION( ASYNCHRONOUS_REPLICA  , ASYNC_REP ),
    REPSYNC_OPTION( CRITICAL              , CRITICAL_ONLY ),
    REPSYNC_OPTION( FULL_IN_PROGRESS      , FULL_SYNC_IN_PROGRESS ),
    REPSYNC_OPTION( PREEMPTED             , PREEMPTED ),
    {0}
};

//*******************
// ReplicaAdd options
//*******************
OPTION_TRANSLATION RepAddOptionToDra[] = {
    REPADD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP                 ),
    REPADD_OPTION( WRITEABLE             , WRIT_REP                 ),
    REPADD_OPTION( INITIAL               , INIT_SYNC                ),
    REPADD_OPTION( PERIODIC              , PER_SYNC                 ),
    REPADD_OPTION( INTERSITE_MESSAGING   , MAIL_REP                 ),
    REPADD_OPTION( ASYNCHRONOUS_REPLICA  , ASYNC_REP                ),
    REPADD_OPTION( DISABLE_NOTIFICATION  , DISABLE_AUTO_SYNC        ),
    REPADD_OPTION( DISABLE_PERIODIC      , DISABLE_PERIODIC_SYNC    ),
    REPADD_OPTION( USE_COMPRESSION       , USE_COMPRESSION          ),
    REPADD_OPTION( NEVER_NOTIFY          , NEVER_NOTIFY             ),
    REPADD_OPTION( TWO_WAY               , TWOWAY_SYNC              ),
    REPADD_OPTION( CRITICAL              , CRITICAL_ONLY            ),
    {0}
};

//*******************
// ReplicaDelete options
//*******************
OPTION_TRANSLATION RepDelOptionToDra[] = {
    REPDEL_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP     ),
    REPDEL_OPTION( WRITEABLE             , WRIT_REP     ), // legacy
    REPDEL_OPTION( INTERSITE_MESSAGING   , MAIL_REP     ), // legacy
    REPDEL_OPTION( IGNORE_ERRORS         , IGNORE_ERROR ),
    REPDEL_OPTION( LOCAL_ONLY            , LOCAL_ONLY   ),
    REPDEL_OPTION( NO_SOURCE             , NO_SOURCE    ),
    REPDEL_OPTION( REF_OK                , REF_OK       ),
    {0}
};

//*******************
// ReplicaModify options
//*******************
OPTION_TRANSLATION RepModOptionToDra[] = {
    REPMOD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP ),
    {0}
};

//*******************
// ReplicaModify field names
//*******************
OPTION_TRANSLATION RepModFieldsToDra[] = {
    REPMOD_OPTION( UPDATE_FLAGS     , UPDATE_FLAGS      ),
    REPMOD_OPTION( UPDATE_ADDRESS   , UPDATE_ADDRESS    ),
    REPMOD_OPTION( UPDATE_SCHEDULE  , UPDATE_SCHEDULE   ),
    REPMOD_OPTION( UPDATE_RESULT    , UPDATE_RESULT     ),
    REPMOD_OPTION( UPDATE_TRANSPORT , UPDATE_TRANSPORT  ),
    {0}
};

//*******************
// UpdateRefs option names
//*******************
OPTION_TRANSLATION UpdRefOptionToDra[] = {
    REPUPD_OPTION( ASYNCHRONOUS_OPERATION, ASYNC_OP ),
    REPUPD_OPTION( WRITEABLE             , WRIT_REP ),
    REPUPD_OPTION( ADD_REFERENCE         , ADD_REF  ),
    REPUPD_OPTION( DELETE_REFERENCE      , DEL_REF  ),
    {0}
};

//*******************
// Replica flag names
//*******************
// This flags are stored in the reps-from.  They are retrieved by the
// Get Neighbors information type, and set in the Modify Replica
// call under the replica flags argument.  These are not the same
// as the options which may be passed to Sync Replica. This table
// is not used to decode flags in the Get Pending Queue function.

// This list should match the contents of RFR_FLAGS

OPTION_TRANSLATION RepNbrOptionToDra[] = {
    REPNBR_OPTION( SYNC_ON_STARTUP,               INIT_SYNC ),
    REPNBR_OPTION( DO_SCHEDULED_SYNCS,            PER_SYNC ),
    REPNBR_OPTION( WRITEABLE,                     WRIT_REP ),
    REPNBR_OPTION( USE_ASYNC_INTERSITE_TRANSPORT, MAIL_REP ),
    REPNBR_OPTION( IGNORE_CHANGE_NOTIFICATIONS,   DISABLE_AUTO_SYNC ),
    REPNBR_OPTION( DISABLE_SCHEDULED_SYNC,        DISABLE_PERIODIC_SYNC ),
    REPNBR_OPTION( FULL_SYNC_IN_PROGRESS,         FULL_SYNC_IN_PROGRESS ),
    REPNBR_OPTION( FULL_SYNC_NEXT_PACKET,         FULL_SYNC_PACKET ),
    REPNBR_OPTION( COMPRESS_CHANGES,              USE_COMPRESSION ),
    REPNBR_OPTION( NO_CHANGE_NOTIFICATIONS,       NEVER_NOTIFY ),
    REPNBR_OPTION( NEVER_SYNCED,                  NEVER_SYNCED ),
    REPNBR_OPTION( TWO_WAY_SYNC,                  TWOWAY_SYNC ),
    REPNBR_OPTION( PARTIAL_ATTRIBUTE_SET,         SYNC_PAS ),
    {0}
};

#undef _MAKE_WIDE
#else

extern OPTION_TRANSLATION RepSyncOptionToDra[];
extern OPTION_TRANSLATION RepAddOptionToDra[];
extern OPTION_TRANSLATION RepDelOptionToDra[];
extern OPTION_TRANSLATION RepModOptionToDra[];
extern OPTION_TRANSLATION RepModFieldsToDra[];
extern OPTION_TRANSLATION UpdRefOptionToDra[];
extern OPTION_TRANSLATION RepNbrOptionToDra[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsaalloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsaalloc.h
//
//--------------------------------------------------------------------------

/*

Description:
    Contains declarations of routines used to allocate memory for
    the RPC runtime.
*/

#ifndef _dsaalloc_h_
#define _dsaalloc_h_

#ifdef __cplusplus
extern "C" {
#endif

extern void* __RPC_USER MIDL_user_allocate( size_t bytes);
extern void __RPC_USER MIDL_user_free( void* memory);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\draasync.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       draasync.h
//
//--------------------------------------------------------------------------

/* draasync.h - Directory Replication Service Async Operations.

	Async Operations are handled in the following manor.

	1). The DRA recieves an RPC request through one of the IDL_DRS...
	functions. This function then builds a AO (Async Op) structure for
	all APIs that can be async (even if this call isnt an async one).

	2). The AO structure is then either placed on the AO list (if this
	operation is an async one) or passed to the async op distpatcher
	routine (DispatchPao) immediately if it is not.

	2.1). A separate thread services the AO list, taking the first
	item from it and calling DispatchPao, on returning from DispatchPao
	the status is set in the AO structure and the next (uncompleted)
	operation in the list is serviced.

	3). The DispatchPao routine unpacks the AO structure and calls the
	appropriate DRS_... function.
	
	NOTES:

	a). We always build the AO structure (even if not an aync op)
	because it reduces the number of paths through the code and makes
	testing easier. It also requires less code overall.

	b). When we build the AO structure we must remember to make COPIES of
	all the parameters. We do this because if this is an async op RPC will
	have deallocated the originals before we get to use them.
*/

#ifndef DRSASYNC_H_INCLUDED
#define DRSASYNC_H_INCLUDED

// If you add to this list, be sure and add the corresponding #undef below.
#ifdef MIDL_PASS
#define SWITCH_TYPE(x)  [switch_type(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define CASE(x)         [case(x)]
#else
#define SWITCH_TYPE(x)
#define SWITCH_IS(x)
#define CASE(x)
#endif

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_add {
    DSNAME          *pNC;
    DSNAME          *pSourceDsaDN;
    DSNAME          *pTransportDN;
    MTX_ADDR        *pDSASMtx_addr;
    LPWSTR          pszSourceDsaDnsDomainName;
    REPLTIMES       *preptimesSync;
} ARGS_REP_ADD;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_del {
    DSNAME          *pNC;
    MTX_ADDR        *pSDSAMtx_addr;
} ARGS_REP_DEL;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_sync {
    DSNAME          *pNC;
    UUID            invocationid;
    LPWSTR          pszDSA;
} ARGS_REP_SYNC;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_upd_refs {
    DSNAME          *pNC;
    MTX_ADDR        *pDSAMtx_addr;
    UUID            invocationid;
} ARGS_UPD_REFS;

// Read NOTE below if you're considering modifying this structure.
typedef struct _args_rep_mod {
    DSNAME *        pNC;
    UUID *          puuidSourceDRA;
    UUID            uuidSourceDRA;
    UUID *          puuidTransportObj;
    UUID            uuidTransportObj;
    MTX_ADDR *      pmtxSourceDRA;
    REPLTIMES       rtSchedule;
    ULONG           ulReplicaFlags;
    ULONG           ulModifyFields;
} ARGS_REP_MOD;

#define AO_OP_REP_ADD	1
#define AO_OP_REP_DEL	2
#define AO_OP_REP_MOD   4
#define AO_OP_REP_SYNC	5
#define AO_OP_UPD_REFS	6

// Read NOTE below if you're considering adding a new member to the union.
typedef SWITCH_TYPE(ULONG) union {
    CASE(AO_OP_REP_ADD ) ARGS_REP_ADD    rep_add;
    CASE(AO_OP_REP_DEL ) ARGS_REP_DEL    rep_del;
    CASE(AO_OP_REP_MOD ) ARGS_REP_MOD    rep_mod;
    CASE(AO_OP_REP_SYNC) ARGS_REP_SYNC   rep_sync;
    CASE(AO_OP_UPD_REFS) ARGS_UPD_REFS   upd_refs;
} ARGS_REP;

typedef struct _ao {
    struct _ao *paoNext;        /* Used to chain AO structures */
    DSTIME      timeEnqueued;   /* time at which the operation was enqueued */
    ULONG       ulSerialNumber; /* ID of this op; unique per machine per boot */
    ULONG       ulOperation;    /* Which Async op */
    ULONG       ulOptions;
    ULONG       ulPriority;     /* Is this a priority operation? */
    ULONG       ulResult;       /* if synchronous, holds result code when done*/
    HANDLE      hDone;          /* if synchronous, signalled when complete */
    SWITCH_IS(ulOperation)
        ARGS_REP args;
} AO;


DWORD DoOpDRS(AO *pao);
void GetDRASyncLock();
void FreeDRASyncLock ();
extern DWORD TidDRAAsync;
#define OWN_DRA_LOCK() (GetCurrentThreadId() == TidDRAAsync)

BOOL IsHigherPriorityDraOpWaiting(void);
BOOL IsDraOpWaiting(void);
void InitDraQueue(void);

extern BOOL gfDRABusy;

// CONFIG here means a system paritition, Config or Schema
// DOMAIN here means a non-system partition, domain or NDNC

typedef enum {                                              // lowest priority
    AOPRI_ASYNC_DELETE                                                   = 10,
    AOPRI_UPDATE_REFS_VERIFY                                             = 20,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE              = 30,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED    = 40,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY                        = 50,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_PREEMPTED              = 60,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE             = 70,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED   = 80,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE                       = 90,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_PREEMPTED             = 100,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE              = 110,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE_PREEMPTED    = 120,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY                        = 130,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_PREEMPTED              = 140,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE             = 150,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED   = 160,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE                       = 170,
    AOPRI_ASYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_PREEMPTED             = 180,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE              = 190,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE_PREEMPTED    = 200,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY                        = 210,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_PREEMPTED              = 220,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE             = 230,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED   = 240,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE                       = 250,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_PREEMPTED             = 260,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE              = 270,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE_PREEMPTED    = 280,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY                        = 290,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_PREEMPTED              = 300,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE             = 310,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED   = 320,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE                       = 330,
    AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED             = 340,
    AOPRI_ASYNC_MODIFY                                                   = 350,
    AOPRI_SYNC_DELETE                                                    = 360,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE               = 370,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED     = 380,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY                         = 390,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_PREEMPTED               = 400,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE              = 410,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED    = 420,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE                        = 430,
    AOPRI_SYNC_SYNCHRONIZE_INTER_DOMAIN_WRITEABLE_PREEMPTED              = 440,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE               = 450,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_NEWSOURCE_PREEMPTED     = 460,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY                         = 470,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_READONLY_PREEMPTED               = 480,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE              = 490,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED    = 500,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE                        = 510,
    AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE_PREEMPTED              = 520,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE               = 530,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_NEWSOURCE_PREEMPTED     = 540,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY                         = 550,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_READONLY_PREEMPTED               = 560,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE              = 570,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_NEWSOURCE_PREEMPTED    = 580,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE                        = 590,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE_PREEMPTED              = 600,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE               = 610,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_NEWSOURCE_PREEMPTED     = 620,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY                         = 630,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY_PREEMPTED               = 640,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE              = 650,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE_PREEMPTED    = 660,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE                        = 670,
    AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED              = 680,
    AOPRI_SYNC_MODIFY                                                    = 690,
    AOPRI_UPDATE_REFS                                                    = 700
} AO_PRIORITY;                                              // highest priority

// Base priority for sync operations (before addition of applicable
// AOPRI_BOOST_SYNCHRONIZE_*'s).
#define AOPRI_SYNCHRONIZE_BASE  AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE

// Priority boost for incremental syncs (vs. syncs from sources we've never
// completed a sync from before).
#define AOPRI_SYNCHRONIZE_BOOST_INCREMENTAL         \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE               \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_NEWSOURCE)

// Priority boost for syncs of writeable NCs (vs. read-only NCs). 
#define AOPRI_SYNCHRONIZE_BOOST_WRITEABLE   \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_READONLY)

// Priority boost for synchronous sync requests (vs. asynchronous syncs).
#define AOPRI_SYNCHRONIZE_BOOST_SYNC        \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_ASYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE)

// Priority boost for preempted sync requests.
#define AOPRI_SYNCHRONIZE_BOOST_PREEMPTED       \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE_PREEMPTED \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE)

// Priority boost for being in the same site
#define AOPRI_SYNCHRONIZE_BOOST_INTRASITE \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTER_CONFIG_WRITEABLE)

// Priority boost for being a system NC
#define AOPRI_SYNCHRONIZE_BOOST_SYSTEM_NC \
    (AOPRI_SYNC_SYNCHRONIZE_INTRA_CONFIG_WRITEABLE       \
     - AOPRI_SYNC_SYNCHRONIZE_INTRA_DOMAIN_WRITEABLE)

#ifndef MIDL_PASS
extern CRITICAL_SECTION csAOList;

ULONG
draGetPendingOps(
    IN  struct _THSTATE *               pTHS,
    IN  struct DBPOS *                  pDB,
    OUT struct _DS_REPL_PENDING_OPSW ** ppPendingOps
    );

ULONG
DraSetQueueLock(
    IN  BOOL  fEnable
    );

ULONG
draGetQueueStatistics(
    IN  struct _THSTATE *                    pTHS,
    OUT struct _DS_REPL_QUEUE_STATISTICSW ** ppQueueStats);

#if DBG
BOOL
DraIsValidLongRunningTask();
#endif // #if DBG

#endif // #ifndef MIDL_PASS

#undef SWITCH_TYPE
#undef SWITCH_IS
#undef CASE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dracheck.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dracheck.h
//
//--------------------------------------------------------------------------

/*****************************************************************************/
/* EMS DRA Consistency external declarations                                 */
/*****************************************************************************/
/* Comands to consistency checker                               	     */
/*****************************************************************************/

enum KCC_COMMAND {
    KCC_CHECK = 2,
    KCC_QUIT
};
/*****************************************************************************/
/* FLags to modify operation		                               	     */
/*****************************************************************************/
#define KCC_ASYNC_OP	1	// Run check asynchronously
#define	KCC_NO_WAIT	0x2	// Don't wait if check is already running

/*****************************************************************************/
/* Entry points exported by DRA Consistency DLL                               */
/*****************************************************************************/
typedef DWORD (WINAPI *DRACheck_DLL_INITFN)
		(LPCSTR szEnt, LPCSTR szSite, LPCSTR szServer);
DWORD WINAPI KccInit(LPCSTR szEnt, LPCSTR szSite, LPCSTR szServer);
typedef DWORD (WINAPI *DRACheck_DLL_ENTRYFN) (enum KCC_COMMAND command, DWORD ulFlag);
DWORD WINAPI KccCommand(enum KCC_COMMAND command, DWORD ulFlag);

/*****************************************************************************/
/* Return code from DLL export                                               */
/*****************************************************************************/
#define		SUCCESS			0

/*****************************************************************************/
/* Name of DRACHECK DLL and entry point                                           */
/*****************************************************************************/
#define DRACHECK_DLL_NAME    "DRACHECK.DLL"
#if defined (_X86_)
#define DRACHECK_DLL_INIT    "KccInit@12"
#define DRACHECK_DLL_ENTRY   "KccCommand@8"
#else
#define DRACHECK_DLL_INIT    "KccInit"
#define DRACHECK_DLL_ENTRY   "KccCommand"
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\drax400.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drax400.h
//
//--------------------------------------------------------------------------

// Defines of error codes returned from the DRA X400 DLL

#define MAIL_SUCCESS 0
#define MAIL_SRC_NAME_ERROR 2
#define MAIL_DEST_NAME_ERROR 3
#define MAIL_OPEN_ERROR 4
#define MAIL_NO_MAIL 5
#define MAIL_REC_ERROR 6
#define MAIL_REC_ERROR_F 7
#define MAIL_NO_MEMORY 8
#define MAIL_LOAD_ERROR 9
#define MAIL_SEND_ERROR 10
#define MAIL_SEND_ERROR_F 10
#define MAIL_NDR_RCVD 11
#define MAIL_V2_EXCEPTION 12

// Define the MTS id structure passed between DRA and DLL

// The array sizes are from xmhp.h. That file cannot be included here
// because that requires a huge tree of further includes.

// Defines are 
#define ADMD_NAME_LEN 16        // MH_VL_ADMD_NAME 
#define COUNTRY_NAME_LEN 3      // MH_VL_COUNTRY_NAME
#define LOCAL_ID_LEN 32         // MH_VL_LOCAL_IDENTIFIER
#define PRMD_ID_LEN 16          // MH_VL_PRMD_IDENTIFIER

typedef struct _MTSID {
    char AdmdName[ADMD_NAME_LEN+1];           // Allow for termination
    char CountryName[COUNTRY_NAME_LEN+1];
    char LocalIdentifier[LOCAL_ID_LEN+1];
    char PrmdIdentifier[PRMD_ID_LEN+1];
} MTSID;
    

// This is the stucture to hold information from an NDR.

typedef struct _NDR_DATA {
    long Diagnostic;
    long Reason;
} NDR_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\drserr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drserr.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Replication error codes

Author:

Environment:

Notes:

    These errors are returned by the replica rpc functions, and are part of the
    formal wire interface between DSAs.  Do not change these values.

April 23, 1998  wlees
These values were once small constants.  Now they refer to standard Win32
values.  This file is effectively obsolete.  Do not add new values to this
file.  Instead, reference the ERROR_DS values directly.

Revision History:

--*/

#ifndef _drserr_
#define _drserr_

#define DRSERR_BASE                     0
#define DRAERR_Success                  0
#define DRAERR_Generic                  ERROR_DS_DRA_GENERIC
#define DRAERR_InvalidParameter         ERROR_DS_DRA_INVALID_PARAMETER
// ERROR_BUSY?
#define DRAERR_Busy                     ERROR_DS_DRA_BUSY
#define DRAERR_BadDN                    ERROR_DS_DRA_BAD_DN
#define DRAERR_BadNC                    ERROR_DS_DRA_BAD_NC
#define DRAERR_DNExists                 ERROR_DS_DRA_DN_EXISTS
#define DRAERR_InternalError            ERROR_DS_DRA_INTERNAL_ERROR
#define DRAERR_InconsistentDIT          ERROR_DS_DRA_INCONSISTENT_DIT
// DRAERR_ConnectionFailed/ERROR_DS_DRA_CONNECTION_FAILED not used anymore
#define DRAERR_BadInstanceType          ERROR_DS_DRA_BAD_INSTANCE_TYPE
// ERROR_NOT_ENOUGH_MEMORY?
#define DRAERR_OutOfMem                 ERROR_DS_DRA_OUT_OF_MEM
#define DRAERR_MailProblem              ERROR_DS_DRA_MAIL_PROBLEM
// DRAERR_ExtnConnectionFailed/ERROR_DS_DRA_EXTN_CONNECTION_FAILED not used
#define DRAERR_RefAlreadyExists         ERROR_DS_DRA_REF_ALREADY_EXISTS
#define DRAERR_RefNotFound              ERROR_DS_DRA_REF_NOT_FOUND
#define DRAERR_ObjIsRepSource           ERROR_DS_DRA_OBJ_IS_REP_SOURCE
#define DRAERR_DBError                  ERROR_DS_DRA_DB_ERROR
#define DRAERR_NoReplica                ERROR_DS_DRA_NO_REPLICA
// ERROR_ACCESS_DENIED?
#define DRAERR_AccessDenied             ERROR_DS_DRA_ACCESS_DENIED
#define DRAERR_SchemaMismatch           ERROR_DS_DRA_SCHEMA_MISMATCH
#define DRAERR_SchemaInfoShip           ERROR_DS_DRA_SCHEMA_INFO_SHIP
#define DRAERR_SchemaConflict           ERROR_DS_DRA_SCHEMA_CONFLICT
#define DRAERR_EarlierSchemaConflict    ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT
#define DRAERR_RPCCancelled             ERROR_DS_DRA_RPC_CANCELLED
#define DRAERR_SourceDisabled           ERROR_DS_DRA_SOURCE_DISABLED
#define DRAERR_SinkDisabled             ERROR_DS_DRA_SINK_DISABLED
#define DRAERR_NameCollision            ERROR_DS_DRA_NAME_COLLISION
#define DRAERR_SourceReinstalled        ERROR_DS_DRA_SOURCE_REINSTALLED
#define DRAERR_IncompatiblePartialSet   ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET
#define DRAERR_SourceIsPartialReplica   ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA
// ERROR_NOT_SUPPORTED?
#define DRAERR_NotSupported             ERROR_DS_DRA_NOT_SUPPORTED

// TODO: Need to make error codes in WINERROR.H
#define DRAERR_CryptError               ERROR_ENCRYPTION_FAILED
#define DRAERR_MissingObject            ERROR_OBJECT_NOT_FOUND

// ** See note on adding new DRS errors above. **

// These errors are now obsolete.  Generate a compile-time syntax error
#undef ERROR_DS_DRA_CONNECTION_FAILED
#undef ERROR_DS_DRA_EXTN_CONNECTION_FAILED

// The folllowing errors are used within the DRA and will not be returned
// from the DRA API.

#define DRAERR_MissingParent    ERROR_DS_DRA_MISSING_PARENT

// The following are warning errors, which means that they may occur in
// normal operation. They are also logged in blue instead of yellow

#define DRAERR_Preempted        ERROR_DS_DRA_PREEMPTED
#define DRAERR_AbandonSync      ERROR_DS_DRA_ABANDON_SYNC

// The following are informational errors, which means that they may occur in
// normal operation. They are also logged in blue instead of yellow

#define DRAERR_Shutdown         ERROR_DS_DRA_SHUTDOWN


#endif /* ifndef _drserr_ */

/* end drserr.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsconfig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsconfig.h
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  GetConfigParam()
 *
 *      PCHAR   parameter       - item for which we want the value
 *      PVOID   value       - pointer to variable in which to
 *                    place the value
 *      DWORD   dwSize      - size of value in bytes
 */

DWORD
GetConfigParam(
    char * parameter,
    void * value,
    DWORD dwSize);

DWORD
GetConfigParamW(
    WCHAR * parameter,
    void * value,
    DWORD dwSize);

DWORD
GetConfigParamA(
    char * parameter,
    void * value,
    DWORD dwSize);

/*
 *  GetConfigParamAlloc()
 *
 *      PCHAR   parameter    - item for which we want the value
 *      PVOID   *value       - pointer to variable in which to
 *                             store a pointer to the newly malloced buffer
 *                             containing the value.
 *      PDWORD   dwSize      - pointer to a variable in which to store the size
 *                             of the buffer.
 */

DWORD
GetConfigParamAlloc(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
GetConfigParamAllocW(
    IN  PWCHAR  parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
GetConfigParamAllocA(
    IN  PCHAR   parameter,
    OUT PVOID   *value,
    OUT PDWORD  pdwSize);

DWORD
SetConfigParam(
    char * parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize);

DWORD
DeleteConfigParam(
    char * parameter);

//
// This macro will make any of the below constants a wide char
// constant.  Note that the indirection of the macros is necessary
// to get the desired effect. This macros only make sense in a
// non-UNICODE environment.
//
#define _MAKE_WIDE(x)  L ## x
#define MAKE_WIDE(x)   _MAKE_WIDE(x)

/*
 *  Following is the list keys defined for use by the DSA and
 *  utilities.  First, the sections.
 */
#define SERVICE_NAME            "NTDS"
#define SERVICE_LONG_NAME       "Microsoft NTDS"
#define DSA_CONFIG_ROOT         "System\\CurrentControlSet\\Services\\NTDS"
#define DSA_CONFIG_SECTION      "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
#define DSA_PERF_SECTION        "System\\CurrentControlSet\\Services\\NTDS\\Performance"
#define DSA_EVENT_SECTION       "System\\CurrentControlSet\\Services\\NTDS\\Diagnostics"
#define DSA_LOCALE_SECTION      "SOFTWARE\\Microsoft\\NTDS\\Language"
#define DSA_SECURITY_SECTION    "SOFTWARE\\Microsoft\\NTDS\\Security"
#define SETUP_SECTION           "SOFTWARE\\Microsoft\\NTDS\\Setup"
#define BACKUP_EXCLUSION_SECTION "System\\CurrentControlSet\\Control\\BackupRestore\\FilesNotToBackup"

/*
 * NTDS key for excluding DS specific files from being backed up as part of filesystem backup
 */
#define NTDS_BACKUP_EXCLUSION_KEY "NTDS"    // REG_MULTI_SZ specifying list of directories to be excluded

/*
 * NTDS SETUP KEYS
*/

#define NTDSINIFILE                  "NTDS Init File"
#define MACHINEDNNAME                "Machine DN Name"
#define REMOTEMACHINEDNNAME          "Remote Machine DN Name"
#define SCHEMADNNAME                 "Schema DN Name"
#define SCHEMADNNAME_W               L"Schema DN Name"

#define ROOTDOMAINDNNAME             "Root Domain"
#define ROOTDOMAINDNNAME_W           L"Root Domain"
#define X500ROOT                     "X500 Root"

#define CONFIGNCDNNAME               "Configuration NC"
#define CONFIGNCDNNAME_W             L"Configuration NC"

#define SRCCONFIGNCSRV               "Src Config NC   Srv"
#define SRCROOTDOMAINSRV             "Src Root Domain Srv"
#define SETUPINITIALREPLWITH         "SetupInitialReplWith"
#define SOURCEDSADNSDOMAINNAME       "Src Srv DNS Domain Name"
#define SOURCEDSAOBJECTGUID          "Src Srv objectGuid"

#define LOCALCONNECTIONDNNAME        "Local Connection DN Name"
#define REMOTECONNECTIONDNNAME       "Remote Connection DN Name"
#define NEWDOMAINCROSSREFDNNAME      "New Domain Cross-Ref DN Name"

#define INIDEFAULTCONFIGNCDIT        "DEFAULTCONFIGNC"
#define INIDEFAULTROOTDOMAINDIT      "DEFAULTROOTDOMAIN"
#define INIDEFAULTMACHINE            "DEFAULTMACHINE"
#define INIDEFAULTSCHEMANCDIT        "DEFAULTSCHEMANC"
#define INIDEFAULTLOCALCONNECTION    "DEFAULTLOCALCONNECTION"
#define INIDEFAULTREMOTECONNECTION   "DEFAULTREMOTECONNECTION"
#define INIDEFAULTNEWDOMAINCROSSREF  "DEFAULTNEWDOMAINCROSSREF"
#define DNSROOT                      "DNS Root"
#define NETBIOSNAME                  "Netbios Name"
#define INSTALLSITENAME              "InstallSiteName"
#define SCHEMAVERSION                "Schema Version"
#define INSTALLSITEDN                "InstallSiteDn"
#define ROOTDOMAINSID                "RootDomainSid"
#define ROOTDOMAINDNSNAME            "RootDomainDnsName"
#define TRUSTEDCROSSREF              "TrustedCrossRef"
#define LOCALMACHINEACCOUNTDN        "Local Machine Account DN"
#define RESTOREPATH                  "RestorePath"
#define FORESTBEHAVIORVERSION        "InstallForestBehaviorVersion"


/* Parameters keys */

#define PHANTOM_SCAN_RATE       "Days per Database Phantom Scan"
#define MAPI_ON_KEY             "Initialize MAPI interface"
#define DO_LIST_OBJECT_KEY      "Enforce LIST_OBJECTS rights"
#define DSA_HEURISTICS          "DSA Heuristics"
#define SERVER_THREADS_KEY      "Max Threads (ExDS+NSP+DRA)"
#define FILEPATH_KEY            "DSA Database file"
#define JETSYSTEMPATH_KEY       "DSA Working Directory"
#define CRITICAL_OBJECT_INSTALL "Critical Object Installation"
#define DSA_DRIVE_MAPPINGS      "DS Drive Mappings"
#define DSA_RESTORE_COUNT_KEY   "DSA Previous Restore Count"
#define TOMB_STONE_LIFE_TIME    "TombstoneLifeTime"
#define DB_MAX_OPEN_TABLES      "Maximum Open Tables"
#define DB_MAX_TRANSACTION_TIME "Max Transaction Time(secs)"
#define DB_CACHE_RECORDS        "Cache database records"

// Garbage collect expired dynamic objects (entryTTL == 0)
#define DSA_DELETE_EXPIRED_ENTRYTTL_SECS        "Delete expired entryTTL (secs)"
#define DSA_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS   "Delete next expired entryTTL (secs)"
#define DSA_SCHEMA_FSMO_LEASE_SECS              "Schema FSMO lease (secs)"
#define DSA_SCHEMA_FSMO_LEASE_MAX_SECS          "Schema FSMO maximum lease (secs)"

// This is currently used for checked builds only.
#define DSA_THREAD_STATE_HEAP_LIMIT                "Thread State Heap Limit"

#define DRA_NOTIFY_START_PAUSE  "Replicator notify pause after modify (secs)"
#define DRA_NOTIFY_INTERDSA_PAUSE "Replicator notify pause between DSAs (secs)"
#define DRA_INTRA_PACKET_OBJS   "Replicator intra site packet size (objects)"
#define DRA_INTRA_PACKET_BYTES  "Replicator intra site packet size (bytes)"
#define DRA_INTER_PACKET_OBJS   "Replicator inter site packet size (objects)"
#define DRA_INTER_PACKET_BYTES  "Replicator inter site packet size (bytes)"
#define DRA_ASYNC_INTER_PACKET_OBJS   "Replicator async inter site packet size (objects)"
#define DRA_ASYNC_INTER_PACKET_BYTES  "Replicator async inter site packet size (bytes)"
#define DRA_MAX_GETCHGTHRDS     "Replicator maximum concurrent read threads"
#define DRA_AOQ_LIMIT           "Replicator operation backlog limit"
#define DRA_THREAD_OP_PRI_THRESHOLD "Replicator thread op priority threshold"
#define DRA_CTX_LIFETIME_INTRA  "Replicator intra site RPC handle lifetime (secs)"
#define DRA_CTX_LIFETIME_INTER  "Replicator inter site RPC handle lifetime (secs)"
#define DRA_CTX_EXPIRY_CHK_INTERVAL "Replicator RPC handle expiry check interval (secs)"
#define DRA_MAX_WAIT_FOR_SDP_LOCK "Replicator maximum wait for SDP lock (msecs)"
#define DRA_MAX_WAIT_MAIL_SEND_MSG "Replicator maximum wait mail send message (msecs)"
#define DRA_MAX_WAIT_SLOW_REPL_WARN "Replicator maximum wait too slow warning (mins)"
#define DRA_THREAD_PRI_HIGH     "Replicator thread priority high"
#define DRA_THREAD_PRI_LOW      "Replicator thread priority low"
#define DRA_REPL_QUEUE_CHECK_TIME "Replicator queue check time (mins)"
#define DRA_REPL_LATENCY_CHECK_INTERVAL "Replicator latency check interval (days)"
#define DRA_REPL_COMPRESSION_LEVEL "Replicator compression level"

#define DB_EXPENSIVE_SEARCH_THRESHOLD   "Expensive Search Results Threshold"
#define DB_INEFFICIENT_SEARCH_THRESHOLD "Inefficient Search Results Threshold"
#define DB_INTERSECT_THRESHOLD          "Intersect Threshold"
#define DB_INTERSECT_RATIO              "Intersect Ratio"

#define DRSRPC_BIND_TIMEOUT            "RPC Bind Timeout (mins)"
#define DRSRPC_REPLICATION_TIMEOUT     "RPC Replication Timeout (mins)"
#define DRSRPC_GCLOOKUP_TIMEOUT        "RPC GC Lookup Timeout (mins)"
#define DRSRPC_MOVEOBJECT_TIMEOUT      "RPC Move Object Timeout (mins)"
#define DRSRPC_NT4CHANGELOG_TIMEOUT    "RPC NT4 Change Log Timeout (mins)"
#define DRSRPC_OBJECTEXISTENCE_TIMEOUT "RPC Object Existence Timeout (mins)"
#define DRSRPC_GETREPLINFO_TIMEOUT     "RPC Get Replica Information Timeout (mins)"

#define LDAP_INTEGRITY_POLICY_KEY   "LdapServerIntegrity"

#define BACKUPPATH_KEY          "Database backup path"
#define BACKUPINTERVAL_KEY      "Database backup interval (hours)"
#define LOGPATH_KEY             "Database log files path"
#define RECOVERY_KEY            "Database logging/recovery"
#define HIERARCHY_PERIOD_KEY    "Hierarchy Table Recalculation interval (minutes)"
#define DSA_RESTORED_DB_KEY     "Database restored from backup"
#define MAX_BUFFERS             "EDB max buffers"
#define MAX_LOG_BUFFERS         "EDB max log buffers"
#define LOG_FLUSH_THRESHOLD     "EDB log buffer flush threshold"
#define BUFFER_FLUSH_START      "EDB buffer flush start"
#define BUFFER_FLUSH_STOP       "EDB buffer flush stop"
#define SPARE_BUCKETS           "EDB max ver pages (increment over the minimum)"
#define SERVER_FUNCTION_KEY     "Server Functionality"
#define TCPIP_PORT              "TCP/IP Port"
#define RESTORE_TRIGGER         "Restore from disk backup"
#define PERF_COUNTER_VERSION    "Performance Counter Version"
#define MAILPATH_KEY            "Mail-based replication drop directory"
#define ISM_ALTERNATE_DIRECTORY_SERVER "ISM Alternate Directory Server"
#define ISM_THREAD_PRIORITY     "ISM thread priority"

#define KCC_UPDATE_TOPL_DELAY       "Repl topology update delay (secs)"
#define KCC_UPDATE_TOPL_PERIOD      "Repl topology update period (secs)"
#define KCC_RUN_AS_NTDSDSA_DN       "KCC run as ntdsDsa DN"     // debug only
#define KCC_SITEGEN_FAILOVER        "KCC site generator fail-over (minutes)"
#define KCC_SITEGEN_RENEW           "KCC site generator renewal interval (minutes)"
#define KCC_CRIT_FAILOVER_TRIES     "CriticalLinkFailuresAllowed"
#define KCC_CRIT_FAILOVER_TIME      "MaxFailureTimeForCriticalLink (sec)"
#define KCC_NONCRIT_FAILOVER_TRIES  "NonCriticalLinkFailuresAllowed"
#define KCC_NONCRIT_FAILOVER_TIME   "MaxFailureTimeForNonCriticalLink (sec)"
#define KCC_INTERSITE_FAILOVER_TRIES "IntersiteFailuresAllowed"
#define KCC_INTERSITE_FAILOVER_TIME "MaxFailureTimeForIntersiteLink (sec)"
#define KCC_ALLOW_MBR_BETWEEN_DCS_OF_SAME_DOMAIN \
                                    "Allow asynchronous replication of writeable domain NCs"
#define KCC_THREAD_PRIORITY         "KCC thread priority"
#define KCC_CONNECTION_PROBATION_TIME "Connection Probation Time (sec)"
#define KCC_CONNECTION_FAILURE_KEY  "KCC connection failures"   // debug only
#define KCC_LINK_FAILURE_KEY        "KCC link failures"         // debug only
#define GC_DELAY_ADVERTISEMENT      "Global Catalog Delay Advertisement (sec)"
#define DRA_PERFORM_INIT_SYNCS      "Repl Perform Initial Synchronizations"
#define GC_OCCUPANCY                "Global Catalog Partition Occupancy"
#define GC_PROMOTION_COMPLETE       "Global Catalog Promotion Complete"
#define DRA_SPN_FALLBACK            "Replicator Allow SPN Fallback"
#define LINKED_VALUE_REPLICATION_KEY "Linked Value Replication"

#define GPO_DOMAIN_FILE_PATH    "GPODomainFilePath"
#define GPO_DOMAIN_LINK         "GPODomainLink"
#define GPO_DC_FILE_PATH        "GPODCFilePath"
#define GPO_DC_LINK             "GPODCLink"
#define GPO_USER_NAME           "GPOUserName"

#define DEBUG_SYSTEMS           "Debug Systems"
#define DEBUG_SEVERITY          "Severity"
#define DEBUG_LOGGING           "Debug Logging"

// No GC logon keys
#define GCLESS_SITE_STICKINESS   "Cached Membership Site Stickiness (minutes)"
#define GCLESS_STALENESS         "Cached Membership Staleness (minutes)"
#define GCLESS_REFRESH_INTERVAL  "Cached Membership Refresh Interval (minutes)"
#define GCLESS_REFRESH_LIMIT     "Cached Membership Refresh Limit"


/* Event Category Keys */

#define KCC_KEY                     "1 Knowledge Consistency Checker"
#define SECURITY_KEY                "2 Security Events"
#define XDS_INTERFACE_KEY           "3 ExDS Interface Events"
#define MAPI_KEY                    "4 MAPI Interface Events"
#define REPLICATION_KEY             "5 Replication Events"
#define GARBAGE_COLLECTION_KEY      "6 Garbage Collection"
#define INTERNAL_CONFIGURATION_KEY  "7 Internal Configuration"
#define DIRECTORY_ACCESS_KEY        "8 Directory Access"
#define INTERNAL_PROCESSING_KEY     "9 Internal Processing"
#define PERFORMANCE_KEY             "10 Performance Counters"
#define STARTUP_SHUTDOWN_KEY        "11 Initialization/Termination"
#define SERVICE_CONTROL_KEY         "12 Service Control"
#define NAME_RESOLUTION_KEY         "13 Name Resolution"
#define BACKUP_KEY                  "14 Backup"
#define FIELD_ENGINEERING_KEY       "15 Field Engineering"
#define LDAP_INTERFACE_KEY          "16 LDAP Interface Events"
#define SETUP_KEY                   "17 Setup"
#define GC_KEY                      "18 Global Catalog"
#define ISM_KEY                     "19 Inter-site Messaging"
#define GROUP_CACHING_KEY           "20 Group Caching"
#define LVR_KEY                     "21 Linked-Value Replication"
#define DS_RPC_CLIENT_KEY           "22 DS RPC Client"
#define DS_RPC_SERVER_KEY           "23 DS RPC Server"
#define DS_SCHEMA_KEY               "24 DS Schema"
#define PRIVACYON_KEY               "Obscure wire data format"

#define LOGGING_OVERRIDE_KEY        "Logging Override"

/* Values for the keys, and defaults */

#define DSA_MESSAGE_DLL "ntdsmsg.dll"         // messages DLL
#define ESE_MESSAGE_DLL "esent.dll"
#define DSA_PERF_DLL    "ntdsperf.dll"
#define INVALID_REPL_NOTIFY_VALUE   -1 // This is a invalid value for the notification delays.
#define DEFAULT_DRA_START_PAUSE 300     // Pause before notifying after modify, seconds
#define DEFAULT_DRA_INTERDSA_PAUSE 30           // Pause between notifying DSAs, seconds
#define DEFAULT_GARB_COLLECT_PERIOD 12      // Pause between collections, hours
#define DEFAULT_HIERARCHY_PERIOD 720        // Pause between hierarchy recalcs, minutes
#define DEFAULT_TOMBSTONE_LIFETIME 60          // Tombstone lifetime, days
#define DRA_CONFLICT_LT_MIN 1                   // Minimum, 1 day
#define DRA_TOMBSTONE_LIFE_MIN 2                // Minimum 2 days
#define DEFAULT_SERVER_THREADS  15
#define DEFAULT_DRA_AOQ_LIMIT   10
#define DEFAULT_STAY_OF_EXECUTION 14          // Stay of execution, days
            // DRA_TOMBSTONE_LIFE_MIN/2 <= DEFAULT_STAY_OF_EXECUTION <= tombstone-lifetime/2
#define DEFAULT_DRA_CTX_LIFETIME_INTRA          (0)         // never expire
#define DEFAULT_DRA_CTX_LIFETIME_INTER          (5 * 60)
#define DEFAULT_DRA_CTX_EXPIRY_CHK_INTERVAL     (3 * 60)
#define DEFAULT_DRA_THREAD_OP_PRI_THRESHOLD     (AOPRI_ASYNC_SYNCHRONIZE_INTER_DOMAIN_READONLY_NEWSOURCE_PREEMPTED)
#define DEFAULT_DRSRPC_BIND_TIMEOUT             (10)      // bind & unbind
#define DEFAULT_DRSRPC_REPLICATION_TIMEOUT      (45)      // legacy replication traffic
#define DEFAULT_DRSRPC_GCLOOKUP_TIMEOUT         (5 )      // simple lookup calls
#define DEFAULT_DRSRPC_MOVEOBJECT_TIMEOUT       (30)      // might be cross-site
#define DEFAULT_DRSRPC_NT4CHANGELOG_TIMEOUT     (15)      // always within site
#define DEFAULT_DRSRPC_OBJECTEXISTENCE_TIMEOUT  (45)   // potential very expensive
#define DEFAULT_DRSRPC_GETREPLINFO_TIMEOUT      (5)       // simple calls?
#define DEFAULT_GC_DELAY_ADVERTISEMENT          (0xffffffffUL)   // Forever in seconds
#define DEFAULT_DRA_MAX_WAIT_SLOW_REPL_WARN     (5) // in mins
#define DEFAULT_DRA_THREAD_PRI_HIGH             (THREAD_PRIORITY_NORMAL)
#define DRA_THREAD_PRI_HIGH_MIN                 (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_HIGH_MAX                 (THREAD_PRIORITY_HIGHEST)
#define DEFAULT_DRA_THREAD_PRI_LOW              (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_LOW_MIN                  (THREAD_PRIORITY_BELOW_NORMAL)
#define DRA_THREAD_PRI_LOW_MAX                  (THREAD_PRIORITY_HIGHEST)
#define DRA_MAX_GETCHGREQ_OBJS_MIN              (100)
#define DRA_MAX_GETCHGREQ_BYTES_MIN             (1024*1024)
#define DEFAULT_DRA_REPL_QUEUE_CHECK_TIME       (60*12) //12 hours in minutes
#define DEFAULT_DRA_REPL_LATENCY_CHECK_INTERVAL (1) //1 day
#define DEFAULT_DRA_REPL_COMPRESSION_LEVEL      9
#define DEFAULT_THREAD_STATE_HEAP_LIMIT         (100L * 1024L * 1024L)

// What priority does the ISM thread run at? The thread priorities
// are values in the range (-2,..,2), but the registry can only store DWORDs, so
// we bias the stored priority values with ISM_THREAD_PRIORITY_BIAS.
#define ISM_DEFAULT_THREAD_PRIORITY 2
#define ISM_MIN_THREAD_PRIORITY     0
#define ISM_MAX_THREAD_PRIORITY     4
#define ISM_THREAD_PRIORITY_BIAS    2

// Delete expired dynamic objects (entryTTL == 0) every 900 secs
// or at the next expiration time plus 30 secs, whichever is less.
#define DEFAULT_DELETE_EXPIRED_ENTRYTTL_SECS        (900)
#define DEFAULT_DELETE_NEXT_EXPIRED_ENTRYTTL_SECS   (30)

// the schema fsmo cannot be transferred for a few seconds after
// it has been transfered or after a schema change (excluding
// replicated or system changes). This gives the schema admin a
// chance to change the schema before having the fsmo pulled away
// by a competing schema admin who also wants to make schema
// changes.
#define DEFAULT_SCHEMA_FSMO_LEASE_SECS          (60)
#define DEFAULT_SCHEMA_FSMO_LEASE_MAX_SECS      (900)

// Performance advisor timeouts
// Define more generous timeouts for the checked build
#if DBG
#define DEFAULT_DRA_MAX_WAIT_FOR_SDP_LOCK   (90 * 1000)  // 90 sec in ms
#define DEFAULT_DRA_MAX_WAIT_MAIL_SEND_MSG  (2 * 60 * 1000) // 2 min in ms
#else
#define DEFAULT_DRA_MAX_WAIT_FOR_SDP_LOCK   (30 * 1000)  // 30 sec in ms
#define DEFAULT_DRA_MAX_WAIT_MAIL_SEND_MSG  (60 * 1000) // 1 min in ms
#endif

#define DEFAULT_DB_EXPENSIVE_SEARCH_THRESHOLD   10000   // evaluated entries >= x
#define DEFAULT_DB_INEFFICIENT_SEARCH_THRESHOLD 1000    // returned entries <= 10% of x visited entries
#define DEFAULT_DB_INTERSECT_THRESHOLD          20
#define DEFAULT_DB_INTERSECT_RATIO              1000

//
// LDAP limits
//

#define DEFAULT_LDAP_SIZE_LIMIT                             1000
#define DEFAULT_LDAP_CONNECTIONS_LIMIT                      1000
#define DEFAULT_LDAP_TIME_LIMIT                             120
#define DEFAULT_LDAP_NOTIFICATIONS_PER_CONNECTION_LIMIT     5
#define DEFAULT_LDAP_INIT_RECV_TIMEOUT                      120
#define DEFAULT_LDAP_ALLOW_DEEP_SEARCH                      FALSE
#define DEFAULT_LDAP_MAX_CONN_IDLE                          900
#define DEFAULT_LDAP_MAX_REPL_SIZE                          2000
#define DEFAULT_LDAP_MAX_TEMP_TABLE                         10000
#define DEFAULT_LDAP_MAX_RESULT_SET                         (256*1024)
#define DEFAULT_LDAP_MAX_DGRAM_RECV                         (4*1024)
#define DEFAULT_LDAP_MAX_RECEIVE_BUF                        (10*1024*1024)

//
// Service-wide settings
//
// Update schema.ini and sch14.ldf when altering these EntryTTL values
#define DEFAULT_DYNAMIC_OBJECT_DEFAULT_TTL                  86400
#define DEFAULT_DYNAMIC_OBJECT_MIN_TTL                      900

//
//
//
#define WEEK_IN_HOURS (7 * 24)

#define DAYS_IN_SECS (24*60*60)
#define HOURS_IN_SECS (60*60)
#define MINS_IN_SECS (60)
#define SECS_IN_SECS (1)
#define RECOVERY_ON             "ON"

/* Service defined service controll must be in range 128-255 */
#define DS_SERVICE_CONTROL_RECALC_HIERARCHY ((DWORD) 129)
#define DS_SERVICE_CONTROL_DO_GARBAGE_COLLECT   ((DWORD) 130)
#define DS_SERVICE_CONTROL_CANCEL_ASYNC     ((DWORD) 131)

/* Flag in ContainerInfo attribute meaning "Show-up-in-hierarchy-table"
 * Admin needs this.
 */
#define VISIBLE_IN_HIERARCHY_TABLE_MASK         0x80000000

//
//The limit of the number of standard servers that can be in
//an enterprise.
#define MAX_STANDARD_SERVERS        2


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\drsuapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drsuapi.h
//
//--------------------------------------------------------------------------

#ifndef _drsuapi_
#define _drsuapi_

/*
 * Historical Note: The I_DRSBlahBlahBlah naming convention was put in to
 * distinguish the top level replicators functions (DRS...) from their
 * IDL-friendly wrappers (I_DRS...), which took modified versions of many
 * data structures, because not all of the core data structures were
 * describable in IDL syntax, and to distinguish the server versions and
 * client versions of the API, which had to be embedded in the same module,
 * because the DS is both client and server for the replicator API.
 *
 *    DRSBlah     - The local DRS Blah function, took core structures
 *    IDL_DRSBlah - The server side stub for the RPC'ed Blah function,
 *                  which takes IDL structures, converts them to core,
 *                  and calls DRSBlah
 *    _IDL_DRSBlah - The client side stub for Blah, which takes IDL structures
 *    I_DRSBlah   - A wrapper around _IDL_DRSBlah which takes core structures
 *                  and takes a server name instead of an RPC handle.
 *
 * Please do not extend this confusing naming practice to functions other
 * than those described in the IDL interface itself.
 */

#include <mdglobal.h>         // THSTATE
#include <drs.h>              // DRS_MSG_*

typedef void * handle_t;

// Async RPC function call types.
typedef enum {
    DRS_CALL_NONE = 0,
    DRS_CALL_GET_CHANGES,
    DRS_CALL_MAX
} DRS_CALL_TYPE;

// Defined in drsuapi.c -- contents opaque here.
struct _DRS_CONTEXT_INFO;

typedef struct _DRS_ASYNC_RPC_ARGS {
    LPWSTR                      pszServerName;
    LPWSTR                      pszDomainName;
    union {
        struct {
            DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn;
            DWORD                         dwOutVersion;
            DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut;
            BYTE *                        pSchemaInfo;
        } GetChg;
    };
} DRS_ASYNC_RPC_ARGS;

// Async RPC state.
typedef struct _DRS_ASYNC_RPC_STATE {
    LIST_ENTRY                  ListEntry;
    DSTIME                      timeInitialized;
    RPC_ASYNC_STATE             RpcState;
    DWORD                       dwCallerTID;
    DRS_CALL_TYPE               CallType;
    DRS_ASYNC_RPC_ARGS          CallArgs;
    SESSION_KEY                 SessionKey;
    struct _DRS_CONTEXT_INFO *  pContextInfo;
    unsigned                    fIsCallInProgress : 1;
} DRS_ASYNC_RPC_STATE;

#ifndef NOPROCS

VOID
RpcCancelAll();

// Initialize/shutdown client binding handle cache for I_DRS* functions.
void DRSClientCacheInit(
    void
    );
void DRSClientCacheUninit(
    void
    );

// Get remote machine principal name.
DWORD
DRSMakeMutualAuthSpn(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszTargetServerName,
    IN  LPWSTR      pszTargetDomainName,    OPTIONAL
    OUT LPWSTR *    ppszSpn
    );

// Register DRS interface extensions to be advertised to server-side DSAs.
ULONG
DRSClientSetExtensions(
    IN  DRS_EXTENSIONS * pext   OPTIONAL
    );


//
// Function to set credentials; once set all I_DRS* calls use these credentials
// to set the credentials to NULL, pass in NULL for all values.
//
ULONG
DRSSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength   // number of characters NOT including terminating
                               // NULL
    );

void
DRSDestroyAsyncRpcState(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    );

BOOL
DRSIsRegisteredAsyncRpcState(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    );

#ifdef DRA
ULONG
_IDL_DRSBind(
    IN  handle_t            rpc_handle,
    IN  UUID *              puuidClientDsa,
    IN  DRS_EXTENSIONS *    pextClient,
    OUT DRS_EXTENSIONS **   ppextServer,
    OUT DRS_HANDLE *        phDrs
    );

ULONG
_IDL_DRSUnbind(
    IN OUT  DRS_HANDLE *    phDrs
    );
#endif /* DRA */

#ifdef DRA
ULONG
_IDL_DRSReplicaSync(
   DRS_HANDLE               hDrs,
   DWORD                    dwMsgVersion,
   DRS_MSG_REPSYNC *        pmsgSync
   );
#endif /* DRA */

ULONG
I_DRSReplicaSync(
    THSTATE *   pTHS,
    LPWSTR      pszDestinationDSA,
    DSNAME *    pNC,
    LPWSTR      pszSourceDSA,
    UUID *      puuidSourceDSA,
    ULONG       ulOptions
    );

#ifdef DRA
ULONG
_IDL_DRSGetNCChanges(
    RPC_ASYNC_STATE *       pAsyncState,
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_GETCHGREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_GETCHGREPLY *   pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetNCChanges(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      LPWSTR                        pszServerDnsDomainName,     OPTIONAL
    IN      DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT     DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOutV1,
    OUT     PBYTE                         pSchemaInfo,
    IN OUT  DRS_ASYNC_RPC_STATE *         pAsyncState                 OPTIONAL
    );

ULONG
I_DRSGetNCChangesComplete(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    );

#ifdef DRA
ULONG
_IDL_DRSUpdateRefs(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_UPDREFS *   pmsgUpdRefs
    );
#endif /* DRA */

//
// Wrapper version of this call which does not take the call completed arg
//

#define I_DRSUpdateRefs(   pTHS, pszDSA, pNC, pszRepsToDSA, puuidRepsToDSA, ulOptions ) \
I_DRSUpdateRefsEx( pTHS, pszDSA, pNC, pszRepsToDSA, puuidRepsToDSA, ulOptions, NULL )

ULONG
I_DRSUpdateRefsEx(
    THSTATE *   pTHS,
    LPWSTR      pszDSA,
    DSNAME *    pNC,
    LPWSTR      pszRepsToDSA,
    UUID *      puuidRepsToDSA,
    ULONG       ulOptions,
    PULONG      pfCallCompleted
    );

#ifdef DRA
ULONG
_IDL_DRSReplicaAdd(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPADD *    pmsgAdd
    );
#endif /* DRA */

//
// Wrapper function to provide access to old interface without the call
// completed flag
//
#define I_DRSReplicaAdd(   pTHS, pszServerName, pNCName, pSourceDsaDN, pTransportDN, pszSourceDsaAddress, pSyncSchedule, ulOptions ) \
        I_DRSReplicaAddEx( pTHS, pszServerName, pNCName, pSourceDsaDN, pTransportDN, pszSourceDsaAddress, pSyncSchedule, ulOptions, NULL )

ULONG
I_DRSReplicaAddEx(
    THSTATE *pTHS,
    LPWSTR szDestinationDSA,
    PDSNAME pNCName,
    PDSNAME pSourceDsaDN,
    PDSNAME pTransportDN,
    LPWSTR szSourceDSA,
    REPLTIMES *pSyncSchedule,
    ULONG ulOptions,
    PULONG pfCallCompleted
    );

#ifdef DRA
ULONG
_IDL_DRSReplicaDel(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPDEL *    pmsgDel
    );
#endif /* DRA */

ULONG
I_DRSReplicaDel(
    THSTATE *   pTHS,
    LPWSTR      szDestinationDSA,
    PDSNAME     pNCName,
    LPWSTR      szSourceDSA,
    ULONG       ulOptions
    );

#ifdef DRA
ULONG
_IDL_DRSVerifyNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSVerifyNames(
    THSTATE                 *pTHS,
    LPWSTR                  szDestinationDSA,
    LPWSTR                  pszDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut
    );


ULONG
I_DRSGetMemberships(
    THSTATE     *pTHS,
    LPWSTR      pszServerName,
    LPWSTR      pszServerDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      errCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory
    );

#ifdef DRA
ULONG
_IDL_DRSGetMemberships(
   DRS_HANDLE hDrs,
   DWORD dwInVersion,
   DRS_MSG_REVMEMB_REQ *pmsgIn,
   DWORD *pdwOutVersion,
   DRS_MSG_REVMEMB_REPLY *pmsgOut
   );
#endif


ULONG
I_DRSGetMemberships2(
    THSTATE                       *pTHS,
    LPWSTR                         pszServerName,
    LPWSTR                         pszServerDnsDomainName,
    DWORD                          dwMsgInVersion,
    DRS_MSG_GETMEMBERSHIPS2_REQ   *pmsgIn,
    DWORD                         *pdwMsgOutVersion,
    DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
    );

#ifdef DRA
ULONG
_IDL_DRSGetMemberships2(
   DRS_HANDLE hDrs,
   DWORD dwInVersion,
   DRS_MSG_GETMEMBERSHIPS2_REQ *pmsgIn,
   DWORD *pdwOutVersion,
   DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
   );
#endif


#ifdef DRA
ULONG
_IDL_DRSInterDomainMove(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    OUT DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSInterDomainMove(
    IN  THSTATE             *pTHS,
    IN  LPWSTR              pDestinationDSA,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    OUT DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    );

#ifdef DRA

ULONG
_IDL_DRSGetNT4ChangeLog(
   DRS_HANDLE          hDrs,
   DWORD               dwInVersion,
   DRS_MSG_NT4_CHGLOG_REQ *pmsgIn,
   DWORD*              pdwOutVersion,
   DRS_MSG_NT4_CHGLOG_REPLY *pmsgOut
   );

#endif

ULONG
I_DRSGetNT4ChangeLog(
    THSTATE *pTHS,
    LPWSTR  pszServerName,
    DWORD  dwFlags,
    ULONG   PreferredMaximumLength,
    PVOID   * ppRestart,
    PULONG  pcbRestart,
    PVOID   * ppLog,
    PULONG  pcbLog,
    NT4_REPLICATION_STATE * ReplicationState,
    NTSTATUS *ActualNtStatus
    );

#ifdef DRA
// Returns WIN32 errors, not DRAERR_*.
ULONG
_IDL_DRSCrackNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSCrackNames(
    THSTATE *               pTHS,
    LPWSTR                  szDestinationDSA,
    LPWSTR                  pszDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut
    );

#ifdef DRA
ULONG
_IDL_DRSAddEntry(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_ADDENTRYREQ    *pmsgIn,
    DWORD                  *pdwMsgOutVersion,
    DRS_MSG_ADDENTRYREPLY  *pmsgOut
);
#endif

struct _DRS_SecBufferDesc;

ULONG
I_DRSAddEntry(
    IN  THSTATE *                   pTHS,
    IN  LPWSTR                      pszServerName,
    IN  struct _DRS_SecBufferDesc * pClientCreds,   OPTIONAL
    IN  DRS_MSG_ADDENTRYREQ_V2 *    pReq,
    OUT DWORD *                     pdwReplyVer,
    OUT DRS_MSG_ADDENTRYREPLY *     pReply
    );

#ifdef DRA
ULONG
_IDL_DRSGetObjectExistence(
    IN  DRS_HANDLE           hDrs,
    IN  DWORD                dwInVersion,
    IN  DRS_MSG_EXISTREQ *   pmsgIn,
    OUT DWORD *              pdwOutVersion,
    OUT DRS_MSG_EXISTREPLY * pmsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetObjectExistence(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DRS_MSG_EXISTREQ *            pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_EXISTREPLY *          pmsgOut
    );

#ifdef DRA
ULONG
_IDL_DRSGetReplInfo(
    IN      DRS_HANDLE           hDrs,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    );
#endif /* DRA */

ULONG
I_DRSGetReplInfo(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pMsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pMsgOut
    );

ULONG
I_DRSIsExtSupported(
    THSTATE                *pTHS,
    LPWSTR                  pszServerName,
    ULONG                   Ext
    );


BOOL
I_DRSIsIntraSiteServer(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName
    );

#endif /* ifndef NOPROCS */
#endif /* ifndef _drsuapi_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsexcept.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsexcept.h
//
//--------------------------------------------------------------------------

//
// Exceptions raised by the Exchange Directory Service
//
// This is a validly formed exception
// 0xE = (binary 1110), where the first two bits are the severity
//
//     Sev - is the severity code
//
//         00 - Success
//         01 - Informational
//         10 - Warning
//         11 - Error
//
//    and the third bit is the Customer flag (1=an app, 0=the OS)
//
// The rest of the high word is the facility, and the low word
// is the code.  For now, I have stated that the DSA is facility 1,
// and the only exception code we have is 1.
//

#define DSA_EXCEPTION 		    0xE0010001
#define DRA_GEN_EXCEPTION   	0xE0010002
#define DSA_MEM_EXCEPTION	    0xE0010003
#define DSA_DB_EXCEPTION	    0xE0010004
#define DSA_BAD_ARG_EXCEPTION	0xE0010005
#define DSA_CRYPTO_EXCEPTION    0xE0010006

#define NUM_DSA_EXCEPT_ARGS     3

// exception generating / filtering / handling function prototypes


DWORD GetDraException (EXCEPTION_POINTERS* pExceptPtrs, ULONG *pret);

DWORD
GetExceptionData(EXCEPTION_POINTERS* pExceptPtrs,
                 DWORD *pdwException,
                 PVOID * pExceptionAddress,
                 ULONG *pulErrorCode,
                 ULONG *pdsid);

// Trap only replicated object string name collisions.
#define GetDraNameException( pExceptPtrs, pret )                              \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
      && ( DRAERR_NameCollision == *pret )                                    \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap only busy errors.
#define GetDraBusyException( pExceptPtrs, pret )                              \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
      && ( DRAERR_Busy == *pret )                                             \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap only replicated object record too big condition
#define GetDraRecTooBigException( pExceptPtrs, pret )                         \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
     && ( ERROR_DS_MAX_OBJ_SIZE_EXCEEDED == *pret )                           \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Trap one condition
#define GetDraAnyOneWin32Exception( pExceptPtrs, pret, code )                       \
(                                                                             \
    (    ( EXCEPTION_EXECUTE_HANDLER == GetDraException( pExceptPtrs, pret ) )\
     && ( (code) == *pret )                                                   \
    )                                                                         \
  ? EXCEPTION_EXECUTE_HANDLER                                                 \
  : EXCEPTION_CONTINUE_SEARCH                                                 \
)

// Exception macro


#define RaiseDsaException(dwException, ulErrorCode, ul2, \
                          usFileNo, nLine , ulSeverity)  \
        RaiseDsaExcept(dwException, ulErrorCode, ul2,   \
                       ((usFileNo << 16L) | nLine), ulSeverity)

void RaiseDsaExcept (DWORD dwException, ULONG ulErrorCode, ULONG_PTR ul2,
		     DWORD dwId , ULONG ulSeverity);

void DraExcept (ULONG ulErrorCode, ULONG_PTR ul2, DWORD dwId,
                        ULONG ulSeverity);

#define	DsaExcept(exception, p1, p2)	\
        RaiseDsaExcept(exception, p1, p2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT(ul1, ul2)      	\
    DraExcept (ul1, ul2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT_DSID(ul1, ul2, dsid) \
    DraExcept (ul1, ul2, dsid, DS_EVENT_SEV_MINIMAL)
#define DRA_EXCEPT_NOLOG(ul1, ul2)      	\
    DraExcept (ul1, ul2, ((FILENO << 16L) | __LINE__), DS_EVENT_SEV_NO_LOGGING)

/*
 * filter expression to handle most exception. Others (access violation, 
 * breakpoint) are not handled and result in a crash
 */
DWORD DoHandleMostExceptions(EXCEPTION_POINTERS* pExceptPtrs, DWORD dwException,
	ULONG ulInternalId);
#define HandleMostExceptions(code)	\
    DoHandleMostExceptions(GetExceptionInformation(), code, \
    (FILENO << 16L) + __LINE__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsjet.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsjet.h
//
//--------------------------------------------------------------------------

#include "esent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dstrguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dstrguid.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Contains the trace guid used by the DS

Author:

    26-Mar-1998  JohnsonA, JeePang

Revision History:

--*/

#ifndef _DSTRGUID_H
#define _DSTRGUID_H

#include <guiddef.h>

//
// This is the control Guid for the group of Guids traced below
//
DEFINE_GUID ( /* 1c83b2fc-c04f-11d1-8afc-00c04fc21914 */
    DsControlGuid,
    0x1c83b2fc,
    0xc04f,
    0x11d1,
    0x8a, 0xfc, 0x00, 0xc0, 0x4f, 0xc2, 0x19, 0x14
  );

//
// Traceable Guids start here
//

DEFINE_GUID ( /* 05acd000-daeb-11d1-be80-00c04fadfff5 */
    DsDirSearchGuid,
    0x05acd000,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd001-daeb-11d1-be80-00c04fadfff5 */
    DsDirAddEntryGuid,
    0x05acd001,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd002-daeb-11d1-be80-00c04fadfff5 */
    DsDirModEntryGuid,
    0x05acd002,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd003-daeb-11d1-be80-00c04fadfff5 */
    DsDirDelEntryGuid,
    0x05acd003,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd004-daeb-11d1-be80-00c04fadfff5 */
    DsDirCompareGuid,
    0x05acd004,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd005-daeb-11d1-be80-00c04fadfff5 */
    DsDirModDNGuid,
    0x05acd005,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd006-daeb-11d1-be80-00c04fadfff5 */
    DsDirGetNcChangesGuid,
    0x05acd006,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsDirReplicaSyncGuid,
    0x05acd007,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsDirFind,
    0x05acd008,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* 05acd007-daeb-11d1-be80-00c04fadfff5 */
    DsLdapBind,
    0x05acd009,
    0xdaeb,
    0x11d1,
    0xbe, 0x80, 0x00, 0xc0, 0x4f, 0xad, 0xff, 0xf5
  );

DEFINE_GUID ( /* b9d4702a-6a98-11d2-b710-00c04fb998a2 */
    DsLdapRequestGuid,
    0xb9d4702a,
    0x6a98,
    0x11d2,
    0xb7, 0x10, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
);

DEFINE_GUID ( /* 14f8aa22-7f4b-11d2-b389-0000f87a46c8 */
    DsKccTaskGuid,
    0x14f8aa22,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa23-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaSyncGuid,
    0x14f8aa23,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa24-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaGetChgGuid,
    0x14f8aa24,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa25-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsUpdateRefsGuid,
    0x14f8aa25,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa26-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaAddGuid,
    0x14f8aa26,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa27-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaModifyGuid,
    0x14f8aa27,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa28-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsReplicaDelGuid,
    0x14f8aa28,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa29-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsVerifyNamesGuid,
    0x14f8aa29,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2a-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsInterDomainMoveGuid,
    0x14f8aa2a,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2b-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsAddEntryGuid,
    0x14f8aa2b,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2c-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsExecuteKccGuid,
    0x14f8aa2c,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2d-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetReplInfoGuid,
    0x14f8aa2d,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2e-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetNT4ChgLogGuid,
    0x14f8aa2e,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa2f-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsCrackNamesGuid,
    0x14f8aa2f,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa30-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsWriteSPNGuid,
    0x14f8aa30,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa31-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsDCInfoGuid,
    0x14f8aa31,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );

DEFINE_GUID ( /* 14f8aa32-7f4b-11d2-b389-0000f87a46c8 */
    DsDrsGetMembershipsGuid,
    0x14f8aa32,
    0x7f4b,
    0x11d2,
    0xb3, 0x89, 0x00, 0x00, 0xf8, 0x7a, 0x46, 0xc8
  );


DEFINE_GUID ( /* f5075994-b9e2-4e51-88f1-e5c43a3cfd9a */
    DsDrsGetMembershipsGuid2,
    0xf5075994,
    0xb9e2,
    0x4e51,
    0x88, 0xf1, 0xe5, 0xc4, 0x3a, 0x3c, 0xfd, 0x9a
  );


DEFINE_GUID( /* D01B04CF-240E-11d3-ACBE-00C04F68A51D */
    DsNspiUpdateStatGuid, 
    0xd01b04cf, 
    0x240e, 
    0x11d3, 
    0xac, 0xbe, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d
  );



DEFINE_GUID( // {4D63B05C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiCompareDNTsGuid, 
    0x4d63b05c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {61569D69-2502-11d3-ACC1-00C04F68A51D}
    DsNspiQueryRowsGuid, 
    0x61569d69, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiSeekEntriesGuid, 
    0x6f370d3c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3D-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetMatchesGuid, 
    0x6f370d3d, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {6F370D3E-2502-11d3-ACC1-00C04F68A51D}
    DsNspiResolveNamesGuid, 
    0x6f370d3e, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189A-2502-11d3-ACC1-00C04F68A51D}
    DsNspiDNToEphGuid, 
    0x7842189a, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189B-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetHierarchyInfoGuid, 
    0x7842189b, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {7842189C-2502-11d3-ACC1-00C04F68A51D}
    DsNspiResortRestrictionGuid, 
    0x7842189c, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {80AD666A-2502-11d3-ACC1-00C04F68A51D}
    DsNspiBindGuid, 
    0x80ad666a, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {873BDDEA-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetNamesFromIDsGuid, 
    0x873bddea, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {873BDDEB-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetIDsFromNamesGuid, 
    0x873bddeb, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5846-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetPropListGuid, 
    0x8d8c5846, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5847-2502-11d3-ACC1-00C04F68A51D}
    DsNspiQueryColumnsGuid, 
    0x8d8c5847, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {8D8C5848-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetPropsGuid, 
    0x8d8c5848, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {96EF9AA6-2502-11d3-ACC1-00C04F68A51D}
    DsNspiGetTemplateInfoGuid, 
    0x96ef9aa6, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {96EF9AA7-2502-11d3-ACC1-00C04F68A51D}
    DsNspiModPropsGuid, 
    0x96ef9aa7, 0x2502, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {380D48A4-2506-11d3-ACC1-00C04F68A51D}
    DsNspiModLinkAttGuid, 
    0x380d48a4, 0x2506, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);


DEFINE_GUID( // {380D48A5-2506-11d3-ACC1-00C04F68A51D}
    DsNspiDeleteEntriesGuid, 
    0x380d48a5, 0x2506, 0x11d3, 0xac, 0xc1, 0x0, 0xc0, 0x4f, 0x68, 0xa5, 0x1d);

DEFINE_GUID( // {E357DC53-B6FC-48e0-8189-C9D2AB2A8F16}
    DsTaskQueueExecuteGuid, 
    0xe357dc53, 0xb6fc, 0x48e0, 0x81, 0x89, 0xc9, 0xd2, 0xab, 0x2a, 0x8f, 0x16);

// ------------------------- Add your new GUIDs here ---------------------------
//
// Don't forget to include them into the array of registered trace GUIDs.
// See DsTraceGuids[] in dstrace.c. Also, include an enum value for your GUID
// into the enum below. It is EXTREMELY IMPORTANT to have the enums in
// EXACTLY the same order as guids appearing in the DsTraceGuids array in
// dstrace.c. This is because the enum is used as an XLAT index: index of
// GUID to the GUID itself (see DoLogEventAndTrace in dsevent.c)

typedef enum _DSTRACE_GUIDS {

    DsGuidSearch,
    DsGuidAdd,
    DsGuidModify,
    DsGuidModDN,
    DsGuidDelete,
    DsGuidCompare,
    DsGuidGetNcChanges,
    DsGuidReplicaSync,
    DsGuidFind,
    DsGuidLdapBind,
    DsGuidLdapRequest,
    DsGuidKccTask,
    DsGuidDrsReplicaSync,
    DsGuidDrsReplicaGetChg,
    DsGuidDrsUpdateRefs,
    DsGuidDrsReplicaAdd,
    DsGuidDrsReplicaModify,
    DsGuidDrsReplicaDel,
    DsGuidDrsVerifyNames,
    DsGuidDrsInterDomainMove,
    DsGuidDrsAddEntry,
    DsGuidDrsExecuteKcc,
    DsGuidDrsGetReplInfo,
    DsGuidDrsGetNT4ChgLog,
    DsGuidDrsCrackNames,
    DsGuidDrsWriteSPN,
    DsGuidDrsDCInfo,
    DsGuidDrsGetMemberships,
    DsGuidDrsGetMemberships2,
    DsGuidNspiUpdateStat,
    DsGuidNspiCompareDNTs,
    DsGuidNspiQueryRows,
    DsGuidNspiSeekEntries,
    DsGuidNspiGetMatches,
    DsGuidNspiResolveNames,
    DsGuidNspiDNToEph,
    DsGuidNspiGetHierarchyInfo,
    DsGuidNspiResortRestriction,
    DsGuidNspiBind,
    DsGuidNspiGetNamesFromIDs,
    DsGuidNspiGetIDsFromNames,
    DsGuidNspiGetPropList,
    DsGuidNspiQueryColumns,
    DsGuidNspiGetProps,
    DsGuidNspiGetTemplateInfo,
    DsGuidNspiModProps,
    DsGuidNspiModLinkAtt,
    DsGuidNspiDeleteEntries,
    DsGuidTaskQueueExecute
} DSTRACE_GUID;

#endif /* _DSTRGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dstrace.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dstrace.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Include file to contain variables required for event tracing of DS

Author:

    26-Mar-1998  JohnsonA, JeePang

Revision History:

--*/

#ifndef _DSTRACE_H
#define _DSTRACE_H

#include <wmistr.h>
#include <evntrace.h>
#include "dstrguid.h"

extern TRACEHANDLE      DsTraceRegistrationHandle;
extern TRACEHANDLE      DsTraceLoggerHandle;
extern PCHAR            DsCallerType[];
extern PCHAR            DsSearchType[];

#define DS_TRACE_VERSION            2

PCHAR
GetCallerTypeString(
    IN THSTATE *pTHS
    );

#define SEARCHTYPE_STRING(i)   DsSearchType[i]

//
// Do the actual trace logs
//

VOID
DsTraceEvent(
    IN MessageId Event,
    IN DWORD    WmiEventType,
    IN DWORD    TraceGuid,
    IN PEVENT_TRACE_HEADER TraceHeader,
    IN DWORD    ClientID,
    IN PWCHAR    Arg1,
    IN PWCHAR    Arg2,
    IN PWCHAR    Arg3,
    IN PWCHAR    Arg4,
    IN PWCHAR    Arg5,
    IN PWCHAR    Arg6,
    IN PWCHAR    Arg7,
    IN PWCHAR    Arg8
    );

#endif /* _DSTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsevent.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       dsevent.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This is the main include file that handles the DS logging stuff.


    SHARING LOGGING INFRASTRUCTURE EX-MODULE, IN-PROCESS
    ====================================================
    [2000-02-15 JeffParh]

    It's relatively easy to share event logging code across DLL (or even EXE)
    boundaries within a single process to reduce code/data footprint and
    alleviate the need to have multiple threads waiting for changes in event
    logging levels:

    1. In the module you wish to export logging from, export the following
       functions:
            DoLogEvent
            DoLogEventAndTrace
            DoLogOverride
            DoLogUnhandledError
            DsGetEventConfig

    2. In the module(s) to which you wish to import logging, create the global
       variable DS_EVENT_CONFIG * gpDsEventConfig and assign it the value
       returned from DsGetEventConfig before any event logging macros are
       invoked.

    See ntdsa (supplier) and ntdskcc (consumer) for an example of exporting
    logging from a DLL, and ismserv (supplier) and ismip/ismsmtp (consumers)
    for an example of exporting logging from an EXE.

[Environment:]

    User Mode - Win32

--*/


#ifndef DSEVENT_H_
#define DSEVENT_H

#include <wmistr.h>
#include <evntrace.h>

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors fix this code.
//

#pragma warning(disable:4296)

#ifdef __cplusplus
extern "C" {
#endif

#define DS_EVENT_MAX_CATEGORIES     24L
#define ESE_EVENT_MAX_CATEGORIES    12L

/* Event categories */

#define DS_EVENT_CAT_KCC                                0
#define DS_EVENT_CAT_SECURITY                           1
#define DS_EVENT_CAT_XDS_INTERFACE                      2
#define DS_EVENT_CAT_MAPI                               3
#define DS_EVENT_CAT_REPLICATION                        4
#define DS_EVENT_CAT_GARBAGE_COLLECTION                 5
#define DS_EVENT_CAT_INTERNAL_CONFIGURATION             6
#define DS_EVENT_CAT_DIRECTORY_ACCESS                   7
#define DS_EVENT_CAT_INTERNAL_PROCESSING                8
#define DS_EVENT_CAT_PERFORMANCE_MONITOR                9   /* also in perfutil.c */
#define DS_EVENT_CAT_STARTUP_SHUTDOWN                   10
#define DS_EVENT_CAT_SERVICE_CONTROL                    11
#define DS_EVENT_CAT_NAME_RESOLUTION                    12
#define DS_EVENT_CAT_BACKUP                             13
#define DS_EVENT_CAT_FIELD_ENGINEERING                  14
#define DS_EVENT_CAT_LDAP_INTERFACE                     15
#define DS_EVENT_CAT_SETUP                              16
#define DS_EVENT_CAT_GLOBAL_CATALOG                     17
#define DS_EVENT_CAT_ISM                                18
#define DS_EVENT_CAT_GROUP_CACHING                      19
#define DS_EVENT_CAT_LVR                                20
#define DS_EVENT_CAT_RPC_CLIENT                         21
#define DS_EVENT_CAT_RPC_SERVER                         22
#define DS_EVENT_CAT_SCHEMA                             23

//
// BOGUS ALERT: You can change this value to anything invalid. Bugus category used to
// force logging to the system log if we fail eventlog initialization
//
#define DS_EVENT_CAT_NETEVENT                      8888888

/* Event severity constants */
#define DS_EVENT_SEV_ALWAYS                             0
#define DS_EVENT_SEV_MINIMAL                            1
#define DS_EVENT_SEV_BASIC                              2
#define DS_EVENT_SEV_EXTENSIVE                          3
#define DS_EVENT_SEV_VERBOSE                            4
#define DS_EVENT_SEV_INTERNAL                           5
#define DS_EVENT_SEV_NO_LOGGING                         128

// Event log name and event sources.  DO NOT CHANGE THESE as they are
// carefully chosen not to conflict with other apps' values.

#define pszNtdsEventLogName         "Directory Service"
#define pszNtdsSourceReplication    "NTDS Replication"
#define pszNtdsSourceDatabase       "NTDS Database"
#define pszNtdsSourceGeneral        "NTDS General"
#define pszNtdsSourceMapi           "NTDS MAPI"
#define pszNtdsSourceXds            "NTDS XDS"
#define pszNtdsSourceSecurity       "NTDS Security"
#define pszNtdsSourceSam            "NTDS SAM"
#define pszNtdsSourceLdap           "NTDS LDAP"
#define pszNtdsSourceSdprop         "NTDS SDPROP"
#define pszNtdsSourceKcc            "NTDS KCC"
#define pszNtdsSourceIsam           "NTDS ISAM"
#define pszNtdsSourceIsm            "NTDS Inter-site Messaging"
#define pszNtdsSourceSetup          "NTDS Setup"
#define pszNtdsSourceRpcClient      "NTDS RPC Client"
#define pszNtdsSourceRpcServer      "NTDS RPC Server"
#define pszNtdsSourceSchema         "NTDS Schema"


typedef struct DS_EVENT_CATEGORY
    {
    MessageId   midCategory;
    ULONG       ulLevel;
    char        *szRegistryKey;
    } DSEventCategory;

typedef struct _DS_EVENT_CONFIG {
    BOOL            fTraceEvents;
    BOOL            fLogOverride;
    DSEventCategory rgEventCategories[DS_EVENT_MAX_CATEGORIES];
} DS_EVENT_CONFIG;

extern DS_EVENT_CONFIG * gpDsEventConfig;

extern HANDLE hServDoneEvent;

typedef struct EventSourceMapping {
    DWORD       dirNo;
    CHAR        *pszEventSource;
} EventSourceMapping;

extern EventSourceMapping   rEventSourceMappings[];
extern DWORD                cEventSourceMappings;
extern DWORD                iDefaultEventSource;

#ifndef CP_TELETEX
#define CP_TELETEX  20261
#endif


/* Macros for alerting and logging */

#if DBG
#define LogEventWouldLogFileNo( cat, sev, fileno ) \
    ((NULL == gpDsEventConfig) \
     ? (DoAssert("Event logging not initialized, can't log event!", \
                 __FILE__, __LINE__), \
        FALSE) \
     : ((((LONG) (sev)) <= (LONG)gpDsEventConfig->rgEventCategories[cat].ulLevel) \
        || (gpDsEventConfig->fLogOverride \
            && DoLogOverride((fileno),((ULONG)(sev))))))
#else
#define LogEventWouldLogFileNo( cat, sev, fileno ) \
    ((NULL != gpDsEventConfig) \
     && ((((LONG) (sev)) <= (LONG)gpDsEventConfig->rgEventCategories[cat].ulLevel) \
         || (gpDsEventConfig->fLogOverride \
             && DoLogOverride((fileno),((ULONG)(sev))))))
#endif

#define LogEventWouldLog(cat, sev) LogEventWouldLogFileNo(cat, sev, FILENO)

#define AlertEvent(cat, sev, msg, arg1, arg2, arg3)  {              \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        LOG_PARAM_BLOCK logBlock;                                      \
        logBlock.nInsert = 0;                                      \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                   \
        logBlock.mid = msg;                                        \
        logBlock.traceFlag = 0;                                    \
        logBlock.fLog = FALSE;                     \
        (arg1); (arg2); (arg3);                     \
        logBlock.pData = NULL;                     \
        logBlock.cData = 0;                        \
        logBlock.fIncludeName = TRUE;              \
        logBlock.fAlert = TRUE;                    \
        logBlock.fileNo = FILENO;                  \
        logBlock.TraceHeader = NULL;               \
        logBlock.ClientID = 0;                     \
        DoLogEventAndTrace(&logBlock);              \
    } \
}


#define LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6,   \
                          arg7, arg8, cbData, pvData)  {                       \
    if (LogEventWouldLog((cat), (sev))) { \
        LOG_PARAM_BLOCK logBlock;                                         \
        logBlock.nInsert = 0;                                                 \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;               \
        logBlock.severity = sev;                                              \
        logBlock.mid = msg;                                                   \
        logBlock.traceFlag = 0;                                               \
        logBlock.fLog = TRUE;                                                 \
        (arg1); (arg2); (arg3); (arg4); (arg5); (arg6); (arg7); (arg8);        \
        logBlock.pData = pvData;                    \
        logBlock.cData = cbData;                    \
        logBlock.fIncludeName = TRUE;               \
        logBlock.fAlert = FALSE;                    \
        logBlock.fileNo = FILENO;                   \
        logBlock.TraceHeader = NULL;                \
        logBlock.ClientID = 0;                      \
        DoLogEventAndTrace(&logBlock);                \
    }                                                \
}

#define LogEventWithFileNo(cat, sev, msg, arg1, arg2, arg3, _FileNo) \
    LogEvent8WithFileNo(cat, sev, msg,  arg1, arg2, arg3, 0, 0, 0, 0, 0, _FileNo)

#define LogEvent8WithFileNo(cat, sev, msg,  arg1, arg2, arg3, arg4, arg5, arg6,   \
                            arg7, arg8, _FileNo ) {        \
    if (LogEventWouldLogFileNo((cat), (sev), (_FileNo))) { \
        LOG_PARAM_BLOCK logBlock;                                                 \
        logBlock.nInsert = 0;                                                 \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;               \
        logBlock.severity = sev;                                              \
        logBlock.mid = msg;                                                   \
        logBlock.traceFlag = 0;                                               \
        logBlock.fLog = TRUE;                                                 \
        (arg1); (arg2); (arg3); (arg4); (arg5); (arg6); (arg7); (arg8);       \
        logBlock.pData = NULL;                      \
        logBlock.cData = 0;                         \
        logBlock.fIncludeName = TRUE;               \
        logBlock.fAlert = FALSE;                    \
        logBlock.fileNo = (_FileNo);                \
        logBlock.TraceHeader = NULL;                \
        logBlock.ClientID = 0;                      \
        DoLogEventAndTrace(&logBlock);                \
    }                                                \
}

#define LogSystemEvent(msg, arg1, arg2, arg3) { \
    LOG_PARAM_BLOCK logBlock;                  \
    logBlock.nInsert = 0;                       \
    logBlock.category = 0;                      \
    logBlock.severity = DS_EVENT_SEV_ALWAYS;    \
    logBlock.mid = msg;                         \
    logBlock.traceFlag = 0;                     \
    logBlock.fLog = TRUE;                       \
    (arg1); (arg2); (arg3);                      \
    logBlock.pData = NULL;                      \
    logBlock.cData = 0;    ;                    \
    logBlock.fIncludeName = FALSE;              \
    logBlock.fAlert = FALSE;                    \
    logBlock.fileNo = DIRNO_NETEVENT;           \
    logBlock.TraceHeader = NULL;                \
    logBlock.ClientID = 0;                      \
    DoLogEventAndTrace(&logBlock);                \
}


typedef
VOID
(*TRACE_EVENT_FN)(
    IN MessageId Mid,
    IN DWORD    WmiEventType,
    IN DWORD    TraceGuid,
    IN PEVENT_TRACE_HEADER TraceHeader,
    IN DWORD    ClientID,
    IN PWCHAR    Arg1,
    IN PWCHAR    Arg2,
    IN PWCHAR    Arg3,
    IN PWCHAR    Arg4,
    IN PWCHAR    Arg5,
    IN PWCHAR    Arg6,
    IN PWCHAR    Arg7,
    IN PWCHAR    Arg8
    );


typedef struct _INSERT_PARAMS {

    DWORD   InsertType;
    PVOID   pInsert;
    DWORD   InsertLen;
    DWORD_PTR   tmpDword;

} INSERT_PARAMS, *PINSERT_PARAMS;


typedef struct _LOG_PARAM_BLOCK {

    DWORD       nInsert;
    MessageId   mid;
    MessageId   category;
    DWORD       severity;
    DWORD       event;
    DWORD       traceFlag;
    BOOL        fLog;
    BOOL        fIncludeName;
    BOOL        fAlert;
    DWORD       fileNo;
    DWORD       cData;
    PVOID       pData;
    DWORD       TraceGuid;
    PEVENT_TRACE_HEADER TraceHeader;
    DWORD               ClientID;

    TRACE_EVENT_FN  TraceEvent;
    INSERT_PARAMS   params[8];

} LOG_PARAM_BLOCK, *PLOG_PARAM_BLOCK;

enum {
    inSz,
    inWC,
    inWCCounted,
    inInt,
    inHex,
    inUL,
    inDN,
    inNT4SID,
    inUUID,
    inDsMsg,
    inWin32Msg,
    inUSN,
    inHex64,
    inJetErrMsg,
    inDbErrMsg,
    inThStateErrMsg
};

/* Macros for inserting parameters into messages */

#define szInsertSz(x)  (logBlock.params[logBlock.nInsert].InsertType = inSz,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertWC(x)  (logBlock.params[logBlock.nInsert].InsertType = inWC,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertWC2(x,len)  (logBlock.params[logBlock.nInsert].InsertType = inWCCounted,\
                            logBlock.params[logBlock.nInsert].InsertLen = (len),\
                            logBlock.params[logBlock.nInsert++].pInsert = (void *)(x) )

#define szInsertInt(x) (logBlock.params[logBlock.nInsert].InsertType = inInt, \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD)x,\
                        logBlock.params[logBlock.nInsert++].pInsert =         \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertHex(x) (logBlock.params[logBlock.nInsert].InsertType = inHex,   \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD)x,  \
                        logBlock.params[logBlock.nInsert++].pInsert =           \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#ifdef _WIN64
#define szInsertPtr(x) (logBlock.params[logBlock.nInsert].InsertType = inHex64,  \
                        logBlock.params[logBlock.nInsert].tmpDword = (DWORD_PTR)x, \
                        logBlock.params[logBlock.nInsert++].pInsert =           \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )
#else // _WIN64
#define szInsertPtr(x) szInsertHex(x)
#endif // _WIN64

#define szInsertUL(x)  (logBlock.params[logBlock.nInsert].InsertType = inUL,\
                        logBlock.params[logBlock.nInsert].tmpDword = x,     \
                        logBlock.params[logBlock.nInsert++].pInsert =       \
                            (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertUSN(x) (logBlock.params[logBlock.nInsert].InsertType = inUSN,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)&(x))

#define szInsertDN(x)  (logBlock.params[logBlock.nInsert].InsertType = inDN,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x))

#define szInsertMTX(x) szInsertSz((x) ? (PCHAR)(x)->mtx_name : "[]")

#define szInsertUUID(x) (logBlock.params[logBlock.nInsert].InsertType = inUUID,\
                        logBlock.params[logBlock.nInsert++].pInsert = (void *)(x))

#define szInsertDsMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inDsMsg, \
                          logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                          logBlock.params[logBlock.nInsert++].pInsert =       \
                              (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertWin32Msg(x) (logBlock.params[logBlock.nInsert].InsertType = inWin32Msg,\
                             logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                             logBlock.params[logBlock.nInsert++].pInsert =       \
                                 (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertJetErrMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inJetErrMsg,\
                           logBlock.params[logBlock.nInsert].tmpDword = (DWORD) (x), \
                           logBlock.params[logBlock.nInsert++].pInsert =       \
                                (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertDbErrMsg(x) (logBlock.params[logBlock.nInsert].InsertType = inDbErrMsg,\
                             logBlock.params[logBlock.nInsert].tmpDword = (x),   \
                             logBlock.params[logBlock.nInsert++].pInsert =       \
                                 (void *)&logBlock.params[logBlock.nInsert].tmpDword )

#define szInsertThStateErrMsg() (logBlock.params[logBlock.nInsert++].InsertType = inThStateErrMsg)

#define szInsertLdapErrMsg(x) szInsertWC(ldap_err2stringW(x))

#define szInsertAttrType(x,buf) szInsertSz(ConvertAttrTypeToStr((x),(buf)))

// If you use this, you must include dsutil.h first
#define szInsertDSTIME(x,buf) szInsertSz(DSTimeToDisplayString((x),(buf)))

DWORD
DsGetEventTraceFlag();

#define LogAndTraceEventWithHeader(_log, cat, sev, msg, _evt, _guid, _TraceHeader, _ClientID,                 \
                                   a1, a2, a3, a4, a5, a6, a7, a8)                    \
{                                                                                   \
    Assert(NULL != gpDsEventConfig); \
    if ((NULL != gpDsEventConfig) \
        && (gpDsEventConfig->fTraceEvents \
            || ((_log) && LogEventWouldLog((cat), (sev))))) { \
        LOG_PARAM_BLOCK logBlock;                                                   \
        logBlock.nInsert = 0;                                                       \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                                   \
        logBlock.mid = msg;                                                        \
        logBlock.event = _evt;                                                     \
        logBlock.traceFlag = gpDsEventConfig->fTraceEvents;                        \
        logBlock.TraceEvent = DsTraceEvent;                                        \
        logBlock.TraceGuid = (DWORD)_guid;                                         \
        logBlock.fLog = ((_log) && LogEventWouldLog((cat), (sev))); \
        (a1); (a2); (a3); (a4); (a5); (a6); (a7); (a8);                             \
        logBlock.pData = NULL;                                                     \
        logBlock.cData = 0;                                                        \
        logBlock.fIncludeName = TRUE;                                              \
        logBlock.fAlert = FALSE;                                                   \
        logBlock.fileNo = FILENO;                                                  \
        logBlock.TraceHeader = _TraceHeader;                                       \
        logBlock.ClientID = _ClientID;                                             \
        DoLogEventAndTrace(&logBlock);                                               \
    }                                                                               \
}

#define LogAndTraceEvent(_log, cat, sev, msg, _evt, _guid, a1, a2, a3, a4, a5, a6, a7, a8) \
    LogAndTraceEventWithHeader(_log, cat, sev, msg, _evt, _guid, NULL, 0, a1, a2, a3, a4, a5, a6, a7, a8)

VOID
DoLogEventAndTrace(PLOG_PARAM_BLOCK LogBlock);

BOOL
DoLogOverride(DWORD file, ULONG sev);

#define LogEvent8(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) \
    LogEvent8WithData(cat, sev, msg, arg1, arg2, arg3, arg4, arg5, \
                      arg6, arg7, arg8, 0, NULL)

#define LogEvent(cat, sev, msg, arg1, arg2, arg3)           \
    LogEvent8(cat, sev, msg, arg1, arg2, arg3, NULL, NULL, NULL, NULL, NULL)

#define LogAndAlertEvent(cat, sev, msg, arg1, arg2, arg3) {\
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        LOG_PARAM_BLOCK logBlock;                                      \
        logBlock.nInsert = 0;                                      \
        logBlock.category = gpDsEventConfig->rgEventCategories[cat].midCategory;    \
        logBlock.severity = sev;                                   \
        logBlock.mid = msg;                                        \
        logBlock.traceFlag = 0;                                    \
        logBlock.fLog = LogEventWouldLog((cat), (sev)); \
        (arg1); (arg2); (arg3);                     \
        logBlock.pData = NULL;                     \
        logBlock.cData = 0;                        \
        logBlock.fIncludeName = TRUE;              \
        logBlock.fAlert = TRUE;                    \
        logBlock.fileNo = FILENO;                  \
        logBlock.TraceHeader = NULL;               \
        logBlock.ClientID = 0;                     \
        DoLogEventAndTrace(&logBlock);              \
    } \
}

void __fastcall DoLogUnhandledError(unsigned long ulID, int iErr, int iIncludeName);

#define LogUnhandledError(err)                      \
    DoLogUnhandledError(((FILENO << 16) | __LINE__), (err), TRUE)

//  For errors where we can't obtain the users name.
#define LogUnhandledErrorAnonymous(err)                      \
    DoLogUnhandledError(((FILENO << 16) | __LINE__), (err), FALSE)

#define MemoryPanic(size) { \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        char szSize[12];                        \
        char szID[9];                           \
        _itoa(size, szSize, 16);                    \
        _ultoa((FILENO << 16) | __LINE__, szID, 16);            \
        DoLogEvent(                         \
            FILENO,                         \
            gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory, \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_MALLOC_FAILURE,                  \
            TRUE,                                   \
            szSize, szID, NULL, NULL, NULL, NULL,   \
                NULL, NULL, 0, NULL);               \
    } \
}

#define LogAndAlertUnhandledError(err) { \
    Assert(NULL != gpDsEventConfig); \
    if (NULL != gpDsEventConfig) { \
        char szErr[12];                             \
        char szHexErr[12];                          \
        char szID[9];                               \
        _itoa(err, szHexErr, 16);                   \
        _itoa(err, szErr, 10);                      \
        _ultoa((FILENO << 16) | __LINE__, szID, 16);\
        DoLogEvent(                                 \
            FILENO,                                 \
            gpDsEventConfig->rgEventCategories[DS_EVENT_CAT_INTERNAL_PROCESSING].midCategory, \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_INTERNAL_FAILURE,                \
            TRUE,                                   \
            szErr, szHexErr, szID, NULL, NULL, NULL, NULL, NULL, 0, NULL);   \
        AlertEvent(DS_EVENT_CAT_FIELD_ENGINEERING,  \
            DS_EVENT_SEV_ALWAYS,                    \
            DIRLOG_INTERNAL_FAILURE,                \
            szErr, szHexErr, szID );                \
    } \
}

PSID GetCurrentUserSid(void);
BOOL DoAlertEvent(MessageId midCategory, ULONG ulSeverity,
          MessageId midEvent, ... );
BOOL DoAlertEventW(MessageId midCategory, ULONG ulSeverity,
          MessageId midEvent, ... );
BOOL DoLogEvent(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
        MessageId midEvent, int iIncludeName,
        char *arg1, char *arg2, char *arg3, char *arg4,
        char *arg5, char *arg6, char *arg7, char *arg8,
        DWORD cbData, VOID * pvData);
BOOL DoLogEventW(DWORD fileNo, MessageId midCategory, ULONG ulSeverity,
        MessageId midEvent, int iIncludeName,
        WCHAR *arg1, WCHAR *arg2, WCHAR *arg3, WCHAR *arg4,
        WCHAR *arg5, WCHAR *arg6, WCHAR *arg7, WCHAR *arg8,
        DWORD cbData, VOID * pvData);

HANDLE LoadEventTable(void);
void UnloadEventTable(void);


typedef void (__cdecl *LoadParametersCallbackFn)(void)  ;
void SetLoadParametersCallback (LoadParametersCallbackFn pFn);

HANDLE LoadParametersTable(void);
void UnloadParametersTable(void);


DWORD
ImpersonateAnyClient(void);

VOID
UnImpersonateAnyClient(void);

PCHAR
ConvertAttrTypeToStr(
    IN ATTRTYP AttributeType,
    IN OUT PCHAR OutBuffer
    );

ULONG
AuthenticateSecBufferDesc(VOID *pv);

DS_EVENT_CONFIG *
DsGetEventConfig(void);

DWORD
InitializeEventLogging();

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // DSEVENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dststlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dststlog.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file exports the ds test logger

Revision History:

--*/

#ifndef _DSTSTLOG_H_
#define _DSTSTLOG_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef
BOOL
(*DS_PRINTLOG)(
    IN DWORD Flags,
    IN LPSTR Format,
    ...
    );

#define DSLOG_FLAG_OPEN     0x00000001
#define DSLOG_FLAG_NOTIME   0x00000002
#define DSLOG_FLAG_TAG_CNPN 0x00000004  // add computername and process nametags

#define DEFINE_DSLOG        HINSTANCE hDsLog=NULL;DS_PRINTLOG pfnDsPrintLog=NULL;
#define DECLARE_DSLOG       extern HINSTANCE hDsLog;extern DS_PRINTLOG pfnDsPrintLog;

#if DBG
#define DSINITLOG() {    \
    hDsLog = LoadLibrary(TEXT("ntdsapi.dll"));     \
    if ( hDsLog != NULL ) {                         \
        pfnDsPrintLog=(DS_PRINTLOG)GetProcAddress(hDsLog,"DsLogEntry");   \
    }     \
}

#define DSLOG(_x)       if (pfnDsPrintLog != NULL) {pfnDsPrintLog _x;}
#define DSLOG_ACTIVE    (pfnDsPrintLog != NULL)
#else
#define DSLOG(_x)
#define DSLOG_ACTIVE    FALSE
#define DSINITLOG()
#endif

extern HINSTANCE hDsLog;
extern DS_PRINTLOG pfnDsPrintLog;

#ifdef __cplusplus
}
#endif


#endif // _DSTSTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\filtypes.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       filtypes.h
//
//--------------------------------------------------------------------------

#define FI_CHOICE_EQUALITY        ((UCHAR) 0x00)
#define FI_CHOICE_SUBSTRING       ((UCHAR) 0x01)
#define FI_CHOICE_GREATER	  ((UCHAR) 0x02)
#define FI_CHOICE_GREATER_OR_EQ   ((UCHAR) 0x03)
#define FI_CHOICE_LESS            ((UCHAR) 0x04)
#define FI_CHOICE_LESS_OR_EQ      ((UCHAR) 0x05)
#define FI_CHOICE_NOT_EQUAL	  ((UCHAR) 0x06)
#define FI_CHOICE_PRESENT         ((UCHAR) 0x07)
#define FI_CHOICE_TRUE            ((UCHAR) 0x08)
#define FI_CHOICE_FALSE           ((UCHAR) 0x09)
#define FI_CHOICE_BIT_AND         ((UCHAR) 0x0A)
#define FI_CHOICE_BIT_OR          ((UCHAR) 0x0B)
#define FI_CHOICE_UNDEFINED       ((UCHAR) 0x0C)


// bitmap table of valid relational operators indexed by syntax
extern WORD  rgValidOperators[];

// macros for setting checking relational operator validity
#define RelOpMask(relop)		((WORD) (1 << (relop)))
#define FLegalOperator(syntax, relop)	(rgValidOperators[syntax] & RelOpMask(relop))

#define FILTER_CHOICE_ITEM    'I'
#define FILTER_CHOICE_AND     'A'
#define FILTER_CHOICE_OR      'O'
#define FILTER_CHOICE_NOT     'N'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\dsutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsutil.h
//
//  Contents:  Common Utility Routines
//
//  Functions:
//
//----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LARGE_INTEGER
atoli
(
    char* Num
);

char *
litoa
(
    LARGE_INTEGER value,
    char *string,
    int radix
);

#if 0
VOID
IntializeCommArg(
    IN OUT COMMARG *pCommArg
);

VOID
InitializeDsName(
    IN DSNAME *pDsName,
    IN WCHAR *NamePrefix,
    IN ULONG NamePrefixLen,
    IN WCHAR *Name,
    IN ULONG NameLength
);
#endif

void
FileTimeToDSTime(
    IN  FILETIME        filetime,
    OUT DSTIME *        pDstime
    );

void
DSTimeToFileTime(
    IN  DSTIME          dstime,
    OUT FILETIME *      pFiletime
    );

void
DSTimeToUtcSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    );

void
DSTimeToLocalSystemTime(
    IN  DSTIME          dstime,
    OUT SYSTEMTIME *    psystime
    );

#define SZDSTIME_LEN (20)
LPSTR
DSTimeToDisplayString(
    IN  DSTIME  dstime,
    OUT LPSTR   pszTime
    );

// This function formats a uuid in the official way www-xxx-yyy-zzz
LPSTR
DsUuidToStructuredString(
    UUID * pUuid,
    LPSTR pszUuidBuffer );

LPWSTR
DsUuidToStructuredStringW(
    UUID * pUuid,
    LPWSTR pszUuidBuffer );

// I_RpcGetExtendedError is not available on Win95/WinNt4 
// (at least not initially) so we make MAP_SECURITY_PACKAGE_ERROR
// a no-op for that platform.

#if !WIN95 && !WINNT4

DWORD
MapRpcExtendedHResultToWin32(
    HRESULT hrCode
    );

// Get extended security error from RPC; Handle HRESULT values
// I_RpcGetExtendedError can return 0 if the error occurred remotely.

#define MAP_SECURITY_PACKAGE_ERROR( status ) \
if ( ( status == RPC_S_SEC_PKG_ERROR ) ) { \
    DWORD secondary; \
    secondary = I_RpcGetExtendedError(); \
    if (secondary) { \
        if (IS_ERROR(secondary)) {\
            status = MapRpcExtendedHResultToWin32( secondary ); \
        } else { \
            status = secondary; \
        } \
    } \
}

#else

#define MAP_SECURITY_PACKAGE_ERROR( status )

#endif

DWORD
AdvanceTickTime(
    DWORD BaseTick,
    DWORD Delay
    );

DWORD
CalculateFutureTickTime(
    IN DWORD Delay
    );

DWORD
DifferenceTickTime(
    DWORD GreaterTick,
    DWORD LesserTick
    );

int
CompareTickTime(
    DWORD Tick1,
    DWORD Tick2
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\emsabtag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1986 - 1999
//
//  File:       emsabtag.h
//
//--------------------------------------------------------------------------

/*
** ---------------------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)
#define PR_EMS_AB_ALL_CHILDREN                PROP_TAG(PT_OBJECT,       0xFFF7)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF7

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/* 
 * Prop tags defined in the schema. 
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY             PROP_TAG(PT_LONG,         0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE         PROP_TAG(PT_BINARY,       0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE            PROP_TAG(PT_LONG,         0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG(PT_BINARY,       0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY, 0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX              PROP_TAG(PT_BINARY,       0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                PROP_TAG(PT_TSTRING,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A              PROP_TAG(PT_STRING8,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W              PROP_TAG(PT_UNICODE,      0x8048)
#define PR_EMS_AB_ADMD                        PROP_TAG(PT_TSTRING,      0x8049)
#define PR_EMS_AB_ADMD_A                      PROP_TAG(PT_STRING8,      0x8049)
#define PR_EMS_AB_ADMD_W                      PROP_TAG(PT_UNICODE,      0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION           PROP_TAG(PT_TSTRING,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A         PROP_TAG(PT_STRING8,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W         PROP_TAG(PT_UNICODE,      0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME          PROP_TAG(PT_TSTRING,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A        PROP_TAG(PT_STRING8,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W        PROP_TAG(PT_UNICODE,      0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL         PROP_TAG(PT_TSTRING,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A       PROP_TAG(PT_STRING8,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W       PROP_TAG(PT_UNICODE,      0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME         PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A       PROP_TAG(PT_STRING8,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W       PROP_TAG(PT_UNICODE,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O       PROP_TAG(PT_OBJECT,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T       PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALT_RECIPIENT               PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A             PROP_TAG(PT_STRING8,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W             PROP_TAG(PT_UNICODE,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O             PROP_TAG(PT_OBJECT,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T             PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL            PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A          PROP_TAG(PT_MV_STRING8,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W          PROP_TAG(PT_MV_UNICODE,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O          PROP_TAG(PT_OBJECT,       0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T          PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ANCESTOR_ID                 PROP_TAG(PT_BINARY,       0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT            PROP_TAG(PT_BINARY,       0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA            PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A          PROP_TAG(PT_MV_STRING8,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W          PROP_TAG(PT_MV_UNICODE,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O          PROP_TAG(PT_OBJECT,       0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T          PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME        PROP_TAG(PT_LONG,         0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL                PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A              PROP_TAG(PT_MV_STRING8,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W              PROP_TAG(PT_MV_UNICODE,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O              PROP_TAG(PT_OBJECT,       0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T              PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST   PROP_TAG(PT_MV_BINARY,    0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN           PROP_TAG(PT_TSTRING,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A         PROP_TAG(PT_STRING8,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W         PROP_TAG(PT_UNICODE,      0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD         PROP_TAG(PT_BINARY,       0x8055)
#define PR_EMS_AB_AUTHORIZED_USER             PROP_TAG(PT_TSTRING,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A           PROP_TAG(PT_STRING8,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W           PROP_TAG(PT_UNICODE,      0x8056)
#define PR_EMS_AB_AUTOREPLY                   PROP_TAG(PT_BOOLEAN,      0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE           PROP_TAG(PT_TSTRING,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A         PROP_TAG(PT_STRING8,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W         PROP_TAG(PT_UNICODE,      0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT           PROP_TAG(PT_TSTRING,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A         PROP_TAG(PT_STRING8,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W         PROP_TAG(PT_UNICODE,      0x803E)
#define PR_EMS_AB_BUSINESS_CATEGORY           PROP_TAG(PT_MV_TSTRING,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A         PROP_TAG(PT_MV_STRING8,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W         PROP_TAG(PT_MV_UNICODE,   0x8057)
#define PR_EMS_AB_BUSINESS_ROLES              PROP_TAG(PT_BINARY,       0x8023)
#define PR_EMS_AB_CA_CERTIFICATE              PROP_TAG(PT_MV_BINARY,    0x8003)
#define PR_EMS_AB_CAN_CREATE_PF               PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A             PROP_TAG(PT_MV_STRING8,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W             PROP_TAG(PT_MV_UNICODE,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O             PROP_TAG(PT_OBJECT,       0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T             PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL            PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A          PROP_TAG(PT_MV_STRING8,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W          PROP_TAG(PT_MV_UNICODE,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O          PROP_TAG(PT_OBJECT,       0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T          PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL            PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A          PROP_TAG(PT_MV_STRING8,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W          PROP_TAG(PT_MV_UNICODE,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O          PROP_TAG(PT_OBJECT,       0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T          PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL         PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A       PROP_TAG(PT_MV_STRING8,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W       PROP_TAG(PT_MV_UNICODE,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O       PROP_TAG(PT_OBJECT,       0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T       PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF           PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A         PROP_TAG(PT_MV_STRING8,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W         PROP_TAG(PT_MV_UNICODE,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O         PROP_TAG(PT_OBJECT,       0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T         PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL        PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A      PROP_TAG(PT_MV_STRING8,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W      PROP_TAG(PT_MV_UNICODE,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O      PROP_TAG(PT_OBJECT,       0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T      PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL        PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A      PROP_TAG(PT_MV_STRING8,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W      PROP_TAG(PT_MV_UNICODE,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O      PROP_TAG(PT_OBJECT,       0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T      PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL     PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A   PROP_TAG(PT_MV_STRING8,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W   PROP_TAG(PT_MV_UNICODE,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O   PROP_TAG(PT_OBJECT,       0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T   PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS            PROP_TAG(PT_BOOLEAN,      0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG(PT_BINARY,       0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET          PROP_TAG(PT_LONG,         0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR          PROP_TAG(PT_BOOLEAN,      0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET        PROP_TAG(PT_LONG,         0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR        PROP_TAG(PT_BOOLEAN,      0x8064)
#define PR_EMS_AB_COMPUTER_NAME               PROP_TAG(PT_TSTRING,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A             PROP_TAG(PT_STRING8,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W             PROP_TAG(PT_UNICODE,      0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS           PROP_TAG(PT_MV_TSTRING,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A         PROP_TAG(PT_MV_STRING8,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W         PROP_TAG(PT_MV_UNICODE,   0x8066)
#define PR_EMS_AB_CONTAINER_INFO              PROP_TAG(PT_LONG,         0x8067)
#define PR_EMS_AB_COST                        PROP_TAG(PT_LONG,         0x8068)
#define PR_EMS_AB_COUNTRY_NAME                PROP_TAG(PT_TSTRING,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A              PROP_TAG(PT_STRING8,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W              PROP_TAG(PT_UNICODE,      0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR      PROP_TAG(PT_MV_BINARY,    0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH           PROP_TAG(PT_LONG,         0x806A)
#define PR_EMS_AB_DELIV_EITS                  PROP_TAG(PT_MV_BINARY,    0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES        PROP_TAG(PT_MV_BINARY,    0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT        PROP_TAG(PT_BOOLEAN,      0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM          PROP_TAG(PT_LONG,         0x806E)
#define PR_EMS_AB_DESCRIPTION                 PROP_TAG(PT_MV_TSTRING,   0x806F)
#define PR_EMS_AB_DESCRIPTION_A               PROP_TAG(PT_MV_STRING8,   0x806F)
#define PR_EMS_AB_DESCRIPTION_W               PROP_TAG(PT_MV_UNICODE,   0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR       PROP_TAG(PT_MV_TSTRING,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A     PROP_TAG(PT_MV_STRING8,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W     PROP_TAG(PT_MV_UNICODE,   0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY          PROP_TAG(PT_TSTRING,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A        PROP_TAG(PT_STRING8,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W        PROP_TAG(PT_UNICODE,      0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE       PROP_TAG(PT_BOOLEAN,      0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE              PROP_TAG(PT_MV_BINARY,    0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP        PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A      PROP_TAG(PT_STRING8,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W      PROP_TAG(PT_UNICODE,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O      PROP_TAG(PT_OBJECT,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T      PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_NAME                 PROP_TAG(PT_TSTRING,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A               PROP_TAG(PT_STRING8,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W               PROP_TAG(PT_UNICODE,      0x8076)
#define PR_EMS_AB_DSA_SIGNATURE               PROP_TAG(PT_BINARY,       0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY              PROP_TAG(PT_BOOLEAN,      0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD           PROP_TAG(PT_BOOLEAN,      0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE            PROP_TAG(PT_LONG,         0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN            PROP_TAG(PT_BOOLEAN,      0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST     PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A   PROP_TAG(PT_MV_STRING8,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W   PROP_TAG(PT_MV_UNICODE,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O   PROP_TAG(PT_OBJECT,       0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T   PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME           PROP_TAG(PT_SYSTIME,      0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ                PROP_TAG(PT_TSTRING,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A              PROP_TAG(PT_STRING8,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W              PROP_TAG(PT_UNICODE,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN            PROP_TAG(PT_LONG,         0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS        PROP_TAG(PT_LONG,         0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8081)
#define PR_EMS_AB_DXA_FLAGS                   PROP_TAG(PT_LONG,         0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                 PROP_TAG(PT_TSTRING,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A               PROP_TAG(PT_STRING8,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W               PROP_TAG(PT_UNICODE,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN             PROP_TAG(PT_LONG,         0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP         PROP_TAG(PT_MV_TSTRING,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A       PROP_TAG(PT_MV_STRING8,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W       PROP_TAG(PT_MV_UNICODE,   0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN             PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A           PROP_TAG(PT_STRING8,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W           PROP_TAG(PT_UNICODE,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O           PROP_TAG(PT_OBJECT,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T           PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL           PROP_TAG(PT_LONG,         0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE     PROP_TAG(PT_TSTRING,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A   PROP_TAG(PT_STRING8,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W   PROP_TAG(PT_UNICODE,      0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP        PROP_TAG(PT_MV_TSTRING,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A      PROP_TAG(PT_MV_STRING8,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W      PROP_TAG(PT_MV_UNICODE,   0x808B)
#define PR_EMS_AB_DXA_PASSWORD                PROP_TAG(PT_TSTRING,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A              PROP_TAG(PT_STRING8,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W              PROP_TAG(PT_UNICODE,      0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS   PROP_TAG(PT_LONG,         0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG(PT_BOOLEAN,      0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG(PT_LONG,    0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES     PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A   PROP_TAG(PT_STRING8,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W   PROP_TAG(PT_UNICODE,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O   PROP_TAG(PT_OBJECT,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T   PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG(PT_LONG,    0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS   PROP_TAG(PT_LONG,         0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES              PROP_TAG(PT_LONG,         0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP            PROP_TAG(PT_TSTRING,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A          PROP_TAG(PT_STRING8,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W          PROP_TAG(PT_UNICODE,      0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT           PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A         PROP_TAG(PT_STRING8,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W         PROP_TAG(PT_UNICODE,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O         PROP_TAG(PT_OBJECT,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T         PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                 PROP_TAG(PT_TSTRING,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A               PROP_TAG(PT_STRING8,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W               PROP_TAG(PT_UNICODE,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN             PROP_TAG(PT_LONG,         0x8098)
#define PR_EMS_AB_DXA_REQNAME                 PROP_TAG(PT_TSTRING,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_A               PROP_TAG(PT_STRING8,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_W               PROP_TAG(PT_UNICODE,      0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                 PROP_TAG(PT_TSTRING,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A               PROP_TAG(PT_STRING8,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W               PROP_TAG(PT_UNICODE,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN             PROP_TAG(PT_LONG,         0x809C)
#define PR_EMS_AB_DXA_TASK                    PROP_TAG(PT_LONG,         0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS        PROP_TAG(PT_LONG,         0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP      PROP_TAG(PT_SYSTIME,      0x809F)
#define PR_EMS_AB_DXA_TYPES                   PROP_TAG(PT_LONG,         0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST   PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG(PT_MV_STRING8,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG(PT_MV_UNICODE,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG(PT_OBJECT,       0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_ENCAPSULATION_METHOD        PROP_TAG(PT_LONG,         0x80A2)
#define PR_EMS_AB_ENCRYPT                     PROP_TAG(PT_BOOLEAN,      0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA         PROP_TAG(PT_MV_TSTRING,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A       PROP_TAG(PT_MV_STRING8,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W       PROP_TAG(PT_MV_UNICODE,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER      PROP_TAG(PT_MV_TSTRING,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A    PROP_TAG(PT_MV_STRING8,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W    PROP_TAG(PT_MV_UNICODE,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA     PROP_TAG(PT_TSTRING,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A   PROP_TAG(PT_STRING8,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W   PROP_TAG(PT_UNICODE,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER  PROP_TAG(PT_TSTRING,      0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG(PT_STRING8,     0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG(PT_UNICODE,     0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY          PROP_TAG(PT_BOOLEAN,      0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME             PROP_TAG(PT_SYSTIME,      0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS           PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A         PROP_TAG(PT_MV_STRING8,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W         PROP_TAG(PT_MV_UNICODE,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O         PROP_TAG(PT_OBJECT,       0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T         PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS    PROP_TAG(PT_BOOLEAN,      0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED      PROP_TAG(PT_BOOLEAN,      0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1       PROP_TAG(PT_TSTRING,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A     PROP_TAG(PT_STRING8,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W     PROP_TAG(PT_UNICODE,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10      PROP_TAG(PT_TSTRING,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A    PROP_TAG(PT_STRING8,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W    PROP_TAG(PT_UNICODE,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2       PROP_TAG(PT_TSTRING,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A     PROP_TAG(PT_STRING8,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W     PROP_TAG(PT_UNICODE,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3       PROP_TAG(PT_TSTRING,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A     PROP_TAG(PT_STRING8,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W     PROP_TAG(PT_UNICODE,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4       PROP_TAG(PT_TSTRING,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A     PROP_TAG(PT_STRING8,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W     PROP_TAG(PT_UNICODE,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5       PROP_TAG(PT_TSTRING,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A     PROP_TAG(PT_STRING8,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W     PROP_TAG(PT_UNICODE,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6       PROP_TAG(PT_TSTRING,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A     PROP_TAG(PT_STRING8,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W     PROP_TAG(PT_UNICODE,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7       PROP_TAG(PT_TSTRING,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A     PROP_TAG(PT_STRING8,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W     PROP_TAG(PT_UNICODE,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8       PROP_TAG(PT_TSTRING,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A     PROP_TAG(PT_STRING8,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W     PROP_TAG(PT_UNICODE,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9       PROP_TAG(PT_TSTRING,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A     PROP_TAG(PT_STRING8,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W     PROP_TAG(PT_UNICODE,      0x8035)
#define PR_EMS_AB_EXTENSION_DATA              PROP_TAG(PT_MV_BINARY,    0x80A8)
#define PR_EMS_AB_EXTENSION_NAME              PROP_TAG(PT_MV_TSTRING,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A            PROP_TAG(PT_MV_STRING8,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W            PROP_TAG(PT_MV_UNICODE,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED    PROP_TAG(PT_MV_TSTRING,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A  PROP_TAG(PT_MV_STRING8,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W  PROP_TAG(PT_MV_UNICODE,   0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER  PROP_TAG(PT_MV_BINARY,    0x80AB)
#define PR_EMS_AB_FILE_VERSION                PROP_TAG(PT_BINARY,       0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES      PROP_TAG(PT_BOOLEAN,      0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME             PROP_TAG(PT_TSTRING,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A           PROP_TAG(PT_STRING8,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W           PROP_TAG(PT_UNICODE,      0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER           PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A         PROP_TAG(PT_STRING8,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W         PROP_TAG(PT_UNICODE,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O         PROP_TAG(PT_OBJECT,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T         PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD         PROP_TAG(PT_LONG,         0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED          PROP_TAG(PT_TSTRING,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A        PROP_TAG(PT_STRING8,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W        PROP_TAG(PT_UNICODE,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG         PROP_TAG(PT_TSTRING,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A       PROP_TAG(PT_STRING8,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W       PROP_TAG(PT_UNICODE,      0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY               PROP_TAG(PT_MV_TSTRING,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A             PROP_TAG(PT_MV_STRING8,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W             PROP_TAG(PT_MV_UNICODE,   0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE        PROP_TAG(PT_BINARY,       0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED         PROP_TAG(PT_SYSTIME,      0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS        PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A      PROP_TAG(PT_MV_STRING8,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W      PROP_TAG(PT_MV_UNICODE,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O      PROP_TAG(PT_OBJECT,       0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T      PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS              PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A            PROP_TAG(PT_MV_STRING8,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W            PROP_TAG(PT_MV_UNICODE,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O            PROP_TAG(PT_OBJECT,       0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T            PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HELP_DATA16                 PROP_TAG(PT_BINARY,       0x803A)
#define PR_EMS_AB_HELP_DATA32                 PROP_TAG(PT_BINARY,       0x8010)
#define PR_EMS_AB_HELP_FILE_NAME              PROP_TAG(PT_TSTRING,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A            PROP_TAG(PT_STRING8,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W            PROP_TAG(PT_UNICODE,      0x803B)
#define PR_EMS_AB_HEURISTICS                  PROP_TAG(PT_LONG,         0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP          PROP_TAG(PT_BOOLEAN,      0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK      PROP_TAG(PT_BOOLEAN,      0x80B9)
#define PR_EMS_AB_HOME_MDB                    PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_A                  PROP_TAG(PT_STRING8,      0x8006)
#define PR_EMS_AB_HOME_MDB_W                  PROP_TAG(PT_UNICODE,      0x8006)
#define PR_EMS_AB_HOME_MDB_O                  PROP_TAG(PT_OBJECT,       0x8006)
#define PR_EMS_AB_HOME_MDB_T                  PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_BL                 PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A               PROP_TAG(PT_MV_STRING8,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W               PROP_TAG(PT_MV_UNICODE,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O               PROP_TAG(PT_OBJECT,       0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T               PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MTA                    PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_MTA_A                  PROP_TAG(PT_STRING8,      0x8007)
#define PR_EMS_AB_HOME_MTA_W                  PROP_TAG(PT_UNICODE,      0x8007)
#define PR_EMS_AB_HOME_MTA_O                  PROP_TAG(PT_OBJECT,       0x8007)
#define PR_EMS_AB_HOME_MTA_T                  PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER          PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A        PROP_TAG(PT_STRING8,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W        PROP_TAG(PT_UNICODE,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O        PROP_TAG(PT_OBJECT,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T        PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER            PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A          PROP_TAG(PT_STRING8,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W          PROP_TAG(PT_UNICODE,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O          PROP_TAG(PT_OBJECT,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T          PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY          PROP_TAG(PT_LONG,         0x80BB)
#define PR_EMS_AB_IMPORTED_FROM               PROP_TAG(PT_TSTRING,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A             PROP_TAG(PT_STRING8,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W             PROP_TAG(PT_UNICODE,      0x8042)
#define PR_EMS_AB_INBOUND_SITES               PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A             PROP_TAG(PT_MV_STRING8,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W             PROP_TAG(PT_MV_UNICODE,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O             PROP_TAG(PT_OBJECT,       0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T             PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE               PROP_TAG(PT_LONG,         0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER   PROP_TAG(PT_MV_TSTRING,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG(PT_MV_STRING8,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG(PT_MV_UNICODE,   0x80BE)
#define PR_EMS_AB_INVOCATION_ID               PROP_TAG(PT_BINARY,       0x80BF)
#define PR_EMS_AB_IS_DELETED                  PROP_TAG(PT_BOOLEAN,      0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL             PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A           PROP_TAG(PT_MV_STRING8,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W           PROP_TAG(PT_MV_UNICODE,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O           PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T           PROP_TAG(PT_MV_TSTRING,   0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED            PROP_TAG(PT_BOOLEAN,      0x80C1)
#define PR_EMS_AB_KCC_STATUS                  PROP_TAG(PT_MV_BINARY,    0x80C2)
#define PR_EMS_AB_KM_SERVER                   PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KM_SERVER_A                 PROP_TAG(PT_STRING8,      0x800D)
#define PR_EMS_AB_KM_SERVER_W                 PROP_TAG(PT_UNICODE,      0x800D)
#define PR_EMS_AB_KM_SERVER_O                 PROP_TAG(PT_OBJECT,       0x800D)
#define PR_EMS_AB_KM_SERVER_T                 PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION       PROP_TAG(PT_MV_TSTRING,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A     PROP_TAG(PT_MV_STRING8,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W     PROP_TAG(PT_MV_UNICODE,   0x80C3)
#define PR_EMS_AB_LINE_WRAP                   PROP_TAG(PT_LONG,         0x80C4)
#define PR_EMS_AB_LINK_ID                     PROP_TAG(PT_LONG,         0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD           PROP_TAG(PT_TSTRING,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A         PROP_TAG(PT_STRING8,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W         PROP_TAG(PT_UNICODE,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS   PROP_TAG(PT_TSTRING,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,      0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN          PROP_TAG(PT_BOOLEAN,      0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                 PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A               PROP_TAG(PT_MV_STRING8,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W               PROP_TAG(PT_MV_UNICODE,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O               PROP_TAG(PT_OBJECT,       0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T               PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOG_FILENAME                PROP_TAG(PT_TSTRING,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A              PROP_TAG(PT_STRING8,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W              PROP_TAG(PT_UNICODE,      0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL       PROP_TAG(PT_LONG,         0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY  PROP_TAG(PT_BOOLEAN,      0x80CC)
#define PR_EMS_AB_MANAGER                     PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_A                   PROP_TAG(PT_STRING8,      0x8005)
#define PR_EMS_AB_MANAGER_W                   PROP_TAG(PT_UNICODE,      0x8005)
#define PR_EMS_AB_MANAGER_O                   PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_T                   PROP_TAG(PT_TSTRING,      0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE           PROP_TAG(PT_LONG,         0x80CD)
#define PR_EMS_AB_MAPI_ID                     PROP_TAG(PT_LONG,         0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID           PROP_TAG(PT_BINARY,       0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL        PROP_TAG(PT_LONG,         0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD     PROP_TAG(PT_LONG,         0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT        PROP_TAG(PT_LONG,         0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA           PROP_TAG(PT_LONG,         0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT            PROP_TAG(PT_LONG,         0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS            PROP_TAG(PT_BOOLEAN,      0x80D4)
#define PR_EMS_AB_MEMBER                      PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_A                    PROP_TAG(PT_MV_STRING8,   0x8009)
#define PR_EMS_AB_MEMBER_W                    PROP_TAG(PT_MV_UNICODE,   0x8009)
#define PR_EMS_AB_MEMBER_O                    PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_T                    PROP_TAG(PT_MV_TSTRING,   0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED    PROP_TAG(PT_BOOLEAN,      0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK               PROP_TAG(PT_BOOLEAN,      0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS             PROP_TAG(PT_BOOLEAN,      0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES            PROP_TAG(PT_BOOLEAN,      0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS    PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A  PROP_TAG(PT_MV_STRING8,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W  PROP_TAG(PT_MV_UNICODE,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O  PROP_TAG(PT_OBJECT,       0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T  PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS           PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A         PROP_TAG(PT_MV_STRING8,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W         PROP_TAG(PT_MV_UNICODE,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O         PROP_TAG(PT_OBJECT,       0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T         PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES          PROP_TAG(PT_MV_TSTRING,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A        PROP_TAG(PT_MV_STRING8,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W        PROP_TAG(PT_MV_UNICODE,   0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY      PROP_TAG(PT_LONG,         0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS      PROP_TAG(PT_LONG,         0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG(PT_LONG,       0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG(PT_BINARY,    0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL  PROP_TAG(PT_MV_TSTRING,   0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG(PT_MV_STRING8,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG(PT_MV_UNICODE,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG(PT_OBJECT,      0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG(PT_MV_TSTRING,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC   PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG(PT_MV_STRING8,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG(PT_MV_UNICODE,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG(PT_OBJECT,       0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG(PT_MV_BINARY,0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG(PT_LONG,    0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG(PT_LONG,       0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG(PT_LONG,     0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG(PT_LONG,        0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG(PT_LONG,     0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG(PT_LONG,        0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS       PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A     PROP_TAG(PT_MV_STRING8,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W     PROP_TAG(PT_MV_UNICODE,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O     PROP_TAG(PT_OBJECT,       0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T     PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR   PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG(PT_MV_STRING8,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG(PT_MV_UNICODE,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG(PT_OBJECT,       0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG(PT_LONG,      0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG(PT_LONG,         0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY    PROP_TAG(PT_LONG,         0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS    PROP_TAG(PT_LONG,         0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED              PROP_TAG(PT_TSTRING,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A            PROP_TAG(PT_STRING8,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W            PROP_TAG(PT_UNICODE,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG             PROP_TAG(PT_TSTRING,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A           PROP_TAG(PT_STRING8,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W           PROP_TAG(PT_UNICODE,      0x80F0)
#define PR_EMS_AB_N_ADDRESS                   PROP_TAG(PT_BINARY,       0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE              PROP_TAG(PT_LONG,         0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS             PROP_TAG(PT_MV_TSTRING,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A           PROP_TAG(PT_MV_STRING8,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W           PROP_TAG(PT_MV_UNICODE,   0x8170)
#define PR_EMS_AB_NT_MACHINE_NAME             PROP_TAG(PT_TSTRING,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A           PROP_TAG(PT_STRING8,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W           PROP_TAG(PT_UNICODE,      0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR      PROP_TAG(PT_BINARY,       0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES         PROP_TAG(PT_LONG,         0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES     PROP_TAG(PT_LONG,         0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY       PROP_TAG(PT_LONG,         0x80F6)
#define PR_EMS_AB_OBJECT_VERSION              PROP_TAG(PT_LONG,         0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS      PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A    PROP_TAG(PT_MV_STRING8,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W    PROP_TAG(PT_MV_UNICODE,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O    PROP_TAG(PT_OBJECT,       0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T    PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE        PROP_TAG(PT_BINARY,       0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER          PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A        PROP_TAG(PT_STRING8,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W        PROP_TAG(PT_UNICODE,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O        PROP_TAG(PT_OBJECT,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T        PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE           PROP_TAG(PT_LONG,         0x80FB)
#define PR_EMS_AB_OID_TYPE                    PROP_TAG(PT_LONG,         0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS             PROP_TAG(PT_BINARY,       0x80FD)
#define PR_EMS_AB_OM_SYNTAX                   PROP_TAG(PT_LONG,         0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR     PROP_TAG(PT_BOOLEAN,      0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL         PROP_TAG(PT_LONG,         0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME           PROP_TAG(PT_MV_TSTRING,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A         PROP_TAG(PT_MV_STRING8,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W         PROP_TAG(PT_MV_UNICODE,   0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME    PROP_TAG(PT_MV_TSTRING,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A  PROP_TAG(PT_MV_STRING8,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W  PROP_TAG(PT_MV_UNICODE,   0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE      PROP_TAG(PT_BINARY,       0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY,      0x8104)
#define PR_EMS_AB_OUTBOUND_SITES              PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A            PROP_TAG(PT_MV_STRING8,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W            PROP_TAG(PT_MV_UNICODE,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O            PROP_TAG(PT_OBJECT,       0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T            PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OWNER                       PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_A                     PROP_TAG(PT_STRING8,      0x800C)
#define PR_EMS_AB_OWNER_W                     PROP_TAG(PT_UNICODE,      0x800C)
#define PR_EMS_AB_OWNER_O                     PROP_TAG(PT_OBJECT,       0x800C)
#define PR_EMS_AB_OWNER_T                     PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_BL                    PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_OWNER_BL_A                  PROP_TAG(PT_STRING8,      0x8024)
#define PR_EMS_AB_OWNER_BL_W                  PROP_TAG(PT_UNICODE,      0x8024)
#define PR_EMS_AB_OWNER_BL_O                  PROP_TAG(PT_OBJECT,       0x8024)
#define PR_EMS_AB_OWNER_BL_T                  PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_P_SELECTOR                  PROP_TAG(PT_BINARY,       0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,      0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,    0x8109)
#define PR_EMS_AB_PF_CONTACTS                 PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_A               PROP_TAG(PT_MV_STRING8,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_W               PROP_TAG(PT_MV_UNICODE,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_O               PROP_TAG(PT_OBJECT,       0x8038)
#define PR_EMS_AB_PF_CONTACTS_T               PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_POSTAL_ADDRESS              PROP_TAG(PT_MV_BINARY,    0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD   PROP_TAG(PT_MV_LONG,      0x810D)
#define PR_EMS_AB_PRMD                        PROP_TAG(PT_TSTRING,      0x810E)
#define PR_EMS_AB_PRMD_A                      PROP_TAG(PT_STRING8,      0x810E)
#define PR_EMS_AB_PRMD_W                      PROP_TAG(PT_UNICODE,      0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES             PROP_TAG(PT_MV_TSTRING,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A           PROP_TAG(PT_MV_STRING8,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W           PROP_TAG(PT_MV_UNICODE,   0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL         PROP_TAG(PT_TSTRING,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A       PROP_TAG(PT_STRING8,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W       PROP_TAG(PT_UNICODE,      0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES            PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A          PROP_TAG(PT_MV_STRING8,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W          PROP_TAG(PT_MV_UNICODE,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O          PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T          PROP_TAG(PT_MV_TSTRING,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL         PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A       PROP_TAG(PT_MV_STRING8,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W       PROP_TAG(PT_MV_UNICODE,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O       PROP_TAG(PT_OBJECT,       0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T       PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG(PT_BINARY,       0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE    PROP_TAG(PT_LONG,         0x8112)
#define PR_EMS_AB_RANGE_LOWER                 PROP_TAG(PT_LONG,         0x8113)
#define PR_EMS_AB_RANGE_UPPER                 PROP_TAG(PT_LONG,         0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER         PROP_TAG(PT_TSTRING,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A       PROP_TAG(PT_STRING8,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W       PROP_TAG(PT_UNICODE,      0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER            PROP_TAG(PT_TSTRING,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A          PROP_TAG(PT_STRING8,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W          PROP_TAG(PT_UNICODE,      0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME    PROP_TAG(PT_TSTRING,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A  PROP_TAG(PT_STRING8,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W  PROP_TAG(PT_UNICODE,      0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME        PROP_TAG(PT_TSTRING,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A      PROP_TAG(PT_STRING8,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W      PROP_TAG(PT_UNICODE,      0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS          PROP_TAG(PT_MV_BINARY,    0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD          PROP_TAG(PT_TSTRING,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A        PROP_TAG(PT_STRING8,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W        PROP_TAG(PT_UNICODE,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS  PROP_TAG(PT_TSTRING,      0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,     0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,     0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER        PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A      PROP_TAG(PT_STRING8,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W      PROP_TAG(PT_UNICODE,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O      PROP_TAG(PT_OBJECT,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T      PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_SITE                 PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_A               PROP_TAG(PT_STRING8,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_W               PROP_TAG(PT_UNICODE,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_O               PROP_TAG(PT_OBJECT,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_T               PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE   PROP_TAG(PT_LONG,         0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY     PROP_TAG(PT_LONG,         0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER         PROP_TAG(PT_LONG,         0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR        PROP_TAG(PT_BOOLEAN,      0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER             PROP_TAG(PT_BOOLEAN,      0x8121)
#define PR_EMS_AB_REPORTS                     PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_A                   PROP_TAG(PT_MV_STRING8,   0x800E)
#define PR_EMS_AB_REPORTS_W                   PROP_TAG(PT_MV_UNICODE,   0x800E)
#define PR_EMS_AB_REPORTS_O                   PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_T                   PROP_TAG(PT_MV_TSTRING,   0x800E)
#define PR_EMS_AB_REQ_SEQ                     PROP_TAG(PT_LONG,         0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA       PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A     PROP_TAG(PT_STRING8,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W     PROP_TAG(PT_UNICODE,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O     PROP_TAG(PT_OBJECT,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T     PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RID_SERVER                  PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_RID_SERVER_A                PROP_TAG(PT_STRING8,      0x8124)
#define PR_EMS_AB_RID_SERVER_W                PROP_TAG(PT_UNICODE,      0x8124)
#define PR_EMS_AB_RID_SERVER_O                PROP_TAG(PT_OBJECT,       0x8124)
#define PR_EMS_AB_RID_SERVER_T                PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT               PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A             PROP_TAG(PT_MV_STRING8,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W             PROP_TAG(PT_MV_UNICODE,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O             PROP_TAG(PT_OBJECT,       0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T             PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROUTING_LIST                PROP_TAG(PT_MV_TSTRING,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_A              PROP_TAG(PT_MV_STRING8,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_W              PROP_TAG(PT_MV_UNICODE,   0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE         PROP_TAG(PT_LONG,         0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT        PROP_TAG(PT_LONG,         0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE             PROP_TAG(PT_LONG,         0x8129)
#define PR_EMS_AB_RUNS_ON                     PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_RUNS_ON_A                   PROP_TAG(PT_MV_STRING8,   0x812A)
#define PR_EMS_AB_RUNS_ON_W                   PROP_TAG(PT_MV_UNICODE,   0x812A)
#define PR_EMS_AB_RUNS_ON_O                   PROP_TAG(PT_OBJECT,       0x812A)
#define PR_EMS_AB_RUNS_ON_T                   PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_S_SELECTOR                  PROP_TAG(PT_BINARY,       0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x812C)
#define PR_EMS_AB_SEARCH_FLAGS                PROP_TAG(PT_LONG,         0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                PROP_TAG(PT_MV_BINARY,    0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL           PROP_TAG(PT_MV_BINARY,    0x8037)
#define PR_EMS_AB_SEE_ALSO                    PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SEE_ALSO_A                  PROP_TAG(PT_MV_STRING8,   0x812F)
#define PR_EMS_AB_SEE_ALSO_W                  PROP_TAG(PT_MV_UNICODE,   0x812F)
#define PR_EMS_AB_SEE_ALSO_O                  PROP_TAG(PT_OBJECT,       0x812F)
#define PR_EMS_AB_SEE_ALSO_T                  PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SERIAL_NUMBER               PROP_TAG(PT_MV_TSTRING,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A             PROP_TAG(PT_MV_STRING8,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W             PROP_TAG(PT_MV_UNICODE,   0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST        PROP_TAG(PT_LONG,         0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER        PROP_TAG(PT_LONG,         0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND       PROP_TAG(PT_LONG,         0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY       PROP_TAG(PT_LONG,         0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE     PROP_TAG(PT_TSTRING,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A   PROP_TAG(PT_STRING8,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W   PROP_TAG(PT_UNICODE,      0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER    PROP_TAG(PT_LONG,         0x8136)
#define PR_EMS_AB_SITE_AFFINITY               PROP_TAG(PT_MV_TSTRING,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A             PROP_TAG(PT_MV_STRING8,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W             PROP_TAG(PT_MV_UNICODE,   0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID            PROP_TAG(PT_BINARY,       0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER          PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A        PROP_TAG(PT_STRING8,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W        PROP_TAG(PT_UNICODE,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O        PROP_TAG(PT_OBJECT,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T        PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE            PROP_TAG(PT_MV_TSTRING,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A          PROP_TAG(PT_MV_STRING8,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W          PROP_TAG(PT_MV_UNICODE,   0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED         PROP_TAG(PT_SYSTIME,      0x8139)
#define PR_EMS_AB_STREET_ADDRESS              PROP_TAG(PT_TSTRING,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x813A)
#define PR_EMS_AB_SUB_REFS                    PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUB_REFS_A                  PROP_TAG(PT_MV_STRING8,   0x813B)
#define PR_EMS_AB_SUB_REFS_W                  PROP_TAG(PT_MV_UNICODE,   0x813B)
#define PR_EMS_AB_SUB_REFS_O                  PROP_TAG(PT_OBJECT,       0x813B)
#define PR_EMS_AB_SUB_REFS_T                  PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH      PROP_TAG(PT_LONG,         0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG(PT_MV_BINARY,  0x813D)
#define PR_EMS_AB_SUPPORTING_STACK            PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A          PROP_TAG(PT_MV_STRING8,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W          PROP_TAG(PT_MV_UNICODE,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O          PROP_TAG(PT_OBJECT,       0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T          PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL         PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A       PROP_TAG(PT_MV_STRING8,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W       PROP_TAG(PT_MV_UNICODE,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O       PROP_TAG(PT_OBJECT,       0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T       PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_T_SELECTOR                  PROP_TAG(PT_BINARY,       0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8141)
#define PR_EMS_AB_TARGET_ADDRESS              PROP_TAG(PT_TSTRING,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x8011)
#define PR_EMS_AB_TARGET_MTAS                 PROP_TAG(PT_MV_TSTRING,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_A               PROP_TAG(PT_MV_STRING8,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_W               PROP_TAG(PT_MV_UNICODE,   0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER            PROP_TAG(PT_MV_TSTRING,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A          PROP_TAG(PT_MV_STRING8,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W          PROP_TAG(PT_MV_UNICODE,   0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG(PT_MV_BINARY,    0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD        PROP_TAG(PT_LONG,         0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME          PROP_TAG(PT_LONG,         0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME      PROP_TAG(PT_TSTRING,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A    PROP_TAG(PT_STRING8,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W    PROP_TAG(PT_UNICODE,      0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS            PROP_TAG(PT_LONG,         0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS          PROP_TAG(PT_LONG,         0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL     PROP_TAG(PT_LONG,         0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG(PT_LONG,         0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL     PROP_TAG(PT_LONG,         0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT     PROP_TAG(PT_LONG,         0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED      PROP_TAG(PT_LONG,         0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA    PROP_TAG(PT_BOOLEAN,      0x814E)
#define PR_EMS_AB_TRUST_LEVEL                 PROP_TAG(PT_LONG,         0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD      PROP_TAG(PT_LONG,         0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY  PROP_TAG(PT_BOOLEAN,      0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL              PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A            PROP_TAG(PT_MV_STRING8,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W            PROP_TAG(PT_MV_UNICODE,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O            PROP_TAG(PT_OBJECT,       0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T            PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_USER_PASSWORD               PROP_TAG(PT_MV_BINARY,    0x8153)
#define PR_EMS_AB_USN_CHANGED                 PROP_TAG(PT_LONG,         0x8029)
#define PR_EMS_AB_USN_CREATED                 PROP_TAG(PT_LONG,         0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED    PROP_TAG(PT_LONG,         0x8155)
#define PR_EMS_AB_USN_LAST_OBJ_REM            PROP_TAG(PT_LONG,         0x8156)
#define PR_EMS_AB_USN_SOURCE                  PROP_TAG(PT_LONG,         0x8157)
#define PR_EMS_AB_X121_ADDRESS                PROP_TAG(PT_MV_TSTRING,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_A              PROP_TAG(PT_MV_STRING8,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_W              PROP_TAG(PT_MV_UNICODE,   0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG(PT_BINARY,       0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG(PT_BINARY,       0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG(PT_BINARY,      0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG(PT_BINARY,      0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT        PROP_TAG(PT_BINARY,       0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED      PROP_TAG(PT_BOOLEAN,      0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE        PROP_TAG(PT_TSTRING,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A      PROP_TAG(PT_STRING8,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W      PROP_TAG(PT_UNICODE,      0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE        PROP_TAG(PT_BINARY,       0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX        PROP_TAG(PT_LONG,         0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST    PROP_TAG(PT_BINARY,       0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT     PROP_TAG(PT_LONG,         0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL         PROP_TAG(PT_LONG,         0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT         PROP_TAG(PT_LONG,         0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\fileno.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       fileno.h
//
//--------------------------------------------------------------------------

//
// fileno.h - defines symbolic constants  for directory server c code
// files. File numbers are 16 bit values. The high byte is the directory number and
// the low byte is the file number within the directory.
//

// Why not make the macro have just one arg, since line is always
// __LINE__?  Because if we did then __LINE__ would be evaluated here,
// rather than at the invocation of the macro, and so would always
// have the value 11.
#define DSID(fileno,line) (((fileno) << 16) | (line))

//
//  *** NOTE: ***
//
//  If you add FILENO_*'s to this list, be sure to make a corresponding update
//  to ds\src\util\dsid.c so that dsid.exe can properly decode the DSID
//  corresponding to the new file.
//
//  If you add DIRNO_*'s to this list, be sure to make a corresponding update
//  to ds\src\dscommon\dsvent.c - rEventSourceMappings[].
//

// define directory numbers

#define DIRNO_COMMON    (0)                             // src\common
#define DIRNO_DRA       (1 << 8)                        // \dsamain\dra
#define DIRNO_DBLAYER   (2 << 8)                        // \dsamain\dblayer
#define DIRNO_SRC       (3 << 8)                        // \dsamain\src
#define DIRNO_NSPIS     (4 << 8)                        // \dsamain\nspis
#define DIRNO_DRS       (5 << 8)                        // \dsamain\drs
#define DIRNO_XDS       (6 << 8)                        // \dsamain\xdsserv
#define DIRNO_BOOT      (7 << 8)                        // \dsamain\boot
#define DIRNO_PERMIT    (8 << 8)                        // \src\permit
#define DIRNO_ALLOCS    (9 << 8)                        // \dsamain\allocs
#define DIRNO_LIBXDS    (10 << 8)                       // \src\libxds
#define DIRNO_SAM       (11 << 8)                       // SAM
#define DIRNO_LDAP      (12 << 8)                       // src\dsamain\ldap
#define DIRNO_SDPROP    (13 << 8)                       // src\dsamain\sdprop
#define DIRNO_TASKQ     (14 << 8)                       // src\taskq
#define DIRNO_KCC       (15 << 8)                       // src\kcc
// Define a DIRNO so that we can make Jet's event log entries go to
// the Directory Service log instead of the Application log.
#define DIRNO_ISAM      (16 << 8)                       // JET
#define DIRNO_ISMSERV   (17 << 8)                       // src\ism\server
#define DIRNO_PEK       (18 << 8)                       // dsamain\src\pek
#define DIRNO_NTDSETUP  (19 << 8)                       // src\ntdsetup
#define DIRNO_NTDSAPI   (20 << 8)                     // src\ntdsapi
#define DIRNO_NTDSCRIPT (21 << 8)                     // util\ntdscript
#define DIRNO_JETBACK   (22 << 8)                       // Jet backup
#define DIRNO_NETEVENT  (0xFF << 8)                     // bogus

// common directory
#define FILENO_ALERT            (DIRNO_COMMON + 0)      // alert.c
#define FILENO_DEBUG            (DIRNO_COMMON + 0)      // debug.c
#define FILENO_DSCONFIG         (DIRNO_COMMON + 1)      // dsconfig.c
#define FILENO_DSEVENT          (DIRNO_COMMON + 2)      // dsevent.c
#define FILENO_DSEXCEPT         (DIRNO_COMMON + 3)      // dsexcept.c
#define FILENO_DBOPEN           (DIRNO_COMMON + 4)      // dsexcept.c
#define FILENO_NTUTILS          (DIRNO_COMMON + 5)      // dsexcept.c

// nspis directory
#define FILENO_NSPSERV          (DIRNO_NSPIS + 0)       // nspserv.c
#define FILENO_MODPROP          (DIRNO_NSPIS + 1)       // modprop.c
#define FILENO_DETAILS          (DIRNO_NSPIS + 2)       // details.c
#define FILENO_ABTOOLS          (DIRNO_NSPIS + 3)       // abtools.c
#define FILENO_ABBIND           (DIRNO_NSPIS + 4)       // abbind.c
#define FILENO_ABSEARCH         (DIRNO_NSPIS + 5)       // absearch.c
#define FILENO_ABNAMEID         (DIRNO_NSPIS + 6)       // abnameid.c
#define FILENO_NSPNOTIF         (DIRNO_NSPIS + 7)       // nspnotif.c
#define FILENO_ABSERV       (DIRNO_NSPIS + 8)   // abserv.c
#define FILENO_MSDSSERV     (DIRNO_NSPIS + 9)   // msdsserv.c
#define FILENO_MSNOTIF      (DIRNO_NSPIS + 10)  // msnotif.c

// dra directory
#define FILENO_DIRTY            (DIRNO_DRA + 0)         // dirty.c
#define FILENO_DRAASYNC         (DIRNO_DRA + 1)         // draasync.c
#define FILENO_DRAERROR         (DIRNO_DRA + 2)         // draerror.c
#define FILENO_DRAGTCHG         (DIRNO_DRA + 3)         // dragtchg.c
#define FILENO_DRAINST          (DIRNO_DRA + 4)         // drainst.c
#define FILENO_DRAMAIL          (DIRNO_DRA + 5)         // dramail.c
#define FILENO_DRANCADD         (DIRNO_DRA + 6)         // drancadd.c
#define FILENO_DRANCDEL         (DIRNO_DRA + 7)         // drancdel.c
#define FILENO_DRANCREP         (DIRNO_DRA + 8)         // drancrep.c
#define FILENO_DRASERV          (DIRNO_DRA + 9)         // draserv.c
#define FILENO_DRASYNC          (DIRNO_DRA + 10)        // drasync.c
#define FILENO_DRAUPDRR         (DIRNO_DRA + 11)        // draupdrr.c
#define FILENO_DRAUTIL          (DIRNO_DRA + 12)        // drautil.c
#define FILENO_PICKEL           (DIRNO_DRA + 13)        // pickel.c
#define FILENO_DRAXUUID         (DIRNO_DRA + 14)        // draxuuid.c
#define FILENO_DRAUPTOD         (DIRNO_DRA + 15)        // drauptod.c
#define FILENO_DRAMETA          (DIRNO_DRA + 16)        // drameta.c
#define FILENO_DRARFMOD         (DIRNO_DRA + 17)        // drarfmod.c
#define FILENO_DRADIR           (DIRNO_DRA + 18)        // dradir.c
#define FILENO_GCLOGON          (DIRNO_DRA + 19)        // gclogon.c
#define FILENO_DRASCH           (DIRNO_DRA + 20)        // drasch.c
#define FILENO_DRACHKPT         (DIRNO_DRA + 21)        // drachkpt.c
#define FILENO_NTDSAPI          (DIRNO_DRA + 22)        // ntdsapi.c
#define FILENO_SPNOP            (DIRNO_DRA + 23)        // spnop.c
#define FILENO_DRACRYPT         (DIRNO_DRA + 24)        // dracrypt.c
#define FILENO_DRAINFO          (DIRNO_DRA + 25)        // drainfo.c
#define FILENO_ADDSID           (DIRNO_DRA + 26)        // addsid.c
#define FILENO_DRAINIT          (DIRNO_DRA + 27)        // drainit.c
#define FILENO_DRADEMOT         (DIRNO_DRA + 28)        // drademot.c
#define FILENO_DRAMSG           (DIRNO_DRA + 29)        // dramsg.c
#define FILENO_NTDSCRIPT        (DIRNO_DRA + 30)        // script.cxx
#define FILENO_DRARPC           (DIRNO_DRA + 31)        // drarpc.c
#define FILENO_DRAMDERR	        (DIRNO_DRA + 32)        // dramderr.c
#define FILENO_DRAEXIST         (DIRNO_DRA + 33)        // draexist.c


// dblayer directory

#define FILENO_DBEVAL           (DIRNO_DBLAYER + 0)     // dbeval.c
#define FILENO_DBINDEX          (DIRNO_DBLAYER + 1)     // dbindex.c
#define FILENO_DBINIT           (DIRNO_DBLAYER + 2)     // dbinit.c
#define FILENO_DBISAM           (DIRNO_DBLAYER + 3)     // dbisam.c
#define FILENO_DBJETEX          (DIRNO_DBLAYER + 4)     // dbjetex.c
#define FILENO_DBOBJ            (DIRNO_DBLAYER + 5)     // dbobj.c
#define FILENO_DBSUBJ           (DIRNO_DBLAYER + 6)     // dbsubj.c
#define FILENO_DBSYNTAX         (DIRNO_DBLAYER + 7)     // dbsyntax.c
#define FILENO_DBTOOLS          (DIRNO_DBLAYER + 8)     // dbtools.c
#define FILENO_DBPROP           (DIRNO_DBLAYER + 9)     // dbprop.c
#define FILENO_DBSEARCH         (DIRNO_DBLAYER + 10)    // dbsearch.c
#define FILENO_DBMETA           (DIRNO_DBLAYER + 11)    // dbmeta.c
#define FILENO_DBESCROW         (DIRNO_DBLAYER + 12)    // dbescrow.c
#define FILENO_DBCACHE          (DIRNO_DBLAYER + 13)    // dbache.c
#define FILENO_DBCONSTR         (DIRNO_DBLAYER + 14)    // dbconstr.c
#define FILENO_DBLINK           (DIRNO_DBLAYER + 15)    // dblink.c
#define FILENO_DBFILTER         (DIRNO_DBLAYER + 16)    // dbfilter.c

// drsserv directory
#define FILENO_DRSUAPI          (DIRNO_DRS + 0)         // drsuapi.c
#define FILENO_IDLNOTIF         (DIRNO_DRS + 1)         // idlnotif.c
#define FILENO_IDLTRANS         (DIRNO_DRS + 2)         // idltrans.c

// xdsserv directory
#define FILENO_ATTRLIST         (DIRNO_XDS + 0)         // attrlist.c
#define FILENO_COMPRES          (DIRNO_XDS + 1)         // compres.c
#define FILENO_CONTEXT          (DIRNO_XDS + 2)         // context.c
#define FILENO_DSWAIT           (DIRNO_XDS + 3)         // dswait.c
#define FILENO_INFSEL           (DIRNO_XDS + 4)         // infsel.c
#define FILENO_LISTRES          (DIRNO_XDS + 5)         // listres.c
#define FILENO_MODIFY           (DIRNO_XDS + 6)         // modify.c
#define FILENO_OMTODSA          (DIRNO_XDS + 7)         // omtodsa.c
#define FILENO_READRES          (DIRNO_XDS + 8)         // readres.c
#define FILENO_SEARCHR          (DIRNO_XDS + 9)         // searchr.c
#define FILENO_SYNTAX           (DIRNO_XDS + 10)        // syntax.c
#define FILENO_XDSAPI           (DIRNO_XDS + 11)        // xdsapi.c
#define FILENO_XDSNOTIF         (DIRNO_XDS + 12)        // xdsnotif.c

// src directory

#define FILENO_DSAMAIN      (DIRNO_SRC + 0)         // dsamain.c
#define FILENO_DSANOTIF     (DIRNO_SRC + 1)         // dsanotif.c
#define FILENO_DSATOOLS     (DIRNO_SRC + 2)         // dsatools.c
#define FILENO_DSTASKQ      (DIRNO_SRC + 3)         // dstaskq.c
#define FILENO_HIERTAB      (DIRNO_SRC + 4)         // hiertab.c
#define FILENO_MDADD        (DIRNO_SRC + 5)         // mdadd.c
#define FILENO_MDBIND       (DIRNO_SRC + 6)         // mdbind.c
#define FILENO_MDCHAIN      (DIRNO_SRC + 7)         // mdchain.c
#define FILENO_MDCOMP       (DIRNO_SRC + 8)         // mdcomp.c
#define FILENO_MDDEL        (DIRNO_SRC + 9)         // mddel.c
#define FILENO_MDDIT        (DIRNO_SRC + 10)        // mddit.c
#define FILENO_MDERRMAP     (DIRNO_SRC + 11)        // mderrmap.c
#define FILENO_MDERROR      (DIRNO_SRC + 12)        // mderror.c
#define FILENO_MDINIDSA     (DIRNO_SRC + 13)        // mdinidsa.c
#define FILENO_MDLIST       (DIRNO_SRC + 14)        // mdlist.c
#define FILENO_MDMOD        (DIRNO_SRC + 15)        // mdmod.c
#define FILENO_MDNAME       (DIRNO_SRC + 16)        // mdname.c
#define FILENO_MDNOTIFY     (DIRNO_SRC + 17)        // mdnotify.c
#define FILENO_MDREAD       (DIRNO_SRC + 18)        // mdread.c
#define FILENO_MDREMOTE     (DIRNO_SRC + 19)        // mdremote.c
#define FILENO_MDSEARCH     (DIRNO_SRC + 20)        // mdsearch.c
#define FILENO_MDUPDATE     (DIRNO_SRC + 21)        // mdupdate.c
#define FILENO_MSRPC        (DIRNO_SRC + 22)        // msrpc.c
#define FILENO_SCACHE       (DIRNO_SRC + 23)        // scache.c
#define FILENO_X500PERM     (DIRNO_SRC + 24)        // x500perm.c
#define FILENO_LOOPBACK     (DIRNO_SRC + 25)        // loopback.c
#define FILENO_MAPPINGS     (DIRNO_SRC + 26)        // mappings.c
#define FILENO_MDMODDN      (DIRNO_SRC + 27)        // mdmoddn.c
#define FILENO_SAMLOGON     (DIRNO_SRC + 28)        // samlogon.c
#define FILENO_SAMWRITE     (DIRNO_SRC + 29)        // samwrite.c
#define FILENO_CRACKNAM     (DIRNO_SRC + 30)        // cracknam.c
#define FILENO_DOMINFO      (DIRNO_SRC + 31)        // dominfo.c
#define FILENO_GCVERIFY     (DIRNO_SRC + 32)        // gcverify.c
#define FILENO_MDCTRL       (DIRNO_SRC + 33)        // mdctrl.c
#define FILENO_PERMIT       (DIRNO_SRC + 34)        // permit.c
#define FILENO_DISKBAK      (DIRNO_SRC + 35)        // diskbak.c
#define FILENO_PARSEDN      (DIRNO_SRC + 36)        // parsedn.c
#define FILENO_MDFIND       (DIRNO_SRC + 37)        // mdfind.c
#define FILENO_SCCHK        (DIRNO_SRC + 38)        // scchk.c
#define FILENO_RPCCANCL     (DIRNO_SRC + 39)        // rpccancl.c
#define FILENO_GTCACHE      (DIRNO_SRC + 40)        // gtcache.c
#define FILENO_DSTRACE      (DIRNO_SRC + 41)        // dstrace.c
#define FILENO_FPOCLEAN     (DIRNO_SRC + 42)        // fpoclean.c
#define FILENO_SERVINFO     (DIRNO_SRC + 43)        // servinfo.c
#define FILENO_PHANTOM      (DIRNO_SRC + 44)        // phantom.c
#define FILENO_XDOMMOVE     (DIRNO_SRC + 45)        // xdommove.c
#define FILENO_IMPERSON     (DIRNO_SRC + 46)        // imperson.c
#define FILENO_MAPSPN       (DIRNO_SRC + 47)        // mapspn.c
#define FILENO_SECADMIN     (DIRNO_SRC + 48)        // secadmin.c
#define FILENO_SAMCACHE     (DIRNO_SRC + 49)        // samcache.c
#define FILENO_LINKCLEAN    (DIRNO_SRC + 50)        // linkclean.c
#define FILENO_MDNDNC       (DIRNO_SRC + 51)        // mdndnc.c
#define FILENO_LHT          (DIRNO_SRC + 52)        // lht.c

// bootstrapping files
#define FILENO_ADDSERV      (DIRNO_BOOT + 0)        // addserv.c
#define FILENO_INSTALL      (DIRNO_BOOT + 1)        // install.cxx
#define FILENO_ADDOBJ       (DIRNO_BOOT + 2)        // addobj.cxx

// permit files
#define FILENO_CHECKSD          (DIRNO_PERMIT + 0)      // checksd.c

// allocs files
#define FILENO_ALLOCS           (DIRNO_ALLOCS + 0)      // allocs.c

// libxds files
#define FILENO_CLIENT           (DIRNO_LIBXDS + 0)      // client.c

//newsam2
#define FILENO_SAM              (DIRNO_SAM + 0)         // SAM

//ldap
#define FILENO_LDAP_GLOBALS     (DIRNO_LDAP + 0)        // global.cxx
#define FILENO_LDAP_CONN        (DIRNO_LDAP + 1)        // connect.cxx
#define FILENO_LDAP_INIT        (DIRNO_LDAP + 2)        // init.cxx
#define FILENO_LDAP_LDAP        (DIRNO_LDAP + 3)        // ldap.cxx
#define FILENO_LDAP_CONV        (DIRNO_LDAP + 4)        // ldapconv.cxx
#define FILENO_LDAP_REQ         (DIRNO_LDAP + 5)        // request.cxx
#define FILENO_LDAP_USER        (DIRNO_LDAP + 6)        // userdata.cxx
#define FILENO_LDAP_CORE        (DIRNO_LDAP + 7)        // ldapcore.cxx
#define FILENO_LDAP_LDAPBER     (DIRNO_LDAP + 8)        // ldapber.cxx
#define FILENO_LDAP_COMMAND     (DIRNO_LDAP + 9)        // command.cxx
#define FILENO_LDAP_LIMITS      (DIRNO_LDAP +10)        // limits.cxx
#define FILENO_LDAP_MISC        (DIRNO_LDAP +11)        // misc.cxx
#define FILENO_LDAP_DECODE      (DIRNO_LDAP +12)        // decode.cxx
#define FILENO_LDAP_ENCODE      (DIRNO_LDAP +13)        // encode.cxx
#define FILENO_LDAP_SECURE      (DIRNO_LDAP +14)        // secure.cxx

//sdprop
#define FILENO_PROPDMON         (DIRNO_SDPROP + 0)      // propdmon.c
#define FILENO_PROPQ            (DIRNO_SDPROP + 1)      // propq.c

//taskq
#define FILENO_TASKQ_TASKQ      (DIRNO_TASKQ + 0)       // taskq.c
#define FILENO_TASKQ_TIME       (DIRNO_TASKQ + 1)       // time.c

//kcc
#define FILENO_KCC_KCCMAIN      (DIRNO_KCC + 0)         // kccmain.cxx
#define FILENO_KCC_KCCLINK      (DIRNO_KCC + 1)         // kcclink.cxx
#define FILENO_KCC_KCCCONN      (DIRNO_KCC + 2)         // kccconn.cxx
#define FILENO_KCC_KCCCREF      (DIRNO_KCC + 3)         // kcccref.cxx
#define FILENO_KCC_KCCDSA       (DIRNO_KCC + 4)         // kccdsa.cxx
#define FILENO_KCC_KCCDUAPI     (DIRNO_KCC + 5)         // kccduapi.cxx
#define FILENO_KCC_KCCTASK      (DIRNO_KCC + 6)         // kcctask.cxx
#define FILENO_KCC_KCCTOPL      (DIRNO_KCC + 7)         // kcctopl.cxx
#define FILENO_KCC_KCCSITE      (DIRNO_KCC + 8)         // kccsite.cxx
#define FILENO_KCC_KCCTOOLS     (DIRNO_KCC + 9)         // kcctools.cxx
#define FILENO_KCC_KCCNCTL      (DIRNO_KCC + 10)        // kccnctl.cxx
#define FILENO_KCC_KCCDYNAR     (DIRNO_KCC + 11)        // kccdynar.cxx
#define FILENO_KCC_KCCSTETL     (DIRNO_KCC + 12)        // kccstetl.cxx
#define FILENO_KCC_KCCSCONN     (DIRNO_KCC + 13)        // kccsconn.cxx
#define FILENO_KCC_KCCTRANS     (DIRNO_KCC + 14)        // kcctrans.cxx
#define FILENO_KCC_KCCCACHE_HXX (DIRNO_KCC + 15)        // kcccache.hxx
#define FILENO_KCC_KCCCACHE     (DIRNO_KCC + 16)        // kcccache.cxx
#define FILENO_KCC_KCCSITELINK  (DIRNO_KCC + 17)        // kccsitelink.cxx
#define FILENO_KCC_KCCBRIDGE    (DIRNO_KCC + 18)        // kccbridge.cxx

//ism\server
#define FILENO_ISMSERV_TRANSPRT (DIRNO_ISMSERV + 0)     // transprt.cxx
#define FILENO_ISMSERV_PENDING  (DIRNO_ISMSERV + 1)     // pending.cxx
#define FILENO_ISMSERV_LDAPOBJ  (DIRNO_ISMSERV + 2)     // ldapobj.cxx
#define FILENO_ISMSERV_ISMAPI   (DIRNO_ISMSERV + 3)     // ismapi.cxx
#define FILENO_ISMSERV_SERVICE  (DIRNO_ISMSERV + 4)     // service.cxx
#define FILENO_ISMSERV_MAIN     (DIRNO_ISMSERV + 5)     // main.cxx
#define FILENO_ISMSERV_IPSEND   (DIRNO_ISMSERV + 6)     // ip\sendrecv.c
#define FILENO_ISMSERV_XMITRECV (DIRNO_ISMSERV + 7)     // smtp\xmitrecv.cxx
#define FILENO_ISMSERV_ROUTE    (DIRNO_ISMSERV + 8)     // route.c
#define FILENO_ISMSERV_ADSISUPP (DIRNO_ISMSERV + 9)     // smtp\adsisupp.cxx
#define FILENO_ISMSERV_ISMSMTP  (DIRNO_ISMSERV + 10)    // smtp\ismsmtp.c
#define FILENO_ISMSERV_CDOSUPP  (DIRNO_ISMSERV + 11)    // smtp\cdosupp.c
#define FILENO_ISMSERV_ISMIP    (DIRNO_ISMSERV + 12)    // ip\ismip.c

//pek
#define FILENO_PEK              (DIRNO_PEK+0)           // pek.c

// ntsetup
#define FILENO_NTDSETUP_NTDSETUP (DIRNO_NTDSETUP+0)     // ntdsetup.c

// ntdsapi
#define FILENO_NTDSAPI_REPLICA  (DIRNO_NTDSAPI + 0)     // replica.c

// ntdscript
#define FILENO_NTDSCRIPT_NTDSCONTENT  (DIRNO_NTDSCRIPT + 0)     // NTDSConent.cxx
#define FILENO_LOG                    (DIRNO_NTDSCRIPT + 1)     // log.cxx

// Jetback
#define FILENO_JETBACK (DIRNO_JETBACK + 0)               // jetback.c
#define FILENO_JETREST (DIRNO_JETBACK + 1)               // jetrest.c
#define FILENO_SNAPSHOT (DIRNO_JETBACK + 2)               // snapshot.cxx
#define FILENO_DIRAPI (DIRNO_JETBACK + 3)               // dirapi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\idltrans.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       idltrans.h
//
//--------------------------------------------------------------------------

/* Translations between native and IDLable versions of data structures. */

extern LINEARAVALIST * DSNameToDistname(DSNAME *);
extern DSNAME * DistnameToDSName(UNALIGNED LINEARAVALIST *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ldapagnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ldapagnt.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file exports the LDAP server to the rest of the NT5 Directory Service.

Author:

    Colin Watson     [ColinW]    09-Jul-1996

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
DoLdapInitialize();

VOID
TriggerLdapStop();

VOID
WaitLdapStop();

BOOL 
LdapStartGCPort( VOID );

VOID 
LdapStopGCPort( VOID );        

VOID 
DisableLdapLimitsChecks( VOID );        

DWORD
LdapEnumConnections(
    IN THSTATE *pTHS,
    IN PDWORD Count,
    IN PVOID *Buffer
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\heurist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       heurist.h
//
//--------------------------------------------------------------------------

/*
 * This file contains the global flags controlled by the 
 * DSA heuristics key.
 */
/* heuristic[0]
 * Flag to ask the DS to allow write caching on disks where
 * we have our dits and log files.
 */
#define AllowWriteCaching               0
extern DWORD gulAllowWriteCaching;
 
/* heuristic[1]
 * Flag which instructs SD propagator to perform additional
 * sanity checks on all SDs it is propagating.
 */
#define ValidateSDHeuristic                 1
extern ULONG gulValidateSDs;

/* heuristic[2]
 * This is to tell the ldap head not to enforce these policies: maxsearches,
 * max connections, and ip deny lists.  This is to enable admins to fixup
 * the policy stuff in case they shoots themselves on the foot, i.e., set
 * maxconn to zero, setting 0 ip 0 mask, maxqueries to zero. 
 */

#define BypassLimitsChecks                   2

/* heuristic[3]
 * Formerly. Whether or not to do exact match on 
 * Mail-Nickname first for ANR.  Currently unused
 */


/* heuristic[4]
 * Whether or not to do compression of 
 * intersite replication mail. 
 * Since compression can now be disabled on a per-site link basis,
 * this heuristic is obsolete.
 */
#define DoMailCompressionHeuristic		4

/* heuristic[5]
 * If set, suppresses many useful but not vital background activities.
 * Used for repeatable performance measurements.
 */
#define SuppressBackgroundTasksHeuristic    5

/* heuristic[6]
 * If set, allows schema cache load to ignore default SD conversion failures
 * so that the system can go ahead and boot at least. Any bad default SDs
 * can then be corrected
 */
#define IgnoreBadDefaultSD  6
extern ULONG gulIgnoreBadDefaultSD;

/* heurusitic[7]
 * If set, forces sequential instead of circular logging in Jet
 */
#define SuppressCircularLogging 7
extern ULONG gulCircularLogging;

/* heuristic[8]
 * If set, the LDAP head will return an error on searches through the GC when 
 * an attempt is made to either filter on a non-GC att, or the list of Atts to
 * return contains a non-GC att.
 */
#define ReturnErrOnGCSearchesWithNonGCAtts 8
extern ULONG gulGCAttErrorsEnabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\mapiperf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       mapiperf.h
//
//--------------------------------------------------------------------------

/*
 -	M A P I P E R F . H
 -
 *	Purpose:
 *		This is the place to define data structures, macros, and functions
 *		used to improve the performance of WMS components.
 *
 *  Stolen from \\malibu\src\slm2\src\mapi\inc\mapiperf.h on 6 April, 1995
 */

#ifndef __MAPIPERF_H__
#define __MAPIPERF_H__
 
#define MAPISetBufferNameFn(pv) \
	(!(pv) || !(*((ULONG *)(pv) - 2) & 0x40000000)) ? 0 : \
		(**((int (__cdecl ***)(void *, ...))((ULONG *)(pv) - 3))) \
			((void *)*((ULONG *)pv - 3), (ULONG *)pv - 4,

#if DBG && !defined(DOS) && defined(WIN32)
#define MAPISetBufferName(pv,psz)		MAPISetBufferNameFn(pv) psz)
#define MAPISetBufferName1(pv,psz,a1)		MAPISetBufferNameFn(pv) psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)	MAPISetBufferNameFn(pv) psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3) 	MAPISetBufferNameFn(pv) psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4) 	MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5) MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4,a5)

#else

#define MAPISetBufferName(pv,psz)
#define MAPISetBufferName1(pv,psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5)

#endif

#endif /* __MAPIPERF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\mbudev.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mbudev.c
//
//--------------------------------------------------------------------------

#include "mbudev.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\msdstag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1986 - 1999
//
//  File:       msdstag.h
//
//--------------------------------------------------------------------------

/*
** ---------------------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)
#define PR_EMS_AB_ALL_CHILDREN                PROP_TAG(PT_OBJECT,       0xFFF7)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF7

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

// pre-defined, but not in the schema
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING     , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8     , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE     , 0x39FF)

#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_OBJECT      , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8     , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE     , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT      , 0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING     , 0x803C)

#include <MSDSMapi.h>

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\msrpc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       msrpc.h
//
//--------------------------------------------------------------------------


/*

Description:
    Contains declarations of data types and routines used to interface
    with the MS RPC runtime.

*/


#ifndef _msrpc_h_
#define _msrpc_h_

/*
 * maximum number of interfaces exported to RPC's name service
 */

#define MAX_RPC_NS_EXPORTED_INTERFACES	3   // xds, nspi, drs
#define NS_ENTRY_NAME_PREFIX "/.:/Directory/"
#define SERVER_PRINCIPAL_NAME "NTDS"
#define SERVER_PRINCIPAL_NAMEW L"NTDS"
#define MAX_NS_ENTRY_NAME_LEN (sizeof(NS_ENTRY_NAME_PREFIX) + MAX_COMPUTERNAME_LENGTH + 1)

#define RPC_TRANSPORT_ANY	0
#define RPC_TRANSPORT_NAMEPIPE	1
#define RPC_TRANSPORT_LPC	2
#define RPC_TRANSPORT_TCP	3
#define RPC_TRANSPORT_NB_NB	4
#define RPC_TRANSPORT_NB_TCP	5
#define RPC_TRANSPORT_SPX	6

//$MAC
#ifdef MAC
#define RPC_TRANSPORT_AT	7
#endif //MAC

/*
 * constants that should really come from Win32
 */
#define NB_NB_PROTSEQ       (unsigned char *)"ncacn_nb_nb"
#define NB_NB_PROTSEQW      (WCHAR *)L"ncacn_nb_nb"
#define NB_TCP_PROTSEQ      (unsigned char *)"ncacn_nb_tcp"
#define NB_TCP_PROTSEQW     (WCHAR *)L"ncacn_nb_tcp"
#define NP_PROTSEQ          (unsigned char *)"ncacn_np"
#define NP_PROTSEQW         (WCHAR *)L"ncacn_np"
#define LPC_PROTSEQ         (unsigned char *)"ncalrpc"
#define LPC_PROTSEQW        (WCHAR *)L"ncalrpc"
#define TCP_PROTSEQ         (unsigned char *)"ncacn_ip_tcp"
#define TCP_PROTSEQW        (WCHAR *)L"ncacn_ip_tcp"
#define DNET_PROTSEQ        (unsigned char *)"ncacn_dnet_nsp"
#define DNET_PROTSEQW       (WCHAR *)L"ncacn_dnet_nsp"
#define SPX_PROTSEQ         (unsigned char *)"ncacn_spx"
#define SPX_PROTSEQW        (WCHAR *)L"ncacn_spx"
#define AT_PROTSEQ          (unsigned char *)"ncacn_at_dsp"
#define AT_PROTSEQW         (WCHAR *)L"ncacn_at_dsp"
#define UDP_PROTSEQ         (unsigned char *)"ncadg_ip_udp"
#define UDP_PROTSEQW        (WCHAR *)L"ncadg_ip_udp"

#define DS_LPC_ENDPOINT     "NTDS_LPC"
#define DS_LPC_ENDPOINTW    L"NTDS_LPC"

extern void StartDsaRpc(void);
extern void StartDraRpc(void);
extern void MSRPC_Uninstall(BOOL fRunningInsideLsa);
extern void MSRPC_Install(BOOL fRunningInsideLsa);
extern void MSRPC_WaitForCompletion(void);
extern void MSRPC_RegisterEndpoints(RPC_IF_HANDLE hServerIf);
extern void MSRPC_UnregisterEndpoints(RPC_IF_HANDLE hServerIf);
extern void MSRPC_Init(void);

/* Max RPC calls */
extern ULONG ulMaxCalls;

extern int gRpcListening;        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\mdschema.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       mdschema.h
//
//--------------------------------------------------------------------------



/*++
 File:    MDS.H
 Purpose: Contains the OID Definition for DS Pkg.
 Creator: Automatically Generated on
 Date:    Sat May 12 11:43:19 2001

 ** This is a Generated File From Schema.INI **
 ** DO NOT MODIFY  DIRECTLY  **
 ** DO NOT INCLUDE DIRECTLY  **

--*/
//
//Attribute Definitions
//
#define OMP_O_DX_A_ACCOUNT_EXPIRES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1F"
#define OMP_O_DX_A_ACCOUNT_NAME_HISTORY                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1B"
#define OMP_O_DX_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x78"
#define OMP_O_DX_A_ACS_ALLOCABLE_RSVP_BANDWIDTH             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7E"
#define OMP_O_DX_A_ACS_CACHE_TIMEOUT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0B"
#define OMP_O_DX_A_ACS_DIRECTION                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x75"
#define OMP_O_DX_A_ACS_DSBM_DEADTIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0A"
#define OMP_O_DX_A_ACS_DSBM_PRIORITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x08"
#define OMP_O_DX_A_ACS_DSBM_REFRESH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x09"
#define OMP_O_DX_A_ACS_ENABLE_ACS_SERVICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x02"
#define OMP_O_DX_A_ACS_ENABLE_RSVP_ACCOUNTING               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x03"
#define OMP_O_DX_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x00"
#define OMP_O_DX_A_ACS_EVENT_LOG_LEVEL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x01"
#define OMP_O_DX_A_ACS_IDENTITY_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x10"
#define OMP_O_DX_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x01"
#define OMP_O_DX_A_ACS_MAX_DURATION_PER_FLOW                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x79"
#define OMP_O_DX_A_ACS_MAX_NO_OF_ACCOUNT_FILES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x05"
#define OMP_O_DX_A_ACS_MAX_NO_OF_LOG_FILES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x06"
#define OMP_O_DX_A_ACS_MAX_PEAK_BANDWIDTH                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7F"
#define OMP_O_DX_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x77"
#define OMP_O_DX_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x06"
#define OMP_O_DX_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x07"
#define OMP_O_DX_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x21"
#define OMP_O_DX_A_ACS_MAX_TOKEN_RATE_PER_FLOW              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x76"
#define OMP_O_DX_A_ACS_MAXIMUM_SDU_SIZE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x22"
#define OMP_O_DX_A_ACS_MINIMUM_DELAY_VARIATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x25"
#define OMP_O_DX_A_ACS_MINIMUM_LATENCY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x24"
#define OMP_O_DX_A_ACS_MINIMUM_POLICED_SIZE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x23"
#define OMP_O_DX_A_ACS_NON_RESERVED_MAX_SDU_SIZE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x28"
#define OMP_O_DX_A_ACS_NON_RESERVED_MIN_POLICED_SIZE        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x29"
#define OMP_O_DX_A_ACS_NON_RESERVED_PEAK_RATE               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x26"
#define OMP_O_DX_A_ACS_NON_RESERVED_TOKEN_SIZE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x27"
#define OMP_O_DX_A_ACS_NON_RESERVED_TX_LIMIT                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0C"
#define OMP_O_DX_A_ACS_NON_RESERVED_TX_SIZE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x02"
#define OMP_O_DX_A_ACS_PERMISSION_BITS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7D"
#define OMP_O_DX_A_ACS_POLICY_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x04"
#define OMP_O_DX_A_ACS_PRIORITY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7C"
#define OMP_O_DX_A_ACS_RSVP_ACCOUNT_FILES_LOCATION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x04"
#define OMP_O_DX_A_ACS_RSVP_LOG_FILES_LOCATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x05"
#define OMP_O_DX_A_ACS_SERVICE_TYPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7A"
#define OMP_O_DX_A_ACS_TIME_OF_DAY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x74"
#define OMP_O_DX_A_ACS_TOTAL_NO_OF_FLOWS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x7B"
#define OMP_O_DX_A_ACS_SERVER_LIST                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x20"
#define OMP_O_DX_A_ADDITIONAL_INFORMATION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x09"
#define OMP_O_DX_A_ADDITIONAL_TRUSTED_SERVICE_NAMES         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x79"
#define OMP_O_DX_A_ADDRESS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x00"
#define OMP_O_DX_A_ADDRESS_BOOK_ROOTS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5C"
#define OMP_O_DX_A_ADDRESS_ENTRY_DISPLAY_TABLE              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x44"
#define OMP_O_DX_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x10"
#define OMP_O_DX_A_ADDRESS_HOME                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x69"
#define OMP_O_DX_A_ADDRESS_SYNTAX                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x7F"
#define OMP_O_DX_A_ADDRESS_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x5E"
#define OMP_O_DX_A_ADMIN_CONTEXT_MENU                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x66"
#define OMP_O_DX_A_ADMIN_COUNT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x16"
#define OMP_O_DX_A_ADMIN_DESCRIPTION                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x62"
#define OMP_O_DX_A_ADMIN_DISPLAY_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x42"
#define OMP_O_DX_A_ADMIN_MULTISELECT_PROPERTY_PAGES         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1A"
#define OMP_O_DX_A_ADMIN_PROPERTY_PAGES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x32"
#define OMP_O_DX_A_ALLOWED_ATTRIBUTES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x11"
#define OMP_O_DX_A_ALLOWED_ATTRIBUTES_EFFECTIVE             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x12"
#define OMP_O_DX_A_ALLOWED_CHILD_CLASSES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0F"
#define OMP_O_DX_A_ALLOWED_CHILD_CLASSES_EFFECTIVE          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x10"
#define OMP_O_DX_A_ALT_SECURITY_IDENTITIES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x63"
#define OMP_O_DX_A_ANR                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x38"
#define OMP_O_DX_A_APP_SCHEMA_VERSION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x50"
#define OMP_O_DX_A_APPLICATION_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5A"
#define OMP_O_DX_A_APPLIES_TO                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x55"
#define OMP_O_DX_A_ASSET_NUMBER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1B"
#define OMP_O_DX_A_ASSISTANT                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0C"
#define OMP_O_DX_A_ASSOC_NT_ACCOUNT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x3D"
#define OMP_O_DX_A_ATTRIBUTE_DISPLAY_NAMES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6C"
#define OMP_O_DX_A_ATTRIBUTE_ID                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x1E"
#define OMP_O_DX_A_ATTRIBUTE_SECURITY_GUID                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x15"
#define OMP_O_DX_A_ATTRIBUTE_SYNTAX                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x20"
#define OMP_O_L0_A_AUDIO                                    "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x37"
#define OMP_O_DX_A_AUDITING_POLICY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4A"
#define OMP_O_DX_A_AUTHENTICATION_OPTIONS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0B"
#define OMP_O_DX_A_AUXILIARY_CLASS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x5F"
#define OMP_O_DX_A_BAD_PASSWORD_TIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x31"
#define OMP_O_DX_A_BAD_PWD_COUNT                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0C"
#define OMP_O_DX_A_BIRTH_LOCATION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4C"
#define OMP_O_DX_A_BRIDGEHEAD_SERVER_LIST_BL                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x34"
#define OMP_O_DX_A_BRIDGEHEAD_TRANSPORT_LIST                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x33"
#define OMP_O_DX_A_BUILTIN_CREATION_TIME                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0D"
#define OMP_O_DX_A_BUILTIN_MODIFIED_COUNT                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0E"
#define OMP_O_DX_A_BYTES_PER_MINUTE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1C"
#define OMP_O_DX_A_CA_CERTIFICATE_DN                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x39"
#define OMP_O_DX_A_CA_CONNECT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2F"
#define OMP_O_DX_A_CA_USAGES                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x32"
#define OMP_O_DX_A_CA_WEB_URL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x30"
#define OMP_O_DX_A_CAN_UPGRADE_SCRIPT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2F"
#define OMP_O_DX_A_CANONICAL_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x14"
#define OMP_O_L1_A_CARLICENSE                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x01"
#define OMP_O_DX_A_CATALOGS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x23"
#define OMP_O_DX_A_CATEGORIES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x20"
#define OMP_O_DX_A_CATEGORY_ID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x42"
#define OMP_O_DX_A_CERTIFICATE_AUTHORITY_OBJECT             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2C"
#define OMP_O_DX_A_CERTIFICATE_TEMPLATES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x37"
#define OMP_O_DX_A_CLASS_DISPLAY_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x62"
#define OMP_O_DX_A_CODE_PAGE                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x10"
#define OMP_O_DX_A_COM_CLASSID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x13"
#define OMP_O_DX_A_COM_CLSID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x79"
#define OMP_O_DX_A_COM_INTERFACEID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x14"
#define OMP_O_DX_A_COM_OTHER_PROG_ID                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7D"
#define OMP_O_DX_A_COM_PROGID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x15"
#define OMP_O_DX_A_COM_TREAT_AS_CLASS_ID                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7B"
#define OMP_O_DX_A_COM_TYPELIB_ID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7E"
#define OMP_O_DX_A_COM_UNIQUE_LIBID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7A"
#define OMP_O_DX_A_COMMENT                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x51"
#define OMP_O_DX_A_COMPANY                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x12"
#define OMP_O_DX_A_CONTENT_INDEXING_ALLOWED                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x18"
#define OMP_O_DX_A_CONTEXT_MENU                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x73"
#define OMP_O_DX_A_CONTROL_ACCESS_RIGHTS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x48"
#define OMP_O_DX_A_COST                                     "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x07"
#define OMP_O_DX_A_COUNTRY_CODE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x19"
#define OMP_O_DX_A_CREATE_DIALOG                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2A"
#define OMP_O_DX_A_CREATE_WIZARD_EXT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2C"
#define OMP_O_DX_A_CREATION_TIME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1A"
#define OMP_O_DX_A_CREATION_WIZARD                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x72"
#define OMP_O_DX_A_CREATOR                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x27"
#define OMP_O_DX_A_CRL_OBJECT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x31"
#define OMP_O_DX_A_CRL_PARTITIONED_REVOCATION_LIST          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2B"
#define OMP_O_DX_A_CURR_MACHINE_ID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x51"
#define OMP_O_DX_A_CURRENT_LOCATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4F"
#define OMP_O_DX_A_CURRENT_PARENT_CA                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x38"
#define OMP_O_DX_A_CURRENT_VALUE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1B"
#define OMP_O_DX_A_DBCS_PWD                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x37"
#define OMP_O_DX_A_DEFAULT_CLASS_STORE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x55"
#define OMP_O_DX_A_DEFAULT_GROUP                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x60"
#define OMP_O_DX_A_DEFAULT_HIDING_VALUE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x06"
#define OMP_O_DX_A_DEFAULT_LOCAL_POLICY_OBJECT              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x39"
#define OMP_O_DX_A_DEFAULT_OBJECT_CATEGORY                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0F"
#define OMP_O_DX_A_DEFAULT_PRIORITY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x68"
#define OMP_O_DX_A_DEFAULT_SECURITY_DESCRIPTOR              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x60"
#define OMP_O_DX_A_DEPARTMENT                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x0D"
#define OMP_O_L1_A_DEPARTMENTNUMBER                         "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x02"
#define OMP_O_DX_A_DESKTOP_PROFILE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x5A"
#define OMP_O_DX_A_DHCP_CLASSES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4B"
#define OMP_O_DX_A_DHCP_FLAGS                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3C"
#define OMP_O_DX_A_DHCP_IDENTIFICATION                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3D"
#define OMP_O_DX_A_DHCP_MASK                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x42"
#define OMP_O_DX_A_DHCP_MAXKEY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4F"
#define OMP_O_DX_A_DHCP_OBJ_DESCRIPTION                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3F"
#define OMP_O_DX_A_DHCP_OBJ_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3E"
#define OMP_O_DX_A_DHCP_OPTIONS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4A"
#define OMP_O_DX_A_DHCP_PROPERTIES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4E"
#define OMP_O_DX_A_DHCP_RANGES                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x43"
#define OMP_O_DX_A_DHCP_RESERVATIONS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x45"
#define OMP_O_DX_A_DHCP_SERVERS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x40"
#define OMP_O_DX_A_DHCP_SITES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x44"
#define OMP_O_DX_A_DHCP_STATE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4D"
#define OMP_O_DX_A_DHCP_SUBNETS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x41"
#define OMP_O_DX_A_DHCP_TYPE                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3B"
#define OMP_O_DX_A_DHCP_UNIQUE_KEY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x3A"
#define OMP_O_DX_A_DHCP_UPDATE_TIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x50"
#define OMP_O_DX_A_DISPLAY_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0D"
#define OMP_O_DX_A_DISPLAY_NAME_PRINTABLE                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x61"
#define OMP_O_DX_A_DIVISION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x05"
#define OMP_O_DX_A_DMD_LOCATION                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x24"
#define OMP_O_DX_A_DMD_NAME                                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x56"
#define OMP_O_DX_A_DN_REFERENCE_UPDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5A"
#define OMP_O_DX_A_DNS_ALLOW_DYNAMIC                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7A"
#define OMP_O_DX_A_DNS_ALLOW_XFR                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7B"
#define OMP_O_DX_A_DNS_HOST_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6B"
#define OMP_O_DX_A_DNS_NOTIFY_SECONDARIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7D"
#define OMP_O_DX_A_DNS_PROPERTY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1A"
#define OMP_O_DX_A_DNS_RECORD                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7E"
#define OMP_O_DX_A_DNS_ROOT                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1C"
#define OMP_O_DX_A_DNS_SECURE_SECONDARIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x7C"
#define OMP_O_DX_A_DNS_TOMBSTONED                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x06"
#define OMP_O_DX_A_DOMAIN_CERTIFICATE_AUTHORITIES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1C"
#define OMP_O_L0_A_DOMAIN_COMPONENT                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x19"
#define OMP_O_DX_A_DOMAIN_CROSS_REF                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x58"
#define OMP_O_DX_A_DOMAIN_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2E"
#define OMP_O_DX_A_DOMAIN_IDENTIFIER                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x73"
#define OMP_O_DX_A_DOMAIN_POLICY_OBJECT                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x20"
#define OMP_O_DX_A_DOMAIN_POLICY_REFERENCE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x26"
#define OMP_O_DX_A_DOMAIN_REPLICA                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1E"
#define OMP_O_DX_A_DOMAIN_WIDE_POLICY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x25"
#define OMP_O_DX_A_DRIVER_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x65"
#define OMP_O_DX_A_DRIVER_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x14"
#define OMP_O_DX_A_DS_CORE_PROPAGATION_DATA                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4D"
#define OMP_O_DX_A_DS_HEURISTICS                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x54"
#define OMP_O_DX_A_DS_UI_ADMIN_MAXIMUM                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x40"
#define OMP_O_DX_A_DS_UI_ADMIN_NOTIFICATION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x3F"
#define OMP_O_DX_A_DS_UI_SHELL_MAXIMUM                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x41"
#define OMP_O_DX_A_DSA_SIGNATURE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x4A"
#define OMP_O_DX_A_DYNAMIC_LDAP_SERVER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x19"
#define OMP_O_L0_A_E_MAIL_ADDRESSES                         "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x03"
#define OMP_O_DX_A_EFSPOLICY                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0C"
#define OMP_O_DX_A_EMPLOYEE_ID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x23"
#define OMP_O_DX_A_EMPLOYEE_NUMBER                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x62"
#define OMP_O_DX_A_EMPLOYEE_TYPE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x65"
#define OMP_O_DX_A_ENABLED                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x2D"
#define OMP_O_DX_A_ENABLED_CONNECTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x24"
#define OMP_O_DX_A_ENROLLMENT_PROVIDERS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x39"
#define OMP_O_DX_A_EXTENDED_ATTRIBUTE_INFO                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0D"
#define OMP_O_DX_A_EXTENDED_CHARS_ALLOWED                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x7C"
#define OMP_O_DX_A_EXTENDED_CLASS_INFO                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0C"
#define OMP_O_DX_A_EXTENSION_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x63"
#define OMP_O_DX_A_EXTRA_COLUMNS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x17"
#define OMP_O_DX_A_FILE_EXT_PRIORITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x30"
#define OMP_O_DX_A_FLAGS                                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x26"
#define OMP_O_DX_A_FLAT_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7F"
#define OMP_O_DX_A_FORCE_LOGOFF                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x27"
#define OMP_O_DX_A_FOREIGN_IDENTIFIER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x64"
#define OMP_O_DX_A_FRIENDLY_NAMES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2A"
#define OMP_O_DX_A_FROM_ENTRY                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x0E"
#define OMP_O_DX_A_FROM_SERVER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x28"
#define OMP_O_DX_A_FRS_COMPUTER_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x65"
#define OMP_O_DX_A_FRS_COMPUTER_REFERENCE_BL                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x66"
#define OMP_O_DX_A_FRS_CONTROL_DATA_CREATION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x67"
#define OMP_O_DX_A_FRS_CONTROL_INBOUND_BACKLOG              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x68"
#define OMP_O_DX_A_FRS_CONTROL_OUTBOUND_BACKLOG             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x69"
#define OMP_O_DX_A_FRS_DIRECTORY_FILTER                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x64"
#define OMP_O_DX_A_FRS_DS_POLL                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6A"
#define OMP_O_DX_A_FRS_EXTENSIONS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x18"
#define OMP_O_DX_A_FRS_FAULT_CONDITION                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6B"
#define OMP_O_DX_A_FRS_FILE_FILTER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x63"
#define OMP_O_DX_A_FRS_FLAGS                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6A"
#define OMP_O_DX_A_FRS_LEVEL_LIMIT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x16"
#define OMP_O_DX_A_FRS_MEMBER_REFERENCE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6B"
#define OMP_O_DX_A_FRS_MEMBER_REFERENCE_BL                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6C"
#define OMP_O_DX_A_FRS_PARTNER_AUTH_LEVEL                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6D"
#define OMP_O_DX_A_FRS_PRIMARY_MEMBER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6E"
#define OMP_O_DX_A_FRS_REPLICA_SET_GUID                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x15"
#define OMP_O_DX_A_FRS_REPLICA_SET_TYPE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x1F"
#define OMP_O_DX_A_FRS_ROOT_PATH                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x67"
#define OMP_O_DX_A_FRS_ROOT_SECURITY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x17"
#define OMP_O_DX_A_FRS_SERVICE_COMMAND                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x74"
#define OMP_O_DX_A_FRS_SERVICE_COMMAND_STATUS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x6F"
#define OMP_O_DX_A_FRS_STAGING_PATH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x68"
#define OMP_O_DX_A_FRS_TIME_LAST_COMMAND                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x70"
#define OMP_O_DX_A_FRS_TIME_LAST_CONFIG_CHANGE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x71"
#define OMP_O_DX_A_FRS_UPDATE_TIMEOUT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x65"
#define OMP_O_DX_A_FRS_VERSION                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x72"
#define OMP_O_DX_A_FRS_VERSION_GUID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2B"
#define OMP_O_DX_A_FRS_WORKING_PATH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x66"
#define OMP_O_DX_A_FSMO_ROLE_OWNER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x71"
#define OMP_O_DX_A_GARBAGE_COLL_PERIOD                      "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x2D"
#define OMP_O_DX_A_GENERATED_CONNECTION                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x29"
#define OMP_O_DX_A_GLOBAL_ADDRESS_LIST                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5D"
#define OMP_O_DX_A_GOVERNS_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x16"
#define OMP_O_DX_A_GP_LINK                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7B"
#define OMP_O_DX_A_GP_OPTIONS                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7C"
#define OMP_O_DX_A_GPC_FILE_SYS_PATH                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7E"
#define OMP_O_DX_A_GPC_FUNCTIONALITY_VERSION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7D"
#define OMP_O_DX_A_GPC_MACHINE_EXTENSION_NAMES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x44"
#define OMP_O_DX_A_GPC_USER_EXTENSION_NAMES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x45"
#define OMP_O_DX_A_GPC_WQL_FILTER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1E"
#define OMP_O_DX_A_GROUP_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x18"
#define OMP_O_DX_A_GROUP_MEMBERSHIP_SAM                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x26"
#define OMP_O_DX_A_GROUP_PRIORITY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x59"
#define OMP_O_DX_A_GROUP_TYPE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6E"
#define OMP_O_DX_A_GROUPS_TO_IGNORE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x58"
#define OMP_O_DX_A_HAS_MASTER_NCS                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0E"
#define OMP_O_DX_A_HAS_PARTIAL_REPLICA_NCS                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x0F"
#define OMP_O_DX_A_HELP_DATA16                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x12"
#define OMP_O_DX_A_HELP_DATA32                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x09"
#define OMP_O_DX_A_HELP_FILE_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x47"
#define OMP_O_DX_A_HIDE_FROM_AB                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x74"
#define OMP_O_DX_A_HOME_DIRECTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2C"
#define OMP_O_DX_A_HOME_DRIVE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x2D"
#define OMP_O_DX_A_ICON_PATH                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5B"
#define OMP_O_DX_A_IMPLEMENTED_CATEGORIES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x40"
#define OMP_O_DX_A_INDEXEDSCOPES                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x29"
#define OMP_O_DX_A_INITIAL_AUTH_INCOMING                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1B"
#define OMP_O_DX_A_INITIAL_AUTH_OUTGOING                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1C"
#define OMP_O_DX_A_INSTALL_UI_LEVEL                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4F"
#define OMP_O_DX_A_INSTANCE_TYPE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x01"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_FAILOVER             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x60"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_GENERATOR            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5E"
#define OMP_O_DX_A_INTER_SITE_TOPOLOGY_RENEW                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5F"
#define OMP_O_DX_A_INVOCATION_ID                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x73"
#define OMP_O_DX_A_IPSEC_DATA                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6F"
#define OMP_O_DX_A_IPSEC_DATA_TYPE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6E"
#define OMP_O_DX_A_IPSEC_FILTER_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x75"
#define OMP_O_DX_A_IPSEC_ID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6D"
#define OMP_O_DX_A_IPSEC_ISAKMP_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x72"
#define OMP_O_DX_A_IPSEC_NAME                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6C"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_ACTION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x78"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_REFERENCE       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x74"
#define OMP_O_DX_A_IPSEC_NEGOTIATION_POLICY_TYPE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x77"
#define OMP_O_DX_A_IPSEC_NFA_REFERENCE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x73"
#define OMP_O_DX_A_IPSEC_OWNERS_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x70"
#define OMP_O_DX_A_IPSEC_POLICY_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x05"
#define OMP_O_DX_A_IS_CRITICAL_SYSTEM_OBJECT                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x64"
#define OMP_O_DX_A_IS_DEFUNCT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x15"
#define OMP_O_DX_A_IS_DELETED                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x30"
#define OMP_O_DX_A_IS_EPHEMERAL                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x3C"
#define OMP_O_DX_A_IS_MEMBER_OF_DL                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x66"
#define OMP_O_DX_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7F"
#define OMP_O_DX_A_IS_PRIVILEGE_HOLDER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7E"
#define OMP_O_DX_A_IS_SINGLE_VALUED                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x21"
#define OMP_O_L0_A_JPEGPHOTO                                "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x3C"
#define OMP_O_DX_A_KEYWORDS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x30"
#define OMP_O_DX_A_LAST_BACKUP_RESTORATION_TIME             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x07"
#define OMP_O_DX_A_LAST_CONTENT_INDEXED                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x32"
#define OMP_O_DX_A_LAST_KNOWN_PARENT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0D"
#define OMP_O_DX_A_LAST_LOGOFF                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x33"
#define OMP_O_DX_A_LAST_LOGON                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x34"
#define OMP_O_DX_A_LAST_LOGON_TIMESTAMP                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x20"
#define OMP_O_DX_A_LAST_SET_TIME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x35"
#define OMP_O_DX_A_LAST_UPDATE_SEQUENCE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4A"
#define OMP_O_DX_A_LDAP_ADMIN_LIMITS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4B"
#define OMP_O_DX_A_LDAP_DISPLAY_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x4C"
#define OMP_O_DX_A_LDAP_IPDENY_LIST                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4C"
#define OMP_O_DX_A_LEGACY_EXCHANGE_DN                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0F"
#define OMP_O_DX_A_LINK_ID                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x32"
#define OMP_O_DX_A_LINK_TRACK_SECRET                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0D"
#define OMP_O_DX_A_LM_PWD_HISTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x20"
#define OMP_O_DX_A_LOCAL_POLICY_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x38"
#define OMP_O_DX_A_LOCAL_POLICY_REFERENCE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x49"
#define OMP_O_DX_A_LOCALE_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3A"
#define OMP_O_DX_A_LOCALIZED_DESCRIPTION                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x31"
#define OMP_O_DX_A_LOCALIZATION_DISPLAY_ID                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x49"
#define OMP_O_DX_A_LOCATION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5E"
#define OMP_O_DX_A_LOCK_OUT_OBSERVATION_WINDOW              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3D"
#define OMP_O_DX_A_LOCKOUT_DURATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3C"
#define OMP_O_DX_A_LOCKOUT_THRESHOLD                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x49"
#define OMP_O_DX_A_LOCKOUT_TIME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x16"
#define OMP_O_L1_A_LOGO                                     "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x24"
#define OMP_O_DX_A_LOGON_COUNT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x29"
#define OMP_O_DX_A_LOGON_HOURS                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x40"
#define OMP_O_DX_A_LOGON_WORKSTATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x41"
#define OMP_O_DX_A_LSA_CREATION_TIME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x42"
#define OMP_O_DX_A_LSA_MODIFIED_COUNT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x43"
#define OMP_O_DX_A_MACHINE_ARCHITECTURE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x44"
#define OMP_O_DX_A_MACHINE_PASSWORD_CHANGE_INTERVAL         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x08"
#define OMP_O_DX_A_MACHINE_ROLE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x47"
#define OMP_O_DX_A_MACHINE_WIDE_POLICY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x4B"
#define OMP_O_DX_A_MANAGED_BY                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0D"
#define OMP_O_DX_A_MANAGED_OBJECTS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0E"
#define OMP_O_L0_A_MANAGER                                  "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x0A"
#define OMP_O_DX_A_MAPI_ID                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x31"
#define OMP_O_DX_A_MARSHALLED_INTERFACE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x48"
#define OMP_O_DX_A_MASTERED_BY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x01"
#define OMP_O_DX_A_MAX_PWD_AGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4A"
#define OMP_O_DX_A_MAX_RENEW_AGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4B"
#define OMP_O_DX_A_MAX_STORAGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4C"
#define OMP_O_DX_A_MAX_TICKET_AGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4D"
#define OMP_O_DX_A_MAY_CONTAIN                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x19"
#define OMP_O_DX_A_MEETINGADVERTISESCOPE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x46"
#define OMP_O_DX_A_MEETINGAPPLICATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3D"
#define OMP_O_DX_A_MEETINGBANDWIDTH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4D"
#define OMP_O_DX_A_MEETINGBLOB                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4E"
#define OMP_O_DX_A_MEETINGCONTACTINFO                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x42"
#define OMP_O_DX_A_MEETINGDESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x37"
#define OMP_O_DX_A_MEETINGENDTIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4C"
#define OMP_O_DX_A_MEETINGID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x35"
#define OMP_O_DX_A_MEETINGIP                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x44"
#define OMP_O_DX_A_MEETINGISENCRYPTED                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x49"
#define OMP_O_DX_A_MEETINGKEYWORD                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x38"
#define OMP_O_DX_A_MEETINGLANGUAGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3E"
#define OMP_O_DX_A_MEETINGLOCATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x39"
#define OMP_O_DX_A_MEETINGMAXPARTICIPANTS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x40"
#define OMP_O_DX_A_MEETINGNAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x36"
#define OMP_O_DX_A_MEETINGORIGINATOR                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x41"
#define OMP_O_DX_A_MEETINGOWNER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x43"
#define OMP_O_DX_A_MEETINGPROTOCOL                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3A"
#define OMP_O_DX_A_MEETINGRATING                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x48"
#define OMP_O_DX_A_MEETINGRECURRENCE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4A"
#define OMP_O_DX_A_MEETINGSCOPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x45"
#define OMP_O_DX_A_MEETINGSTARTTIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x4B"
#define OMP_O_DX_A_MEETINGTYPE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x3B"
#define OMP_O_DX_A_MEETINGURL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x47"
#define OMP_O_DX_A_MHS_OR_ADDRESS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0A"
#define OMP_O_DX_A_MIN_PWD_AGE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4E"
#define OMP_O_DX_A_MIN_PWD_LENGTH                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x4F"
#define OMP_O_DX_A_MIN_TICKET_AGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x50"
#define OMP_O_DX_A_MODIFIED_COUNT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x28"
#define OMP_O_DX_A_MODIFIED_COUNT_AT_LAST_PROM              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x51"
#define OMP_O_DX_A_MONIKER                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x52"
#define OMP_O_DX_A_MONIKER_DISPLAY_NAME                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x53"
#define OMP_O_DX_A_MOVE_TREE_STATE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x19"
#define OMP_O_DX_A_MS_COM_DEFAULTPARTITIONLINK              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x13"
#define OMP_O_DX_A_MS_COM_OBJECTID                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x14"
#define OMP_O_DX_A_MS_COM_PARTITIONLINK                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x0F"
#define OMP_O_DX_A_MS_COM_PARTITIONSETLINK                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x10"
#define OMP_O_DX_A_MS_COM_USERLINK                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x11"
#define OMP_O_DX_A_MS_COM_USERPARTITIONSETLINK              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x12"
#define OMP_O_DX_A_MS_DS_ADDITIONAL_DNS_HOST_NAME           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x35"
#define OMP_O_DX_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x36"
#define OMP_O_DX_A_MS_DS_ALL_USERS_TRUST_QUOTA              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7D"
#define OMP_O_DX_A_MS_DS_ALLOWED_DNS_SUFFIXES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2E"
#define OMP_O_DX_A_MS_DS_ALLOWED_TO_DELEGATE_TO             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7B"
#define OMP_O_DX_A_MS_DS_AUXILIARY_CLASSES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x32"
#define OMP_O_DX_A_MS_DS_APPROX_IMMED_SUBORDINATES          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x05"
#define OMP_O_DX_A_MS_DS_BEHAVIOR_VERSION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x33"
#define OMP_O_DX_A_MS_DS_CACHED_MEMBERSHIP                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x21"
#define OMP_O_DX_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x22"
#define OMP_O_DX_A_MS_DS_CONSISTENCY_GUID                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x50"
#define OMP_O_DX_A_MS_DS_CONSISTENCY_CHILD_COUNT            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x51"
#define OMP_O_DX_A_MS_DS_CREATOR_SID                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x02"
#define OMP_O_DX_A_MS_DS_DNSROOTALIAS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x37"
#define OMP_O_DX_A_MS_DS_ENTRY_TIME_TO_DIE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x56"
#define OMP_O_DX_A_MS_DS_EXECUTESCRIPTPASSWORD              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x77"
#define OMP_O_DX_A_MS_DS_FILTER_CONTAINERS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x27"
#define OMP_O_DX_A_MS_DS_HAS_INSTANTIATED_NCS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2D"
#define OMP_O_DX_A_MS_DS_INTID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x34"
#define OMP_O_DX_A_MS_DS_LOGON_TIME_SYNC_INTERVAL           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x78"
#define OMP_O_DX_A_MS_DS_TRUST_FOREST_TRUST_INFO            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x26"
#define OMP_O_DX_A_MS_DS_MACHINE_ACCOUNT_QUOTA              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x03"
#define OMP_O_DX_A_MS_DS_OTHER_SETTINGS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x55"
#define OMP_O_DX_A_MS_DS_NC_REPL_CURSORS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x28"
#define OMP_O_DX_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x29"
#define OMP_O_DX_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2A"
#define OMP_O_DX_A_MS_DS_NC_REPLICA_LOCATIONS               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x7D"
#define OMP_O_DX_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x19"
#define OMP_O_DX_A_MS_DS_PER_USER_TRUST_QUOTA               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7C"
#define OMP_O_DX_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7E"
#define OMP_O_DX_A_MS_DS_PREFERRED_GC_SITE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x24"
#define OMP_O_DX_A_MS_DS_REPL_ATTRIBUTE_META_DATA           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2B"
#define OMP_O_DX_A_MS_DS_REPL_VALUE_META_DATA               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2C"
#define OMP_O_DX_A_MS_DS_REPLICATES_NC_REASON               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x00"
#define OMP_O_DX_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x7F"
#define OMP_O_DX_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_ "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x00"
#define OMP_O_DX_A_MS_DS_REPLICATIONEPOCH                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x38"
#define OMP_O_DX_A_MS_DS_SCHEMA_EXTENSIONS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x20"
#define OMP_O_DX_A_MS_DS_SD_REFERENCE_DOMAIN                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x2F"
#define OMP_O_DX_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x18"
#define OMP_O_DX_A_MS_DS_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x21"
#define OMP_O_DX_A_MS_DS_SITE_AFFINITY                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x23"
#define OMP_O_DX_A_MS_DS_SPN_SUFFIXES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x33"
#define OMP_O_DX_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x34"
#define OMP_O_DX_A_MS_DS_UPDATESCRIPT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x39"
#define OMP_O_DX_A_MS_EXCH_ASSISTANT_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x3C"
#define OMP_O_DX_A_MS_EXCH_LABELEDURI                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x51"
#define OMP_O_DX_A_MS_EXCH_OWNER_BL                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x68"
#define OMP_O_DX_A_MS_FRS_HUB_MEMBER                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1D"
#define OMP_O_DX_A_MS_FRS_TOPOLOGY_PREF                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1C"
#define OMP_O_DX_A_MS_IIS_FTP_DIR                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x7A"
#define OMP_O_DX_A_MS_IIS_FTP_ROOT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x79"
#define OMP_O_DX_A_MS_MMS_DATA                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x3C"
#define OMP_O_DX_A_MS_MMS_INDEX                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x3D"
#define OMP_O_DX_A_MS_MMS_INDICE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x3E"
#define OMP_O_DX_A_MS_MMS_XML                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x3F"
#define OMP_O_DX_A_MS_MMS_JOIN_LINK                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x40"
#define OMP_O_DX_A_MS_MMS_LINEAGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x41"
#define OMP_O_DX_A_MS_MMS_PROV_STATUS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x42"
#define OMP_O_DX_A_MS_MMS_SYNC_STATUS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x43"
#define OMP_O_DX_A_MS_MMS_PARTITION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x44"
#define OMP_O_DX_A_MS_MMS_MA_STAGING_LINK                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x45"
#define OMP_O_DX_A_MS_MMS_MA_STAGING_BL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x46"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_LINK                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x47"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_BL                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x48"
#define OMP_O_DX_A_MS_MMS_ASSOCIATED_LINK                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x49"
#define OMP_O_DX_A_MS_MMS_ASSOCIATED_BL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4A"
#define OMP_O_DX_A_MS_MMS_SCOPE_LINK                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4B"
#define OMP_O_DX_A_MS_MMS_SCOPE_BL                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4C"
#define OMP_O_DX_A_MS_MMS_CRITERIA                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4D"
#define OMP_O_DX_A_MS_MMS_DOMAIN_CONTROLLER                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4E"
#define OMP_O_DX_A_MS_MMS_SERVICE_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x4F"
#define OMP_O_DX_A_MS_MMS_INSTANCE_CONFIGURATION            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x50"
#define OMP_O_DX_A_MS_MMS_TOOLS_CONFIGURATION               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x51"
#define OMP_O_DX_A_MS_MMS_INSTANCE_RULE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x52"
#define OMP_O_DX_A_MS_MMS_INSTALL_STATUS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x53"
#define OMP_O_DX_A_MS_MMS_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x54"
#define OMP_O_DX_A_MS_MMS_CONNECTOR_SPACE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x55"
#define OMP_O_DX_A_MS_MMS_SCOPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x56"
#define OMP_O_DX_A_MS_MMS_INSTANCE_SCHEDULE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x57"
#define OMP_O_DX_A_MS_MMS_INSTANCE_INFO                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x58"
#define OMP_O_DX_A_MS_MMS_MA_CONFIGURATION                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x59"
#define OMP_O_DX_A_MS_MMS_MA_CONFIGURATION_PRIVATE          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5A"
#define OMP_O_DX_A_MS_MMS_MA_SCHEMA                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5B"
#define OMP_O_DX_A_MS_MMS_MA_MAP                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5C"
#define OMP_O_DX_A_MS_MMS_MA_CAPABILITY                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5D"
#define OMP_O_DX_A_MS_MMS_MA_EXECUTION_HISTORY              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5E"
#define OMP_O_DX_A_MS_MMS_MA_CATEGORY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x5F"
#define OMP_O_DX_A_MS_MMS_MA_AD_INFO                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x60"
#define OMP_O_DX_A_MS_MMS_MA_CD_INFO                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x61"
#define OMP_O_DX_A_MS_MMS_MA_PROCESS_INFO                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x62"
#define OMP_O_DX_A_MS_MMS_MA_SCRIPT_INFO                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x63"
#define OMP_O_DX_A_MS_MMS_MA_SYSTEM                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x64"
#define OMP_O_DX_A_MS_MMS_MA_SYNCHRONIZATION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x65"
#define OMP_O_DX_A_MS_MMS_JOIN_BL                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x66"
#define OMP_O_DX_A_MS_MMS_ANCHOR                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x67"
#define OMP_O_DX_A_MS_MMS_EXPORT_KEY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x68"
#define OMP_O_DX_A_MS_MMS_IMPORT_KEY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x69"
#define OMP_O_DX_A_MS_MMS_STATE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6A"
#define OMP_O_DX_A_MS_MMS_HOLOGRAM                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6B"
#define OMP_O_DX_A_MS_MMS_DELTA_HOLOGRAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6C"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_CONFIGURATION        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6D"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_CONFIGURATION_PRIVAT "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6E"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_AD_INFO              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x6F"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_SYSTEM               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x70"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_STATUS_XML           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x71"
#define OMP_O_DX_A_MS_MMS_PROVISIONING_STATUS_BINARY        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x72"
#define OMP_O_DX_A_MS_PKI_CERT_TEMPLATE_OID                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1C"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0A"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_NAME_FLAG             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x18"
#define OMP_O_DX_A_MS_PKI_CERTIFICATE_POLICY                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1F"
#define OMP_O_DX_A_MS_PKI_ENROLLMENT_FLAG                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x16"
#define OMP_O_DX_A_MS_PKI_MINIMAL_KEY_SIZE                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x19"
#define OMP_O_DX_A_MS_PKI_OID_ATTRIBUTE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x07"
#define OMP_O_DX_A_MS_PKI_OID_CPS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x08"
#define OMP_O_DX_A_MS_PKI_OID_LOCALIZEDNAME                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x30"
#define OMP_O_DX_A_MS_PKI_OID_USER_NOTICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x09"
#define OMP_O_DX_A_MS_PKI_PRIVATE_KEY_FLAG                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x17"
#define OMP_O_DX_A_MS_PKI_SUPERSEDE_TEMPLATES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1D"
#define OMP_O_DX_A_MS_PKI_TEMPLATE_MINOR_REVISION           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1B"
#define OMP_O_DX_A_MS_PKI_TEMPLATE_SCHEMA_VERSION           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1A"
#define OMP_O_DX_A_MS_PKI_RA_APPLICATION_POLICIES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0B"
#define OMP_O_DX_A_MS_PKI_RA_POLICIES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x1E"
#define OMP_O_DX_A_MS_PKI_RA_SIGNATURE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x15"
#define OMP_O_DX_A_MS_RRAS_ATTRIBUTE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x74"
#define OMP_O_DX_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x73"
#define OMP_O_DX_A_MS_SQL_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x53"
#define OMP_O_DX_A_MS_SQL_REGISTEREDOWNER                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x54"
#define OMP_O_DX_A_MS_SQL_CONTACT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x55"
#define OMP_O_DX_A_MS_SQL_LOCATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x56"
#define OMP_O_DX_A_MS_SQL_MEMORY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x57"
#define OMP_O_DX_A_MS_SQL_BUILD                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x58"
#define OMP_O_DX_A_MS_SQL_SERVICEACCOUNT                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x59"
#define OMP_O_DX_A_MS_SQL_CHARACTERSET                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5A"
#define OMP_O_DX_A_MS_SQL_SORTORDER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5B"
#define OMP_O_DX_A_MS_SQL_UNICODESORTORDER                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5C"
#define OMP_O_DX_A_MS_SQL_CLUSTERED                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5D"
#define OMP_O_DX_A_MS_SQL_NAMEDPIPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5E"
#define OMP_O_DX_A_MS_SQL_MULTIPROTOCOL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x5F"
#define OMP_O_DX_A_MS_SQL_SPX                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x60"
#define OMP_O_DX_A_MS_SQL_TCPIP                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x61"
#define OMP_O_DX_A_MS_SQL_APPLETALK                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x62"
#define OMP_O_DX_A_MS_SQL_VINES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x63"
#define OMP_O_DX_A_MS_SQL_STATUS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x64"
#define OMP_O_DX_A_MS_SQL_LASTUPDATEDDATE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x65"
#define OMP_O_DX_A_MS_SQL_INFORMATIONURL                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x66"
#define OMP_O_DX_A_MS_SQL_CONNECTIONURL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x67"
#define OMP_O_DX_A_MS_SQL_PUBLICATIONURL                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x68"
#define OMP_O_DX_A_MS_SQL_GPSLATITUDE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x69"
#define OMP_O_DX_A_MS_SQL_GPSLONGITUDE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6A"
#define OMP_O_DX_A_MS_SQL_GPSHEIGHT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6B"
#define OMP_O_DX_A_MS_SQL_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6C"
#define OMP_O_DX_A_MS_SQL_LANGUAGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6D"
#define OMP_O_DX_A_MS_SQL_DESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6E"
#define OMP_O_DX_A_MS_SQL_TYPE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x6F"
#define OMP_O_DX_A_MS_SQL_INFORMATIONDIRECTORY              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x70"
#define OMP_O_DX_A_MS_SQL_DATABASE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x71"
#define OMP_O_DX_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x72"
#define OMP_O_DX_A_MS_SQL_ALIAS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x73"
#define OMP_O_DX_A_MS_SQL_SIZE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x74"
#define OMP_O_DX_A_MS_SQL_CREATIONDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x75"
#define OMP_O_DX_A_MS_SQL_LASTBACKUPDATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x76"
#define OMP_O_DX_A_MS_SQL_LASTDIAGNOSTICDATE                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x77"
#define OMP_O_DX_A_MS_SQL_APPLICATIONS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x78"
#define OMP_O_DX_A_MS_SQL_KEYWORDS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x79"
#define OMP_O_DX_A_MS_SQL_PUBLISHER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7A"
#define OMP_O_DX_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7B"
#define OMP_O_DX_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTIO "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7C"
#define OMP_O_DX_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7D"
#define OMP_O_DX_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7E"
#define OMP_O_DX_A_MS_SQL_THIRDPARTY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x7F"
#define OMP_O_DX_A_MS_TAPI_CONFERENCE_BLOB                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x24"
#define OMP_O_DX_A_MS_TAPI_IP_ADDRESS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x25"
#define OMP_O_DX_A_MS_TAPI_PROTOCOL_ID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x23"
#define OMP_O_DX_A_MS_TAPI_UNIQUE_IDENTIFIER                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x22"
#define OMP_O_DX_A_MS_WMI_AUTHOR                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x57"
#define OMP_O_DX_A_MS_WMI_CHANGEDATE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x58"
#define OMP_O_DX_A_MS_WMI_CLASS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0C"
#define OMP_O_DX_A_MS_WMI_CLASSDEFINITION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x59"
#define OMP_O_DX_A_MS_WMI_CREATIONDATE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5A"
#define OMP_O_DX_A_MS_WMI_GENUS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0D"
#define OMP_O_DX_A_MS_WMI_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5B"
#define OMP_O_DX_A_MS_WMI_INTDEFAULT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5C"
#define OMP_O_DX_A_MS_WMI_INTFLAGS1                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0E"
#define OMP_O_DX_A_MS_WMI_INTFLAGS2                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x0F"
#define OMP_O_DX_A_MS_WMI_INTFLAGS3                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x10"
#define OMP_O_DX_A_MS_WMI_INTFLAGS4                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x11"
#define OMP_O_DX_A_MS_WMI_INTMAX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5D"
#define OMP_O_DX_A_MS_WMI_INTMIN                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5E"
#define OMP_O_DX_A_MS_WMI_INTVALIDVALUES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x5F"
#define OMP_O_DX_A_MS_WMI_INT8DEFAULT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x60"
#define OMP_O_DX_A_MS_WMI_INT8MAX                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x61"
#define OMP_O_DX_A_MS_WMI_INT8MIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x62"
#define OMP_O_DX_A_MS_WMI_INT8VALIDVALUES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x63"
#define OMP_O_DX_A_MS_WMI_MOF                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x66"
#define OMP_O_DX_A_MS_WMI_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x67"
#define OMP_O_DX_A_MS_WMI_NORMALIZEDCLASS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x68"
#define OMP_O_DX_A_MS_WMI_PARM1                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x12"
#define OMP_O_DX_A_MS_WMI_PARM2                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x13"
#define OMP_O_DX_A_MS_WMI_PARM3                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x14"
#define OMP_O_DX_A_MS_WMI_PARM4                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x15"
#define OMP_O_DX_A_MS_WMI_PROPERTYNAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x69"
#define OMP_O_DX_A_MS_WMI_QUERY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6A"
#define OMP_O_DX_A_MS_WMI_QUERYLANGUAGE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6B"
#define OMP_O_DX_A_MS_WMI_SCOPEGUID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x16"
#define OMP_O_DX_A_MS_WMI_SOURCEORGANIZATION                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6C"
#define OMP_O_DX_A_MS_WMI_STRINGDEFAULT                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x64"
#define OMP_O_DX_A_MS_WMI_STRINGVALIDVALUES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x65"
#define OMP_O_DX_A_MS_WMI_TARGETCLASS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6D"
#define OMP_O_DX_A_MS_WMI_TARGETNAMESPACE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6E"
#define OMP_O_DX_A_MS_WMI_TARGETOBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x6F"
#define OMP_O_DX_A_MS_WMI_TARGETPATH                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x70"
#define OMP_O_DX_A_MS_WMI_TARGETTYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8C\x71"
#define OMP_O_DX_A_MSCOPE_ID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x4C"
#define OMP_O_DX_A_MSI_FILE_LIST                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1F"
#define OMP_O_DX_A_MSI_SCRIPT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2E"
#define OMP_O_DX_A_MSI_SCRIPT_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4D"
#define OMP_O_DX_A_MSI_SCRIPT_PATH                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x0F"
#define OMP_O_DX_A_MSI_SCRIPT_SIZE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x4E"
#define OMP_O_DX_A_MSMQ_AUTHENTICATE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1B"
#define OMP_O_DX_A_MSMQ_BASE_PRIORITY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x18"
#define OMP_O_DX_A_MSMQ_COMPUTER_TYPE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x25"
#define OMP_O_DX_A_MSMQ_COMPUTER_TYPE_EX                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x09"
#define OMP_O_DX_A_MSMQ_COST                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x32"
#define OMP_O_DX_A_MSMQ_CSP_NAME                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2C"
#define OMP_O_DX_A_MSMQ_DEPENDENT_CLIENT_SERVICE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x57"
#define OMP_O_DX_A_MSMQ_DEPENDENT_CLIENT_SERVICES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4A"
#define OMP_O_DX_A_MSMQ_DIGESTS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x34"
#define OMP_O_DX_A_MSMQ_DIGESTS_MIG                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x46"
#define OMP_O_DX_A_MSMQ_DS_SERVICE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x56"
#define OMP_O_DX_A_MSMQ_DS_SERVICES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4C"
#define OMP_O_DX_A_MSMQ_ENCRYPT_KEY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x28"
#define OMP_O_DX_A_MSMQ_FOREIGN                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x26"
#define OMP_O_DX_A_MSMQ_IN_ROUTING_SERVERS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x21"
#define OMP_O_DX_A_MSMQ_INTERVAL1                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1C"
#define OMP_O_DX_A_MSMQ_INTERVAL2                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1D"
#define OMP_O_DX_A_MSMQ_JOURNAL                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x16"
#define OMP_O_DX_A_MSMQ_JOURNAL_QUOTA                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x19"
#define OMP_O_DX_A_MSMQ_LABEL                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1A"
#define OMP_O_DX_A_MSMQ_LABEL_EX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x07"
#define OMP_O_DX_A_MSMQ_LONG_LIVED                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2D"
#define OMP_O_DX_A_MSMQ_MIGRATED                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x38"
#define OMP_O_DX_A_MSMQ_MULTICAST_ADDRESS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x32"
#define OMP_O_DX_A_MSMQ_NAME_STYLE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2B"
#define OMP_O_DX_A_MSMQ_NT4_FLAGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x44"
#define OMP_O_DX_A_MSMQ_NT4_STUB                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x40"
#define OMP_O_DX_A_MSMQ_OS_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x27"
#define OMP_O_DX_A_MSMQ_OUT_ROUTING_SERVERS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x20"
#define OMP_O_DX_A_MSMQ_OWNER_ID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1D"
#define OMP_O_DX_A_MSMQ_PREV_SITE_GATES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x49"
#define OMP_O_DX_A_MSMQ_PRIVACY_LEVEL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1C"
#define OMP_O_DX_A_MSMQ_QM_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x37"
#define OMP_O_DX_A_MSMQ_QUEUE_JOURNAL_QUOTA                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x43"
#define OMP_O_DX_A_MSMQ_QUEUE_NAME_EXT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x5B"
#define OMP_O_DX_A_MSMQ_QUEUE_QUOTA                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x42"
#define OMP_O_DX_A_MSMQ_QUEUE_TYPE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x15"
#define OMP_O_DX_A_MSMQ_QUOTA                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x17"
#define OMP_O_DX_A_MSMQ_RECIPIENT_FORMATNAME                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x1F"
#define OMP_O_DX_A_MSMQ_ROUTING_SERVICE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x55"
#define OMP_O_DX_A_MSMQ_ROUTING_SERVICES                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x4B"
#define OMP_O_DX_A_MSMQ_SECURED_SOURCE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8D\x31"
#define OMP_O_DX_A_MSMQ_SERVICE_TYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x22"
#define OMP_O_DX_A_MSMQ_SERVICES                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x36"
#define OMP_O_DX_A_MSMQ_SIGN_CERTIFICATES                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x33"
#define OMP_O_DX_A_MSMQ_SIGN_CERTIFICATES_MIG               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x47"
#define OMP_O_DX_A_MSMQ_SIGN_KEY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x29"
#define OMP_O_DX_A_MSMQ_SITE_1                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2F"
#define OMP_O_DX_A_MSMQ_SITE_2                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x30"
#define OMP_O_DX_A_MSMQ_SITE_FOREIGN                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x41"
#define OMP_O_DX_A_MSMQ_SITE_GATES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x31"
#define OMP_O_DX_A_MSMQ_SITE_GATES_MIG                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1E"
#define OMP_O_DX_A_MSMQ_SITE_ID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x39"
#define OMP_O_DX_A_MSMQ_SITE_NAME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x45"
#define OMP_O_DX_A_MSMQ_SITE_NAME_EX                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x08"
#define OMP_O_DX_A_MSMQ_SITES                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1F"
#define OMP_O_DX_A_MSMQ_TRANSACTIONAL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x1E"
#define OMP_O_DX_A_MSMQ_USER_SID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x39"
#define OMP_O_DX_A_MSMQ_VERSION                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x2E"
#define OMP_O_DX_A_MSNPALLOWDIALIN                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x5F"
#define OMP_O_DX_A_MSNPCALLEDSTATIONID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x63"
#define OMP_O_DX_A_MSNPCALLINGSTATIONID                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x64"
#define OMP_O_DX_A_MSNPSAVEDCALLINGSTATIONID                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x6A"
#define OMP_O_DX_A_MSRADIUSCALLBACKNUMBER                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x88\x79"
#define OMP_O_DX_A_MSRADIUSFRAMEDIPADDRESS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x01"
#define OMP_O_DX_A_MSRADIUSFRAMEDROUTE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x06"
#define OMP_O_DX_A_MSRADIUSSERVICETYPE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x13"
#define OMP_O_DX_A_MSRASSAVEDCALLBACKNUMBER                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x25"
#define OMP_O_DX_A_MSRASSAVEDFRAMEDIPADDRESS                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x26"
#define OMP_O_DX_A_MSRASSAVEDFRAMEDROUTE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x27"
#define OMP_O_DX_A_MUST_CONTAIN                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x18"
#define OMP_O_DX_A_NAME_SERVICE_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x71"
#define OMP_O_DX_A_NC_NAME                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x10"
#define OMP_O_DX_A_NETBIOS_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x57"
#define OMP_O_DX_A_NETBOOT_ALLOW_NEW_CLIENTS                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x51"
#define OMP_O_DX_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x56"
#define OMP_O_DX_A_NETBOOT_ANSWER_REQUESTS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x55"
#define OMP_O_DX_A_NETBOOT_CURRENT_CLIENT_COUNT             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x54"
#define OMP_O_DX_A_NETBOOT_GUID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x67"
#define OMP_O_DX_A_NETBOOT_INITIALIZATION                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x66"
#define OMP_O_DX_A_NETBOOT_INTELLIMIRROR_OSES               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x59"
#define OMP_O_DX_A_NETBOOT_LIMIT_CLIENTS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x52"
#define OMP_O_DX_A_NETBOOT_LOCALLY_INSTALLED_OSES           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5B"
#define OMP_O_DX_A_NETBOOT_MACHINE_FILE_PATH                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x69"
#define OMP_O_DX_A_NETBOOT_MAX_CLIENTS                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x53"
#define OMP_O_DX_A_NETBOOT_MIRROR_DATA_FILE                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x59"
#define OMP_O_DX_A_NETBOOT_NEW_MACHINE_NAMING_POLICY        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x57"
#define OMP_O_DX_A_NETBOOT_NEW_MACHINE_OU                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x58"
#define OMP_O_DX_A_NETBOOT_SCP_BL                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x60"
#define OMP_O_DX_A_NETBOOT_SERVER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5C"
#define OMP_O_DX_A_NETBOOT_SIF_FILE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x58"
#define OMP_O_DX_A_NETBOOT_TOOLS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x5A"
#define OMP_O_DX_A_NETWORK_ADDRESS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x4B"
#define OMP_O_DX_A_NEXT_LEVEL_STORE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x56"
#define OMP_O_DX_A_NEXT_RID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x58"
#define OMP_O_DX_A_NON_SECURITY_MEMBER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x12"
#define OMP_O_DX_A_NON_SECURITY_MEMBER_BL                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x13"
#define OMP_O_DX_A_NOTIFICATION_LIST                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2F"
#define OMP_O_DX_A_NT_GROUP_MEMBERS                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x59"
#define OMP_O_DX_A_NT_MIXED_DOMAIN                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x65"
#define OMP_O_DX_A_NT_PWD_HISTORY                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5E"
#define OMP_O_DX_A_NT_SECURITY_DESCRIPTOR                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x19"
#define OMP_O_DX_A_OBJECT_CATEGORY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x0E"
#define OMP_O_DX_A_OBJECT_CLASS_CATEGORY                    "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x72"
#define OMP_O_DX_A_OBJECT_COUNT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7A"
#define OMP_O_DX_A_OBJECT_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x02"
#define OMP_O_DX_A_OBJECT_SID                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x12"
#define OMP_O_DX_A_OBJECT_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x4C"
#define OMP_O_DX_A_OEM_INFORMATION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x17"
#define OMP_O_DX_A_OM_OBJECT_CLASS                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x5A"
#define OMP_O_DX_A_OM_SYNTAX                                "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x67"
#define OMP_O_DX_A_OMT_GUID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x79"
#define OMP_O_DX_A_OMT_INDX_GUID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4D"
#define OMP_O_DX_A_OPERATING_SYSTEM                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6B"
#define OMP_O_DX_A_OPERATING_SYSTEM_HOTFIX                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x1F"
#define OMP_O_DX_A_OPERATING_SYSTEM_SERVICE_PACK            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6D"
#define OMP_O_DX_A_OPERATING_SYSTEM_VERSION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6C"
#define OMP_O_DX_A_OPERATOR_COUNT                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x10"
#define OMP_O_DX_A_OPTION_DESCRIPTION                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x48"
#define OMP_O_DX_A_OPTIONS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x33"
#define OMP_O_DX_A_OPTIONS_LOCATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x49"
#define OMP_O_DX_A_ORIGINAL_DISPLAY_TABLE                   "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x3D"
#define OMP_O_DX_A_ORIGINAL_DISPLAY_TABLE_MSDOS             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x56"
#define OMP_O_DX_A_OTHER_LOGIN_WORKSTATIONS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5B"
#define OMP_O_DX_A_OTHER_MAILBOX                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x0B"
#define OMP_O_L1_A_OTHER_NAME                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x22"
#define OMP_O_DX_A_OTHER_WELL_KNOWN_OBJECTS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4F"
#define OMP_O_DX_A_PACKAGE_FLAGS                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x47"
#define OMP_O_DX_A_PACKAGE_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x46"
#define OMP_O_DX_A_PACKAGE_TYPE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x44"
#define OMP_O_DX_A_PARENT_CA                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x2D"
#define OMP_O_DX_A_PARENT_CA_CERTIFICATE_CHAIN              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x2D"
#define OMP_O_DX_A_PARENT_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x48"
#define OMP_O_DX_A_PARTIAL_ATTRIBUTE_DELETION_LIST          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x17"
#define OMP_O_DX_A_PARTIAL_ATTRIBUTE_SET                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x00"
#define OMP_O_DX_A_PEK_KEY_CHANGE_INTERVAL                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x62"
#define OMP_O_DX_A_PEK_LIST                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x61"
#define OMP_O_DX_A_PENDING_CA_CERTIFICATES                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x35"
#define OMP_O_DX_A_PENDING_PARENT_CA                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x37"
#define OMP_O_DX_A_PER_MSG_DIALOG_DISPLAY_TABLE             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x45"
#define OMP_O_DX_A_PER_RECIP_DIALOG_DISPLAY_TABLE           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x46"
#define OMP_O_DX_A_PERSONAL_TITLE                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x67"
#define OMP_O_DX_A_PHONE_FAX_OTHER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x06"
#define OMP_O_DX_A_PHONE_HOME_OTHER                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x15"
#define OMP_O_L0_A_PHONE_HOME_PRIMARY                       "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x14"
#define OMP_O_DX_A_PHONE_IP_OTHER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x52"
#define OMP_O_DX_A_PHONE_IP_PRIMARY                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x51"
#define OMP_O_DX_A_PHONE_ISDN_PRIMARY                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x09"
#define OMP_O_DX_A_PHONE_MOBILE_OTHER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x07"
#define OMP_O_L0_A_PHONE_MOBILE_PRIMARY                     "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x29"
#define OMP_O_DX_A_PHONE_OFFICE_OTHER                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x12"
#define OMP_O_DX_A_PHONE_PAGER_OTHER                        "\x2A\x86\x48\x86\xF7\x14\x01\x02\x76"
#define OMP_O_L0_A_PHONE_PAGER_PRIMARY                      "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x2A"
#define OMP_O_L0_A_PHOTO                                    "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x07"
#define OMP_O_DX_A_PHYSICAL_LOCATION_OBJECT                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x02"
#define OMP_O_L1_A_PICTURE                                  "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x23"
#define OMP_O_DX_A_PKI_CRITICAL_EXTENSIONS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x32"
#define OMP_O_DX_A_PKI_DEFAULT_CSPS                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x36"
#define OMP_O_DX_A_PKI_DEFAULT_KEY_SPEC                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x2F"
#define OMP_O_DX_A_PKI_ENROLLMENT_ACCESS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x37"
#define OMP_O_DX_A_PKI_EXPIRATION_PERIOD                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x33"
#define OMP_O_DX_A_PKI_EXTENDED_KEY_USAGE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x35"
#define OMP_O_DX_A_PKI_KEY_USAGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x30"
#define OMP_O_DX_A_PKI_MAX_ISSUING_DEPTH                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x31"
#define OMP_O_DX_A_PKI_OVERLAP_PERIOD                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x34"
#define OMP_O_DX_A_PKT                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4E"
#define OMP_O_DX_A_PKT_GUID                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x4D"
#define OMP_O_DX_A_POLICY_REPLICATION_FLAGS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x79"
#define OMP_O_DX_A_PORT_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x64"
#define OMP_O_DX_A_POSS_SUPERIORS                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x08"
#define OMP_O_DX_A_POSSIBLE_INFERIORS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x13"
#define OMP_O_L1_A_PREFERREDLANGUAGE                        "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x27"
#define OMP_O_DX_A_PREFERRED_OU                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x61"
#define OMP_O_DX_A_PREFIX_MAP                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x1A"
#define OMP_O_DX_A_PREVIOUS_CA_CERTIFICATES                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x34"
#define OMP_O_DX_A_PREVIOUS_PARENT_CA                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x36"
#define OMP_O_DX_A_PRIMARY_GROUP_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x62"
#define OMP_O_DX_A_PRIMARY_GROUP_TOKEN                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x04"
#define OMP_O_DX_A_PRINT_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x77"
#define OMP_O_DX_A_PRINT_BIN_NAMES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6D"
#define OMP_O_DX_A_PRINT_COLLATE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x72"
#define OMP_O_DX_A_PRINT_COLOR                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x73"
#define OMP_O_DX_A_PRINT_DUPLEX_SUPPORTED                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x1F"
#define OMP_O_DX_A_PRINT_END_TIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6A"
#define OMP_O_DX_A_PRINT_FORM_NAME                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6B"
#define OMP_O_DX_A_PRINT_KEEP_PRINTED_JOBS                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x13"
#define OMP_O_DX_A_PRINT_LANGUAGE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x76"
#define OMP_O_DX_A_PRINT_MAC_ADDRESS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x20"
#define OMP_O_DX_A_PRINT_MAX_COPIES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x71"
#define OMP_O_DX_A_PRINT_MAX_RESOLUTION_SUPPORTED           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x6E"
#define OMP_O_DX_A_PRINT_MAX_X_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x15"
#define OMP_O_DX_A_PRINT_MAX_Y_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x16"
#define OMP_O_DX_A_PRINT_MEDIA_READY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x21"
#define OMP_O_DX_A_PRINT_MEDIA_SUPPORTED                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2B"
#define OMP_O_DX_A_PRINT_MEMORY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1A"
#define OMP_O_DX_A_PRINT_MIN_X_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x17"
#define OMP_O_DX_A_PRINT_MIN_Y_EXTENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x18"
#define OMP_O_DX_A_PRINT_NETWORK_ADDRESS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1F"
#define OMP_O_DX_A_PRINT_NOTIFY                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x10"
#define OMP_O_DX_A_PRINT_NUMBER_UP                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x22"
#define OMP_O_DX_A_PRINT_ORIENTATIONS_SUPPORTED             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x70"
#define OMP_O_DX_A_PRINT_OWNER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0F"
#define OMP_O_DX_A_PRINT_PAGES_PER_MINUTE                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x77"
#define OMP_O_DX_A_PRINT_RATE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1D"
#define OMP_O_DX_A_PRINT_RATE_UNIT                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x1E"
#define OMP_O_DX_A_PRINT_SEPARATOR_FILE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x66"
#define OMP_O_DX_A_PRINT_SHARE_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x0E"
#define OMP_O_DX_A_PRINT_SPOOLING                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x12"
#define OMP_O_DX_A_PRINT_STAPLING_SUPPORTED                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x19"
#define OMP_O_DX_A_PRINT_START_TIME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x69"
#define OMP_O_DX_A_PRINT_STATUS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x11"
#define OMP_O_DX_A_PRINTER_NAME                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2C"
#define OMP_O_DX_A_PRIOR_SET_TIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x63"
#define OMP_O_DX_A_PRIOR_VALUE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x64"
#define OMP_O_DX_A_PRIORITY                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x67"
#define OMP_O_DX_A_PRIVATE_KEY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x65"
#define OMP_O_DX_A_PRIVILEGE_ATTRIBUTES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7C"
#define OMP_O_DX_A_PRIVILEGE_DISPLAY_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7A"
#define OMP_O_DX_A_PRIVILEGE_HOLDER                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7D"
#define OMP_O_DX_A_PRIVILEGE_VALUE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x7B"
#define OMP_O_DX_A_PRODUCT_CODE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x32"
#define OMP_O_DX_A_PROFILE_PATH                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0B"
#define OMP_O_DX_A_PROXIED_OBJECT_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x61"
#define OMP_O_DX_A_PROXY_ADDRESSES                          "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x52"
#define OMP_O_DX_A_PROXY_GENERATION_ENABLED                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x84\x0B"
#define OMP_O_DX_A_PROXY_LIFETIME                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x67"
#define OMP_O_DX_A_PUBLIC_KEY_POLICY                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x24"
#define OMP_O_DX_A_PURPORTED_SEARCH                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x76"
#define OMP_O_DX_A_PWD_HISTORY_LENGTH                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5F"
#define OMP_O_DX_A_PWD_LAST_SET                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x60"
#define OMP_O_DX_A_PWD_PROPERTIES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5D"
#define OMP_O_DX_A_QUALITY_OF_SERVICE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x4A"
#define OMP_O_DX_A_QUERY_FILTER                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4B"
#define OMP_O_DX_A_QUERY_POLICY_BL                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x60"
#define OMP_O_DX_A_QUERY_POLICY_OBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x5F"
#define OMP_O_DX_A_QUERYPOINT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x28"
#define OMP_O_DX_A_RANGE_LOWER                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x22"
#define OMP_O_DX_A_RANGE_UPPER                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x23"
#define OMP_O_DX_A_RDN                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x01"
#define OMP_O_DX_A_RDN_ATT_ID                               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x1A"
#define OMP_O_DX_A_REMOTE_SERVER_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x69"
#define OMP_O_DX_A_REMOTE_SOURCE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6B"
#define OMP_O_DX_A_REMOTE_SOURCE_TYPE                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6C"
#define OMP_O_DX_A_REMOTE_STORAGE_GUID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x29"
#define OMP_O_DX_A_REPL_PROPERTY_META_DATA                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x03"
#define OMP_O_DX_A_REPL_TOPOLOGY_STAY_OF_EXECUTION          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x25"
#define OMP_O_DX_A_REPL_UPTODATE_VECTOR                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x04"
#define OMP_O_DX_A_REPLICA_SOURCE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x6D"
#define OMP_O_DX_A_REPORTS                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x34"
#define OMP_O_DX_A_REPL_INTERVAL                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x38"
#define OMP_O_DX_A_REPS_FROM                                "\x2A\x86\x48\x86\xF7\x14\x01\x02\x5B"
#define OMP_O_DX_A_REPS_TO                                  "\x2A\x86\x48\x86\xF7\x14\x01\x02\x53"
#define OMP_O_DX_A_REQUIRED_CATEGORIES                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x41"
#define OMP_O_DX_A_RETIRED_REPL_DSA_SIGNATURES              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x21"
#define OMP_O_DX_A_TOKEN_GROUPS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x15"
#define OMP_O_DX_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8B\x0A"
#define OMP_O_DX_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x17"
#define OMP_O_DX_A_REVISION                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x11"
#define OMP_O_DX_A_RID                                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x19"
#define OMP_O_DX_A_RID_ALLOCATION_POOL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x73"
#define OMP_O_DX_A_RID_AVAILABLE_POOL                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x72"
#define OMP_O_DX_A_RID_MANAGER_REFERENCE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x70"
#define OMP_O_DX_A_RID_NEXT_RID                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x76"
#define OMP_O_DX_A_RID_PREVIOUS_ALLOCATION_POOL             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x74"
#define OMP_O_DX_A_RID_SET_REFERENCES                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1D"
#define OMP_O_DX_A_RID_USED_POOL                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x75"
#define OMP_O_DX_A_RIGHTS_GUID                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x54"
#define OMP_O_L0_A_ROOMNUMBER                               "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x06"
#define OMP_O_DX_A_ROOT_TRUST                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x22"
#define OMP_O_DX_A_RPC_NS_ANNOTATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6E"
#define OMP_O_DX_A_RPC_NS_BINDINGS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x71"
#define OMP_O_DX_A_RPC_NS_CODESET                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6F"
#define OMP_O_DX_A_RPC_NS_ENTRY_FLAGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x72"
#define OMP_O_DX_A_RPC_NS_GROUP                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x72"
#define OMP_O_DX_A_RPC_NS_INTERFACE_ID                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x73"
#define OMP_O_DX_A_RPC_NS_OBJECT_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x38"
#define OMP_O_DX_A_RPC_NS_PRIORITY                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x75"
#define OMP_O_DX_A_RPC_NS_PROFILE_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x76"
#define OMP_O_DX_A_RPC_NS_TRANSFER_SYNTAX                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x3A"
#define OMP_O_DX_A_SAM_ACCOUNT_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5D"
#define OMP_O_DX_A_SAM_ACCOUNT_TYPE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2E"
#define OMP_O_DX_A_SCHEDULE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x53"
#define OMP_O_DX_A_SCHEMA_FLAGS_EX                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x78"
#define OMP_O_DX_A_SCHEMA_ID_GUID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x14"
#define OMP_O_DX_A_SCHEMA_INFO                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4E"
#define OMP_O_DX_A_SCHEMA_UPDATE                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x61"
#define OMP_O_DX_A_SCHEMA_VERSION                           "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x57"
#define OMP_O_DX_A_SCOPE_FLAGS                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4A"
#define OMP_O_DX_A_SCRIPT_PATH                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x3E"
#define OMP_O_DX_A_SD_RIGHTS_EFFECTIVE                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x18"
#define OMP_O_DX_A_SEARCH_FLAGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x4E"
#define OMP_O_L0_A_SECRETARY                                "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x15"
#define OMP_O_DX_A_SECURITY_IDENTIFIER                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x79"
#define OMP_O_DX_A_SEQ_NOTIFICATION                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x78"
#define OMP_O_DX_A_SERVER_NAME                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x5F"
#define OMP_O_DX_A_SERVER_REFERENCE                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x03"
#define OMP_O_DX_A_SERVER_REFERENCE_BL                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x04"
#define OMP_O_DX_A_SERVER_ROLE                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1D"
#define OMP_O_DX_A_SERVER_STATE                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1A"
#define OMP_O_DX_A_SERVICE_BINDING_INFORMATION              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7E"
#define OMP_O_DX_A_SERVICE_CLASS_ID                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7A"
#define OMP_O_DX_A_SERVICE_CLASS_INFO                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7B"
#define OMP_O_DX_A_SERVICE_CLASS_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7D"
#define OMP_O_DX_A_SERVICE_DNS_NAME                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x11"
#define OMP_O_DX_A_SERVICE_DNS_NAME_TYPE                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x13"
#define OMP_O_DX_A_SERVICE_INSTANCE_VERSION                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x47"
#define OMP_O_DX_A_SERVICE_PRINCIPAL_NAME                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x03"
#define OMP_O_DX_A_SETUP_COMMAND                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x45"
#define OMP_O_DX_A_SHELL_CONTEXT_MENU                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x67"
#define OMP_O_DX_A_SHELL_PROPERTY_PAGES                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x33"
#define OMP_O_DX_A_SHORT_SERVER_NAME                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x89\x39"
#define OMP_O_DX_A_SHOW_IN_ADDRESS_BOOK                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x04"
#define OMP_O_DX_A_SHOW_IN_ADVANCED_VIEW_ONLY               "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x29"
#define OMP_O_DX_A_SID_HISTORY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x61"
#define OMP_O_DX_A_SIGNATURE_ALGORITHMS                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x38"
#define OMP_O_DX_A_SITE_GUID                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x6A"
#define OMP_O_DX_A_SITE_LINK_LIST                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x36"
#define OMP_O_DX_A_SITE_LIST                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x35"
#define OMP_O_DX_A_SITE_OBJECT                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x00"
#define OMP_O_DX_A_SITE_OBJECT_BL                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x01"
#define OMP_O_DX_A_SITE_SERVER                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x6E"
#define OMP_O_DX_A_SMTP_MAIL_ADDRESS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x12"
#define OMP_O_DX_A_SPN_MAPPINGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x43"
#define OMP_O_DX_A_SUB_CLASS_OF                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x15"
#define OMP_O_DX_A_SUB_REFS                                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x07"
#define OMP_O_DX_A_SUPER_SCOPE_DESCRIPTION                  "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x47"
#define OMP_O_DX_A_SUPER_SCOPES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x46"
#define OMP_O_DX_A_SUPERIOR_DNS_ROOT                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x14"
#define OMP_O_DX_A_SUPPLEMENTAL_CREDENTIALS                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x7D"
#define OMP_O_DX_A_SYNC_ATTRIBUTES                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1A"
#define OMP_O_DX_A_SYNC_MEMBERSHIP                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x19"
#define OMP_O_DX_A_SYNC_WITH_OBJECT                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x18"
#define OMP_O_DX_A_SYNC_WITH_SID                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x1B"
#define OMP_O_DX_A_SYSTEM_AUXILIARY_CLASS                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x46"
#define OMP_O_DX_A_SYSTEM_FLAGS                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x77"
#define OMP_O_DX_A_SYSTEM_MAY_CONTAIN                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x44"
#define OMP_O_DX_A_SYSTEM_MUST_CONTAIN                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x45"
#define OMP_O_DX_A_SYSTEM_ONLY                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x2A"
#define OMP_O_DX_A_SYSTEM_POSS_SUPERIORS                    "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x43"
#define OMP_O_DX_A_TELEX_PRIMARY                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x08"
#define OMP_O_DX_A_TEMPLATE_ROOTS                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x42"
#define OMP_O_DX_A_TERMINAL_SERVER                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x75"
#define OMP_O_DX_A_TEXT_COUNTRY                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x81\x03"
#define OMP_O_L0_A_TEXT_ENCODED_OR_ADDRESS                  "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x02"
#define OMP_O_DX_A_TIME_REFRESH                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x77"
#define OMP_O_DX_A_TIME_VOL_CHANGE                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x76"
#define OMP_O_DX_A_TOMBSTONE_LIFETIME                       "\x2A\x86\x48\x86\xF7\x14\x01\x02\x36"
#define OMP_O_DX_A_TRANSPORT_ADDRESS_ATTRIBUTE              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7F"
#define OMP_O_DX_A_TRANSPORT_DLL_NAME                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x15"
#define OMP_O_DX_A_TRANSPORT_TYPE                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x17"
#define OMP_O_DX_A_TREAT_AS_LEAF                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x26"
#define OMP_O_DX_A_TREE_NAME                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x14"
#define OMP_O_DX_A_TRUST_ATTRIBUTES                         "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x56"
#define OMP_O_DX_A_TRUST_AUTH_INCOMING                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x01"
#define OMP_O_DX_A_TRUST_AUTH_OUTGOING                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x07"
#define OMP_O_DX_A_TRUST_DIRECTION                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x04"
#define OMP_O_DX_A_TRUST_PARENT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x57"
#define OMP_O_DX_A_TRUST_PARTNER                            "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x05"
#define OMP_O_DX_A_TRUST_POSIX_OFFSET                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x06"
#define OMP_O_DX_A_TRUST_TYPE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x08"
#define OMP_O_DX_A_UAS_COMPAT                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1B"
#define OMP_O_L0_A_UID                                      "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01\x01"
#define OMP_O_DX_A_UNC_NAME                                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x09"
#define OMP_O_DX_A_UNICODE_PWD                              "\x2A\x86\x48\x86\xF7\x14\x01\x04\x5A"
#define OMP_O_DX_A_UPGRADE_PRODUCT_CODE                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x2D"
#define OMP_O_DX_A_UPN_SUFFIXES                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x86\x7A"
#define OMP_O_DX_A_USER_ACCOUNT_CONTROL                     "\x2A\x86\x48\x86\xF7\x14\x01\x04\x08"
#define OMP_O_DX_A_USER_CERT                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x05"
#define OMP_O_DX_A_USER_COMMENT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x1C"
#define OMP_O_DX_A_USER_PARAMETERS                          "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0A"
#define OMP_O_L1_A_USERPKCS12                               "\x60\x86\x48\x01\x86\xF8\x42\x03\x01\x81\x58"
#define OMP_O_DX_A_USER_PRINCIPAL_NAME                      "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x10"
#define OMP_O_DX_A_USER_SHARED_FOLDER                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6F"
#define OMP_O_DX_A_USER_SHARED_FOLDER_OTHER                 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x70"
#define OMP_O_L1_A_USER_SMIME_CERTIFICATE                   "\x60\x86\x48\x01\x86\xF8\x42\x03\x81\x0C"
#define OMP_O_DX_A_USER_WORKSTATIONS                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x56"
#define OMP_O_DX_A_USN_CHANGED                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x78"
#define OMP_O_DX_A_USN_CREATED                              "\x2A\x86\x48\x86\xF7\x14\x01\x02\x13"
#define OMP_O_DX_A_USN_DSA_LAST_OBJ_REMOVED                 "\x2A\x86\x48\x86\xF7\x14\x01\x02\x82\x0B"
#define OMP_O_DX_A_USN_INTERSITE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x55"
#define OMP_O_DX_A_USN_LAST_OBJ_REM                         "\x2A\x86\x48\x86\xF7\x14\x01\x02\x79"
#define OMP_O_DX_A_USN_SOURCE                               "\x2A\x86\x48\x86\xF7\x14\x01\x04\x87\x00"
#define OMP_O_DX_A_VALID_ACCESSES                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x8A\x4C"
#define OMP_O_DX_A_VENDOR                                   "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x7F"
#define OMP_O_DX_A_VERSION_NUMBER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0D"
#define OMP_O_DX_A_VERSION_NUMBER_HI                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x48"
#define OMP_O_DX_A_VERSION_NUMBER_LO                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x49"
#define OMP_O_DX_A_VOL_TABLE_GUID                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x50"
#define OMP_O_DX_A_VOL_TABLE_IDX_GUID                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x4E"
#define OMP_O_DX_A_VOLUME_COUNT                             "\x2A\x86\x48\x86\xF7\x14\x01\x04\x83\x7B"
#define OMP_O_DX_A_WBEM_PATH                                "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x2D"
#define OMP_O_DX_A_WELL_KNOWN_OBJECTS                       "\x2A\x86\x48\x86\xF7\x14\x01\x04\x84\x6A"
#define OMP_O_DX_A_WHEN_CHANGED                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x03"
#define OMP_O_DX_A_WHEN_CREATED                             "\x2A\x86\x48\x86\xF7\x14\x01\x02\x02"
#define OMP_O_DX_A_WINSOCK_ADDRESSES                        "\x2A\x86\x48\x86\xF7\x14\x01\x04\x81\x0E"
#define OMP_O_DX_A_WWW_HOME_PAGE                            "\x2A\x86\x48\x86\xF7\x14\x01\x02\x83\x50"
#define OMP_O_DX_A_WWW_PAGE_OTHER                           "\x2A\x86\x48\x86\xF7\x14\x01\x04\x85\x6D"
//
//Class Definitions
//
#define OMP_O_DX_O_ACS_POLICY                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x09"
#define OMP_O_DX_O_ACS_RESOURCE_LIMITS                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3F"
#define OMP_O_DX_O_ACS_SUBNET                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0A"
#define OMP_O_DX_O_ADDRESS_BOOK_CONTAINER                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x7D"
#define OMP_O_DX_O_ADDRESS_TEMPLATE                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x3A"
#define OMP_O_DX_O_APPLICATION_SETTINGS                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x31"
#define OMP_O_DX_O_APPLICATION_SITE_SETTINGS                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x44"
#define OMP_O_DX_O_APPLICATION_VERSION                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x58"
#define OMP_O_DX_O_ATTRIBUTE_SCHEMA                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0E"
#define OMP_O_DX_O_BUILTIN_DOMAIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x04"
#define OMP_O_DX_O_CATEGORY_REGISTRATION                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4A"
#define OMP_O_DX_O_CLASS_REGISTRATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0A"
#define OMP_O_DX_O_CLASS_SCHEMA                             "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0D"
#define OMP_O_DX_O_CLASS_STORE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2C"
#define OMP_O_DX_O_COM_CONNECTION_POINT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0B"
#define OMP_O_DX_O_COMPUTER                                 "\x2A\x86\x48\x86\xF7\x14\x01\x03\x1E"
#define OMP_O_DX_O_CONFIGURATION                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0C"
#define OMP_O_DX_O_CONNECTION_POINT                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0E"
#define OMP_O_DX_O_CONTACT                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x0F"
#define OMP_O_DX_O_CONTAINER                                "\x2A\x86\x48\x86\xF7\x14\x01\x03\x17"
#define OMP_O_DX_O_CONTROL_ACCESS_RIGHT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4D"
#define OMP_O_DX_O_CROSS_REF                                "\x2A\x86\x48\x86\xF7\x14\x01\x03\x0B"
#define OMP_O_DX_O_CROSS_REF_CONTAINER                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x35"
#define OMP_O_DX_O_DFS_CONFIGURATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2A"
#define OMP_O_DX_O_DHCP_CLASS                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x04"
#define OMP_O_DX_O_DISPLAY_SPECIFIER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x54"
#define OMP_O_DX_O_DISPLAY_TEMPLATE                         "\x2A\x86\x48\x86\xF7\x14\x01\x03\x3B"
#define OMP_O_DX_O_DMD                                      "\x2A\x86\x48\x86\xF7\x14\x01\x03\x09"
#define OMP_O_DX_O_DNS_NODE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x56"
#define OMP_O_DX_O_DNS_ZONE                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x55"
#define OMP_O_DX_O_DOMAIN                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x42"
#define OMP_O_DX_O_DOMAIN_DNS                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x43"
#define OMP_O_DX_O_DOMAIN_POLICY                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x12"
#define OMP_O_DX_O_DS_UI_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x37"
#define OMP_O_DX_O_FILE_LINK_TRACKING                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x34"
#define OMP_O_DX_O_FILE_LINK_TRACKING_ENTRY                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x3B"
#define OMP_O_DX_O_FOREIGN_SECURITY_PRINCIPAL               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4C"
#define OMP_O_DX_O_FT_DFS                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x2B"
#define OMP_O_DX_O_GROUP                                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x08"
#define OMP_O_DX_O_GROUP_POLICY_CONTAINER                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1D"
#define OMP_O_DX_O_INDEX_SERVER_CATALOG                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x02"
#define OMP_O_L1_O_INETORGPERSON                            "\x60\x86\x48\x01\x86\xF8\x42\x03\x02\x02"
#define OMP_O_DX_O_INFRASTRUCTURE_UPDATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x2F"
#define OMP_O_DX_O_INTELLIMIRROR_GROUP                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x18"
#define OMP_O_DX_O_INTELLIMIRROR_SCP                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x17"
#define OMP_O_DX_O_INTER_SITE_TRANSPORT                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0D"
#define OMP_O_DX_O_INTER_SITE_TRANSPORT_CONTAINER           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0C"
#define OMP_O_DX_O_IPSEC_BASE                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x38"
#define OMP_O_DX_O_IPSEC_FILTER                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x76"
#define OMP_O_DX_O_IPSEC_ISAKMP_POLICY                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x78"
#define OMP_O_DX_O_IPSEC_NEGOTIATION_POLICY                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x77"
#define OMP_O_DX_O_IPSEC_NFA                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x79"
#define OMP_O_DX_O_IPSEC_POLICY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x62"
#define OMP_O_DX_O_LEAF                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x14"
#define OMP_O_DX_O_LICENSING_SITE_SETTINGS                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x4E"
#define OMP_O_DX_O_LINK_TRACK_OBJECT_MOVE_TABLE             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5B"
#define OMP_O_DX_O_LINK_TRACK_OMT_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5D"
#define OMP_O_DX_O_LINK_TRACK_VOL_ENTRY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5C"
#define OMP_O_DX_O_LINK_TRACK_VOLUME_TABLE                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5A"
#define OMP_O_DX_O_LOST_AND_FOUND                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x0B"
#define OMP_O_DX_O_MAIL_RECIPIENT                           "\x2A\x86\x48\x86\xF7\x14\x01\x03\x2E"
#define OMP_O_DX_O_MEETING                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x68"
#define OMP_O_DX_O_MS_COM_PARTITION                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x41"
#define OMP_O_DX_O_MS_COM_PARTITIONSET                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x42"
#define OMP_O_DX_O_MS_DS_APP_CONFIGURATION                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5C"
#define OMP_O_DX_O_MS_EXCH_CONFIGURATION_CONTAINER          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x30"
#define OMP_O_DX_O_MS_MMS_MANAGEMENT_AGENT                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x62"
#define OMP_O_DX_O_MS_MMS_INSTANCE                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x61"
#define OMP_O_DX_O_MS_MMS_OBJECT                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x60"
#define OMP_O_DX_O_MS_MMS_MANAGEMENT_AGENT_HISTORY          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x63"
#define OMP_O_DX_O_MS_MMS_CONNECTOR                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x64"
#define OMP_O_DX_O_MS_MMS_PROVISIONING_SERVICE              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x65"
#define OMP_O_DX_O_MS_MMS_PROVISIONING_SERVICE_HISTORY      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x66"
#define OMP_O_DX_O_MS_MMS_WORKFLOW                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x67"
#define OMP_O_DX_O_MS_MMS_PROVISIONING_STATUS               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x68"
#define OMP_O_DX_O_MS_MMS_EVENT_ASSOCIATION                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x69"
#define OMP_O_DX_O_MS_PKI_ENTERPRISE_OID                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x44"
#define OMP_O_DX_O_MS_PKI_KEY_RECOVERY_AGENT                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x43"
#define OMP_O_DX_O_MS_SQL_SQLSERVER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x38"
#define OMP_O_DX_O_MS_SQL_OLAPSERVER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x39"
#define OMP_O_DX_O_MS_SQL_SQLREPOSITORY                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3A"
#define OMP_O_DX_O_MS_SQL_SQLPUBLICATION                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3B"
#define OMP_O_DX_O_MS_SQL_SQLDATABASE                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3C"
#define OMP_O_DX_O_MS_SQL_OLAPDATABASE                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3D"
#define OMP_O_DX_O_MS_SQL_OLAPCUBE                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x3E"
#define OMP_O_DX_O_MS_TAPI_RT_CONFERENCE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5D"
#define OMP_O_DX_O_MS_TAPI_RT_PERSON                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5E"
#define OMP_O_DX_O_MS_WMI_INTRANGEPARAM                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4D"
#define OMP_O_DX_O_MS_WMI_INTSETPARAM                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4E"
#define OMP_O_DX_O_MS_WMI_MERGEABLEPOLICYTEMPLATE           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4A"
#define OMP_O_DX_O_MS_WMI_OBJECTENCODING                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x59"
#define OMP_O_DX_O_MS_WMI_POLICYTEMPLATE                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x48"
#define OMP_O_DX_O_MS_WMI_POLICYTYPE                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x53"
#define OMP_O_DX_O_MS_WMI_RANGEPARAM                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4B"
#define OMP_O_DX_O_MS_WMI_REALRANGEPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x51"
#define OMP_O_DX_O_MS_WMI_RULE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x56"
#define OMP_O_DX_O_MS_WMI_SHADOWOBJECT                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x54"
#define OMP_O_DX_O_MS_WMI_SIMPLEPOLICYTEMPLATE              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x49"
#define OMP_O_DX_O_MS_WMI_SOM                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x55"
#define OMP_O_DX_O_MS_WMI_STRINGSETPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x52"
#define OMP_O_DX_O_MS_WMI_UINTRANGEPARAM                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4F"
#define OMP_O_DX_O_MS_WMI_UINTSETPARAM                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x50"
#define OMP_O_DX_O_MS_WMI_UNKNOWNRANGEPARAM                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x4C"
#define OMP_O_DX_O_MS_WMI_WMIGPO                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x57"
#define OMP_O_DX_O_MSMQ_CONFIGURATION                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x22"
#define OMP_O_DX_O_MSMQ_CUSTOM_RECIPIENT                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5A"
#define OMP_O_DX_O_MSMQ_ENTERPRISE_SETTINGS                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x23"
#define OMP_O_DX_O_MSMQ_GROUP                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5B"
#define OMP_O_DX_O_MSMQ_MIGRATED_USER                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x33"
#define OMP_O_DX_O_MSMQ_QUEUE                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x21"
#define OMP_O_DX_O_MSMQ_SETTINGS                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x25"
#define OMP_O_DX_O_MSMQ_SITE_LINK                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x24"
#define OMP_O_DX_O_NTDS_CONNECTION                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x47"
#define OMP_O_DX_O_NTDS_DSA                                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x2F"
#define OMP_O_DX_O_NTDS_SERVICE                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x48"
#define OMP_O_DX_O_NTDS_SITE_SETTINGS                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x45"
#define OMP_O_DX_O_NTFRS_MEMBER                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x19"
#define OMP_O_DX_O_NTFRS_REPLICA_SET                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x66"
#define OMP_O_DX_O_NTFRS_SETTINGS                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x59"
#define OMP_O_DX_O_NTFRS_SUBSCRIBER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1B"
#define OMP_O_DX_O_NTFRS_SUBSCRIPTIONS                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1A"
#define OMP_O_DX_O_PACKAGE_REGISTRATION                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x31"
#define OMP_O_DX_O_PHYSICAL_LOCATION                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x61"
#define OMP_O_DX_O_PKI_CERTIFICATE_TEMPLATE                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x31"
#define OMP_O_DX_O_PKI_ENROLLMENT_SERVICE                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x32"
#define OMP_O_DX_O_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT        "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x5F"
#define OMP_O_DX_O_PRINT_QUEUE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x17"
#define OMP_O_DX_O_QUERY_POLICY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x6A"
#define OMP_O_DX_O_REMOTE_MAIL_RECIPIENT                    "\x2A\x86\x48\x86\xF7\x14\x01\x05\x18"
#define OMP_O_DX_O_REMOTE_STORAGE_SERVICE_POINT             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x12"
#define OMP_O_DX_O_RID_MANAGER                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x53"
#define OMP_O_DX_O_RID_SET                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x01"
#define OMP_O_DX_O_RPC_CONTAINER                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x08"
#define OMP_O_DX_O_RPC_ENTRY                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1B"
#define OMP_O_DX_O_RPC_GROUP                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x50"
#define OMP_O_DX_O_RPC_PROFILE                              "\x2A\x86\x48\x86\xF7\x14\x01\x05\x52"
#define OMP_O_DX_O_RPC_PROFILE_ELEMENT                      "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1A"
#define OMP_O_DX_O_RPC_SERVER                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x51"
#define OMP_O_DX_O_RPC_SERVER_ELEMENT                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x49"
#define OMP_O_DX_O_RRAS_ADMINISTRATION_CONNECTION_POINT     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x16"
#define OMP_O_DX_O_RRAS_ADMINISTRATION_DICTIONARY           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x1C"
#define OMP_O_DX_O_SAM_DOMAIN                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x03"
#define OMP_O_DX_O_SAM_DOMAIN_BASE                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x02"
#define OMP_O_DX_O_SAM_SERVER                               "\x2A\x86\x48\x86\xF7\x14\x01\x05\x05"
#define OMP_O_DX_O_SECRET                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1C"
#define OMP_O_DX_O_SECURITY_OBJECT                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x01"
#define OMP_O_DX_O_SECURITY_PRINCIPAL                       "\x2A\x86\x48\x86\xF7\x14\x01\x05\x06"
#define OMP_O_DX_O_SERVER                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x11"
#define OMP_O_DX_O_SERVERS_CONTAINER                        "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58\x30"
#define OMP_O_DX_O_SERVICE_ADMINISTRATION_POINT             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5E"
#define OMP_O_DX_O_SERVICE_CLASS                            "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1D"
#define OMP_O_DX_O_SERVICE_CONNECTION_POINT                 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x7E"
#define OMP_O_DX_O_SERVICE_INSTANCE                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1E"
#define OMP_O_DX_O_SITE                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x1F"
#define OMP_O_DX_O_SITE_LINK                                "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x13"
#define OMP_O_DX_O_SITE_LINK_BRIDGE                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x81\x14"
#define OMP_O_DX_O_SITES_CONTAINER                          "\x2A\x86\x48\x86\xF7\x14\x01\x05\x6B"
#define OMP_O_DX_O_STORAGE                                  "\x2A\x86\x48\x86\xF7\x14\x01\x05\x21"
#define OMP_O_DX_O_SUBNET                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x60"
#define OMP_O_DX_O_SUBNET_CONTAINER                         "\x2A\x86\x48\x86\xF7\x14\x01\x05\x5F"
#define OMP_O_DX_O_TRUSTED_DOMAIN                           "\x2A\x86\x48\x86\xF7\x14\x01\x05\x22"
#define OMP_O_DX_O_TYPE_LIBRARY                             "\x2A\x86\x48\x86\xF7\x14\x01\x05\x35"
#define OMP_O_DX_O_USER                                     "\x2A\x86\x48\x86\xF7\x14\x01\x05\x09"
#define OMP_O_DX_O_VOLUME                                   "\x2A\x86\x48\x86\xF7\x14\x01\x05\x24"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\mdglobal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mdglobal.h
//
//--------------------------------------------------------------------------

#ifndef _mdglobal_h_
#define _mdglobal_h_


#include "msrpc.h"
#include "ntsam.h"
#include <align.h>          // alignment macros

#include <authz.h>          // Authz framework
#include <authzi.h>          // Authz framework


#define DEFS_ONLY
#include <draatt.h>
#undef DEFS_ONLY

/**************************************************************************
The following constants define the DS behavior version this binary supports, 
DS_BEHAVIOR_VERSION_CURRENT is the current version, DS_BEHAVIOR_VERSION_MIN 
defines the lowest version that this binary supports.  

If any change is to be made to these constants, the "msDs-Behavior-Version"
attributes in schema.ini need to be updated manually. As shown below, you have
to change all the x's to the value of DS_BEHAVIOR_VERSION_MIN and all the y's
to the value of DS_BEHAVIOR_VERSION_CURRENT in their respective sections.

[DEFAULTROOTDOMAIN]
ms-Ds-Behavior-Version=x
......
[PARTITIONS]
ms-Ds-Behavior-Version=x
......
[DEFAULTFIRSTMACHINE]
ms-Ds-Behavior-Version=y
......
[DEFAULTADDLMACHINE]
ms-Ds-Behavior-Version=y
......
[DEFAULTADDLMACHINEREPLICA]
ms-Ds-Behavior-Version=y
***************************************************************************/

#define DS_BEHAVIOR_VERSION_CURRENT   DS_BEHAVIOR_WHISTLER
#define DS_BEHAVIOR_VERSION_MIN       DS_BEHAVIOR_WIN2000

// The new schema reuse, defunct, and delete behavior is enabled
// by setting the forest version to DS_BEHAVIOR_SCHEMA_REUSE.
// aka BETA3.
//
// Schema reuse (aka schema delete) is only enabled in later forests
// because downrev binaries will stop replicating and can't be demoted
// or recovered once msDS-IntIds are allocated to new attributes!
// All DCs must support schema-reuse before setting the forest
// version to DS_BEHAVIOR_SCHEMA_REUSE.
#define DS_BEHAVIOR_SCHEMA_REUSE      DS_BEHAVIOR_WHISTLER

// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

/**************************************************************************
 *   Miscellaneous Common Data Structures
 **************************************************************************/

typedef DSNAME NAMING_CONTEXT;

typedef struct _CROSS_REF {
    NAMING_CONTEXT *pNC;         /* NC this CR is for */
    ATTRBLOCK      *pNCBlock;    /* NC, in predigested block format */
    DSNAME         *pObj;        /* Object holding info for this CR */
    LPWSTR          NetbiosName; /* if ntds domain, netbios name of domain, NULL otherwise */
    LPWSTR          DnsName;     /* if ntds domain or ndnc, dns name of nc, NULL otherwise */
    LPWSTR          DnsAliasName;/* if ntds domain or ndnc, alias dns name of nc, NULL otherwise */
    DWORD           flags;       /* Cross-Ref object's FLAG_CR_* bits */
    DWORD           dwFirstNotifyDelay;       /* This is the delay before notifying the
                                               first DSA replication partner of changes. */
    DWORD           dwSubsequentNotifyDelay;  /* This is the delay between notifying a
                                               subsequent DSA repl partners of changes */
    DSNAME *        pdnSDRefDom;        /* This is the Security Descriptor Reference
                                           Domain for NDNCs.  It's SDRefDom for short. */
    PSID            pSDRefDomSid;       /* All access to this variable should be done through
                                           GetSDRefDomSid().  This variable may or may not
                                           be filled in. */
    // All values from ATT_DNS_ROOT. DnsName (above) is a copy of the
    // first value. A copy is used to avoid confusing the old code that
    // thinks a cross ref has one and only one dns name. Which is true
    // for Active Directory's NC cross refs although it might not be
    // true for the user-created cross refs. At any rate, the code will
    // use DnsName above when a DNS name is needed and will use the values
    // stored here when generating a referral.
    ATTRVALBLOCK    DnsReferral;
    DWORD           bEnabled; // ATT_ENABLED (TRUE if not present)
} CROSS_REF;


#define PAS_DATA_VER               VERSION_V1
typedef struct _PAS_Data {
    SHORT                version;       // structure version
    SHORT                size;          // structure size
    DWORD                flag;          // current PAS replication state. Used only for Assert at the moment.
    PARTIAL_ATTR_VECTOR  PAS;           // additional attributes required for PAS cycle
} PAS_DATA, *PPAS_DATA;


typedef struct _ReplicaLink_V1 {
    ULONG       cb;                     // total size of this structure
    ULONG       cConsecutiveFailures;   // * number of consecutive call failures along
                                        //    this link; used by the KCC to route around
                                        //    servers that are temporarily down
    DSTIME       timeLastSuccess;      // (Reps-From) time of last successful replication or
                                        //    (Reps-To) time at which Reps-To was added or updated
    DSTIME       timeLastAttempt;      // * time of last replication attempt
    ULONG       ulResultLastAttempt;    // * result of last replication attempt (DRSERR_*)
    ULONG       cbOtherDraOffset;       // offset (from struct *) of other-dra MTX_ADDR
    ULONG       cbOtherDra;             // size of other-dra MTX_ADDR
    ULONG       ulReplicaFlags;         // zero or more DRS_* flags
    REPLTIMES   rtSchedule;             // * periodic replication schedule
                                        //    (valid only if ulReplicaFlags & DRS_PER_SYNC)
    USN_VECTOR  usnvec;                 // * propagation state
    UUID        uuidDsaObj;             // objectGUID of other-dra's ntdsDSA object
    UUID        uuidInvocId;            // * invocation id of other-dra
    UUID        uuidTransportObj;       // * objectGUID of interSiteTransport object
                                        //      corresponding to the transport by which we
                                        //      communicate with the source DSA
    DWORD       dwReserved1;            // * Was used for a brief period. Available for re-use.
    ULONG       cbPASDataOffset;        // * offset from beginning of struct to PAS_DATA section
                                        // WARNING: if you extend this struct make sure it is always aligned at
                                        // ALIGN_DWORD boundaries. (since PASDataOfffset must align correctly).
    BYTE        rgb[];                  // storage for the rest of the structure
                                        // * indicates valid only on Reps-From
} REPLICA_LINK_V1;

typedef struct _ReplicaLink {
    DWORD       dwVersion;
    union
    {
        REPLICA_LINK_V1 V1;
    };
} REPLICA_LINK;

// return the address of other dra (as an MTX_ADDR *) embedded in a REPLICA_LINK
#define RL_POTHERDRA(prl)       ((MTX_ADDR *) ((prl)->V1.cbOtherDraOffset+ (BYTE *)(prl)))

// Validate macro for currently supported replica link version
#define VALIDATE_REPLICA_LINK_VERSION(prl) Assert(VERSION_V1 == (prl)->dwVersion);

// return address of PAS_DATA
#define RL_PPAS_DATA(prl)       ((PPAS_DATA) ((prl)->V1.cbPASDataOffset + (BYTE *)(prl)))

// PAS alignment
#define RL_ALIGN_PAS_DATA(prl) {                                            \
    if (!COUNT_IS_ALIGNED((prl)->V1.cbPASDataOffset, ALIGN_DWORD)) {        \
        DWORD offset = (prl)->V1.cbPASDataOffset;                           \
        (prl)->V1.cbPASDataOffset =                                         \
                ROUND_UP_COUNT((prl)->V1.cbPASDataOffset, ALIGN_DWORD);     \
        offset = (prl)->V1.cbPASDataOffset - offset;                        \
        Assert(offset < sizeof(DWORD));                                     \
        (prl)->V1.cb += offset;                                             \
        Assert(COUNT_IS_ALIGNED((prl)->V1.cbPASDataOffset, ALIGN_DWORD))    \
    }                                                                       \
}

// calculates REPLICA_LINK size
// size := struct_length + <dynamic_data> where,
// <dynamic_data> := OtherDra_length + optional{<alignment_offset> + PAS_data_length}
// where,
// <alignment_offset := cbPASDataOffset - (cbOtherDraOffset+cbOtherDra)
// Note: there's room to optimize this, but since it is only used in asserts
// we'll leave in this form. To optimize, get rid of the +/- of cbOtherDra.
#define RL_SIZE(prl)                                    \
            (sizeof(REPLICA_LINK) +                     \
             (prl)->V1.cbOtherDra +                     \
             ((prl)->V1.cbPASDataOffset ?               \
              ((prl)->V1.cbPASDataOffset -              \
               (prl)->V1.cbOtherDraOffset -             \
               (prl)->V1.cbOtherDra       +             \
               RL_PPAS_DATA(prl)->size) : 0) )

// validate PAS size
#define VALIDATE_REPLICA_LINK_SIZE(prl) Assert( (prl)->V1.cb == RL_SIZE(prl) )

//
// Used to compare guids
//

#define DsIsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

/*
 * These structures are used to cache information in the DNRead call
 * in the file dbsubj.c.  They need to be here so that the cache can
 * live on the THSTATE, since the cache is specific to a thread.
 */

// Struct holding info about a name part
typedef struct
{
   ULONG   PDNT;                        // parent's tag
   ATTRTYP rdnType;                     // Type of rdn (msDS-IntId)
   ULONG   cbRdn;                       // Count of bytes of RDN (remember RDNs
                                        // are unicode)
   WCHAR  *pRdn;                        // rdn (it's unicode)

} d_tagname;

typedef LONGLONG SDID;

// Full name info structure (used for dnread cache, etc.)
typedef struct _d_memname
{
    ULONG     DNT;                     // data file tag for this entry
    ULONG     NCDNT;                   // raw NCDNT data this entry
    d_tagname tag;                     // name part info
    GUID      Guid;                    // Guid of this object (may be null)
    NT4SID    Sid;                     // Sid of this object (may be null)
    ULONG     SidLen;                  // How much sid info exists
    BOOL      objflag;                 // 0 if record is a phantom
    DWORD     cAncestors;
    DWORD    *pAncestors;
    SDID      sdId;                    // sd id for this DNT
    DWORD     dwObjectClass;           // raw object class value
} d_memname;

typedef struct _LOCAL_DNREADCACHE_SLOT {
    DWORD DNT;
    DWORD PDNT;
    DWORD ulRDNLen;
    DWORD hitCount;
    d_memname *pName;
    DWORD    dwHashKey;
} DNREADCACHESLOT;

#define DN_READ_CACHE_SLOT_NUM 6
// Hold holds the next dnreadcache to be discarded if we have to.
// Slot are the normal, active caches
// Index is used to figure out the next slot to use.  The DNT field is used as
// an index into the slot array.  The PDNT and ulRDNLen fields are bit-wise ORs
// of the PDNT and ulRDNLen field of all the slots and the hold.  Thus, if you
// are scanning looking for a match by PDNT-RDN, if anding your values with the
// values in the index doesn't return exactly your value, you don't need to look
// at the slots.
typedef struct _LOCAL_DNREADCACHE_BUCKET {
    DNREADCACHESLOT hold;
    DNREADCACHESLOT slot[DN_READ_CACHE_SLOT_NUM];
    DNREADCACHESLOT index;
} DNREADCACHEBUCKET;

// This should be a power of 2.
#define LOCAL_DNREAD_CACHE_SIZE 32
#define LOCAL_DNREAD_CACHE_MASK (LOCAL_DNREAD_CACHE_SIZE - 1)

typedef struct _GLOBALDNREADCACHESLOT{
    BOOL                  valid;
    d_memname             name;
    DWORD                 dwHashKey;
} GLOBALDNREADCACHESLOT;

typedef struct _GLOBALDNREADCACHE {
    DWORD refCount;
    DWORD count;
    GLOBALDNREADCACHESLOT *pData;
} GLOBALDNREADCACHE;

/* Values for the "mark" field in the previous structure */
#define DNREAD_NOMARK       0
#define DNREAD_MARK         1
#define DNREAD_COMMON       2

// Structs for cache of parents and their list children security state
#define VIEW_SECURITY_CACHE_SIZE 64
// valid states for the next structure.
#define LIST_CONTENTS_ALLOWED    1
#define LIST_CONTENTS_DENIED     2
#define LIST_CONTENTS_AMBIGUOUS  3
typedef struct _VIEW_SECURITY_CACHE_ELEMENT {
    DWORD dnt;
    DWORD State;
} VIEW_SECURITY_CACHE_ELEMENT;

typedef struct _VIEW_SECURITY_CACHE {
    DWORD index;
    VIEW_SECURITY_CACHE_ELEMENT CacheVals[VIEW_SECURITY_CACHE_SIZE];
} VIEW_SECURITY_CACHE;



/*-------------------------------------------------------------------------*/
/* This structure holds the state information for a single thread.
This state information is valid during the course of a single transaction,
where a transaction is servicing one DSA call.
*/

typedef enum {

    ImpersonateNone = 0,
    ImpersonateRpcClient = 1,
    ImpersonateNullSession = 2,
    ImpersonateSspClient = 3,
    ImpersonateDelegatedClient = 4

} ImpersonationState;

///////////////////////////////////////////////////////////////////////
//                                                                   //
//                                                                   //
//  IndexType Definitions                                            //
//                                                                   //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define SAM_SEARCH_SID                          0
#define SAM_SEARCH_NC_ACCTYPE_NAME              1
#define SAM_SEARCH_NC_ACCTYPE_SID               2
#define SAM_SEARCH_PRIMARY_GROUP_ID             3

//
// Structure Which Holds search hints for SAM
//
typedef struct _SAMP_SEARCH_INFORMATION
{
    ULONG   IndexType;
    ULONG   HighLimitLength1;
    PVOID   HighLimit1;
    ULONG   HighLimitLength2;
    PVOID   HighLimit2;
    ULONG   LowLimitLength1;
    PVOID   LowLimit1;
    ULONG   LowLimitLength2;
    PVOID   LowLimit2;
    BOOLEAN bRootOfSearchIsNcHead;
} SAMP_SEARCH_INFORMATION;


typedef enum _DS_DB_OBJECT_TYPE {

    DsDbObjectSam = 1,
    DsDbObjectLsa
} DS_DB_OBJECT_TYPE, *PDS_DB_OBJECT_TYPE;

//
// Structure which holds notification information For SAM
//
typedef struct _SAMP_NOTIFICATION_INFORMATION
{
    struct _SAMP_NOTIFICATION_INFORMATION * Next;
    ULONG                   iClass;
    DS_DB_OBJECT_TYPE       ObjectType;
    SECURITY_DB_DELTA_TYPE  DeltaType;
    NT4SID                  Sid;
    PUNICODE_STRING         AccountName;
    ULONG                   AccountControl;
    NT4SID                  UserSid;
    LUID                    UserAuthenticationId;
    DSNAME                 *Object;
    BOOL                    RoleTransfer;
    DOMAIN_SERVER_ROLE      NewRole;
    BOOL                    MixedModeChange;
    ULONG                   GroupType;
} SAMP_NOTIFICATION_INFORMATION;


typedef enum
{
    // Dir* depends on pTHS->SchemaUpdate being initialized to 
    // eNotSchemaOp by create_thread_state. create_thread_state
    // initializes pTHS->SchemaUpdate by effectively clearing
    // THSTATE. Specifically define eNotSchemaOp to 0 to highlight
    // the dependency.
    eNotSchemaOp = 0,

    eSchemaAttAdd,
    eSchemaAttMod,
    eSchemaAttDel,

    eSchemaClsAdd,
    eSchemaClsMod,
    eSchemaClsDel,

}SCENUM;

//
// A bunch of data structures used to track info that must be
// acted upon when committing to transaction level 0.
//
typedef struct _ESCROWITEM {
    DWORD   DNT;
    long    delta;
    long    ABRefdelta;
} ESCROWITEM;

typedef struct _ESCROWINFO {
    DWORD               cItems;     // elements in use in rItems
    DWORD               cItemsMax;  // max elements in rItems
    ESCROWITEM          *rItems;
} ESCROWINFO;

#define MODIFIED_OBJ_INFO_NUM_OBJS 6
//
// The following structure is used for tracking all DNTs and their PDNTs and
// NCDNTS  that are modified durring a transaction. This is used for a variety
// of things, including notifying waiting threads when these changes are
// committed, and invalidating objects in the gtcache.
//

#define MODIFIED_OBJ_modified       0
#define MODIFIED_OBJ_intrasite_move 1
#define MODIFIED_OBJ_intersite_move 2

typedef struct _MODIFIED_OBJ_FIELDS
{
    ULONG *pAncestors;
    ULONG cAncestors;
    ULONG ulNCDNT;
    BOOL  fNotifyWaiters;
    DWORD fChangeType;
} MODIFIED_OBJ_FIELDS;


typedef struct _MODIFIED_OBJ_INFO {
    DWORD cItems;
    MODIFIED_OBJ_FIELDS Objects[MODIFIED_OBJ_INFO_NUM_OBJS];
    struct _MODIFIED_OBJ_INFO *pNext;
} MODIFIED_OBJ_INFO;

typedef struct _HIERARCHYTABLEINFO {
    DWORD Count;
    DWORD *pABConts;
    int    adjustment;
    struct _HIERARCHYTABLEINFO *Next;
} HIERARCHYTABLEINFO, *PHIERARCHYTABLEINFO;

typedef struct _LOOPBACKTASKINFO
{
    struct _LOOPBACKTASKINFO *Next;
    PVOID                     TaskInfo;
} LOOPBACKTASKINFO, *PLOOPBACKTASKINFO;

#define OBJCACHE_ADD 1
#define OBJCACHE_DEL 2
typedef struct _OBJCACHE_DATA {
    DWORD           type;
    struct CROSS_REF_LIST *pCRL;
    MTX_ADDR       *pMTX;
    WCHAR          *pRootDNS;
    DSNAME         *pDN;
    struct _OBJCACHE_DATA *pNext;
} OBJCACHE_DATA;

/* This typedef describes a Linked-list of naming contexts;  A NC is the
   node name of a subtree root in this DSA.  Note that the NC must be the
   last element in the array because it is actually variable length and
   extends contiguously below its definition.
*/

typedef struct NAMING_CONTEXT_LIST {
   struct NAMING_CONTEXT_LIST *pNextNC;           /*Next Naming context*/
   NAMING_CONTEXT             *pNC;               /*Naming Context     */
   ATTRBLOCK                  *pNCBlock;          /*pre-parsed NC name */
   DWORD                       NCDNT;             /*NC DNT */
   BOOL                        fReplNotify;       /* must we notify others? */
   DWORD                       DelContDNT;        /*DNT of deleted ojbects   */
                                                  /*contaner (or INVALIDDNT) */
                                                  /* for this NC.            */
                                                  /* Not always maintained   */
   DWORD                       LostAndFoundDNT;   /*DNT of lost and found    */
                                                  /*contaner (or INVALIDDNT) */
                                                  /* for this NC.            */
                                                  /* Not always maintained   */

   ULONG                       ulEstimatedSize;  /* Estimated number of       */
                                                 /* entries in this NC        */
                                                 /* 0=not cestimated          */
   DWORD                       cbAncestors;      /* bytes in pAncestors     */
   DWORD                      *pAncestors;       /* DNTs of DSName's ancestors*/
} NAMING_CONTEXT_LIST;

typedef struct _CATALOG_UPDATES {
    NAMING_CONTEXT_LIST *pAddedEntries;     // ptr to the linked list of added entries
    NAMING_CONTEXT_LIST **pDeletedEntries;  // array of deleted entry pointers
                                            // (can not use linked list since they are still in the global list!)
    DWORD               dwDelCount;         // count of entries in the above array
    DWORD               dwDelLength;        // length of the currently allocated array
} CATALOG_UPDATES;

typedef struct _OBJCACHINGINFO
{
    BOOL fRecalcMapiHierarchy:1;
    BOOL fSignalSCache:1;
    BOOL fNotifyNetLogon:1;
    BOOL fSignalGcPromotion:1;
    OBJCACHE_DATA *pData;
    CATALOG_UPDATES masterNCUpdates;
    CATALOG_UPDATES replicaNCUpdates;
} OBJCACHINGINFO;


// The data type to wrap up all these.
typedef struct _NESTED_TRANSACTIONAL_DATA {
    BOOL                preProcessed;
    struct _NESTED_TRANSACTIONAL_DATA *pOuter; // points to outer level transaction.
    ESCROWINFO          escrowInfo;
    MODIFIED_OBJ_INFO  *pModifiedObjects;
    HIERARCHYTABLEINFO *pHierarchyTableInfo;
    LOOPBACKTASKINFO   *pLoopbackTaskInfo;
    OBJCACHINGINFO      objCachingInfo;
} NESTED_TRANSACTIONAL_DATA;



typedef struct _SESSIONCACHE {
    JET_SESID       sesid;
    JET_DBID        dbid;
    JET_TABLEID     objtbl;
    JET_TABLEID     searchtbl;
    JET_TABLEID     linktbl;
    JET_TABLEID     sdproptbl;
    JET_TABLEID     sdtbl;
    BOOL            tablesInUse;
    ULONG           transLevel;     // see transactionlevel below
    ULONG           cTickTransLevel1Started;    // tick at which transaction
                                                // level 1 was started
    NESTED_TRANSACTIONAL_DATA *dataPtr;
} SESSIONCACHE;

#define MAX_PDB_COUNT 8           // Better not open more that 8 PDB's

typedef struct _MEMZONE {
    PUCHAR Base;                // ptr to base of mem zone
    PUCHAR Cur;                 // ptr to next block to be allocated
    BOOL   Full;                // TRUE if no free space remains in zone
} MEMZONE;

#define ZONEBLOCKSIZE 16
#define ZONETOTALSIZE (ZONEBLOCKSIZE*1024)


typedef struct _SESSION_KEY {
    ULONG  SessionKeyLength;
    PUCHAR SessionKey;
} SESSION_KEY;

typedef struct _SEARCH_LOGGING {
    DWORD SearchEntriesVisited;    // number of entries visited during a search operation
    DWORD SearchEntriesReturned;   // number of entries returned during a search operation
    LPSTR pszFilter;               // the filter (processed) used for searching
    LPSTR pszIndexes;              // the indexes that the optimizer decided to use
} SEARCH_LOGGING;


typedef struct _LIST_OF_ERRORS {
    DWORD dsid;
    DWORD dwErr;
    DWORD data;
    WCHAR *pMessage;
    struct _LIST_OF_ERRORS *pPrevError;
} LIST_OF_ERRORS;


// CLIENT_CONTEXT struct.
//  ClientContext struct contains a hAuthzContext handle
//  The authz  context is created from the client token. The handle is created on-demand
//
//  The struct can be shared between an LDAP connection object and a thread.
//  Therefore, it is refcounted. NEVER assign a pointer to the struct directly,
//  use AssignClientContext function istead. To destroy context, assign NULL
//  to the variable that contains a reference.
//  NEVER use handle directly, instead, use access function: it ensures that
//  the handle is created (this is done on-demand).
//
//  The CLIENT_CONTEXTs stored in LDAP connections can
//  be reused by threads spawned by the same LDAP connection. Note that an LDAP
//  connection can change a context due to a BIND operation. If there are running
//  threads that were spawned previously by the same LDAP thread (such as a long
//  running search op), they will still use the original CLIENT_CONTEXT which will
//  be released automatically when they finish the job.
//

typedef struct _AUTHZ_CLIENT_CONTEXT {
    AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzContext;      // authz context
    LONG                            lRefCount;          // ref count
} *PAUTHZ_CLIENT_CONTEXT, AUTHZ_CLIENT_CONTEXT;

// TRANSACTIONS AND THREAD STATE.
//  Jet Transactions are on a per Jet Session basis. We always have one Jet
//  session per thread state. A DBOpen will obtain a new set of Jet cursors and
//  optionally begin a Jet Transaction. However note that Jet transaction
//  levels are cumulative on the Jet session. It is for this reason that we
//  must maintain state regarding transaction levels in the thread state.
//  Similarly any logic that requires state and needs to come in to play
//  conditionally on a transaction commit to level 0 needs to maintain its
//  state in the thread state.  Exceptions are CheckNameForRename and
//  CheckNameForAdd. They begin transactions on a fresh jet session after
//  resetting parameters in the thread state. Since they care to perform a
//  careful cleanup, the transaction in the thread state is not altered
//  after they have finished executing.  This has been made slightly easier by
//  associating transaction level and escrow information with a session cache
//  entry.

#define INVALID_TS_INDEX ((DWORD) -1)

typedef struct _THSTATE {

    HANDLE      hHeap;          // handle to per-thread heap
    MEMZONE     Zone;           // small block heap cache
    DWORD       dwClientID;     // Unique ID used by heads to identify specific
                                // connections. Set to 0 if no specific identity
                                // is required.
    ULONG       errCode;        // Identifies a Directory error
    DIRERR      *pErrInfo;      // full error information

    struct DBPOS *pDB;          // Holds a DB handle (NULL if not used)
    SESSIONCACHE JetCache;      // Jet handles of various sorts
#define transactionlevel JetCache.transLevel
    VIEW_SECURITY_CACHE * ViewSecurityCache;
    HANDLE      hThread;        // thread handle - see create_thread_state

    //BITFIELD BLOCK.  Please add all new booleans and bitfields here

    unsigned    transType:2;    // Indicates if this transaction is a
                                // reader, a writer or a writer that
                                // allows reads.  Set by Sync calls
                                // at the start of each transaction.
    unsigned    transControl:2; // one of DirTransactionControl values
    BOOL        fSyncSet:1;     // A sync point is active (the usual case)
    BOOL        fCatalogCacheTouched:1; //Indicates that the catalog information has been updated
    BOOL        fSDP:1;         // TRUE if this is a SD propagator thread.
    BOOL        fDRA:1;         // TRUE if this is a replicator thread.
    BOOL        fEOF:1;         // End Of File flag (used by Nspi)
    BOOL        fLazyCommit:1;  // should we commit lazily?
    BOOL        fDSA:1;         // TRUE if the thread is acting on behalf of
                                // the DSA itself (e.g. during startup), FALSE
                                // if the thread is acting on behalf of an RPC
                                // client.
    BOOL        fSAM:1;         // TRUE if this thread is from SAM.
    BOOL        fSamDoCommit:1; // TRUE if SAM commit should commit DS too.
    BOOL        fSamWriteLockHeld:1; // TRUE if the DS has acquired the SAM
                                // write lock
    BOOL        UpdateDITStructure:1; // TRUE if Schema Recalculation also
                                // results in a DIT update
    BOOL        RecalcSchemaNow:1;    // TRUE if we want the schema update
                                // immediately.
    BOOL        fLsa:1;         // Call was originated by the Lsa
    BOOL        fAccessChecksCompleted:1;// Set By Loopback to indicate that
                                // access checks have completed and the
                                // core DS need not bother doing access
                                // checks
    BOOL        fGCLocalCleanup:1;  // Set if the thread is performing local
                                    // cleanup on a GC to purge attributes
                                    // removed from the partial attribute set
    BOOL        fDidInvalidate:1;   // Set if any attempt to invalidate an
                                    // object in the dnread cache (local or
                                    // global) was made.
    BOOL        fBeginDontEndHoldsSamLock:1;    // See SET_SAM_LOCK_TRACKING
                                                // in dsatools.c

    BOOL        fCrossDomainMove:1; // Enable exceptions for X-dom move.

    BOOL        fNlSubnetNotify:1; // Tell NetLogon about subnet change
    BOOL        fNlSiteObjNotify:1;// Tell NetLogon about site object change
    BOOL        fNlSiteNotify:1;   // Tell NetLogon that we changed sites
    BOOL        fDefaultLcid:1;    // Is the LCID in the dwLcid field default?
    BOOL        fPhantomDaemon:1;  // TRUE if this is the phantom daemon.
    BOOL        fAnchorInvalidated:1; // TRUE if a change in the open transaction
                                   // has invalidated a portion of the anchor
    BOOL        fSchemaConflict:1; // Used by DRA to indicate that a conflict
                                   // is detected while replicating in the
                                   // schema NC, so all later updates in the
                                   // in the packet should not be committed
                                   // (but still process to find any further
                                   // conflicts)
    BOOL        fExecuteKccOnCommit:1; // TRUE if kcc run should be triggered
                                   // on successful commit of 0th trans
    BOOL        fLinkedValueReplication:1; // TRUE if this feature is enabled
                                  // This feature requires forest-wide upgrade
                        // FALSE in W2K, and may be enabled in W2K+1 or greater
    BOOL        fNlDnsRootAliasNotify:1; // Notify NetLogon the DnsRootAlias is changed
    BOOL        fSingleUserModeThread:1; // TRUE if this is the thread for the
                                       // single user mode dealing with
                                       // high risk stuff
    BOOL        fDeletingTree:1;    // TRUE if a tree is being deleted. No permission checks
                                    // are done, just audits for deleting objects.
    BOOL        fBehaviorVersionUpdate:1; //invoke behaviorversionUpdate thread
                                          //after the transaction 
    BOOL        fIsValidLongRunningTask:1; // This tells the DS that this is a long
                                           // running thread, that should be immune
                                           // to the assert on long running threads.
    // end OF BITFIELD BLOCK

    SAMP_NOTIFICATION_INFORMATION
                * pSamNotificationTail;
    SAMP_NOTIFICATION_INFORMATION
                * pSamNotificationHead; // Holds Information for Notification
                                        // for downlevel replication. Changes are
                                        // added to the tail of the list. While notifications
                                        // are issued from the Head. Maintiaing 2 pointers provides
                                        // quick access while preserving the order of notifications.

    USN         UnCommUsn;      // Lowest uncommited usn
    HANDLE      hHeapOrg;       // for use by TH_mark and TH_free_to_mark
    MEMZONE     ZoneOrg;        // for use by TH_mark and TH_free_to_mark
    struct _THSTATE *   pSpareTHS; // for use by TH_mark and TH_free_to_mark
    ULONG       cAllocs;        // count of outstanding allocs from the heap
    ULONG       cAllocsOrg;     // for use by TH_mark and TH_free_to_mark
    LCID        dwLcid;         // Locale to use for Unicode compares.  Null
                                // means to use a default sort
    VOID        *pSamLoopback;  // SAM loopback argument block.
    SAMP_SEARCH_INFORMATION
                *pSamSearchInformation; // SAM search information block
    BOOL        NTDSErrorFlag;  // Output Error Info on Dir Call Failures.

    VOID        *phSecurityContext; // When non-null gives SSP context
    ImpersonationState impState;// Client type we're currently impersonating
    FILETIME    TimeCreated;    // When this THSTATE was created
    ULONG       ulTickCreated;  // TickCount when this THSTATE was created
    struct _schemaptr *CurrSchemaPtr;  // SchemaPtr
    SCENUM      SchemaUpdate;   // It is a Schema Update (set to eNotSchemaOp
                                // by RecycleHeap and GrabHeap
    PVOID       NewPrefix;         // Pointer to any new prefix added that is still not in the global prefix table
    ULONG       cNewPrefix;        // No. of new prefixes added by this thread
    PVOID       pClassPtr;      // To keep a pointer to the pre-updated copy of a
                                // class-schema object during class-modify so that
                                // a comparison can be done later with the updated version
    PVOID       pCachedSDInfo;   // To cache last default SD converted to allow
                                // caching during default SD conversions during schema cache load
    VOID        *GCVerifyCache; // cache of names successfully verified
                                // against the GC.

    DRS_EXTENSIONS *pextRemote; // DRS interface extensions supported by the
                                // current client (set only if DRA thread)

    ULONG       opendbcount;     // open dbpos count for this thread

    PVOID       pNotifyNCs;     // List of NCDNTs to notify on commit (see dbtools.c\DbTransOut)

    DWORD       CallerType;     // Used for directory usage statistics

    DWORD       CipherStrength; // strength of cipher encoding in bits
                                // 0 if not secure link

    DWORD       spaceHolder;    // TO BE REUSED / REMOVED

    GLOBALDNREADCACHE *Global_DNReadCache;   // The DNReadCache.
    DWORD        cGlobalCacheHits;
    DWORD        *pGlobalCacheHits; // Track hot objects in the Global Cache.
    DSTIME       LocalDNReadOriginSequence;
                                // When was the LocalDNRead cache last reset?
                                // This tracks the invalidate sequence number
                                // used by the global dnread cache.
    DNREADCACHEBUCKET LocalDNReadCache[LOCAL_DNREAD_CACHE_SIZE];

    PVOID       TraceHeader;    // WMI trace header
    DWORD       ClientIP;       // IP address of LDAP client

    PLOOPBACKTASKINFO
                SamTaskList;    // List of to do items for SAM once when
                                // a transaction commits

    // Items for delegated impersonation.
    VOID          *pCtxtHandle;     // Original client ctxt when impersonating.
    // End items for delegated impersonation.
    DWORD       ClientContext;  // Context that uniquely identifies a client. Used by WMI to
                                // track client activity

    DWORD       dsidOrigin;     // DSID of InitTHSTATE which made this THSTATE

    SESSION_KEY SessionKey;     // For a replicator thread, this is the
                                // the session key established between
                                // this DC and the remote DC.

    PAUTHZ_CLIENT_CONTEXT       pAuthzCC;               // AUTHZ_CLIENT_CONTEXT ptr (initially NULL)
    AUTHZ_AUDIT_EVENT_HANDLE     hAuthzAuditInfo;        // audit info handle (created on demand)

    SEARCH_LOGGING searchLogging; // performance logging for search operations

    UUID        InvocationID;   // Invocation ID at the time our thread/
                                // transaction was created
    PVOID       pExtSchemaPtr;  // extended SchemaPtr

    LIST_OF_ERRORS *pErrList;   // used to keep track of erros in the script processing
    
#if DBG
    ULONG       Size;           // The running total of memory allocated
    ULONG       SizeOrg;        // for use by TH_mark and TH_free_to_mark
    ULONG       Totaldbpos;     // Total number of dbpos's opened so far. Statistic for
                                // performance tracking
    struct DBPOS *pDBList[MAX_PDB_COUNT]; // Array of all the DBPOS's that are currently
                                          // opened on this thread state. This is used
                                          // to keep track of all opened DBPoses by this
                                          // thread and can be used to verify DBPoses in
                                          // the debugger.
    PVOID       pRpcSecurityContext; // Pointer to the security context
                                     // that we actually recieved in a callback
                                     // from RPC . This is useful in tracking
                                     // any password encryption problems when
                                     // replicating
    PVOID       pRpcCallHandle;  // Pointer to the actual RPC call handle that
                                 // was actually recieved in a callback from
                                 // RPC. This is useful in tracking any password
                                 // encryption system problems when replicating
#endif

#ifdef USE_THALLOC_TRACE
    HANDLE      hDebugMemHeap;     // Heap used for debugging purposes
    HANDLE      hDebugMemHeapOrg;  // Heap used for debugging purposes
    PVOID       pDebugHeapLog;
#endif

}THSTATE;


// This macro checks to make sure a THSTATE seems valid.  We check to see
// that it has a non-null address, that it has a non-null heap, that
// the THSTATE seems to have been allocated from its heap, and that
// (since THSTATEs are supposed to be short lived) the THSTATE was
// initialized within the last hour.  In real life I'd expect a THSTATE to
// be recycled within seconds, but under a debugger I can imagine slow step
// throughs taking quite a while.  Since the goal of this clause is to
// catch internal callers who create a THSTATE at IPL time and then
// (incorrectly) never free it, we have the limit set to be long enough
// to not falsely trigger under a slow debug session, but short enough
// to get caught during normal test passes.

extern BOOL IsValidTHSTATE(THSTATE *, ULONG);

#define VALID_THSTATE(pTHS)                     \
    IsValidTHSTATE(                             \
        pTHS,                                   \
        GetTickCount()                          \
        )


// Verify if the caller is a member of a group. If the security context is unavailable, then
// it will be obtained by impersonating the client.
DWORD
CheckGroupMembershipAnyClient(
    IN THSTATE *pTHS,
    IN PSID groupSid,
    OUT BOOL *bResult
    );

// assign a client context ptr to a variable
// IMPORTANT: NEVER copy pointers to CLIENT_CONTEXT directly, always
// use this function. This ensures that they are properly refcounted.
VOID AssignAuthzClientContext(
    IN PAUTHZ_CLIENT_CONTEXT *var,
    IN PAUTHZ_CLIENT_CONTEXT value
    );

// get AuthzContext from thread state. If the context has not yet been allocated
// then the client will get impersonated, token grabbed and Authz context created.
// Then the client is unimpersonated again.
DWORD
GetAuthzContextHandle(
    IN THSTATE *pTHS,
    OUT AUTHZ_CLIENT_CONTEXT_HANDLE *phAuthzContext
    );


typedef struct _RESOBJ {
    DSNAME       *pObj;
    DWORD        InstanceType;
    ATTRTYP      MostSpecificObjClass;
    DWORD        DNT;
    DWORD        PDNT;
    DWORD        NCDNT;
    BOOL         IsDeleted;
} RESOBJ;


// This is some types to support creating an NC head in an add operation.
typedef struct _CREATENCINFO {
    INT               iKind;   // This is whether it is a Config, Schema,
                               //     Domain, or Non-Domain NC from the
                               //     constants below this struct.
    BOOL              fNcAbove:1; // This flag indicates that the parent
                                  //     object is a local NC.
    BOOL              fTestAdd:1; // This flag is used to indicate we're
                                  //     testing an add, to see if we
                                  //     should add a cross-ref.
    BOOL              fNullNcGuid:1; // This tells us whether the GUID
                                     // of the NC was on the cross-ref,
                                     // if not, we need to create an
                                     // infrastructure update object.
    BOOL              fSetRefDom:1;  // Set if we need to set the reference
                                     // domain on the cross-ref, typically
                                     // the case, as usually the ref dom
                                     // isn't preset.
    CROSS_REF *       pSDRefDomCR; // This is a pointer to the crossRef of
                                   // of the reference domain for SDs in
                                   // the NDNC being created.
} CREATENCINFO;

#define   CREATE_DOMAIN_NC            0x00000001
#define   CREATE_SCHEMA_NC            0x00000002
#define   CREATE_CONFIGURATION_NC     0x00000004
#define   CREATE_NONDOMAIN_NC         0x00000008

#define VALID_CREATENCINFO(x)         ((x) && \
                                       ((x->iKind & CREATE_DOMAIN_NC) || \
                                        (x->iKind & CREATE_SCHEMA_NC) || \
                                        (x->iKind & CREATE_CONFIGURATION_NC) || \
                                        (x->iKind & CREATE_NONDOMAIN_NC)))

typedef struct _ADDCROSSREFINFO {
    DSNAME *          pdnNcName;       // This is the name of the nCName attr of
                                       // the crossRef that we're trying to add.
    BOOL              bEnabled;        // THis is the enabled attr of the crossRef
                                       // we're trying to add.
    ULONG             ulSysFlags;      // This is the systemFlags attr of the
                                       // crossRef that we're trying to add.
    ULONG             ulDsCrackChild;  // Result of the DsCrackNames() for the
                                       // modulated canonical name of the child
                                       // check.
    ULONG             ulChildCheck;    // Independant name specific result of the
                                       // child check we usually expect an error
                                       // for this.
    WCHAR *           wszChildCheck;   // The DN we retrieved for the child check,
                                       // typically this will be a NULL.
    ULONG             ulDsCrackParent; // Result of the DsCrackNames() for the
                                       // Parent DN, we expect this to be 0.
    ULONG             ulParentCheck;   // This is the independant name specific
                                       // error for the DN parent check.  We expect
                                       // this to be 0.
    GUID              ParentGuid;      // This is the GUID retrived for the parent
                                       // DN, we expect this to be !fNullUuid()
} ADDCROSSREFINFO;

VOID
SetCommArgDefaults(
    IN DWORD MaxTempTableSize
    );

// returns info about the RDN in a DSNAME
unsigned GetRDNInfo(THSTATE *pTHS,
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype);

extern DWORD     NTDSErrorFlag;

//
// Valid definitions for NTDSErrorFlag
//

#define NTDSERRFLAG_DISPLAY_ERRORS           0x00000001
#define NTDSERRFLAG_DUMP_TOKEN               0x00000002

//
// Add More Flag Definitions in here.
//

#define NTDSERRFLAG_DISPLAY_ERRORS_AND_BREAK 0x80000000

//
// Macro for testing ntdserror flag
//

#define TEST_ERROR_FLAG(_Value) \
            ((NTDSErrorFlag|pTHStls->NTDSErrorFlag) & _Value)

extern BOOL gUpdatesEnabled;
extern DWORD dwTSindex;
extern BOOL gfRunningInsideLsa;
extern volatile BOOL fAssertLoop;
extern volatile ULONG ulcActiveReplicationThreads;

typedef enum {
    eRunning = 0,
    eRemovingClients = 1,
    eSecuringDatabase = 2,
    eFreeingResources = 3,
    eStopped = 4
} SHUTDOWN;
extern volatile SHUTDOWN eServiceShutdown;


#define LOCALE_SENSITIVE_COMPARE_FLAGS  (NORM_IGNORECASE     |   \
                                         NORM_IGNOREKANATYPE |   \
                                         NORM_IGNORENONSPACE |   \
                                         NORM_IGNOREWIDTH    |   \
                                         NORM_IGNORESYMBOLS  |   \
                                         SORT_STRINGSORT)

/* Floating Single Master Operation (FSMO) functions and defines */

/* FSMO functions */
ULONG ReqFSMOOp(THSTATE *        pTHS,
                DSNAME  *        pFSMO,
                ULONG            RepFlags,
                ULONG            ulOp,
                ULARGE_INTEGER * pllFsmoInfo,
                ULONG   *        pulRet);

ULONG
ReqFsmoGiveaway(THSTATE *pTHS,
                DSNAME  *pFSMO,
                DSNAME  *pTarget,
                ULONG   *pExtendedRet);

/* FSMO Operations */
#define FSMO_REQ_ROLE       1   /* Request Role-Owner transfer */
#define FSMO_REQ_RID_ALLOC  2   /* Request RID allocation */
#define FSMO_RID_REQ_ROLE   3   /* Request RID Role-Owner transfer */
#define FSMO_REQ_PDC        4   /* Request PDC Role-Owner transfer */
#define FSMO_ABANDON_ROLE   5   /* Tells Callee to call back and request */
                                /* a role transfer for this role */
// NOTE: If you add more codes to this list, please also update the debugger
// extensions translation code in dsexts\dra.c.

/* FSMO Errors */
/* 0 deliberately left unused to distinguish FSMO and non-FSMO replies */
#define FSMO_ERR_SUCCESS        1
#define FSMO_ERR_UNKNOWN_OP     2   /* unrecognized request */
#define FSMO_ERR_NOT_OWNER      3   /* callee was not role-owner */
#define FSMO_ERR_UPDATE_ERR     4   /* could not modify objects to be returned */
#define FSMO_ERR_EXCEPTION      5   /* callee blew up */
#define FSMO_ERR_UNKNOWN_CALLER 6   /* caller's object not present on owner */
#define FSMO_ERR_RID_ALLOC      7   /* unable to alloc RID pool to a DSA */
#define FSMO_ERR_OWNER_DELETED  8   /* owning DSA object is deleted */
#define FSMO_ERR_PENDING_OP     9   /* operation in progress on owning DSA */
#define FSMO_ERR_MISMATCH      10   /* caller/callee have different notion of
                                       the fsmo object */

#define FSMO_ERR_COULDNT_CONTACT 11 /* can't reach current FSMO via rpc */
#define FSMO_ERR_REFUSING_ROLES  12 /* currently giving away fsmo's */
#define FSMO_ERR_DIR_ERROR       13 /* DbFindDSName failed */
#define FSMO_ERR_MISSING_SETTINGS 14 /* Can't find ATT_FSMO_ROLE_OWNER */
#define FSMO_ERR_ACCESS_DENIED   15 /* control access is not granted */

// NOTE: If you add more codes to this list, please also update the debugger
// extensions translation code in dsexts\dra.c.

#endif  /* _mdglobal_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\nsp_both.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nsp_both.h
//
//--------------------------------------------------------------------------

/*
 *      Common Name Service Provider Header
 *
 *  Things both the client and server side need to know
 */

#ifndef CP_WINUNICODE
#define CP_WINUNICODE 1200
#endif

#if (CP_WINUNICODE != 1200)
#error Win32 definition of CP_WINUNICODE has changed!
#endif
     
/*
 *  Basic data types and macros
 */
#ifndef _NSP_BOTH
#define _NSP_BOTH


#define EMAIL_TYPE     "EX"
#define EMAIL_TYPE_W   L"EX"

#define MAX_RECS    50

/* Number of rows to get on pre-emptive Query-Rows done by GetMatches. */
#define  DEF_SROW_COUNT 50

/*
 * ModLinkAtt Flags.
 */
#define fDELETE         0x1

/*
 * Searching and seeking flags
 */
#define bAPPROX		0
#define bEXACT		0x1
#define bPREFIX		0x2
#define bADMIN          0x8
#define bEND            0x10

/*
 * Flag for logon
 */
#define fAnonymousLogin 0x1

/*
 *  Flags for NspiModProp.
 */
#define AB_ADD                  1 // The modify is really adding a new object

/* 
 * Flags for NspiGetProps.
 */
#define AB_SKIP_OBJECTS	1

/*
 *  Flags for NspiGetHierarchyInfo
 */
#define AB_DOS			1
#define AB_ONE_OFF              2
#define AB_UNICODE              4
#define AB_ADMIN                8
#define AB_PAGE_HIER            16

/*
 *  Flags for ulInterfaceOptions on OpenProperty
 * This flag is strictly internal.  Other, external, flags are
 * defined in emsabtag.h
 */
#define AB_LINK_ONLY             1

/*
 *  Values for flags used in GetProps and QueryRows to describe behavior
 *  of the GetSRow call. These flags are used as a bit map, so use powers
 *  of 2 for new flags.
 */

/* default handling of entry ids is to return a permanent, this flag forces
 * use of an ephemeral.
 */
#define fEPHID                 2
/* default handling of deleted or phantom objects is to not find them.  This
 * flag tells us to fake up properties for these things if they are in a
 * restriction.
 */
#define fPhantoms              4   

#define   ONE_OFF_PROP_COUNT    7       // # of propvals in a OneOffTable row

/*
 * Flags for NspiGetTemplateInfo
 *
 * TI_MAX_TEMPLATE_INFO is the number of different information items that can
 * be returned.  TI_foo is a flag asking for the foo information.
 */
#define TI_MAX_TEMPLATE_INFO 6
#define TI_TEMPLATE	 1
#define TI_DOS_TEMPLATE	 2
#define TI_SCRIPT	 4
#define TI_HELPFILE16 	 8
#define TI_EMT		 16
#define TI_HELPFILE_NAME 32
#define TI_HELPFILE32 	 64


typedef struct  _CNTRL {
    DWORD dwType;
    ULONG ulSize;
    LPSTR pszString;
} CNTRL;

typedef struct  _TROW {
    long lXPos;
    long lDeltaX;
    long lYPos;
    long lDeltaY;
    long lControlType;
    long lControlFlags;
    CNTRL cnControlStruc;
} TROW, FAR * LPTROW;

typedef struct  _TRowSet_r {
    ULONG ulVersion;
    ULONG cRows;
    TROW aRow[1];
} TRowSet, FAR * LPTRowSet, FAR * FAR * LPLPTRowSet;

#define DSA_TEMPLATE     1

/* 
 * The following codes are defined by windows NT in winerror.h. However, we need
 * to access them on all platforms, so define them here if they are not 
 * previously defined.
 */

#ifndef ERROR_PASSWORD_MUST_CHANGE
#define ERROR_PASSWORD_MUST_CHANGE	1907L
#endif
#ifndef ERROR_PASSWORD_EXPIRED
#define ERROR_PASSWORD_EXPIRED		1330L
#endif
#ifndef ERROR_INVALID_WORKSTATION
#define ERROR_INVALID_WORKSTATION	1329L
#endif
#ifndef ERROR_INVALID_LOGON_HOURS
#define ERROR_INVALID_LOGON_HOURS	1328L
#endif
#ifndef ERROR_ACCOUNT_DISABLED
#define ERROR_ACCOUNT_DISABLED		1331L
#endif

#endif      // ifdef _NSP_BOTH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\msdsmapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       msdsmapi.h
//
//--------------------------------------------------------------------------

/*++
 File:    MSDSMAPI.H
 Purpose: Contains the MAPI Definition .
 Creator: Automatically Generated on
 Date:    Thu Dec 21 10:55:04 2000

 ** This is a Generated File From Schema.INI **
 ** DO NOT MODIFY  DIRECTLY  **
 ** DO NOT INCLUDE DIRECTLY  **

--*/
#define PR_EMS_AB_ADDRESS                                       PROP_TAG(PT_TSTRING            , 0x3A29)
#define PR_EMS_AB_ADDRESS_A                                     PROP_TAG(PT_STRING8            , 0x3A29)
#define PR_EMS_AB_ADDRESS_W                                     PROP_TAG(PT_UNICODE            , 0x3A29)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE                   PROP_TAG(PT_BINARY             , 0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS             PROP_TAG(PT_BINARY             , 0x8047)
#define PR_EMS_AB_ADDRESS_HOME                                  PROP_TAG(PT_TSTRING            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_HOME_A                                PROP_TAG(PT_STRING8            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_HOME_W                                PROP_TAG(PT_UNICODE            , 0x3A5D)
#define PR_EMS_AB_ADDRESS_SYNTAX                                PROP_TAG(PT_BINARY             , 0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                                  PROP_TAG(PT_TSTRING            , 0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A                                PROP_TAG(PT_STRING8            , 0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W                                PROP_TAG(PT_UNICODE            , 0x8048)
#define PR_EMS_AB_ADMIN_DESCRIPTION                             PROP_TAG(PT_TSTRING            , 0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A                           PROP_TAG(PT_STRING8            , 0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W                           PROP_TAG(PT_UNICODE            , 0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME                            PROP_TAG(PT_TSTRING            , 0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A                          PROP_TAG(PT_STRING8            , 0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W                          PROP_TAG(PT_UNICODE            , 0x804B)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST                     PROP_TAG(PT_MV_BINARY          , 0x8026)
#define PR_EMS_AB_BUSINESS_CATEGORY                             PROP_TAG(PT_MV_TSTRING         , 0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A                           PROP_TAG(PT_MV_STRING8         , 0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W                           PROP_TAG(PT_MV_UNICODE         , 0x8057)
#define PR_EMS_AB_CA_CERTIFICATE                                PROP_TAG(PT_MV_BINARY          , 0x8003)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST                   PROP_TAG(PT_BINARY             , 0x8016)
#define PR_EMS_AB_COMMENT                                       PROP_TAG(PT_TSTRING            , 0x3004)
#define PR_EMS_AB_COMMENT_A                                     PROP_TAG(PT_STRING8            , 0x3004)
#define PR_EMS_AB_COMMENT_W                                     PROP_TAG(PT_UNICODE            , 0x3004)
#define PR_EMS_AB_COMMON_NAME                                   PROP_TAG(PT_TSTRING            , 0x3A0F)
#define PR_EMS_AB_COMMON_NAME_A                                 PROP_TAG(PT_STRING8            , 0x3A0F)
#define PR_EMS_AB_COMMON_NAME_W                                 PROP_TAG(PT_UNICODE            , 0x3A0F)
#define PR_EMS_AB_COMPANY                                       PROP_TAG(PT_TSTRING            , 0x3a16)
#define PR_EMS_AB_COMPANY_A                                     PROP_TAG(PT_STRING8            , 0x3a16)
#define PR_EMS_AB_COMPANY_W                                     PROP_TAG(PT_UNICODE            , 0x3a16)
#define PR_EMS_AB_COST                                          PROP_TAG(PT_LONG               , 0x8068)
#define PR_EMS_AB_COUNTRY_NAME                                  PROP_TAG(PT_TSTRING            , 0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A                                PROP_TAG(PT_STRING8            , 0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W                                PROP_TAG(PT_UNICODE            , 0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR                        PROP_TAG(PT_MV_BINARY          , 0x8025)
#define PR_EMS_AB_DELTA_REVOCATION_LIST                         PROP_TAG(PT_MV_BINARY          , 0x8C46)
#define PR_EMS_AB_DEPARTMENT                                    PROP_TAG(PT_TSTRING            , 0x3A18)
#define PR_EMS_AB_DEPARTMENT_A                                  PROP_TAG(PT_STRING8            , 0x3A18)
#define PR_EMS_AB_DEPARTMENT_W                                  PROP_TAG(PT_UNICODE            , 0x3A18)
#define PR_EMS_AB_DESCRIPTION                                   PROP_TAG(PT_MV_TSTRING         , 0x806F)
#define PR_EMS_AB_DESCRIPTION_A                                 PROP_TAG(PT_MV_STRING8         , 0x806F)
#define PR_EMS_AB_DESCRIPTION_W                                 PROP_TAG(PT_MV_UNICODE         , 0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR                         PROP_TAG(PT_MV_TSTRING         , 0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A                       PROP_TAG(PT_MV_STRING8         , 0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W                       PROP_TAG(PT_MV_UNICODE         , 0x8070)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE                        PROP_TAG(PT_TSTRING            , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A                      PROP_TAG(PT_STRING8            , 0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W                      PROP_TAG(PT_UNICODE            , 0x39FF)
#define PR_EMS_AB_DMD_NAME                                      PROP_TAG(PT_TSTRING            , 0x8C56)
#define PR_EMS_AB_DMD_NAME_A                                    PROP_TAG(PT_STRING8            , 0x8C56)
#define PR_EMS_AB_DMD_NAME_W                                    PROP_TAG(PT_UNICODE            , 0x8C56)
#define PR_EMS_AB_DSA_SIGNATURE                                 PROP_TAG(PT_BINARY             , 0x8077)
#define PR_EMS_AB_E_MAIL_ADDRESSES                              PROP_TAG(PT_TSTRING            , 0x39FE)
#define PR_EMS_AB_E_MAIL_ADDRESSES_A                            PROP_TAG(PT_STRING8            , 0x39FE)
#define PR_EMS_AB_E_MAIL_ADDRESSES_W                            PROP_TAG(PT_UNICODE            , 0x39FE)
#define PR_EMS_AB_EMPLOYEE_NUMBER                               PROP_TAG(PT_TSTRING            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_NUMBER_A                             PROP_TAG(PT_STRING8            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_NUMBER_W                             PROP_TAG(PT_UNICODE            , 0x8C67)
#define PR_EMS_AB_EMPLOYEE_TYPE                                 PROP_TAG(PT_TSTRING            , 0x8C69)
#define PR_EMS_AB_EMPLOYEE_TYPE_A                               PROP_TAG(PT_STRING8            , 0x8C69)
#define PR_EMS_AB_EMPLOYEE_TYPE_W                               PROP_TAG(PT_UNICODE            , 0x8C69)
#define PR_EMS_AB_ENABLED                                       PROP_TAG(PT_BOOLEAN            , 0x8C21)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED                        PROP_TAG(PT_BOOLEAN            , 0x80A7)
#define PR_EMS_AB_EXTENSION_NAME                                PROP_TAG(PT_MV_TSTRING         , 0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A                              PROP_TAG(PT_MV_STRING8         , 0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W                              PROP_TAG(PT_MV_UNICODE         , 0x80A9)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER                    PROP_TAG(PT_TSTRING            , 0x3a23)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER_A                  PROP_TAG(PT_STRING8            , 0x3a23)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER_W                  PROP_TAG(PT_UNICODE            , 0x3a23)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD                           PROP_TAG(PT_LONG               , 0x80AF)
#define PR_EMS_AB_GENERATION_QUALIFIER                          PROP_TAG(PT_TSTRING            , 0x8C53)
#define PR_EMS_AB_GENERATION_QUALIFIER_A                        PROP_TAG(PT_STRING8            , 0x8C53)
#define PR_EMS_AB_GENERATION_QUALIFIER_W                        PROP_TAG(PT_UNICODE            , 0x8C53)
#define PR_EMS_AB_GIVEN_NAME                                    PROP_TAG(PT_TSTRING            , 0x3A06)
#define PR_EMS_AB_GIVEN_NAME_A                                  PROP_TAG(PT_STRING8            , 0x3A06)
#define PR_EMS_AB_GIVEN_NAME_W                                  PROP_TAG(PT_UNICODE            , 0x3A06)
#define PR_EMS_AB_HAS_MASTER_NCS                                PROP_TAG(PT_MV_OBJECT          , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A                              PROP_TAG(PT_MV_STRING8         , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W                              PROP_TAG(PT_MV_UNICODE         , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O                              PROP_TAG(PT_MV_OBJECT          , 0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T                              PROP_TAG(PT_MV_TSTRING         , 0x80B6)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS                       PROP_TAG(PT_MV_OBJECT          , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_A                     PROP_TAG(PT_MV_STRING8         , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_W                     PROP_TAG(PT_MV_UNICODE         , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_O                     PROP_TAG(PT_MV_OBJECT          , 0x80B5)
#define PR_EMS_AB_HAS_PARTIAL_REPLICA_NCS_T                     PROP_TAG(PT_MV_TSTRING         , 0x80B5)
#define PR_EMS_AB_HELP_DATA16                                   PROP_TAG(PT_BINARY             , 0x803A)
#define PR_EMS_AB_HELP_DATA32                                   PROP_TAG(PT_BINARY             , 0x8010)
#define PR_EMS_AB_HELP_FILE_NAME                                PROP_TAG(PT_TSTRING            , 0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A                              PROP_TAG(PT_STRING8            , 0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W                              PROP_TAG(PT_UNICODE            , 0x803B)
#define PR_EMS_AB_INITIALS                                      PROP_TAG(PT_TSTRING            , 0x3A0A)
#define PR_EMS_AB_INITIALS_A                                    PROP_TAG(PT_STRING8            , 0x3A0A)
#define PR_EMS_AB_INITIALS_W                                    PROP_TAG(PT_UNICODE            , 0x3A0A)
#define PR_EMS_AB_INSTANCE_TYPE                                 PROP_TAG(PT_LONG               , 0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER                     PROP_TAG(PT_MV_TSTRING         , 0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A                   PROP_TAG(PT_MV_STRING8         , 0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W                   PROP_TAG(PT_MV_UNICODE         , 0x80BE)
#define PR_EMS_AB_INVOCATION_ID                                 PROP_TAG(PT_BINARY             , 0x80BF)
#define PR_EMS_AB_IS_DELETED                                    PROP_TAG(PT_BOOLEAN            , 0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL                               PROP_TAG(PT_MV_OBJECT          , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A                             PROP_TAG(PT_MV_STRING8         , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W                             PROP_TAG(PT_MV_UNICODE         , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O                             PROP_TAG(PT_MV_OBJECT          , 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T                             PROP_TAG(PT_MV_TSTRING         , 0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED                              PROP_TAG(PT_BOOLEAN            , 0x80C1)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION                         PROP_TAG(PT_MV_TSTRING         , 0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A                       PROP_TAG(PT_MV_STRING8         , 0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W                       PROP_TAG(PT_MV_UNICODE         , 0x80C3)
#define PR_EMS_AB_LDAP_DISPLAY_NAME                             PROP_TAG(PT_TSTRING            , 0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A                           PROP_TAG(PT_STRING8            , 0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W                           PROP_TAG(PT_UNICODE            , 0x8171)
#define PR_EMS_AB_LINK_ID                                       PROP_TAG(PT_LONG               , 0x80C5)
#define PR_EMS_AB_LOCALITY_NAME                                 PROP_TAG(PT_TSTRING            , 0x3A27)
#define PR_EMS_AB_LOCALITY_NAME_A                               PROP_TAG(PT_STRING8            , 0x3A27)
#define PR_EMS_AB_LOCALITY_NAME_W                               PROP_TAG(PT_UNICODE            , 0x3A27)
#define PR_EMS_AB_MANAGED_BY                                    PROP_TAG(PT_OBJECT             , 0x800C)
#define PR_EMS_AB_MANAGED_BY_A                                  PROP_TAG(PT_STRING8            , 0x800C)
#define PR_EMS_AB_MANAGED_BY_W                                  PROP_TAG(PT_UNICODE            , 0x800C)
#define PR_EMS_AB_MANAGED_BY_O                                  PROP_TAG(PT_OBJECT             , 0x800C)
#define PR_EMS_AB_MANAGED_BY_T                                  PROP_TAG(PT_TSTRING            , 0x800C)
#define PR_EMS_AB_MANAGED_OBJECTS                               PROP_TAG(PT_MV_OBJECT          , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_A                             PROP_TAG(PT_MV_STRING8         , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_W                             PROP_TAG(PT_MV_UNICODE         , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_O                             PROP_TAG(PT_MV_OBJECT          , 0x8024)
#define PR_EMS_AB_MANAGED_OBJECTS_T                             PROP_TAG(PT_MV_TSTRING         , 0x8024)
#define PR_EMS_AB_MANAGER                                       PROP_TAG(PT_OBJECT             , 0x8005)
#define PR_EMS_AB_MANAGER_A                                     PROP_TAG(PT_STRING8            , 0x8005)
#define PR_EMS_AB_MANAGER_W                                     PROP_TAG(PT_UNICODE            , 0x8005)
#define PR_EMS_AB_MANAGER_O                                     PROP_TAG(PT_OBJECT             , 0x8005)
#define PR_EMS_AB_MANAGER_T                                     PROP_TAG(PT_TSTRING            , 0x8005)
#define PR_EMS_AB_MAPI_ID                                       PROP_TAG(PT_LONG               , 0x80CE)
#define PR_EMS_AB_MEMBER                                        PROP_TAG(PT_MV_OBJECT          , 0x8009)
#define PR_EMS_AB_MEMBER_A                                      PROP_TAG(PT_MV_STRING8         , 0x8009)
#define PR_EMS_AB_MEMBER_W                                      PROP_TAG(PT_MV_UNICODE         , 0x8009)
#define PR_EMS_AB_MEMBER_O                                      PROP_TAG(PT_MV_OBJECT          , 0x8009)
#define PR_EMS_AB_MEMBER_T                                      PROP_TAG(PT_MV_TSTRING         , 0x8009)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME                        PROP_TAG(PT_TSTRING            , 0x896)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME_A                      PROP_TAG(PT_STRING8            , 0x896)
#define PR_EMS_AB_MS_EXCH_ASSISTANT_NAME_W                      PROP_TAG(PT_UNICODE            , 0x896)
#define PR_EMS_AB_MS_EXCH_LABELEDURI                            PROP_TAG(PT_MV_TSTRING         , 0x921)
#define PR_EMS_AB_MS_EXCH_LABELEDURI_A                          PROP_TAG(PT_MV_STRING8         , 0x921)
#define PR_EMS_AB_MS_EXCH_LABELEDURI_W                          PROP_TAG(PT_MV_UNICODE         , 0x921)
#define PR_EMS_AB_NETWORK_ADDRESS                               PROP_TAG(PT_MV_TSTRING         , 0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A                             PROP_TAG(PT_MV_STRING8         , 0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W                             PROP_TAG(PT_MV_UNICODE         , 0x8170)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR                        PROP_TAG(PT_BINARY             , 0x8013)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY                         PROP_TAG(PT_LONG               , 0x80F6)
#define PR_EMS_AB_OBJECT_GUID                                   PROP_TAG(PT_BINARY             , 0x8C6D)
#define PR_EMS_AB_OBJECT_SID                                    PROP_TAG(PT_BINARY             , 0x8027)
#define PR_EMS_AB_OBJECT_VERSION                                PROP_TAG(PT_LONG               , 0x80F7)
#define PR_EMS_AB_OM_OBJECT_CLASS                               PROP_TAG(PT_BINARY             , 0x80FD)
#define PR_EMS_AB_OM_SYNTAX                                     PROP_TAG(PT_LONG               , 0x80FE)
#define PR_EMS_AB_ORGANIZATION_NAME                             PROP_TAG(PT_MV_TSTRING         , 0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A                           PROP_TAG(PT_MV_STRING8         , 0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W                           PROP_TAG(PT_MV_UNICODE         , 0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME                      PROP_TAG(PT_MV_TSTRING         , 0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A                    PROP_TAG(PT_MV_STRING8         , 0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W                    PROP_TAG(PT_MV_UNICODE         , 0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE                        PROP_TAG(PT_BINARY             , 0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS                  PROP_TAG(PT_BINARY             , 0x8104)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE                  PROP_TAG(PT_BINARY             , 0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE                PROP_TAG(PT_BINARY             , 0x8109)
#define PR_EMS_AB_PERSONAL_TITLE                                PROP_TAG(PT_TSTRING            , 0x8C6B)
#define PR_EMS_AB_PERSONAL_TITLE_A                              PROP_TAG(PT_STRING8            , 0x8C6B)
#define PR_EMS_AB_PERSONAL_TITLE_W                              PROP_TAG(PT_UNICODE            , 0x8C6B)
#define PR_EMS_AB_PHONE_HOME_OTHER                              PROP_TAG(PT_MV_TSTRING         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_OTHER_A                            PROP_TAG(PT_MV_STRING8         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_OTHER_W                            PROP_TAG(PT_MV_UNICODE         , 0x3A2F)
#define PR_EMS_AB_PHONE_HOME_PRIMARY                            PROP_TAG(PT_TSTRING            , 0x3A09)
#define PR_EMS_AB_PHONE_HOME_PRIMARY_A                          PROP_TAG(PT_STRING8            , 0x3A09)
#define PR_EMS_AB_PHONE_HOME_PRIMARY_W                          PROP_TAG(PT_UNICODE            , 0x3A09)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY                          PROP_TAG(PT_TSTRING            , 0x3A1C)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY_A                        PROP_TAG(PT_STRING8            , 0x3A1C)
#define PR_EMS_AB_PHONE_MOBILE_PRIMARY_W                        PROP_TAG(PT_UNICODE            , 0x3A1C)
#define PR_EMS_AB_PHONE_OFFICE_OTHER                            PROP_TAG(PT_MV_TSTRING         , 0x3A1B)
#define PR_EMS_AB_PHONE_OFFICE_OTHER_A                          PROP_TAG(PT_MV_STRING8         , 0x3A1B)
#define PR_EMS_AB_PHONE_OFFICE_OTHER_W                          PROP_TAG(PT_MV_UNICODE         , 0x3A1B)
#define PR_EMS_AB_PHONE_PAGER_OTHER                             PROP_TAG(PT_MV_TSTRING         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_OTHER_A                           PROP_TAG(PT_MV_STRING8         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_OTHER_W                           PROP_TAG(PT_MV_UNICODE         , 0x8C6E)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY                           PROP_TAG(PT_TSTRING            , 0x3A21)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY_A                         PROP_TAG(PT_STRING8            , 0x3A21)
#define PR_EMS_AB_PHONE_PAGER_PRIMARY_W                         PROP_TAG(PT_UNICODE            , 0x3A21)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME                 PROP_TAG(PT_TSTRING            , 0x3A19)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME_A               PROP_TAG(PT_STRING8            , 0x3A19)
#define PR_EMS_AB_PHYSICAL_DELIVERY_OFFICE_NAME_W               PROP_TAG(PT_UNICODE            , 0x3A19)
#define PR_EMS_AB_POST_OFFICE_BOX                               PROP_TAG(PT_MV_TSTRING         , 0x3A2B)
#define PR_EMS_AB_POST_OFFICE_BOX_A                             PROP_TAG(PT_MV_STRING8         , 0x3A2B)
#define PR_EMS_AB_POST_OFFICE_BOX_W                             PROP_TAG(PT_MV_UNICODE         , 0x3A2B)
#define PR_EMS_AB_POSTAL_ADDRESS                                PROP_TAG(PT_MV_TSTRING         , 0x810c)
#define PR_EMS_AB_POSTAL_ADDRESS_A                              PROP_TAG(PT_MV_STRING8         , 0x810c)
#define PR_EMS_AB_POSTAL_ADDRESS_W                              PROP_TAG(PT_MV_UNICODE         , 0x810c)
#define PR_EMS_AB_POSTAL_CODE                                   PROP_TAG(PT_TSTRING            , 0x3A2A)
#define PR_EMS_AB_POSTAL_CODE_A                                 PROP_TAG(PT_STRING8            , 0x3A2A)
#define PR_EMS_AB_POSTAL_CODE_W                                 PROP_TAG(PT_UNICODE            , 0x3A2A)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD                     PROP_TAG(PT_MV_LONG            , 0x810D)
#define PR_EMS_AB_PROXY_ADDRESSES                               PROP_TAG(PT_MV_TSTRING         , 0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A                             PROP_TAG(PT_MV_STRING8         , 0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W                             PROP_TAG(PT_MV_UNICODE         , 0x800F)
#define PR_EMS_AB_PROXY_GENERATION_ENABLED                      PROP_TAG(PT_BOOLEAN            , 0x81B1)
#define PR_EMS_AB_RANGE_LOWER                                   PROP_TAG(PT_LONG               , 0x8113)
#define PR_EMS_AB_RANGE_UPPER                                   PROP_TAG(PT_LONG               , 0x8114)
#define PR_EMS_AB_RDN                                           PROP_TAG(PT_TSTRING            , 0x8202)
#define PR_EMS_AB_RDN_A                                         PROP_TAG(PT_STRING8            , 0x8202)
#define PR_EMS_AB_RDN_W                                         PROP_TAG(PT_UNICODE            , 0x8202)
#define PR_EMS_AB_REGISTERED_ADDRESS                            PROP_TAG(PT_MV_BINARY          , 0x8119)
#define PR_EMS_AB_REPORTS                                       PROP_TAG(PT_MV_OBJECT          , 0x800E)
#define PR_EMS_AB_REPORTS_A                                     PROP_TAG(PT_MV_STRING8         , 0x800E)
#define PR_EMS_AB_REPORTS_W                                     PROP_TAG(PT_MV_UNICODE         , 0x800E)
#define PR_EMS_AB_REPORTS_O                                     PROP_TAG(PT_MV_OBJECT          , 0x800E)
#define PR_EMS_AB_REPORTS_T                                     PROP_TAG(PT_MV_TSTRING         , 0x800E)
#define PR_EMS_AB_ROLE_OCCUPANT                                 PROP_TAG(PT_MV_OBJECT          , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A                               PROP_TAG(PT_MV_STRING8         , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W                               PROP_TAG(PT_MV_UNICODE         , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O                               PROP_TAG(PT_MV_OBJECT          , 0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T                               PROP_TAG(PT_MV_TSTRING         , 0x8125)
#define PR_EMS_AB_SCHEMA_VERSION                                PROP_TAG(PT_MV_LONG            , 0x817C)
#define PR_EMS_AB_SEARCH_FLAGS                                  PROP_TAG(PT_LONG               , 0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                                  PROP_TAG(PT_MV_BINARY          , 0x812E)
#define PR_EMS_AB_SEE_ALSO                                      PROP_TAG(PT_MV_OBJECT          , 0x812F)
#define PR_EMS_AB_SEE_ALSO_A                                    PROP_TAG(PT_MV_STRING8         , 0x812F)
#define PR_EMS_AB_SEE_ALSO_W                                    PROP_TAG(PT_MV_UNICODE         , 0x812F)
#define PR_EMS_AB_SEE_ALSO_O                                    PROP_TAG(PT_MV_OBJECT          , 0x812F)
#define PR_EMS_AB_SEE_ALSO_T                                    PROP_TAG(PT_MV_TSTRING         , 0x812F)
#define PR_EMS_AB_SERIAL_NUMBER                                 PROP_TAG(PT_MV_TSTRING         , 0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A                               PROP_TAG(PT_MV_STRING8         , 0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W                               PROP_TAG(PT_MV_UNICODE         , 0x8130)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME                        PROP_TAG(PT_TSTRING            , 0x3A28)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME_A                      PROP_TAG(PT_STRING8            , 0x3A28)
#define PR_EMS_AB_STATE_OR_PROVINCE_NAME_W                      PROP_TAG(PT_UNICODE            , 0x3A28)
#define PR_EMS_AB_STREET_ADDRESS                                PROP_TAG(PT_TSTRING            , 0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A                              PROP_TAG(PT_STRING8            , 0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W                              PROP_TAG(PT_UNICODE            , 0x813A)
#define PR_EMS_AB_SUB_REFS                                      PROP_TAG(PT_MV_OBJECT          , 0x813B)
#define PR_EMS_AB_SUB_REFS_A                                    PROP_TAG(PT_MV_STRING8         , 0x813B)
#define PR_EMS_AB_SUB_REFS_W                                    PROP_TAG(PT_MV_UNICODE         , 0x813B)
#define PR_EMS_AB_SUB_REFS_O                                    PROP_TAG(PT_MV_OBJECT          , 0x813B)
#define PR_EMS_AB_SUB_REFS_T                                    PROP_TAG(PT_MV_TSTRING         , 0x813B)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT                 PROP_TAG(PT_MV_BINARY          , 0x813D)
#define PR_EMS_AB_SURNAME                                       PROP_TAG(PT_TSTRING            , 0x3A11)
#define PR_EMS_AB_SURNAME_A                                     PROP_TAG(PT_STRING8            , 0x3A11)
#define PR_EMS_AB_SURNAME_W                                     PROP_TAG(PT_UNICODE            , 0x3A11)
#define PR_EMS_AB_TELEPHONE_NUMBER                              PROP_TAG(PT_TSTRING            , 0x3A08)
#define PR_EMS_AB_TELEPHONE_NUMBER_A                            PROP_TAG(PT_STRING8            , 0x3A08)
#define PR_EMS_AB_TELEPHONE_NUMBER_W                            PROP_TAG(PT_UNICODE            , 0x3A08)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER                   PROP_TAG(PT_MV_BINARY          , 0x8143)
#define PR_EMS_AB_TELEX_NUMBER                                  PROP_TAG(PT_MV_BINARY          , 0x3A2C)
#define PR_EMS_AB_TEXT_COUNTRY                                  PROP_TAG(PT_TSTRING            , 0x3A26)
#define PR_EMS_AB_TEXT_COUNTRY_A                                PROP_TAG(PT_STRING8            , 0x3A26)
#define PR_EMS_AB_TEXT_COUNTRY_W                                PROP_TAG(PT_UNICODE            , 0x3A26)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS                       PROP_TAG(PT_TSTRING            , 0x8C81)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS_A                     PROP_TAG(PT_STRING8            , 0x8C81)
#define PR_EMS_AB_TEXT_ENCODED_OR_ADDRESS_W                     PROP_TAG(PT_UNICODE            , 0x8C81)
#define PR_EMS_AB_TITLE                                         PROP_TAG(PT_TSTRING            , 0x3A17)
#define PR_EMS_AB_TITLE_A                                       PROP_TAG(PT_STRING8            , 0x3A17)
#define PR_EMS_AB_TITLE_W                                       PROP_TAG(PT_UNICODE            , 0x3A17)
#define PR_EMS_AB_TOMBSTONE_LIFETIME                            PROP_TAG(PT_LONG               , 0x8145)
#define PR_EMS_AB_USER_CERT                                     PROP_TAG(PT_BINARY             , 0x3A22)
#define PR_EMS_AB_USER_PASSWORD                                 PROP_TAG(PT_MV_BINARY          , 0x8153)
#define PR_EMS_AB_USER_SMIME_CERTIFICATE                        PROP_TAG(PT_MV_BINARY          , 0x3a70)
#define PR_EMS_AB_USN_INTERSITE                                 PROP_TAG(PT_LONG               , 0x817A)
#define PR_EMS_AB_WHEN_CHANGED                                  PROP_TAG(PT_SYSTIME            , 0x3008)
#define PR_EMS_AB_WHEN_CREATED                                  PROP_TAG(PT_SYSTIME            , 0x3007)
#define PR_EMS_AB_WWW_PAGE_OTHER                                PROP_TAG(PT_MV_TSTRING         , 0x8175)
#define PR_EMS_AB_WWW_PAGE_OTHER_A                              PROP_TAG(PT_MV_STRING8         , 0x8175)
#define PR_EMS_AB_WWW_PAGE_OTHER_W                              PROP_TAG(PT_MV_UNICODE         , 0x8175)
#define PR_EMS_AB_X121_ADDRESS                                  PROP_TAG(PT_MV_TSTRING         , 0x8158)
#define PR_EMS_AB_X121_ADDRESS_A                                PROP_TAG(PT_MV_STRING8         , 0x8158)
#define PR_EMS_AB_X121_ADDRESS_W                                PROP_TAG(PT_MV_UNICODE         , 0x8158)
#define PR_EMS_AB_X509_CERT                                     PROP_TAG(PT_MV_BINARY          , 0x8c6a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ndnc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ndnc.h

Abstract:

    This module defines the functions for Appication Directory
    Partitions, aka NDNCs, or Non-Domain Naming Contexts, or 
    Application Partitions.  Note: Often Application is replaced
    with some application, such as "TAPI Directory Partition".

Author:

    Brett Shirley (BrettSh) 20-Feb-2000

Revision History:

    21-Jul-2000     BrettSh
        
        Moved this file and it's functionality from the ntdsutil
        directory to the new a new library ndnc.lib.  This is so
        it can be used by ntdsutil and tapicfg commands.  The  old
        source location: \nt\ds\ds\src\util\ntdsutil\ndnc.h.                                    


--*/

#ifndef _NDNC_H_
#define _NDNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------
// Helper Routines.

ULONG
GetRootAttr(
    IN  LDAP *       hld,
    IN  WCHAR *      wszAttr,
    OUT WCHAR **     pwszOut
    );

LDAP *
GetLdapBinding(
    WCHAR *          pszServer,
    DWORD *          pdwRet
    );

LDAP *
GetDomainNamingFSMOBinding(
    DWORD *          pdwRet
    );


ULONG
GetDomainNamingDns(
    IN  LDAP *       hld,
    OUT WCHAR **     wszDomainNamingFsmo
    );

ULONG
GetCrossRefDNFromNCDN(
    IN  LDAP *       hld, 
    IN  WCHAR *      wszNCDN,
    OUT WCHAR **     pwszCrossRefDn
    );

ULONG
GetServerNtdsaDnFromServerDns(
    IN LDAP *        hld,                   
    IN WCHAR *       wszServerDNS,
    OUT WCHAR **     pwszServerDn
    );

ULONG
GetServerDnsFromServerNtdsaDn(
    IN LDAP *        hld,                   
    IN WCHAR *       wszServerDn,
    OUT WCHAR **     pwszServerDNS
    );


ULONG
GetCrossRefDNFromNDNCDNS(
    IN LDAP *        hldDC, 
    IN WCHAR *       wszNDNCDNS,
    OUT WCHAR **     wszCrossRefDN
    );

ULONG
GetServerDNFromServerDNS(
    IN LDAP *        hldDC, 
    IN WCHAR *       wszServerDNS,
    OUT WCHAR **      wszServerDN
    );

BOOL
SetIscReqDelegate(
    LDAP *  hld
    );

LDAP *  
GetNdncLdapBinding(
    WCHAR *          pszServer,
    DWORD *          pdwRet,
    BOOL             fReferrals,
    SEC_WINNT_AUTH_IDENTITY_W   * pCreds
    );

BOOL
CheckDnsDn(
    IN   WCHAR       * wszDnsDn
    );

// --------------------------------------
// Main Routines.

ULONG
CreateNDNC(
    IN LDAP *        hldNDNCDC,
    const IN WCHAR *  wszNDNC,
    const IN WCHAR *  wszShortDescription
    );

ULONG
RemoveNDNC(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC
    );

ULONG
ModifyNDNCReplicaSet(
    IN LDAP *        hldDomainNamingFSMO,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReplicaNtdsaDn,
    IN BOOL          fAdd // Else it is considered a delete
    );

ULONG
SetNDNCSDReferenceDomain(
    IN LDAP *        hldDomainNamingFsmo,
    IN WCHAR *       wszNDNC,
    IN WCHAR *       wszReferenceDomain
    );

ULONG
SetNCReplicationDelays(
    IN LDAP *        hldDomainNamingFsmo,
    IN WCHAR *       wszNDNC,
    IN INT           iFirstDSADelay,
    IN INT           iSubsequentDSADelay
    );

#ifdef __cplusplus
}
#endif

#endif // _NDNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdsa.h ===
/* Copyright 1989-1999 Microsoft Corporation, All Rights Reserved */

#ifndef _ntdsa_h_
#define _ntdsa_h_
#include "ntdsadef.h"

// If you add to this list, be sure and add the corresponding #undef below.
#ifdef MIDL_PASS
#define SIZE_IS(x)      [size_is(x)]
#define SWITCH_IS(x)    [switch_is(x)]
#define SWITCH_TYPE(x)  [switch_type(x)]
#define CASE(x)         [case(x)]
#define VAR_SIZE_ARRAY
#else
#define SIZE_IS(x)
#define SWITCH_IS(x)
#define SWITCH_TYPE(x)
#define CASE(x)
#define VAR_SIZE_ARRAY  (1)
#endif

#ifdef MIDL_PASS
typedef [string] char * SZ;
#else
typedef char * SZ;
#endif

/***************************************************************************
    General Size Limits
***************************************************************************/

#define MAX_ADDRESS_SIZE      256   /* The max size of a DNS address (we hope) */

/***************************************************************************
 *    OSI defs (things to define attributes.)
 ***************************************************************************/

/*
 * Identifies an attribute
 */

typedef ULONG  ATTRTYP;

/*
 * A single attribute value.  This value is set according to the data type
 */

typedef struct ATTVAL{
    ULONG     valLen;                  /* length of attribute value        */
    SIZE_IS(valLen) UCHAR *pVal;     /* value.  May be of any predefined
                                      * type                             */
}ATTRVAL;

/*
 * A bunch of attribute values
 */
typedef struct ATTRVALBLOCK{
    ULONG valCount;                      /* count of values */
    SIZE_IS(valCount) ATTRVAL *pAVal;  /* attribute values */
}ATTRVALBLOCK;



/*
 * An attribute is composed of an attribute type and one
 * or more attribute values.
 */

typedef struct ATTR{
    ATTRTYP   attrTyp;                 /* the attribute type               */
    ATTRVALBLOCK AttrVal;              /* the values */
}ATTR;

/*
 * A block of attributes
 */

typedef struct ATTRBLOCK{
    ULONG attrCount;
    SIZE_IS(attrCount) ATTR *pAttr;
}ATTRBLOCK;

typedef ATTR RDN;

#define MAX_NT4_SID_SIZE 28

typedef struct _NT4SID {
    char Data[MAX_NT4_SID_SIZE];
} NT4SID;

typedef NT4SID *PNT4SID;

/* The Distinguished Name.  The full path name of a directory object,
 * consisting of an ordered sequence of RDNs, stored in accordance with
 * RFC 1779 string DN format (e.g., CN=donh,OU=BSD,O=Microsoft,C=US).
 *
 * To facilitate identity based and security operations, the object's
 * GUID and SID are optionally present in the DSNAME structure.  If
 * present, the GUID is assumed to take precedence over the string name.
 *
 * The NameLen includes all the non-null characters in the string name,
 * but specifically does NOT include the trailing NULL.  However, the
 * total structure size as specified by the structLen should include
 * enough storage for a trailing NULL after the string name.  This means
 * that StringName[NameLen] will always be NULL, and that
 * StringName[NameLen-1] will never be NULL.  Please don't try to compute
 * structure sizes on your own, but instead use the DSNameSizeFromLen
 * macro provided below.
 */

/*
 * The combination ID/name structure
 */
typedef struct _DSNAME {
    ULONG structLen;            /* length of entire DSNAME, in bytes */
    ULONG SidLen;               /* length of the SID, in bytes (0 = none) */
    GUID Guid;                  /* id of this object */
    NT4SID Sid;                 /* SID for this object, if present */
    ULONG NameLen;              /* length of the StringName, in chars */
#ifdef MIDL_PASS
    [size_is(NameLen+1)]        /* Unicode string name - Adding one so that */
        WCHAR StringName[];     /*   terminating NULL is also sent*/
#else
    WCHAR StringName[1];        /* Unicode string name */
#endif
} DSNAME;

typedef DSNAME *PDSNAME;

/*
 * The SizeFromLen macro is a sad commentary on the state of the sizeof
 * operator (which rounds up to allow for padding) and the IDL compiler
 * (which munges empty arrays into 1 sized arrays).
 */
#define DSNameSizeFromLen(x) \
    (sizeof(GUID) + 3*sizeof(ULONG) + sizeof(WCHAR) + sizeof(NT4SID) \
     + (x)*sizeof(WCHAR))
#define DNTFromShortDSName(x) (*((DWORD *)((x)->StringName)))

/*
 * A Generic sized buffer of bytes.
 */

typedef struct OCTET{
    USHORT     len;                      /* length */
    SIZE_IS(len) PUCHAR pVal;      /* pointer to value */
}OCTET;

// The time/date type used by the DS.
typedef LONGLONG DSTIME;

// ENTINF flags

// Read from a writeable copy
#define ENTINF_FROM_MASTER        0x00000001

// Dynamic Object (new in Whistler)
// Only available when fDRA is set (see mdread.c)
#define ENTINF_DYNAMIC_OBJECT     0x00000002

typedef struct _ENTINF
{
    DSNAME           *pName;            // Object name and identity
    ULONG            ulFlags;           // Entry flags
    ATTRBLOCK        AttrBlock;         // The attributes returned.
} ENTINF;

typedef struct _ENTINFLIST
{
    struct _ENTINFLIST   *pNextEntInf;  // linked-list to next entry of info
    ENTINF           Entinf;            // information about this entry
} ENTINFLIST;


// UTF8-encoded, transport-specific DSA address.
typedef struct{
    ULONG  mtx_namelen;          /* Length of the name, incl. null terminator */
#ifdef MIDL_PASS
    [size_is(mtx_namelen)] char mtx_name[];
#else
    char mtx_name[1];
#endif
} MTX_ADDR;
#define MTX_TSIZE(pmtx) (offsetof(MTX_ADDR, mtx_name) + (pmtx)->mtx_namelen)
// NOTE: cch does _not_ include null terminator.
#define MTX_TSIZE_FROM_LEN(cch) (offsetof(MTX_ADDR, mtx_name) + (cch) + 1)


/* An attribute value assertion is composed of an attribute type and value*/

typedef struct AVA{
    ATTRTYP  type;                       /* attribute type           */
    ATTRVAL  Value;                      /* a single attribute value */
}AVA;



/* A list of AVA's */

typedef struct AVALIST{
   struct AVALIST FAR *pNextAVAVal;      /* linked list of AVA's   */
   AVA                  AVAVal;          /* The AVA type and value */
}AVALIST;


/***************************************************************************
 *    Replication-specific structures
 ***************************************************************************/

// Property-Meta-Data:
//      This contains all the replication meta-data associated with a single
//      property of an object.  This data is required for incremental
//      replication as well as per-property propagation dampening.
//
//      attrType - identifies the attribute whose meta-data rest of fields
//          represent.
//      usnProperty - USN corresponding to the last change on the property.
//      dwVersion - Version of the property.
//      timeChanged - Time stamp corresponding to the last change to the
//          property.
//      uuidDsaOriginating - uuid of the DSA that did the last originating
//          write on the property.
//      usnOriginating - USN corresponding to the last originating write in
//          the originating DSA's USN space.


typedef struct _PROPERTY_META_DATA {
    ATTRTYP             attrType;
    DWORD               dwVersion;
    DSTIME              timeChanged;
    UUID                uuidDsaOriginating;
    USN                 usnOriginating;
    USN                 usnProperty;
} PROPERTY_META_DATA;

// Property-Meta-Data-Vector:
//      This is a vector of property-meta-data which holds the meta-data for
//      one or more properties of an object.

typedef struct _PROPERTY_META_DATA_VECTOR_V1 {
    DWORD                   cNumProps;
#ifdef MIDL_PASS
    [size_is(cNumProps)]
        PROPERTY_META_DATA  rgMetaData[];
#else
    PROPERTY_META_DATA  rgMetaData[1];
#endif
} PROPERTY_META_DATA_VECTOR_V1;

typedef struct _PROPERTY_META_DATA_VECTOR {
    DWORD               dwVersion;
    SWITCH_IS(dwVersion) union {
        CASE(1) PROPERTY_META_DATA_VECTOR_V1 V1;
    };
} PROPERTY_META_DATA_VECTOR;

#define MetaDataVecV1SizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA))

#define MetaDataVecV1Size(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_VECTOR,V1.rgMetaData[0]) \
     + ((pMetaDataVec)->V1.cNumProps)*sizeof(PROPERTY_META_DATA))

#define VALIDATE_META_DATA_VECTOR_VERSION(pVec)         \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }

// Value-Meta-Data
//      This contains all the replication meta-data associated with a single
//      value of a property of an object.  This is the internal version of the
//      metadata: it is not written to disk or transmitted across the wire.
//      Use the EXT form for that.
typedef struct _VALUE_META_DATA {
    DSTIME             timeCreated;
    PROPERTY_META_DATA MetaData;
} VALUE_META_DATA;

// Property-Meta-Data-Ext:
//      This is a trimmed version of property meta data containing only the
//      fields that are required by the remote DSA as part of the replication
//      packet.
typedef struct _PROPERTY_META_DATA_EXT {
    DWORD   dwVersion;
    DSTIME  timeChanged;
    UUID    uuidDsaOriginating;
    USN     usnOriginating;
} PROPERTY_META_DATA_EXT;

// Value-Meta-Data-Ext
// This structure contains the trimmed version of the value meta data
// This structure does not have a version number because it is a fixed
// size: versions may be distinguished by checking the size of the
// structure.
typedef struct _VALUE_META_DATA_EXT_V1 {
    DSTIME                 timeCreated;
    PROPERTY_META_DATA_EXT MetaData;
} VALUE_META_DATA_EXT_V1;

// Shorthand for most current version of structure
typedef VALUE_META_DATA_EXT_V1 VALUE_META_DATA_EXT;

// Property-Meta-Data-Ext-Vector:
//      This is a vector of property-meta-data-ext which holds the trimmed
//      property meta data for one or more properties of an object.
typedef struct _PROPERTY_META_DATA_EXT_VECTOR {
    DWORD                   cNumProps;
#ifdef MIDL_PASS
    [size_is( cNumProps)]
    PROPERTY_META_DATA_EXT  rgMetaData[];
#else
    PROPERTY_META_DATA_EXT  rgMetaData[1];
#endif
} PROPERTY_META_DATA_EXT_VECTOR;


#define MetaDataExtVecSizeFromLen(cNumProps) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + (cNumProps)*sizeof(PROPERTY_META_DATA_EXT))

#define MetaDataExtVecSize(pMetaDataVec) \
    (offsetof(PROPERTY_META_DATA_EXT_VECTOR,rgMetaData[0]) \
     + ((pMetaDataVec)->cNumProps)*sizeof(PROPERTY_META_DATA_EXT))


// PARTIAL_ATTR_VECTOR - represents the partial attribute set. This is an array of
//      sorted attids that make the partial set.

typedef struct _PARTIAL_ATTR_VECTOR_V1 {
    DWORD cAttrs;    // count of partial attributes in the array
#ifdef MIDL_PASS
    [size_is(cAttrs)] ATTRTYP rgPartialAttr[];
#else
    ATTRTYP rgPartialAttr[1];
#endif
} PARTIAL_ATTR_VECTOR_V1;

// We need to make sure the start of the union is aligned at an 8 byte
// boundary so that we can freely cast between internal and external
// formats.
typedef struct _PARTIAL_ATTR_VECTOR_INTERNAL {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) PARTIAL_ATTR_VECTOR_V1 V1;
    };
} PARTIAL_ATTR_VECTOR_INTERNAL;

typedef PARTIAL_ATTR_VECTOR_INTERNAL PARTIAL_ATTR_VECTOR;

#define PartialAttrVecV1SizeFromLen(cAttrs) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + (cAttrs)*sizeof(ATTRTYP))

#define PartialAttrVecV1Size(pPartialAttrVec) \
    (offsetof(PARTIAL_ATTR_VECTOR, V1.rgPartialAttr[0]) \
     + ((pPartialAttrVec)->V1.cAttrs) * sizeof(ATTRTYP))

typedef struct _PARTIAL_ATTR_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cAttrs;
#ifdef MIDL_PASS
    [size_is(cAttrs)] ATTRTYP rgPartialAttr[];
#else
    ATTRTYP rgPartialAttr[1];
#endif
} PARTIAL_ATTR_VECTOR_V1_EXT;

#define VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(pVec)      \
    {   if (NULL != (pVec)) {                           \
            Assert(VERSION_V1 == (pVec)->dwVersion);    \
        }                                               \
    }


// USN Vector.  Replication session state.  Tracks the state of the last
//      replication session between a given pair of DSAs.

typedef struct _USN_VECTOR {
    USN         usnHighObjUpdate;
    USN         usnReserved;    // was usnHighObjCreate; not used post beta-2
    USN         usnHighPropUpdate;
} USN_VECTOR;


// Up-to-date vector.  This vector indicates the last changes each side of a
//      GetNCChanges() call saw from its neighbors.  This information, in turn,
//      is used to filter out items that do not need to be transmitted.

typedef struct _UPTODATE_CURSOR_V1 {
    UUID uuidDsa;
    USN  usnHighPropUpdate;
} UPTODATE_CURSOR_V1;

#ifdef __cplusplus
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // genuine C++ inheritance.
    typedef struct _UPTODATE_CURSOR_V2 : _UPTODATE_CURSOR_V1 {
#else
    // _UPTODATE_CURSOR_V2 inherits from _UPTODATE_CURSOR_V1 using
    // Microsoft's "Anonymous Structure" C language extension.
    typedef struct _UPTODATE_CURSOR_V2 {
        #ifdef MIDL_PASS
            struct  _UPTODATE_CURSOR_V1 v1;
        #else
            struct  _UPTODATE_CURSOR_V1;
        #endif
#endif
        DSTIME  timeLastSyncSuccess;
    } UPTODATE_CURSOR_V2;

typedef struct _UPTODATE_VECTOR_V1 {
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1;

typedef struct _UPTODATE_VECTOR_V2 {
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2;

typedef struct _UPTODATE_VECTOR {
    DWORD   dwVersion;
    DWORD   dwReserved1;
    SWITCH_IS(dwVersion) union {
        CASE(1) UPTODATE_VECTOR_V1 V1;
        CASE(2) UPTODATE_VECTOR_V2 V2;
    };
} UPTODATE_VECTOR;

#define UpToDateVecV1SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2SizeFromLen(cNumCursors)  \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + (cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecV1Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) \
     + ((putodvec)->V1.cNumCursors)*sizeof(UPTODATE_CURSOR_V1))

#define UpToDateVecV2Size(putodvec) \
    (offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) \
     + ((putodvec)->V2.cNumCursors)*sizeof(UPTODATE_CURSOR_V2))

#define UpToDateVecSize(putodvec) \
    ((2 == (putodvec)->dwVersion) \
     ? UpToDateVecV2Size(putodvec) \
     : UpToDateVecV1Size(putodvec))

// Native UTD types/macros.  These must be updated if the native (internally
// used) type is changed from Vx to Vy.
typedef UPTODATE_CURSOR_V2 UPTODATE_CURSOR_NATIVE;
typedef UPTODATE_VECTOR_V2 UPTODATE_VECTOR_NATIVE;
#define UPTODATE_VECTOR_NATIVE_VERSION (2)
#define UpToDateVecVNSizeFromLen(cNumCursors) UpToDateVecV2SizeFromLen(cNumCursors)
    

// MIDL doesn't like marshalling the definition of UPTODATE_VECTOR. So, we are
// keeping strucurally identical but a simpler looking version-specific
// definitions of UPTODATE_VECTOR for marshalling.  Castings between
// UPTODATE_VECTOR and UPTODATE_VECTOR_Vx_EXT are perfectly valid as long as
// dwVersion == x.
// Note:-
// We need the Reserved1 & Reserved2 variables to account for alignment.
// The internal form gets an 8 byte alignment due to the _int64 field in
// the UPTODATE_CURSOR. So, unless we account for this alignment through
// dummy variables, we can't freely cast back & forth between the internal
// and external versions.
typedef struct _UPTODATE_VECTOR_V1_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V1 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V1_EXT;

typedef struct _UPTODATE_VECTOR_V2_EXT {
    DWORD               dwVersion;
    DWORD               dwReserved1;
    DWORD               cNumCursors;
    DWORD               dwReserved2;
    SIZE_IS(cNumCursors) UPTODATE_CURSOR_V2 rgCursors[VAR_SIZE_ARRAY];
} UPTODATE_VECTOR_V2_EXT;

#ifdef MIDL_PASS
typedef UPTODATE_VECTOR_V1_EXT UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR_V2_EXT UPTODATE_VECTOR_V2_WIRE;
#else
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V1_WIRE;
typedef UPTODATE_VECTOR UPTODATE_VECTOR_V2_WIRE;
#endif


#define IS_VALID_UPTODATE_VECTOR(x) \
    ((1 == (x)->dwVersion) || (2 == (x)->dwVersion))

#define IS_NULL_OR_VALID_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_UPTODATE_VECTOR(x))

#define IS_VALID_NATIVE_UPTODATE_VECTOR(x) \
    (UPTODATE_VECTOR_NATIVE_VERSION == (x)->dwVersion)

#define IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(x) \
    ((NULL == (x)) || IS_VALID_NATIVE_UPTODATE_VECTOR(x))


// Following version definitions are probably unnecessary. But it shows
// explicitly through a constant that our versions start from 1 not 0.
#define VERSION_V1 (1)
#define VERSION_V2 (2)
#define VERSION_V3 (3)


// This is the structure used to set periodic replication times, each bit
// represents a 15 minute period, 8 bits* 84 bytes * 15 mins = a week
typedef struct _repltimes {
    UCHAR rgTimes[84];
} REPLTIMES;


// REPLENTINFLIST:  Similar to ENTINFLIST except it also has additional fields
//      for holding incremental replication and name space reconciliation
//      fields.
typedef struct _REPLENTINFLIST {
    struct _REPLENTINFLIST *
                pNextEntInf;    // linked-list to the next entry info
    ENTINF      Entinf;         // all the old repl info alongwith shipped
                                //      attributes
    BOOL        fIsNCPrefix;    // is this object the NC prefix?
    GUID *      pParentGuid;    // points to parent guid while replicating
                                //      renames; NULL otherwise
    PROPERTY_META_DATA_EXT_VECTOR *
                pMetaDataExt;   // pointer to the meta-data to be shipped
} REPLENTINFLIST;

// REPLVALINF: describe a single value change for replication
typedef struct _REPLVALINF {
    PDSNAME pObject;                // containing object
    ATTRTYP attrTyp;                // containing attribute
    ATTRVAL Aval;                   // The value itself
    BOOL fIsPresent;                // adding or removing?
    VALUE_META_DATA_EXT MetaData;   // Originating info
} REPLVALINF;


// DRS_EXTENSIONS is an arbitrary byte array describing the capabilities and
// other state information for a particular server.  Exchanged at bind
// time, the structure allows client and server to negotiate a compatible
// protocol.
typedef struct _DRS_EXTENSIONS {
    DWORD cb;    // length of rgb field (not of entire struct)
#ifdef MIDL_PASS
    [size_is(cb)] BYTE rgb[];
#else
    BYTE rgb[1];
#endif
} DRS_EXTENSIONS, *PDRS_EXTENSIONS;


// DRS_EXTENSIONS_INT is the data structure described by the DRS_EXTENSIONS byte
// array.  This array can be safely extended by adding additional fields onto
// the end (but not anywhere else).
//
// Parts of the extension are carried in the variable-length mail-based
// replication header. If you extend this structure, please examine
// dramail.h structure definition and dramail.c get/set extensions routines
// and consider whether your new information should be carried there as well.
//
// PORTABILITY WARNING: Since this structure is marshalled as a byte array,
// big-endian machines will need to do local byte-swapping.
typedef struct _DRS_EXTENSIONS_INT {
    DWORD cb;           // set to sizeof(DRS_EXTENSIONS_INT) - sizeof(DWORD)
    DWORD dwFlags;      // various DRS_EXT_* bits
    UUID  SiteObjGuid;  // objectGuid of owning DSA's site object
    INT   pid;          // process id of client (used to facilitate leak trking)
    DWORD dwReplEpoch;  // replication epoch (for domain rename)

    // If you extend this structure, see SITE_GUID_FROM_DRS_EXT() for an example
    // of how to safely extract your new field's data.
} DRS_EXTENSIONS_INT;

// To define an extension, add an entry to the following enumeration just
// above DRS_EXT_MAX.

// NOTE: If you add/remove extensions, please make corresponding updates to the
// structure in Dump_BHCache() in dsexts\md.c.
typedef enum {
    DRS_EXT_BASE = 0,

    // Bits for DRS_EXTENSIONS_DATA Flags field.
    DRS_EXT_ASYNCREPL,      // supports DRS_MSG_REPADD_V2, DRS_MSG_GETCHGREQ_V2
    DRS_EXT_REMOVEAPI,      // supports RemoveDsServer, RemoveDsDomain
    DRS_EXT_MOVEREQ_V2,     // supports DRS_MOVEREQ_V2
    DRS_EXT_GETCHG_COMPRESS,// supports DRS_MSG_GETCHGREPLY_V2
    DRS_EXT_DCINFO_V1,      // supports DS_DOMAIN_CONTROLLER_INFO_1
    DRS_EXT_RESTORE_USN_OPTIMIZATION,
        // supports bookmark optimizations on restore to avoid full syncs
    DRS_EXT_ADDENTRY,       // supports remoted AddEntry, v1
    DRS_EXT_KCC_EXECUTE,    // supports IDL_DRSExecuteKCC
    DRS_EXT_ADDENTRY_V2,    // supports remoted AddEntry, v2
    DRS_EXT_LINKED_VALUE_REPLICATION, // LVR supported AND enabled
    DRS_EXT_DCINFO_V2,      // supports DS_DOMAIN_CONTROLLER_INFO_2
    DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD,
        // inbound repl doesn't require instance type in repl stream for mods
    DRS_EXT_CRYPTO_BIND,    // supports RPC session key setup on bind
    DRS_EXT_GET_REPL_INFO,  // supports IDL_DRSGetReplInfo
    DRS_EXT_STRONG_ENCRYPTION,
        // supports additional 128 bit encryption for passwords over the wire
    DRS_EXT_DCINFO_VFFFFFFFF,
        // supports DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF
    DRS_EXT_TRANSITIVE_MEMBERSHIP,
        // supports transitive membership expansion at G.C
    DRS_EXT_ADD_SID_HISTORY,// supports DRS_MSG_ADDSIDREQ
    DRS_EXT_POST_BETA3,     // supports sending/receiving schema info,
                            //  DS_REPL_INFO_KCC_DSA_*_FAILURES,
                            //  and DS_REPL_PENDING_OPSW
    DRS_EXT_GETCHGREQ_V5,   // supports DRS_MSG_GETCHGREQ_V5
    DRS_EXT_GETMEMBERSHIPS2,   // supports DRS_MSG_GETMEMBERSHIPS2
    DRS_EXT_GETCHGREQ_V6,   // supports DRS_MSG_GETCHGREQ_V6
    DRS_EXT_NONDOMAIN_NCS,  // understands non-domain NCs
    DRS_EXT_GETCHGREQ_V8,   // supports DRS_MSG_GETCHGREQ_V8
    DRS_EXT_GETCHGREPLY_V5, // supports DRS_MSG_GETCHGREPLY_V5
    DRS_EXT_GETCHGREPLY_V6, // supports DRS_MSG_GETCHGREPLY_V6   
    DRS_EXT_WHISTLER_BETA3, // supports DRS_MSG_ADDENTRYREPLY_V3, 
                            //          DRS_MSG_REPVERIFYOBJ
                            //          DRS_MSG_GETCHGREPLY_V7
    DRS_EXT_XPRESS_COMPRESSION, // supports the Xpress compression library
    //    NO MORE BITS AVAILABLE
    // BUGBUG Either this flag DRS_EXT_RESERVED_FOR_WIN2K_PART2 or the 
    //        DRS_EXT_LAST_FLAG (preferred if it can be used) will need
    //        to be used to signal to use the extended extension bits
    //        that you'll have to create if you want a new extension bit! :)
    DRS_EXT_RESERVED_FOR_WIN2K_PART1,
    DRS_EXT_RESERVED_FOR_WIN2K_PART2, // 30
    //
    // AND DON'T FORGET TO UPDATE UTIL\REPADMIN\REPDSREP.C and DSEXTS\MD.C!
    //
    DRS_EXT_LAST_FLAG = 31,

    // Bits to hold site guid.
    DRS_EXT_SITEGUID_BEGIN = 32,
    DRS_EXT_SITEGUID_END = DRS_EXT_SITEGUID_BEGIN + sizeof(GUID)*8 - 1,

    // Bits to hold client process ID (to facilitate leak tracking).
    DRS_EXT_PID_BEGIN,
    DRS_EXT_PID_END = DRS_EXT_PID_BEGIN + sizeof(int)*8 - 1,

    // Bits to hold replication epoch.
    DRS_EXT_EPOCH_BEGIN,
    DRS_EXT_EPOCH_END = DRS_EXT_EPOCH_BEGIN + sizeof(DWORD)*8 - 1,

    DRS_EXT_MAX
} DRS_EXT;

// We decided that it'd be better self-documenting code if we tied
// this paticular bit BETA3 to conceptual bits describing what they
// do.  This makes code/repadmin/dsexts/everything much more clear.
// If someone is passionate enough, they could make DRS_EXT_POST_BETA2
// into a similar breakdown.
#define DRS_EXT_ADDENTRYREPLY_V3    DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_GETCHGREPLY_V7      DRS_EXT_WHISTLER_BETA3
#define DRS_EXT_VERIFY_OBJECT       DRS_EXT_WHISTLER_BETA3


// Maximum length in bytes of an extensions _string_ containing any bits we care
// about.  (Incoming strings can be longer if they come from an up-level DSA,
// but if so the extra bytes contain bits for extensions we don't know about, so
// we need not store them.)
#define CURR_MAX_DRS_EXT_FIELD_LEN (1 + ((DRS_EXT_MAX - 1)/ sizeof(BYTE)))

// Maximum length in bytes of an extensions _structure_ containing any bits we
// care about.
#define CURR_MAX_DRS_EXT_STRUCT_SIZE \
    (sizeof(DWORD) + CURR_MAX_DRS_EXT_FIELD_LEN)

// Length in bytes of the given extensions structure.
#define DrsExtSize(pext) ((pext) ? sizeof(DWORD) + (pext)->cb : 0)

// Is the specified extension supported in the given DRS_EXTENSIONS set?
#define IS_DRS_EXT_SUPPORTED(pext, x)                   \
    ((NULL != (pext))                                   \
     && ( (pext)->cb >= 1+((x)/8) )                     \
     && ( 0 != ( (pext)->rgb[(x)/8] & (1<<((x)%8) ))))

// Get a pointer to the dwReplEpoch for a DSA given its DRS_EXTENSIONS, or 0
// if unavailable.
#define REPL_EPOCH_FROM_DRS_EXT(pext)                               \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, dwReplEpoch)    \
                       + sizeof(DWORD)   /* dwReplEpoch */          \
                       - sizeof(DWORD))) /* cb */                   \
     ? 0                                                            \
     : ((DRS_EXTENSIONS_INT *)(pext))->dwReplEpoch)

// Get a pointer to the site objectGuid for a DSA given its DRS_EXTENSIONS, or
// NULL if unavailable.
#define SITE_GUID_FROM_DRS_EXT(pext)                                \
    (((NULL == (pext))                                              \
      || ((pext)->cb < offsetof(DRS_EXTENSIONS_INT, SiteObjGuid)    \
                       + sizeof(GUID)    /* SitObjGuid */           \
                       - sizeof(DWORD))) /* cb */                   \
     ? NULL                                                         \
     : &((DRS_EXTENSIONS_INT *)(pext))->SiteObjGuid)

// Given the DRS extensions for a given DSA, determine whether it's in the
// given site.  If a definite determination cannot be made, errs on the side
// of "same site."
#define IS_REMOTE_DSA_IN_SITE(pext, pSiteDN)        \
    ((NULL == (pSiteDN))                            \
     || fNullUuid(&(pSiteDN)->Guid)                 \
     || fNullUuid(SITE_GUID_FROM_DRS_EXT(pext))     \
     || (0 == memcmp(&(pSiteDN)->Guid,              \
                     SITE_GUID_FROM_DRS_EXT(pext),  \
                     sizeof(GUID))))



// Destination can support linked value replication data
// Does the DSA support linked value replication
#define IS_LINKED_VALUE_REPLICATION_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_LINKED_VALUE_REPLICATION)

// Safely set extension as supported
#define SET_DRS_EXT_SUPPORTED(pext, x) \
{ \
      if ( (NULL != (pext)) && ( (pext)->cb >= 1+((x)/8) ) )  \
            (pext)->rgb[(x)/8] |= (1<<((x)%8)); \
      }


// Schema prefix table.

typedef struct OID_s {
    unsigned length;
#ifdef MIDL_PASS
    [size_is(length)] BYTE * elements;
#else
    BYTE  * elements;
#endif
} OID_t;

typedef struct {
    DWORD       ndx;
    OID_t       prefix;
} PrefixTableEntry;

typedef struct {
    DWORD PrefixCount;
    SIZE_IS(PrefixCount)
        PrefixTableEntry *  pPrefixEntry;
} SCHEMA_PREFIX_TABLE;

//
// This begins the on the wire representation of the thread state error
// NOTE: if the DIRERR struct is changed then you should increment the
// version of the DRS_Error_Data_V1 and make a function that can convert
// and package and unpackage the error state.  See:
//      DRS_SetDirErr_SemiDeepCopy() and
//      DRS_THError_SemiDeepCopy()
//

typedef struct _NAMERESOP_DRS_WIRE_V1
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP_DRS_WIRE_V1;

typedef struct ANYSTRINGLIST_DRS_WIRE_V1{       /* A list of substrings to match */
    struct ANYSTRINGLIST_DRS_WIRE_V1 FAR *pNextAnyVal;
    ATTRVAL AnyVal;
}ANYSTRINGLIST_DRS_WIRE_V1;

typedef struct SUBSTRING_DRS_WIRE_V1{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal_DRS_WIRE_V1{
        USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST_DRS_WIRE_V1 FirstAnyVal; /* a list of substrings to match */
    }AnyVal_DRS_WIRE_V1;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING_DRS_WIRE_V1;

/**************************************************************************
 *    Error Data Structures
 **************************************************************************/

// Obviously this is now an external format error.
typedef struct INTERNAL_FORMAT_PROBLEM_DRS_WIRE_V1
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB_DRS_WIRE_V1;

typedef struct _PROBLEMLIST_DRS_WIRE_V1
{
    struct _PROBLEMLIST_DRS_WIRE_V1 FAR *pNextProblem; /* linked-list to next prob att */
    INTFORMPROB_DRS_WIRE_V1 intprob;
} PROBLEMLIST_DRS_WIRE_V1;



/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

typedef UNICODE_STRING DSA_ADDRESS;
typedef struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 {
    struct _DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pNextAddress;
    // For ease marshalling I turned this into a pointer, so this is
    // not exactly like the original.
    DSA_ADDRESS *                            pAddress;
} DSA_ADDRESS_LIST_DRS_WIRE_V1;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

#define CH_REFTYPE_SUPERIOR     0
#define CH_REFTYPE_SUBORDINATE  1
#define CH_REFTYPE_NSSR         2
#define CH_REFTYPE_CROSS        3

typedef struct CONTREF_DRS_WIRE_V1
{
    PDSNAME                         pTarget;        /* target name in continuing operation */
    NAMERESOP_DRS_WIRE_V1           OpState;        /* operation status */
    USHORT                          aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT                          RDNsInternal;   /* reserved */
    USHORT                          refType;        /* reserved */
    USHORT                          count;          /* number of access points */
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *  pDAL;           /* linked list of access points */
    struct CONTREF_DRS_WIRE_V1 *    pNextContRef;   /* linked list of CRs */
    
    // NOTE: This is assumed to be NULL, and is skipped.  For the purposes
    // of IDL_DRSAddEntry() we won't get a referral with a Filter.  However, if
    // someone did a remote search type thing, then they could get a filter in
    // the thread state error, and then they'd have to update the existing DRS
    // thread state packaging routines to account for and package up the filter.
    // PFILTER_DRS_WIRE_V1             pNewFilter;     /* new filter (optional) */

    BOOL                            bNewChoice;     /* is a new choice present? */
    UCHAR                           choice;         /* new search choice (optional) */
} CONTREF_DRS_WIRE_V1;

/* These are the seven problem types wire versions, for more   */ 
/* information about each kind look lower to the type without  */
/* the _DRS_WIRE_V1 appended                                   */

typedef struct ATRERR_DRS_WIRE_V1
{
    PDSNAME                    pObject;        /* name of the offending object */
    ULONG                      count;          /* the number of attribute errors */
    PROBLEMLIST_DRS_WIRE_V1    FirstProblem;   /* a linked-list of attribute errors */
} ATRERR_DRS_WIRE_V1;

typedef struct NAMERR_DRS_WIRE_V1
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above. */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR_DRS_WIRE_V1;

typedef struct REFERR_DRS_WIRE_V1
{
    DWORD                dsid;
    DWORD                extendedErr;        /* Non-standard error code */
    DWORD                extendedData;   /* extra data to go with it */
    CONTREF_DRS_WIRE_V1  Refer;                 /* alternate DSAs to contact */
} REFERR_DRS_WIRE_V1;

typedef struct _SECERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR_DRS_WIRE_V1;

typedef struct _SVCERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR_DRS_WIRE_V1;

typedef struct _UPDERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR_DRS_WIRE_V1;

typedef struct _SYSERR_DRS_WIRE_V1
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR_DRS_WIRE_V1;


/* This is the number of errors alloted per return code type. */

#define   DIR_ERROR_BASE      1000

/* These error defines correspond to API return codes. */

#define attributeError      1   /* attribute error */
#define nameError           2   /* name error */
#define referralError       3   /* referral error */
#define securityError       4   /* security error */
#define serviceError        5   /* service error */
#define updError            6   /* update error */
#define systemError         7   /* system error */

/*

    This is the wire version of the mail DIRERR info for transfering the
    thread state error.  If changes need to be made, then all structures
    above the structure will need to change to a version 2.  So for 
    instances if you changed the referral error to include the pFilter
    which it doesn't (in V1) have, then the below RefErr element would be
    of type REFERR_DRS_WIRE_V2, while the rest could remain unchanged.  
    CONTREF_DRS_WIRE_V1 would goto V2 as well.
    
    Then the encoding and decoding routines in dramderr.c would need to
    be updated to handle the different versions, and set the dwErrVer 
    correctly in the using routines, and marshall/translate/set the
    pErrData correctly depending on the new version.
    
*/    
typedef SWITCH_TYPE(DWORD) union _DIRERR_DRS_WIRE_V1
{
    CASE(attributeError) ATRERR_DRS_WIRE_V1  AtrErr;  /* attribute error */
    CASE(nameError)      NAMERR_DRS_WIRE_V1  NamErr;  /* name error      */
    CASE(referralError)  REFERR_DRS_WIRE_V1  RefErr;  /* referral error  */
    CASE(securityError)  SECERR_DRS_WIRE_V1  SecErr;  /* security error  */
    CASE(serviceError)   SVCERR_DRS_WIRE_V1  SvcErr;  /* service error   */
    CASE(updError)       UPDERR_DRS_WIRE_V1  UpdErr;  /* update error    */
    CASE(systemError)    SYSERR_DRS_WIRE_V1  SysErr;  /* system error    */
} DIRERR_DRS_WIRE_V1;


/***************************************************************************

    NOTHING BELOW THIS LINE WILL BE INCLUDED IN THE MIDL COMPILATION STAGE!

 ***************************************************************************/
#ifndef MIDL_PASS

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)




/***************************************************************************
 *    Filter Definitions
 ***************************************************************************/


typedef struct ANYSTRINGLIST{       /* A list of substrings to match */
    struct ANYSTRINGLIST FAR *pNextAnyVal;
    ATTRVAL AnyVal;
}ANYSTRINGLIST;

typedef struct SUBSTRING{
    ATTRTYP type;                  /* The type of attribute */
    BOOL    initialProvided;       /* If true an initial sub is provided*/
    ATTRVAL InitialVal;            /* The initial substring (str*) to match */
    struct AnyVal{
        USHORT count;              /* The # of subs (*str1*str2*) to match*/
        ANYSTRINGLIST FirstAnyVal; /* a list of substrings to match */
    }AnyVal;
    BOOL    finalProvided;         /* If true an final sub  is provided*/
    ATTRVAL FinalVal;              /* The final substring (str*) to match */
}SUBSTRING;


/* A filter item indicates a logical test of an AVA.  This means that
 * the provided attribute value should have one of these test performed
 * against the attribute value found on the directory object.
 */

typedef struct FILITEM{
    UCHAR   choice;                /* The type of operator:
                                    * Valid values defined in filtypes.h
                                    */
    struct FilTypes{
        AVA           ava;         /* contain the value for all binary relops */
        SUBSTRING FAR *pSubstring; /* substring match             */
        ATTRTYP       present;     /* attribute presence on entry */
        BOOL          *pbSkip;     /* when evaling filter, dont read from DB */
                                   /* Set to false for security purposes */
    }FilTypes;

    DWORD             expectedSize; /* The estimated size of this Filter Item */
                                    /* Zero means not estimated */
}FILITEM;



/* This is a linked list of filters that are either Anded or Orded together.*/

struct FilterSet{
    USHORT              count;         /* number of items in linked-set */
    struct FILTER FAR * pFirstFilter;  /* first filter in set */
};




/* The filter is used to construct an arbitrary logical test of a
 *   directory object.  It consists of either a single item (see
 *   FILIITEM above) which is a test of a single attribute,
 *   a set of attribute tests (FilterSet) Anded or Ored together,
 *   or a negation of a test or an attribute set.
 *
 *   The following examples should illustrate how filter structures work.
 *   Actual attribute names and values are omitted to simplify the examples.
 *
 *   EXAMPLE:
 *
 *        A = 5
 *
 *        item
 *        ------
 *       | A=5  |
 *        ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and (b = ab) and (c = 2)
 *
 *        AND set            item            item            item
 *        -------- first    ------ next     ------ next     ------
 *       | 3 items|---->   | A=5  |---->   | b=ab |---->   | c=2  |
 *        -------- filter   ------ filter   ------ filter   ------
 *  ___________________________________________________________________________
 *
 *        (A = 5) and ((b = "abc") or (c = 2)) and (d <=1)
 *
 *        AND set            item           OR set           item
 *        -------- first    ------ next     -------- next    ------
 *       | 3 items|---->   | A=5  |---->   | 2 items|--->   | d<=1 |
 *        -------- filter   ------ filter   -------- filter  ------
 *                                                 |
 *                                           first | filter
 *                                                 V
 *                                                item          item
 *                                             -------- next    ------
 *                                            | b="abc"|---->  | c=2  |
 *                                             -------- filter  ------
 *
 */

typedef struct FILTER{
    struct FILTER FAR *pNextFilter;  /* points to next filter in set */
    UCHAR   choice;                      /* filter type
                                          * Valid values defined in filtypes.h
                                          */
    struct _FilterTypes{                          /* based on the choice */
        FILITEM           Item;
        struct FilterSet  And;
        struct FilterSet  Or;
        struct FILTER FAR *pNot;
    }FilterTypes;
}FILTER;

typedef FILTER FAR *PFILTER;

typedef ULONG MessageId;

/* The service control structure allows the client to control how
 *    directory operations are performed.
 *
 * Prefer chaining indicates that the client perfers that distributed
 *    operations are chained rather than referred.  This does not guarantee
 *    what type of distribution may actually be used.
 *
 * ChainingProhibited stops the DSA from contacting other DSA's if the
 *    information needed to satisfy the operation resides in another DSA.
 *    Instead it will construct a referral list of DSA's for the
 *    client to contact directly. This gives the client control over the cost
 *    of a distributed operation.
 *
 * Local scope tells the DSA to only contact DSA's that are nearby
 *    (perhaps even on the same subnet) if it can't complete
 *    an operation alone.  The client may receive a referral list
 *    of other DSA's to contact if the operation couldn't be satisfied by
 *    the local set of DSA's.  This flag lets the client limit the cost of
 *    an operation by prohibiting contact to DSA's that are expensive to reach.
 *
 * DontUseCopy tells the directory that the target of the operation
 *    is the master object.  This is used when the client (usually an
 *    administrator) needs the up-to-date version of a directory object.
 *
 * DerefAliasFlag tells the directory what kind of aliases to dereference.
 *    Valid values are:
 *    DA_NEVER - never deref aliases
 *    DA_SEARCHING - deref when searching, but not for locating the base
 *                   of the search.
 *    DA_BASE - deref in locating the base of the search, but not while s
 *              searching
 *    DA_ALWAYS - always deref aliases.
 *
 * MakeDeletionsAvail is used by the internal synchronization process only.
 *    It makes visible objects that have been deleted but not yet physically
 *    removed from the system.
 *
 * DontPerformSearchOp is used to get Search Statistics from the DS using the
 *    LDAP STATS control. There are two options:
 *      a) optimize the search query and return expected number of operations
 *         without visiting the actual entries on the disk
 *      b) perform the query, but instead of returning the real data, return
 *         statistics for the query performed
 *
 * pGCVerifyHint - The DS verifies all DSNAME-valued properties for existence
 *    either against itself if it holds the naming context in question, or
 *    against a GC if not.  There are cases where apps need to add an object O1
 *    on machine M1 and then immediately thereafter add a reference to O1 on
 *    object O2 on machine M2.  M2 will fail the O1 verification check if
 *    it doesn't hold O1's NC and its choice of GC is not M1, or if it does
 *    hold O1's NC but isn't the replica where O1 was just added.  This field
 *    allows a client to tell the DS which machine to perform DSNAME
 *    verification against.  This hint is unilateral and unconditional in that
 *    if specified, all DSNAME-valued properties will be verified at the
 *    specified machine and no where else, not even locally.  Best results
 *    are obtained when the value is the DNS host name for a DC, though other
 *    forms of names may work in certain environments.
 *
 *   NOTE: The omission of the SVCCNTL (null pointer) parameter will default
 *   to no preference for chaining, chaining not prohibited, no limit on the
 *   scope of operation, use of a copy permitted, aliases will be dereferenced,
 *   a copy can not be updated and deletions will not be visible.
 */


typedef struct SVCCNTL
{
    ULONG SecurityDescriptorFlags;    /*  flags describing what part  */
                                      /*  of the SD to read.          */
    unsigned DerefAliasFlag:2;        /*  don't dereference an alias  */
    BOOL preferChaining:1;            /*  chaining is preferred       */
    BOOL chainingProhibited:1;        /*  chaining prohibited         */
    BOOL localScope:1;                /*  local scope chaining only   */
    BOOL dontUseCopy:1;               /*  dont use copy               */

    /* Non standard extensions.  Set to TRUE */
    // None yet.

    /* Non standard extensions.  Set to FALSE */
    BOOL makeDeletionsAvail:1;
    BOOL fUnicodeSupport:1;
    BOOL fStringNames:1;
    BOOL fSDFlagsNonDefault:1;
    BOOL fPermissiveModify:1;         /* don't err on update errors that   */
                                      /* do not affect the final object    */
                                      /* (e.g., remove of non-extant value */
    BOOL fUrgentReplication:1;        /* Skip wait to being replication */
    BOOL fAuthoritativeModify:1;      /* Change made is authoritative   */
                                      /* and wins against any other     */
                                      /* version that currently exists  */
                                      /* in the enterprise              */
    BOOL fMaintainSelOrder:1;         /* Don't reorder selection list   */
    BOOL fDontOptimizeSel:1;          /* Don't touch selection list     */
    BOOL fGcAttsOnly:1;               /* Only request for GC Partial Atts */

    BOOL fMissingAttributesOnGC:1;    /* Client requested attributes that */
                                      /* were not visible on the GC port */

    unsigned DontPerformSearchOp:2;   /* Do not perform actual search Op */

    WCHAR *pGCVerifyHint;             /* See description above          */

} SVCCNTL;

#define DA_NEVER     0
#define DA_SEARCHING 1
#define DA_BASE      2
#define DA_ALWAYS    (DA_SEARCHING | DA_BASE)

#define SO_NORMAL        0
#define SO_STATS         1
#define SO_ONLY_OPTIMIZE 2

/*  This structure is used by the client to continue an ongoing
 *   operation with a different DSA.  This occurs when a DSA does not have
 *   the information needed to complete an operation but knows of other
 *   DSA's that may be able to perform the operation that it can not
 *   contact for various reasons (e.g SVCCNTL's).  The information that is
 *   returned from the DSA is used to set this data structure (see REFERR
 *   error).
 *
 *   The nameRes filed is usually set to OP_NAMERES_NOT_STARTED.
 */

#define OP_NAMERES_NOT_STARTED          'S'
#define OP_NAMERES_PROCEEDING           'P'
#define OP_NAMERES_COMPLETED            'C'

typedef struct _NAMERESOP
{
    UCHAR   nameRes;        /*  status of name resolution.
                             *  Valid values:
                             *    - OP_NAMERES_NOT_STARTED
                             *    - OP_NAMERES_PROCEEDING
                             *    - OP_NAMERES_COMPLETED
                             */
    UCHAR   unusedPad;
    USHORT  nextRDN;        /*  index to the next part of the name to be
                             *  resolved.  This parm only has meaning
                             *  if the operation is proceeding.
                             */
} NAMERESOP;

typedef unsigned char BYTE;


/*
local_extension

A local_extension is similar to the X.500 extension object.
It provides a method for extending the protocol. Local extensions
are Microsoft specific.

Each extension is identified by an OID. In addition, the
extension has a critical boolean, which is true if the extension
is critical (i.e. must be supported for the call to be properly
serviced). The item element points to extension specific
data.
*/

/*
Paged Results

Although technically a local extension, Paged Results is made a
permanent part of the common arguments structure.  It is intended
to work like this:

The common argument structure contains a pointer to the PR restart
data structure provided by the user, if present.  The possible
conditions are:

fPresent FALSE => user didn't request PR; pRestart set to NULL

fPresent TRUE, pRestart NULL => first call (not a restart), PR requested

fPresent TRUE, pRestart != NULL => restart (cotinue) PR call

*/

/*
Unicode strings
Unicode strings is another microsoft extension that allows clients to request
strings of syntax OM_S_UNICODE_STRING to be returned as such. by default,
such strings are translated to OM_S_TELETEX_STRING.
*/

//
// Possible values of the restartType variable in a RESTART struct.
//
#define NTDS_RESTART_PAGED 1
#define NTDS_RESTART_VLV   2

typedef struct _RESTART
{
    // !! Any changes to this struct must leave !!
    // !! the 'data' member 8 byte aligned      !!
    ULONG       restartType;             // Is this a paged search restart or vlv.
    ULONG       structLen;              // The size of this whole structure.
    ULONG       CRC32;                  // the CRC of this whole structure
    ULONG       pad4;                   // four bytes of padding so that the rest
                                        // of the struct will be 8 byte aligned.
    GUID        serverGUID;             // the GUID of the server that created this structure
    DWORD       data[];                 // Hand marshalled data holding the
                                        // restart information.  We use DWORDs
                                        // because most of the packed data is
                                        // DWORD and I want to encourange
                                        // alignment.
} RESTART, * PRESTART;

typedef struct
{
    PRESTART    pRestart;       /* restart data */
    BOOL        fPresent:1;
} PAGED_RESULT;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for VLV results)
    BOOL           fseekToValue:1;    // flag whether we navigate using seekValue or
                                      // targetPosition
    IN ULONG       beforeCount;       // number of entries before target
    IN ULONG       afterCount;        // number of entries after target
    IN OUT ULONG   targetPosition;    // target position (offset from start)
                                      // in = Ci, out = Si
    IN OUT ULONG   contentCount;      // size of container
                                      // in = Cc, out = Sc
    IN ATTRVAL     seekValue;         // the value we seek From

    IN OUT PRESTART pVLVRestart;      // Restart Argument

    DWORD           Err;              // VLV Specific Service Error

} VLV_REQUEST, * PVLV_REQUEST;


typedef struct
{
    BOOL           fPresent:1;        // Flag whether this data structure contains
                                      // valid information (whether the client
                                      // asks for ASQ results)
    BOOL           fMissingAttributesOnGC:1; // Flag whether the search operation
                                             // references attributes that are
                                             // not part of the GC partial attr set


    ATTRTYP        attrType;

    DWORD          Err;               // ASQ Specific Service Error

} ASQ_REQUEST, * PASQ_REQUEST;


/*  These common input arguments are supplied with most directory
    calls.  The service controls provide client options that govern the
    operation.  The operation state specifies if this is  a new or
    continued operation (see OPERATION above).  The aliasRDN is only set
    if this is a continuation of a referral (see REFERR).  It is  set
    from the aliasRDN of the continuation referrence of the referral.

    Note that pReserved must be set to NULL!
*/


typedef struct _COMMARG
{
    SVCCNTL         Svccntl;     /* service controls */
    NAMERESOP       Opstate;     /* the state of the operation */
    ULONG         * pReserved;   /* Must be set to NULL*/
    ULONG           ulSizeLimit; /* size limit */
    ATTRTYP         SortAttr;    /* Attribute to sort on. */
    int             Delta;       /* Number of objects to skip on a list or
                                    search. Negative means walk backwards.  */
    ULONG           StartTick;   /* Tick count of the start of this operation
                                    0 means no time limit.                  */
    ULONG           DeltaTick;   /* Number of ticks to let this operation run.*/
    USHORT          aliasRDN;    /* number of RDN's produced by alias dereferencing */
    ULONG           SortType;    /* 0 - none, 1 - optional sort, 2-mandatory */
    BOOL            fForwardSeek:1;/* should the results of a list or search be
                                      constructed from the next objects, or the
                                      previous objects in whatever index we
                                      use. */
    BOOL            fLazyCommit:1; /* Can JET commit lazily? */
    BOOL            fFindSidWithinNc:1; /* Tells Do Name Res, to find a DS Name
                                         with only a Sid specified to be in
                                         the NC of authoritative Domain for
                                         the domain controller */

    DWORD           MaxTempTableSize;   // max entries per temp table

    PAGED_RESULT    PagedResult; /* Paged Results local extension */
    VLV_REQUEST     VLVRequest;  /* VLV Request local extension   */
    ASQ_REQUEST     ASQRequest;  /* ASQ Request local extension */

} COMMARG;

/* ...and a routine to give you default values.  Use it! */
VOID InitCommarg(COMMARG *pCommArg);

typedef struct _COMMRES {
    BOOL            aliasDeref;
    ULONG           errCode;
    union _DIRERR  *pErrInfo;
} COMMRES;

// Values for SortType
#define SORT_NEVER     0
#define SORT_OPTIONAL  1
#define SORT_MANDATORY 2

/*  This data structure is used on DirRead and DirSearch operations
 *  to specify the type of information the directory should return.  The
 *  client must specify the return of some or all of the object
 *  attributes found.  If only some attributes are to be returned, the
 *  client must provide a list of the desired attribute types.  An
 *  indication of some attributes together with a NULL attribute list
 *  indicates that no attributes are to be returned.  Attributes are
 *  returned only if they are present.  An attributeError with the
 *  PR_PROBLEM_NO_ATTRIBUTE designation will be returned if none of the
 *  selected attributes are present.
 *
 *  The client also specifies whether the attribute types or both the
 *  types and values should be returned.
 */

#define EN_ATTSET_ALL            'A'  /* get all atts                        */
#define EN_ATTSET_ALL_WITH_LIST  'B'  /* get all atts and list               */
#define EN_ATTSET_LIST           'L'  /* get selected atts                   */
#define EN_ATTSET_LIST_DRA       'E'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA        'D'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_EXT   'F'  /* get selected atts, deny special DRA */
#define EN_ATTSET_ALL_DRA_EXT    'G'  /* get all atts except special DRA     */
#define EN_ATTSET_LIST_DRA_PUBLIC   'H'  /* get selected atts, deny special DRA, deny secret */
#define EN_ATTSET_ALL_DRA_PUBLIC    'I'  /* get all atts except special DRA, deny secret     */

#define EN_INFOTYPES_TYPES_ONLY  'T'  /* return att types only               */
#define EN_INFOTYPES_TYPES_MAPI  't'  /* types only, obj name in MAPI form   */
#define EN_INFOTYPES_TYPES_VALS  'V'  /* return types and values             */
#define EN_INFOTYPES_SHORTNAMES  'S'  /* Types + values, short DSName format */
#define EN_INFOTYPES_MAPINAMES   'M'  /* Types + values, MAPI DSName format  */

typedef struct _ENTINFSEL
{
    UCHAR        attSel;      /*  Retrieve all or a list of selected atts:
                               *  Valid values:
                               *    see EN_ATTSET_* defines above
                               */
    ATTRBLOCK    AttrTypBlock; /*  counted block of attribute types */
    UCHAR        infoTypes;    /*  Retrieve attribute types or types and values
                                *  Valid values:
                                *     see EN_INFOTYPES_* defines above
                                */
} ENTINFSEL;



/**************************************************************************
 *    Attribute Value Syntax Data Types
 **************************************************************************/

#define SYNTAX_UNDEFINED_TYPE           0
#define SYNTAX_DISTNAME_TYPE            1
#define SYNTAX_OBJECT_ID_TYPE           2
#define SYNTAX_CASE_STRING_TYPE         3
#define SYNTAX_NOCASE_STRING_TYPE       4
#define SYNTAX_PRINT_CASE_STRING_TYPE   5
#define SYNTAX_NUMERIC_STRING_TYPE      6
#define SYNTAX_DISTNAME_BINARY_TYPE     7
#define SYNTAX_BOOLEAN_TYPE             8
#define SYNTAX_INTEGER_TYPE             9
#define SYNTAX_OCTET_STRING_TYPE        10
#define SYNTAX_TIME_TYPE                11
#define SYNTAX_UNICODE_TYPE             12

/* MD specific attribute syntaxes. */
#define SYNTAX_ADDRESS_TYPE             13
#define SYNTAX_DISTNAME_STRING_TYPE    14
#define SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE 15
#define SYNTAX_I8_TYPE                  16
#define SYNTAX_SID_TYPE                 17


/*  All attribute syntaxes are represented as a linear values.  This  means
 *  that an entire attribute value is stored in a contiguous set of bytes
 *  that contain no pointers.  Valid comparisons are defined in dbsyntax.c
 */

typedef UCHAR    SYNTAX_UNDEFINED;
typedef DSNAME   SYNTAX_DISTNAME;
typedef ULONG    SYNTAX_OBJECT_ID;
typedef UCHAR    SYNTAX_CASE_STRING;
typedef UCHAR    SYNTAX_NOCASE_STRING;
typedef UCHAR    SYNTAX_PRINT_CASE_STRING;
typedef UCHAR    SYNTAX_NUMERIC_STRING;
typedef BOOL     SYNTAX_BOOLEAN;
typedef long     SYNTAX_INTEGER;
typedef UCHAR    SYNTAX_OCTET_STRING;
typedef DSTIME   SYNTAX_TIME;
typedef wchar_t  SYNTAX_UNICODE;
typedef UCHAR    SYNTAX_NT_SECURITY_DESCRIPTOR;
typedef LARGE_INTEGER SYNTAX_I8;
typedef UCHAR    SYNTAX_SID;


typedef struct _SYNTAX_ADDR
{
    ULONG structLen;                    // Total length of this structure,
                                        // in BYTES!!!

    union {
        BYTE    byteVal[1];
        wchar_t uVal[1];
    };

} SYNTAX_ADDRESS;

typedef SYNTAX_ADDRESS STRING_LENGTH_PAIR;

/*
 * The following macro's can be used to correctly calculate the structlen
 * of a SYNTAX_ADDRESS from the payload length, or vice versa.
 */
#define PAYLOAD_LEN_FROM_STRUCTLEN( structLen ) \
    ((structLen) - sizeof(ULONG))

#define STRUCTLEN_FROM_PAYLOAD_LEN( stringLen ) \
    ((stringLen) + sizeof(ULONG))


/*  Note: In general, the <String> field of the following structure
 *  should not be directly referenced since the preceding <Name> field
 *  is variable-sized.  Also, one should not should not rely on the
 *  "sizeof()" operator's evaluation of the size of the structure since
 *  the size of the SYNTAX_DISTNAME <Name> will usually be larger than
 *  "sizeof(SYNTAX_DISTNAME)."
 */

typedef struct _SYNTAX_DISTNAME_DATA
{
    DSNAME         Name;                // the Distinguished Name
    SYNTAX_ADDRESS Data;                // The data
} SYNTAX_DISTNAME_STRING, SYNTAX_DISTNAME_BINARY;


/*  The following defines can be used to find <Name> and <Data>
 *  fields and otherwise manipulate _SYNTAX_DISTNAME_BLOB attributes.
 */

/* produce a pointer to the <Name> field: */

#define NAMEPTR( pDN_Blob ) \
    ((DSNAME *) (&(pDN_Blob)->Name))


// Produce the size of a given DISTNAME, padded to the nearest 4 bytes.
#define PADDEDNAMEMASK (~3)
#define PADDEDNAMESIZE(pDN) \
    (((pDN)->structLen + 3) & PADDEDNAMEMASK)

/* produce a pointer to the <Address> field: */
#define DATAPTR( pDN_Blob ) \
    ((SYNTAX_ADDRESS *)(PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + (char *)(pDN_Blob)))

/* find the combined size of the <Name> and <Data> structures: */
#define NAME_DATA_SIZE( pDN_Blob ) \
    (PADDEDNAMESIZE(NAMEPTR(pDN_Blob)) + DATAPTR(pDN_Blob)->structLen)

/* given a DSNAME and a SYNTAX_ADDRESS, find their combined size: */
#define DERIVE_NAME_DATA_SIZE( pDN, pData ) \
    (PADDEDNAMESIZE(pDN) + (pData)->structLen)

/*  Given a SYNTAX_DISTNAME, a STRING_LENGTH_PAIR, and pre-allocated space
    of the appropriate size, build a _SYNTAX_DISTNAME_BLOB attribute
    by copying in its component parts:
*/

#define BUILD_NAME_DATA( pDN_Blob, pDN, pData ) \
    memcpy( NAMEPTR(pDN_Blob), (pDN)  , (pDN)->structLen ); \
    memcpy( DATAPTR(pDN_Blob), (pData), (pData)->structLen );


/**************************************************************************
 *    Error Data Structures
 **************************************************************************/


/* An ATRERR reports an attribute related problem */

#define ATRERR_BASE                     ( attributeError * DIR_ERROR_BASE )

#define PR_PROBLEM_NO_ATTRIBUTE_OR_VAL      ( ATRERR_BASE + 1 )
#define PR_PROBLEM_INVALID_ATT_SYNTAX       ( ATRERR_BASE + 2 )
#define PR_PROBLEM_UNDEFINED_ATT_TYPE       ( ATRERR_BASE + 3 ) /*DirAddEntry &
                                                                 * DirModEntry
                                                                 * only
                                                                 */
#define PR_PROBLEM_WRONG_MATCH_OPER         ( ATRERR_BASE + 4 )
#define PR_PROBLEM_CONSTRAINT_ATT_TYPE      ( ATRERR_BASE + 5 )
#define PR_PROBLEM_ATT_OR_VALUE_EXISTS      ( ATRERR_BASE + 6 )

/*

   Most of the error data structures (like the ones below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct INTERNAL_FORMAT_PROBLEM
{
    DWORD                   dsid;
    DWORD                   extendedErr;  /* Non-standard error code */
    DWORD                   extendedData;   /* extra data to go with it */
    USHORT                  problem;      /* Attribute problem type,
                                           * valid values defined above
                                           */
    ATTRTYP                 type;         /* the offending attribute type */
    BOOL                    valReturned;  /* indicates that an attribute
                                           * value follows
                                           */
    ATTRVAL                 Val;          /* optionally supplied offending
                                           * att value
                                           */
} INTFORMPROB;

typedef struct PROBLEMLIST
{
    struct PROBLEMLIST FAR *pNextProblem; /* linked-list to next prob att */
    INTFORMPROB intprob;      
} PROBLEMLIST;

typedef struct ATRERR
{
    PDSNAME     pObject;        /* name of the offending object */
    ULONG       count;          /* the number of attribute errors */
    PROBLEMLIST FirstProblem;   /* a linked-list of attribute errors */
} ATRERR;




/*  A NAMERR reports a problem with a name provided as an operation argument.
 *  Note that a problem with the attribute types and/or values in a DistName
 *  used as an operation argument is reported via a NAMERR with problem
 *  NA_PROBLEM_BAD_ATT_SYNTAX rather than as an ATRERR or an UPDERR
 */

#define NAMERR_BASE                         ( nameError * DIR_ERROR_BASE )

#define NA_PROBLEM_NO_OBJECT                ( NAMERR_BASE + 1 )
#define NA_PROBLEM_NO_OBJ_FOR_ALIAS         ( NAMERR_BASE + 2 )
#define NA_PROBLEM_BAD_ATT_SYNTAX           ( NAMERR_BASE + 3 )
#define NA_PROBLEM_ALIAS_NOT_ALLOWED        ( NAMERR_BASE + 4 )
#define NA_PROBLEM_NAMING_VIOLATION         ( NAMERR_BASE + 5 )
#define NA_PROBLEM_BAD_NAME                 ( NAMERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct NAMERR
{
    DWORD       dsid;
    DWORD       extendedErr;    /* Non-standard error code */
    DWORD       extendedData;   /* extra data to go with it */
    USHORT      problem;        /* The type of name problem, valid values
                                 * defined above.
                                 */
    PDSNAME     pMatched;       /*  the closest name match  */
} NAMERR;


/*  The referral is an indication from a DSA that it was unable to
 *  complete the operation because of either client specified
 *  restrictions or because some DSA's are unavailable.  It provides
 *  information as to the state of the operation and a list of other
 *  DSA's that may be able to satisfy the request.
 *
 *  To continue the request, the client must bind to each referred DSA
 *  and attempt the same operation.  They must specify the CONTREF.target
 *  object name as the search object name. (This may be different from
 *  the original object name because of alias dereferencing.)  The
 *  operation state (opstate) on the common arguments (COMMARG) must be
 *  set from the operation state on the continuation reference CONTREF.
 *  The aliasRDN of the common arguments must be set from the aliasRDN of
 *  the continuation reference.
 */

/*  The access point is the name and address of a DSA to contact.
 *  This is returned from a DSA referral and is used to bind to a
 *  referred DSA (see DirBind).
 */

typedef SYNTAX_DISTNAME_STRING ACCPNT;

/* A list of access points is returned on referrals. */
typedef struct ACCPNTLIST
{
    struct ACCPNTLIST  * pNextAccPnt;     /* linked-list to next ACCPNT */
    ACCPNT             * pAccPnt;         /* this access point */
} ACCPNTLIST;

/* Access Points seem excessively ISO specific, and since everyone on
 * the planet seems to be using TCP/IP and DNS, which use a simple
 * string representation of an address rather than an ISO Presentation
 * Address, we are migrating data structures this way.
 */

// moved up to above the IDL line: typedef UNICODE_STRING DSA_ADDRESS;

typedef struct _DSA_ADDRESS_LIST {
    struct _DSA_ADDRESS_LIST * pNextAddress;
    DSA_ADDRESS              Address;
} DSA_ADDRESS_LIST;

/*  The continuation referrence is returned on a referral to other DSA's
    for the completion of an operation.  The reference contains the name
    of the desired directory object, the state of the partially completed
    operation, some support information that is used to continue and a
    list of other DSA's to contact.
*/

// The CH_REFTYPE_XXXXX were moved up to the CONTREF_DRS_WIRE_V1 area. 

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct CONTREF
{
    PDSNAME     pTarget;        /* target name in continuing operation */
    NAMERESOP   OpState;        /* operation status */
    USHORT      aliasRDN;       /* # of RDN's produced by dereferencing */
    USHORT      RDNsInternal;   /* reserved */
    USHORT      refType;        /* reserved */
    USHORT      count;          /* number of access points */
    DSA_ADDRESS_LIST *pDAL;     /* linked list of access points */
    struct CONTREF *pNextContRef; /* linked list of CRs */
    PFILTER     pNewFilter;     /* new filter (optional) */
    BOOL        bNewChoice;     /* is a new choice present? */
    UCHAR       choice;         /* new search choice (optional) */
} CONTREF;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct REFERR
{
    DWORD      dsid;
    DWORD      extendedErr;        /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    CONTREF Refer;                 /* alternate DSAs to contact */
} REFERR;


/*  A SECERR reports a problem in carrying out an operation because of
 *  security reasons.
 *
 *  NOTE: for this release only SE_PROBLEM_INSUFF_ACCESS_RIGHTS will be
 *        returned on a security error
 */

#define SECERR_BASE                         ( securityError * DIR_ERROR_BASE )

#define SE_PROBLEM_INAPPROPRIATE_AUTH       ( SECERR_BASE + 1 )
#define SE_PROBLEM_INVALID_CREDENTS         ( SECERR_BASE + 2 )
#define SE_PROBLEM_INSUFF_ACCESS_RIGHTS     ( SECERR_BASE + 3 )
#define SE_PROBLEM_INVALID_SIGNATURE        ( SECERR_BASE + 4 )
#define SE_PROBLEM_PROTECTION_REQUIRED      ( SECERR_BASE + 5 )
#define SE_PROBLEM_NO_INFORMATION           ( SECERR_BASE + 6 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SECERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SECERR;


/* Service errors */

#define SVCERR_BASE                         ( serviceError * DIR_ERROR_BASE )

#define SV_PROBLEM_BUSY                     ( SVCERR_BASE + 1  )
#define SV_PROBLEM_UNAVAILABLE              ( SVCERR_BASE + 2  )
#define SV_PROBLEM_WILL_NOT_PERFORM         ( SVCERR_BASE + 3  )
#define SV_PROBLEM_CHAINING_REQUIRED        ( SVCERR_BASE + 4  )
#define SV_PROBLEM_UNABLE_TO_PROCEED        ( SVCERR_BASE + 5  )
#define SV_PROBLEM_INVALID_REFERENCE        ( SVCERR_BASE + 6  )
#define SV_PROBLEM_TIME_EXCEEDED            ( SVCERR_BASE + 7  )
#define SV_PROBLEM_ADMIN_LIMIT_EXCEEDED     ( SVCERR_BASE + 8  )
#define SV_PROBLEM_LOOP_DETECTED            ( SVCERR_BASE + 9  )
#define SV_PROBLEM_UNAVAIL_EXTENSION        ( SVCERR_BASE + 10 )
#define SV_PROBLEM_OUT_OF_SCOPE             ( SVCERR_BASE + 11 )
#define SV_PROBLEM_DIR_ERROR                ( SVCERR_BASE + 12 )


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct SVCERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} SVCERR;



/* Update errors */

#define UPDERR_BASE                         ( updError * DIR_ERROR_BASE )

#define UP_PROBLEM_NAME_VIOLATION           ( UPDERR_BASE + 1 )
#define UP_PROBLEM_OBJ_CLASS_VIOLATION      ( UPDERR_BASE + 2 )
#define UP_PROBLEM_CANT_ON_NON_LEAF         ( UPDERR_BASE + 3 )
#define UP_PROBLEM_CANT_ON_RDN              ( UPDERR_BASE + 4 )
#define UP_PROBLEM_ENTRY_EXISTS             ( UPDERR_BASE + 5 )
#define UP_PROBLEM_AFFECTS_MULT_DSAS        ( UPDERR_BASE + 6 )
#define UP_PROBLEM_CANT_MOD_OBJ_CLASS       ( UPDERR_BASE + 7 )

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct UPDERR
{
    DWORD      dsid;
    DWORD      extendedErr;    /* Non-standard error code */
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;        /* Problems, valid values defined above */
} UPDERR;


/* problem codes are from errno.h */

/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef struct _SYSERR
{
    DWORD      dsid;
    DWORD      extendedErr;
    DWORD      extendedData;   /* extra data to go with it */
    USHORT     problem;
} SYSERR;


/*

   Most of the error data structures (like the one below) have an on the wire
   data structure version too with a _DRS_WIRE_Vx appended to it, where X is
   the revision.  If this structure is changed, corresponding changes should 
   be made to the WIRE versions, and to the packaging functions 
   draEncodeError() and draDecodeDraErrorDataAndSetThError().
   
*/
typedef union _DIRERR
{
    ATRERR  AtrErr;             /* attribute error */
    NAMERR  NamErr;             /* name error      */
    REFERR  RefErr;             /* referral error  */
    SECERR  SecErr;             /* security error  */
    SVCERR  SvcErr;             /* service error   */
    UPDERR  UpdErr;             /* update error    */
    SYSERR  SysErr;             /* system error    */
} DIRERR;


/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

/* From mdlocal.h */

unsigned AttrTypeToKey(ATTRTYP attrtyp, WCHAR *pOutBuf);
ATTRTYP KeyToAttrTypeLame(WCHAR * pKey, unsigned cc);

unsigned QuoteRDNValue(const WCHAR * pVal,
                       unsigned ccVal,
                       WCHAR * pQuote,
                       unsigned ccQuoteBufMax);

unsigned UnquoteRDNValue(const WCHAR * pQuote,
                         unsigned ccQuote,
                         WCHAR * pVal);

unsigned GetRDN(const WCHAR **ppDN,
                unsigned *pccDN,
                const WCHAR **ppKey,
                unsigned *pccKey,
                const WCHAR **ppVal,
                unsigned *pccVal);

unsigned GetDefaultSecurityDescriptor(
        ATTRTYP classID,
        ULONG   *pLen,
        PSECURITY_DESCRIPTOR *ppSD
        );

DWORD
UserFriendlyNameToDSName (
        WCHAR *pUfn,
        DWORD ccUfn,
        DSNAME **ppDN
        );


// This function trims a Dsname by the given number of avas.
BOOL TrimDSNameBy(
        DSNAME *pDNSrc,
        ULONG cava,
        DSNAME *pDNDst);


// returns info about the RDN in a DSNAME. This is the external version
// of GetRDNInfo to be called outside of ntdsa
unsigned GetRDNInfoExternal(
                    const DSNAME *pDN,
                    WCHAR *pRDNVal,
                    ULONG *pRDNlen,
                    ATTRTYP *pRDNtype);

// Tests if the RDN is indeed mangled. This is the external version to be
// called outside of ntdsa
BOOL IsMangledRDNExternal(
                    WCHAR * pszRDN,  // Pointer to the RDN
                    ULONG   cchRDN,  // Length of the RDN
                    PULONG  pcchUnmangled OPTIONAL); // Offset in the RDN
                                                     // where mangling
                                                     // starts



// Append an RDN to an existing DSNAME.  Return value is 0 on success.
// A non-zero return value is the size, in bytes, that would have been
// required to hold the output name.  A return of -1 indicates that one
// of the input values was bad (most likely the Attid)
unsigned AppendRDN(DSNAME *pDNBase, // Base name to append from
                   DSNAME *pDNNew,  // Buffer to hold results
                   ULONG ulBufSize, // Size of pDNNew buffer, in bytes
                   WCHAR *pRDNVal,  // RDN value to append
                   ULONG RDNlen,    // length of RDN val, in characters
                                    // 0 means NULL terminated string
                   ATTRTYP AttId);  // RDN attribute type

// Determines the count of name parts (i.e., the level),
// returns 0 or error code
unsigned CountNameParts(const DSNAME *pName, unsigned *pCount);

// Reasons for mangling an RDN.
typedef enum {
    MANGLE_OBJECT_RDN_FOR_DELETION = 0,
    MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
    MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT
} MANGLE_FOR;

// Mangle an RDN to avoid name conflicts.  NOTE: pszRDN must be pre-allocated
// to hold at least MAX_RDN_SIZE WCHARs.
DWORD
MangleRDNWithStatus(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    );

// Detect and decode previously mangled RDN. peMangleFor is optional
BOOL
IsMangledRDN(
    IN           WCHAR      *pszRDN,
    IN           DWORD       cchRDN,
    OUT          GUID       *pGuid,
    OUT OPTIONAL MANGLE_FOR *peMangleFor
    );

/* End: From mdlocal.h */

typedef struct _ServerSitePair {
    WCHAR *         wszDnsServer;
    WCHAR *         wszSite;
} SERVERSITEPAIR;

VOID
DsFreeServersAndSitesForNetLogon(
    SERVERSITEPAIR *         paServerSites
    );

NTSTATUS
DsGetServersAndSitesForNetLogon(
    IN   WCHAR *         pNCDNS,
    OUT  SERVERSITEPAIR ** ppaRes
    );

NTSTATUS
CrackSingleName(
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       dwFlags,                // DS_NAME_FLAG mask
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    WCHAR       *pDnsDomain,            // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    WCHAR       *pNameOut,              // buffer for formatted name
    DWORD       *pErr);                 // one of DS_NAME_ERROR in ntdsapi.h

typedef enum
{
    DSCONFIGNAME_DMD = 1,   // Hint: this is the Schema NC.
    DSCONFIGNAME_DSA = 2,
    DSCONFIGNAME_DOMAIN = 3,
    DSCONFIGNAME_CONFIGURATION = 4,
    DSCONFIGNAME_ROOT_DOMAIN = 5,
    DSCONFIGNAME_LDAP_DMD = 6,
    DSCONFIGNAME_PARTITIONS = 7,
    DSCONFIGNAME_DS_SVC_CONFIG = 8,
    DSCONFIGNAMELIST_NCS = 9, // extended command, must use GetConfigurationNamesList().
    DSCONFIGNAME_DOMAIN_CR = 10,
    DSCONFIGNAME_ROOT_DOMAIN_CR = 11
} DSCONFIGNAME;

// The Following are the flags needed to provide the
// GetConfigurationNamesList() more parameters with which to run by.
// The flags differ for each command differ from command to command.

// DSCNL_NCS_ flags have to do with which NCS to get, you will need
// at least one flag from the type of NCs and one from the locality of
// the NCs.

// Note that _NCS_NDNCS does not include Config or Schema NCs, making
// these first 4 flags mututally exclusive sets.  This is more convient
// for getting any list of NCs you want.
#define DSCNL_NCS_DOMAINS         0x00000001
#define DSCNL_NCS_CONFIG          0x00000002
#define DSCNL_NCS_SCHEMA          0x00000004
#define DSCNL_NCS_NDNCS           0x00000008
#define DSCNL_NCS_ALL_NCS         (DSCNL_NCS_DOMAINS | DSCNL_NCS_CONFIG | DSCNL_NCS_SCHEMA | DSCNL_NCS_NDNCS)
// THis flag is the same kind of flag, but not mututally exclusive of the others
#define DSCNL_NCS_ROOT_DOMAIN     0x00000010

// This set of three flags also forms a mututally exclusive set of sets, that
// together form the whole
#define DSCNL_NCS_LOCAL_MASTER    0x00000100
#define DSCNL_NCS_LOCAL_READONLY  0x00000200
#define DSCNL_NCS_REMOTE          0x00000400
#define DSCNL_NCS_ALL_LOCALITIES  (DSCNL_NCS_LOCAL_MASTER | DSCNL_NCS_LOCAL_READONLY | DSCNL_NCS_REMOTE)

NTSTATUS
GetConfigurationNamesList(
    DWORD       which,
    DWORD       dwFlags,
    DWORD *     pcbNames,
    DSNAME **   padsNames);

NTSTATUS
GetDnsRootAlias(
    WCHAR * pDnsRootAlias,
    WCHAR * pRootDnsRootAlias);

NTSTATUS
GetConfigurationName(
    DWORD       which,
    DWORD       *pcbName,
    DSNAME      *pName);

/* From dsatools.h */

void * THAlloc(DWORD size);

void * THReAlloc(void *, DWORD size);

void THFree(void *buff);

// returns TRUE if the two names match (refer to the same object)
extern int
NameMatched(const DSNAME *pDN1, const DSNAME *pDN2);
extern int
NameMatchedStringNameOnly(const DSNAME *pDN1, const DSNAME *pDN2);

// helper function which takes a DSNAME and returns its hashkey
extern DWORD DSNAMEToHashKeyExternal(const DSNAME *pDN);

// helper function which takes a DSNAME and returns its LCMapped version
// this can be used in string comparisons using strcmp
extern CHAR* DSNAMEToMappedStrExternal(const DSNAME *pDN);

// helper function which takes a WCHAR and returns its hashkey
extern DWORD DSStrToHashKeyExternal(const WCHAR *pStr, int cchLen);

// helper function that takes a WCHAR string and returns the LCMapped version
// cchMaxStr is the maximum expected size of the passed in string
extern CHAR * DSStrToMappedStrExternal(const WCHAR *pStr, int cchMaxStr);


/* End: From dsatools.h */

/* New */

// Any change to this enum must be reflected both in the array DsCallerType
// in src\dstrace.c and in the Dump_THSTATE routine in dsexts\md.c
typedef enum _CALLERTYPE {
    CALLERTYPE_NONE = 0,
    CALLERTYPE_SAM,
    CALLERTYPE_DRA,
    CALLERTYPE_LDAP,
    CALLERTYPE_LSA,
    CALLERTYPE_KCC,
    CALLERTYPE_NSPI,
    CALLERTYPE_INTERNAL,
    CALLERTYPE_NTDSAPI
} CALLERTYPE;

#define IsCallerTypeValid( x )  ( ( ( x ) >= CALLERTYPE_SAM ) && ( ( x ) <= CALLERTYPE_NTDSAPI ) )

ULONG THCreate(DWORD);     /* returns 0 on success */
ULONG THDestroy(void);          /* returns 0 on success */
BOOL  THQuery(void);            /* returns 1 if THSTATE exists, 0 if not */
PVOID THSave();
VOID THRestore(PVOID);
VOID THClearErrors();
VOID THRefresh();

// Returns error string associated with THSTATE error; free with THFree().
LPSTR THGetErrorString();

BOOL THVerifyCount(unsigned count);  /* Returns TRUE if thread has exactly   */
                                     /* count thread states, FALSE if not.   */
                                     /* Only works if thread state mapping   */
                                     /* is enabled (chk or under debug),     */
                                     /* returns TRUE if disabled.            */

// obsolete; use THClearErrors() instead
#define SampClearErrors THClearErrors

VOID
SampSetDsa(
   BOOLEAN DsaFlag);

VOID
SampSetLsa(
   BOOLEAN DsaFlag);

/*++

    This routine gets the requested property of the class schema object, for the
    Class specified in ClassId.
Parameters:
    ClassId  The ClassId of the class that we are interseted in
    AttributeId The attribute of the class schema object that we want
    attLen    The length of the attribute value is present in here .
              Caller allocates the buffer in pAttVal and passes its length
              in attLen. If the buffer required is less than the buffer supplied
              then the data is returned in pattVal. Else  the required size is
              returned in attLen.
    pattVal      The value of the attribute is returned in here.

    Security Descriptors returned by this routine are always in a format that
    can be used by the RTL routines.
Return Values:
    STATUS_SUCCESS
    STATUS_NOT_FOUND
    STATUS_BUFFER_TOO_SMALL
--*/
extern
NTSTATUS
SampGetClassAttribute(
     IN     ULONG    ClassId,
     IN     ULONG    Attribute,
     OUT    PULONG   attLen,
     OUT    PVOID    pattVal
     );


/* End: New */

/*************************************************************************
    MINI-DIRECTORY API - MINI-DIRECTORY API - MINI-DIRECTORY API
*************************************************************************/


// All the Dir APIs requires a valid thread state and are atomic.
// I.e. They implicitly begin/end a transaction.  Some in-process
// clients like the LSA wish to perform multi-object transactions,
// AND PLEDGE TO KEEP TRANSACTIONS SHORT!!!  The following defines
// and routines can be used to perform multi-object transactions.
// DirTransactControl() must be called with a valid thread state.
// By default, a thread's transaction control is TRANSACT_BEGIN_END.
// A transaction is ended on error.  It must explicitly be ended via a
// TRANSACT_BEGIN_END or TRANSACT_DONT_BEGIN_END transaction state

typedef enum DirTransactionOption
{
    TRANSACT_BEGIN_END              = 0,
    TRANSACT_DONT_BEGIN_END         = 1,
    TRANSACT_BEGIN_DONT_END         = 2,
    TRANSACT_DONT_BEGIN_DONT_END    = 3
} DirTransactionOption;

VOID
DirTransactControl(
    DirTransactionOption    option);

/*
 * There are some controls that we need to send directly to a DSA that
 * have no correlation to any directory object.  For example, we might
 * need to tell a DSA to recals its hierarchy table, or force it to run
 * garbage collection now, or initiate some FSMO request.  These operation
 * controls are bundled together in this API.  Some operation controls take
 * values as arguments, those are passed through the sized buffer.
 */
typedef enum _OpType {
    OP_CTRL_INVALID = 0,
    OP_CTRL_RID_ALLOC = 1,
    OP_CTRL_BECOME_RID_MASTER = 2,
    OP_CTRL_BECOME_SCHEMA_MASTER = 3,
    OP_CTRL_GARB_COLLECT = 4,
    OP_CTRL_RECALC_HIER = 5,
    OP_CTRL_REPL_TEST_HOOK = 6,
    OP_CTRL_BECOME_DOM_MASTER = 7,
//    OP_CTRL_DECLARE_QUIESCENCE = 8,
    OP_CTRL_SCHEMA_UPDATE_NOW = 9,
    OP_CTRL_BECOME_PDC = 10,
    OP_CTRL_FIXUP_INHERITANCE = 11,
    OP_CTRL_FSMO_GIVEAWAY = 12,
    OP_CTRL_INVALIDATE_RID_POOL = 13,
    OP_CTRL_DUMP_DATABASE = 14,
    OP_CTRL_CHECK_PHANTOMS = 15,
    OP_CTRL_BECOME_INFRASTRUCTURE_MASTER = 16,
    OP_CTRL_BECOME_PDC_WITH_CHECKPOINT = 17,
    OP_CTRL_UPDATE_CACHED_MEMBERSHIPS = 18,
    OP_CTRL_ENABLE_LVR = 19,
    OP_CTRL_LINK_CLEANUP = 20,
    OP_CTRL_SCHEMA_UPGRADE_IN_PROGRESS = 21,
    OP_CTRL_DYNAMIC_OBJECT_CONTROL = 22,
    // Following for test purposes in debug builds only.

#ifdef INCLUDE_UNIT_TESTS
    OP_CTRL_REFCOUNT_TEST = 10000,
    OP_CTRL_TAKE_CHECKPOINT=10001,
    OP_CTRL_ROLE_TRANSFER_STRESS=10002,
    OP_CTRL_ANCESTORS_TEST=10003,
    OP_CTRL_BHCACHE_TEST=10004,
    OP_SC_CACHE_CONSISTENCY_TEST=10005,
    OP_CTRL_PHANTOMIZE=10006,
    OP_CTRL_REMOVE_OBJECT = 10007,
    OP_CTRL_GENERIC_CONTROL = 10008,
    OP_CTRL_PROTECT_OBJECT = 10009,
#endif
#ifdef DBG
    OP_CTRL_EXECUTE_SCRIPT = 10010,
#endif
} OpType;

typedef struct _OPARG {
    OpType     eOp;
    char      *pBuf;            /* optional value */
    ULONG      cbBuf;           /* size of value buffer */
} OPARG;

typedef struct _OPRES {
    COMMRES    CommRes;
    ULONG      ulExtendedRet;
} OPRES;

typedef struct _FSMO_GIVEAWAY_DATA_V1 {

    ULONG Flags;

    ULONG NameLen;
    WCHAR StringName[1];  // variable sized array

} FSMO_GIVEAWAY_DATA_V1, *PFSMO_GIVEAWAY_DATA_V1;

typedef struct _FSMO_GIVEAWAY_DATA_V2 {

    ULONG Flags;

    ULONG NameLen;          // length of DSA DN, excluding null terminator
                            //   (which is required); may be 0

    ULONG NCLen;            // length of NC DN, excluding null terminator
                            //   (which is required); may be 0

    WCHAR Strings[1];       // variable sized array; DSA DN (or '\0' if none)
                            // followed by NC DN (or '\0' if none)

} FSMO_GIVEAWAY_DATA_V2, *PFSMO_GIVEAWAY_DATA_V2;

typedef struct _FSMO_GIVEAWAY_DATA {

    DWORD Version;
    union {
        FSMO_GIVEAWAY_DATA_V1 V1;
        FSMO_GIVEAWAY_DATA_V2 V2;
    };

} FSMO_GIVEAWAY_DATA, *PFSMO_GIVEAWAY_DATA;


//
// Flags for FSMO_GIVEAWAY_DATA_V1
//
#define FSMO_GIVEAWAY_DOMAIN       0x01
#define FSMO_GIVEAWAY_ENTERPRISE   0x02
#define FSMO_GIVEAWAY_NONDOMAIN    0x04


ULONG
DirOperationControl(
                    OPARG   * pOpArg,
                    OPRES  ** ppOpRes
);

/*++
  DirBind
--*/

typedef struct _BINDARG {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The user name
                             */
} BINDARG;


/* The output data structs carries a little more info */

typedef struct _BINDRES {
    OCTET       Versions;   /*  The client version on BINDARG
                             *  (defaults to "v1988" if not provided,
                             *  i.e. if <Versions.pVal> == NULL or
                             *  <Versions.len> == 0).
                             *  The DSA supported Versions on BINDRES.
                             */
    PDSNAME     pCredents;  /*  The DSA name.
                             */
    COMMRES     CommRes;
} BINDRES;

ULONG
DirBind (
    BINDARG               * pBindArg,    /* binding credentials            */
    BINDRES              ** ppBindRes    /* binding results                */
);

/*++
  DirUnBind - currently a placeholder
--*/
ULONG DirUnBind
(
    void
);


/*++
  DirRead
--*/
// These structures holds information about range limits for values on
// attributes in a search.
typedef struct _RANGEINFOITEM {
    ATTRTYP   AttId;
    DWORD     lower;
    DWORD     upper;
} RANGEINFOITEM;

typedef struct _RANGESEL {
    DWORD valueLimit;
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINFSEL;

typedef struct _RANGEINF {
    DWORD count;
    RANGEINFOITEM *pRanges;
} RANGEINF;

typedef struct _RANGEINFLIST {
    struct _RANGEINFLIST *pNext;
    RANGEINF              RangeInf;
} RANGEINFLIST;

typedef struct _READARG
{
    DSNAME        * pObject;    /* object name                           */
    ENTINFSEL FAR * pSel;       /* entry information selection           */
                                /* (null means read all atts and values) */
    RANGEINFSEL   * pSelRange;  /* range information (i.e. max number of */
                                /* values or subrange of values to read  */
                                /* for a given attribute) null = all     */

    COMMARG         CommArg;    /* common arguments                      */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} READARG;

typedef struct _READRES
{
    ENTINF  entry;               /* entry information                    */
    RANGEINF range;
    COMMRES     CommRes;
} READRES;


ULONG
DirRead (
    READARG FAR   * pReadArg,       /* Read argument                        */
    READRES      ** ppReadRes
);


/*++
  DirCompare
--*/

typedef struct _COMPAREARG
{
    PDSNAME     pObject;        /* object name                             */
    AVA         Assertion;      /*  The specified attribute to match       */
    COMMARG     CommArg;        /*  common arguments                       */
    struct _RESOBJ * pResObj;   /* for internal caching use, leave null */
} COMPAREARG;

typedef struct _COMPARERES
{
    PDSNAME     pObject;        /* Name provided if an alias was
                                 *  dereferrenced.
                                 */
    BOOL        fromMaster;     /* TRUE if the object is from the master   */
    BOOL        matched;        /* True if the match was successful        */
    COMMRES     CommRes;
} COMPARERES;

ULONG
DirCompare(
    COMPAREARG        * pCompareArg, /* Compare argument                   */
    COMPARERES       ** ppCompareRes
);



/*++
  DirList

    This API is used to list the object names of objects that are directly
    subordinate to the given object.

    If the list is incomplete, the PARTIALOUTCOME structure is returned.
    This structure indicates the reason for the failure and a set of DSA's
    to contact to complete the operation.  For this release, this will
    only occur when more selected data exists in this DSA than can be
    returned.  In this case the CONTREF will point back into the same
    DSA.  PARTIALOUTCOME is used as follows:

    If the pPartialOutcomeQualifier is NULL the query is complete.
    If the pointer is not NULL there is more data available.  More data
    can be retrieved by repeating the operation with the same input
    arguments except that the nameRes field of the CommArg structure is
    set to OP_NAMERES_COMPLETE.  Setting this field indicates to the DSA
    that the operation is continuing.  This continued call must use the
    same handle as the original call and must be the next operation
    made with this handle.  Subsequent continuing calls may be applied
    until all data are returned.
--*/

typedef struct _LISTARG
{
    PDSNAME     pObject;            /* object name (base of search)        */
    COMMARG     CommArg;            /* common arguments                    */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */
} LISTARG;


typedef struct _CHILDLIST
{
    struct _CHILDLIST    * pNextChild;  /* linked-list to next info entry  */
    RDN FAR              * pChildName;  /* information about this entry    */
    BOOL                   aliasEntry;  /* If true the child is an alias   */
    BOOL                   fromMaster;  /* True if master object           */
} CHILDLIST;

#define PA_PROBLEM_TIME_LIMIT       'T'
#define PA_PROBLEM_SIZE_LIMIT       'S'
#define PA_PROBLEM_ADMIN_LIMIT      'A'

typedef struct _PARTIALOUTCOME
{
    UCHAR   problem;        /*  the reason for incomplete output
                             *   Valid values:
                             *     - PA_PROBLEM_TIME_LIMIT
                             *     - PA_PROBLEM_SIZE_LIMIT
                             *     - PA_PROBLEM_ADMIN_LIMIT
                             */
    UCHAR   unusedPad;
    USHORT  count;            /* count of unexplored DSAs */
    CONTREF *pUnexploredDSAs; /* Other DSA's to visit     */
} PARTIALOUTCOME;


typedef struct _LISTRES
{
    PDSNAME              pBase;          /* Name provided if an alias was
                                          *  dereferrenced.
                                          */
    ULONG                count;          /* number of output entries       */
    CHILDLIST            Firstchild;     /* linked-list of output entries  */

    PARTIALOUTCOME     * pPartialOutcomeQualifier;  /* incomplete operation*/

    PAGED_RESULT    PagedResult;         /* Paged Results local extension  */
    COMMRES              CommRes;
} LISTRES;


ULONG
DirList(
    LISTARG FAR   * pListArg,
    LISTRES      ** ppListRes

);



/*++
  DirSearch
--*/

#define SE_CHOICE_BASE_ONLY                 0
#define SE_CHOICE_IMMED_CHLDRN              1
#define SE_CHOICE_WHOLE_SUBTREE             2


typedef struct _SEARCHARG
{
    PDSNAME     pObject;        /* object name (base of search)              */
    UCHAR       choice;         /* depth of search:
                                 *  Valid values:
                                 *    - SE_CHOICE_BASE_ONLY
                                 *    - SE_CHOICE_IMMED_CHLDRN
                                 *    - SE_CHOICE_BASE_AND_SUBTREE
                                 */
    BOOL        bOneNC;         /* Are results constrained to same NC
                                 * as pObject
                                 */
    PFILTER     pFilter;        /* filter information
                                 *  (NULL if all objects selected)
                                 */
    BOOL        searchAliases;  /* If true, aliases are dereferenced for
                                 *  subtree elements.
                                 *  NOTE: ALWAYS Set to FALSE for this release.
                                 */
    ENTINFSEL * pSelection;     /* entry information selection
                                 *  (null means read all atts and values)
                                 */
    RANGEINFSEL *pSelectionRange;/* range information (i.e. max number of values
                                 * or subrange of values to read for a given
                                 * attribute
                                 */

    BOOL        fPutResultsInSortedTable:1;
                                 /* If set, leave the results in a
                                    temporary sorted Table and don't
                                    return a ENTINFLIST.
                                    The attribute to sort on is specified
                                    in CommArg.SortAttr
                                 */

    COMMARG     CommArg;        /* common arguments                          */
    struct _RESOBJ *pResObj;   /* for internal caching use, leave null */

} SEARCHARG;

typedef struct _SEARCHRES
{
    BOOL        baseProvided;       /* indicates if the base object name
                                     * is provided.  (Only provided when
                                     * an alias has been dereferenced
                                     */
    BOOL        bSorted;            /* indicates that these results have
                                     * been sorted based on the sort
                                     * attribute specified in the commarg
                                     * in the SEARCHARG
                                     */
    PDSNAME     pBase;              /* base object of subtree                */
    ULONG       count;              /* number of output entries              */
    ENTINFLIST  FirstEntInf;        /* linked-list of output entries         */
    RANGEINFLIST FirstRangeInf;     /* linked-list of output range info      */

    PARTIALOUTCOME *pPartialOutcomeQualifier;  /* Defined in DirList     */
                                    /* Indicates incomplete operation        */

    COMMRES       CommRes;          /* Common Results                        */
    PAGED_RESULT  PagedResult;      /* Paged Results extension related       */
    VLV_REQUEST   VLVRequest;       /* VLV Request extension related         */
    ASQ_REQUEST   ASQRequest;       /* ASQ Request extension related         */

    DWORD         SortResultCode;   /* Result code for sorting               */

} SEARCHRES;


ULONG
DirSearch (
    SEARCHARG     * pSearchArg,
    SEARCHRES    ** ppSearchRes
);

typedef BOOL (*PF_PFI)(DWORD hClient, DWORD hServer, void ** ppImpersonateData);
typedef void (*PF_TD)(DWORD hClient, DWORD hServer, ENTINF *pEntInf);
typedef void (*PF_SI)(DWORD hClient, DWORD hServer, void * pImpersonateData);

typedef struct _NOTIFYARG {
    PF_PFI pfPrepareForImpersonate;
    PF_TD  pfTransmitData;
    PF_SI  pfStopImpersonating;
    DWORD  hClient;
} NOTIFYARG;

typedef struct _NOTIFYRES {
    COMMRES     CommRes;
    DWORD       hServer;
} NOTIFYRES;


ULONG
DirNotifyRegister(
                  SEARCHARG *pSearchArg,
                  NOTIFYARG *pNotifyArg,
                  NOTIFYRES **ppNotifyRes
);

ULONG
DirNotifyUnRegister(
                    DWORD hServer,
                    NOTIFYRES **pNotifyRes
);

BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        );

VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        );


/*++
  DirAddEntry
--*/



typedef struct _ADDARG
{
    PDSNAME     pObject;                /* target object name                */
    ATTRBLOCK   AttrBlock;              /* The block of attributes to add    */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge  */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)       */
    COMMARG     CommArg;                /* common input arguments            */
    struct _RESOBJ * pResParent;        /* for internal caching use, leave null */
    struct _CREATENCINFO * pCreateNC;   /* for internal caching use, leave null */
    struct _ADDCROSSREFINFO * pCRInfo;  /* for internal caching use. leave null */

} ADDARG;


/* No result is returned on successful completion of the operation.          */
typedef struct _ADDRES
{
    COMMRES     CommRes;
} ADDRES;

ULONG DirAddEntry
(
    ADDARG        * pAddArg,        /* add argument                          */
    ADDRES       ** ppAddRes
);



/*++
  DirRemoveEntry

    This API is used to delete a directory leaf object.  Non-leaves
    cannot be removed (unless one first removes all of the object's
    children, which, in effect, makes the object itself a leaf).

--*/

typedef struct _REMOVEARG
{
    PDSNAME     pObject;              /* target object name                 */
    BOOL        fPreserveRDN;         /* don't mangle the tombstone RDN     */
    BOOL        fGarbCollectASAP;     /* set deletion time such that the    */
                                      /*   object will be picked up by the  */
                                      /*   next garbage collection and      */
                                      /*   physically deleted               */
    BOOL        fTreeDelete;          /* Try to delete the object and all   */
                                      /* children.  USE SPARINGLY!!!!       */
    BOOL        fDontDelCriticalObj;  /* If set, objects mark critical will */
                                      /* cause the delete to fail.  Used    */
                                      /* with tree delete to avoid disaster */
    PROPERTY_META_DATA_VECTOR *       /* Remote meta data vector to merge   */
                pMetaDataVecRemote;   /*   (should be NULL if !fDRA)        */
    COMMARG     CommArg;              /* common input arguments             */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} REMOVEARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _REMOVERES
{
    COMMRES     CommRes;
} REMOVERES;

ULONG DirRemoveEntry
(
    REMOVEARG  * pRemoveArg,
    REMOVERES ** ppRemoveRes
);



/*++
  DirModifyEntry
--*/

#define AT_CHOICE_ADD_ATT           'A'
#define AT_CHOICE_REMOVE_ATT        'R'
#define AT_CHOICE_ADD_VALUES        'a'
#define AT_CHOICE_REMOVE_VALUES     'r'
#define AT_CHOICE_REPLACE_ATT       'C'

typedef struct _ATTRMODLIST
{
    struct _ATTRMODLIST * pNextMod;     /* linked-list to next att mod      */

    USHORT      choice;                 /* modification type:
                                         *  Valid values:
                                         *    - AT_CHOICE_ADD_ATT
                                         *    - AT_CHOICE_REMOVE_ATT
                                         *    - AT_CHOICE_ADD_VALUES
                                         *    - AT_CHOICE_REMOVE_VALUES
                                         *    - AT_CHOICE_REPLACE_ATT
                                         */
    ATTR AttrInf;                       /* information about the attribute  */
} ATTRMODLIST;


typedef struct _MODIFYARG
{
    PDSNAME     pObject;                /* target object name               */
    USHORT      count;                  /* num of link modifications        */
    ATTRMODLIST FirstMod;               /* linked-list of attr mods         */
    PROPERTY_META_DATA_VECTOR *         /* Remote meta data vector to merge */
                pMetaDataVecRemote;     /*   (should be NULL if !fDRA)      */
    COMMARG     CommArg;                /* common input arguments           */
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
} MODIFYARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYRES
{
    COMMRES     CommRes;
} MODIFYRES;

ULONG DirModifyEntry
(
    MODIFYARG  * pModifyArg,
    MODIFYRES ** ppModifyRes
);



/*++
  DirModifyDN

  Rename and object and/or change it's parent.

--*/

typedef struct _MODIFYDNARG
{
    PDSNAME     pObject;                 /* target object name              */
    PDSNAME     pNewParent;              /* name of new parent              */
    ATTR        *pNewRDN;                /* new rdn                         */
    PROPERTY_META_DATA_VECTOR *          /* Remote meta data vector to merge*/
                pMetaDataVecRemote;      /*   (should be NULL if !fDRA)     */
    COMMARG     CommArg;                 /* common input arguments          */
    PWCHAR      pDSAName;                /* destination DSA, cross DSA move */
    DWORD       fAllowPhantomParent;     // whether we allow the parent to be a phantom
                                         // useful if moving object under phantoms
    struct _RESOBJ *pResObj;       /* for internal caching use, leave null */
    struct _RESOBJ * pResParent;    /* for internal caching use, leave null */
} MODIFYDNARG;

/* No result is returned on successful completion of the operation.         */
typedef struct _MODIFYDNRES
{
    COMMRES     CommRes;
} MODIFYDNRES;

ULONG DirModifyDN
(
    MODIFYDNARG    * pModifyDNArg,
    MODIFYDNRES   ** ppModifyDNRes
);


/*++

  DirFind

  A light weight Search, that searches on a unique indexed attribute

--*/
typedef struct _FINDARG {
    ULONG       hDomain;
    ATTRTYP     AttId;
    ATTRVAL     AttrVal;
    COMMARG     CommArg;
    BOOL        fShortNames;
} FINDARG;

typedef struct _FINDRES {
    DSNAME     *pObject;
    COMMRES     CommRes;
} FINDRES;


DWORD DirGetDomainHandle(DSNAME *pDomainDN);

ULONG DirFindEntry
(
    FINDARG    *pFindArg,
    FINDRES    ** ppFindRes
);


/*++
  UpdateDSPerfStats

  Update performance counters held by NTDSA.DLL

  Note that the DSSTAT_ constants map directly to perf block offsets defined
  in the NTDSCTR.H file.  This is done so that UpdateDSPerfStats() can
  operate more efficiently (avoiding a large switch{} statement).

--*/

#define FLAG_COUNTER_INCREMENT  0x00000001
#define FLAG_COUNTER_DECREMENT  0x00000002
#define FLAG_COUNTER_SET        0x00000003

enum DSSTAT_TYPE
{
    DSSTAT_CREATEMACHINETRIES = 0,
    DSSTAT_CREATEMACHINESUCCESSFUL,
    DSSTAT_CREATEUSERTRIES,
    DSSTAT_CREATEUSERSUCCESSFUL,
    DSSTAT_PASSWORDCHANGES,
    DSSTAT_MEMBERSHIPCHANGES,
    DSSTAT_QUERYDISPLAYS,
    DSSTAT_ENUMERATIONS,
    DSSTAT_ASREQUESTS,
    DSSTAT_TGSREQUESTS,
    DSSTAT_KERBEROSLOGONS,
    DSSTAT_MSVLOGONS,
    DSSTAT_ATQTHREADSTOTAL,
    DSSTAT_ATQTHREADSLDAP,
    DSSTAT_ATQTHREADSOTHER,
    DSSTAT_UNKNOWN,             // always last item
};

// Count of exposed counters with UpdateDSPerfStats()

#define DSSTAT_COUNT            DSSTAT_UNKNOWN

VOID
UpdateDSPerfStats(
    IN DWORD        dwStat,
    IN DWORD        dwOperation,
    IN DWORD        dwChange
);

#define DSINIT_SAMLOOP_BACK      ((ULONG)(1<<0))
#define DSINIT_FIRSTTIME         ((ULONG)(1<<1))

typedef struct _DS_INSTALL_PARAM 
{
    PVOID BootKey;
    DWORD cbBootKey;
    BOOL  fPreferGcInstall;
    DWORD ReplicationEpoch;

    // The sam account name of the local computer
    LPWSTR AccountName;

    // The token of the caller requesting the install
    HANDLE ClientToken;
    
} DS_INSTALL_PARAM,*PDS_INSTALL_PARAM;

#define DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED  ((ULONG)(1<<0))

typedef struct _DS_INSTALL_RESULT
{
    DWORD ResultFlags;

    // Flags from the NTDS_INSTALL_* space to indicate
    // what operations have been completed and not undo
    // during initialization.
    ULONG InstallOperationsDone;

} DS_INSTALL_RESULT,*PDS_INSTALL_RESULT;

NTSTATUS
DsInitialize(
    ULONG Flags,
    IN  PDS_INSTALL_PARAM   InParams  OPTIONAL,
    OUT PDS_INSTALL_RESULT  OutParams OPTIONAL
    );

NTSTATUS
DsUninitialize(
    BOOL fExternalOnly
    );

VOID
DsaDisableUpdates(
    VOID
    );

VOID
DsaEnableUpdates(
    VOID
    );


#define NTDS_INSTALL_SERVER_CREATED 0x00000001
#define NTDS_INSTALL_DOMAIN_CREATED 0x00000002
#define NTDS_INSTALL_SERVER_MORPHED 0x00000004

typedef DWORD (*DSA_CALLBACK_STATUS_TYPE)( IN LPWSTR wczStatus );
typedef DWORD (*DSA_CALLBACK_ERROR_TYPE)(  IN PWSTR  Status,
                                           IN DWORD  WinError );
typedef DWORD (*DSA_CALLBACK_CANCEL_TYPE) ( BOOLEAN fCancelOk );
  
VOID
DsaSetInstallCallback(
    IN DSA_CALLBACK_STATUS_TYPE        pfnUpdateStatus,
    IN DSA_CALLBACK_ERROR_TYPE         pfnErrorStatus,
    IN DSA_CALLBACK_CANCEL_TYPE        pfnCancelOperation,
    IN HANDLE                          ClientToken
    );

NTSTATUS
DirErrorToNtStatus(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

DWORD
DirErrorToWinError(
    IN  DWORD    DirError,
    IN  COMMRES *CommonResult
    );

ULONG
DirProtectEntry(IN DSNAME *pObj);

LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    );

MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    );

LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    );

extern
LPCWSTR
MapSpnServiceClass(WCHAR *);

extern
NTSTATUS
MatchCrossRefBySid(
   IN PSID           SidToMatch,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchCrossRefByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       XrefDsName OPTIONAL,
   IN OUT PULONG     XrefNameLen
   );

extern
NTSTATUS
MatchDomainDnByNetbiosName(
   IN LPWSTR         NetbiosName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

extern
NTSTATUS
FindNetbiosDomainName(
   IN DSNAME*        DomainDsName,
   OUT LPWSTR        NetbiosName OPTIONAL,
   IN OUT PULONG     NetbiosNameLen
   );

DSNAME *
DsGetDefaultObjCategory(
    IN  ATTRTYP objClass
    );


BOOL
DsCheckConstraint(
        IN ATTRTYP  attID,
        IN ATTRVAL *pAttVal,
        IN BOOL     fVerifyAsRDN
        );

BOOL
IsStringGuid(
    WCHAR       *pwszGuid,
    GUID        *pGuid
    );

#endif // MIDL_PASS not defined

#undef SIZE_IS
#undef SWITCH_IS
#undef CASE

#endif // _ntdsa_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdsbsrv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdsbsrv.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module proto-types the interface for the NT Directory Service
    Backup Server APIs. The proto-types would be called by the process
    that hosts the backup/restore server interface.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:
    
    Created		03/19/97    rsraghav

--*/

#ifndef _NTDSBSRV_H_
#define _NTDSBSRV_H_

typedef	DWORD ERR;

#ifndef	NTDSBSRV_BUILD
#define	NTDSBSRV_API	__declspec(dllimport) _stdcall
#else
#define	NTDSBSRV_API
#endif

#ifdef __cplusplus
extern "C" {
#endif 

#define	BACKUP_WITH_UUID

// HRESULT should be defined if the user included ntdef.h or winnt.h or wtypes.h
// Define it anyways just in case it is not defined yet
#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
    typedef LONG HRESULT;
#endif // _HRESULT_DEFINED

typedef DWORD ERR;

/*************************************************************************************
Proto-Types: 
    
      Server side DLL is loaded dynamically. The functions exported by the DLL are
      typedef'ed below to aid dynamic loading of the server DLL.

**************************************************************************************/

HRESULT
NTDSBSRV_API
HrBackupRegister(
    );

HRESULT
NTDSBSRV_API
HrBackupUnregister(
    );

ERR
NTDSBSRV_API
ErrRestoreRegister(
	);

ERR
NTDSBSRV_API
ErrRestoreUnregister(
	);

ERR
NTDSBSRV_API
ErrRecoverAfterRestoreW(
	WCHAR * szParametersRoot,
	WCHAR * wszAnnotation,
        BOOL fInSafeMode
	);
typedef ERR (*ERR_RECOVER_AFTER_RESTORE_W)(WCHAR *, WCHAR *, BOOL);

ERR
NTDSBSRV_API
ErrRecoverAfterRestoreA(
	char * szParametersRoot,
	char * szAnnotation,
        BOOL fInSafeMode
	);
typedef ERR (*ERR_RECOVER_AFTER_RESTORE_A)(CHAR *, CHAR *, BOOL);

#define NEW_INVOCID_CREATE_IF_NONE  (0x1)
#define NEW_INVOCID_DELETE          (0x2)
#define NEW_INVOCID_SAVE            (0x4)
ERR
NTDSBSRV_API
ErrGetNewInvocationId(
    IN      DWORD   dwFlags,
    OUT     GUID *  NewId
    );
typedef ERR (*ERR_GET_NEW_INVOCATION_ID)(DWORD, GUID*);

DWORD
ErrGetBackupUsnFromDatabase(
    IN  JET_DBID      dbid,
    IN  JET_SESID     hiddensesid,
    IN  JET_TABLEID   hiddentblid,
    IN  JET_SESID     datasesid,
    IN  JET_TABLEID   datatblid_arg,
    IN  JET_COLUMNID  usncolid,
    IN  JET_TABLEID   linktblid_arg,
    IN  JET_COLUMNID  linkusncolid,
    IN  BOOL          fDelete,
    OUT USN *         pusnAtBackup
    );
typedef ERR (*ERR_GET_BACKUP_USN_FROM_DATABASE)(
    JET_DBID, JET_SESID, JET_TABLEID, JET_SESID, JET_TABLEID, JET_COLUMNID,
    JET_TABLEID, JET_COLUMNID, BOOL, USN *);

typedef HRESULT FN_HrBackupRegister();
typedef HRESULT FN_HrBackupUnregister();

typedef ERR     FN_ErrRestoreRegister();
typedef ERR     FN_ErrRestoreUnregister();

typedef void    FN_SetNTDSOnlineStatus(BOOL fBootedOffNTDS);


#define BACKUP_REGISTER_FN              "HrBackupRegister"
#define BACKUP_UNREGISTER_FN            "HrBackupUnregister"
#define RESTORE_REGISTER_FN             "ErrRestoreRegister"
#define RESTORE_UNREGISTER_FN           "ErrRestoreUnregister"
#define SET_NTDS_ONLINE_STATUS_FN       "SetNTDSOnlineStatus"
#define GET_NEW_INVOCATION_ID_FN        "ErrGetNewInvocationId"
#define GET_BACKUP_USN_FROM_DATABASE_FN "ErrGetBackupUsnFromDatabase"
#define ERR_RECOVER_AFTER_RESTORE_A_FN  "ErrRecoverAfterRestoreA"
#define ERR_RECOVER_AFTER_RESTORE_W_FN  "ErrRecoverAfterRestoreW"

#define NTDSBACKUPDLL_A "ntdsbsrv"
#define NTDSBACKUPDLL_W L"ntdsbsrv"

#ifdef	UNICODE
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreW
#define ERR_RECOVER_AFTER_RESTORE_FN ERR_RECOVER_AFTER_RESTORE_W_FN
#define ERR_RECOVER_AFTER_RESTORE ERR_RECOVER_AFTER_RESTORE_W
#define NTDSBACKUPDLL NTDSBACKUPDLL_W
#else
#define	ErrRecoverAfterRestore ErrRecoverAfterRestoreA
#define ERR_RECOVER_AFTER_RESTORE_FN ERR_RECOVER_AFTER_RESTORE_A_FN
#define ERR_RECOVER_AFTER_RESTORE ERR_RECOVER_AFTER_RESTORE_A
#define NTDSBACKUPDLL NTDSBACKUPDLL_A
#endif


#ifdef __cplusplus
}
#endif 

#endif // _NTDSBSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdsetup.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ntdsetup.h

Abstract:

    Contains entry point declarations for ntdsetup.dll

Author:

    ColinBr  29-Sept-1996

Environment:

    User Mode - NT

Revision History:

    ColinBr 4-Jan-1997
        Added NTDSInstallReplica

    ColinBr 25-Jan-1997
        Added general purposes install primitive api with new
        helper functions

    ColinBr 03-September-1997
        Added NtdsISetReplicaMachineAccount

    ColinBr 09-Jan-1998
        Added demote support and cleanup


--*/

#ifndef _NTDSETUP_H_
#define _NTDSETUP_H_

//
// This typedef is used so functions in the dll can update the 
// OperationResultsFlag
//                                                                      
typedef DWORD (*CALLBACK_OPERATION_RESULT_FLAGS_TYPE)(IN DWORD Flags);

//
// This typedef is used so functions in the dll can give status
// updates since some of them take several minutes and perform
// many operations
//
typedef DWORD (*CALLBACK_STATUS_TYPE)( IN LPWSTR wczStatus );

//
// This typedef is used so function is ntdsetup.dll can give
// a detailed string giving the context of a particular error
//
typedef DWORD (*CALLBACK_ERROR_TYPE)( IN PWSTR String,  
                                      IN DWORD ErrorCode );


//
// Valid flags for NTDS_INSTALL_INFO
//
#define NTDS_INSTALL_ENTERPRISE         0x00000001
#define NTDS_INSTALL_DOMAIN             0x00000002
#define NTDS_INSTALL_REPLICA            0x00000004

// These cause the the existing dc's or domain's in the
// enterprise to be removed from the ds before
// installing the directory service.    
#define NTDS_INSTALL_DC_REINSTALL       0x00000008
#define NTDS_INSTALL_DOMAIN_REINSTALL   0x00000010

// This tells us to use hives that we saved off
#define NTDS_INSTALL_UPGRADE            0x00000020

// This tells NtdsInstall when creating a first dc in domain
// create a new domain, not migrate the exist server accounts
#define NTDS_INSTALL_FRESH_DOMAIN       0x00000040

// This indicates that the new domain is a new tree
#define NTDS_INSTALL_NEW_TREE           0x00000080

// This indicates to allow anonymous access
#define NTDS_INSTALL_ALLOW_ANONYMOUS    0x00000100

// This indicates to set the ds repair password to the
// current admin's password
#define NTDS_INSTALL_DFLT_REPAIR_PWD    0x00000200


// This indicates to set the behavior version of the forest
// to the most current version.  Valid only for new forest installs.
#define NTDS_INSTALL_SET_FOREST_CURRENT 0x00000400

//
// Flags for NtdsDemote
//
#define NTDS_LAST_DC_IN_DOMAIN           0x00000001
#define NTDS_LAST_DOMAIN_IN_ENTERPRISE   0x00000002
#define NTDS_DONT_DELETE_DOMAIN          0x00000004 
//
// Flags for NtdsInstallReplicaFULL
//
#define NTDS_IFM_PROMOTION               0x00000001

typedef struct {

    // Describes the kind of install requested
    DWORD   Flags;

    // Location of restored database
    LPWSTR  RestorePath;

    // Location of database files
    LPWSTR  DitPath;
    LPWSTR  LogPath;
    LPWSTR  SysVolPath;

    PVOID  BootKey;
    DWORD  cbBootKey;

    // Ds location of server object
    LPWSTR  SiteName;   OPTIONAL

    // The name of the domain to join or create
    LPWSTR  DnsDomainName;
    LPWSTR  FlatDomainName;

    // The name of the tree to join
    LPWSTR  DnsTreeRoot;

    // This is required for replica or domain install
    LPWSTR  ReplServerName;

    // Credentials for replication
    SEC_WINNT_AUTH_IDENTITY *Credentials;   OPTIONAL

    // Status function
    CALLBACK_STATUS_TYPE pfnUpdateStatus;   OPTIONAL

    // New admin password
    LPWSTR AdminPassword;

    // Error function
    CALLBACK_ERROR_TYPE pfnErrorStatus;     OPTIONAL

    // OperationResultsFlags update function
    CALLBACK_OPERATION_RESULT_FLAGS_TYPE pfnOperationResultFlags;   OPTIONAL

    // Client Token
    HANDLE              ClientToken;

    // The safe mode (aka ds repair) admin password
    LPWSTR SafeModePassword;

    // The name of domain we will replicate from
    LPWSTR SourceDomainName;

    // The options Field
    ULONG Options;


} NTDS_INSTALL_INFO, *PNTDS_INSTALL_INFO;

typedef struct {

    LPWSTR DnsDomainName;
    GUID   DomainGuid;
    GUID   DsaGuid;
    LPWSTR DnsHostName;

} NTDS_DNS_RR_INFO, *PNTDS_DNS_RR_INFO;

#ifdef __cplusplus
extern "C" {
#endif

//
// This function starts the initialization of the directory service and
// performs any upgrading that the NT Security Accounts Manager requires
// to use the directory service.  The ds is left "running" so other lsass
// components can upgrade thier database items.
//
// The caller must free SiteName with RtlFreeHeap() from the process heap
// The caller must free NewDnsDomainSid with RtlFreeHeap() from the process
// heap.
//
DWORD
NtdsInstall(
    IN  PNTDS_INSTALL_INFO InstallInfo,
    OUT LPWSTR *InstalledSiteName, OPTIONAL
    OUT GUID   *NewDnsDomainGuid,  OPTIONAL
    OUT PSID   *NewDnsDomainSid    OPTIONAL
    );

//
// This function shuts down the directory service when started by
// NtdsInstall.  This function will only succeed when NtdsInstall
// has succeeded and must be called between calls to NtdsInstall,
// should NtdsInstall be called more than once.
//
DWORD
NtdsInstallShutdown(
    VOID
    );

//
// This function undoes the effect of NtdsInstall
//
DWORD
NtdsInstallUndo(
    VOID
    );

//
// This function copies the Domain NC from the source machine.  During
// NtdsInstall, only the critical objects were copied at that time.
//
DWORD
NtdsInstallReplicateFull(
    CALLBACK_STATUS_TYPE StatusCallback,
    HANDLE               ClientToken,
    ULONG                ulRepOptions
    );

//
// This function causes NtdsInstall or NtdsInstallReplicateFull running in
// another thread to finish prematurely.
//
DWORD
NtdsInstallCancel(
    void
    );

//
// This function prepares the directory service to shutdown
// but does not perform the actual demotion
//
DWORD
NtdsPrepareForDemotion(
    IN ULONG Flags,
    IN LPWSTR                   ServerName,        OPTIONAL
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorStatus,     OPTIONAL
    IN HANDLE                   ClientToken,        OPTIONAL
    OUT PNTDS_DNS_RR_INFO       *pDnsRRInfo
    );

//
// This function undoes any actions performed by
// NtdsPrepareForDemotion
//
DWORD
NtdsPrepareForDemotionUndo(
    VOID
    );

//
// This function performs the DS and SAM actions to be become a
// server from a DC and stops the ds
//
DWORD
NtdsDemote(
    IN SEC_WINNT_AUTH_IDENTITY *Credentials,   OPTIONAL
    IN LPWSTR                   AdminPassword, OPTIONAL
    IN DWORD                    Flags,
    IN LPWSTR                   ServerName,
    IN HANDLE                   ClientToken,
    IN CALLBACK_STATUS_TYPE     pfnStatusCallBack, OPTIONAL
    IN CALLBACK_ERROR_TYPE      pfnErrorStatus     OPTIONAL
    );


DWORD
NtdsPrepareForDsUpgrade(
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO NewLocalAccountInfo,
    OUT LPWSTR                     *NewAdminPassword
    );

//
// This is a helper function for the ui to suggest what dns domain
// name should be used.
//
DWORD
NtdsGetDefaultDnsName(
    OUT LPWSTR     DnsName, OPTIONAL
    IN  OUT ULONG *DnsNameLength
    );


//
// This function will set the machine account type of the
// computer object of the local server via ldap.
//
typedef DWORD ( *NTDSETUP_NtdsSetReplicaMachineAccount )(
            IN SEC_WINNT_AUTH_IDENTITY_W *Credentials,
            IN HANDLE                     ClientToken,
            IN LPWSTR                     DcName,
            IN LPWSTR                     AccountName,
            IN ULONG                      AccountFlags,
            IN OUT WCHAR**                AccountDn OPTIONAL
            );

#define NTDSETUP_SET_MACHINE_ACCOUNT_FN  "NtdsSetReplicaMachineAccount"

DWORD
NtdsSetReplicaMachineAccount(
    IN SEC_WINNT_AUTH_IDENTITY_W   *Credentials,
    IN HANDLE                     ClientToken,
    IN LPWSTR                     DcName,
    IN LPWSTR                     AccountName,
    IN ULONG                      AccountType,  // either UF_SERVER_TRUST_ACCOUNT
                                                // or     UF_WORKSTATION_TRUST_ACCOUNT
    IN OUT WCHAR**                AccountDn    OPTIONAL
    );

VOID
NtdsFreeDnsRRInfo(
    IN PNTDS_DNS_RR_INFO pInfo
    );

#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // _NTDSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdsimp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       imports.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#ifdef MIDL_PASS
/******************************************************************
 *    Standard c data structures.  These should match the defaults.
 ******************************************************************/

typedef unsigned short USHORT;
typedef unsigned long  ULONG;
typedef unsigned char  UCHAR;
typedef UCHAR *PUCHAR;
typedef LONGLONG USN;

#define BOOL long
#define FAR
#define PASCAL

/* Needed to patch up the IDL understanding of UNICODE_STRING this is
   also defined in ntdef.h, but including ntdef.h provided too many 
   conflicts.  That is probably why this was added and things like
   USHORT, ULONG, UCHAR, etc were added.  Be nice if someone fixed 
   this */
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

#define NULL 0

#define IN
#define OUT

// So MIDL doesn't choke on parts of ntdsapi.h.
#define DECLSPEC_IMPORT
#define WINAPI

#endif

#include <ntdsapi.h>
#include <ntdsa.h>
#include <ntdsapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdspch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ntdspch.h
//
//--------------------------------------------------------------------------
//
//  Contents:   Common Header Files For the DS Project - Precompiled.
//              #include <NTDSpch.h>
//              #pragma  hdrstop
//
//--------------------------------------------------------------------------
#ifndef _NTDSpch_
#define _NTDSpch_
//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>

//
// Common DS Headers
//
#include <ntdsapi.h>

// DS-wide error control
#include <ntdswarn.h>

// Macros to control Prefix
#include <tuneprefix.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdskcc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdskcc.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/21/97    Jeff Parham (jeffparh)
                In-process interface to the KCC.

REVISION HISTORY:

--*/


NTSTATUS
KccInitialize();

// Tells the KCC to shut down, but does not wait to see if it does so
void
KccUnInitializeTrigger();


// Waits at most dwMaxWaitInMsec milliseconds for the current KCC task
// to complete.  You must call the trigger routine (above) first.
NTSTATUS
KccUnInitializeWait(
    DWORD   dwMaxWaitInMsec
    );

// Force the KCC to run a task (e.g., update the replication topology).
DWORD
KccExecuteTask(
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsg
    );

// Returns the contents of the connection or link failure cache.
DWORD
KccGetFailureCache(
    IN  DWORD                         InfoType,
    OUT DS_REPL_KCC_DSA_FAILURESW **  ppFailures
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdsguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       ntdsguid.h
//
//--------------------------------------------------------------------------


/*++
 File:    NTDSGUID.H
 Purpose: Contains the Schema Guids for the Attributes and Class
          Schema Objects in NTDS.
 Creator: Automatically generated on
 Date:    Sat May 12 11:43:18 2001

 ** This is a Generated File From Schema.INI **

--*/
#ifndef _NTDSGUID_
#define _NTDSGUID_

// 
// The List of GUID Controls used in DS
// 

extern const GUID GUID_CONTROL_DomainListAccounts       ;  
extern const GUID GUID_CONTROL_DomainLookup             ;  
extern const GUID GUID_CONTROL_DomainAdministerServer   ;  
extern const GUID GUID_CONTROL_UserChangePassword       ;  
extern const GUID GUID_CONTROL_UserForceChangePassword  ;  
extern const GUID GUID_CONTROL_SendAs                   ;  
extern const GUID GUID_CONTROL_SendTo                   ;  
extern const GUID GUID_CONTROL_ReceiveAs                ;  
extern const GUID GUID_CONTROL_ListGroupMembership      ;  
extern const GUID GUID_CONTROL_DsInstallReplica         ;  
extern const GUID GUID_CONTROL_DsSamEnumEntireDomain    ;  

//
// List of SAM property set GUIDS
//

extern const GUID GUID_PS_DOMAIN_PASSWORD               ;  
extern const GUID GUID_PS_GENERAL_INFO                  ;  
extern const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS     ;  
extern const GUID GUID_PS_USER_LOGON                    ;  
extern const GUID GUID_PS_MEMBERSHIP                    ;  
extern const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS       ;  


// 
// The list of Property Set GUIDS used by LSA
// 

extern const GUID GUID_PS_PASSWORD_POLICY               ;   
extern const GUID GUID_PS_LOCKOUT_POLICY                ;   
extern const GUID GUID_PS_DOMAIN_CONFIGURATION          ;   
extern const GUID GUID_PS_DOMAIN_POLICY                 ;   
extern const GUID GUID_PS_PRIVILEGES                    ;   
extern const GUID GUID_PS_ADMINISTRATIVE_ACCESS         ;   
extern const GUID GUID_PS_LOCAL_POLICY                  ;   
extern const GUID GUID_PS_AUDIT                         ;   
extern const GUID GUID_PS_BUILTIN_LOCAL_GROUPS          ;   



//--------------------------------------
// ATTRIBUTE SCHEMA GUIDS
//--------------------------------------
extern const GUID GUID_A_ACCOUNT_EXPIRES                     ;
extern const GUID GUID_A_ACCOUNT_NAME_HISTORY                ;
extern const GUID GUID_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER      ;
extern const GUID GUID_A_ACS_ALLOCABLE_RSVP_BANDWIDTH        ;
extern const GUID GUID_A_ACS_CACHE_TIMEOUT                   ;
extern const GUID GUID_A_ACS_DIRECTION                       ;
extern const GUID GUID_A_ACS_DSBM_DEADTIME                   ;
extern const GUID GUID_A_ACS_DSBM_PRIORITY                   ;
extern const GUID GUID_A_ACS_DSBM_REFRESH                    ;
extern const GUID GUID_A_ACS_ENABLE_ACS_SERVICE              ;
extern const GUID GUID_A_ACS_ENABLE_RSVP_ACCOUNTING          ;
extern const GUID GUID_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING      ;
extern const GUID GUID_A_ACS_EVENT_LOG_LEVEL                 ;
extern const GUID GUID_A_ACS_IDENTITY_NAME                   ;
extern const GUID GUID_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER      ;
extern const GUID GUID_A_ACS_MAX_DURATION_PER_FLOW           ;
extern const GUID GUID_A_ACS_MAX_NO_OF_ACCOUNT_FILES         ;
extern const GUID GUID_A_ACS_MAX_NO_OF_LOG_FILES             ;
extern const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH              ;
extern const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW      ;
extern const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE      ;
extern const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE       ;
extern const GUID GUID_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW       ;
extern const GUID GUID_A_ACS_MAX_TOKEN_RATE_PER_FLOW         ;
extern const GUID GUID_A_ACS_MAXIMUM_SDU_SIZE                ;
extern const GUID GUID_A_ACS_MINIMUM_DELAY_VARIATION         ;
extern const GUID GUID_A_ACS_MINIMUM_LATENCY                 ;
extern const GUID GUID_A_ACS_MINIMUM_POLICED_SIZE            ;
extern const GUID GUID_A_ACS_NON_RESERVED_MAX_SDU_SIZE       ;
extern const GUID GUID_A_ACS_NON_RESERVED_MIN_POLICED_SIZE      ;
extern const GUID GUID_A_ACS_NON_RESERVED_PEAK_RATE          ;
extern const GUID GUID_A_ACS_NON_RESERVED_TOKEN_SIZE         ;
extern const GUID GUID_A_ACS_NON_RESERVED_TX_LIMIT           ;
extern const GUID GUID_A_ACS_NON_RESERVED_TX_SIZE            ;
extern const GUID GUID_A_ACS_PERMISSION_BITS                 ;
extern const GUID GUID_A_ACS_POLICY_NAME                     ;
extern const GUID GUID_A_ACS_PRIORITY                        ;
extern const GUID GUID_A_ACS_RSVP_ACCOUNT_FILES_LOCATION      ;
extern const GUID GUID_A_ACS_RSVP_LOG_FILES_LOCATION         ;
extern const GUID GUID_A_ACS_SERVICE_TYPE                    ;
extern const GUID GUID_A_ACS_TIME_OF_DAY                     ;
extern const GUID GUID_A_ACS_TOTAL_NO_OF_FLOWS               ;
extern const GUID GUID_A_ACS_SERVER_LIST                     ;
extern const GUID GUID_A_ADDITIONAL_INFORMATION              ;
extern const GUID GUID_A_ADDITIONAL_TRUSTED_SERVICE_NAMES      ;
extern const GUID GUID_A_ADDRESS                             ;
extern const GUID GUID_A_ADDRESS_BOOK_ROOTS                  ;
extern const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE         ;
extern const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS      ;
extern const GUID GUID_A_ADDRESS_HOME                        ;
extern const GUID GUID_A_ADDRESS_SYNTAX                      ;
extern const GUID GUID_A_ADDRESS_TYPE                        ;
extern const GUID GUID_A_ADMIN_CONTEXT_MENU                  ;
extern const GUID GUID_A_ADMIN_COUNT                         ;
extern const GUID GUID_A_ADMIN_DESCRIPTION                   ;
extern const GUID GUID_A_ADMIN_DISPLAY_NAME                  ;
extern const GUID GUID_A_ADMIN_MULTISELECT_PROPERTY_PAGES      ;
extern const GUID GUID_A_ADMIN_PROPERTY_PAGES                ;
extern const GUID GUID_A_ALLOWED_ATTRIBUTES                  ;
extern const GUID GUID_A_ALLOWED_ATTRIBUTES_EFFECTIVE        ;
extern const GUID GUID_A_ALLOWED_CHILD_CLASSES               ;
extern const GUID GUID_A_ALLOWED_CHILD_CLASSES_EFFECTIVE      ;
extern const GUID GUID_A_ALT_SECURITY_IDENTITIES             ;
extern const GUID GUID_A_ANR                                 ;
extern const GUID GUID_A_APP_SCHEMA_VERSION                  ;
extern const GUID GUID_A_APPLICATION_NAME                    ;
extern const GUID GUID_A_APPLIES_TO                          ;
extern const GUID GUID_A_ASSET_NUMBER                        ;
extern const GUID GUID_A_ASSISTANT                           ;
extern const GUID GUID_A_ASSOC_NT_ACCOUNT                    ;
extern const GUID GUID_A_ATTRIBUTECERTIFICATEATTRIBUTE       ;
extern const GUID GUID_A_ATTRIBUTE_DISPLAY_NAMES             ;
extern const GUID GUID_A_ATTRIBUTE_ID                        ;
extern const GUID GUID_A_ATTRIBUTE_SECURITY_GUID             ;
extern const GUID GUID_A_ATTRIBUTE_SYNTAX                    ;
extern const GUID GUID_A_ATTRIBUTE_TYPES                     ;
extern const GUID GUID_A_AUDIO                               ;
extern const GUID GUID_A_AUDITING_POLICY                     ;
extern const GUID GUID_A_AUTHENTICATION_OPTIONS              ;
extern const GUID GUID_A_AUTHORITY_REVOCATION_LIST           ;
extern const GUID GUID_A_AUXILIARY_CLASS                     ;
extern const GUID GUID_A_BAD_PASSWORD_TIME                   ;
extern const GUID GUID_A_BAD_PWD_COUNT                       ;
extern const GUID GUID_A_BIRTH_LOCATION                      ;
extern const GUID GUID_A_BRIDGEHEAD_SERVER_LIST_BL           ;
extern const GUID GUID_A_BRIDGEHEAD_TRANSPORT_LIST           ;
extern const GUID GUID_A_BUILTIN_CREATION_TIME               ;
extern const GUID GUID_A_BUILTIN_MODIFIED_COUNT              ;
extern const GUID GUID_A_BUSINESS_CATEGORY                   ;
extern const GUID GUID_A_BYTES_PER_MINUTE                    ;
extern const GUID GUID_A_CA_CERTIFICATE                      ;
extern const GUID GUID_A_CA_CERTIFICATE_DN                   ;
extern const GUID GUID_A_CA_CONNECT                          ;
extern const GUID GUID_A_CA_USAGES                           ;
extern const GUID GUID_A_CA_WEB_URL                          ;
extern const GUID GUID_A_CAN_UPGRADE_SCRIPT                  ;
extern const GUID GUID_A_CANONICAL_NAME                      ;
extern const GUID GUID_A_CARLICENSE                          ;
extern const GUID GUID_A_CATALOGS                            ;
extern const GUID GUID_A_CATEGORIES                          ;
extern const GUID GUID_A_CATEGORY_ID                         ;
extern const GUID GUID_A_CERTIFICATE_AUTHORITY_OBJECT        ;
extern const GUID GUID_A_CERTIFICATE_REVOCATION_LIST         ;
extern const GUID GUID_A_CERTIFICATE_TEMPLATES               ;
extern const GUID GUID_A_CLASS_DISPLAY_NAME                  ;
extern const GUID GUID_A_CODE_PAGE                           ;
extern const GUID GUID_A_COM_CLASSID                         ;
extern const GUID GUID_A_COM_CLSID                           ;
extern const GUID GUID_A_COM_INTERFACEID                     ;
extern const GUID GUID_A_COM_OTHER_PROG_ID                   ;
extern const GUID GUID_A_COM_PROGID                          ;
extern const GUID GUID_A_COM_TREAT_AS_CLASS_ID               ;
extern const GUID GUID_A_COM_TYPELIB_ID                      ;
extern const GUID GUID_A_COM_UNIQUE_LIBID                    ;
extern const GUID GUID_A_COMMENT                             ;
extern const GUID GUID_A_COMMON_NAME                         ;
extern const GUID GUID_A_COMPANY                             ;
extern const GUID GUID_A_CONTENT_INDEXING_ALLOWED            ;
extern const GUID GUID_A_CONTEXT_MENU                        ;
extern const GUID GUID_A_CONTROL_ACCESS_RIGHTS               ;
extern const GUID GUID_A_COST                                ;
extern const GUID GUID_A_COUNTRY_CODE                        ;
extern const GUID GUID_A_COUNTRY_NAME                        ;
extern const GUID GUID_A_CREATE_DIALOG                       ;
extern const GUID GUID_A_CREATE_TIME_STAMP                   ;
extern const GUID GUID_A_CREATE_WIZARD_EXT                   ;
extern const GUID GUID_A_CREATION_TIME                       ;
extern const GUID GUID_A_CREATION_WIZARD                     ;
extern const GUID GUID_A_CREATOR                             ;
extern const GUID GUID_A_CRL_OBJECT                          ;
extern const GUID GUID_A_CRL_PARTITIONED_REVOCATION_LIST      ;
extern const GUID GUID_A_CROSS_CERTIFICATE_PAIR              ;
extern const GUID GUID_A_CURR_MACHINE_ID                     ;
extern const GUID GUID_A_CURRENT_LOCATION                    ;
extern const GUID GUID_A_CURRENT_PARENT_CA                   ;
extern const GUID GUID_A_CURRENT_VALUE                       ;
extern const GUID GUID_A_DBCS_PWD                            ;
extern const GUID GUID_A_DEFAULT_CLASS_STORE                 ;
extern const GUID GUID_A_DEFAULT_GROUP                       ;
extern const GUID GUID_A_DEFAULT_HIDING_VALUE                ;
extern const GUID GUID_A_DEFAULT_LOCAL_POLICY_OBJECT         ;
extern const GUID GUID_A_DEFAULT_OBJECT_CATEGORY             ;
extern const GUID GUID_A_DEFAULT_PRIORITY                    ;
extern const GUID GUID_A_DEFAULT_SECURITY_DESCRIPTOR         ;
extern const GUID GUID_A_DELTA_REVOCATION_LIST               ;
extern const GUID GUID_A_DEPARTMENT                          ;
extern const GUID GUID_A_DEPARTMENTNUMBER                    ;
extern const GUID GUID_A_DESCRIPTION                         ;
extern const GUID GUID_A_DESKTOP_PROFILE                     ;
extern const GUID GUID_A_DESTINATION_INDICATOR               ;
extern const GUID GUID_A_DHCP_CLASSES                        ;
extern const GUID GUID_A_DHCP_FLAGS                          ;
extern const GUID GUID_A_DHCP_IDENTIFICATION                 ;
extern const GUID GUID_A_DHCP_MASK                           ;
extern const GUID GUID_A_DHCP_MAXKEY                         ;
extern const GUID GUID_A_DHCP_OBJ_DESCRIPTION                ;
extern const GUID GUID_A_DHCP_OBJ_NAME                       ;
extern const GUID GUID_A_DHCP_OPTIONS                        ;
extern const GUID GUID_A_DHCP_PROPERTIES                     ;
extern const GUID GUID_A_DHCP_RANGES                         ;
extern const GUID GUID_A_DHCP_RESERVATIONS                   ;
extern const GUID GUID_A_DHCP_SERVERS                        ;
extern const GUID GUID_A_DHCP_SITES                          ;
extern const GUID GUID_A_DHCP_STATE                          ;
extern const GUID GUID_A_DHCP_SUBNETS                        ;
extern const GUID GUID_A_DHCP_TYPE                           ;
extern const GUID GUID_A_DHCP_UNIQUE_KEY                     ;
extern const GUID GUID_A_DHCP_UPDATE_TIME                    ;
extern const GUID GUID_A_DISPLAY_NAME                        ;
extern const GUID GUID_A_DISPLAY_NAME_PRINTABLE              ;
extern const GUID GUID_A_DIT_CONTENT_RULES                   ;
extern const GUID GUID_A_DIVISION                            ;
extern const GUID GUID_A_DMD_LOCATION                        ;
extern const GUID GUID_A_DMD_NAME                            ;
extern const GUID GUID_A_DN_REFERENCE_UPDATE                 ;
extern const GUID GUID_A_DNS_ALLOW_DYNAMIC                   ;
extern const GUID GUID_A_DNS_ALLOW_XFR                       ;
extern const GUID GUID_A_DNS_HOST_NAME                       ;
extern const GUID GUID_A_DNS_NOTIFY_SECONDARIES              ;
extern const GUID GUID_A_DNS_PROPERTY                        ;
extern const GUID GUID_A_DNS_RECORD                          ;
extern const GUID GUID_A_DNS_ROOT                            ;
extern const GUID GUID_A_DNS_SECURE_SECONDARIES              ;
extern const GUID GUID_A_DNS_TOMBSTONED                      ;
extern const GUID GUID_A_DOMAIN_CERTIFICATE_AUTHORITIES      ;
extern const GUID GUID_A_DOMAIN_COMPONENT                    ;
extern const GUID GUID_A_DOMAIN_CROSS_REF                    ;
extern const GUID GUID_A_DOMAIN_ID                           ;
extern const GUID GUID_A_DOMAIN_IDENTIFIER                   ;
extern const GUID GUID_A_DOMAIN_POLICY_OBJECT                ;
extern const GUID GUID_A_DOMAIN_POLICY_REFERENCE             ;
extern const GUID GUID_A_DOMAIN_REPLICA                      ;
extern const GUID GUID_A_DOMAIN_WIDE_POLICY                  ;
extern const GUID GUID_A_DRIVER_NAME                         ;
extern const GUID GUID_A_DRIVER_VERSION                      ;
extern const GUID GUID_A_DS_CORE_PROPAGATION_DATA            ;
extern const GUID GUID_A_DS_HEURISTICS                       ;
extern const GUID GUID_A_DS_UI_ADMIN_MAXIMUM                 ;
extern const GUID GUID_A_DS_UI_ADMIN_NOTIFICATION            ;
extern const GUID GUID_A_DS_UI_SHELL_MAXIMUM                 ;
extern const GUID GUID_A_DSA_SIGNATURE                       ;
extern const GUID GUID_A_DYNAMIC_LDAP_SERVER                 ;
extern const GUID GUID_A_E_MAIL_ADDRESSES                    ;
extern const GUID GUID_A_EFSPOLICY                           ;
extern const GUID GUID_A_EMPLOYEE_ID                         ;
extern const GUID GUID_A_EMPLOYEE_NUMBER                     ;
extern const GUID GUID_A_EMPLOYEE_TYPE                       ;
extern const GUID GUID_A_ENABLED                             ;
extern const GUID GUID_A_ENABLED_CONNECTION                  ;
extern const GUID GUID_A_ENROLLMENT_PROVIDERS                ;
extern const GUID GUID_A_ENTRY_TTL                           ;
extern const GUID GUID_A_EXTENDED_ATTRIBUTE_INFO             ;
extern const GUID GUID_A_EXTENDED_CHARS_ALLOWED              ;
extern const GUID GUID_A_EXTENDED_CLASS_INFO                 ;
extern const GUID GUID_A_EXTENSION_NAME                      ;
extern const GUID GUID_A_EXTRA_COLUMNS                       ;
extern const GUID GUID_A_FACSIMILE_TELEPHONE_NUMBER          ;
extern const GUID GUID_A_FILE_EXT_PRIORITY                   ;
extern const GUID GUID_A_FLAGS                               ;
extern const GUID GUID_A_FLAT_NAME                           ;
extern const GUID GUID_A_FORCE_LOGOFF                        ;
extern const GUID GUID_A_FOREIGN_IDENTIFIER                  ;
extern const GUID GUID_A_FRIENDLY_NAMES                      ;
extern const GUID GUID_A_FROM_ENTRY                          ;
extern const GUID GUID_A_FROM_SERVER                         ;
extern const GUID GUID_A_FRS_COMPUTER_REFERENCE              ;
extern const GUID GUID_A_FRS_COMPUTER_REFERENCE_BL           ;
extern const GUID GUID_A_FRS_CONTROL_DATA_CREATION           ;
extern const GUID GUID_A_FRS_CONTROL_INBOUND_BACKLOG         ;
extern const GUID GUID_A_FRS_CONTROL_OUTBOUND_BACKLOG        ;
extern const GUID GUID_A_FRS_DIRECTORY_FILTER                ;
extern const GUID GUID_A_FRS_DS_POLL                         ;
extern const GUID GUID_A_FRS_EXTENSIONS                      ;
extern const GUID GUID_A_FRS_FAULT_CONDITION                 ;
extern const GUID GUID_A_FRS_FILE_FILTER                     ;
extern const GUID GUID_A_FRS_FLAGS                           ;
extern const GUID GUID_A_FRS_LEVEL_LIMIT                     ;
extern const GUID GUID_A_FRS_MEMBER_REFERENCE                ;
extern const GUID GUID_A_FRS_MEMBER_REFERENCE_BL             ;
extern const GUID GUID_A_FRS_PARTNER_AUTH_LEVEL              ;
extern const GUID GUID_A_FRS_PRIMARY_MEMBER                  ;
extern const GUID GUID_A_FRS_REPLICA_SET_GUID                ;
extern const GUID GUID_A_FRS_REPLICA_SET_TYPE                ;
extern const GUID GUID_A_FRS_ROOT_PATH                       ;
extern const GUID GUID_A_FRS_ROOT_SECURITY                   ;
extern const GUID GUID_A_FRS_SERVICE_COMMAND                 ;
extern const GUID GUID_A_FRS_SERVICE_COMMAND_STATUS          ;
extern const GUID GUID_A_FRS_STAGING_PATH                    ;
extern const GUID GUID_A_FRS_TIME_LAST_COMMAND               ;
extern const GUID GUID_A_FRS_TIME_LAST_CONFIG_CHANGE         ;
extern const GUID GUID_A_FRS_UPDATE_TIMEOUT                  ;
extern const GUID GUID_A_FRS_VERSION                         ;
extern const GUID GUID_A_FRS_VERSION_GUID                    ;
extern const GUID GUID_A_FRS_WORKING_PATH                    ;
extern const GUID GUID_A_FSMO_ROLE_OWNER                     ;
extern const GUID GUID_A_GARBAGE_COLL_PERIOD                 ;
extern const GUID GUID_A_GENERATED_CONNECTION                ;
extern const GUID GUID_A_GENERATION_QUALIFIER                ;
extern const GUID GUID_A_GIVEN_NAME                          ;
extern const GUID GUID_A_GLOBAL_ADDRESS_LIST                 ;
extern const GUID GUID_A_GOVERNS_ID                          ;
extern const GUID GUID_A_GP_LINK                             ;
extern const GUID GUID_A_GP_OPTIONS                          ;
extern const GUID GUID_A_GPC_FILE_SYS_PATH                   ;
extern const GUID GUID_A_GPC_FUNCTIONALITY_VERSION           ;
extern const GUID GUID_A_GPC_MACHINE_EXTENSION_NAMES         ;
extern const GUID GUID_A_GPC_USER_EXTENSION_NAMES            ;
extern const GUID GUID_A_GPC_WQL_FILTER                      ;
extern const GUID GUID_A_GROUP_ATTRIBUTES                    ;
extern const GUID GUID_A_GROUP_MEMBERSHIP_SAM                ;
extern const GUID GUID_A_GROUP_PRIORITY                      ;
extern const GUID GUID_A_GROUP_TYPE                          ;
extern const GUID GUID_A_GROUPS_TO_IGNORE                    ;
extern const GUID GUID_A_HAS_MASTER_NCS                      ;
extern const GUID GUID_A_HAS_PARTIAL_REPLICA_NCS             ;
extern const GUID GUID_A_HELP_DATA16                         ;
extern const GUID GUID_A_HELP_DATA32                         ;
extern const GUID GUID_A_HELP_FILE_NAME                      ;
extern const GUID GUID_A_HIDE_FROM_AB                        ;
extern const GUID GUID_A_HOME_DIRECTORY                      ;
extern const GUID GUID_A_HOME_DRIVE                          ;
extern const GUID GUID_A_ICON_PATH                           ;
extern const GUID GUID_A_IMPLEMENTED_CATEGORIES              ;
extern const GUID GUID_A_INDEXEDSCOPES                       ;
extern const GUID GUID_A_INITIAL_AUTH_INCOMING               ;
extern const GUID GUID_A_INITIAL_AUTH_OUTGOING               ;
extern const GUID GUID_A_INITIALS                            ;
extern const GUID GUID_A_INSTALL_UI_LEVEL                    ;
extern const GUID GUID_A_INSTANCE_TYPE                       ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_FAILOVER        ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_GENERATOR       ;
extern const GUID GUID_A_INTER_SITE_TOPOLOGY_RENEW           ;
extern const GUID GUID_A_INTERNATIONAL_ISDN_NUMBER           ;
extern const GUID GUID_A_INVOCATION_ID                       ;
extern const GUID GUID_A_IPSEC_DATA                          ;
extern const GUID GUID_A_IPSEC_DATA_TYPE                     ;
extern const GUID GUID_A_IPSEC_FILTER_REFERENCE              ;
extern const GUID GUID_A_IPSEC_ID                            ;
extern const GUID GUID_A_IPSEC_ISAKMP_REFERENCE              ;
extern const GUID GUID_A_IPSEC_NAME                          ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_ACTION      ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_REFERENCE      ;
extern const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_TYPE       ;
extern const GUID GUID_A_IPSEC_NFA_REFERENCE                 ;
extern const GUID GUID_A_IPSEC_OWNERS_REFERENCE              ;
extern const GUID GUID_A_IPSEC_POLICY_REFERENCE              ;
extern const GUID GUID_A_IS_CRITICAL_SYSTEM_OBJECT           ;
extern const GUID GUID_A_IS_DEFUNCT                          ;
extern const GUID GUID_A_IS_DELETED                          ;
extern const GUID GUID_A_IS_EPHEMERAL                        ;
extern const GUID GUID_A_IS_MEMBER_OF_DL                     ;
extern const GUID GUID_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET      ;
extern const GUID GUID_A_IS_PRIVILEGE_HOLDER                 ;
extern const GUID GUID_A_IS_SINGLE_VALUED                    ;
extern const GUID GUID_A_JPEGPHOTO                           ;
extern const GUID GUID_A_KEYWORDS                            ;
extern const GUID GUID_A_KNOWLEDGE_INFORMATION               ;
extern const GUID GUID_A_LABELEDURI                          ;
extern const GUID GUID_A_LAST_BACKUP_RESTORATION_TIME        ;
extern const GUID GUID_A_LAST_CONTENT_INDEXED                ;
extern const GUID GUID_A_LAST_KNOWN_PARENT                   ;
extern const GUID GUID_A_LAST_LOGOFF                         ;
extern const GUID GUID_A_LAST_LOGON                          ;
extern const GUID GUID_A_LAST_LOGON_TIMESTAMP                ;
extern const GUID GUID_A_LAST_SET_TIME                       ;
extern const GUID GUID_A_LAST_UPDATE_SEQUENCE                ;
extern const GUID GUID_A_LDAP_ADMIN_LIMITS                   ;
extern const GUID GUID_A_LDAP_DISPLAY_NAME                   ;
extern const GUID GUID_A_LDAP_IPDENY_LIST                    ;
extern const GUID GUID_A_LEGACY_EXCHANGE_DN                  ;
extern const GUID GUID_A_LINK_ID                             ;
extern const GUID GUID_A_LINK_TRACK_SECRET                   ;
extern const GUID GUID_A_LM_PWD_HISTORY                      ;
extern const GUID GUID_A_LOCAL_POLICY_FLAGS                  ;
extern const GUID GUID_A_LOCAL_POLICY_REFERENCE              ;
extern const GUID GUID_A_LOCALE_ID                           ;
extern const GUID GUID_A_LOCALITY_NAME                       ;
extern const GUID GUID_A_LOCALIZED_DESCRIPTION               ;
extern const GUID GUID_A_LOCALIZATION_DISPLAY_ID             ;
extern const GUID GUID_A_LOCATION                            ;
extern const GUID GUID_A_LOCK_OUT_OBSERVATION_WINDOW         ;
extern const GUID GUID_A_LOCKOUT_DURATION                    ;
extern const GUID GUID_A_LOCKOUT_THRESHOLD                   ;
extern const GUID GUID_A_LOCKOUT_TIME                        ;
extern const GUID GUID_A_LOGO                                ;
extern const GUID GUID_A_LOGON_COUNT                         ;
extern const GUID GUID_A_LOGON_HOURS                         ;
extern const GUID GUID_A_LOGON_WORKSTATION                   ;
extern const GUID GUID_A_LSA_CREATION_TIME                   ;
extern const GUID GUID_A_LSA_MODIFIED_COUNT                  ;
extern const GUID GUID_A_MACHINE_ARCHITECTURE                ;
extern const GUID GUID_A_MACHINE_PASSWORD_CHANGE_INTERVAL      ;
extern const GUID GUID_A_MACHINE_ROLE                        ;
extern const GUID GUID_A_MACHINE_WIDE_POLICY                 ;
extern const GUID GUID_A_MANAGED_BY                          ;
extern const GUID GUID_A_MANAGED_OBJECTS                     ;
extern const GUID GUID_A_MANAGER                             ;
extern const GUID GUID_A_MAPI_ID                             ;
extern const GUID GUID_A_MARSHALLED_INTERFACE                ;
extern const GUID GUID_A_MASTERED_BY                         ;
extern const GUID GUID_A_MAX_PWD_AGE                         ;
extern const GUID GUID_A_MAX_RENEW_AGE                       ;
extern const GUID GUID_A_MAX_STORAGE                         ;
extern const GUID GUID_A_MAX_TICKET_AGE                      ;
extern const GUID GUID_A_MAY_CONTAIN                         ;
extern const GUID GUID_A_MEETINGADVERTISESCOPE               ;
extern const GUID GUID_A_MEETINGAPPLICATION                  ;
extern const GUID GUID_A_MEETINGBANDWIDTH                    ;
extern const GUID GUID_A_MEETINGBLOB                         ;
extern const GUID GUID_A_MEETINGCONTACTINFO                  ;
extern const GUID GUID_A_MEETINGDESCRIPTION                  ;
extern const GUID GUID_A_MEETINGENDTIME                      ;
extern const GUID GUID_A_MEETINGID                           ;
extern const GUID GUID_A_MEETINGIP                           ;
extern const GUID GUID_A_MEETINGISENCRYPTED                  ;
extern const GUID GUID_A_MEETINGKEYWORD                      ;
extern const GUID GUID_A_MEETINGLANGUAGE                     ;
extern const GUID GUID_A_MEETINGLOCATION                     ;
extern const GUID GUID_A_MEETINGMAXPARTICIPANTS              ;
extern const GUID GUID_A_MEETINGNAME                         ;
extern const GUID GUID_A_MEETINGORIGINATOR                   ;
extern const GUID GUID_A_MEETINGOWNER                        ;
extern const GUID GUID_A_MEETINGPROTOCOL                     ;
extern const GUID GUID_A_MEETINGRATING                       ;
extern const GUID GUID_A_MEETINGRECURRENCE                   ;
extern const GUID GUID_A_MEETINGSCOPE                        ;
extern const GUID GUID_A_MEETINGSTARTTIME                    ;
extern const GUID GUID_A_MEETINGTYPE                         ;
extern const GUID GUID_A_MEETINGURL                          ;
extern const GUID GUID_A_MEMBER                              ;
extern const GUID GUID_A_MHS_OR_ADDRESS                      ;
extern const GUID GUID_A_MIN_PWD_AGE                         ;
extern const GUID GUID_A_MIN_PWD_LENGTH                      ;
extern const GUID GUID_A_MIN_TICKET_AGE                      ;
extern const GUID GUID_A_MODIFIED_COUNT                      ;
extern const GUID GUID_A_MODIFIED_COUNT_AT_LAST_PROM         ;
extern const GUID GUID_A_MODIFY_TIME_STAMP                   ;
extern const GUID GUID_A_MONIKER                             ;
extern const GUID GUID_A_MONIKER_DISPLAY_NAME                ;
extern const GUID GUID_A_MOVE_TREE_STATE                     ;
extern const GUID GUID_A_MS_COM_DEFAULTPARTITIONLINK         ;
extern const GUID GUID_A_MS_COM_OBJECTID                     ;
extern const GUID GUID_A_MS_COM_PARTITIONLINK                ;
extern const GUID GUID_A_MS_COM_PARTITIONSETLINK             ;
extern const GUID GUID_A_MS_COM_USERLINK                     ;
extern const GUID GUID_A_MS_COM_USERPARTITIONSETLINK         ;
extern const GUID GUID_A_MS_DS_ADDITIONAL_DNS_HOST_NAME      ;
extern const GUID GUID_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME      ;
extern const GUID GUID_A_MS_DS_ALL_USERS_TRUST_QUOTA         ;
extern const GUID GUID_A_MS_DS_ALLOWED_DNS_SUFFIXES          ;
extern const GUID GUID_A_MS_DS_ALLOWED_TO_DELEGATE_TO        ;
extern const GUID GUID_A_MS_DS_AUXILIARY_CLASSES             ;
extern const GUID GUID_A_MS_DS_APPROX_IMMED_SUBORDINATES      ;
extern const GUID GUID_A_MS_DS_BEHAVIOR_VERSION              ;
extern const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP             ;
extern const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP      ;
extern const GUID GUID_A_MS_DS_CONSISTENCY_GUID              ;
extern const GUID GUID_A_MS_DS_CONSISTENCY_CHILD_COUNT       ;
extern const GUID GUID_A_MS_DS_CREATOR_SID                   ;
extern const GUID GUID_A_MS_DS_DNSROOTALIAS                  ;
extern const GUID GUID_A_MS_DS_ENTRY_TIME_TO_DIE             ;
extern const GUID GUID_A_MS_DS_EXECUTESCRIPTPASSWORD         ;
extern const GUID GUID_A_MS_DS_FILTER_CONTAINERS             ;
extern const GUID GUID_A_MS_DS_HAS_INSTANTIATED_NCS          ;
extern const GUID GUID_A_MS_DS_INTID                         ;
extern const GUID GUID_A_MS_DS_LOGON_TIME_SYNC_INTERVAL      ;
extern const GUID GUID_A_MS_DS_TRUST_FOREST_TRUST_INFO       ;
extern const GUID GUID_A_MS_DS_MACHINE_ACCOUNT_QUOTA         ;
extern const GUID GUID_A_MS_DS_OTHER_SETTINGS                ;
extern const GUID GUID_A_MS_DS_NC_REPL_CURSORS               ;
extern const GUID GUID_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS      ;
extern const GUID GUID_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS      ;
extern const GUID GUID_A_MS_DS_NC_REPLICA_LOCATIONS          ;
extern const GUID GUID_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES      ;
extern const GUID GUID_A_MS_DS_PER_USER_TRUST_QUOTA          ;
extern const GUID GUID_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA      ;
extern const GUID GUID_A_MS_DS_PREFERRED_GC_SITE             ;
extern const GUID GUID_A_MS_DS_REPL_ATTRIBUTE_META_DATA      ;
extern const GUID GUID_A_MS_DS_REPL_VALUE_META_DATA          ;
extern const GUID GUID_A_MS_DS_REPLICATES_NC_REASON          ;
extern const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY      ;
extern const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY      ;
extern const GUID GUID_A_MS_DS_REPLICATIONEPOCH              ;
extern const GUID GUID_A_MS_DS_SCHEMA_EXTENSIONS             ;
extern const GUID GUID_A_MS_DS_SD_REFERENCE_DOMAIN           ;
extern const GUID GUID_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES      ;
extern const GUID GUID_A_MS_DS_SETTINGS                      ;
extern const GUID GUID_A_MS_DS_SITE_AFFINITY                 ;
extern const GUID GUID_A_MS_DS_SPN_SUFFIXES                  ;
extern const GUID GUID_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED      ;
extern const GUID GUID_A_MS_DS_UPDATESCRIPT                  ;
extern const GUID GUID_A_MS_EXCH_ASSISTANT_NAME              ;
extern const GUID GUID_A_MS_EXCH_LABELEDURI                  ;
extern const GUID GUID_A_MS_EXCH_OWNER_BL                    ;
extern const GUID GUID_A_MS_FRS_HUB_MEMBER                   ;
extern const GUID GUID_A_MS_FRS_TOPOLOGY_PREF                ;
extern const GUID GUID_A_MS_IIS_FTP_DIR                      ;
extern const GUID GUID_A_MS_IIS_FTP_ROOT                     ;
extern const GUID GUID_A_MS_MMS_DATA                         ;
extern const GUID GUID_A_MS_MMS_INDEX                        ;
extern const GUID GUID_A_MS_MMS_INDICE                       ;
extern const GUID GUID_A_MS_MMS_XML                          ;
extern const GUID GUID_A_MS_MMS_JOIN_LINK                    ;
extern const GUID GUID_A_MS_MMS_LINEAGE                      ;
extern const GUID GUID_A_MS_MMS_PROV_STATUS                  ;
extern const GUID GUID_A_MS_MMS_SYNC_STATUS                  ;
extern const GUID GUID_A_MS_MMS_PARTITION                    ;
extern const GUID GUID_A_MS_MMS_MA_STAGING_LINK              ;
extern const GUID GUID_A_MS_MMS_MA_STAGING_BL                ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_LINK            ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_BL              ;
extern const GUID GUID_A_MS_MMS_ASSOCIATED_LINK              ;
extern const GUID GUID_A_MS_MMS_ASSOCIATED_BL                ;
extern const GUID GUID_A_MS_MMS_SCOPE_LINK                   ;
extern const GUID GUID_A_MS_MMS_SCOPE_BL                     ;
extern const GUID GUID_A_MS_MMS_CRITERIA                     ;
extern const GUID GUID_A_MS_MMS_DOMAIN_CONTROLLER            ;
extern const GUID GUID_A_MS_MMS_SERVICE_NAME                 ;
extern const GUID GUID_A_MS_MMS_INSTANCE_CONFIGURATION       ;
extern const GUID GUID_A_MS_MMS_TOOLS_CONFIGURATION          ;
extern const GUID GUID_A_MS_MMS_INSTANCE_RULE                ;
extern const GUID GUID_A_MS_MMS_INSTALL_STATUS               ;
extern const GUID GUID_A_MS_MMS_VERSION                      ;
extern const GUID GUID_A_MS_MMS_CONNECTOR_SPACE              ;
extern const GUID GUID_A_MS_MMS_SCOPE                        ;
extern const GUID GUID_A_MS_MMS_INSTANCE_SCHEDULE            ;
extern const GUID GUID_A_MS_MMS_INSTANCE_INFO                ;
extern const GUID GUID_A_MS_MMS_MA_CONFIGURATION             ;
extern const GUID GUID_A_MS_MMS_MA_CONFIGURATION_PRIVATE      ;
extern const GUID GUID_A_MS_MMS_MA_SCHEMA                    ;
extern const GUID GUID_A_MS_MMS_MA_MAP                       ;
extern const GUID GUID_A_MS_MMS_MA_CAPABILITY                ;
extern const GUID GUID_A_MS_MMS_MA_EXECUTION_HISTORY         ;
extern const GUID GUID_A_MS_MMS_MA_CATEGORY                  ;
extern const GUID GUID_A_MS_MMS_MA_AD_INFO                   ;
extern const GUID GUID_A_MS_MMS_MA_CD_INFO                   ;
extern const GUID GUID_A_MS_MMS_MA_PROCESS_INFO              ;
extern const GUID GUID_A_MS_MMS_MA_SCRIPT_INFO               ;
extern const GUID GUID_A_MS_MMS_MA_SYSTEM                    ;
extern const GUID GUID_A_MS_MMS_MA_SYNCHRONIZATION           ;
extern const GUID GUID_A_MS_MMS_JOIN_BL                      ;
extern const GUID GUID_A_MS_MMS_ANCHOR                       ;
extern const GUID GUID_A_MS_MMS_EXPORT_KEY                   ;
extern const GUID GUID_A_MS_MMS_IMPORT_KEY                   ;
extern const GUID GUID_A_MS_MMS_STATE                        ;
extern const GUID GUID_A_MS_MMS_HOLOGRAM                     ;
extern const GUID GUID_A_MS_MMS_DELTA_HOLOGRAM               ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_CONFIGURATION      ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_CONFIGURATION_PRIVATE      ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_AD_INFO         ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_SYSTEM          ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_STATUS_XML      ;
extern const GUID GUID_A_MS_MMS_PROVISIONING_STATUS_BINARY      ;
extern const GUID GUID_A_MS_PKI_CERT_TEMPLATE_OID            ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY      ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_NAME_FLAG        ;
extern const GUID GUID_A_MS_PKI_CERTIFICATE_POLICY           ;
extern const GUID GUID_A_MS_PKI_ENROLLMENT_FLAG              ;
extern const GUID GUID_A_MS_PKI_MINIMAL_KEY_SIZE             ;
extern const GUID GUID_A_MS_PKI_OID_ATTRIBUTE                ;
extern const GUID GUID_A_MS_PKI_OID_CPS                      ;
extern const GUID GUID_A_MS_PKI_OID_LOCALIZEDNAME            ;
extern const GUID GUID_A_MS_PKI_OID_USER_NOTICE              ;
extern const GUID GUID_A_MS_PKI_PRIVATE_KEY_FLAG             ;
extern const GUID GUID_A_MS_PKI_SUPERSEDE_TEMPLATES          ;
extern const GUID GUID_A_MS_PKI_TEMPLATE_MINOR_REVISION      ;
extern const GUID GUID_A_MS_PKI_TEMPLATE_SCHEMA_VERSION      ;
extern const GUID GUID_A_MS_PKI_RA_APPLICATION_POLICIES      ;
extern const GUID GUID_A_MS_PKI_RA_POLICIES                  ;
extern const GUID GUID_A_MS_PKI_RA_SIGNATURE                 ;
extern const GUID GUID_A_MS_RRAS_ATTRIBUTE                   ;
extern const GUID GUID_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY      ;
extern const GUID GUID_A_MS_SQL_NAME                         ;
extern const GUID GUID_A_MS_SQL_REGISTEREDOWNER              ;
extern const GUID GUID_A_MS_SQL_CONTACT                      ;
extern const GUID GUID_A_MS_SQL_LOCATION                     ;
extern const GUID GUID_A_MS_SQL_MEMORY                       ;
extern const GUID GUID_A_MS_SQL_BUILD                        ;
extern const GUID GUID_A_MS_SQL_SERVICEACCOUNT               ;
extern const GUID GUID_A_MS_SQL_CHARACTERSET                 ;
extern const GUID GUID_A_MS_SQL_SORTORDER                    ;
extern const GUID GUID_A_MS_SQL_UNICODESORTORDER             ;
extern const GUID GUID_A_MS_SQL_CLUSTERED                    ;
extern const GUID GUID_A_MS_SQL_NAMEDPIPE                    ;
extern const GUID GUID_A_MS_SQL_MULTIPROTOCOL                ;
extern const GUID GUID_A_MS_SQL_SPX                          ;
extern const GUID GUID_A_MS_SQL_TCPIP                        ;
extern const GUID GUID_A_MS_SQL_APPLETALK                    ;
extern const GUID GUID_A_MS_SQL_VINES                        ;
extern const GUID GUID_A_MS_SQL_STATUS                       ;
extern const GUID GUID_A_MS_SQL_LASTUPDATEDDATE              ;
extern const GUID GUID_A_MS_SQL_INFORMATIONURL               ;
extern const GUID GUID_A_MS_SQL_CONNECTIONURL                ;
extern const GUID GUID_A_MS_SQL_PUBLICATIONURL               ;
extern const GUID GUID_A_MS_SQL_GPSLATITUDE                  ;
extern const GUID GUID_A_MS_SQL_GPSLONGITUDE                 ;
extern const GUID GUID_A_MS_SQL_GPSHEIGHT                    ;
extern const GUID GUID_A_MS_SQL_VERSION                      ;
extern const GUID GUID_A_MS_SQL_LANGUAGE                     ;
extern const GUID GUID_A_MS_SQL_DESCRIPTION                  ;
extern const GUID GUID_A_MS_SQL_TYPE                         ;
extern const GUID GUID_A_MS_SQL_INFORMATIONDIRECTORY         ;
extern const GUID GUID_A_MS_SQL_DATABASE                     ;
extern const GUID GUID_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALIAS                        ;
extern const GUID GUID_A_MS_SQL_SIZE                         ;
extern const GUID GUID_A_MS_SQL_CREATIONDATE                 ;
extern const GUID GUID_A_MS_SQL_LASTBACKUPDATE               ;
extern const GUID GUID_A_MS_SQL_LASTDIAGNOSTICDATE           ;
extern const GUID GUID_A_MS_SQL_APPLICATIONS                 ;
extern const GUID GUID_A_MS_SQL_KEYWORDS                     ;
extern const GUID GUID_A_MS_SQL_PUBLISHER                    ;
extern const GUID GUID_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION      ;
extern const GUID GUID_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING      ;
extern const GUID GUID_A_MS_SQL_THIRDPARTY                   ;
extern const GUID GUID_A_MS_TAPI_CONFERENCE_BLOB             ;
extern const GUID GUID_A_MS_TAPI_IP_ADDRESS                  ;
extern const GUID GUID_A_MS_TAPI_PROTOCOL_ID                 ;
extern const GUID GUID_A_MS_TAPI_UNIQUE_IDENTIFIER           ;
extern const GUID GUID_A_MS_WMI_AUTHOR                       ;
extern const GUID GUID_A_MS_WMI_CHANGEDATE                   ;
extern const GUID GUID_A_MS_WMI_CLASS                        ;
extern const GUID GUID_A_MS_WMI_CLASSDEFINITION              ;
extern const GUID GUID_A_MS_WMI_CREATIONDATE                 ;
extern const GUID GUID_A_MS_WMI_GENUS                        ;
extern const GUID GUID_A_MS_WMI_ID                           ;
extern const GUID GUID_A_MS_WMI_INTDEFAULT                   ;
extern const GUID GUID_A_MS_WMI_INTFLAGS1                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS2                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS3                    ;
extern const GUID GUID_A_MS_WMI_INTFLAGS4                    ;
extern const GUID GUID_A_MS_WMI_INTMAX                       ;
extern const GUID GUID_A_MS_WMI_INTMIN                       ;
extern const GUID GUID_A_MS_WMI_INTVALIDVALUES               ;
extern const GUID GUID_A_MS_WMI_INT8DEFAULT                  ;
extern const GUID GUID_A_MS_WMI_INT8MAX                      ;
extern const GUID GUID_A_MS_WMI_INT8MIN                      ;
extern const GUID GUID_A_MS_WMI_INT8VALIDVALUES              ;
extern const GUID GUID_A_MS_WMI_MOF                          ;
extern const GUID GUID_A_MS_WMI_NAME                         ;
extern const GUID GUID_A_MS_WMI_NORMALIZEDCLASS              ;
extern const GUID GUID_A_MS_WMI_PARM1                        ;
extern const GUID GUID_A_MS_WMI_PARM2                        ;
extern const GUID GUID_A_MS_WMI_PARM3                        ;
extern const GUID GUID_A_MS_WMI_PARM4                        ;
extern const GUID GUID_A_MS_WMI_PROPERTYNAME                 ;
extern const GUID GUID_A_MS_WMI_QUERY                        ;
extern const GUID GUID_A_MS_WMI_QUERYLANGUAGE                ;
extern const GUID GUID_A_MS_WMI_SCOPEGUID                    ;
extern const GUID GUID_A_MS_WMI_SOURCEORGANIZATION           ;
extern const GUID GUID_A_MS_WMI_STRINGDEFAULT                ;
extern const GUID GUID_A_MS_WMI_STRINGVALIDVALUES            ;
extern const GUID GUID_A_MS_WMI_TARGETCLASS                  ;
extern const GUID GUID_A_MS_WMI_TARGETNAMESPACE              ;
extern const GUID GUID_A_MS_WMI_TARGETOBJECT                 ;
extern const GUID GUID_A_MS_WMI_TARGETPATH                   ;
extern const GUID GUID_A_MS_WMI_TARGETTYPE                   ;
extern const GUID GUID_A_MSCOPE_ID                           ;
extern const GUID GUID_A_MSI_FILE_LIST                       ;
extern const GUID GUID_A_MSI_SCRIPT                          ;
extern const GUID GUID_A_MSI_SCRIPT_NAME                     ;
extern const GUID GUID_A_MSI_SCRIPT_PATH                     ;
extern const GUID GUID_A_MSI_SCRIPT_SIZE                     ;
extern const GUID GUID_A_MSMQ_AUTHENTICATE                   ;
extern const GUID GUID_A_MSMQ_BASE_PRIORITY                  ;
extern const GUID GUID_A_MSMQ_COMPUTER_TYPE                  ;
extern const GUID GUID_A_MSMQ_COMPUTER_TYPE_EX               ;
extern const GUID GUID_A_MSMQ_COST                           ;
extern const GUID GUID_A_MSMQ_CSP_NAME                       ;
extern const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICE       ;
extern const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICES      ;
extern const GUID GUID_A_MSMQ_DIGESTS                        ;
extern const GUID GUID_A_MSMQ_DIGESTS_MIG                    ;
extern const GUID GUID_A_MSMQ_DS_SERVICE                     ;
extern const GUID GUID_A_MSMQ_DS_SERVICES                    ;
extern const GUID GUID_A_MSMQ_ENCRYPT_KEY                    ;
extern const GUID GUID_A_MSMQ_FOREIGN                        ;
extern const GUID GUID_A_MSMQ_IN_ROUTING_SERVERS             ;
extern const GUID GUID_A_MSMQ_INTERVAL1                      ;
extern const GUID GUID_A_MSMQ_INTERVAL2                      ;
extern const GUID GUID_A_MSMQ_JOURNAL                        ;
extern const GUID GUID_A_MSMQ_JOURNAL_QUOTA                  ;
extern const GUID GUID_A_MSMQ_LABEL                          ;
extern const GUID GUID_A_MSMQ_LABEL_EX                       ;
extern const GUID GUID_A_MSMQ_LONG_LIVED                     ;
extern const GUID GUID_A_MSMQ_MIGRATED                       ;
extern const GUID GUID_A_MSMQ_MULTICAST_ADDRESS              ;
extern const GUID GUID_A_MSMQ_NAME_STYLE                     ;
extern const GUID GUID_A_MSMQ_NT4_FLAGS                      ;
extern const GUID GUID_A_MSMQ_NT4_STUB                       ;
extern const GUID GUID_A_MSMQ_OS_TYPE                        ;
extern const GUID GUID_A_MSMQ_OUT_ROUTING_SERVERS            ;
extern const GUID GUID_A_MSMQ_OWNER_ID                       ;
extern const GUID GUID_A_MSMQ_PREV_SITE_GATES                ;
extern const GUID GUID_A_MSMQ_PRIVACY_LEVEL                  ;
extern const GUID GUID_A_MSMQ_QM_ID                          ;
extern const GUID GUID_A_MSMQ_QUEUE_JOURNAL_QUOTA            ;
extern const GUID GUID_A_MSMQ_QUEUE_NAME_EXT                 ;
extern const GUID GUID_A_MSMQ_QUEUE_QUOTA                    ;
extern const GUID GUID_A_MSMQ_QUEUE_TYPE                     ;
extern const GUID GUID_A_MSMQ_QUOTA                          ;
extern const GUID GUID_A_MSMQ_RECIPIENT_FORMATNAME           ;
extern const GUID GUID_A_MSMQ_ROUTING_SERVICE                ;
extern const GUID GUID_A_MSMQ_ROUTING_SERVICES               ;
extern const GUID GUID_A_MSMQ_SECURED_SOURCE                 ;
extern const GUID GUID_A_MSMQ_SERVICE_TYPE                   ;
extern const GUID GUID_A_MSMQ_SERVICES                       ;
extern const GUID GUID_A_MSMQ_SIGN_CERTIFICATES              ;
extern const GUID GUID_A_MSMQ_SIGN_CERTIFICATES_MIG          ;
extern const GUID GUID_A_MSMQ_SIGN_KEY                       ;
extern const GUID GUID_A_MSMQ_SITE_1                         ;
extern const GUID GUID_A_MSMQ_SITE_2                         ;
extern const GUID GUID_A_MSMQ_SITE_FOREIGN                   ;
extern const GUID GUID_A_MSMQ_SITE_GATES                     ;
extern const GUID GUID_A_MSMQ_SITE_GATES_MIG                 ;
extern const GUID GUID_A_MSMQ_SITE_ID                        ;
extern const GUID GUID_A_MSMQ_SITE_NAME                      ;
extern const GUID GUID_A_MSMQ_SITE_NAME_EX                   ;
extern const GUID GUID_A_MSMQ_SITES                          ;
extern const GUID GUID_A_MSMQ_TRANSACTIONAL                  ;
extern const GUID GUID_A_MSMQ_USER_SID                       ;
extern const GUID GUID_A_MSMQ_VERSION                        ;
extern const GUID GUID_A_MSNPALLOWDIALIN                     ;
extern const GUID GUID_A_MSNPCALLEDSTATIONID                 ;
extern const GUID GUID_A_MSNPCALLINGSTATIONID                ;
extern const GUID GUID_A_MSNPSAVEDCALLINGSTATIONID           ;
extern const GUID GUID_A_MSRADIUSCALLBACKNUMBER              ;
extern const GUID GUID_A_MSRADIUSFRAMEDIPADDRESS             ;
extern const GUID GUID_A_MSRADIUSFRAMEDROUTE                 ;
extern const GUID GUID_A_MSRADIUSSERVICETYPE                 ;
extern const GUID GUID_A_MSRASSAVEDCALLBACKNUMBER            ;
extern const GUID GUID_A_MSRASSAVEDFRAMEDIPADDRESS           ;
extern const GUID GUID_A_MSRASSAVEDFRAMEDROUTE               ;
extern const GUID GUID_A_MUST_CONTAIN                        ;
extern const GUID GUID_A_NAME_SERVICE_FLAGS                  ;
extern const GUID GUID_A_NC_NAME                             ;
extern const GUID GUID_A_NETBIOS_NAME                        ;
extern const GUID GUID_A_NETBOOT_ALLOW_NEW_CLIENTS           ;
extern const GUID GUID_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS      ;
extern const GUID GUID_A_NETBOOT_ANSWER_REQUESTS             ;
extern const GUID GUID_A_NETBOOT_CURRENT_CLIENT_COUNT        ;
extern const GUID GUID_A_NETBOOT_GUID                        ;
extern const GUID GUID_A_NETBOOT_INITIALIZATION              ;
extern const GUID GUID_A_NETBOOT_INTELLIMIRROR_OSES          ;
extern const GUID GUID_A_NETBOOT_LIMIT_CLIENTS               ;
extern const GUID GUID_A_NETBOOT_LOCALLY_INSTALLED_OSES      ;
extern const GUID GUID_A_NETBOOT_MACHINE_FILE_PATH           ;
extern const GUID GUID_A_NETBOOT_MAX_CLIENTS                 ;
extern const GUID GUID_A_NETBOOT_MIRROR_DATA_FILE            ;
extern const GUID GUID_A_NETBOOT_NEW_MACHINE_NAMING_POLICY      ;
extern const GUID GUID_A_NETBOOT_NEW_MACHINE_OU              ;
extern const GUID GUID_A_NETBOOT_SCP_BL                      ;
extern const GUID GUID_A_NETBOOT_SERVER                      ;
extern const GUID GUID_A_NETBOOT_SIF_FILE                    ;
extern const GUID GUID_A_NETBOOT_TOOLS                       ;
extern const GUID GUID_A_NETWORK_ADDRESS                     ;
extern const GUID GUID_A_NEXT_LEVEL_STORE                    ;
extern const GUID GUID_A_NEXT_RID                            ;
extern const GUID GUID_A_NON_SECURITY_MEMBER                 ;
extern const GUID GUID_A_NON_SECURITY_MEMBER_BL              ;
extern const GUID GUID_A_NOTIFICATION_LIST                   ;
extern const GUID GUID_A_NT_GROUP_MEMBERS                    ;
extern const GUID GUID_A_NT_MIXED_DOMAIN                     ;
extern const GUID GUID_A_NT_PWD_HISTORY                      ;
extern const GUID GUID_A_NT_SECURITY_DESCRIPTOR              ;
extern const GUID GUID_A_OBJ_DIST_NAME                       ;
extern const GUID GUID_A_OBJECT_CATEGORY                     ;
extern const GUID GUID_A_OBJECT_CLASS                        ;
extern const GUID GUID_A_OBJECT_CLASS_CATEGORY               ;
extern const GUID GUID_A_OBJECT_CLASSES                      ;
extern const GUID GUID_A_OBJECT_COUNT                        ;
extern const GUID GUID_A_OBJECT_GUID                         ;
extern const GUID GUID_A_OBJECT_SID                          ;
extern const GUID GUID_A_OBJECT_VERSION                      ;
extern const GUID GUID_A_OEM_INFORMATION                     ;
extern const GUID GUID_A_OM_OBJECT_CLASS                     ;
extern const GUID GUID_A_OM_SYNTAX                           ;
extern const GUID GUID_A_OMT_GUID                            ;
extern const GUID GUID_A_OMT_INDX_GUID                       ;
extern const GUID GUID_A_OPERATING_SYSTEM                    ;
extern const GUID GUID_A_OPERATING_SYSTEM_HOTFIX             ;
extern const GUID GUID_A_OPERATING_SYSTEM_SERVICE_PACK       ;
extern const GUID GUID_A_OPERATING_SYSTEM_VERSION            ;
extern const GUID GUID_A_OPERATOR_COUNT                      ;
extern const GUID GUID_A_OPTION_DESCRIPTION                  ;
extern const GUID GUID_A_OPTIONS                             ;
extern const GUID GUID_A_OPTIONS_LOCATION                    ;
extern const GUID GUID_A_ORGANIZATION_NAME                   ;
extern const GUID GUID_A_ORGANIZATIONAL_UNIT_NAME            ;
extern const GUID GUID_A_ORIGINAL_DISPLAY_TABLE              ;
extern const GUID GUID_A_ORIGINAL_DISPLAY_TABLE_MSDOS        ;
extern const GUID GUID_A_OTHER_LOGIN_WORKSTATIONS            ;
extern const GUID GUID_A_OTHER_MAILBOX                       ;
extern const GUID GUID_A_OTHER_NAME                          ;
extern const GUID GUID_A_OTHER_WELL_KNOWN_OBJECTS            ;
extern const GUID GUID_A_OWNER                               ;
extern const GUID GUID_A_PACKAGE_FLAGS                       ;
extern const GUID GUID_A_PACKAGE_NAME                        ;
extern const GUID GUID_A_PACKAGE_TYPE                        ;
extern const GUID GUID_A_PARENT_CA                           ;
extern const GUID GUID_A_PARENT_CA_CERTIFICATE_CHAIN         ;
extern const GUID GUID_A_PARENT_GUID                         ;
extern const GUID GUID_A_PARTIAL_ATTRIBUTE_DELETION_LIST      ;
extern const GUID GUID_A_PARTIAL_ATTRIBUTE_SET               ;
extern const GUID GUID_A_PEK_KEY_CHANGE_INTERVAL             ;
extern const GUID GUID_A_PEK_LIST                            ;
extern const GUID GUID_A_PENDING_CA_CERTIFICATES             ;
extern const GUID GUID_A_PENDING_PARENT_CA                   ;
extern const GUID GUID_A_PER_MSG_DIALOG_DISPLAY_TABLE        ;
extern const GUID GUID_A_PER_RECIP_DIALOG_DISPLAY_TABLE      ;
extern const GUID GUID_A_PERSONAL_TITLE                      ;
extern const GUID GUID_A_PHONE_FAX_OTHER                     ;
extern const GUID GUID_A_PHONE_HOME_OTHER                    ;
extern const GUID GUID_A_PHONE_HOME_PRIMARY                  ;
extern const GUID GUID_A_PHONE_IP_OTHER                      ;
extern const GUID GUID_A_PHONE_IP_PRIMARY                    ;
extern const GUID GUID_A_PHONE_ISDN_PRIMARY                  ;
extern const GUID GUID_A_PHONE_MOBILE_OTHER                  ;
extern const GUID GUID_A_PHONE_MOBILE_PRIMARY                ;
extern const GUID GUID_A_PHONE_OFFICE_OTHER                  ;
extern const GUID GUID_A_PHONE_PAGER_OTHER                   ;
extern const GUID GUID_A_PHONE_PAGER_PRIMARY                 ;
extern const GUID GUID_A_PHOTO                               ;
extern const GUID GUID_A_PHYSICAL_DELIVERY_OFFICE_NAME       ;
extern const GUID GUID_A_PHYSICAL_LOCATION_OBJECT            ;
extern const GUID GUID_A_PICTURE                             ;
extern const GUID GUID_A_PKI_CRITICAL_EXTENSIONS             ;
extern const GUID GUID_A_PKI_DEFAULT_CSPS                    ;
extern const GUID GUID_A_PKI_DEFAULT_KEY_SPEC                ;
extern const GUID GUID_A_PKI_ENROLLMENT_ACCESS               ;
extern const GUID GUID_A_PKI_EXPIRATION_PERIOD               ;
extern const GUID GUID_A_PKI_EXTENDED_KEY_USAGE              ;
extern const GUID GUID_A_PKI_KEY_USAGE                       ;
extern const GUID GUID_A_PKI_MAX_ISSUING_DEPTH               ;
extern const GUID GUID_A_PKI_OVERLAP_PERIOD                  ;
extern const GUID GUID_A_PKT                                 ;
extern const GUID GUID_A_PKT_GUID                            ;
extern const GUID GUID_A_POLICY_REPLICATION_FLAGS            ;
extern const GUID GUID_A_PORT_NAME                           ;
extern const GUID GUID_A_POSS_SUPERIORS                      ;
extern const GUID GUID_A_POSSIBLE_INFERIORS                  ;
extern const GUID GUID_A_POST_OFFICE_BOX                     ;
extern const GUID GUID_A_POSTAL_ADDRESS                      ;
extern const GUID GUID_A_POSTAL_CODE                         ;
extern const GUID GUID_A_PREFERRED_DELIVERY_METHOD           ;
extern const GUID GUID_A_PREFERREDLANGUAGE                   ;
extern const GUID GUID_A_PREFERRED_OU                        ;
extern const GUID GUID_A_PREFIX_MAP                          ;
extern const GUID GUID_A_PRESENTATION_ADDRESS                ;
extern const GUID GUID_A_PREVIOUS_CA_CERTIFICATES            ;
extern const GUID GUID_A_PREVIOUS_PARENT_CA                  ;
extern const GUID GUID_A_PRIMARY_GROUP_ID                    ;
extern const GUID GUID_A_PRIMARY_GROUP_TOKEN                 ;
extern const GUID GUID_A_PRINT_ATTRIBUTES                    ;
extern const GUID GUID_A_PRINT_BIN_NAMES                     ;
extern const GUID GUID_A_PRINT_COLLATE                       ;
extern const GUID GUID_A_PRINT_COLOR                         ;
extern const GUID GUID_A_PRINT_DUPLEX_SUPPORTED              ;
extern const GUID GUID_A_PRINT_END_TIME                      ;
extern const GUID GUID_A_PRINT_FORM_NAME                     ;
extern const GUID GUID_A_PRINT_KEEP_PRINTED_JOBS             ;
extern const GUID GUID_A_PRINT_LANGUAGE                      ;
extern const GUID GUID_A_PRINT_MAC_ADDRESS                   ;
extern const GUID GUID_A_PRINT_MAX_COPIES                    ;
extern const GUID GUID_A_PRINT_MAX_RESOLUTION_SUPPORTED      ;
extern const GUID GUID_A_PRINT_MAX_X_EXTENT                  ;
extern const GUID GUID_A_PRINT_MAX_Y_EXTENT                  ;
extern const GUID GUID_A_PRINT_MEDIA_READY                   ;
extern const GUID GUID_A_PRINT_MEDIA_SUPPORTED               ;
extern const GUID GUID_A_PRINT_MEMORY                        ;
extern const GUID GUID_A_PRINT_MIN_X_EXTENT                  ;
extern const GUID GUID_A_PRINT_MIN_Y_EXTENT                  ;
extern const GUID GUID_A_PRINT_NETWORK_ADDRESS               ;
extern const GUID GUID_A_PRINT_NOTIFY                        ;
extern const GUID GUID_A_PRINT_NUMBER_UP                     ;
extern const GUID GUID_A_PRINT_ORIENTATIONS_SUPPORTED        ;
extern const GUID GUID_A_PRINT_OWNER                         ;
extern const GUID GUID_A_PRINT_PAGES_PER_MINUTE              ;
extern const GUID GUID_A_PRINT_RATE                          ;
extern const GUID GUID_A_PRINT_RATE_UNIT                     ;
extern const GUID GUID_A_PRINT_SEPARATOR_FILE                ;
extern const GUID GUID_A_PRINT_SHARE_NAME                    ;
extern const GUID GUID_A_PRINT_SPOOLING                      ;
extern const GUID GUID_A_PRINT_STAPLING_SUPPORTED            ;
extern const GUID GUID_A_PRINT_START_TIME                    ;
extern const GUID GUID_A_PRINT_STATUS                        ;
extern const GUID GUID_A_PRINTER_NAME                        ;
extern const GUID GUID_A_PRIOR_SET_TIME                      ;
extern const GUID GUID_A_PRIOR_VALUE                         ;
extern const GUID GUID_A_PRIORITY                            ;
extern const GUID GUID_A_PRIVATE_KEY                         ;
extern const GUID GUID_A_PRIVILEGE_ATTRIBUTES                ;
extern const GUID GUID_A_PRIVILEGE_DISPLAY_NAME              ;
extern const GUID GUID_A_PRIVILEGE_HOLDER                    ;
extern const GUID GUID_A_PRIVILEGE_VALUE                     ;
extern const GUID GUID_A_PRODUCT_CODE                        ;
extern const GUID GUID_A_PROFILE_PATH                        ;
extern const GUID GUID_A_PROXIED_OBJECT_NAME                 ;
extern const GUID GUID_A_PROXY_ADDRESSES                     ;
extern const GUID GUID_A_PROXY_GENERATION_ENABLED            ;
extern const GUID GUID_A_PROXY_LIFETIME                      ;
extern const GUID GUID_A_PUBLIC_KEY_POLICY                   ;
extern const GUID GUID_A_PURPORTED_SEARCH                    ;
extern const GUID GUID_A_PWD_HISTORY_LENGTH                  ;
extern const GUID GUID_A_PWD_LAST_SET                        ;
extern const GUID GUID_A_PWD_PROPERTIES                      ;
extern const GUID GUID_A_QUALITY_OF_SERVICE                  ;
extern const GUID GUID_A_QUERY_FILTER                        ;
extern const GUID GUID_A_QUERY_POLICY_BL                     ;
extern const GUID GUID_A_QUERY_POLICY_OBJECT                 ;
extern const GUID GUID_A_QUERYPOINT                          ;
extern const GUID GUID_A_RANGE_LOWER                         ;
extern const GUID GUID_A_RANGE_UPPER                         ;
extern const GUID GUID_A_RDN                                 ;
extern const GUID GUID_A_RDN_ATT_ID                          ;
extern const GUID GUID_A_REGISTERED_ADDRESS                  ;
extern const GUID GUID_A_REMOTE_SERVER_NAME                  ;
extern const GUID GUID_A_REMOTE_SOURCE                       ;
extern const GUID GUID_A_REMOTE_SOURCE_TYPE                  ;
extern const GUID GUID_A_REMOTE_STORAGE_GUID                 ;
extern const GUID GUID_A_REPL_PROPERTY_META_DATA             ;
extern const GUID GUID_A_REPL_TOPOLOGY_STAY_OF_EXECUTION      ;
extern const GUID GUID_A_REPL_UPTODATE_VECTOR                ;
extern const GUID GUID_A_REPLICA_SOURCE                      ;
extern const GUID GUID_A_REPORTS                             ;
extern const GUID GUID_A_REPL_INTERVAL                       ;
extern const GUID GUID_A_REPS_FROM                           ;
extern const GUID GUID_A_REPS_TO                             ;
extern const GUID GUID_A_REQUIRED_CATEGORIES                 ;
extern const GUID GUID_A_RETIRED_REPL_DSA_SIGNATURES         ;
extern const GUID GUID_A_TOKEN_GROUPS                        ;
extern const GUID GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL      ;
extern const GUID GUID_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE       ;
extern const GUID GUID_A_REVISION                            ;
extern const GUID GUID_A_RID                                 ;
extern const GUID GUID_A_RID_ALLOCATION_POOL                 ;
extern const GUID GUID_A_RID_AVAILABLE_POOL                  ;
extern const GUID GUID_A_RID_MANAGER_REFERENCE               ;
extern const GUID GUID_A_RID_NEXT_RID                        ;
extern const GUID GUID_A_RID_PREVIOUS_ALLOCATION_POOL        ;
extern const GUID GUID_A_RID_SET_REFERENCES                  ;
extern const GUID GUID_A_RID_USED_POOL                       ;
extern const GUID GUID_A_RIGHTS_GUID                         ;
extern const GUID GUID_A_ROLE_OCCUPANT                       ;
extern const GUID GUID_A_ROOMNUMBER                          ;
extern const GUID GUID_A_ROOT_TRUST                          ;
extern const GUID GUID_A_RPC_NS_ANNOTATION                   ;
extern const GUID GUID_A_RPC_NS_BINDINGS                     ;
extern const GUID GUID_A_RPC_NS_CODESET                      ;
extern const GUID GUID_A_RPC_NS_ENTRY_FLAGS                  ;
extern const GUID GUID_A_RPC_NS_GROUP                        ;
extern const GUID GUID_A_RPC_NS_INTERFACE_ID                 ;
extern const GUID GUID_A_RPC_NS_OBJECT_ID                    ;
extern const GUID GUID_A_RPC_NS_PRIORITY                     ;
extern const GUID GUID_A_RPC_NS_PROFILE_ENTRY                ;
extern const GUID GUID_A_RPC_NS_TRANSFER_SYNTAX              ;
extern const GUID GUID_A_SAM_ACCOUNT_NAME                    ;
extern const GUID GUID_A_SAM_ACCOUNT_TYPE                    ;
extern const GUID GUID_A_SCHEDULE                            ;
extern const GUID GUID_A_SCHEMA_FLAGS_EX                     ;
extern const GUID GUID_A_SCHEMA_ID_GUID                      ;
extern const GUID GUID_A_SCHEMA_INFO                         ;
extern const GUID GUID_A_SCHEMA_UPDATE                       ;
extern const GUID GUID_A_SCHEMA_VERSION                      ;
extern const GUID GUID_A_SCOPE_FLAGS                         ;
extern const GUID GUID_A_SCRIPT_PATH                         ;
extern const GUID GUID_A_SD_RIGHTS_EFFECTIVE                 ;
extern const GUID GUID_A_SEARCH_FLAGS                        ;
extern const GUID GUID_A_SEARCH_GUIDE                        ;
extern const GUID GUID_A_SECRETARY                           ;
extern const GUID GUID_A_SECURITY_IDENTIFIER                 ;
extern const GUID GUID_A_SEE_ALSO                            ;
extern const GUID GUID_A_SEQ_NOTIFICATION                    ;
extern const GUID GUID_A_SERIAL_NUMBER                       ;
extern const GUID GUID_A_SERVER_NAME                         ;
extern const GUID GUID_A_SERVER_REFERENCE                    ;
extern const GUID GUID_A_SERVER_REFERENCE_BL                 ;
extern const GUID GUID_A_SERVER_ROLE                         ;
extern const GUID GUID_A_SERVER_STATE                        ;
extern const GUID GUID_A_SERVICE_BINDING_INFORMATION         ;
extern const GUID GUID_A_SERVICE_CLASS_ID                    ;
extern const GUID GUID_A_SERVICE_CLASS_INFO                  ;
extern const GUID GUID_A_SERVICE_CLASS_NAME                  ;
extern const GUID GUID_A_SERVICE_DNS_NAME                    ;
extern const GUID GUID_A_SERVICE_DNS_NAME_TYPE               ;
extern const GUID GUID_A_SERVICE_INSTANCE_VERSION            ;
extern const GUID GUID_A_SERVICE_PRINCIPAL_NAME              ;
extern const GUID GUID_A_SETUP_COMMAND                       ;
extern const GUID GUID_A_SHELL_CONTEXT_MENU                  ;
extern const GUID GUID_A_SHELL_PROPERTY_PAGES                ;
extern const GUID GUID_A_SHORT_SERVER_NAME                   ;
extern const GUID GUID_A_SHOW_IN_ADDRESS_BOOK                ;
extern const GUID GUID_A_SHOW_IN_ADVANCED_VIEW_ONLY          ;
extern const GUID GUID_A_SID_HISTORY                         ;
extern const GUID GUID_A_SIGNATURE_ALGORITHMS                ;
extern const GUID GUID_A_SITE_GUID                           ;
extern const GUID GUID_A_SITE_LINK_LIST                      ;
extern const GUID GUID_A_SITE_LIST                           ;
extern const GUID GUID_A_SITE_OBJECT                         ;
extern const GUID GUID_A_SITE_OBJECT_BL                      ;
extern const GUID GUID_A_SITE_SERVER                         ;
extern const GUID GUID_A_SMTP_MAIL_ADDRESS                   ;
extern const GUID GUID_A_SPN_MAPPINGS                        ;
extern const GUID GUID_A_STATE_OR_PROVINCE_NAME              ;
extern const GUID GUID_A_STREET_ADDRESS                      ;
extern const GUID GUID_A_STRUCTURAL_OBJECT_CLASS             ;
extern const GUID GUID_A_SUB_CLASS_OF                        ;
extern const GUID GUID_A_SUB_REFS                            ;
extern const GUID GUID_A_SUBSCHEMASUBENTRY                   ;
extern const GUID GUID_A_SUPER_SCOPE_DESCRIPTION             ;
extern const GUID GUID_A_SUPER_SCOPES                        ;
extern const GUID GUID_A_SUPERIOR_DNS_ROOT                   ;
extern const GUID GUID_A_SUPPLEMENTAL_CREDENTIALS            ;
extern const GUID GUID_A_SUPPORTED_APPLICATION_CONTEXT       ;
extern const GUID GUID_A_SURNAME                             ;
extern const GUID GUID_A_SYNC_ATTRIBUTES                     ;
extern const GUID GUID_A_SYNC_MEMBERSHIP                     ;
extern const GUID GUID_A_SYNC_WITH_OBJECT                    ;
extern const GUID GUID_A_SYNC_WITH_SID                       ;
extern const GUID GUID_A_SYSTEM_AUXILIARY_CLASS              ;
extern const GUID GUID_A_SYSTEM_FLAGS                        ;
extern const GUID GUID_A_SYSTEM_MAY_CONTAIN                  ;
extern const GUID GUID_A_SYSTEM_MUST_CONTAIN                 ;
extern const GUID GUID_A_SYSTEM_ONLY                         ;
extern const GUID GUID_A_SYSTEM_POSS_SUPERIORS               ;
extern const GUID GUID_A_TELEPHONE_NUMBER                    ;
extern const GUID GUID_A_TELETEX_TERMINAL_IDENTIFIER         ;
extern const GUID GUID_A_TELEX_NUMBER                        ;
extern const GUID GUID_A_TELEX_PRIMARY                       ;
extern const GUID GUID_A_TEMPLATE_ROOTS                      ;
extern const GUID GUID_A_TERMINAL_SERVER                     ;
extern const GUID GUID_A_TEXT_COUNTRY                        ;
extern const GUID GUID_A_TEXT_ENCODED_OR_ADDRESS             ;
extern const GUID GUID_A_TIME_REFRESH                        ;
extern const GUID GUID_A_TIME_VOL_CHANGE                     ;
extern const GUID GUID_A_TITLE                               ;
extern const GUID GUID_A_TOMBSTONE_LIFETIME                  ;
extern const GUID GUID_A_TRANSPORT_ADDRESS_ATTRIBUTE         ;
extern const GUID GUID_A_TRANSPORT_DLL_NAME                  ;
extern const GUID GUID_A_TRANSPORT_TYPE                      ;
extern const GUID GUID_A_TREAT_AS_LEAF                       ;
extern const GUID GUID_A_TREE_NAME                           ;
extern const GUID GUID_A_TRUST_ATTRIBUTES                    ;
extern const GUID GUID_A_TRUST_AUTH_INCOMING                 ;
extern const GUID GUID_A_TRUST_AUTH_OUTGOING                 ;
extern const GUID GUID_A_TRUST_DIRECTION                     ;
extern const GUID GUID_A_TRUST_PARENT                        ;
extern const GUID GUID_A_TRUST_PARTNER                       ;
extern const GUID GUID_A_TRUST_POSIX_OFFSET                  ;
extern const GUID GUID_A_TRUST_TYPE                          ;
extern const GUID GUID_A_UAS_COMPAT                          ;
extern const GUID GUID_A_UID                                 ;
extern const GUID GUID_A_UNC_NAME                            ;
extern const GUID GUID_A_UNICODE_PWD                         ;
extern const GUID GUID_A_UNIQUEMEMBER                        ;
extern const GUID GUID_A_UNSTRUCTUREDADDRESS                 ;
extern const GUID GUID_A_UNSTRUCTUREDNAME                    ;
extern const GUID GUID_A_UPGRADE_PRODUCT_CODE                ;
extern const GUID GUID_A_UPN_SUFFIXES                        ;
extern const GUID GUID_A_USER_ACCOUNT_CONTROL                ;
extern const GUID GUID_A_USER_CERT                           ;
extern const GUID GUID_A_USER_COMMENT                        ;
extern const GUID GUID_A_USER_PARAMETERS                     ;
extern const GUID GUID_A_USER_PASSWORD                       ;
extern const GUID GUID_A_USERPKCS12                          ;
extern const GUID GUID_A_USER_PRINCIPAL_NAME                 ;
extern const GUID GUID_A_USER_SHARED_FOLDER                  ;
extern const GUID GUID_A_USER_SHARED_FOLDER_OTHER            ;
extern const GUID GUID_A_USER_SMIME_CERTIFICATE              ;
extern const GUID GUID_A_USER_WORKSTATIONS                   ;
extern const GUID GUID_A_USN_CHANGED                         ;
extern const GUID GUID_A_USN_CREATED                         ;
extern const GUID GUID_A_USN_DSA_LAST_OBJ_REMOVED            ;
extern const GUID GUID_A_USN_INTERSITE                       ;
extern const GUID GUID_A_USN_LAST_OBJ_REM                    ;
extern const GUID GUID_A_USN_SOURCE                          ;
extern const GUID GUID_A_VALID_ACCESSES                      ;
extern const GUID GUID_A_VENDOR                              ;
extern const GUID GUID_A_VERSION_NUMBER                      ;
extern const GUID GUID_A_VERSION_NUMBER_HI                   ;
extern const GUID GUID_A_VERSION_NUMBER_LO                   ;
extern const GUID GUID_A_VOL_TABLE_GUID                      ;
extern const GUID GUID_A_VOL_TABLE_IDX_GUID                  ;
extern const GUID GUID_A_VOLUME_COUNT                        ;
extern const GUID GUID_A_WBEM_PATH                           ;
extern const GUID GUID_A_WELL_KNOWN_OBJECTS                  ;
extern const GUID GUID_A_WHEN_CHANGED                        ;
extern const GUID GUID_A_WHEN_CREATED                        ;
extern const GUID GUID_A_WINSOCK_ADDRESSES                   ;
extern const GUID GUID_A_WWW_HOME_PAGE                       ;
extern const GUID GUID_A_WWW_PAGE_OTHER                      ;
extern const GUID GUID_A_X121_ADDRESS                        ;
extern const GUID GUID_A_X500UNIQUEIDENTIFIER                ;
extern const GUID GUID_A_X509_CERT                           ;


//--------------------------------------
// CLASS SCHEMA GUIDS
//--------------------------------------
extern const GUID GUID_C_ACS_POLICY                         ;
extern const GUID GUID_C_ACS_RESOURCE_LIMITS                ;
extern const GUID GUID_C_ACS_SUBNET                         ;
extern const GUID GUID_C_ADDRESS_BOOK_CONTAINER             ;
extern const GUID GUID_C_ADDRESS_TEMPLATE                   ;
extern const GUID GUID_C_APPLICATION_ENTITY                 ;
extern const GUID GUID_C_APPLICATION_PROCESS                ;
extern const GUID GUID_C_APPLICATION_SETTINGS               ;
extern const GUID GUID_C_APPLICATION_SITE_SETTINGS          ;
extern const GUID GUID_C_APPLICATION_VERSION                ;
extern const GUID GUID_C_ATTRIBUTE_SCHEMA                   ;
extern const GUID GUID_C_BUILTIN_DOMAIN                     ;
extern const GUID GUID_C_CATEGORY_REGISTRATION              ;
extern const GUID GUID_C_CERTIFICATION_AUTHORITY            ;
extern const GUID GUID_C_CLASS_REGISTRATION                 ;
extern const GUID GUID_C_CLASS_SCHEMA                       ;
extern const GUID GUID_C_CLASS_STORE                        ;
extern const GUID GUID_C_COM_CONNECTION_POINT               ;
extern const GUID GUID_C_COMPUTER                           ;
extern const GUID GUID_C_CONFIGURATION                      ;
extern const GUID GUID_C_CONNECTION_POINT                   ;
extern const GUID GUID_C_CONTACT                            ;
extern const GUID GUID_C_CONTAINER                          ;
extern const GUID GUID_C_CONTROL_ACCESS_RIGHT               ;
extern const GUID GUID_C_COUNTRY                            ;
extern const GUID GUID_C_CRL_DISTRIBUTION_POINT             ;
extern const GUID GUID_C_CROSS_REF                          ;
extern const GUID GUID_C_CROSS_REF_CONTAINER                ;
extern const GUID GUID_C_DEVICE                             ;
extern const GUID GUID_C_DFS_CONFIGURATION                  ;
extern const GUID GUID_C_DHCP_CLASS                         ;
extern const GUID GUID_C_DISPLAY_SPECIFIER                  ;
extern const GUID GUID_C_DISPLAY_TEMPLATE                   ;
extern const GUID GUID_C_DMD                                ;
extern const GUID GUID_C_DNS_NODE                           ;
extern const GUID GUID_C_DNS_ZONE                           ;
extern const GUID GUID_C_DOMAIN                             ;
extern const GUID GUID_C_DOMAIN_DNS                         ;
extern const GUID GUID_C_DOMAIN_POLICY                      ;
extern const GUID GUID_C_DS_UI_SETTINGS                     ;
extern const GUID GUID_C_DSA                                ;
extern const GUID GUID_C_DYNAMIC_OBJECT                     ;
extern const GUID GUID_C_FILE_LINK_TRACKING                 ;
extern const GUID GUID_C_FILE_LINK_TRACKING_ENTRY           ;
extern const GUID GUID_C_FOREIGN_SECURITY_PRINCIPAL         ;
extern const GUID GUID_C_FT_DFS                             ;
extern const GUID GUID_C_GROUP                              ;
extern const GUID GUID_C_GROUP_OF_NAMES                     ;
extern const GUID GUID_C_GROUPOFUNIQUENAMES                 ;
extern const GUID GUID_C_GROUP_POLICY_CONTAINER             ;
extern const GUID GUID_C_INDEX_SERVER_CATALOG               ;
extern const GUID GUID_C_INETORGPERSON                      ;
extern const GUID GUID_C_INFRASTRUCTURE_UPDATE              ;
extern const GUID GUID_C_INTELLIMIRROR_GROUP                ;
extern const GUID GUID_C_INTELLIMIRROR_SCP                  ;
extern const GUID GUID_C_INTER_SITE_TRANSPORT               ;
extern const GUID GUID_C_INTER_SITE_TRANSPORT_CONTAINER     ;
extern const GUID GUID_C_IPSEC_BASE                         ;
extern const GUID GUID_C_IPSEC_FILTER                       ;
extern const GUID GUID_C_IPSEC_ISAKMP_POLICY                ;
extern const GUID GUID_C_IPSEC_NEGOTIATION_POLICY           ;
extern const GUID GUID_C_IPSEC_NFA                          ;
extern const GUID GUID_C_IPSEC_POLICY                       ;
extern const GUID GUID_C_LEAF                               ;
extern const GUID GUID_C_LICENSING_SITE_SETTINGS            ;
extern const GUID GUID_C_LINK_TRACK_OBJECT_MOVE_TABLE       ;
extern const GUID GUID_C_LINK_TRACK_OMT_ENTRY               ;
extern const GUID GUID_C_LINK_TRACK_VOL_ENTRY               ;
extern const GUID GUID_C_LINK_TRACK_VOLUME_TABLE            ;
extern const GUID GUID_C_LOCALITY                           ;
extern const GUID GUID_C_LOST_AND_FOUND                     ;
extern const GUID GUID_C_MAIL_RECIPIENT                     ;
extern const GUID GUID_C_MEETING                            ;
extern const GUID GUID_C_MS_COM_PARTITION                   ;
extern const GUID GUID_C_MS_COM_PARTITIONSET                ;
extern const GUID GUID_C_MS_DS_APP_CONFIGURATION            ;
extern const GUID GUID_C_MS_EXCH_CONFIGURATION_CONTAINER     ;
extern const GUID GUID_C_MS_MMS_MANAGEMENT_AGENT            ;
extern const GUID GUID_C_MS_MMS_INSTANCE                    ;
extern const GUID GUID_C_MS_MMS_OBJECT                      ;
extern const GUID GUID_C_MS_MMS_MANAGEMENT_AGENT_HISTORY     ;
extern const GUID GUID_C_MS_MMS_CONNECTOR                   ;
extern const GUID GUID_C_MS_MMS_PROVISIONING_SERVICE        ;
extern const GUID GUID_C_MS_MMS_PROVISIONING_SERVICE_HISTORY     ;
extern const GUID GUID_C_MS_MMS_WORKFLOW                    ;
extern const GUID GUID_C_MS_MMS_PROVISIONING_STATUS         ;
extern const GUID GUID_C_MS_MMS_EVENT_ASSOCIATION           ;
extern const GUID GUID_C_MS_PKI_ENTERPRISE_OID              ;
extern const GUID GUID_C_MS_PKI_KEY_RECOVERY_AGENT          ;
extern const GUID GUID_C_MS_SQL_SQLSERVER                   ;
extern const GUID GUID_C_MS_SQL_OLAPSERVER                  ;
extern const GUID GUID_C_MS_SQL_SQLREPOSITORY               ;
extern const GUID GUID_C_MS_SQL_SQLPUBLICATION              ;
extern const GUID GUID_C_MS_SQL_SQLDATABASE                 ;
extern const GUID GUID_C_MS_SQL_OLAPDATABASE                ;
extern const GUID GUID_C_MS_SQL_OLAPCUBE                    ;
extern const GUID GUID_C_MS_TAPI_RT_CONFERENCE              ;
extern const GUID GUID_C_MS_TAPI_RT_PERSON                  ;
extern const GUID GUID_C_MS_WMI_INTRANGEPARAM               ;
extern const GUID GUID_C_MS_WMI_INTSETPARAM                 ;
extern const GUID GUID_C_MS_WMI_MERGEABLEPOLICYTEMPLATE     ;
extern const GUID GUID_C_MS_WMI_OBJECTENCODING              ;
extern const GUID GUID_C_MS_WMI_POLICYTEMPLATE              ;
extern const GUID GUID_C_MS_WMI_POLICYTYPE                  ;
extern const GUID GUID_C_MS_WMI_RANGEPARAM                  ;
extern const GUID GUID_C_MS_WMI_REALRANGEPARAM              ;
extern const GUID GUID_C_MS_WMI_RULE                        ;
extern const GUID GUID_C_MS_WMI_SHADOWOBJECT                ;
extern const GUID GUID_C_MS_WMI_SIMPLEPOLICYTEMPLATE        ;
extern const GUID GUID_C_MS_WMI_SOM                         ;
extern const GUID GUID_C_MS_WMI_STRINGSETPARAM              ;
extern const GUID GUID_C_MS_WMI_UINTRANGEPARAM              ;
extern const GUID GUID_C_MS_WMI_UINTSETPARAM                ;
extern const GUID GUID_C_MS_WMI_UNKNOWNRANGEPARAM           ;
extern const GUID GUID_C_MS_WMI_WMIGPO                      ;
extern const GUID GUID_C_MSMQ_CONFIGURATION                 ;
extern const GUID GUID_C_MSMQ_CUSTOM_RECIPIENT              ;
extern const GUID GUID_C_MSMQ_ENTERPRISE_SETTINGS           ;
extern const GUID GUID_C_MSMQ_GROUP                         ;
extern const GUID GUID_C_MSMQ_MIGRATED_USER                 ;
extern const GUID GUID_C_MSMQ_QUEUE                         ;
extern const GUID GUID_C_MSMQ_SETTINGS                      ;
extern const GUID GUID_C_MSMQ_SITE_LINK                     ;
extern const GUID GUID_C_NTDS_CONNECTION                    ;
extern const GUID GUID_C_NTDS_DSA                           ;
extern const GUID GUID_C_NTDS_SERVICE                       ;
extern const GUID GUID_C_NTDS_SITE_SETTINGS                 ;
extern const GUID GUID_C_NTFRS_MEMBER                       ;
extern const GUID GUID_C_NTFRS_REPLICA_SET                  ;
extern const GUID GUID_C_NTFRS_SETTINGS                     ;
extern const GUID GUID_C_NTFRS_SUBSCRIBER                   ;
extern const GUID GUID_C_NTFRS_SUBSCRIPTIONS                ;
extern const GUID GUID_C_ORGANIZATION                       ;
extern const GUID GUID_C_ORGANIZATIONAL_PERSON              ;
extern const GUID GUID_C_ORGANIZATIONAL_ROLE                ;
extern const GUID GUID_C_ORGANIZATIONAL_UNIT                ;
extern const GUID GUID_C_PACKAGE_REGISTRATION               ;
extern const GUID GUID_C_PERSON                             ;
extern const GUID GUID_C_PHYSICAL_LOCATION                  ;
extern const GUID GUID_C_PKI_CERTIFICATE_TEMPLATE           ;
extern const GUID GUID_C_PKI_ENROLLMENT_SERVICE             ;
extern const GUID GUID_C_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT     ;
extern const GUID GUID_C_PRINT_QUEUE                        ;
extern const GUID GUID_C_QUERY_POLICY                       ;
extern const GUID GUID_C_REMOTE_MAIL_RECIPIENT              ;
extern const GUID GUID_C_REMOTE_STORAGE_SERVICE_POINT       ;
extern const GUID GUID_C_RESIDENTIAL_PERSON                 ;
extern const GUID GUID_C_RID_MANAGER                        ;
extern const GUID GUID_C_RID_SET                            ;
extern const GUID GUID_C_RPC_CONTAINER                      ;
extern const GUID GUID_C_RPC_ENTRY                          ;
extern const GUID GUID_C_RPC_GROUP                          ;
extern const GUID GUID_C_RPC_PROFILE                        ;
extern const GUID GUID_C_RPC_PROFILE_ELEMENT                ;
extern const GUID GUID_C_RPC_SERVER                         ;
extern const GUID GUID_C_RPC_SERVER_ELEMENT                 ;
extern const GUID GUID_C_RRAS_ADMINISTRATION_CONNECTION_POINT     ;
extern const GUID GUID_C_RRAS_ADMINISTRATION_DICTIONARY     ;
extern const GUID GUID_C_SAM_DOMAIN                         ;
extern const GUID GUID_C_SAM_DOMAIN_BASE                    ;
extern const GUID GUID_C_SAM_SERVER                         ;
extern const GUID GUID_C_SECRET                             ;
extern const GUID GUID_C_SECURITY_OBJECT                    ;
extern const GUID GUID_C_SECURITY_PRINCIPAL                 ;
extern const GUID GUID_C_SERVER                             ;
extern const GUID GUID_C_SERVERS_CONTAINER                  ;
extern const GUID GUID_C_SERVICE_ADMINISTRATION_POINT       ;
extern const GUID GUID_C_SERVICE_CLASS                      ;
extern const GUID GUID_C_SERVICE_CONNECTION_POINT           ;
extern const GUID GUID_C_SERVICE_INSTANCE                   ;
extern const GUID GUID_C_SITE                               ;
extern const GUID GUID_C_SITE_LINK                          ;
extern const GUID GUID_C_SITE_LINK_BRIDGE                   ;
extern const GUID GUID_C_SITES_CONTAINER                    ;
extern const GUID GUID_C_STORAGE                            ;
extern const GUID GUID_C_SUBNET                             ;
extern const GUID GUID_C_SUBNET_CONTAINER                   ;
extern const GUID GUID_C_SUBSCHEMA                          ;
extern const GUID GUID_C_TOP                                ;
extern const GUID GUID_C_TRUSTED_DOMAIN                     ;
extern const GUID GUID_C_TYPE_LIBRARY                       ;
extern const GUID GUID_C_USER                               ;
extern const GUID GUID_C_VOLUME                             ;


#endif //_NTDSGUID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdswarn.h ===
// A place to put any DS specific warning pragmas, such as
// #pragma warning(error:4312)  // cast of 32-bit int to 64-bit ptr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\ntdspchx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ntdspchx.h
//
//--------------------------------------------------------------------------
//
//  Contents:   Common Header Files For the DS Project - Precompiled.
//              #include <NTDSpch.h>
//              #pragma  hdrstop
//
//--------------------------------------------------------------------------
#ifndef _NTDSpch_
#define _NTDSpch_


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>


//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>

//
// Common DS Headers
//
#include <ntdsapi.h>

// DS-wide error control
#include <ntdswarn.h>

// Macros to control Prefix
#include <tuneprefix.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\objids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       objids.h
//
//--------------------------------------------------------------------------

/* Contains all hard-coded ATT and CLASS ID's used by the server.   6/13/89
*/

#include <attids.h>

/***************************************************************
* 
* KEEP THESE SORTED BY NUMBER !
*
***************************************************************/

// The attid space is 32bits wide and is divided into the ranges:
//     0x00000000..0x7FFFFFFF - OIDs mapped into attids
//     0x80000000..0xBFFFFFFF - Randomly assigned Internal attids (msDS-IntId)
//     0xC0000000..0xFFFEFFFF - unused at this time.
//     0xFFFF0000..0xFFFFFFFE - Hardcoded fixed attids
//     0xFFFFFFFF             - the invalid attid

// OIDS are mapped into ULONG attids in this range
#define FIRST_MAPPED_ATT        ((ATTRTYP)0x00000000)
#define LAST_MAPPED_ATT         ((ATTRTYP)0x7FFFFFFF)

// IntIds are programmatically assigned in this range
#define FIRST_INTID_PREFIX      ((ATTRTYP)0x8000)
#define FIRST_INTID_ATT         ((ATTRTYP)0x80000000)
#define LAST_INTID_ATT          ((ATTRTYP)0xBFFFFFFF)

#define FIRST_UNUSED_ATT        ((ATTRTYP)0xC0000000)
#define LAST_UNUSED_ATT         ((ATTRTYP)0xFFFEFFFF)

// Fixed attids are hardcoded in this range
/* Fixed columns (High Word = 0xFFFF)  Currently only used by DBGetSingleValue*/
#define FIRST_FIXED_ATT         ((ATTRTYP)0xFFFF0000)
#define FIXED_ATT_ANCESTORS     ((ATTRTYP)0xFFFF0001)
#define FIXED_ATT_DNT           ((ATTRTYP)0xFFFF0002)
#define FIXED_ATT_NCDNT         ((ATTRTYP)0xFFFF0003)
#define FIXED_ATT_OBJ           ((ATTRTYP)0xFFFF0004)
#define FIXED_ATT_PDNT          ((ATTRTYP)0xFFFF0005)
#define FIXED_ATT_REFCOUNT      ((ATTRTYP)0xFFFF0006)
#define FIXED_ATT_RDN_TYPE      ((ATTRTYP)0xFFFF0007)
#define FIXED_ATT_AB_REFCOUNT   ((ATTRTYP)0xFFFF0008)
#define FIXED_ATT_EX_FOREST     ((ATTRTYP)0xFFFF0009)
#define FIXED_ATT_NEEDS_CLEANING ((ATTRTYP)0xFFFF000A)
#define LAST_FIXED_ATT          ((ATTRTYP)0xFFFFFFFE)

// The invalid attid
#define INVALID_ATT             ((ATTRTYP)0xFFFFFFFF)


// these attids are only used internally, temporarily, on a pre thread basis
// they are not present in the prefix table

#define  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY    0xFFFF0010
#define  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY   0xFFFF0011
#define  ATT_MS_DS_NC_REPL_CURSORS_BINARY              0xFFFF0012
#define  ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY     0xFFFF0013
#define  ATT_MS_DS_REPL_VALUE_META_DATA_BINARY         0xFFFF0014


// These are valid values for the ATT_INSTANCE_TYPE.  

// First, the primitive bits

// Note that these bits, must be the same as the bits in ntdsapi.[w||h], note it is a BUGBUG for these
// to be in ntdsapi.w, they should be in ntdsadef.w.  Anyway, when that gets changed this comment
// should be fixed to reflect that one can not change these bits, as thier part of public domain.

// IT_NC_HEAD   == The head of naming context.
#define IT_NC_HEAD     ((SYNTAX_INTEGER) DS_INSTANCETYPE_IS_NC_HEAD)
// IT_UNINSTANT == This is an uninstantiated replica
#define IT_UNINSTANT   ((SYNTAX_INTEGER) 2)
// IT_WRITE     == The object is writable on this directory
#define IT_WRITE       ((SYNTAX_INTEGER) DS_INSTANCETYPE_NC_IS_WRITEABLE)
// IT_NC_ABOVE  == We hold the naming context above this one on this directory
#define IT_NC_ABOVE    ((SYNTAX_INTEGER) 8)
// IT_NC_COMING == The NC is in the process of being constructed for the first
//                 time via replication.
#define IT_NC_COMING   ((SYNTAX_INTEGER) 16)
// IT_NC_GOING  == The NC is in the process of being removed from the local DSA.
#define IT_NC_GOING    ((SYNTAX_INTEGER) 32)

// IT_NC_ABOVE, IT_UNINSTANT, IT_NC_COMING, and IT_NC_GOING are uninteresting
// unless the object they are on is also the head of a naming context, so they
// should be unset if IT_NC_HEAD is unset.

// Mask of all instance type bits understood by the current DSA version.
#define IT_MASK_CURRENT (IT_NC_HEAD | IT_UNINSTANT | IT_WRITE | IT_NC_ABOVE \
                         | IT_NC_COMING | IT_NC_GOING)

// Mask of all instance type bits understood by Win2k DSAs.
#define IT_MASK_WIN2K   (IT_NC_HEAD | IT_UNINSTANT | IT_WRITE | IT_NC_ABOVE)


// INT_* => interior node, NC_*/SUBREF => NC head.
// NC_MASTER* => writeable, NC_FULL_REPLICA* read-only.
// NC_*_SUBREF => serves as both an NC head and a subref.

// Now, the various combinations:
#define INT_MASTER                    ((SYNTAX_INTEGER) (IT_WRITE))
#define SUBREF                        ((SYNTAX_INTEGER) (IT_UNINSTANT | IT_NC_HEAD | IT_NC_ABOVE))
#define INT_FULL_REPLICA              ((SYNTAX_INTEGER) (0))
#define NC_MASTER                     ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD))
#define NC_MASTER_COMING              ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_COMING))
#define NC_MASTER_GOING               ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_GOING))
#define NC_FULL_REPLICA               ((SYNTAX_INTEGER) (IT_NC_HEAD))
#define NC_FULL_REPLICA_COMING        ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_COMING))
#define NC_FULL_REPLICA_GOING         ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_GOING))
#define NC_MASTER_SUBREF              ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE))
#define NC_MASTER_SUBREF_COMING       ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE | IT_NC_COMING))
#define NC_MASTER_SUBREF_GOING        ((SYNTAX_INTEGER) (IT_WRITE | IT_NC_HEAD | IT_NC_ABOVE | IT_NC_GOING))
#define NC_FULL_REPLICA_SUBREF        ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE))
#define NC_FULL_REPLICA_SUBREF_COMING ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE | IT_NC_COMING))
#define NC_FULL_REPLICA_SUBREF_GOING  ((SYNTAX_INTEGER) (IT_NC_HEAD | IT_NC_ABOVE | IT_NC_GOING))

#define ISVALIDINSTANCETYPE(it) \
    ((BOOL) (((it) == INT_MASTER)                    || \
             ((it) == NC_MASTER)                     || \
             ((it) == NC_MASTER_COMING)              || \
             ((it) == NC_MASTER_GOING)               || \
             ((it) == NC_MASTER_SUBREF)              || \
             ((it) == NC_MASTER_SUBREF_COMING)       || \
             ((it) == NC_MASTER_SUBREF_GOING)        || \
             ((it) == INT_FULL_REPLICA)              || \
             ((it) == NC_FULL_REPLICA)               || \
             ((it) == NC_FULL_REPLICA_COMING)        || \
             ((it) == NC_FULL_REPLICA_GOING)         || \
             ((it) == NC_FULL_REPLICA_SUBREF)        || \
             ((it) == NC_FULL_REPLICA_SUBREF_COMING) || \
             ((it) == NC_FULL_REPLICA_SUBREF_GOING)  || \
             ((it) == SUBREF)                        ))

// FExitIt - is 'it' an NC exit point type.
#define FExitIt(it) ((BOOL) ((it) & IT_NC_HEAD))

// FPrefixIt - is 'it' an NC prefix type.
#define FPrefixIt(it) ((BOOL) (((it) & IT_NC_HEAD) && !((it) & IT_UNINSTANT)))

// FPartialReplicaIt - is 'it' a partial NC prefix type.
#define FPartialReplicaIt(it) (FPrefixIt(it) && !((it) & IT_WRITE))

// FMasterIt - is 'it' a master type.
#define FMasterIt(it) ((BOOL) ((it) & IT_WRITE))



/*
 * These are valid values for the ATT_OBJECT_CLASS_CATEGORY.
 */

#define DS_88_CLASS           0
#define DS_STRUCTURAL_CLASS   1
#define DS_ABSTRACT_CLASS     2
#define DS_AUXILIARY_CLASS    3


/***************************************************************
* 
* KEEP THESE SORTED BY NUMBER !
*
***************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\permit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       permit.h
//
//--------------------------------------------------------------------------

/****************************************************************************
*                            permit.h                                       *
*                                                                           *
*  This file contains all the definition used by the directory service to   *
* implement security, as well the prototypes for the apis exposed.          *
*									    *
****************************************************************************/
#include "ntdsapi.h"
//
// Define the rights used in the DS
//

#define	RIGHT_DS_CREATE_CHILD	  ACTRL_DS_CREATE_CHILD
#define RIGHT_DS_DELETE_CHILD     ACTRL_DS_DELETE_CHILD
#define RIGHT_DS_DELETE_SELF      DELETE
#define RIGHT_DS_LIST_CONTENTS    ACTRL_DS_LIST
#define RIGHT_DS_WRITE_PROPERTY_EXTENDED  ACTRL_DS_SELF
#define RIGHT_DS_READ_PROPERTY    ACTRL_DS_READ_PROP
#define RIGHT_DS_WRITE_PROPERTY   ACTRL_DS_WRITE_PROP
#define RIGHT_DS_DELETE_TREE      ACTRL_DS_DELETE_TREE
#define RIGHT_DS_LIST_OBJECT      ACTRL_DS_LIST_OBJECT
#define RIGHT_DS_CONTROL_ACCESS   ACTRL_DS_CONTROL_ACCESS
//
// Define the generic rights
//

#define GENERIC_READ_MAPPING     DS_GENERIC_READ
#define GENERIC_EXECUTE_MAPPING  DS_GENERIC_EXECUTE
#define GENERIC_WRITE_MAPPING    DS_GENERIC_WRITE
#define GENERIC_ALL_MAPPING      DS_GENERIC_ALL

//
// Standard DS generic access rights mapping
//

#define DS_GENERIC_MAPPING {GENERIC_READ_MAPPING,    \
			    GENERIC_WRITE_MAPPING,   \
			    GENERIC_EXECUTE_MAPPING, \
			    GENERIC_ALL_MAPPING}




DWORD
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\samicli2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       samicli2.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains private samlib routines for use by internal clients.

Author:

    DaveStr     12-Mar-99

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMICLI2_
#define _SAMICLI2_

NTSTATUS
SamConnectWithCreds(
    IN  PUNICODE_STRING             ServerName,
    OUT PSAM_HANDLE                 ServerHandle,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    IN  RPC_AUTH_IDENTITY_HANDLE    Creds,
    IN  PWCHAR                      Spn,
    OUT BOOL                        *pfDstIsW2K
    );

#endif // _SAMICLI2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\rpcbind.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       rpcbind.h
//
//--------------------------------------------------------------------------

#ifndef MAC
#define MAX_SUPPORTED_PROTSEQ	6
#else // MAC
//$MAC - add 1 protseq
#define MAX_SUPPORTED_PROTSEQ	7
#endif // MAC

// 
// protocol sequence array indexed by transport type as defined in mds.h 
// and msrpc.h
//

extern unsigned char __RPC_FAR *rgszProtseq[];

RPC_STATUS GetRpcBinding(RPC_BINDING_HANDLE __RPC_FAR *phBinding,
       RPC_IF_HANDLE IfHandle,
    unsigned long ulTransportType,  unsigned char __RPC_FAR *szNetworkAddress);


// flag values GetBindingInfo
#define fServerToServer			0x00000001
#define fSupportNewCredentials		0x00000002

RPC_STATUS GetBindingInfo( void __RPC_FAR * __RPC_FAR *pBindingInfo,
    RPC_IF_HANDLE IfHandle,
    unsigned long ulTransportType, unsigned char __RPC_FAR *szNetworkAddress,
    unsigned long  cServerAddresses,
    unsigned char __RPC_FAR * __RPC_FAR *rgszServerAddresses,
    unsigned long ulFlags);

RPC_BINDING_HANDLE SelectRpcBinding( void __RPC_FAR * BindingInfo);

void FreeRpcBinding(RPC_BINDING_HANDLE __RPC_FAR *phBinding);

void FreeBindingInfo( void __RPC_FAR * BindingInfo);


typedef enum _CONNECTSTATE {offLine, connected, disconnected} CONNECTSTATE;

#ifndef HFILE
#define HFILE   int
#endif

#pragma warning( disable:4200)		// avoid non-standard extension warning
typedef struct _auth_info_buffer {
	struct _auth_info_buffer __RPC_FAR *pNext;
	BYTE rgbAuthInfo[];
} AUTH_INFO_BUFFER;
#pragma warning( default:4200)


typedef struct _RpcConnection {
        // RPC info
    CONNECTSTATE connectState;
    handle_t hBinding;
    void __RPC_FAR * hRpc;
    unsigned long   hServerContext;     // XDS server context for ds_wait
    unsigned long   ulTotRecs;          // OAB info
    unsigned long   ulTotANRdex;        // num of ANR recs
    unsigned long   oRoot;
    char __RPC_FAR * pDNTable;
    HFILE   hBrowse;            // file handle -- note these are NEAR ptrs in Win16
    HFILE   hDetails;
    HFILE   hRDNdex;
    HFILE   hANRdex;
    HFILE   hTmplts;
    ULONG   ulUIParam;
    ULONG   ulMapiFlags;
    ULONG   ulAuthenticationState;
    ULONG   ulAuthenticationFlags;
    RPC_AUTH_IDENTITY_HANDLE hCredentials;
    void __RPC_FAR *pvEmsuiSupportObject;
    AUTH_INFO_BUFFER __RPC_FAR *pBuffer;
} RPCCONNECTION;

// values for ulAuthenticationState
#define	AUTH_STATE_NO_AUTH		0
#define AUTH_STATE_OS_CREDENTIALS	1
#define AUTH_STATE_USER_CREDENTIALS	2


// Flag values for ulAuthenticationFlags
#define fAlwaysLogin			0x00000001
#define fCredentialsCameFromUser	0x00000002
#define fNeedEncryption			0x00000008
#define fInvalidCredentials		0x00000010

RPC_STATUS SetRpcAuthenticationInfo(RPC_BINDING_HANDLE hBinding,
    unsigned long ulAuthnLevel, RPC_AUTH_IDENTITY_HANDLE pAutthId);

RPC_STATUS
SetRpcAuthenticationInfoEx(
    RPC_BINDING_HANDLE          hBinding,
    unsigned char __RPC_FAR *   pszServerPrincName,
    ULONG                       ulAuthnLevel,
    ULONG                       ulAuthnSvc,
    RPC_AUTH_IDENTITY_HANDLE    hAuthId
    );

RPC_STATUS SetAuthInfoWithCredentials(RPC_BINDING_HANDLE hBinding,
    RPCCONNECTION  __RPC_FAR *pConnect);

#if DBG
void
DisplayBinding(RPC_BINDING_HANDLE hBinding);
void
DisplayBindingVector(RPC_BINDING_VECTOR __RPC_FAR *pVector);
#else
#define DisplayBinding(x)
#define DisplayBindingVector(x)
#endif /* DBG */

void ReleaseRpcContextHandle(void __RPC_FAR * __RPC_FAR * ContextHandle);


#ifdef WIN32
DWORD GetRpcAuthLevelFromReg(void);

void SetRpcAuthInfoFromReg(RPC_BINDING_HANDLE hBinding);
#endif

RPC_STATUS StepDownRpcSecurity(RPC_BINDING_HANDLE hBinding);

#define FUnsupportedAuthenticationLevel(status) 			\
    ((status == RPC_S_UNKNOWN_AUTHN_LEVEL) || (status == RPC_S_UNKNOWN_AUTHN_TYPE))

RPC_STATUS
StepDownRpcAuthnService(
    RPC_BINDING_HANDLE  hBinding
    );

#define FUnsupportedAuthenticationService(status) \
    ((status) == RPC_S_UNKNOWN_AUTHN_SERVICE)

// RPC bug - 5 is retuned on win16 for an access denied error so we
// hard code it

#define FPasswordInvalid(status) ((status == RPC_S_ACCESS_DENIED) || (status == 5))

void FreeAuthenticationBufferList(AUTH_INFO_BUFFER __RPC_FAR * __RPC_FAR * ppBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\samisrv2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       samisrv2.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contain private routines for use by Trusted SAM clients
    which live in the same process as the SAM server in NT5.

Author:

    Colin Watson (ColinW) 23-Aug-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMISRV2_
#define _SAMISRV2_



NTSTATUS
SamIImpersonateNullSession(
    );

NTSTATUS
SamIRevertNullSession(
    );

#endif // _SAMISRV2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\taskq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       taskq.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

    01/10/97    Jeff Parham (jeffparh)

REVISION HISTORY:
    01/28/00    Xin He (xinhe)
                Moved struct TQEntry into taskq.h from taskq.c.
                Struct TQEntry is only for internal use, and is put
                into taskq.h because debugger extension program needs it.

    01/22/97    Jeff Parham (jeffparh)
                Modified PTASKQFN definition such that a queued function
                can automatically reschedule itself without making another
                call to InsertTaskInQueue().  This mechanism reuses
                already allocated memory in the scheduler to avoid the
                case where a periodic function stops working when at
                some point in its lifetime a memory shortage prevented
                it from rescheduling itself.

Note, the functions provided by taskq\taskq.c are also stubbed out in mkdit\stubs.c
on behalf of the standalone tools mkdit and mkhdr.  If you add new task queue functions
you may need to stub them out also.

--*/

#define TASKQ_DONT_RESCHEDULE   ( 0xFFFFFFFF )

extern DWORD gTaskSchedulerTID;
extern BOOL  gfIsTqRunning;

typedef void (*PTASKQFN)(
    IN  void *  pvParam,                // input parameter for this iteration
    OUT void ** ppvParamNextIteration,  // input parameter for next iteration
    OUT DWORD * pSecsUntilNextIteration // delay until next iteration in seconds
                                        //     set to TASKQ_DONT_RESCHEDULE to
                                        //     not reschedule the task
    );

typedef void (*PSPAREFN)(void);

typedef struct _SPAREFN_INFO {
    HANDLE    hevSpare;
    PSPAREFN  pfSpare;
} SPAREFN_INFO;


//for internal use only
typedef struct TQEntry
{
    void           *    pvTaskParm;
    DWORD               cTickRegistered;
    DWORD               cTickDelay;
    PTASKQFN            pfnTaskFn;
    PCHAR               pfnName;
}   TQEntry, *pTQEntry;

// Initialize task scheduler.
BOOL
InitTaskScheduler(
    IN  DWORD           cSpares,
    IN  SPAREFN_INFO *  pSpares
    );

// Signal task scheduler to shut down.  Returns immediately
void
ShutdownTaskSchedulerTrigger( void );

// Waits for the task scheduler to shut down
// Returns TRUE if successful (implying current task, if any, ended).
BOOL
ShutdownTaskSchedulerWait(
    DWORD   dwWaitTimeInMilliseconds    // maximum time to wait for current
    );                                  //   task (if any) to complete

extern BOOL gfIsTqRunning;  // is the scheduler running?

// Insert a task in the task queue.
// Contains useful debugging assertions.
// note that when in singleusermode, we will not insert in the taskqueue
// but we don't want to assert
#define InsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow) {                               \
    Assert( gfIsTqRunning && "InsertInTaskQueue() called before InitTaskScheduler()!" || DsaIsSingleUserMode()); \
    DoInsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow, FALSE, #pfnTaskQFn);    \
}

// Insert a task in the task queue.
// Does not contain assertions.  Useful during shutdown.
#define InsertInTaskQueueSilent(pfnTaskQFn, pvParam, cSecsFromNow, fReschedule) \
        DoInsertInTaskQueue(pfnTaskQFn, pvParam, cSecsFromNow, fReschedule, #pfnTaskQFn)
        
// Remove a task from task queue (if it's there).
// (Ignore time data).
#define CancelTask(pfnTaskQFn, pvParam) \
        DoCancelTask(pfnTaskQFn, pvParam, #pfnTaskQFn)

// Cause the given task queue function to be executed synchonously with respect
// to other tasks in the task queue.
#define TriggerTaskSynchronously(pfnTaskQFn, pvParam) \
        DoTriggerTaskSynchronously(pfnTaskQFn, pvParam, #pfnTaskQFn)

BOOL
DoInsertInTaskQueue(
    PTASKQFN    pfnTaskQFn,     // task to execute
    void *      pvParam,        // user-defined parameter to that task
    DWORD       cSecsFromNow,   // secs from now to execute
    BOOL        fReschedule,    // attempt reschedule first?
    PCHAR       pfnName         // function name
    );

BOOL
DoCancelTask(
    PTASKQFN    pfnTaskQFn,    // task to remove
    void *      pvParm,        // task parameter
    PCHAR       pfnName         // function name
    );

DWORD
DoTriggerTaskSynchronously(
    PTASKQFN    pfnTaskQFn,
    void *      pvParm,
    PCHAR       pfnName         // function name
    );

// Return seconds since Jan 1, 1601.
DSTIME
GetSecondsSince1601( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\w32topl.h ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    w32topl.h

Abstract:

    This file contains the dll entrypoint declarations for the w32topl.dll

    The purpose of this module is provide a simple mechanism to manipulate
    a graph data structure and to provide a useful set of pre-written 
    graph analysis routines.
    
    These functions perform in-memory actions only - there is no device IO.
    As such it is expected that errors are few and occur rarly. Thus,
    the error handling model is exception based.  All function calls in this
    module should be called from within a try/except block.
    
    All data types are in fact typeless.   However run-time type checking is
    enforced and a failure will cause an exception to be thrown with the 
    error TOPL_WRONG_OBJECT.  This includes the scenario when a deleted
    object is reused.

    The two common error codes for raised exceptions are 
    
    TOPL_OUT_OF_MEMORY : this indicates a memory allocation failed.
    
    and
    
    TOPL_WRONG_OBJECT  : this indicates an object passed in not of the
                         type specfied by the function parameter list    
    
    Individual functions may have additional parameter checks too. See function
    comments below for details.
    
               
Author:

    Colin Brace  (ColinBr)
    
Revision History

    3-12-97   ColinBr    Created
    6-9-00    NickHar    Add New W32TOPL Functionality
    
--*/

#ifndef __W32TOPL_H
#define __W32TOPL_H

//
// Other header files for new w32topl functionality
//
#include "w32toplsched.h"
#include "w32toplspantree.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// Exception Error codes raised from this module
//

// The TOPL_EX_PREFIX indicates that the error code is an error (not a warning, etc)
// and will not conflict with any system exception codes.
//
#define ERROR_CODE     (0x3 << 30)
#define CUSTOMER_CODE  (0x1 << 29)
#define TOPL_EX_PREFIX (ERROR_CODE | CUSTOMER_CODE)


//
// These can be thrown be all Topl* functions
//
#define TOPL_EX_OUT_OF_MEMORY             (TOPL_EX_PREFIX | (0x1<<1))   /* 2 */
#define TOPL_EX_WRONG_OBJECT              (TOPL_EX_PREFIX | (0x1<<2))   /* 4 */

// These are specialized errors
#define TOPL_EX_INVALID_EDGE              (TOPL_EX_PREFIX | (0x1<<3))   /* 8 */
#define TOPL_EX_INVALID_VERTEX            (TOPL_EX_PREFIX | (0x1<<4))   /* 16 */
#define TOPL_EX_INVALID_INDEX             (TOPL_EX_PREFIX | (0x1<<5))   /* 32 */

// Schedule Manager reserves error codes from 100-199
// New Spanning Tree algorithm reserves error codes from 200-299

int
ToplIsToplException(
    DWORD ErrorCode
    );

//
// Type definitions of w32topl objects
//

typedef VOID* TOPL_LIST_ELEMENT;
typedef VOID* TOPL_LIST;
typedef VOID* TOPL_ITERATOR;

// both TOPL_EDGE and TOPL_VERTEX can be treated as TOPL_LIST_ELEMENT
typedef VOID* TOPL_EDGE;
typedef VOID* TOPL_VERTEX;
typedef VOID* TOPL_GRAPH;


//
// List manipulation routines
//

TOPL_LIST
ToplListCreate(
    VOID
    );

VOID 
ToplListFree(
    IN TOPL_LIST List,
    IN BOOLEAN   fRecursive   // TRUE implies free the elements contained 
                              // in the list
    );

VOID
ToplListSetIter(
    IN TOPL_LIST     List,
    IN TOPL_ITERATOR Iterator
    );

//
// Passing NULL for Elem removes the first element from the list if any
//
TOPL_LIST_ELEMENT
ToplListRemoveElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    );

VOID
ToplListAddElem(
    IN TOPL_LIST         List,
    IN TOPL_LIST_ELEMENT Elem
    );


DWORD
ToplListNumberOfElements(
    IN TOPL_LIST         List
    );

//
// Iterator object routines
//

TOPL_ITERATOR
ToplIterCreate(
    VOID
    );

VOID 
ToplIterFree(
    IN TOPL_ITERATOR Iterator
    );

TOPL_LIST_ELEMENT
ToplIterGetObject(
    IN TOPL_ITERATOR Iterator
    );

VOID
ToplIterAdvance(
    IN TOPL_ITERATOR Iterator
    );

//
// Edge object routines
//

TOPL_EDGE
ToplEdgeCreate(
    VOID
    );

VOID
ToplEdgeFree(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeSetToVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX ToVertex
    );

TOPL_VERTEX
ToplEdgeGetToVertex(
    IN TOPL_EDGE   Edge
    );

VOID
ToplEdgeSetFromVertex(
    IN TOPL_EDGE   Edge,
    IN TOPL_VERTEX FromVertex
    );

TOPL_VERTEX
ToplEdgeGetFromVertex(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeAssociate(
    IN TOPL_EDGE Edge
    );

VOID
ToplEdgeDisassociate(
    IN TOPL_EDGE Edge
    );


VOID
ToplEdgeSetWeight(
    IN TOPL_EDGE Edge,
    IN DWORD     Weight
    );

DWORD
ToplEdgeGetWeight(
    IN TOPL_EDGE Edge
    );


//
// Vertex object routines
//

TOPL_VERTEX
ToplVertexCreate(
    VOID
    );

VOID
ToplVertexFree(
    IN TOPL_VERTEX Vertex
    );

VOID
ToplVertexSetId(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Id
    );

DWORD
ToplVertexGetId(
    IN TOPL_VERTEX Vertex
    );

DWORD
ToplVertexNumberOfInEdges(
    IN TOPL_VERTEX Vertex
    );

TOPL_EDGE
ToplVertexGetInEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    );

DWORD
ToplVertexNumberOfOutEdges(
    IN TOPL_VERTEX Vertex
    );

TOPL_EDGE
ToplVertexGetOutEdge(
    IN TOPL_VERTEX Vertex,
    IN DWORD       Index
    );

VOID
ToplVertexSetParent(
    IN TOPL_VERTEX Vertex,
    IN TOPL_VERTEX Parent
    );

TOPL_VERTEX
ToplVertexGetParent(
    IN TOPL_VERTEX Vertex
    );

//
// Graph object routines
//

TOPL_GRAPH
ToplGraphCreate(
    VOID
    );

VOID
ToplGraphFree(
    IN TOPL_GRAPH Graph,
    IN BOOLEAN    fRecursive    // TRUE implies recursively free the vertices
                                // that have been added to this graph
    );   

VOID
ToplGraphAddVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToAdd,
    IN PVOID       VertexName
    );

TOPL_VERTEX
ToplGraphRemoveVertex(
    IN TOPL_GRAPH  Graph,
    IN TOPL_VERTEX VertexToRemove
    );
      
VOID
ToplGraphSetVertexIter(
    IN TOPL_GRAPH    Graph,
    IN TOPL_ITERATOR Iter
    );

DWORD
ToplGraphNumberOfVertices(
    IN TOPL_GRAPH    Graph
    );


//
// This can used to release arrays of objects that may be passed back.
// It should not be used to free object themselves - use the appropriate
// Topl*Free() routines.
//

VOID
ToplFree(
    VOID *p
    );


//
// Can be used to change the default memory allocation routines used by this
// library.  Settings are per-thread.
//
typedef VOID * (TOPL_ALLOC)(DWORD size);
typedef VOID * (TOPL_REALLOC)(VOID *, DWORD size);
typedef VOID (TOPL_FREE)(VOID *);

DWORD
ToplSetAllocator(
    IN  TOPL_ALLOC *    pfAlloc     OPTIONAL,
    IN  TOPL_REALLOC *  pfReAlloc   OPTIONAL,
    IN  TOPL_FREE *     pfFree      OPTIONAL
    );


//
// General graph analysis routines
//

//
// The Flags parameter must be set to exactly one of these values
//
#define TOPL_RING_ONE_WAY   (0x1 << 1)
#define TOPL_RING_TWO_WAY   (0x1 << 2)

VOID
ToplGraphMakeRing(
    IN TOPL_GRAPH  Graph,
    IN DWORD       Flags,
    OUT TOPL_LIST  EdgesToAdd,
    OUT TOPL_EDGE  **EdgesToKeep,
    OUT ULONG      *cEdgesToKeep
    );


// Note: Caller must user ToplDeleteComponents() to free the
// TOPL_COMPONENTS structure.
TOPL_COMPONENTS*
ToplGraphFindEdgesForMST(
    IN  TOPL_GRAPH  Graph,
    IN  TOPL_VERTEX RootVertex,
    IN  TOPL_VERTEX VertexOfInterest,
    OUT TOPL_EDGE  **EdgesNeeded,
    OUT ULONG*      cEdgesNeeded
    );


#ifdef __cplusplus  
};
#endif

//
// For c++ users
//
//
typedef enum {

    eEdge,
    eVertex,
    eGraph,
    eList,
    eIterator,
    eInvalidObject

}TOPL_OBJECT_TYPE;

//
// Private type definitions
//

typedef struct {

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    SINGLE_LIST_ENTRY Head;
    ULONG             NumberOfElements;

}LIST, *PLIST;

typedef struct {

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    PSINGLE_LIST_ENTRY pLink;

} ITERATOR, *PITERATOR;

typedef struct {

    VOID  **Array;
    DWORD   Count;
    DWORD   ElementsAllocated;

}DYNAMIC_ARRAY, *PDYNAMIC_ARRAY;

struct _ListElement; 

typedef struct
{     

#ifdef __cplusplus
private:
#endif

    struct _ListElement* To;
    struct _ListElement* From;
    DWORD   Weight;


} EDGE_DATA, *PEDGE_DATA;

typedef struct
{

#ifdef __cplusplus
private:
#endif

    DWORD         Id;
    PVOID          VertexName;
    DYNAMIC_ARRAY InEdges;
    DYNAMIC_ARRAY OutEdges;

    struct _ListElement* Parent;

} VERTEX_DATA, *PVERTEX_DATA;
        
//
// Vertex, edge and graph definitions
//
struct _ListElement
{

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE     ObjectType;

    SINGLE_LIST_ENTRY    Link;

    union {
        VERTEX_DATA VertexData;
        EDGE_DATA   EdgeData;
    };

};

typedef struct _ListElement  EDGE;
typedef struct _ListElement* PEDGE;

typedef struct _ListElement  VERTEX;
typedef struct _ListElement* PVERTEX;

typedef struct _ListElement  LIST_ELEMENT;
typedef struct _ListElement* PLIST_ELEMENT;

typedef struct
{

#ifdef __cplusplus
private:
#endif

    TOPL_OBJECT_TYPE  ObjectType;

    LIST VertexList;

} GRAPH, *PGRAPH;

#ifdef __cplusplus
extern "C" {
#endif

VOID
ToplVertexInit(
    PVERTEX
    );

VOID
ToplVertexDestroy(
    PVERTEX
    );

VOID
ToplEdgeInit(
    PEDGE
    );

VOID
ToplEdgeDestroy(
    PEDGE
    );

VOID
ToplGraphInit(
    PGRAPH
    );

VOID
ToplGraphDestroy(
    PGRAPH
    );

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

class CTOPL_VERTEX;
class CTOPL_EDGE;
class CTOPL_GRAPH;



//
// Class definitions
//

class CTOPL_VERTEX : public VERTEX
{
public:

    CTOPL_VERTEX()
    {   
        ToplVertexInit((PVERTEX)this);
    }
    
    ~CTOPL_VERTEX()
    {
        ToplVertexDestroy((PVERTEX)this);
    }

    VOID
    ClearEdges(VOID) 
    {
        ToplVertexDestroy((PEDGE)this);
        ToplVertexInit((PEDGE)this);
    }

    VOID
    SetId(DWORD id)
    {
        ToplVertexSetId((PVERTEX)this, id);
    }

    DWORD
    GetId(VOID)
    {
        return ToplVertexGetId((PVERTEX)this);
    }

    DWORD
    NumberOfInEdges(void)
    {
        return ToplVertexNumberOfInEdges((PEDGE)this);
    }

    CTOPL_EDGE*
    GetInEdge(DWORD Index)
    {
        return (CTOPL_EDGE*)ToplVertexGetInEdge((PEDGE)this, Index);
    }

    DWORD
    NumberOfOutEdges(void)
    {
        return ToplVertexNumberOfOutEdges((PEDGE)this);
    }

    CTOPL_EDGE*
    GetOutEdge(DWORD Index)
    {
        return (CTOPL_EDGE*)ToplVertexGetOutEdge((PEDGE)this, Index);
    }

};

class CTOPL_EDGE : public EDGE
{
public:

    CTOPL_EDGE()
    {   
        ToplEdgeInit((PEDGE)this);
    }
    
    ~CTOPL_EDGE()
    {
        ToplEdgeDestroy((PEDGE)this);
    }


    VOID
    SetTo(CTOPL_VERTEX* V)
    {
        ToplEdgeSetToVertex((PEDGE)this, (PVERTEX)V);
    }

    VOID
    SetFrom(CTOPL_VERTEX* V)
    {
        ToplEdgeSetFromVertex((PEDGE)this, (PVERTEX)V);
    }

    CTOPL_VERTEX*
    GetTo()
    {
        return (CTOPL_VERTEX*)ToplEdgeGetToVertex((PEDGE)this);
    }

    CTOPL_VERTEX*
    GetFrom()
    {
        return (CTOPL_VERTEX*)ToplEdgeGetFromVertex((PEDGE)this);
    }

    VOID
    SetWeight(DWORD Weight)
    {
        ToplEdgeSetWeight((PEDGE)this, Weight);
    }

    DWORD
    GetWeight(void)
    {
        return ToplEdgeGetWeight((PEDGE)this);
    }

    VOID
    Associate(void)
    {
        ToplEdgeAssociate((PEDGE)this);
    }

    VOID
    Disassociate(void)
    {
        ToplEdgeDisassociate((PEDGE)this);
    }
};

class CTOPL_GRAPH : public GRAPH
{
public:


    CTOPL_GRAPH()
    {   
        ToplGraphInit((PGRAPH)this);
    }
    
    ~CTOPL_GRAPH()
    {
        ToplGraphDestroy((PGRAPH)this);
    }

    void
    // The KCC passes a KCC_SITE object in as a CTOPL_VERTEX and, because
    // of multiple inheritence, the pointer gets adjusted. W32TOPL later needs to add
    // the Vertex to a TOPL_COMPONENT structure, which contains a PVOID. The KCC
    // will examine the TOPL_COMPONENT structure and expect to receive a KCC_SITE.
    // However, because the pointer has been adjusted, it will receive a bogus pointer.
    // In order to work around this problem, this function takes a second parameter,
    // VertexName, which is of type PVOID and thus does not get adjusted.
    AddVertex(CTOPL_VERTEX *VertexToAdd, PVOID VertexName)
    {
        ToplGraphAddVertex((PGRAPH) this, (PVERTEX)VertexToAdd, VertexName);
    }

    void
    RemoveVertex(CTOPL_VERTEX *VertexToRemove)
    {
        ToplGraphRemoveVertex((PGRAPH) this, (PVERTEX)VertexToRemove);
    }
      
    void
    SetVertexIter(TOPL_ITERATOR Iter)
    {
        ToplGraphSetVertexIter((PGRAPH) this, Iter);
    }

    DWORD
    NumberOfVertices(void)
    {
        return ToplGraphNumberOfVertices((PGRAPH) this);
    }

    VOID
    MakeRing(IN DWORD       Flags,
             OUT TOPL_LIST  EdgesToAdd,
             OUT TOPL_EDGE  **EdgesToKeep,
             OUT ULONG      *cEdgesToKeep)
    {
        ToplGraphMakeRing((PGRAPH)this,
                          Flags,
                          EdgesToAdd,
                          EdgesToKeep,
                          cEdgesToKeep);
    }

    // Note: Caller must user ToplDeleteComponents() to free the
    // TOPL_COMPONENTS structure.
    TOPL_COMPONENTS*
    FindEdgesForMST(
        IN  CTOPL_VERTEX* RootVertex,
        IN  CTOPL_VERTEX* VertexOfInterest,
        OUT CTOPL_EDGE  ***EdgesNeeded,
        OUT ULONG*      cEdgesNeeded )
    {
        return ToplGraphFindEdgesForMST((PGRAPH) this,
                                        (TOPL_VERTEX)RootVertex,
                                        (TOPL_VERTEX)VertexOfInterest,
                                        (TOPL_EDGE**)EdgesNeeded,
                                        cEdgesNeeded );
    }

};

#endif // __cplusplus


#endif // __W32TOPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\_hindex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       _hindex.h
//
//--------------------------------------------------------------------------

/*
 * Constants used to refer to indices in the stat block used in the 
 * MAPI interface. 
 *
 */

/* NOTE: H_DISPLAYNAME_INDEX and H_WHEN_CHANGED_INDEX are the only ones
 * currently supported in a general way.  The others are for special
 * purpose code in the DSA itself.
 */

#define H_DISPLAYNAME_INDEX     0
#define H_WHEN_CHANGED_INDEX    1
#define H_PROXY_INDEX           2
#define AB_MAX_SUPPORTED_INDEX  2

#define H_READ_TABLE_INDEX   1000
#define H_WRITE_TABLE_INDEX  1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\cxx\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.cxx
//
//--------------------------------------------------------------------------

#include <ntdspchx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\c\pch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.c
//
//--------------------------------------------------------------------------

#include <ntdspch.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\w32toplsched.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    w32toplsched.h

Abstract:

    This file provides the interfaces for working with the new schedule cache,
    and some new 'helper' functions for working with schedules. 

Author:

    Nick Harvey    (NickHar)
    
Revision History

    13-6-2000   NickHar   Created
    
--*/

#ifndef SCHEDMAN_H
#define SCHEDMAN_H

/***** Header Files *****/
#include <schedule.h>

#ifdef __cplusplus
extern "C" {
#endif

/***** Data Structures *****/
/* These structures are opaque */
typedef PVOID TOPL_SCHEDULE;
typedef PVOID TOPL_SCHEDULE_CACHE;

/***** Exceptions *****/
/* Schedule Manager reserves error codes from 100-199 */
#define TOPL_EX_NULL_POINTER              (TOPL_EX_PREFIX | 101)
#define TOPL_EX_SCHEDULE_ERROR            (TOPL_EX_PREFIX | 102)
#define TOPL_EX_CACHE_ERROR               (TOPL_EX_PREFIX | 103)
#define TOPL_EX_NEVER_SCHEDULE            (TOPL_EX_PREFIX | 104)

/***** ToplScheduleCacheCreate *****/
/* Create a cache */
TOPL_SCHEDULE_CACHE
ToplScheduleCacheCreate(
	VOID
	);

/***** ToplScheduleCacheDestroy *****/
/* Destroy the cache. Frees all storage occupied by the cache and any handles
 * in the cache. The TOPL_SCHEDULE objects are also freed, and should not be
 * used after destroying the cache that they live in. */
VOID
ToplScheduleCacheDestroy(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
	);

/***** ToplScheduleImport *****/
/* Store an external schedule in the cache, either creating a new entry or
 * reusing an existing one. No expectations are made around the memory
 * allocator of pExternalSchedule. The pExternalSchedule parameter is copied
 * into the cache, and may be immediately freed by the caller.
 * If pExternalSchedule is NULL, this is interpreted as the 'always schedule'.
 * Schedules whose bits are all 0 (the 'never schedule') are acceptable for
 * importing into the cache. */
TOPL_SCHEDULE
ToplScheduleImport(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN PSCHEDULE pExternalSchedule
	);

/***** ToplScheduleNumEntries *****/
/* Returns a count of how many unique schedules are stored in the cache.
 * Note: this count does not include any always schedules that were
 * imported into the cache. */
DWORD
ToplScheduleNumEntries(
    IN TOPL_SCHEDULE_CACHE ScheduleCache
    );

/***** ToplScheduleExportReadonly *****/
/* Obtain a pointer to an external schedule given a TOPL_SCHEDULE object.
 * The exported schedule is considered readonly by the caller and should
 * not be deallocated by him. 
 * Note: If the input is TOPL_ALWAYS_SCHEDULE, a properly constructed
 * PSCHEDULE _will_ be returned. */
PSCHEDULE
ToplScheduleExportReadonly(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplScheduleMerge *****/
/* Return a new cached schedule which is the intersection of the two provided 
 * schedules. If the two schedules do not intersect, the fIsNever flag is set
 * to true (but an 'always unavailable' schedule is returned.) */
TOPL_SCHEDULE
ToplScheduleMerge(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2,
    OUT PBOOLEAN fIsNever
	);

/***** ToplScheduleCreate *****/
/* Create a new schedule in the cache according to the criteria.  If the
 * template schedule is given, it is used as the basis for the new schedule, else
 * the ALWAYS schedule is used. A new schedule is formed by finding the first
 * active period, marking it, skipping ahead by interval specified, and repeating. */
TOPL_SCHEDULE
ToplScheduleCreate(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN DWORD IntervalInMinutes,
	IN TOPL_SCHEDULE TemplateSchedule OPTIONAL
	);

/***** ToplScheduleIsEqual *****/
/* This function indicates whether two schedule handles refer to the same schedule.
 * This may simply be check for pointer equality internally, but we don't want to
 * expose that knowledge to the caller. */
BOOLEAN
ToplScheduleIsEqual(
	IN TOPL_SCHEDULE_CACHE ScheduleCache,
	IN TOPL_SCHEDULE Schedule1,
	IN TOPL_SCHEDULE Schedule2
	);

/***** ToplScheduleDuration *****/
/* Return the number of minutes in use by the given schedule. */
DWORD
ToplScheduleDuration(
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplScheduleMaxUnavailable *****/
/* Return the length in minutes of the longest contiguous period
 * of time for which the schedule is unavailable. */
DWORD
ToplScheduleMaxUnavailable(
	IN TOPL_SCHEDULE Schedule
	);

/***** ToplGetAlwaysSchedule *****/
/* Return the 'always schedule' */
TOPL_SCHEDULE
ToplGetAlwaysSchedule(
	IN TOPL_SCHEDULE_CACHE ScheduleCache
    );

/***** ToplScheduleValid *****/
/* Returns true if a topl schedule appears to be valid, false otherwise.
 * NULL schedules are accepted -- they are interpreted to mean the
 * 'always schedule'. */
BOOLEAN
ToplScheduleValid(
    IN TOPL_SCHEDULE Schedule
    );

/***** ToplPScheduleValid *****/
/* Returns true if a pschedule is in a supported format, false otherwise.
 * Never schedules are not supported. */
BOOLEAN
ToplPScheduleValid(
    IN PSCHEDULE Schedule
    );

#ifdef __cplusplus
}
#endif

#endif // SCHEDMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\_entryid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1986 - 1999
//
//  File:       _entryid.h
//
//--------------------------------------------------------------------------

/*
** --_entryid.h----------------------------------------------------------------
**
**  Header file describing internal structure of EntryIDs returned
**  by Exchange Address Book provider.
**
** ----------------------------------------------------------------------------
*/

#ifndef _ENTRYID_
#define _ENTRYID_

/*
 *  The version of this ABPs entryids
 */
#define EMS_VERSION         0x000000001

/*
 * The version of the entryids supported by the CreateEntry method in this 
 * ABP.
 */
#define NEW_OBJ_EID_VERSION 0x00000002

/*
 *  Valid values for the entry id's Type field are Mapi Display Types, plus:
 */
#define AB_DT_CONTAINER     0x000000100
#define AB_DT_TEMPLATE      0x000000101
#define AB_DT_OOUSER        0x000000102
#define AB_DT_SEARCH        0x000000200

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}

/*
 *  Directory entry id structure
 *
 *  This entryid is permanent.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _dir_entryid
#else
typedef struct _dir_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
} DIR_ENTRYID, FAR * LPDIR_ENTRYID;

#define CBDIR_ENTRYID sizeof(DIR_ENTRYID)

/*
 *  Mail user entry id structure
 *
 *  This entryid is ephemeral.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_entryid
#else
typedef struct _usr_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    DWORD dwEph;
} USR_ENTRYID, FAR * LPUSR_ENTRYID;

/*
 *  This entryid is permanent.
 */
/* turn off the warning for the unsized array */
#pragma warning (disable:4200)
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_permid
#else
typedef struct _usr_permid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    char  szAddr[];
} USR_PERMID, FAR * LPUSR_PERMID;
#pragma warning (default:4200)

#define CBUSR_ENTRYID sizeof(USR_ENTRYID)
#define CBUSR_PERMID sizeof(USR_PERMID)

#define EPHEMERAL   (UCHAR)(~(  MAPI_NOTRECIP      \
                              | MAPI_THISSESSION   \
                              | MAPI_NOW           \
                              | MAPI_NOTRESERVED))


#endif  /* _ENTRYID_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\inc\w32toplspantree.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    w32toplspantree.h

Abstract:

    This file provides the interfaces for invoking w32topl's new graph algorithms,
    which are used for calculating network topologies.

Memory Responsibilities:

    W32TOPL is responsible for:
        The graph state
        The multi-edges
        The output edges from the spanning-tree algorithm
        The components
    
    The user must allocate:
        All vertex names
        The list of pointers to vertex names
        The schedule cache
        The vertices for edges
        The edge sets
        The list of color vertices

Author:

    Nick Harvey    (NickHar)
    
Revision History

    19-6-2000   NickHar   Created
    14-7-2000   NickHar   Initial development complete, submit to source control
    
--*/

#ifndef W32TOPLSPANTREE_H
#define W32TOPLSPANTREE_H

/***** Header Files *****/
#include "w32toplsched.h"

#ifdef __cplusplus
extern "C" {
#endif

/***** Exceptions *****/
/* New Spanning Tree algorithm reserves error codes from 200-299. The meanings
 * of these errors are explained in the comments of any functions that raise them. */
#define TOPL_EX_GRAPH_STATE_ERROR         (TOPL_EX_PREFIX | 201)
#define TOPL_EX_INVALID_EDGE_TYPE         (TOPL_EX_PREFIX | 202)
#define TOPL_EX_INVALID_EDGE_SET          (TOPL_EX_PREFIX | 203)
#define TOPL_EX_COLOR_VTX_ERROR           (TOPL_EX_PREFIX | 204)
#define TOPL_EX_ADD_EDGE_AFTER_SET        (TOPL_EX_PREFIX | 205)
#define TOPL_EX_TOO_FEW_VTX               (TOPL_EX_PREFIX | 206)
#define TOPL_EX_TOO_FEW_EDGES             (TOPL_EX_PREFIX | 207)
#define TOPL_EX_NONINTERSECTING_SCHEDULES (TOPL_EX_PREFIX | 208)


/***** TOPL_GRAPH_STATE *****/
/* This structure is opaque */
typedef PVOID PTOPL_GRAPH_STATE;


/***** TOPL_REPL_INFO *****/
/* This structure describes the configured replication parameters of a graph edge.
 * When determining the replication parameters for a path (a sequence of edges),
 * the replication parameters are combined as follows:
 *  - The combined cost of two edges is the sum of the costs of the two edges.
 *    This sum will saturate at the maximum value of a DWORD.
 *  - The replication interval of two edges is the maximum of the replication
 *    intervals of the two edges.
 *  - The combined options of two edges is the logical AND of the options of the
 *    individual edges.
 *  - The combined schedule of two edges is formed by calling ToplScheduleMerge()
 *    function on the schedules of the individual edges. The semantics of that
 *    function are specified elsewhere.
 * Note that a NULL schedule implicitly means the 'always schedule'.
 */
typedef struct {
    DWORD               cost;
    DWORD               repIntvl;
    DWORD               options;
    TOPL_SCHEDULE       schedule;
} TOPL_REPL_INFO;
typedef TOPL_REPL_INFO *PTOPL_REPL_INFO;


/***** TOPL_NAME_STRUCT *****/
/* This structure contains a pointer to the name of a vertex and a 'reserved'
 * field, which is used internally for efficiency purposes. The user should
 * not set or examine the reserved field. */
typedef struct {
    PVOID   name;
    DWORD   reserved;
} TOPL_NAME_STRUCT;


/***** TOPL_MULTI_EDGE *****/
/* This structure is used to specify a connection between a set of vertices.
 * There can be multiple edges connecting the same set of vertices, hence the
 * name 'multi-edge'. Since the edge can connect more than 2 vertices, it
 * should be called a 'hyper-multi-edge', but that's not a very nice name. This
 * object acts like a fully connected subgraph of all vertices it contains.
 * When building a spanning tree, any combination of end-points can be chosen
 * for tree edges.  Each edge also has an associated 'edge type'. Vertices can
 * choose whether or not to permit spanning-tree edges of a given type (see
 * 'TOPL_COLOR_VERTEX'). The 'fDirectedEdge' flag is used only in edges output from
 * ToplGetSpanningTreeEdgesForVtx(). It can be ignored for input edges. */
typedef struct {
    DWORD               numVertices;
    DWORD               edgeType;       /* Legal values are 0..31 */
    TOPL_REPL_INFO      ri;
    BOOLEAN             fDirectedEdge;
    TOPL_NAME_STRUCT    vertexNames[1];
} TOPL_MULTI_EDGE;
typedef TOPL_MULTI_EDGE *PTOPL_MULTI_EDGE;


/***** TOPL_MULTI_EDGE_SET *****/
/* This structure contains a set of multi-edges. It essentially describes a
 * 'universe of transitivity'. Replication data can flow transitively from
 * one edge to another if all those edges are contained in some multi-edge set.
 * All edges within an edge set must have the same edge type. Every multi-edge
 * set should contain at least 2 edges.
 */
typedef struct {
    DWORD               numMultiEdges;
    PTOPL_MULTI_EDGE   *multiEdgeList;
} TOPL_MULTI_EDGE_SET;
typedef TOPL_MULTI_EDGE_SET *PTOPL_MULTI_EDGE_SET;


/***** TOPL_VERTEX_COLOR *****/
/* Used to specify the type of the graph's vertices. White vertices are
 * used only for finding paths between colored vertices. Red and black
 * vertices are more important -- they are the vertices that are part of
 * the spanning tree. In a sense, red vertices have higher 'priority'
 * than black vertices. */
typedef enum {
    COLOR_WHITE,        
    COLOR_RED,          
    COLOR_BLACK
} TOPL_VERTEX_COLOR;


/***** TOPL_COLOR_VERTEX *****/
/* This structure defines additional configuration information for a vertex,
 * including its color (red, black), and the edgeTypes it will accept. White
 * (non-colored) vertices do not need to use this structure to specify
 * additional information. 
 * 
 * When choosing spanning tree edges incident with a vertex, we can use this
 * structure to refuse edges of a certain type. In fact, we have even more
 * flexibility than that -- we can choose to refuse edges which connect two
 * red vertices, but accept edges whose endpoints are red-black or black-black.
 * For example, to accept a red-red edge of type i, set the i'th bit of
 * 'acceptRedRed' to 1. To deny a red-black edge of type j, set the j'th bit
 * of 'acceptBlack' to 0. */
typedef struct {
    PVOID               name;
    TOPL_VERTEX_COLOR   color;
    DWORD               acceptRedRed;
    DWORD               acceptBlack;
} TOPL_COLOR_VERTEX;
typedef TOPL_COLOR_VERTEX *PTOPL_COLOR_VERTEX;


/***** TOPL_COMPONENT *****/
/* This structure describes a single component of a spanning forest. */
typedef struct {
    DWORD               numVertices;
    PVOID              *vertexNames;
} TOPL_COMPONENT;


/***** TOPL_COMPONENTS *****/
/* This structure describes the components of the spanning forest computed by
 * the algorithm. If all is well, the graph will be connected and there will
 * be only one component. If not, this structure will contain information about
 * the different graph components. */
typedef struct {
    DWORD               numComponents;
    TOPL_COMPONENT     *pComponent;
} TOPL_COMPONENTS;
typedef TOPL_COMPONENTS *PTOPL_COMPONENTS;



/* The parameters to this comparison function are pointers to the PVOID
 * vertex names which were passed in. */
typedef int (__cdecl *TOPL_COMPARISON_FUNC)(const void*,const void*);


/***** Prototypes *****/

/***** ToplMakeGraphState *****/
/* Create a GraphState object. The graph's vertices are specified at creation
 * time -- the user should allocate an array of pointers to some structure
 * which names a vertex. W32TOPL is not interested in the details of the vertex
 * names. The multi-edges should all be added later by calling 'AddEdgeToGraph'.
 * Edge sets should be added after that to specify edge transitivity. The
 * function ToplDeleteGraphState() should be used to free the graph state
 * structure, but the user has the responsibility of deleting the vertex names,
 * their array, and the schedule cache.
 *
 * Error Conditions:
 *  - If the vertexNames array or any of its elements, vnCompFunc, or schedCache
 *    are NULL,  an exception of type TOPL_EX_NULL_POINTER will be raised.
 *  - Since this function allocates memory, it can also raise an exception if
 *    memory is exhausted.
 *
 * Warnings:
 *  - The contents of 'vertexNames' will be reordered after calling this function
 */
PTOPL_GRAPH_STATE
ToplMakeGraphState(
    IN PVOID* vertexNames,
    IN DWORD numVertices,
    IN TOPL_COMPARISON_FUNC vnCompFunc,
    IN TOPL_SCHEDULE_CACHE schedCache
    );


/***** ToplAddEdgeToGraph *****/
/* Allocate a multi-edge object, and add it to the graph G.
 * The number of vertices that this edge will contain must be specified
 * in the 'numVtx' parameter, so that the appropriate amount of memory
 * can be allocated. The names of the vertices contained in this edge
 * are not yet specified -- they are NULL. The names must be specified
 * later, by calling the function ToplEdgeSetVtx(). All names must be
 * set before adding this edge to an edge set, and before calling
 * ToplGetSpanningTreeEdgesForVtx().
 * 
 * Note: All edges must be added to the graph before starting to add
 * edge sets, otherwise an exception of type TOPL_EX_ADD_EDGE_AFTER_SET
 * will be raised. This is for performance reasons. 
 *
 * Error Conditions:
 *  - If this edge contains fewer than 2 vertices, an exception of type
 *    TOPL_EX_TOO_FEW_VTX will be raised.
 *  - If the pointer to replication info is NULL, an exception of type
 *    TOPL_EX_NULL_POINTER will be raised.
 *  - If the edge type is not in the legal range (0..31), an exception of
 *    type TOPL_EX_INVALID_EDGE_TYPE will be raised.
 *  - If the the schedule in the replication info is invalid, an exception
 *    of type TOPL_EX_SCHEDULE_ERROR will be raised. Note that a NULL
 *    schedule is interpreted as an 'always schedule'.
 *  - Since this function allocates memory, an exception can be raised
 *    if memory is exhausted.
 */
PTOPL_MULTI_EDGE
ToplAddEdgeToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN DWORD numVtx,
    IN DWORD edgeType,
    IN PTOPL_REPL_INFO ri
    );


/***** ToplEdgeSetVtx *****/
/* This function is used to set the name of a vertex in an edge.
 * If edge e has n vertices, 'whichVtx' should be in the range
 * [0..n-1]. The vertex name should be set up by the user, and there
 * is no reason why it can't point to the same name object passed to
 * ToplMakeGraphState().
 *
 * Error conditions:
 * - If the multi-edge 'e' is not valid, an appropriate exception
 *   will be raised.
 * - If 'whichVtx' is out of range for this edge, or if 'vtxName' is
 *   not the name of a vertex in the graph, an exception of type
 *   TOPL_EX_INVALID_VERTEX will be raised.
 * - If 'vtxName' is NULL, an exception of type TOPL_EX_NULL_POINTER
 *   will be raised.
 */
VOID
ToplEdgeSetVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE e,
    IN DWORD whichVtx,
    IN PVOID vtxName
    );


/***** ToplAddEdgeSetToGraph *****/
/* Adds a single edge-set to the graph state. Edge sets define transitivity
 * for paths through the graph. When the spanning-tree algorithm searches for
 * paths between vertices, it will only allow paths for which all edges are in
 * an edge set. A given edge can appear in more than one edge set.
 *
 * The user is responsible for allocating and setting up the edge set. The user
 * should free this memory after deleting the graph state, G.
 */
VOID
ToplAddEdgeSetToGraph(
    IN PTOPL_GRAPH_STATE G,
    IN PTOPL_MULTI_EDGE_SET s
    );


/***** ToplGetSpanningTreeEdgesForVtx *****/
/* This function is the heart of the spanning-tree generation algorithm.
 * Its behavior is fairly complicated, but briefly it generates a minimum
 * cost spanning tree connecting the red and black vertices. It uses
 * edge sets and other (non-colored) vertices in the graph to determine how
 * the colored vertices can be connected. This function returns all tree edges
 * containing the filter vertex, 'whichVtx'.
 * 
 * Note: This function can be called many times for the same graph with
 * different sets of colored vertices.
 *
 * Note: If the graph is fully transitive, the caller must create the
 * appropriate edge-set containing all edges.
 *
 * Note: If whichVtxName is NULL, this function will return all edges in
 * the spanning tree.
 *
 * Note: It is possible that a full spanning tree could not be built if
 * the graph is not connected, or it was connected but some paths
 * were invalidated due to non-intersecting schedules or something.
 * This condition can be detected by examining the number of components 
 * in the graph. If the number of components is 1 then the spanning tree
 * was successfully built. If the number of components is > 1 then the
 * spanning tree does not connect all vertices.
 *
 * Detailed Description:
 * ---------------------
 * The first step is to find a set of paths P in G, which have the
 * following properties:
 *    - Let p be an path in P. Then both its endpoints are either red or black.
 *    - p is a shortest-path in G
 *
 * Build a new graph G', whose vertices are all red or black vertices. There
 * is an edge (u,v) in G' if there is a path in P with endpoints u and v.
 * The cost of this edge is the total cost of the path P. The various
 * replication parameters of P are combined to get replication parameters
 * for edge (u,v).
 *
 * Our goal is to find a spanning tree of G', with the following conditions:
 *    - Edges in G' with two red endpoints are considered cheaper than edges in
 *      P without two red endpoints.
 *    - Edges of a certain type may be disallowed by certain properties set
 *      at its endpoint vertices
 *    - The spanning tree is of minimum cost, under the above assumptions.
 *
 * For each edge in the spanning tree, if one of its endpoints is 'whichVtx',
 * we add this edge TOPL_MULTI_EDGE to the output stEdgeList. If at least one of the
 * endpoints of the edge are black and this edge is in a component containing at least
 * one red vertex, then this edge will have the 'fDirectedEdge' flag set. The vertices
 * will be ordered such that e->vertexNames[0] will be closer to a red vertex than
 * e->vertexNames[1]. 
 *
 * The array of spanning tree edges is then returned to the caller as the return
 * value of this function. The number of edges in the list is returned in
 * 'numStEdges'.
 *
 * Information about the graph components is returned in the pComponents
 * structure. The user needs to provide a pointer to a TOPL_COMPONENTS
 * structure, which will then be filled in by this function. The first graph
 * component in the list always contains the filter vertex, 'whichVtxName', if
 * one was provided. Each component is described with a number of vertices and
 * all list of the vertices in the component.
 *
 * Error Conditions:
 *  - If the graph state or the array of color vertices is NULL, an exception
 *    of type TOPL_EX_NULL_POINTER will be raised.
 *  - If the graph state is invalid, an exception of type
 *    TOPL_EX_GRAPH_STATE_ERROR will be raised.
 *  - If the list of color vertices has fewer than two entries, an exception
 *    of type TOPL_EX_COLOR_VTX_ERROR will be raised.
 *  - If an entry in the array of color vertices has a NULL name, an exception
 *    of type TOPL_EX_NULL_POINTER will be raised.
 *  - If an entry in the array of color vertices doesn't refer to a vertex in
 *    the graph, or if two entries describe the same vertex, or the color
 *    specified in the entry is neither red nor black, an error of type
 *    TOPL_EX_COLOR_VTX_ERROR will be raised.
 *  - If whichVtx, the vertex whose edges we want, is not in the graph, or if
 *    it was not colored red or black, an exception of type
 *    TOPL_EX_INVALID_VERTEX will be raised.
 *  - If we discover that schedules don't intersect in our shortest-paths,
 *    we raise an exception of type TOPL_EX_NONINTERSECTING_SCHEDULES.
 */
PTOPL_MULTI_EDGE*
ToplGetSpanningTreeEdgesForVtx(
    IN PTOPL_GRAPH_STATE G,
    IN PVOID whichVtxName,
    IN TOPL_COLOR_VERTEX *colorVtx,
    IN DWORD numColorVtx,
    OUT DWORD *numStEdges,
    OUT PTOPL_COMPONENTS pComponents
    );


/***** ToplDeleteSpanningTreeEdges *****/
/* After finding the spanning-tree edges, this function should be used to
 * free their memory. */
VOID
ToplDeleteSpanningTreeEdges(
    PTOPL_MULTI_EDGE *stEdgeList,
    DWORD numStEdges
    );


/***** ToplDeleteComponents *****/
/* After finding the spanning-tree edges, this function should be used to
 * free the data describing the components */
VOID
ToplDeleteComponents(
    PTOPL_COMPONENTS pComponents
    );


/***** ToplDeleteGraphState *****/
/* After the ToplGraphState object is not needed any more, this function
 * should be used to free its memory. */
VOID
ToplDeleteGraphState(
    PTOPL_GRAPH_STATE g
    );


#ifdef __cplusplus
}
#endif


#endif W32TOPLSPANTREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\client\ism_client.c ===
#include <ism_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\client\ismapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismapi.c

ABSTRACT:

    Service-to-ISM (Intersite Messaging) service API.

DETAILS:

CREATED:

    97/11/26    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/


#include <ntdspch.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>

typedef RPC_BINDING_HANDLE ISM_HANDLE;

#define I_ISMUnbind(ph) RpcBindingFree(ph)

#ifdef DLLBUILD
// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

BOOL
WINAPI
DllEntryPoint(
    IN  HINSTANCE   hDll,
    IN  DWORD       dwReason,
    IN  LPVOID      pvReserved
    )
/*++

Routine Description:

    DLL entry point routine.  Initializes global DLL state on process attach.

Arguments:

    See "DllEntryPoint" docs in Win32 SDK.

Return Values:

    TRUE - Success.
    FALSE - Failure.

--*/
{
    static BOOL fFirstCall = TRUE;

    if (fFirstCall) {
        fFirstCall = FALSE;

        DEBUGINIT(0, NULL, "ismapi");
        DisableThreadLibraryCalls(hDll);
    }

    return TRUE;
}
#endif


DWORD
I_ISMBind(
    OUT ISM_HANDLE *    phIsm
    )
/*++

Routine Description:

    Bind to the local ISM service.

Arguments:

    phIsm (OUT) - On successful return, holds a handle to the local ISM
        service.  This handle can be used in subsequent IDL_ISM* calls.
        Caller is responsible for eventually calling I_ISMUnbind() on this
        handle.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD   err;
    UCHAR * pszStringBinding = NULL;
    // Quality of service structure to ensure authentication.
    RPC_SECURITY_QOS SecurityQOS = { 0 };
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID pSID = NULL;
    CHAR rgchName[128];
    LPSTR pszName = rgchName;
    DWORD cbName = sizeof(rgchName);
    CHAR rgchDomainName[128];
    LPSTR pszDomainName = rgchDomainName;
    DWORD cbDomainName = sizeof(rgchDomainName);
    SID_NAME_USE Use;

    *phIsm = NULL;

    // Specify quality of service parameters.
    SecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    // Dynamic identity tracking is more efficient for a single LRPC call.
    SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    // The client system service needs to impersonate the security context
    // of the client utility on the remote systems where it may replicate
    // files from.
    // We need to impersonate with level delegate, since the server system
    // service will need to impersonate the user further.
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_DELEGATE;

    __try {
        // Compose string binding for local ISM service via LPC.
        err = RpcStringBindingCompose(NULL, "ncalrpc", NULL,
                    ISMSERV_LPC_ENDPOINT, NULL, &pszStringBinding);
        if (RPC_S_OK != err) {
            __leave;
        }

        // Bind from string binding.
        err = RpcBindingFromStringBinding(pszStringBinding, phIsm);
        if (RPC_S_OK != err) {
            __leave;
        }

        // The server must be running under this identity
        // Change this to SECURITY_NETWORK_SERVICE_RID someday
        if (AllocateAndInitializeSid(&SIDAuth, 1,
                                     SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pSID) == 0) {
            err = GetLastError();
            __leave;
        }

        if (LookupAccountSid(NULL, // name of local or remote computer
                             pSID, // security identifier
                             pszName, // account name buffer
                             &cbName, // size of account name buffer
                             pszDomainName, // domain name
                             &cbDomainName, // size of domain name buffer
                             &Use) == 0) { // SID type
            err = GetLastError();
            __leave;
        }

        // Set authentication info using our process's credentials.

        // By speciying NULL for the 5th parameter we use the security login
        // context for the current address space.
        // The security level is "PRIVACY" since it is the only level
        // provided by LRPC.
        // We are assured of talking to a local service running with 
        // system privileges.

        err = RpcBindingSetAuthInfoEx(*phIsm, pszName,
                                      RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_WINNT,
                                      NULL, RPC_C_AUTHN_NONE,
                                      &SecurityQOS);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
    }

    if (NULL != pszStringBinding) {
        RpcStringFree(&pszStringBinding);
    }

    if (pSID != NULL) {
        FreeSid( pSID );
    }

    if ((RPC_S_OK != err) && (NULL != *phIsm)) {
        RpcBindingFree(phIsm);
    }

    return err;
}


DWORD
I_ISMSend(
    IN  const ISM_MSG * pMsg,
    IN  LPCWSTR         pszServiceName,
    IN  LPCWSTR         pszTransportDN,
    IN  LPCWSTR         pszTransportAddress
    )
/*++

Routine Description:

    Sends a message to a service on a remote machine.  If the client specifies a
    NULL transport, the lowest cost transport will be used.

Arguments:

    pMsg (IN) - Data to send.

    pszServiceName (IN) - Service to which to send the message.

    pszTransportDN (IN) - The DN of the Inter-Site-Transport object
        corresponding to the transport by which the message should be sent.

    pszTransportAddress (IN) - The transport-specific address to which to send
        the message.
            
Return Values:

    NO_ERROR - Message successfully queued for send.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        __try {
            err = IDL_ISMSend(hIsm, pMsg, pszServiceName, pszTransportDN,
                              pszTransportAddress);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            err = GetExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        }

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMReceive(
    IN  LPCWSTR         pszServiceName,
    IN  DWORD           dwMsecToWait,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Receives a message addressed to the given service on the local machine.

    If successful and no message is waiting, immediately returns a NULL message.
    If a non-empty message is returned, the caller is responsible for
    eventually calling I_ISMFree(*ppMsg).

Arguments:

    pszServiceName (IN) - Service for which to receive the message.

    dwMsecToWait (IN) - Milliseconds to wait for message if none is immediately
        available; in the range [0, INFINITE].

    ppMsg (OUT) - On successful return, holds a pointer to the returned data, or
        NULL if none.

Return Values:

    NO_ERROR - Message successfully returned (or NULL returned, indicating no
        message is waiting).
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    *ppMsg = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        __try {
            err = IDL_ISMReceive(hIsm, pszServiceName, dwMsecToWait, ppMsg);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            err = GetExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        }

        I_ISMUnbind(&hIsm);
    }

    return err;
}


void
I_ISMFree(
    IN  VOID *  pv
    )
/*++

Routine Description:

    Frees memory allocated on the behalf of the client by I_ISM* APIs.

Arguments:

    pv (IN) - Memory to free.

Return Values:

    None.

--*/
{
    if (NULL != pv) {
        MIDL_user_free(pv);
    }
}


DWORD
I_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppConnectivity) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppConnectivity = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        __try {
            err = IDL_ISMGetConnectivity(hIsm, pszTransportDN, ppConnectivity);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            err = GetExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        }

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        __try {
            err = IDL_ISMGetTransportServers(hIsm, pszTransportDN,
                                             pszSiteDN, ppServerList);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            err = GetExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        }

        I_ISMUnbind(&hIsm);
    }

    return err;
}


DWORD
I_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN1, pszSiteDN2 (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err;
    ISM_HANDLE  hIsm;

    if (NULL == ppSchedule) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppSchedule = NULL;

    err = I_ISMBind(&hIsm);

    if (NO_ERROR == err) {
        __try {
            err = IDL_ISMGetConnectionSchedule(hIsm, pszTransportDN,
                       pszSiteDN1, pszSiteDN2, ppSchedule);
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            err = GetExceptionCode();
            if (RPC_X_NULL_REF_POINTER == err) {
                err = ERROR_INVALID_PARAMETER;
            }
        }

        I_ISMUnbind(&hIsm);
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\client\ismmidl.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       allocc.c
//
//--------------------------------------------------------------------------

/*
File: allocc.c

Description:
    
    Routines to handle allocation and deallocation for the client
    side RPC.
    
    Note: the RPC system allows the different MIDL_user_allocate()
    routines on the client and server sides. The DSA uses a
    special implementation of these routines. The client
    side is a simple malloc/free combination. The server side
    uses the THAlloc*() routines.
*/

#pragma warning( disable:4114)  // "same type qualifier used more than once"
#include <NTDSpch.h>
#pragma hdrstop
#pragma warning( default:4114)

#include <memory.h>

#include "dsaalloc.h"

#ifdef DEBUG
/* gAllocated keeps track of the number of times that
the MIDL allocater is called. It is intended to help spot memory leaks.
*/

volatile int gAllocated = 0;
#endif

/*
MIDL_user_allocate

On the server stub side, called by the stub to allocate space for [in]
parameters. Upon return from the called proceedure, the stub will
call MIDL_user_free to deallocate this memory.

The server stub also presumes that this routine is called to allocate
memory for [out] parameters. Upon return from the called proceedure, the
stub will call MIDL_user_free to deallocate [out] parameters.
*/

void* __RPC_USER MIDL_user_allocate( size_t bytes )
{
    void*   ret;
    
    /* Keep track of the number of times the
    allocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated++;
#endif

    ret = malloc( (size_t) bytes );
    if ( ret == NULL ) {
        return( ret );
    } else {
        /* Zero out the memory */
        memset( ret, 0, (size_t) bytes );
    }
    
    /* Normal return */
    
    return( ret );
}


void __RPC_USER MIDL_user_free( void* memory )
{
    /* Keep track of the number of times the
    deallocater is called. Helps in spotting memory leaks.
    Assumes the following operation is atomic.
    */
    
#ifdef DEBUG
    gAllocated--;
#endif
    free( memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#

!INCLUDE $(NTMAKEENV)\makefile.plt

UNICODE=1

SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)
PRIVINC = $(DS_INC_PATH)

INCS = -I$(SDKINC) -I$(SDKCRTINC) -I$(PRIVINC) -Iinclude

EXTRN_DEPENDS = $(SDKINC)\winbase.h \
                $(SDKINC)\windef.h

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H -DMIDL_PASS
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"

#
# MIDL COMPILE
#

$(O)\ism.h $(O)\ism_c.c $(O)\ism_s.c: .\ism.idl .\ism.acf $(SDKINC)\ismapi.h $(EXTRN_DEPENDS)
    midl -Oicf -robust -oldnames -error all -ms_ext -c_ext -out .\$(O) $(CPP) $(INCS) .\ism.idl

$(O)\seo.h $(O)\seo_i.c: $(INETSRV_INC_PATH)\seo.idl
    midl -Oicf -robust -error all -ms_ext -c_ext -out .\$(O) $(CPP) $(INCS) $(INETSRV_INC_PATH)\seo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\client\ismtest.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismtest.c

ABSTRACT:

    Test utility for the Intersite Messaging service.

DETAILS:

CREATED:

    97/12/10    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ismapi.h>

#include <schedule.h>


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tue","Wed","Thu","Fri","Sat"};

    printf( "day: 0123456789ab0123456789ab\n" );
    for( day = 0; day < 7; day++ ) {
        printf( "%s: ", dow[day] );
        for( hour = 0; hour < 24; hour++ ) {
            printf( "%x", (*data & 0xf) );
            data++;
        }
        printf( "\n" );
    }
}

int
__cdecl
wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    BOOL        fDisplayUsage = FALSE;
    BOOL        fSend = FALSE;
    BOOL        fReceive = FALSE;
    BOOL        fConnect = FALSE;
    BOOL        fServers = FALSE;
    BOOL        fSchedule = FALSE;
    LPWSTR      pszColon;
    LPWSTR      pszFile = NULL;
    LPWSTR      pszService = NULL;
    LPWSTR      pszTransport = NULL;
    LPWSTR      pszAddress = NULL;
    LPWSTR      pszSite1 = NULL;
    LPWSTR      pszSite2 = NULL;
    LPWSTR      pszSubject = NULL;
    int         iArg;
    BOOL        fSuccess = FALSE;
    HANDLE      hFile;
    ISM_MSG     msg = {0};
    ISM_MSG *   pmsg = NULL;
    DWORD       err;
    DWORD       cbActual;
    DWORD       dwTimeout = 0;

    for (iArg = 1; iArg < argc; iArg++) {
        switch (argv[iArg][0]) {
          case '/':
          case '-':
            // An option.
            pszColon = wcschr(&argv[iArg][1], ':');

            if (NULL == pszColon) {
                if (!lstrcmpiW(&argv[iArg][1], L"send")) {
                    fSend = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"receive")) {
                    fReceive = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"connect")) {
                    fConnect = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"servers")) {
                    fServers = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"schedule")) {
                    fSchedule = TRUE;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"?")
                         || !lstrcmpiW(&argv[iArg][1], L"h")
                         || !lstrcmpiW(&argv[iArg][1], L"help")) {
                    fDisplayUsage = TRUE;
                    break;
                }
            }
            else {
                *pszColon = '\0';
                
                if (!lstrcmpiW(&argv[iArg][1], L"file")) {
                    pszFile = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"service")) {
                    pszService = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"transport")) {
                    pszTransport = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"address")) {
                    pszAddress = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"site")) {
                    pszSite1 = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"site2")) {
                    pszSite2 = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"subject")) {
                    pszSubject = pszColon + 1;
                    break;
                }
                else if (!lstrcmpiW(&argv[iArg][1], L"timeout")) {
                    if (!lstrcmpiW(pszColon + 1, L"infinite")) {
                        dwTimeout = INFINITE;
                    }
                    else {
                        dwTimeout = _wtoi(pszColon + 1);
                    }
                    break;
                }
            }
            // Not a valid option if we're here.  Fall through....

          default:
            printf("Unrecognized parameter \"%ls\".\n", argv[iArg]);
            fDisplayUsage = TRUE;
            break;
        }
    }

    if (fDisplayUsage) {
        printf("\n"
               "Intersite Messaging Service Test Client\n"
               "Copyright (c) 1997 Microsoft Corporation.\n"
               "All rights reserved.\n"
               "\n"
               "Usage: %ls {operation} [paramaters...],\n"
               "where {operation} is one of:\n"
               "    /send     - Send a message.\n"
               "    /receive  - Retreieve a waiting message.\n"
               "    /connect  - Retrieve transport-specific site connectivity information.\n"
               "    /servers  - Get the servers in a site capable of using a given transport.\n"
               "    /schedule - Query for the schedule by which two sites are connected.\n"
               "and [parameters...] are composed of the following:\n"
               "    /file:{filename} - Holds message data.\n"
               "    /service:{service name}\n"
               "    /transport:{interSiteTransport object DN}\n"
               "    /address:{transport-specific address}\n"
               "    /site:{site object DN}\n"
               "    /site2:{site object DN}\n"
               "    /subject:{string}\n"
               "    /timeout:infinite|{timeout_in_msec}\n",
               argv[0]);
    }
    else if (fSend && !fReceive && !fConnect && !fServers && !fSchedule) {
        if (NULL != pszFile) {
            hFile = CreateFileW(pszFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

            if (INVALID_HANDLE_VALUE != hFile) {
                msg.cbData = GetFileSize(hFile, NULL);

                if (0xFFFFFFFF != msg.cbData) {
                    msg.pbData = LocalAlloc(LMEM_FIXED, msg.cbData);

                    fSuccess = (NULL != msg.pbData)
                               && ReadFile(hFile, msg.pbData, msg.cbData, &cbActual, NULL)
                               && (cbActual == msg.cbData);
                }

                CloseHandle(hFile);
            }
            msg.pszSubject = pszSubject;  // may be null
            if (fSuccess) {
                err = I_ISMSend(&msg, pszService, pszTransport, pszAddress);
                
                if (NO_ERROR == err) {
                    printf("%d bytes sent.\n", msg.cbData);
                }
                else {
                    printf("I_ISMSend failed, error %d.\n", err);
                }
            }
            else {
                printf("Failed to read file \"%ls\", error %d.\n",
                       pszFile, GetLastError());
            }

            if (NULL != msg.pbData) {
                LocalFree(msg.pbData);
            }
        }
        else {
            printf("Must specify /file.\n");
        }
    }
    else if (!fSend && fReceive && !fConnect && !fServers && !fSchedule) {
        if (NULL != pszFile) {
            err = I_ISMReceive(pszService, dwTimeout, &pmsg);
            
            if (NO_ERROR == err) {
                if (NULL == pmsg) {
                    printf("No message waiting.\n");
                }
                else {
                    hFile = CreateFileW(pszFile,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);

                    fSuccess = (NULL != hFile)
                               && WriteFile(hFile, pmsg->pbData, pmsg->cbData, &cbActual, NULL)
                               && (cbActual == pmsg->cbData);

                    CloseHandle(hFile);

                    if (pmsg->pszSubject) {
                        printf( "Subj: '%ws'\n", pmsg->pszSubject );
                    } else {
                        printf( "no subject string present.\n" );
                    }

                    if (fSuccess) {
                        printf("%d bytes received.\n", pmsg->cbData);
                    }
                    else {
                        printf("Failed to write file \"%ls\", error %d.\n",
                               pszFile, GetLastError());
                    }

                    I_ISMFree(pmsg);
                }
            }
            else {
                printf("I_ISMReceive failed, error %d.\n", err);
            }
        }
        else {
            printf("Must specify /file.\n");
        }
    }
    else if (!fSend && !fReceive && fConnect && !fServers && !fSchedule) {
        ISM_CONNECTIVITY * pSiteConnect;
        DWORD iSite1, iSite2;

        err = I_ISMGetConnectivity(pszTransport, &pSiteConnect);
        
        if (NO_ERROR == err) {
            printf("Received connectivity information for %d sites:\n\n", pSiteConnect->cNumSites);


            for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                printf( "%s%4d", iSite2 ? ", " : "     ", iSite2 );
            }
            printf("\n");
            for (iSite1 = 0; iSite1 < pSiteConnect->cNumSites; iSite1++) {
                printf("(%2d) %ls\n", iSite1, pSiteConnect->ppSiteDNs[iSite1]);
                for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                    PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

                    printf("%s%d:%d", iSite2 ? ", " : "     ",
                           pLink->ulCost, pLink->ulReplicationInterval );

                }
                printf("\n");
            }
        }
        else {
            printf("I_ISMGetConnectivity() failed, error %d.\n", err);
        }        
    }
    else if (!fSend && !fReceive && !fConnect && fServers && !fSchedule) {
        ISM_SERVER_LIST * pServerList;
        DWORD iServer;

        err = I_ISMGetTransportServers(pszTransport, pszSite1, &pServerList);
        
        if (NO_ERROR == err) {
            if (NULL == pServerList) {
                printf("All DCs in the site (with a transport address) are reachable.\n");
            }
            else {
                for (iServer = 0; iServer < pServerList->cNumServers; iServer++) {
                    printf("%d server(s) are defined as bridgeheads for this transport & site:\n\n",
                           pServerList->cNumServers);
                    printf("(%2d) %ls\n", iServer, pServerList->ppServerDNs[iServer]);
                }
            }
        }
        else {
            printf("I_ISMGetTransportServers() failed, error %d.\n", err);
        }        
    }
    else if (!fSend && !fReceive && !fConnect && !fServers && fSchedule) {
        ISM_SCHEDULE * pSchedule;
        DWORD iServer;

        err = I_ISMGetConnectionSchedule(pszTransport, pszSite1, pszSite2, &pSchedule);
        
        if (NO_ERROR == err) {
            if (NULL == pSchedule) {
                printf("Connection is always available.\n");
            }
            else {
                printSchedule( pSchedule->pbSchedule );
            }
        }
        else {
            printf("I_ISMGetTransportServers() failed, error %d.\n", err);
        }        
    }
    else {
        printf("Must specify exactly one of /send, /receive, /connect, /servers, or /schedule.\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\include\memory.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Debug memory allocator.
    Checks for heap corruption.
    Reports memory not deallocated

    User interface:
    ptr = NEW_TYPE( type )
    ptr = NEW_TYPE_ARRAY( count, type )
    ptr = NEW_TYPE_ZERO( type )
    ptr = NEW_TYPE_ARRAY_ZERO( count, type )
    TYPE_FREE( ptr )

Author:

    Will Lees (wlees) 23-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _MEMORY_
#define _MEMORY_

#ifdef __cplusplus
extern "C" {
#endif

/* Prototypes */
/* End Prototypes */

// memory.c

void
DebugMemoryInitialize(
    void
    );

void
DebugMemoryTerminate(
    void
    );

#if DBG
PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define NEW_TYPE( type ) (type *) DebugMemoryAllocate( sizeof( type ), __FILE__, __LINE__ )
#define NEW_TYPE_ARRAY( count, type ) (type *) DebugMemoryAllocate( (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define NEW_TYPE( type ) (type *) malloc( sizeof( type ) )
#define NEW_TYPE_ARRAY( count, type ) (type *) malloc( (count) * sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
PVOID
DebugMemoryReallocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define REALLOC_TYPE( p, type ) (type *) DebugMemoryReallocate( p, sizeof( type ), __FILE__, __LINE__ )
#define REALLOC_TYPE_ARRAY( p, count, type ) (type *) DebugMemoryReallocate( p, (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define REALLOC_TYPE( p, type ) (type *) realloc( p, sizeof( type ) )
#define REALLOC_TYPE_ARRAY( p, count, type ) (type *) realloc( p, (count) * sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );
#define NEW_TYPE_ZERO( type ) (type *) DebugMemoryAllocateZero( sizeof( type ), __FILE__, __LINE__ )
#define NEW_TYPE_ARRAY_ZERO( count, type ) (type *) DebugMemoryAllocateZero( (count) * sizeof( type ), __FILE__, __LINE__ )
#else
#define NEW_TYPE_ZERO( type ) (type *) calloc( 1, sizeof( type ) )
#define NEW_TYPE_ARRAY_ZERO( count, type ) (type *) calloc( (count), sizeof( type ) )
//CODE.IMPROVEMENT: LOGGING IN THE CASE OF ERRORS
#endif

#if DBG
BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );
#define MEMORY_CHECK( p ) DebugMemoryCheck( p, __FILE__,__LINE__ )
#else
#define MEMORY_CHECK( p )
#endif

#if DBG
void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );
#define FREE_TYPE( p ) DebugMemoryFree( p, __FILE__, __LINE__ )
#else
#define FREE_TYPE( p ) free( p )
#endif

#if DBG
void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    );
#define MEMORY_CHECK_ALL( ) DebugMemoryCheckAll( __FILE__, __LINE__ )
#else
#define MEMORY_CHECK_ALL()
#endif

#ifdef __cplusplus
}
#endif

#endif /* _MEMORY_ */

/* end memory.h */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\include\common.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    common.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _COMMON_H_INCLUDED_
#define _COMMON_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

#include "memory.h"         // debug memory allocator
#include <wtypes.h>         // BSTR

#ifndef MAX
#define MAX( a, b ) ( (a > b) ? a : b)
#endif

// Time support

typedef LONGLONG DSTIME;

// Generic table entry

typedef struct _TABLE_INSTANCE *PTABLE_INSTANCE;

typedef struct _TABLE_ENTRY {
    LPWSTR Name;
    struct _TABLE_ENTRY *Next;
} TABLE_ENTRY, *PTABLE_ENTRY;

// Long-lived routing state
// This is kept in the transport handle for lifetime reasons, but it is
// managed by the routing package.

// TODO: Make this an opaque handle managed inside the routing package
typedef struct _ROUTING_STATE {
    volatile BOOL fCacheIsValid;
    DWORD NumberSites;
    LPWSTR *pSiteList;
    struct _GRAPH_INSTANCE *CostGraph;
    struct _TABLE_INSTANCE *SiteSymbolTable;
} ROUTING_STATE, *PROUTING_STATE;

typedef struct _SMTP_INSTANCE {
    LPWSTR  pszSmtpAddress;
    PVOID pvCurrentCollection;
    LONG lCount;
    BSTR bstrDropDirectory;
    PVOID pvGuidTable;
} SMTP_INSTANCE;

typedef struct _IP_INSTANCE {
    DWORD dwReserved;
} IP_INSTANCE;

// Contains configuration info for each named transport passed to the
// Startup API

typedef struct _TRANSPORT_INSTANCE {
    DWORD Size;
    DWORD ReferenceCount;
    LPWSTR Name;
    LIST_ENTRY ListEntry;
    CRITICAL_SECTION Lock;
    PVOID DirectoryConnection;
    HANDLE ListenerThreadHandle;      // Handle on listener thread
    LONG ListenerThreadID;            // TID of listener thread
    volatile BOOLEAN fShutdownInProgress;      // Flag to indicate listener thread should exit
    HANDLE hShutdownEvent;            // Signalled when asked to shut down
    LIST_ENTRY ServiceListHead;       // Server-side list of services seen
    DWORD ServiceCount;               // Count of services that have left msg
    ISM_NOTIFY *pNotifyFunction;
    HANDLE hNotify;
    ROUTING_STATE RoutingState;
    DWORD Options;                    // Transport options, from trans object
    DWORD ReplInterval;               // Default repliation interval
    DWORD NotifyMessageNumber;        // LDAP notification message number
    HANDLE NotifyThreadHandle;        // Handle on notification thread
    union {
        IP_INSTANCE Ip;           // IP-specific port for this instance to use
        SMTP_INSTANCE Smtp;           // SMTP-specific info for this instance
    };
} TRANSPORT_INSTANCE, *PTRANSPORT_INSTANCE;

// This is a opaque graph descriptor

typedef struct _GRAPH_INSTANCE *PGRAPH;

// Max Registry path

#define MAX_REG_PATH 1024
#define MAX_REG_COMPONENT 255

// Cost array

#define INFINITE_COST 0xffffffff

// Limit on number of services which can be buffered

#define ISM_MAX_SERVICE_LIMIT 10

// route.c

// Routing flags.

#define ROUTE_IGNORE_SCHEDULES  (NTDSTRANSPORT_OPT_IGNORE_SCHEDULES)
    // Schedules on siteLink objects will be ignored. (And the "ever-present"
    // schedule is assumed.)

#define ROUTE_BRIDGES_REQUIRED  (NTDSTRANSPORT_OPT_BRIDGES_REQUIRED)
    // siteLinks must be explicitly bridged with siteLinkBridge objects to
    // indicate transitive connections. Otherwise, siteLink transitivity is
    // assumed.

// Routing API.

VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    );

DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    );

// graph.c

void
GraphAllCosts(
    PGRAPH CostArray,
    BOOL fIgnoreSchedules
    );

void
GraphMerge(
    PGRAPH FinalArray,
    PGRAPH TempArray
    );

PGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    );

DWORD
GraphAddEdgeIfBetter(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

DWORD
GraphInit(
    PGRAPH Graph
    );

void
GraphFree(
    PGRAPH Graph
    );

void
GraphReferenceMatrix(
    PGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

VOID
GraphDereferenceMatrix(
    PGRAPH Graph,
    PISM_LINK pLinkArray
    );

DWORD
GraphGetPathSchedule(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *pSchedule,
    DWORD *pLength
    );

// dirobj.c

DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    );

DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    );

DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    );

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    );

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    );

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    );

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    );

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    );

void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    );

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    );

DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    );

void
DirFreeMultiszString(
    LPWSTR MultiszString
    );

void
DirFreeSchedule(
    PBYTE pSchedule
    );

DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    );

DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirRegisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT HANDLE *              phServerChanges
    );

DWORD
DirWaitForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirUnregisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

// table

PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    );

VOID
TableFree(
    PTABLE_INSTANCE Table
    );

PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    );

// list

typedef struct _LIST_ENTRY_INSTANCE {
    LPWSTR Name;
    LIST_ENTRY ListEntry;
} LIST_ENTRY_INSTANCE, *PLIST_ENTRY_INSTANCE;

typedef DWORD (__cdecl LIST_CREATE_CALLBACK_FN)(
    PLIST_ENTRY_INSTANCE pListEntry
    );

typedef DWORD (__cdecl LIST_DESTROY_CALLBACK_FN)(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    );

DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroyFunction,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    );


#ifdef __cplusplus
}
#endif

#endif /* _COMMON_H_INCLUDED_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\ismapi.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismapi.cxx

ABSTRACT:

    Server stubs for functions exposed through the ISM RPC interface.

DETAILS:

CREATED:

    97/11/26    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/


#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>

#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>

#include "ismserv.hxx"

#define DEBSUB "ISMAPI:"
#define FILENO FILENO_ISMSERV_ISMAPI


// Thread-specific variables to track the last data structure returned.  Used
// by IDL_ISM*_notify() to free the structure once it has been marshalled.
__declspec(thread) ISM_TRANSPORT *      gpTransport;
__declspec(thread) ISM_MSG *            gpMsg;
__declspec(thread) ISM_CONNECTIVITY *   gpConnectivity;
__declspec(thread) ISM_SERVER_LIST *    gpServerList;
__declspec(thread) ISM_SCHEDULE *       gpSchedule;


extern "C"
DWORD
IDL_ISMSend(
    IN  RPC_BINDING_HANDLE  hRpcBinding,
    IN  const ISM_MSG *     pMsg,
    IN  LPCWSTR             pszServiceName,
    IN  LPCWSTR             pszTransportDN,
    IN  LPCWSTR             pszTransportAddress
    )
/*++

Routine Description:

    Sends a message to a service on a remote machine.  If the client specifies a
    NULL transport, the lowest cost transport will be used.

Arguments:

    pMsg (IN) - The data to send.

    pszServiceName (IN) - Service to which to send the message.

    pszTransportDN (IN) - The DN of the Inter-Site-Transport object
        corresponding to the transport by which the message should be sent.
            
    pszTransportAddress (IN) - The transport-specific address to which to send
        the message.
            
Return Values:

    NO_ERROR - Message successfully queued for send.

    other - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    __try {    
        DPRINT(4, "Sending message...\n");

        pTransport = gService.m_TransportList.Get(pszTransportDN);

        if (NULL != pTransport) {
            err = pTransport->Send(pMsg, pszServiceName, pszTransportAddress);

            if (NO_ERROR == err) {
                DPRINT5(2, "Sent %d bytes to service %ls at %ls on transport %ls.\nSubject: %ls\n",
                        pMsg->cbData, pszServiceName, pszTransportAddress, pszTransportDN,
                        pMsg->pszSubject);
            }
            else {
                DPRINT4(0, "Failed to send message to service %ls at %ls on transport %ls, error %d.\n",
                        pszServiceName, pszTransportAddress, pszTransportDN, err);
            }
        }
        else {
            DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
            err = ERROR_NOT_FOUND;
        }
    }
    __finally {
        gService.m_TransportList.ReleaseLock();
    }

    if (NO_ERROR == err) {
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_ISM_SEND_SUCCESS,
                  szInsertUL(pMsg->cbData),
                  szInsertWC(pszServiceName),
                  szInsertWC(pszTransportAddress),
                  szInsertWC(pszTransportDN),
                  szInsertWC(pMsg->pszSubject),
                  NULL, NULL, NULL);
    }
    else {
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SEND_FAILURE,
                          szInsertUL(pMsg->cbData),
                          szInsertWC(pszServiceName),
                          szInsertWC(pszTransportAddress),
                          szInsertWC(pszTransportDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


extern "C"
DWORD
IDL_ISMReceive(
    IN  RPC_BINDING_HANDLE  hRpcBinding,
    IN  LPCWSTR             pszServiceName,
    IN  DWORD               dwMsecToWait,
    OUT ISM_MSG **          ppMsg
    )
/*++

Routine Description:

    Receives a message addressed to the given service on the local machine.

    If successful and no message is waiting, immediately returns a NULL message.
    If a non-NULL message is returned, the caller is responsible for eventually
    calling I_ISMFree()'ing the returned message.

Arguments:

    pszServiceName (IN) - Service for which to receive the message.

    dwMsecToWait (IN) - Milliseconds to wait for message if none is immediately
        available; in the range [0, INFINITE].

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    NO_ERROR - Message successfully returned (or NULL was returned,
        indicating no message is waiting).

    other - Failure.

--*/
{
    DWORD           err = NO_ERROR;
    DWORD           iTransport;
    ISM_TRANSPORT * pTransport;
    BOOL            fRetry;
    ISM_TRANSPORT * rgpTransports[MAXIMUM_WAIT_OBJECTS];
    HANDLE          rgWaitHandles[MAXIMUM_WAIT_OBJECTS];
    const DWORD     cMaxTransports = MAXIMUM_WAIT_OBJECTS - 2;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Receiving message...\n");

    do {
        fRetry = FALSE;

        // Check all transports for inbound messages for the given service.
        // If the receive fails or the transport has no message for this service,
        // continue on to the next service.

        for (iTransport = 0, pTransport = gService.m_TransportList[0];
             NULL != pTransport;
             pTransport = gService.m_TransportList[++iTransport]) {

            Assert((iTransport < cMaxTransports) && "Too many transports!");

            // Leave room in handle array for shutdown and transport list
            // change events.
            if (iTransport < cMaxTransports) {
                rgpTransports[iTransport] = pTransport;

                rgWaitHandles[iTransport] = pTransport->GetWaitHandle(pszServiceName);
                Assert(NULL != rgWaitHandles[iTransport]);
            }

            err = pTransport->Receive(pszServiceName, ppMsg);

            if (NO_ERROR == err) {
                if (NULL == *ppMsg) {
                    DPRINT2(3, "Transport %ls has no message for service %ls.\n",
                            pTransport->GetDN(), pszServiceName);
                }
                else {
                    DPRINT4(2, "Received %d bytes for service %ls via transport %ls.\nSubject: %ls.\n",
                            (*ppMsg)->cbData, pszServiceName, pTransport->GetDN(),
                            (*ppMsg)->pszSubject);

                    LogEvent8(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_ISM_RECEIVE_SUCCESS,
                              szInsertUL((*ppMsg)->cbData),
                              szInsertWC(pszServiceName),
                              szInsertWC(pTransport->GetDN()),
                              szInsertWC((*ppMsg)->pszSubject),
                              NULL, NULL, NULL, NULL
                        );
                    
                    // Remember transport and received message so we can free the
                    // message once it's been marshalled.
                    gpTransport = pTransport;
                    gpMsg = *ppMsg;

                    break;
                }
            }
            else {
                DPRINT3(0, "Failed to receive message for service %ls via transport %ls, error %d.\n",
                        pszServiceName, pTransport->GetDN(), err);
                
                LogEvent8WithData(DS_EVENT_CAT_ISM,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_ISM_RECEIVE_FAILURE,
                                  szInsertWC(pszServiceName),
                                  szInsertWC(pTransport->GetDN()),
                                  szInsertWin32Msg(err),
                                  NULL, NULL, NULL, NULL, NULL,
                                  sizeof(err),
                                  &err);
            }
        }

        if ((NULL == *ppMsg) && (NO_ERROR == err)) {
            DPRINT1(3, "No message waiting for service %ls.\n", pszServiceName);

            if (0 != dwMsecToWait) {
                // Round up wait handles from all the transports.
                DWORD cNumTransports = min(iTransport, cMaxTransports);
                DWORD cNumHandles = cNumTransports;
                DWORD iShutdownEvent;
                DWORD iTransportChangeEvent;

                // Stop waiting if shutdown is signalled, too.
                iShutdownEvent = cNumHandles++;
                rgWaitHandles[iShutdownEvent] = gService.GetShutdownEvent();

                // ...or if a new transport is added.
                iTransportChangeEvent = cNumHandles++;
                rgWaitHandles[iTransportChangeEvent]
                    = gService.m_TransportList.GetChangeEvent();

                // Release lock while we're waiting.
                gService.m_TransportList.ReleaseLock();

                err = WaitForMultipleObjects(cNumHandles, rgWaitHandles, FALSE,
                                             dwMsecToWait);

                // Note that lock is released in notify routine.
                gService.m_TransportList.AcquireReadLock();

#pragma warning(disable:4296)
                // The following test generates an error 4296, because it turns
                // out that WAIT_OBJECT_0 is 0, and unsigned err can never be
                // negative.
                if ((WAIT_OBJECT_0 <= err) && (err < (WAIT_OBJECT_0 + cNumTransports))) {
#pragma warning(default:4296)
                    // Received notification of pending message.
                    iTransport = err - WAIT_OBJECT_0;
                    pTransport = gService.m_TransportList[iTransport];

                    for (iTransport = 0, pTransport = gService.m_TransportList[0];
                         NULL != pTransport;
                         pTransport = gService.m_TransportList[++iTransport]) {
                        if (pTransport == rgpTransports[err - WAIT_OBJECT_0]) {
                            // This is the transport that notified us.
                            break;
                        }
                    }

                    if (NULL == pTransport) {
                        // We were notified, but by the time we turned around
                        // the transport that notified us was gone.
                        DPRINT(0, "Unable to find transport that notified us; rewaiting.\n");
                        fRetry = TRUE;
                    }
                    else {
                        err = pTransport->Receive(pszServiceName, ppMsg);

                        if ((NO_ERROR != err) || (NULL == *ppMsg)) {
                            // We were notified, but apparently someone beat us
                            // to the message.
                            DPRINT2(1, "No message waiting for %ls from %ls, despite notification; rewaiting.\n",
                                    pszServiceName, pTransport->GetDN());
                            fRetry = TRUE;

                            if (err) {
                                LogEvent8WithData(DS_EVENT_CAT_ISM,
                                                  DS_EVENT_SEV_ALWAYS,
                                                  DIRLOG_ISM_RECEIVE_FAILURE,
                                                  szInsertWC(pszServiceName),
                                                  szInsertWC(pTransport->GetDN()),
                                                  szInsertWin32Msg(err),
                                                  NULL, NULL, NULL, NULL, NULL,
                                                  sizeof(err),
                                                  &err);
                            }
                        }
                        else {
                            DPRINT3(2, "Received %d bytes for service %ls via transport %ls.\n",
                                    (*ppMsg)->cbData, pszServiceName, pTransport->GetDN());

			    LogEvent8(DS_EVENT_CAT_ISM,
				      DS_EVENT_SEV_BASIC,
				      DIRLOG_ISM_RECEIVE_SUCCESS,
				      szInsertUL((*ppMsg)->cbData),
				      szInsertWC(pszServiceName),
				      szInsertWC(pTransport->GetDN()),
				      szInsertWC((*ppMsg)->pszSubject),
				      NULL, NULL, NULL, NULL
				      );

                            // Remember transport and received message so we can free the
                            // message once it's been marshalled.
                            gpTransport = pTransport;
                            gpMsg = *ppMsg;
                            
                            break;
                        }
                    }
                }
                else if ((WAIT_OBJECT_0 + iShutdownEvent) == err) {
                    // Shutting down.
                    DPRINT(0, "Shutdown signalled; wait terminated.\n");
                    err = ERROR_SHUTDOWN_IN_PROGRESS;
                }
                else if ((WAIT_OBJECT_0 + iTransportChangeEvent) == err) {
                    // Transport list has changed.
                    DPRINT(0, "Transport list changed; re-acquiring and re-waiting.\n");
                    fRetry = TRUE;
                }
                else if (WAIT_TIMEOUT == err) {
                    // Still no waiting message; return.
                    DPRINT2(2, "After %u msec, still no message for service %ls.\n",
                            dwMsecToWait, pszServiceName);
                    err = NO_ERROR;
                }
                else if ((WAIT_ABANDONED_0 <= err)
                         && (err < (WAIT_ABANDONED_0 + cNumTransports))) {
                    // Wait abandoned -- that transport must be being shut down.
                    // Wait again.
                    DPRINT(0, "Wait abandoned; re-waiting.\n");
                    fRetry = TRUE;
                }
                else {
		    DWORD gle = GetLastError();
		    DPRINT2(0, "Failed to wait for message, error %d (GLE = %d).\n",
                            err, gle);
		    LogEvent8WithData(
			DS_EVENT_CAT_ISM,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,   
			szInsertWin32Msg( gle ),   
			NULL,
			NULL,
			NULL,
			NULL, NULL, NULL, NULL,
			sizeof(gle),
			&gle);  
                }
            }
        }
    } while (fRetry);

    return err;
}


extern "C"
void
IDL_ISMReceive_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppMsg to ship back to the client.

    We take this opportunity to free the message via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpMsg) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing message.\n");
        gpTransport->FreeMsg(gpMsg);

        gpTransport = NULL;
        gpMsg = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetConnectivity(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    PISM_CONNECTIVITY_df_an *       ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting connectivity...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetConnectivity(ppConnectivity);

        if (NO_ERROR == err) {
            DPRINT1(2, "Retrieved site connectivity for transport %ls.\n",
                    pszTransportDN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpConnectivity = *ppConnectivity;
        }
        else {
            DPRINT2(0, "Failed to get site connectivity for transport %ls, error %d.\n",
                    pszTransportDN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    // BAD_NET_RESP is the special error that LDAP returns at shutdown

    if ( (err) &&
         (err != ERROR_BAD_NET_RESP)  // shutdown, don't log
        ) {
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_GET_CONNECTIVITY_FAILURE,
                          szInsertWC(pszTransportDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


extern "C"
void
IDL_ISMGetConnectivity_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppConnectivity to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpConnectivity) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing connectivity.\n");
        gpTransport->FreeConnectivity(gpConnectivity);

        gpTransport = NULL;
        gpConnectivity = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetTransportServers(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    LPCWSTR                         pszSiteDN,
    PISM_SERVER_LIST_df_an *        ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting transport servers...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetTransportServers(pszSiteDN, ppServerList);

        if (NO_ERROR == err) {
            DPRINT2(2, "Retrieved %d transport servers for transport %ls.\n",
                    (NULL == *ppServerList) ? 0 : (*ppServerList)->cNumServers,
                    pszTransportDN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpServerList = *ppServerList;
        }
        else {
            DPRINT2(0, "Failed to get transport servers for transport %ls, error %d.\n",
                    pszTransportDN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    if (err) {
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_GET_TRANSPORT_SERVERS_FAILURE,
                          szInsertWC(pszSiteDN),
                          szInsertWC(pszTransportDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


extern "C"
void
IDL_ISMGetTransportServers_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppServerList to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpServerList) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing transport servers.\n");
        gpTransport->FreeTransportServers(gpServerList);

        gpTransport = NULL;
        gpServerList = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}


extern "C"
DWORD
IDL_ISMGetConnectionSchedule(
    handle_t                        hRpcBinding,
    LPCWSTR                         pszTransportDN,
    LPCWSTR                         pszSite1DN,
    LPCWSTR                         pszSite2DN,
    PISM_SCHEDULE_df_an *           ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    ISM_TRANSPORT * pTransport;

    gService.m_TransportList.AcquireReadLock();
    // Note that lock is released in notify routine.

    DPRINT(4, "Getting connection schedule...\n");

    pTransport = gService.m_TransportList.Get(pszTransportDN);

    if (NULL != pTransport) {
        err = pTransport->GetConnectionSchedule(pszSite1DN, pszSite2DN, ppSchedule);

        if (NO_ERROR == err) {
            DPRINT4(2, "Retrieved schedule of %d bytes for transport %ls between sites %ls and %ls.\n",
                    (NULL == *ppSchedule) ? 0 : (*ppSchedule)->cbSchedule,
                    pszTransportDN, pszSite1DN, pszSite2DN);

            // Remember transport and received structure so we can free the
            // structure once it's been marshalled.
            gpTransport = pTransport;
            gpSchedule = *ppSchedule;
        }
        else {
            DPRINT4(0, "Failed to get schedule for transport %ls between sites %ls and %ls, error %d.\n",
                    pszTransportDN, pszSite1DN, pszSite2DN, err);
        }
    }
    else {
        DPRINT1(0, "No intersite transport %ls.\n", pszTransportDN);
        err = ERROR_NOT_FOUND;
    }

    if (err) {
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_GET_CONECTION_SCHEDULE_FAILURE,
                          szInsertWC(pszSite1DN),
                          szInsertWC(pszSite2DN),
                          szInsertWC(pszTransportDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


extern "C"
void
IDL_ISMGetConnectionSchedule_notify()
/*++

Routine Description:

    Called by RPC after marshalling *ppSchedule to ship back to the client.

    We take this opportunity to free the structure via the plug-in API.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if ((NULL != gpSchedule) && (NULL != gpTransport)) {
        DPRINT(4, "Freeing connection schedule.\n");
        gpTransport->FreeConnectionSchedule(gpSchedule);

        gpTransport = NULL;
        gpSchedule = NULL;
    }

    gService.m_TransportList.ReleaseLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\ism_server.c ===
#include <ism_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\transprt.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    transprt.cxx

ABSTRACT:

    ISM_TRANSPORT class.  Abstracts interaction with specific plug-in
    transports, defined by DS objects of class Site-Transport.

    Also contains ISM_TRANSPORT_LIST class, which abstracts a collection of
    ISM_TRANSPORT objects.

DETAILS:

CREATED:

    97/12/03    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>
#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>
#include <ntldap.h>
#include "ismserv.hxx"

#define DEBSUB "TRANSPRT:"
#define FILENO FILENO_ISMSERV_TRANSPRT


////////////////////////////////////////////////////////////////////////////////
//
//  ISM_TRANSPORT methods.
//

void
ISM_TRANSPORT::Destroy()
/*++

Routine Description:

    Free the resources associated with an ISM_TRANSPORT object, returning it to
    its un-Init()'ed state.

Arguments:

    None.

Return Values:

    None.

--*/
{
    if (m_fIsInitialized) {
        m_fIsInitialized = FALSE;

        delete [] m_pszTransportDN;

        delete [] m_pszTransportDll;

        (*m_pShutdown)(
            m_hIsm,
            (gService.IsStoppingAndBeingRemoved() ?
             ISM_SHUTDOWN_REASON_REMOVAL : ISM_SHUTDOWN_REASON_NORMAL )
            );

        FreeLibrary(m_hDll);

        Reset();
    }
}


DWORD
ISM_TRANSPORT::Init(
    IN  LPCWSTR         pszTransportDN,
    IN  const GUID *    pTransportGuid,
    IN  LPCWSTR         pszTransportDll
    )
/*++

Routine Description:

    Initialize an ISM_TRANSPORT object.

Arguments:

    pszTransportDN (IN) - The DN of the corresponding Inter-Site-Transport
        object.
    pTransportGuid (IN) - The objectGuid of the corresponding Inter-Site-Transport
        object.
    pszTransportDll (IN) - Name of the associated transport plug-in DLL.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err = NO_ERROR;
    BOOL  fStarted = FALSE;
    LPSTR pszExport = NULL;

    Assert(!m_fIsInitialized);

    // Load plug-in DLL and retrieve its exports.
    m_hDll = LoadLibraryW(pszTransportDll);
    if (NULL == m_hDll) {
        err = GetLastError();
        DPRINT2(0, "Failed to load transport plug-in DLL %ls, error %d.\n",
                pszTransportDll, err);
    }

#define GET_EXPORT(name, type, var) \
    (pszExport = name, var = (type *) GetProcAddress(m_hDll, pszExport))

    if ((NO_ERROR == err)
        && GET_EXPORT("IsmStartup",                ISM_STARTUP,                  m_pStartup)
        && GET_EXPORT("IsmRefresh",                ISM_REFRESH,                  m_pRefresh)
        && GET_EXPORT("IsmSend",                   ISM_SEND,                     m_pSend)
        && GET_EXPORT("IsmReceive",                ISM_RECEIVE,                  m_pReceive)
        && GET_EXPORT("IsmFreeMsg",                ISM_FREE_MSG,                 m_pFreeMsg)
        && GET_EXPORT("IsmGetConnectivity",        ISM_GET_CONNECTIVITY,         m_pGetConnectivity)
        && GET_EXPORT("IsmFreeConnectivity",       ISM_FREE_CONNECTIVITY,        m_pFreeConnectivity)
        && GET_EXPORT("IsmGetTransportServers",    ISM_GET_TRANSPORT_SERVERS,    m_pGetTransportServers)
        && GET_EXPORT("IsmFreeTransportServers",   ISM_FREE_TRANSPORT_SERVERS,   m_pFreeTransportServers)
        && GET_EXPORT("IsmGetConnectionSchedule",  ISM_GET_CONNECTION_SCHEDULE,  m_pGetConnectionSchedule)
        && GET_EXPORT("IsmFreeConnectionSchedule", ISM_FREE_CONNECTION_SCHEDULE, m_pFreeConnectionSchedule)
        && GET_EXPORT("IsmShutdown",               ISM_SHUTDOWN,                 m_pShutdown)) {

        DPRINT1(1, "Loaded transport plug-in DLL %ls.\n", pszTransportDll);
    }
    else {
        err = GetLastError();
        DPRINT3(0, "Failed to find export %s in plug-in DLL %ls, error %d.\n",
                pszExport, pszTransportDll, err);
    }

    if (NO_ERROR == err) {
        // Call transport DLL startup routine.
        err = (*m_pStartup)(pszTransportDN, Notify, this, &m_hIsm);
        fStarted = (NO_ERROR == err);
    }

    if (NO_ERROR == err) {
        // Save transport DN.
        DWORD cchTransportDN = wcslen(pszTransportDN) + 1;
        m_pszTransportDN = new WCHAR[cchTransportDN];

        if (NULL != m_pszTransportDN) {
            memcpy(m_pszTransportDN, pszTransportDN,
                   cchTransportDN * sizeof(WCHAR));
        }
        else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (NO_ERROR == err) {
        // Save transport guid.
        m_TransportGuid = *pTransportGuid;
    }

    if (NO_ERROR == err) {
        // Save transport DLL name.
        DWORD cchTransportDll = wcslen(pszTransportDll) + 1;
        m_pszTransportDll = new WCHAR[cchTransportDll];

        if (NULL != m_pszTransportDll) {
            memcpy(m_pszTransportDll, pszTransportDll,
                   cchTransportDll * sizeof(WCHAR));
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (NO_ERROR == err) {
        DPRINT1(0, "Transport %ls initialized.\n", pszTransportDN);
        m_fIsInitialized = TRUE;
    }
    else {
        DPRINT2(0, "Failed to initialize transport %ls, error %d.\n",
                pszTransportDN, err);

        if (NULL != m_pszTransportDN) {
            delete [] m_pszTransportDN;
        }

        if (NULL != m_pszTransportDll) {
            delete [] m_pszTransportDll;
        }

        if (fStarted) {
            // We could pass ISM_SHUTDOWN_REASON_ERROR if this were useful?
            (*m_pShutdown)(m_hIsm, ISM_SHUTDOWN_REASON_NORMAL);
        }

        if (NULL != m_hDll) {
            FreeLibrary(m_hDll);
        }

        Reset();

        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_TRANSPORT_LOAD_FAILURE,
                          szInsertWC(pszTransportDN),
                          szInsertWC(pszTransportDll),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


DWORD
ISM_TRANSPORT::Refresh(
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR     pszObjectDN
    )
/*++

Routine Description:

    Signals a change in the Inter-Site-Transport object.

Arguments:

    eReason (IN) - Reason code for refresh

    pszObjectDN (IN) - DN of the transport object.  Might be different
        from the value originally given in the Init() call, as the transport
        object can be renamed.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);
    err = (*m_pRefresh)(m_hIsm, eReason, pszObjectDN);

    if (NO_ERROR != err) {
        // Failure to refresh implies shutdown.
        Destroy();

        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_TRANSPORT_REFRESH_FAILURE,
                          szInsertWC(pszObjectDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    return err;
}


void
ISM_TRANSPORT::Notify(
    IN  void *      pvThis,
    IN  LPCWSTR     pszServiceName
    )
{
    ISM_TRANSPORT * pTransport = (ISM_TRANSPORT *) pvThis;

    DPRINT2(3, "Message pending for %ls on transport %ls.\n", pszServiceName,
            pTransport->GetDN());

    LogEvent(DS_EVENT_CAT_ISM,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_ISM_MESSAGE_PENDING,
             szInsertWC(pszServiceName),
             szInsertWC(pTransport->GetDN()),
             NULL);

    pTransport->m_PendingList.Add(pTransport->GetDN(), pszServiceName);
}


////////////////////////////////////////////////////////////////////////////////
//
//  ISM_TRANSPORT_LIST methods.
//

ISM_TRANSPORT *
ISM_TRANSPORT_LIST::Get(
    IN  const GUID *      pTransportGuid
    )
/*++

Routine Description:

    Retrieve the member transport that was initialized from the
    Inter-Site-Transport object with the given objectGuid, or NULL if none.

Arguments:

    pTransportGuid (IN) - The objectGuid to look for.

Return Values:

    A pointer to the associated ISM_TRANSPORT object, or NULL if none.

--*/
{
    for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
        if (0 == memcmp(m_ppTransport[iTransport]->GetGUID(),
                        pTransportGuid, sizeof(GUID))) {
            return m_ppTransport[iTransport];
        }
    }

    return NULL;
}


void
ISM_TRANSPORT_LIST::Destroy()
/*++

Routine Description:

    Free the resources associated with an ISM_TRANSPORT_LIST object, returning
    it to its un-Init()'ed state.

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err;
    DWORD win32err;
    // Run down the transport notification thread

    if ( (NULL != m_hLdap) && (m_ulTransportNotifyMsgNum) ) {
        err = ldap_abandon(m_hLdap, m_ulTransportNotifyMsgNum);
        if (0 != err) { 
            if (!gService.IsStopping()) {
	        win32err = LdapMapErrorToWin32(err);
	        LogEvent8WithData(
		    DS_EVENT_CAT_ISM,
		    DS_EVENT_SEV_ALWAYS,
		    DIRLOG_ISM_LDAP_ABANDON_FAILED,  
		    szInsertWin32Msg( win32err ),
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(win32err),
		    &win32err
		);
	        DPRINT2(0, "Failed to abandon transport notif search -- err %d, %d!\n",
		    err, m_hLdap->ld_errno);
	    }
	}
    }

    if (NULL != m_hTransportMonitorThread) {
        err = WaitForSingleObject(m_hTransportMonitorThread, 3*1000);

        if (WAIT_OBJECT_0 != err) {
	    DWORD gle = GetLastError();
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( gle ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(gle),
		&gle
		);
            DPRINT2(0, "Transport monitor thread failed to terminate -- err %d, gle %d!\n",
                    err, gle);
        }

        CloseHandle(m_hTransportMonitorThread);
    }

    // Run down the site notification thread

    if ( (NULL != m_hLdap)  && (m_ulSiteNotifyMsgNum) ) {
        err = ldap_abandon(m_hLdap, m_ulSiteNotifyMsgNum);
        if (0 != err) {
            if (!gService.IsStopping()) {
	        win32err = LdapMapErrorToWin32(err);
	        LogEvent8WithData(
		    DS_EVENT_CAT_ISM,
		    DS_EVENT_SEV_ALWAYS,
		    DIRLOG_ISM_LDAP_ABANDON_FAILED,  
		    szInsertWin32Msg( win32err ),
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(win32err),
		    &win32err
		    );
                DPRINT2(0, "Failed to abandon site notif search -- err %d, %d!\n",
                    err, m_hLdap->ld_errno);
	    }
        }
    }

    if (NULL != m_hSiteMonitorThread) {
        err = WaitForSingleObject(m_hSiteMonitorThread, 3*1000);

        if (WAIT_OBJECT_0 != err) {
	    DWORD gle = GetLastError();
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( gle ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(gle),
		&gle
		);
            DPRINT2(0, "Site monitor thread failed to terminate -- err %d, gle %d!\n",
                    err, gle);
        }

        CloseHandle(m_hSiteMonitorThread);
    }

    for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
        delete m_ppTransport[iTransport];
    }

    // Yes, realloc() and free() are used since there is no equivalent of
    // realloc() in the new/delete family.
    free(m_ppTransport);

    delete [] m_pszTransportContainerDN;
    delete [] m_pszSiteContainerDN;

    if (NULL != m_hLdap) {
        ldap_unbind(m_hLdap);
    }

    Reset();
}


ISM_TRANSPORT *
ISM_TRANSPORT_LIST::Get(
    IN  LPCWSTR   pszTransportDN
    )
/*++

Routine Description:

    Retrieve the member transport that was initialized from the
    Inter-Site-Transport object with the given DN, or NULL if none.

Arguments:

    pszTransportDN (IN) - The DN to look for.

Return Values:

    A pointer to the associated ISM_TRANSPORT object, or NULL if none.

--*/
{
    Assert(NULL != pszTransportDN);

    if (NULL != pszTransportDN) {
        for (DWORD iTransport = 0; iTransport < m_cNumTransports; iTransport++) {
            if (!_wcsicmp(m_ppTransport[iTransport]->GetDN(), pszTransportDN)) {
                return m_ppTransport[iTransport];
            }
        }
    }

    return NULL;
}


DWORD
ISM_TRANSPORT_LIST::Init()
/*++

Routine Description:

    Initialize the ISM_TRANSPORT_LIST object, populating it with all the
    configured transports.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    AcquireWriteLock();
    __try {
        m_hChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hChangeEvent) {
            err = GetLastError();
            DPRINT1(0, "Unable to CreateEvent(), error %d.\n", err);
            Destroy();
            return err;
        }

        err = InitializeTransports();
        if (NO_ERROR != err) {
            DPRINT1(0, "Unable to InitializeTransports(), error %d.\n", err);
            Destroy();
            return err;
        }

        m_fIsInitialized = TRUE;
    } __finally {
        ReleaseLock();
    }

    return NO_ERROR;
}


DWORD
ISM_TRANSPORT_LIST::Add(
    IN  LPCWSTR         pszTransportDN,
    IN  const GUID *    pTransportGuid,
    IN  LPCWSTR         pszTransportDll
    )
/*++

Routine Description:

    Add given transport with the given definition to the set.

Arguments:

    pszTransportDN (IN) - The DN of the corresponding Inter-Site-Transport
        object.
    pTransportGuid (IN) - The objectGuid of the corresponding Inter-Site-Transport
        object.
    pszTransportDll (IN) - Name of the associated transport plug-in DLL.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD               err;
    ISM_TRANSPORT *     pTransport;
    ISM_TRANSPORT **    ppNewTransportList;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_Lock));

    pTransport = new ISM_TRANSPORT;

    if (NULL != pTransport) {
        err = pTransport->Init(pszTransportDN, pTransportGuid, pszTransportDll);

        if (NO_ERROR == err) {
            // Yes, realloc() and free() are used since there is no equivalent
            // of realloc() in the new/delete family.
            ppNewTransportList =
                (ISM_TRANSPORT **) realloc(m_ppTransport,
                                           sizeof(m_ppTransport[0])
                                             * (1 + m_cNumTransports));

            if (NULL != ppNewTransportList) {
                m_ppTransport = ppNewTransportList;
                m_ppTransport[m_cNumTransports++] = pTransport;
            }
            else {
                DPRINT(0, "Out of memory.\n");
                delete pTransport;
                err = ERROR_OUTOFMEMORY;
            }
        }
        else {
            DPRINT2(0, "Transport %ls failed to initialize, error %d.\n",
                    pszTransportDN, err);
            delete pTransport;
        }
    }
    else {
        DPRINT(0, "Out of memory.\n");
        err = ERROR_OUTOFMEMORY;
    }

    return err;
}


DWORD
ISM_TRANSPORT_LIST::InitializeTransports()
/*++

Routine Description:

    Add an ISM_TRANSPORT object for each Inter-Site-Transport object configured
    in the DS.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err;
    DWORD           win32err;
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext", NULL};
    LPWSTR          rgpszTransportAttrsToRead[] = {L"objectGuid", L"objectClass", L"transportDllName", L"isDeleted", NULL};
    LPWSTR          rgpszSiteAttrsToRead[] = {L"objectGuid", L"objectClass", L"isDeleted", NULL};
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};

    Assert(0 == m_cNumTransports);

    // Connect.
    m_hLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == m_hLdap) {
        DPRINT(0, "Failed to open LDAP connection.\n");
        ldStatus = LDAP_SERVER_DOWN;
    }

    // Bind.
    if (LDAP_SUCCESS == ldStatus) {

        // Force LDAP V3.  Without this, the LDAP client dumbs down to V2 and
        // rejects any searches that use controls.
        Assert(m_hLdap);
        m_hLdap->ld_version = LDAP_VERSION3;

        ldStatus = ldap_bind_s(m_hLdap, NULL, NULL, LDAP_AUTH_NTLM);
       if (LDAP_SUCCESS != ldStatus) {  
	   DPRINT1(0, "Failed to ldap_bind_s(), ldap error %d.\n", ldStatus); 
	   win32err = LdapMapErrorToWin32(ldStatus);
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_LDAP_BIND_FAILED,  
		szInsertWin32Msg( win32err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(win32err),
		&win32err
		);
	}
    }

    // Get the configuration NC.
    if (LDAP_SUCCESS == ldStatus) {
        pResults = NULL;
        ldStatus = ldap_search_s(
                        m_hLdap,
                        NULL,
                        LDAP_SCOPE_BASE,
                        L"(objectClass=*)",
                        rgpszRootAttrsToRead,
                        0,
                        &pResults
                        );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0, "Failed to ldap_search_s() the root, ldap error %d.\n", ldStatus);
            win32err = LdapMapErrorToWin32(ldStatus);
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,  
		szInsertWC( rgpszRootAttrsToRead[0] ),
		szInsertWin32Msg( win32err ),  
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(win32err),
		&win32err
		);
            // bug 327001, ldap_search* functions can return failure and still allocate
            // the result buffer.
            if (pResults) {
                ldap_msgfree(pResults);
            }
        }
    }

    // Derive the location of the Inter-Site Transports container.
    if (LDAP_SUCCESS == ldStatus) {
        const WCHAR szSitesPrefix[] = L"CN=Sites,";
        const WCHAR szTransportsPrefix[] = L"CN=Inter-Site Transports,";
        LPWSTR * ppszConfigNC;
        DWORD cchConfigNC;

        pEntry = ldap_first_entry(m_hLdap, pResults);
        Assert(NULL != pEntry);

        ppszConfigNC = ldap_get_values(m_hLdap, pEntry, L"configurationNamingContext");
        Assert(NULL != ppszConfigNC);
        Assert(1 == ldap_count_values(ppszConfigNC));

        cchConfigNC = wcslen(*ppszConfigNC);

        // Build the sites container
        m_pszSiteContainerDN = new WCHAR[cchConfigNC + ARRAY_SIZE(szSitesPrefix)];
        if (NULL != m_pszSiteContainerDN) {
            wcscpy(m_pszSiteContainerDN, szSitesPrefix);
            wcscat(m_pszSiteContainerDN, *ppszConfigNC);

            DPRINT1(0, "Site container is %ls.\n", m_pszSiteContainerDN);
        }
        else {
            DPRINT(0, "Out of memory.\n");
            ldStatus = LDAP_NO_MEMORY;
        }

        // Build the transports container
        if (LDAP_SUCCESS == ldStatus) {
            m_pszTransportContainerDN = new WCHAR[cchConfigNC + ARRAY_SIZE(szSitesPrefix) - 1 + ARRAY_SIZE(szTransportsPrefix) ];
            if (NULL != m_pszTransportContainerDN) {
                wcscpy(m_pszTransportContainerDN, szTransportsPrefix);
                wcscat(m_pszTransportContainerDN, szSitesPrefix);
                wcscat(m_pszTransportContainerDN, *ppszConfigNC);

                DPRINT1(0, "Transport container is %ls.\n", m_pszTransportContainerDN);
            }
            else {
                DPRINT(0, "Out of memory.\n");
                ldStatus = LDAP_NO_MEMORY;
            }
        }

        ldap_value_free(ppszConfigNC);

        ldap_msgfree(pResults);
    }

    // Register to receive notifications of changes in the contents of the
    // sites container.
    // Note that we start the notification before the initial read so that
    // we are assured there isn't a timing window after the read where
    // changes could be made before the notification is established.
    if (LDAP_SUCCESS == ldStatus) {
        ldStatus = ldap_search_ext(
                        m_hLdap,
                        m_pszSiteContainerDN,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=*)",
                        rgpszSiteAttrsToRead,
                        0,
                        rgpctrlServerCtrls,
                        NULL,
                        0,
                        0,
                        &m_ulSiteNotifyMsgNum
                        );
        if (LDAP_SUCCESS != ldStatus) {
           DPRINT1(0,"Failed to site ldap_search_ext(), ldap error %d.\n",ldStatus);
	   win32err = LdapMapErrorToWin32(ldStatus);
	   LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
		szInsertWC( m_pszSiteContainerDN ),
		szInsertWin32Msg( win32err ),  
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(win32err),
		&win32err
		);
	}
    }

    // Register to receive notifications of changes in the contents of the
    // transports container.
    if (LDAP_SUCCESS == ldStatus) {
        ldStatus = ldap_search_ext(
                        m_hLdap,
                        m_pszTransportContainerDN,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=*)",
                        rgpszTransportAttrsToRead,
                        0,
                        rgpctrlServerCtrls,
                        NULL,
                        0,
                        0,
                        &m_ulTransportNotifyMsgNum
                        );
        if (LDAP_SUCCESS != ldStatus) {
           DPRINT1(0,"Failed to transport ldap_search_ext(), ldap error %d.\n",ldStatus);
	   win32err = LdapMapErrorToWin32(ldStatus);
	   LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
		szInsertWC( m_pszTransportContainerDN ),
		szInsertWin32Msg( win32err ),  
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(win32err),
		&win32err
		);
        }
    }

    // Query for initial contents of transports container.
    if (LDAP_SUCCESS == ldStatus) {
        pResults = NULL;
        ldStatus = ldap_search_s(
                        m_hLdap,
                        m_pszTransportContainerDN,
                        LDAP_SCOPE_ONELEVEL,
                        L"(objectClass=interSiteTransport)",
                        rgpszTransportAttrsToRead,
                        0,
                        &pResults
                        );

        if (LDAP_SUCCESS == ldStatus) {
            UpdateTransportObjects(pResults);
        }
        else {
            DPRINT1(0,"Failed to ldap_search_s(), ldap error %d.\n", ldStatus);
	    win32err = LdapMapErrorToWin32(ldStatus);
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,  
		szInsertWC( m_pszTransportContainerDN ),
		szInsertWin32Msg( win32err ),  
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(win32err),
		&win32err
		);
        }

        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        if (pResults) {
            ldap_msgfree(pResults);
        }
    }

    err = LdapMapErrorToWin32(ldStatus);

    // Start monitoring sites container
    if (NO_ERROR == err) {
        unsigned tid;

        m_hSiteMonitorThread = (HANDLE) _beginthreadex(
                                        NULL,
                                        0,
                                        &MonitorSiteContainerThread,
                                        this,
                                        0,
                                        &tid
                                        );
        if (NULL == m_hSiteMonitorThread) {
            DPRINT(0, "Failed to start MonitorTransportsContainerThread().\n");
            err = -1;
	    LogEvent(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_TRANSPORT_MONITOR_START_FAILURE,    
		NULL,  
		NULL,
		NULL
		);
        }
    }

    // Start monitoring transport container
    if (NO_ERROR == err) {
        unsigned tid;

        m_hTransportMonitorThread = (HANDLE) _beginthreadex(
                                        NULL,
                                        0,
                                        &MonitorTransportsContainerThread,
                                        this,
                                        0,
                                        &tid
                                        );
        if (NULL == m_hTransportMonitorThread) {
            DPRINT(0, "Failed to start MonitorTransportsContainerThread().\n");
            err = -1;
	    LogEvent(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_TRANSPORT_MONITOR_START_FAILURE,    
		NULL,  
		NULL,
		NULL
		);
        }
    }

    return err;
}


unsigned int
__stdcall
ISM_TRANSPORT_LIST::MonitorSiteContainerThread(
    IN  void *  pvThis
    )
/*++

Routine Description:

    Query the DS for any changes in the Site objects and, if
    changes have been made, reflect those changes in the ISM_TRANSPORT object
    list.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err;
    int                     ldStatus;
    LDAPMessage *           pResults;
    ISM_TRANSPORT_LIST *    pThis = (ISM_TRANSPORT_LIST *) pvThis;
    int                     ldResType;
    LPWSTR          rgpszSiteAttrsToRead[] = {L"objectGuid", L"objectClass", L"isDeleted", NULL};
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};

    // pThis->m_fIsInitialized is not set yet
    Assert(pThis->m_hLdap && pThis->m_ulSiteNotifyMsgNum);

    while (1) {

        do {
            // Wait for changes in the transports container.
            ldResType = ldap_result(
                pThis->m_hLdap,
                pThis->m_ulSiteNotifyMsgNum,
                LDAP_MSG_ONE,
                NULL,     // No timeout (wait forever).
                &pResults
                );

            if (gService.IsStopping()) {
                ldStatus = LDAP_SUCCESS;
                break;
            }

            ldStatus = pThis->m_hLdap->ld_errno;

            DPRINT3(2, "Back from site ldap_result(): ldResType = 0x%x, ldStatus = 0x%x, pResults = %p.\n",
                    ldResType, ldStatus, pResults);

            if (LDAP_RES_SEARCH_ENTRY == ldResType) {
                Assert(LDAP_SUCCESS == ldStatus);

                pThis->AcquireWriteLock();
                __try {
                    ldStatus = pThis->UpdateSiteObjects(pResults);

                    ldap_msgfree(pResults);
                }
                __finally {
                    pThis->ReleaseLock();
                }
            }
        } while (LDAP_SUCCESS == ldStatus);

        // See if we are really shutting down
        err = WaitForSingleObject( gService.m_hShutdown, 60 * 1000 );
        if ( (err != WAIT_OBJECT_0) &&
             (err != WAIT_TIMEOUT) ) {
	    DWORD gle = GetLastError();
            DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                     err, gle );
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( gle ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(gle),
		&gle
		);
        }

        if (gService.IsStopping()) {
            // Ignore errors on shutdown
            err = LDAP_SUCCESS;
            break;
        }

        DPRINT1(0, "Failed to site ldap_result(), error %d; retrying notification.\n",
                ldStatus);
        err = LdapMapErrorToWin32(ldStatus);
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                          szInsertWC(pThis->m_pszSiteContainerDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
        // Assert( !"Ldap search terminated prematurely" );

        // Error recovery - start a new search
        // This can occur under some legitimate circumstances, such as when
        // Kerberos tickets expire.

        err = ldap_abandon(pThis->m_hLdap, pThis->m_ulSiteNotifyMsgNum);
        // ignore error

        ldStatus = ldap_search_ext(
            pThis->m_hLdap,
            pThis->m_pszSiteContainerDN,
            LDAP_SCOPE_ONELEVEL,
            L"(objectClass=*)",
            rgpszSiteAttrsToRead,
            0,
            rgpctrlServerCtrls,
            NULL,
            0,
            0,
            &(pThis->m_ulSiteNotifyMsgNum)
            );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to site ldap_search_ext(), ldap error %d.\n",ldStatus);
            err = LdapMapErrorToWin32(ldStatus);
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_TRANSPORT_MONITOR_FAILURE,
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(err),
                              &err);
            break;
        }

    } // while (1)

    return err;
}


unsigned int
__stdcall
ISM_TRANSPORT_LIST::MonitorTransportsContainerThread(
    IN  void *  pvThis
    )
/*++

Routine Description:

    Query the DS for any changes in the Inter-Site-Transport objects and, if
    changes have been made, reflect those changes in the ISM_TRANSPORT object
    list.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err;
    int                     ldStatus;
    LDAPMessage *           pResults;
    ISM_TRANSPORT_LIST *    pThis = (ISM_TRANSPORT_LIST *) pvThis;
    int                     ldResType;
    LPWSTR          rgpszTransportAttrsToRead[] = {L"objectGuid", L"objectClass", L"transportDllName", L"isDeleted", NULL};
    LDAPControl     ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *   rgpctrlServerCtrls[] = {&ctrlNotify, NULL};

    // pThis->m_fIsInitialized is not set yet
    Assert(pThis->m_hLdap && pThis->m_ulTransportNotifyMsgNum);

    while (1) {

        do {
            // Wait for changes in the transports container.
            ldResType = ldap_result(
                pThis->m_hLdap,
                pThis->m_ulTransportNotifyMsgNum,
                LDAP_MSG_ONE,
                NULL,     // No timeout (wait forever).
                &pResults
                );

            if (gService.IsStopping()) {
                ldStatus = LDAP_SUCCESS;
                break;
            }

            ldStatus = pThis->m_hLdap->ld_errno;

            DPRINT3(2, "Back from transport ldap_result(): ldResType = 0x%x, ldStatus = 0x%x, pResults = %p.\n",
                    ldResType, ldStatus, pResults);

            if (LDAP_RES_SEARCH_ENTRY == ldResType) {
                Assert(LDAP_SUCCESS == ldStatus);

                pThis->AcquireWriteLock();
                __try {
                    // Inform interested parties that the transport list is
                    // changing.
                    SetEvent(pThis->m_hChangeEvent);

                    ldStatus = pThis->UpdateTransportObjects(pResults);

                    ldap_msgfree(pResults);
                }
                __finally {
                    pThis->ReleaseLock();
                }
            }
        } while (LDAP_SUCCESS == ldStatus);

        // See if we are really shutting down
        err = WaitForSingleObject( gService.m_hShutdown, 60 * 1000 );
        if ( (err != WAIT_OBJECT_0) &&
             (err != WAIT_TIMEOUT) ) {
	    DWORD gle = GetLastError();
            DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                     err, gle );
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( gle ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(gle),
		&gle
		);
        }

        if (gService.IsStopping()) {
            // Ignore errors on shutdown
            err = ERROR_SUCCESS;
            break;
        }

        DPRINT1(0, "Failed to transport ldap_result(), error %d; retrying notification.\n",
                ldStatus);
        err = LdapMapErrorToWin32(ldStatus);
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                          szInsertWC(pThis->m_pszTransportContainerDN),
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
        // Assert( !"Ldap search terminated prematurely" );

        // Error recovery - start a new search
        // This can occur under some legitimate circumstances, such as when
        // Kerberos tickets expire.

        err = ldap_abandon(pThis->m_hLdap, pThis->m_ulTransportNotifyMsgNum);
        // ignore error

        ldStatus = ldap_search_ext(
            pThis->m_hLdap,
            pThis->m_pszTransportContainerDN,
            LDAP_SCOPE_ONELEVEL,
            L"(objectClass=*)",
            rgpszTransportAttrsToRead,
            0,
            rgpctrlServerCtrls,
            NULL,
            0,
            0,
            &(pThis->m_ulTransportNotifyMsgNum)
            );
        if (LDAP_SUCCESS != ldStatus) {
            DPRINT1(0,"Failed to transport ldap_search_ext(), ldap error %d.\n",ldStatus);

            err = LdapMapErrorToWin32(ldStatus);
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_TRANSPORT_MONITOR_FAILURE,
                              szInsertWin32Msg(err),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(err),
                              &err);
            break;
        }

    } // while (1)

    return err;
}


int
ISM_TRANSPORT_LIST::UpdateSiteObjects(
    IN  LDAPMessage *   pResults
    )
/*++

Routine Description:

Notify the transport objects of changes to the site list

Arguments:

    pResults (IN) - The DS objects.

Return Values:

    LDAP_SUCCESS - Success.
    LDAP_* - Failure.

--*/
{
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pEntry;

    // For each site object...
    for (pEntry = ldap_first_entry(m_hLdap, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(m_hLdap, pEntry)) {

        LPWSTR              pszSiteDN;
        LPWSTR *            ppszObjectClass;
        LPWSTR *            ppszIsDeleted;
        struct berval **    ppbvObjectGuid;
        GUID *              pObjectGuid;
        BOOL                fIsDeleted;
        ISM_TRANSPORT *     pTransport;
        DWORD               err, iTransport;

        // Retrieve its interesting attributes.
        pszSiteDN = ldap_get_dn(m_hLdap, pEntry);
        Assert(NULL != pszSiteDN);

        ppbvObjectGuid = ldap_get_values_len(m_hLdap, pEntry, L"objectGuid");
        Assert(NULL != ppbvObjectGuid);

        ppszObjectClass = ldap_get_values(m_hLdap, pEntry, L"objectClass");
        Assert(NULL != ppszObjectClass);

        ppszIsDeleted = ldap_get_values(m_hLdap, pEntry, L"isDeleted");

        if ((NULL != pszSiteDN)
            && (NULL != ppbvObjectGuid)
            && (NULL != ppszObjectClass)) {

            Assert(1 == ldap_count_values_len(ppbvObjectGuid));
            Assert(sizeof(GUID) == ppbvObjectGuid[0]->bv_len);
            Assert((NULL == ppszIsDeleted)
                   || (1 == ldap_count_values(ppszIsDeleted)));

            fIsDeleted = (NULL != ppszIsDeleted)
                         && (0 == _wcsicmp(*ppszIsDeleted, L"TRUE"));

            pObjectGuid = (GUID *) ppbvObjectGuid[0]->bv_val;

            // Notify transports
            for( iTransport = 0; iTransport < m_cNumTransports; iTransport++ ){
                pTransport = m_ppTransport[iTransport];

                // Notify on all kinds of site changes
                err = pTransport->Refresh(ISM_REFRESH_REASON_SITE, pszSiteDN);
                if (NO_ERROR == err) {
                    DPRINT2(0, "Refreshed transport %ls with site %ls.\n",
                            pTransport->GetDN(), pszSiteDN);
                }
                else {
                    DPRINT3(0, "Failed to refresh transport %ls with site %ls, error %d.\n",
                            pTransport->GetDN(), pszSiteDN, err);
                }
            }
        }
        else {
            DPRINT1(0, "Failed to read critical attributes for site %ls; ignoring.\n",
                    pszSiteDN ? pszSiteDN : L"");
	    LogEvent(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_CRITICAL_SITE_ATTRIBUTE_FAILURE,  
		szInsertWC( pszSiteDN ),
		NULL,
		NULL
		);
        }

        if (NULL != pszSiteDN) {
            ldap_memfree(pszSiteDN);
        }

        if (NULL != ppbvObjectGuid) {
            ldap_value_free_len(ppbvObjectGuid);
        }

        if (NULL != ppszObjectClass) {
            ldap_value_free(ppszObjectClass);
        }

        if (NULL != ppszIsDeleted) {
            ldap_value_free(ppszIsDeleted);
        }
    }

    return ldStatus;
}

int
ISM_TRANSPORT_LIST::UpdateTransportObjects(
    IN  LDAPMessage *   pResults
    )
/*++

Routine Description:

    Update the list of in-memory ISM_TRANSPORT objects given a set of
    corresponding DS objects.

Arguments:

    pResults (IN) - The DS objects.

Return Values:

    LDAP_SUCCESS - Success.
    LDAP_* - Failure.

--*/
{
    int             ldStatus = LDAP_SUCCESS;
    LDAPMessage *   pEntry;

    // For each transport object...
    for (pEntry = ldap_first_entry(m_hLdap, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(m_hLdap, pEntry)) {

        LPWSTR              pszTransportDN;
        LPWSTR *            ppszTransportDll;
        LPWSTR *            ppszObjectClass;
        LPWSTR *            ppszIsDeleted;
        struct berval **    ppbvObjectGuid;
        GUID *              pObjectGuid;
        BOOL                fIsDeleted;
        ISM_TRANSPORT *     pTransport;
        DWORD               err;
        BOOL                fAddNewTransport;

        // Retrieve its interesting attributes.
        pszTransportDN = ldap_get_dn(m_hLdap, pEntry);
        Assert(NULL != pszTransportDN);

        ppbvObjectGuid = ldap_get_values_len(m_hLdap, pEntry, L"objectGuid");
        Assert(NULL != ppbvObjectGuid);
        Assert(1 == ldap_count_values_len(ppbvObjectGuid));
        Assert(sizeof(GUID) == ppbvObjectGuid[0]->bv_len);

        ppszObjectClass = ldap_get_values(m_hLdap, pEntry, L"objectClass");
        Assert(NULL != ppszObjectClass);

        ppszIsDeleted = ldap_get_values(m_hLdap, pEntry, L"isDeleted");
        Assert((NULL == ppszIsDeleted)
               || (1 == ldap_count_values(ppszIsDeleted)));
        fIsDeleted = (NULL != ppszIsDeleted)
                     && (0 == _wcsicmp(*ppszIsDeleted, L"TRUE"));

        ppszTransportDll = ldap_get_values(m_hLdap, pEntry, L"transportDllName");
        Assert((NULL != ppszTransportDll) || fIsDeleted);
        Assert((NULL == ppszTransportDll)
               || (1 == ldap_count_values(ppszTransportDll)));

        if ((NULL != pszTransportDN)
            && (NULL != ppbvObjectGuid)
            && (NULL != ppszObjectClass)) {

            pObjectGuid = (GUID *) ppbvObjectGuid[0]->bv_val;
            pTransport = Get(pObjectGuid);

            fAddNewTransport = (NULL == pTransport) && !fIsDeleted;

            if (NULL != pTransport) {
                // Update pre-existing transport.
                if (!fIsDeleted) {
                    if ((NULL != ppszTransportDll)
                        && (0 != _wcsicmp(pTransport->GetDLL(),
                                          ppszTransportDll[0]))) {
                        // The DLL for this transport has changed.
                        // Unload current DLL and load new one.
                        DPRINT1(0, "Switching to new DLL for transport %ls.\n",
                                pTransport->GetDN());
                        Delete(pTransport);
                        fAddNewTransport = TRUE;
                    } else {
                        err = pTransport->Refresh(ISM_REFRESH_REASON_TRANSPORT,
                                                  pszTransportDN);
                        if (NO_ERROR == err) {
                            DPRINT1(0, "Refreshed transport %ls.\n", pszTransportDN);
                        }
                        else {
                            DPRINT2(0, "Failed to refresh transport %ls, error %d.\n",
                                    pszTransportDN, err);
                        }
                    }
                }
                else {
                    // Transport has been deleted.
                    DPRINT1(0, "Deleting transport %ls.\n", pTransport->GetDN());
                    Delete(pTransport);
                }
            }

            if (fAddNewTransport) {
                if (NULL != ppszTransportDll) {
                    gService.SetStatus(); // Give SCM a status report

                    // Add new transport.
                    err = Add(pszTransportDN, pObjectGuid, ppszTransportDll[0]);
                    if (NO_ERROR == err) {
                        DPRINT1(0, "Added transport %ls.\n", pszTransportDN);
                    }
                    else {
                        DPRINT2(0, "Failed to add transport %ls, error %d.\n",
                                pszTransportDN, err);
                    }

                    gService.SetStatus(); // Give SCM a status report
                } else {
                    DPRINT1(0, "Failed to read critical attribute transportDllName for transport %ls; ignoring.\n",
                            pszTransportDN ? pszTransportDN : L"");
		    LogEvent(
			DS_EVENT_CAT_ISM,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ISM_CRITICAL_TRANSPORT_ATTRIBUTE_FAILURE,  
			szInsertWC( pszTransportDN ),
			NULL,
			NULL
			);
		}
            }
        }
        else {
            DPRINT1(0, "Failed to read critical attributes for transport %ls; ignoring.\n",
                    pszTransportDN ? pszTransportDN : L"");
	    LogEvent(
			DS_EVENT_CAT_ISM,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ISM_CRITICAL_TRANSPORT_ATTRIBUTE_FAILURE,  
			szInsertWC( pszTransportDN ),
			NULL,
			NULL
			);
        }

        if (NULL != pszTransportDN) {
            ldap_memfree(pszTransportDN);
        }

        if (NULL != ppszTransportDll) {
            ldap_value_free(ppszTransportDll);
        }

        if (NULL != ppbvObjectGuid) {
            ldap_value_free_len(ppbvObjectGuid);
        }

        if (NULL != ppszObjectClass) {
            ldap_value_free(ppszObjectClass);
        }

        if (NULL != ppszIsDeleted) {
            ldap_value_free(ppszIsDeleted);
        }
    }

    return ldStatus;
}


VOID
ISM_TRANSPORT_LIST::Delete(
    IN  ISM_TRANSPORT * pTransport
    )
/*++

Routine Description:

    Remove the given ISM_TRANSPORT from the list.

Arguments:

    pTransport (IN) - Transport to remove.

Return Values:

    None.

--*/
{
    DWORD i;
    BOOL  fFound = FALSE;

    Assert(OWN_RESOURCE_EXCLUSIVE(&m_Lock));

    for (i = 0; i < m_cNumTransports; i++) {
        if (pTransport == m_ppTransport[i]) {
            // Remove pTransport from the list.
            memmove(&m_ppTransport[i],
                    &m_ppTransport[i+1],
                    (m_cNumTransports - (i + 1)) * sizeof(*m_ppTransport));
            m_cNumTransports--;
            fFound = TRUE;
            break;
        }
    }

    Assert(fFound);

    delete pTransport;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\pending.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    pending.cxx

ABSTRACT:

    ISM_PENDING_LIST class.  Tracks pending messages for a specific transport.

DETAILS:

CREATED:

    97/01/13    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ism.h>
#include <ismapi.h>
#include <debug.h>
#include <fileno.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <mdcodes.h>
#include "ismserv.hxx"

#define DEBSUB "PENDING:"
#define FILENO FILENO_ISMSERV_PENDING


void
ISM_PENDING_LIST::Add(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        pPending = GetPendingEntry(pszTransportDN, pszServiceName);

        if (NULL != pPending) {
            SetEvent(pPending->hEvent);
        }
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }
}


HANDLE
ISM_PENDING_LIST::GetEvent(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;
    HANDLE              hEvent = NULL;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        pPending = GetPendingEntry(pszTransportDN, pszServiceName);

        if (NULL != pPending) {
            hEvent = pPending->hEvent;
        }
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }

    return hEvent;
}


void
ISM_PENDING_LIST::Destroy()
{
    ISM_PENDING_ENTRY * pPending;
    ISM_PENDING_ENTRY * pPendingNext;

    RtlEnterCriticalSection(&m_Lock);
    __try {
        for (pPending = m_pPending; NULL != pPending; pPending = pPendingNext) {
            pPendingNext = pPending->pNext;
            delete pPending;
        }

        m_pPending = NULL;
    }
    __finally {
        RtlLeaveCriticalSection(&m_Lock);
    }
}



LPWSTR
buildEventName(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )

/*++

Routine Description:

Construct an event name based on the transport dn and the service name

Use only the first RDN of the transport DN.

The constructed name looks like:

_NT_DS_ISM_<transport rdn><service name>

Arguments:

    pszTransportDN - 
    pszServiceName - 

Return Value:

    LPWSTR - allocated event name string, or null on error

--*/

{
#define EVENT_NAME_PREFIX L"_NT_DS_ISM_"
    LPWSTR eventName, start, end;
    DWORD length, total;

    Assert( pszTransportDN );
    Assert( pszServiceName );

    // Extract the first RDN.  If we can't find the separators, use the whole
    start = wcschr( pszTransportDN, L'=' );
    if (start) {
        pszTransportDN = start + 1;
        end = wcschr( pszTransportDN, L',' );
        if (end) {
            length = (DWORD)(end - pszTransportDN);
        } else {
            length = wcslen( pszTransportDN );
        }
    } else {
        DPRINT1( 0, "Malformed transport dn, %ws\n", pszTransportDN );
	LogEvent(
	    DS_EVENT_CAT_ISM,
	    DS_EVENT_SEV_ALWAYS,
	    DIRLOG_ISM_DS_BAD_NAME_SYNTAX,  
	    szInsertWC(pszTransportDN),
	    szInsertWC(pszServiceName),
	    NULL
	    );
        return NULL;
    }

    total = wcslen( EVENT_NAME_PREFIX ) +
        length +
        wcslen( pszServiceName ) +
        1;

    eventName = new WCHAR [total];
    if (eventName == NULL) {
        DPRINT( 0, "Memory allocation failed\n" );
	LogEvent(
	    DS_EVENT_CAT_ISM,
	    DS_EVENT_SEV_ALWAYS,
	    DIRLOG_ISM_NOT_ENOUGH_MEMORY,  
	    szInsertWC(pszTransportDN),
	    szInsertWC(pszServiceName),
	    NULL 
	    );
        return NULL;
    }

    start = eventName;
    wcsncpy( start, EVENT_NAME_PREFIX, wcslen( EVENT_NAME_PREFIX ) );
    start += wcslen( EVENT_NAME_PREFIX );
    wcsncpy( start, pszTransportDN, length );
    start += length;
    wcscpy( start, pszServiceName );

    DPRINT1( 3, "buildEventName, %ws\n", eventName );

    return eventName;

} /* buildEventName */

ISM_PENDING_ENTRY *
ISM_PENDING_LIST::GetPendingEntry(
    IN LPCWSTR pszTransportDN,
    IN LPCWSTR pszServiceName
    )
{
    ISM_PENDING_ENTRY * pPending;

    for (pPending = m_pPending; NULL != pPending; pPending = pPending->pNext) {
        if (0 == _wcsicmp(pszServiceName, pPending->szServiceName)) {
            // Found it.
            break;
        }
    }

    if (NULL == pPending) {
        // Not found; add it.
        pPending = (ISM_PENDING_ENTRY *) new BYTE[
                        offsetof(ISM_PENDING_ENTRY, szServiceName)
                        + sizeof(WCHAR) * (1 + wcslen(pszServiceName))];

        if (NULL != pPending) {
            LPWSTR pszEventName;

            pPending->hEvent = NULL;

            pszEventName = buildEventName( pszTransportDN, pszServiceName );
            if (pszEventName) {
                // Auto-reset, initially non-signalled.
                pPending->hEvent = CreateEventW(NULL, FALSE, FALSE, pszEventName);

                if (pszEventName) {
                    delete pszEventName;
                }
            }
            if (NULL != pPending->hEvent) {
                wcscpy(pPending->szServiceName, pszServiceName);

                // Add new entry to the list.
                pPending->pNext = m_pPending;
                m_pPending = pPending;
            }
            else {
                // Failed to CreateEvent().
                DWORD err = GetLastError();
                
                DPRINT1(0, "Failed to CreateEvent(), error %d.\n", err);  
		LogEvent8WithData(
		    DS_EVENT_CAT_ISM,
		    DS_EVENT_SEV_ALWAYS,
		    DIRLOG_ISM_CREATE_EVENT_FAILED,
		    szInsertWC(pszServiceName),
		    szInsertWC(pszTransportDN),
		    szInsertWin32Msg( err ),  
		    NULL,
		    NULL, NULL, NULL, NULL,
		    sizeof( err ),
		    &err);                
		delete pPending;
		pPending = NULL;
            }
        }
    }

    return pPending;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\graph.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    graph.c

Abstract:

    Graph routines.

    The current implementation uses a matrix to represent the edge costs.  This is because the
    all pairs shortest cost algorithm uses an array as input, and also because the ISM ultimately
    wants an connectivity information as a matrix.

    It also uses a sparse array for the schedules.  This is with the expectation that scheduled
    Site-Links will be unusual.  We could also have used an array of pointers to schedules.

Author:

    Will Lees (wlees) 22-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>
#include <schedule.h>

#include "common.h"

#define DEBSUB "IPGRAPH:"

// An element in the sparse array
typedef struct _SPARSE_ELEMENT {
    DWORD To;
    PBYTE pSchedule;
    struct _SPARSE_ELEMENT *Next;
} SPARSE_ELEMENT, *PSPARSE_ELEMENT;

// An instance of type graph.  Returned by GraphCreate.  The head of the data structure
typedef struct _GRAPH_INSTANCE {
    DWORD Size;
    DWORD NumberElements;
    PISM_LINK LinkArray;
    PSPARSE_ELEMENT *SparseArray;
} GRAPH, *PGRAPH;

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 27 10:58:50 1998 */

void
GraphAllCosts(
    PGRAPH Graph,
    BOOL fIgnoreSchedules
    );

void
GraphMerge(
    PGRAPH FinalGraph,
    PGRAPH TempGraph
    );

PGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    );

DWORD
GraphAddEdgeIfBetter(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

DWORD
GraphInit(
    PGRAPH Graph
    );

void
GraphFree(
    PGRAPH Graph
    );

void
GraphReferenceMatrix(
    PGRAPH Graph,
    PISM_LINK *ppLinkArray
    );

VOID
GraphDereferenceMatrix(
    PGRAPH Graph,
    PISM_LINK pLinkArray
    );

DWORD
GraphGetPathSchedule(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    );

void
GraphComputeTransitiveClosure(
    IN OUT  GRAPH *     pGraph
    );

static PBYTE
sparseScheduleFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    );

static void
sparseArrayFree(
    PGRAPH Graph
    );

static void
sparseElementFree(
    PSPARSE_ELEMENT Element
    );

static DWORD
SparseScheduleAddDel(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE pTemplateSchedule
    );

static PSPARSE_ELEMENT
sparseElementFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    );

static BOOLEAN
scheduleOverlap(
    PBYTE pSchedule1,
    PBYTE pSchedule2,
    PBYTE *ppNewSchedule
    );

static BOOLEAN
scheduleEmpty(
    PBYTE pSchedule
    );

static DWORD
scheduleLength(
    PBYTE pSchedule
    );

static PBYTE
scheduleAllocCopy(
    PBYTE pSchedule
    );

static DWORD
scheduleDuration(
    PBYTE pSchedule
    );

/* End Forward */


void
GraphAllCosts(
    PGRAPH Graph,
    BOOL fIgnoreSchedules
    )

/*++

Routine Description:

    Find the shortest path between all pairs of nodes

    When a path is updated, its schedule is considered.  If they paths are have a common schedule,
    the path can be chosen.  When two weights are the same, the path with the most available
    schedule is chosen.

    SCALING BUG 87827: this is an order(n^3) algorithm

    This algorithm is taken from:
    Fundamentals of Data Structures, Horowitz and Sahni,
    Computer Science Press, 1976, pp. 307

    for k = 1 to n
        for i = 1 to n
            for j = 1 to n
                A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

    "Some speed up can be obtained by noticing that the innermost for loop
     need be executed only when A(i,k) and A(k,j) are not equal to infinity."

Arguments:

    IN OUT CostArray (global) - Input is cost matrix, Output is shortest path array

Return Value:

    None

--*/

{
    DWORD NumberSites = Graph->NumberElements;
    PISM_LINK LinkArray = Graph->LinkArray;
    PISM_LINK pElement1, pElement2, pElement3;
    ISM_LINK newPath;
    DWORD i, j, k, cost1, cost2, cost3;
    PBYTE pS1, pS2, pS3, pS23;
    BOOLEAN replace;

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }

    for( k = 0; k < NumberSites; k++ ) {

        for( i = 0; i < NumberSites; i++ ) {

            pElement2 = &( LinkArray[ i * NumberSites + k ] );
            cost2 = pElement2->ulCost;
            if (cost2 == INFINITE_COST) {
                continue;
            }

            pS2 = sparseScheduleFind( Graph, i, k );

            for( j = 0; j < NumberSites; j++ ) {

                // A(i,j) <- min{ A(i,j) , A(i,k)+A(k,j) }

                pElement1 = &( LinkArray[ i * NumberSites + j ] );

                cost1 = pElement1->ulCost;
                pS1 = sparseScheduleFind( Graph, i, j );

                pElement3 = &( LinkArray[ k * NumberSites + j ] );
                cost3 = pElement3->ulCost;
                if (cost3 == INFINITE_COST) {
                    continue;
                }
                pS3 = sparseScheduleFind( Graph, k, j );

                // These equations aggregate attributes along a path
                newPath.ulCost = cost2 + cost3;
                newPath.ulReplicationInterval =
                    MAX( pElement2->ulReplicationInterval,
                         pElement3->ulReplicationInterval );
                newPath.ulOptions =
                    pElement2->ulOptions & pElement3->ulOptions;

                if (!fIgnoreSchedules) {
                    // Consider Schedules

                    // new weight must be better or not a candidate
                    if (newPath.ulCost > cost1 ) {
                        continue;
                    }

                    if (!scheduleOverlap( pS2, pS3, &pS23 )) {
                        continue;   // no common schedule for candidate
                    }

                    replace = TRUE;

                    // If weights the same, schedule must be better
                    if (newPath.ulCost == cost1) {
                        replace = scheduleDuration( pS23 ) > scheduleDuration( pS1 );
                    }

                    if (replace) {
                        *pElement1 = newPath;
                        SparseScheduleAddDel( Graph, i, j, pS23 );
                    }

                    if (pS23) {
                        FREE_TYPE( pS23 );
                    }

                } else {

                    // Don't consider schedules
                    if (newPath.ulCost < cost1 ) {
                        *pElement1 = newPath;
                    }
                }

            }
        }
    }
}


void
GraphMerge(
    PGRAPH FinalGraph,
    PGRAPH TempGraph
    )

/*++

Routine Description:

"OR" two graphs together, such that an edge is added only if it is better than what was there
before.  Better is defined as small weight, or more available schedule if the weights are the
same.

Arguments:

    FinalGraph - 
    TempGraph - 

Return Value:

    None

--*/

{
    DWORD NumberSites = FinalGraph->NumberElements;
    DWORD i, j, new, *pElement;
    PBYTE pOldSchedule, pNewSchedule;
    BOOLEAN replace;

    if ( (FinalGraph->Size != sizeof( GRAPH )) ||
         (TempGraph->Size != sizeof( GRAPH )) ||
         (FinalGraph->NumberElements != TempGraph->NumberElements) ||
         (FinalGraph->LinkArray == NULL) ||
         (TempGraph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }

    for( i = 0; i < NumberSites; i++ ) {

        for( j = 0; j < NumberSites; j++ ) {

            pElement = &(FinalGraph->LinkArray[i * NumberSites + j].ulCost);

            new = TempGraph->LinkArray[i * NumberSites + j].ulCost;
            pNewSchedule = sparseScheduleFind( TempGraph, i, j );

            // Replace old value with new value *only* if smaller, or better schedule

            replace = FALSE;
            if (new == *pElement) {
                pOldSchedule = sparseScheduleFind( FinalGraph, i, j );
                replace =
                    scheduleDuration( pNewSchedule ) > scheduleDuration( pOldSchedule );
            } else {
                replace = (new < *pElement);
            }

            // Replace element value
            if (replace) {
                *pElement = new;

                // replace schedule
                SparseScheduleAddDel( FinalGraph, i, j, pNewSchedule );
            }

        }

    }
} /* GraphMerge */


PGRAPH
GraphCreate(
    DWORD NumberElements,
    BOOLEAN Initialize
    )

/*++

Routine Description:

Create a new graph.

The sparse array part is not allocated until used.

Arguments:

    NumberElements - 
    Initialize - 

Return Value:

    PGRAPH - 

--*/

{
    PGRAPH graph = NULL;
    DWORD i;

    // use calloc so cleanup can know whether to free embedded pointers
    graph = NEW_TYPE_ARRAY_ZERO( 1, GRAPH );
    if (graph == NULL) {
        return NULL;
    }

    // INITIALIZE GRAPH INSTANCE
    graph->Size = sizeof( GRAPH );
    graph->NumberElements = NumberElements;

    graph->LinkArray = NEW_TYPE_ARRAY(
        NumberElements * NumberElements, ISM_LINK );
    if (graph->LinkArray == NULL) {
        goto cleanup;
    }

    // Not allocated yet
    graph->SparseArray = NULL;

    // INITIALIZE GRAPH INSTANCE

    if (Initialize) {
        GraphInit( graph );
    }

    return graph;

cleanup:
    if (graph->LinkArray) {
        FREE_TYPE( graph->LinkArray );
    }
    if (graph->SparseArray) {
        FREE_TYPE( graph->SparseArray );
    }
    if (graph) {
        FREE_TYPE( graph );
    }
    return NULL;
} /* GraphCreate */


DWORD
GraphAddEdgeIfBetter(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    )

/*++

Routine Description:

Add an edge to the graph, only if it is better.
Better is defined as lower weight, or more available schedule.

Arguments:

    Graph - 
    From - 
    To - 
    Value - 
    pSchedule - may be NULL, indicating connectivity at all times

Return Value:

    DWORD - 

--*/

{
    PISM_LINK pElement;
    BOOLEAN replace;
    PBYTE pOldSchedule;

    DPRINT5( 4, "GraphAddEdgeIfBetter, From=%d, To=%d, Value=(%d,%d), pSched=%p\n",
             From, To,
             pLinkValue->ulCost, pLinkValue->ulReplicationInterval,
             pSchedule );

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Don't add obvious bad connections
    if ( scheduleEmpty( pSchedule ) || (pLinkValue->ulCost == INFINITE_COST)) {
        DPRINT( 1, "Not adding edge because schedule empty or weight infinite\n" );
        return ERROR_SUCCESS;
    }

    pElement = &( Graph->LinkArray[ From * Graph->NumberElements + To ] );

    // See if the new value is better, or the schedule is better
    replace = FALSE;
    if (pLinkValue->ulCost == pElement->ulCost) {
        pOldSchedule = sparseScheduleFind( Graph, From, To );
        replace = scheduleDuration( pSchedule ) > scheduleDuration( pOldSchedule );
    } else {
        replace = (pLinkValue->ulCost < pElement->ulCost);
    }

    if (replace) {
        *pElement = *pLinkValue;
        SparseScheduleAddDel( Graph, From, To, pSchedule );
    }

    return ERROR_SUCCESS;
} /* GraphAddEdgeIfBetter */


DWORD
GraphInit(
    PGRAPH Graph
    )

/*++

Routine Description:

Clear out old values in a graph.  Graph must already be created.  Graph may or may not
have any sparse elements yet.

Arguments:

    Graph - 

Return Value:

    DWORD - 

--*/

{
    DWORD i, number = Graph->NumberElements;

    if ( (Graph->Size != sizeof( GRAPH ) ) ||
         (Graph->LinkArray == NULL ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Zero the array of structures
    ZeroMemory( Graph->LinkArray, number * number * sizeof( ISM_LINK ) );

    // Initially all costs are infinite
    for( i = 0; i < number * number; i++ ) {
        Graph->LinkArray[i].ulCost = INFINITE_COST;
    }
    
    // Cost to ourselves is zero
    for( i = 0; i < number; i++ ) {
        Graph->LinkArray[i * number + i].ulCost = 0; // loopback cost
    }

    sparseArrayFree( Graph );

    return ERROR_SUCCESS;
} /* GraphInit */


void
GraphFree(
    PGRAPH Graph
    )

/*++

Routine Description:

Deallocate a graph.
May or may not have any sparse elements.
It may or may not have had its matrix extracted.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (Graph->LinkArray != NULL) {
        FREE_TYPE( Graph->LinkArray );
    }
    Graph->LinkArray = NULL;

    sparseArrayFree( Graph );

    FREE_TYPE( Graph );
} /* GraphFree */


void
GraphReferenceMatrix(
    PGRAPH Graph,
    PISM_LINK *ppLinkArray
    )

/*++

Routine Description:

Copy the cost matrix out

The caller must release the matrix when he is finished using the
GraphDereferenceMatrix function.

Arguments:

    Graph - 
    ppArray - 

Return Value:

    None

--*/

{
    PISM_LINK pLinkArray = NULL;
    DWORD number, i, j, index;

    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return;
    }
    if (ppLinkArray == NULL) {
        DPRINT( 0, "Invalid parameter\n" );
        return;
    }

    number = Graph->NumberElements;

    // Allocate a new array to hold the cost matrix
    pLinkArray = NEW_TYPE_ARRAY( number * number, ISM_LINK );
    if (pLinkArray == NULL) {
        goto cleanup;
    }

    CopyMemory( pLinkArray, Graph->LinkArray,
                number * number * sizeof( ISM_LINK ) );

cleanup:

    *ppLinkArray = pLinkArray;
    // Note, Graph is still alive and well at this point

} /* GraphReturnMatrix */


VOID
GraphDereferenceMatrix(
    PGRAPH Graph,
    PISM_LINK pLinkArray
    )

/*++

Routine Description:

Release a matrix reference.

The idea behind the reference/dereference api is to allow us to return a
pointer to the matrix instead of copying it each time.  This is useful when
the caller is himself going to copy the data, and will protect our reference
from corruption by users.

The problem with this approach is that a reference to the matrix implies
a reference count on the graph, so it won't go away while it is referenced.
TODO: implement reference counts

Arguments:

    Graph - 
    pLinkArray - 

Return Value:

    None

--*/

{
    // Warning, at this writing there is no reference count on the graph, so
    // it may be NULL or different entirely at this point from when it was
    // referenced.

    // For now, just deallocate the copy
    if (pLinkArray) {
        FREE_TYPE( pLinkArray );
    }

} /* GraphDereferenceMatrix */


DWORD
GraphGetPathSchedule(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE *ppSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

Public routine to get a schedule for a path in the graph.

We try to limit knowlege of the schedule.h structure of the schedule from the other modules.
We return the length here because clients need it and we don't want others to have to
calculate it.

Arguments:

    Graph - 
    From - 
    To - 
    ppSchedule - pointer to pointer to receive pointer to newly allocated schedule
    pLength - pointer to dword to receive length of blob

Return Value:

    DWORD - 

--*/

{
    PBYTE pSchedule;
    DWORD length;

    // Validate

    if (Graph->Size != sizeof( GRAPH ) ) {
        DPRINT( 0, "Graph instance is invalid\n" );
        return ERROR_INVALID_BLOCK;
    }
    if ( (To >= Graph->NumberElements) ||
         (From >= Graph->NumberElements) ) {
        DPRINT( 0, "node index is invalid\n" );
        return ERROR_INVALID_PARAMETER;
    }
    if ( (ppSchedule == NULL) ||
         (pLength == NULL) ) {
        DPRINT( 0, "Invalid parameter\n" );
        return ERROR_INVALID_PARAMETER;
    }

    // Find the schedule if there is one

    pSchedule = sparseScheduleFind( Graph, From, To );
    if (pSchedule == NULL) {
        *ppSchedule = NULL;
        *pLength = 0;
        return ERROR_SUCCESS;
    }

    // Make a private copy for the user

    *ppSchedule = scheduleAllocCopy( pSchedule );
    if ( *ppSchedule == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pLength = scheduleLength( pSchedule );

    return ERROR_SUCCESS;
} /* GraphGetPathSchedule */


#if 0


void
GraphComputeTransitiveClosure(
    IN OUT  GRAPH *     pGraph
    )
/*++

Routine Description:

    Given a graph containing only weighted edges, add in the shortest path
    (i.e., least cost) transitive closure.

    ** NOTE THAT SCHEDULES ARE IGNORED. **

    An adaptation of the Floyd-Warshall algorithm as illustrated in
    "Introduction to Algorithms," p. 556, by Cormen-Leiserson-Rivest, published
    by MIT Press, 1990.

    Runs in O(N^3) time, where N = pGraph->NumberElements.

Arguments:

    pGraph (IN/OUT) - The weighted graph on entry; on exit, its least cost
        transitive closure.

Return Values:

    None.

--*/
{
    DWORD i, j, k;
    DWORD *pCurrCost;
    DWORD Cost1, Cost2;

    Assert(pGraph->NumberElements > 0);

    for (k = 0; k < pGraph->NumberElements; k++) {
        for (i = 0; i < pGraph->NumberElements; i++) {
            for (j = 0; j < pGraph->NumberElements; j++) {
                pCurrCost = &pGraph->LinkArray[i*pGraph->NumberElements + j].ulCost;

                Cost1 = pGraph->LinkArray[i*pGraph->NumberElements + k].ulCost;
                Cost2 = pGraph->LinkArray[k*pGraph->NumberElements + j].ulCost;

                if ((INFINITE_COST != Cost1)
                    && (INFINITE_COST != Cost2)
                    && (Cost1 + Cost2 >= min(Cost1, Cost2))
                    && (Cost1 + Cost2 < *pCurrCost)) {
                    // This path is cheaper than the cheapest one we've
                    // found thus far.
                    *pCurrCost = Cost1 + Cost2;
                }
            }
        }
    }
}
#endif


static PBYTE
sparseScheduleFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    )

/*++

Routine Description:

    Helper routine to see if a schedule is present in a graph

Arguments:

    Graph - 
    From - 
    To - 

Return Value:

    PBYTE - 

--*/

{
    PSPARSE_ELEMENT element;
    
    element = sparseElementFind( Graph, From, To );
    if (element == NULL) {
        return NULL;
    } else {
        return element->pSchedule;
    }
} /* sparseScheduleFind */


static void
sparseArrayFree(
    PGRAPH Graph
    )

/*++

Routine Description:

Free the sparse array portion of the graph.  The sparse array portion can be deallocated while
the graph is allocated.  This is a normal mode of the sparse array, and it represents and empty
array.

Arguments:

    Graph - 

Return Value:

    None

--*/

{
    DWORD i;
    PSPARSE_ELEMENT element, next;

    if (Graph->SparseArray == NULL) {
        return;
    }

    for( i = 0; i < Graph->NumberElements; i++ ) {
        element = Graph->SparseArray[i];
        while (element != NULL) {
            next = element->Next;
            sparseElementFree( element );
            element = next;
        }
    }

    FREE_TYPE( Graph->SparseArray );

    Graph->SparseArray = NULL;
} /* sparseArrayFree */


static void
sparseElementFree(
    PSPARSE_ELEMENT Element
    )

/*++

Routine Description:

Free an individual sparse array element

Arguments:

    Element - 

Return Value:

    None

--*/

{
    FREE_TYPE( Element->pSchedule );
    FREE_TYPE( Element );
} /* sparseElementFree */


static DWORD
SparseScheduleAddDel(
    PGRAPH Graph,
    DWORD From,
    DWORD To,
    PBYTE pTemplateSchedule
    )

/*++

Routine Description:

Add or delete a schedule from a sparse array.  An element may be created or destroyed in the
process.

CODE.IMP: This code ties the life of a element to the life of a schedule.  If we ever store
more stuff in the element besides the schedule, we will need to revisit this.

The sparse array is allocated only when needed.  If an
element, or the array itself is not present, it means the requested node is not present.

Arguments:

    Graph - 
    From - 
    To - 
    pSchedule - may be null, indicating any previous value should be removed
        A copy is made of the schedule.  The caller can do what he will with it after.

Return Value:

    PSPARSE_ELEMENT - 

--*/

{
    DWORD length;
    PBYTE pNewSchedule;
    PSPARSE_ELEMENT element, new, prev;

    DPRINT3( 4, "SparseScheduleAddDel, from=%d, to=%d, pSchedule=%p\n",
            From, To, pTemplateSchedule );

    // Allocate the sparse array headers the first time a sparse element is needed
    if (Graph->SparseArray == NULL) {

        // Nothing to delete
        if (pTemplateSchedule == NULL) {
            return ERROR_SUCCESS;
        }

        // Use calloc so pointers are null'd out to start
        Graph->SparseArray = NEW_TYPE_ARRAY_ZERO( Graph->NumberElements, PSPARSE_ELEMENT );
        if (Graph->SparseArray == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    // Make a copy for ourselves
    if (pTemplateSchedule) {
        pNewSchedule = scheduleAllocCopy( pTemplateSchedule );
        if (pNewSchedule == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        pNewSchedule = NULL;
    }

    // Find element

    prev = NULL;
    element = Graph->SparseArray[From];
    while (element) {

        // Found an existing sparse array element
        if (element->To == To) {
            if (pNewSchedule == NULL) {

                // Delete element 'cause schedule taken away

                if (prev == NULL) {
                    Graph->SparseArray[From] = element->Next;
                } else {
                    prev->Next = element->Next;
                }
                sparseElementFree( element );
            } else {
                // Replace schedule value
                FREE_TYPE( element->pSchedule );
                element->pSchedule = pNewSchedule;
            }
            return ERROR_SUCCESS;

        } else if (element->To > To) {
            break;
        }

        prev = element;
        element = element->Next;
    }

    // Nothing found to delete, exit
    if (pNewSchedule == NULL) {
        return ERROR_SUCCESS;
    }

    // Create new element for schedule

    new = NEW_TYPE( SPARSE_ELEMENT );
    if (new == NULL) {
        FREE_TYPE( pNewSchedule );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    new->To = To;
    new->pSchedule = pNewSchedule;
    new->Next = element;

    if (prev == NULL) {
        Graph->SparseArray[From] = new;
    } else {
        prev->Next = new;
    }

    return ERROR_SUCCESS;
} /* SparseScheduleAddDel */


static PSPARSE_ELEMENT
sparseElementFind(
    PGRAPH Graph,
    DWORD From,
    DWORD To
    )

/*++

Routine Description:

Find a sparse array element.  This is used by sparseScheduleFind.

Arguments:

    Graph - 
    From - 
    To - 

Return Value:

    PSPARSE_ELEMENT - NULL indicates not found

--*/

{
    PSPARSE_ELEMENT element;
    
    if (Graph->SparseArray == NULL) {
        return NULL;
    }

    element = Graph->SparseArray[From];
    while (element) {
        if (element->To == To) {
            return element;
        } else if (element->To > To) {
            break;
        }
        element = element->Next;
    }

    return NULL;
} /* sparseElementFind */


static BOOLEAN
scheduleOverlap(
    PBYTE pSchedule1,
    PBYTE pSchedule2,
    PBYTE *ppNewSchedule
    )

/*++

Routine Description:

Determine if two schedules overlap. If so, allocate a new schedule which represents the common
time periods of the two.

A new schedule is only returned if this function returns TRUE.  Caller must deallocate.

Arguments:

    pSchedule1 - 
    pSchedule2 - 
    ppNewSchedule - 

Return Value:

    BOOLEAN - 

--*/

{
    PSCHEDULE header1, header2;
    PBYTE new, data1, data2;
    DWORD hour;
    BYTE common, overlap;

    // Always connected
    if ( (pSchedule1 == NULL) && (pSchedule2 == NULL) ) {
        *ppNewSchedule = NULL;
        return TRUE;
    }

    // If one is NULL, return the other schedule
    if (pSchedule1 == NULL) {
        new = scheduleAllocCopy( pSchedule2 );
        if (new == NULL) {
            return FALSE;
        }
        *ppNewSchedule = new;
        return TRUE;
    } else if (pSchedule2 == NULL) {
        new = scheduleAllocCopy( pSchedule1 );
        if (new == NULL) {
            return FALSE;
        }
        *ppNewSchedule = new;
        return TRUE;
    }

    header1 = (PSCHEDULE) pSchedule1;
    header2 = (PSCHEDULE) pSchedule2;

    // If formats not identical, don't even bother
    if ( (header1->Size != header2->Size) ||
         (header1->NumberOfSchedules != header2->NumberOfSchedules) ||
         (header1->Schedules[0].Type != header2->Schedules[0].Type) ) {
        DPRINT( 0, "Schedule overlap cannot be determined because formats not identical\n" );
        DPRINT3( 1, "s1: size %d number %d type %d\n",
                 header1->Size,
                 header1->NumberOfSchedules,
                 header1->Schedules[0].Type );
        DPRINT3( 1, "s2: size %d number %d type %d\n",
                 header2->Size,
                 header2->NumberOfSchedules,
                 header2->Schedules[0].Type );
        return FALSE;
    }

    // CODE.IMPROVEMENT: Must be interval format, only one schedule

    if ( (header1->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES ) ||
         (header1->NumberOfSchedules != 1) ||
         (header1->Schedules[0].Type != SCHEDULE_INTERVAL) ) {
        DPRINT( 0, "Schedule overlap cannot be determined because format not supported\n" );
        DPRINT5(1, "s1: size %d (exp %d) number %d (exp 1) type %d (exp %d)\n",
                 header1->Size, (sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES),
                 header1->NumberOfSchedules,
                 header1->Schedules[0].Type, SCHEDULE_INTERVAL );
        return FALSE;
    }

    new = scheduleAllocCopy( pSchedule1 );
    if (new == NULL) {
        return FALSE;
    }

    header1 = (PSCHEDULE) new;

    data1 = (PBYTE) (header1 + 1);  // point just beyond structure
    data2 = (PBYTE) (header2 + 1);  // point just beyond structure

    // For each hour, AND lower four bits together. High order bits left alone.
    // Overlap flag tracks whether we have seen atleast one nonzero hour

    overlap = 0;
    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        *data1 &= ( (*data2++) | 0xf0 );
        overlap |= *data1++;
    }

    if (overlap & 0xf) {
        *ppNewSchedule = new;
        return TRUE;
    } else {
        FREE_TYPE( new );
        DPRINT2( 3, "No overlap found between %p and %p\n",
                 pSchedule1, pSchedule2 );
        return FALSE;
    }

} /* scheduleOverlap */


static BOOLEAN
scheduleEmpty(
    PBYTE pSchedule
    )

/*++

Routine Description:

Test if any intervals are set in the schedule.  This is a subset of the functionality of the
scheduleDuration function.

Arguments:

    pSchedule - 

Return Value:

    BOOLEAN - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);  // point just beyond structure
    DWORD hours;

    if (pSchedule == NULL) {
        return FALSE; // not empty
    }

    // CODE.IMP - we only handle one schedule of type INTERVAL

    // Return something reasonable if we don't understand the blob
    if ( (header->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (header->NumberOfSchedules != 1) ||
         (header->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (header->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return FALSE;  // not empty
    }

    for( hours = 0; hours < SCHEDULE_DATA_ENTRIES; hours++ ) {
        if ( (*data++) & 0xf ) {
            return FALSE; // not empty
        }
    }
    
    return TRUE;  // empty
} /* scheduleEmpty */


static DWORD
scheduleLength(
    PBYTE pSchedule
    )

/*++

Routine Description:

Return the length of the schedule blob.  This function is abstracted to a seperate routine
in case we ever support multiple schedule formats.

Arguments:

    pSchedule - 

Return Value:

    DWORD - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;

    return header->Size;
} /* scheduleLength */


static PBYTE
scheduleAllocCopy(
    PBYTE pSchedule
    )

/*++

Routine Description:

Copy a schedule to a new blob.  This is made a separate function in case we support new
schedule formats.

Arguments:

    pSchedule - 

Return Value:

    PBYTE - 

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE new;

    if (pSchedule == NULL) {
        return NULL;
    }

    new = NEW_TYPE_ARRAY( header->Size, BYTE );
    if (new == NULL) {
        return NULL;
    }

    CopyMemory( new, pSchedule, header->Size );

    return new;
} /* scheduleAllocCopy */


static DWORD
scheduleDuration(
    PBYTE pSchedule
    )
    
/*++

Routine Description:

Return the amount of minutes of uptime that a schedule represents.  Used to derive a metric
to compare two schedules.

Arguments:

    pSchedule - 

Return Value:

    DWORD - Duration in minutes

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);  // point just beyond structure
    DWORD hour, entry, duration = 0;

    if (pSchedule == NULL) {
        return SCHEDULE_DATA_ENTRIES * 4 * 15;  // MAX DURATION
    }

    // CODE.IMP - we only handle one schedule of type INTERVAL

    // Return something reasonable if we don't understand the blob
    if ( (header->Size != sizeof( SCHEDULE ) + SCHEDULE_DATA_ENTRIES) ||
         (header->NumberOfSchedules != 1) ||
         (header->Schedules[0].Type != SCHEDULE_INTERVAL) ||
         (header->Schedules[0].Offset != sizeof( SCHEDULE ) ) ) {
        return 0; // unknown duration
    }

    for( hour = 0; hour < SCHEDULE_DATA_ENTRIES; hour++ ) {
        entry = (*data++) & 0xf;
        if (entry & 0x1) { duration += 15; }
        if (entry & 0x2) { duration += 15; }
        if (entry & 0x4) { duration += 15; }
        if (entry & 0x8) { duration += 15; }
    }

    return duration;
} /* scheduleDuration */

/* end graph.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    Command-line/Service Control Manager entry points for ISM (Intersite
    Messaging) service.

DETAILS:

CREATED:

    97/12/03    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <debug.h>
#include <ism.h>
#include <ismapi.h>
#include <ntdsa.h>
#include <dsevent.h>
#include <fileno.h>
#include <mdcodes.h>
#include "ismserv.hxx"

#define DEBSUB "MAIN:"
#define FILENO FILENO_ISMSERV_MAIN


ISM_SERVICE gService;


extern "C" {
// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }
}


VOID
WINAPI
ServiceMain(
    IN  DWORD   argc,
    IN  LPTSTR  argv[]
    )
/*++

Routine Description:

    Entry point used by SCM (Service Control Manager) to start the ISM service
    once main() has been invoked.

Arguments:

    argc, argv (IN) - Command-line arguments configured for this service
        (ignored).

Return Values:

    None.

--*/
{
    gService.Run();
}


VOID
WINAPI
ServiceCtrlHandler(
    IN  DWORD   dwControl
    )
/*++

Routine Description:

    Entry point used by SCM (Service Control Manager) to control (i.e., stop,
    query, etc.) the ISM service once it's been started via main() and
    ServiceMain().

Arguments:

    dwControl (IN) - Requested action.  See docs for "Handler" function in
        Win32 SDK.

Return Values:

    None.

--*/
{
    gService.Control(dwControl);
}


BOOL
WINAPI
ConsoleCtrlHandler(
    IN  DWORD   dwCtrlType
    )
/*++

Routine Description:

    Console control handler.  Intercepts Ctrl-C and Ctrl-Break to simulate
    "stop" service control when running in debug mode (i.e., when not running
    under the Service Control Manager).

Arguments:

    dwCtrlType (IN) - Console control type.  See docs for "HandlerRoutine" in
        Win32 SDK.

Return Values:

    TRUE - The function handled the control signal.
    FALSE - Control not handled; the next handler function in the list of
        handlers for this process should be used. 

--*/
{
    switch (dwCtrlType) {
      case CTRL_BREAK_EVENT:
      case CTRL_C_EVENT:
        printf("Stopping %s service.\n", gService.m_pszDisplayName);
        gService.Stop();
        return TRUE;

      default:
        return FALSE;
    }
}


int
__cdecl
main(
    IN  int     argc,
    IN  char *  argv[]
    )
/*++

Routine Description:

    Entry point for the ISM process.  Called when started both directly from
    the command line and indirectly via the Service Control Manager.

Arguments:

    argc, argv (IN) - Command-line arguments.  Accepted arguments are:
       /install - Add the service to the Service Control Manager (SCM) database.
       /remove  - Remove the service from the SCM database.
       /debug   - Run the service as a normal process, not under the SCM.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    static SERVICE_TABLE_ENTRY DispatchTable[] = {
        { (char *) ISM_SERVICE::m_pszName, ServiceMain },
        { NULL, NULL }
    };

    int  ret = NO_ERROR;
    BOOL fInstall = FALSE;
    BOOL fRemove = FALSE;
    BOOL fDisplayUsage = FALSE;

    ret = gService.Init(ServiceCtrlHandler);
    if (NO_ERROR != ret) {
        DPRINT1(0, "Failed to gService.Init(), error %d.\n", ret);
	LogEvent8WithData(
	    DS_EVENT_CAT_ISM,
	    DS_EVENT_SEV_ALWAYS,
	    DIRLOG_ISM_INIT_SERVICE,  
	    szInsertWin32Msg( ret ),   
	    NULL,
	    NULL,
	    NULL,
	    NULL, NULL, NULL, NULL,
	    sizeof(ret),
	    &ret); 
        return ret;
    }

    // Parse command-line argumemnts.
    for (int iArg = 1; iArg < argc; iArg++) {
        switch (argv[iArg][0]) {
          case '/':
          case '-':
            // An option.
            if (!lstrcmpi(&argv[iArg][1], "install")) {
                fInstall = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "remove")) {
                fRemove = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "debug")) {
                gService.m_fIsRunningAsService = FALSE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "?")
                     || !lstrcmpi(&argv[iArg][1], "h")
                     || !lstrcmpi(&argv[iArg][1], "help")) {
                fDisplayUsage = TRUE;
                break;
            }
            else {
                // Fall through...
            }

          default:
            printf("Unrecognized parameter \"%s\".\n", argv[iArg]);
            ret = -1;
            fDisplayUsage = TRUE;
            break;
        }
    }

    if (fDisplayUsage) {
        // Display usage information.
        printf("\n"
               "Intersite Messaging Service\n"
               "Copyright (c) 1997 Microsoft Corporation.\n"
               "All rights reserved.\n"
               "\n"
               "/install    Add the service to the Service Control Manager (SCM) database.\n"
               "/remove     Remove the service from the SCM database.\n"
               "/debug      Run the service as a normal process, not under the SCM.\n"
               "\n");
    }
    else if (fInstall) {
        // Add service to the Service Control Manager database.
        ret = gService.Install();

        if (NO_ERROR == ret) {
            printf("Service installed successfully.\n");
        }
        else {
            printf("Failed to install service, error %d.\n", ret);
        }
    }
    else if (fRemove) {
        // Remove service from the Service Control Manager database.
        ret = gService.Remove();

        if (NO_ERROR == ret) {
            printf("Service removeed successfully.\n");
        }
        else {
            printf("Failed to remove service, error %d.\n", ret);
        }
    }
    else {
        if (gService.m_fIsRunningAsService) {
            LPSTR rgpszDebugParams[] = {"ismserv.exe", "-noconsole"};
            DWORD cNumDebugParams = sizeof(rgpszDebugParams)
                                    / sizeof(rgpszDebugParams[0]);

            // Start service under Service Control Manager.
            DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ismserv");

            if (!StartServiceCtrlDispatcher(DispatchTable)) {
                ret = GetLastError();
                DPRINT1(0, "Unable to StartServiceCtrlDispatcher(), error %d.\n", ret);
		LogEvent8WithData(
		    DS_EVENT_CAT_ISM,
		    DS_EVENT_SEV_ALWAYS,
		    DIRLOG_ISM_START_SERVICE_CTRL_DISPATCHER_FAILURE,  
		    szInsertWin32Msg( ret ),   
		    NULL,
		    NULL,
		    NULL,
		    NULL, NULL, NULL, NULL,
		    sizeof(ret),
		    &ret);   
            }
        }
        else {
            // Start service without Service Control Manager supervision.
            DEBUGINIT(0, NULL, "ismserv");

            SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);

            ret = gService.Run();
            DEBUGTERM( );
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\server\service.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    service.cxx

ABSTRACT:

    ISM_SERVICE implementation.  The ISM_SERVICE class handles interaction with
    the Service Control Manager (SCM) and starting and stopping the ISM RPC
    server.

DETAILS:

CREATED:

    97/11/21    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntdspchx.h>
#include <ntdsa.h>      // for NTDS_DELAYED_STARTUP_COMPLETED_EVENT
#include <debug.h>
#include <ism.h>
#include <ismapi.h>
#include <ntdsa.h>
#include <mdcodes.h>
#include <dsevent.h>
#include <fileno.h>
#include "ismserv.hxx"

#define DEBSUB "SERVICE:"
#define FILENO FILENO_ISMSERV_SERVICE


// Static constants.
LPCTSTR ISM_SERVICE::m_pszName         = "ismserv";
LPCTSTR ISM_SERVICE::m_pszDisplayName  = "Intersite Messaging";
LPCTSTR ISM_SERVICE::m_pszDependencies = "samss\0";
LPCTSTR ISM_SERVICE::m_pszLpcEndpoint  = ISMSERV_LPC_ENDPOINT;

const DWORD ISM_SERVICE::m_cMinRpcCallThreads = 1;
const DWORD ISM_SERVICE::m_cMaxConcurrentRpcCalls
    = RPC_C_LISTEN_MAX_CALLS_DEFAULT;


DWORD
ISM_SERVICE::Init(
    IN  LPHANDLER_FUNCTION  pServiceCtrlHandler
    )
/*++

Routine Description:

    Initialize the service object.

Arguments:

    pServiceCtrlHandler (IN) - Function to be called by SCM to issue service
        control requests.  Unfortunately the SCM requires that this be a global
        function with no context parameter (which could be used, e.g., to pass
        a this pointer).  This global function typically calls the Control()
        member function of a known, global ISM_SERVICE object.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err = NO_ERROR;

    m_pServiceCtrlHandler = pServiceCtrlHandler;
    m_fIsRunningAsService = TRUE;

    m_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == m_hShutdown) {
        err = GetLastError();
    }

    m_hLogLevelChange = LoadEventTable();
    if (NULL == m_hLogLevelChange) {
        err = -1;
    }
    
    m_fIsInitialized = (NO_ERROR == err);

    return err;
}


VOID
ISM_SERVICE::Control(
    IN  DWORD   dwControl
    )
/*++

Routine Description:

    Process a service control (stop, interrogate, or shutdown) requested by the
    SCM.

Arguments:

    dwControl (IN) - Requested action.  See docs for "Handler" function in
        Win32 SDK.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    switch (dwControl) {
    case ISM_SERVICE_CONTROL_REMOVE_STOP:
        m_fIsRemoveStopPending = TRUE;
        // Fall through

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        Stop();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        SetStatus();
        break;
    }
}


DWORD
ISM_SERVICE::Run()
/*++

Routine Description:

    Execute the service.  Called either directly or by way of the SCM.  Returns
    on error or when service shutdown is requested.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);

    m_fIsStopPending = FALSE;
    m_fIsRemoveStopPending = FALSE;

    if (m_fIsRunningAsService) {
        m_hStatus = RegisterServiceCtrlHandler(m_pszName, m_pServiceCtrlHandler);
        if (NULL == m_hStatus) {
            err = GetLastError();
            DPRINT1(0, "RegisterServiceCtrlHandler() failed, error %d.\n", err);
            LogEvent8WithData(
	    DS_EVENT_CAT_ISM,
	    DS_EVENT_SEV_ALWAYS,
	    DIRLOG_ISM_REGISTER_SERVICE_CONTROL_HANDLER_FAILED,  
	    szInsertWin32Msg( err ),
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(err),
	    &err
	    ); 
            return err;
        }
    }

    // Start the service immediately so that the service controller and other
    // automatically started services are not delayed by long initialization.
    memset(&m_Status, 0, sizeof(m_Status)); 
    m_Status.dwServiceType      = SERVICE_WIN32;
    m_Status.dwCurrentState     = SERVICE_RUNNING; 
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    m_Status.dwWaitHint         = 15*1000;
    SetStatus();

    err = m_TransportList.Init();

    if (NO_ERROR == err) {
        err = StartRpcServer();
        
        if (NO_ERROR == err) {
            // RPC server is running; process requests until we're asked to stop.
            WaitForRpcServerTermination();
        }
        else {
            DPRINT1(0, "Failed to StartRpcServer(), error %d.\n", err);
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_START_RPC_SERVER_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		);
        }

        // Control returns here when the service is stopped
        // All calls should be complete at this time

        m_TransportList.Destroy();
    }
    else {
        DPRINT1(0, "Failed to m_TransportList.Init(), error %d.\n", err);
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_TRANSPORT_CONFIG_FAILURE,
                          szInsertWin32Msg(err),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(err),
                          &err);
    }

    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwWin32ExitCode = err;
    SetStatus();

    m_fIsStopPending = FALSE;
    m_fIsRemoveStopPending = FALSE;

    return m_Status.dwWin32ExitCode;
}

 
VOID
ISM_SERVICE::Stop()
/*++

Routine Description:

    Signal the service to stop.  Does not wait for service termination before
    returning.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    m_fIsStopPending = TRUE;

    m_Status.dwCurrentState = SERVICE_STOP_PENDING;
    SetStatus();

    SetEvent(m_hShutdown);

    StopRpcServer();
}

 
VOID
ISM_SERVICE::SetStatus()
/*++

Routine Description:

    Report current service status to the SCM.

Arguments:

    None.

Return Values:

    None.

--*/
{
    Assert(m_fIsInitialized);

    if (m_fIsRunningAsService) {
        m_Status.dwCheckPoint++;
        SetServiceStatus(m_hStatus, &m_Status);
    }
}


DWORD
ISM_SERVICE::Install()
/*++

Routine Description:

    Add service to the SCM database.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD       err = NO_ERROR;
    SC_HANDLE   hService = NULL;
    SC_HANDLE   hSCM = NULL;
    TCHAR       szPath[512];
    DWORD       cchPath;

    Assert(m_fIsInitialized);

    cchPath = GetModuleFileName(NULL, szPath, ARRAY_SIZE(szPath));
    if (0 == cchPath) {
        err = GetLastError();
        DPRINT1(0, "Unable to GetModuleFileName(), error %d.\n", err);
    }

    if (NO_ERROR == err) {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (NULL == hSCM) {
            err = GetLastError();
            DPRINT1(0, "Unable to OpenSCManager(), error %d.\n", err);
        }
    }

    if (NO_ERROR == err) {
        hService = CreateService(hSCM,
                                 m_pszName,
                                 m_pszDisplayName,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_WIN32_OWN_PROCESS,
                                 SERVICE_AUTO_START,
                                 SERVICE_ERROR_NORMAL,
                                 szPath,
                                 NULL,
                                 NULL,
                                 m_pszDependencies,
                                 NULL,
                                 NULL);
        if (NULL == hService) {
            err = GetLastError();
            DPRINT1(0, "Unable to CreateService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}


DWORD
ISM_SERVICE::Remove()
/*++

Routine Description:

    Remove service from the SCM database.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD           err = NO_ERROR;
    SC_HANDLE       hService = NULL;
    SC_HANDLE       hSCM = NULL;
    SERVICE_STATUS  SvcStatus;

    Assert(m_fIsInitialized);

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCM) {
        err = GetLastError();
        DPRINT1(0, "Unable to OpenSCManager(), error %d.\n", err);
    }

    if (NO_ERROR == err) {
        hService = OpenService(hSCM, m_pszName, SERVICE_ALL_ACCESS);
        if (NULL == hService) {
            err = GetLastError();
            DPRINT1(0, "Unable to OpenService(), error %d.\n", err);
        }
    }

    if (NO_ERROR == err) {
        if (!DeleteService(hService)) {
            err = GetLastError();
            DPRINT1(0, "Unable to DeleteService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}


BOOL
InitializeAdminOnlyDacl(
    PACL *ppDacl
    )

/*++

Routine Description:

This routine constructs a Dacl which allows the local administrators all
access.

Arguments:

    ppDacl - pointer to pointer to receive allocated pDacl. Caller must
    deallocate using HeapFree

Return Value:

    BOOL - success/failure

--*/

{
    DWORD status;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PACL pDacl = NULL;
    PSID pAdministratorsSid = NULL;
    DWORD dwAclSize;

    //
    // preprate a Sid representing the well-known admin group
    // Are both the local admin and the domain admin members of this group?
    //

    if (!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pAdministratorsSid
        )) {
        status = GetLastError();
        DPRINT1(0, "Unable to allocate and init sid, error %d\n", status);
        goto cleanup;
    }

    //
    // compute size of new acl
    //
    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pAdministratorsSid) ;

    //
    // allocate storage for Acl
    //
    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
    if(pDacl == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DPRINT1(0, "Unable to allocate acl, error %d\n", status);
        goto cleanup;
    }

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        status = GetLastError();
        DPRINT1(0, "Unable to initialize acl, error %d\n", status);
        goto cleanup;
    }

    //
    // grant the Administrators Sid KEY_ALL_ACCESS access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        KEY_ALL_ACCESS,
        pAdministratorsSid
        )) {
        status = GetLastError();
        DPRINT1(0, "Unable to add access allowed ace, error %d\n", status);
        goto cleanup;
    }

    *ppDacl = pDacl;
    pDacl = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if(pAdministratorsSid != NULL)
    {
        FreeSid(pAdministratorsSid);
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    return (status == ERROR_SUCCESS) ? TRUE : FALSE;
} /* InitializeAdminOnlyDacl */

DWORD
ISM_SERVICE::StartRpcServer()
/*++

Routine Description:

    Start RPC server to service client requests.

Arguments:

    None.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD                   err = 0;
    BYTE                    rgbSD[ SECURITY_DESCRIPTOR_MIN_LENGTH ];
    PSECURITY_DESCRIPTOR    pSD = (PSECURITY_DESCRIPTOR) rgbSD;
    RPC_POLICY rpcPolicy;
    PACL pDacl = NULL;

    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;

    Assert(m_fIsInitialized);
    Assert(!m_fIsRpcServerListening);

    // Construct the security descriptor to apply to our LPC interface.
    // By default LPC allows access only to the account under which the server
    // is running; ours should allow access to all local administrators.

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
        || !InitializeAdminOnlyDacl( &pDacl )
        || !SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE)) {
        err = GetLastError();
        DPRINT1(0, "Unable to construct security descriptor, error %d\n", err);
        LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_CONSTRUCT_SECURITY_DESCRIPTOR_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		);
    }

    if (NO_ERROR == err) {
        // Listen on LPC (local machine only).
        err = RpcServerUseProtseqEpEx((UCHAR *) "ncalrpc",
                                      m_cMaxConcurrentRpcCalls,
                                      (UCHAR *) m_pszLpcEndpoint,
                                      pSD,
                                      &rpcPolicy);
        if (err) {
            DPRINT1(0, "Unable to RpcServerUseProtseqEpEx(), error %d.\n", err);
            LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_USE_PROT_SEQ_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		);
        }
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    if (NO_ERROR == err) {
        // Register interface.
        err = RpcServerRegisterIf(ismapi_ServerIfHandle, 0, 0);
        if (err) {
            DPRINT1(0, "Unable to RpcServerRegisterIf(), error %d.\n", err);
            LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_REGISTER_IF_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		);
        }
    }

    if (NO_ERROR == err) {
        // Principal name is NULL for local system service.
        err = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);
        if (err) {
            DPRINT1(0, "Unable to RpcServerRegisterAuthInfo(), error %d.\n", err);
            LogEvent8WithData(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_RPC_SERVER_REGISTER_AUTH_INFO_FAILED,  
                szInsertWin32Msg( err ),
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                sizeof(err),
                &err
                );
        }
    }

    if (NO_ERROR == err) {
        // Start taking calls.
        err = RpcServerListen(m_cMinRpcCallThreads, m_cMaxConcurrentRpcCalls, TRUE);
        if (err) {
            DPRINT1(0, "Unable to RpcServerListen(), error %d.\n", err);
            LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_LISTEN_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		);
        }
    }

    if (NO_ERROR == err) {
        m_fIsRpcServerListening = TRUE;
        DPRINT1(0, "RPC server listening...\n", err);
    }

    return err;
}


VOID
ISM_SERVICE::StopRpcServer()
/*++

Routine Description:

    Signals the RPC server to stop processing requests.  Does not wait for calls
    currently being processed to complete.

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err;

    Assert(m_fIsInitialized);

    if (m_fIsRpcServerListening) {
        err = RpcMgmtStopServerListening(NULL);
        if (err) {
            DPRINT1(0, "Unable to RpcMgmtStopServerListening(), error %d.\n", err);
            LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_RPC_SERVER_STOP_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		); 
        }
    }
}


VOID
ISM_SERVICE::WaitForRpcServerTermination()
/*++

Routine Description:

    Waits for completion of all RPC client calls made before StopRpcServer() is
    invoked.  (No RPC calls are accepted after the StopRpcServer().)

Arguments:

    None.

Return Values:

    None.

--*/
{
    DWORD err = 0;
    HANDLE rgWaitHandles[2];
    DWORD waitStatus;

    Assert(m_fIsInitialized);
    Assert(m_fIsRpcServerListening);

    /// m_hLogLevelChange
    rgWaitHandles[0] = m_hShutdown;
    rgWaitHandles[1] = m_hLogLevelChange;
    
    do {
        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rgWaitHandles),
                                            rgWaitHandles,
                                            FALSE,
                                            INFINITE);
        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // Shutdown was requested.
            // We'll fall out of the do-while loop below.
            Assert(SERVICE_RUNNING != m_Status.dwCurrentState);
            break;

        case WAIT_OBJECT_0 + 1:
            // Our logging levels have changed.
            LoadEventTable();
            break;

        case WAIT_FAILED:
        default:
            err = GetLastError();
            Assert(err);
            DPRINT2(0, "WaitForMultipleObjects() failed, waitStatus %d, error %d.\n",
                    waitStatus, err);
	    LogEvent8WithData(
		DS_EVENT_CAT_ISM,
		DS_EVENT_SEV_ALWAYS,
		DIRLOG_ISM_WAIT_FOR_OBJECTS_FAILED,  
		szInsertWin32Msg( err ),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(err),
		&err
		); 
            break;
        }
    } while (!err
             && (SERVICE_RUNNING == m_Status.dwCurrentState));

    err = RpcMgmtWaitServerListen();
    Assert((RPC_S_OK == err) || (RPC_S_NOT_LISTENING == err));

    DPRINT1(0, "RPC server terminated.\n", err);

    m_fIsRpcServerListening = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\ldapobj.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ldapobj.c

Abstract:

    This module implements an object specific interface to the directory.

    The current directory is the NT 5 DS, as accessed through LDAP.

    The implementation of the directory is abstracted away, so that any directory may be used.
    For example, the registry was used during testing.

    THIS IS THE LDAP IMPLEMENTATION.

Author:

    Will Lees (wlees) 07-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <winsock2.h>
#define LDAP_UNICODE 1
#include <winldap.h>
#include <ntldap.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include <dsconfig.h>                   // GetConfigParam

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_LDAPOBJ

#include <debug.h>
#define DEBSUB "LDAPOBJ:"

#include <ismapi.h>

#include <common.h>

// The number of items returned from a paged search
#if DBG
// Make smaller on checked build to stress page handling
#define ISM_LDAP_PAGE_SIZE 10
#else
#define ISM_LDAP_PAGE_SIZE 1000
#endif

// This is the internal state for a connection
typedef struct _CONNECTION_INSTANCE {
    DWORD Size;
    // ldap stuff goes here
    LDAP *LdapConnection;
    LPWSTR ConfigNC;
    // We don't cache the server dn in here because it might be renamed
    WCHAR szServerGuidDN[32+sizeof("<GUID=>")];
} CONNECTION_INSTANCE, *PCONNECTION_INSTANCE;

// This is the internal state kept across calls to the iteration routines
typedef struct _ITERATION_CONTEXT {
    LDAP *hLdap;
    LDAPSearch *pSearch;
    LDAPMessage *Results;
    LDAPMessage *Message;
} ITERATION_CONTEXT, *PITERATION_CONTEXT;

/* External */

/* Static */

static LPWSTR ExtendedErrorSpecialError = L"Failed to get server error.";

/* Forward */ /* Generated by Emacs 21.1 (patch 9) "Canyonlands" XEmacs Lucid on Wed Jan 03 10:34:07 2001 */

void
logExtendedServerError(
    IN LDAP *pLdap
    );

DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    );

DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    );

DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    );

DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    );

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    );

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    );

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    );

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    );

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    );

static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    );

void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    );

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    );

DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    );

void
DirFreeMultiszString(
    LPWSTR MultiszString
    );

void
DirFreeSchedule(
    PBYTE pSchedule
    );

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    );

DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    );

DWORD
DirWriteServerSmtpAttributesUnused(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

DWORD
DirRegisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT HANDLE *              phServerChanges
    );

DWORD
DirWaitForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

DWORD
DirUnregisterForServerSmtpChanges(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  HANDLE                hServerChanges
    );

static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    );

DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    );

DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    );

BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    );

unsigned __stdcall
notifyThread(
    PVOID Argument
    );

/* End Forward */


void
logExtendedServerError(
    IN LDAP *pLdap
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *pmsg = NULL;
    DWORD err = 0;

    ldap_get_optionW( pLdap, LDAP_OPT_SERVER_ERROR, &pmsg );
    ldap_get_optionW(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &err);

    if ( pmsg || err ) {
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_EXTENDED_SERVER_ERROR,
            szInsertWC( pmsg ? pmsg : L"" ),
            szInsertWin32Msg( err ),
            NULL, NULL, NULL, NULL, NULL, NULL,
            sizeof(err), &err
            );
    }

    DPRINT2( 0, "Ism extended LDAP error info:\nServer Error: %ws\nExtended Error: %d\n",
             pmsg, err );

    if ( pmsg != NULL ) {
        ldap_memfreeW(pmsg);
    }
}


DWORD
DirOpenConnection(
    PVOID *ConnectionHandle
    )

/*++

Routine Description:

Open a connection handle to the directory service.  This package chooses the implementation and
which server to open.

This is needed because some directory services need a long-lived handle on which each call
is made.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = NULL;
    DWORD status, ldapStatus;
    LDAP *ldapConnection = NULL;
    LPWSTR configNC = NULL;
    WCHAR pszTargetServer[MAX_PATH];

    connection = NEW_TYPE_ZERO( CONNECTION_INSTANCE );
    if (connection == NULL) {
        // no resources to free yet
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    connection->Size = sizeof( CONNECTION_INSTANCE );

    // Allow means to configure ISM to use remote directory instance
#if DBG
    if (GetConfigParamW( MAKE_WIDE( ISM_ALTERNATE_DIRECTORY_SERVER ),
                         pszTargetServer, MAX_PATH )) {
        // Parameter not found or other error
        wcscpy( pszTargetServer, L"localhost" );
    } else {
        DPRINT1( 0, "ISM using alternate directory server %ws\n", pszTargetServer );
    }
#else
    wcscpy( pszTargetServer, L"localhost" );
#endif

    // Open ourselves as the ldap server.
    // Assumption: this code is always running on a DC

    ldapConnection = ldap_initW( pszTargetServer, LDAP_PORT );
    if (ldapConnection == NULL) {
        status = GetLastError();
        DPRINT1(0, "ldap_initW failed, status = %d\n", status);
        goto cleanup;
    }

    DPRINT1( 2, "Connected to server %s.\n", ldapConnection->ld_host );

    // Force LDAP V3.  Without this, the LDAP client dumbs down to V2 and
    // rejects any searches that use controls.
    ldapConnection->ld_version = LDAP_VERSION3;

    ldapStatus = ldap_bind_s( ldapConnection, NULL, NULL, LDAP_AUTH_NTLM );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_bind_s failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        logExtendedServerError( ldapConnection );
        goto cleanup;
    }

    connection->LdapConnection = ldapConnection;

    status = cacheOperationalAtts(connection);
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    *ConnectionHandle = (PVOID) connection;

    return ERROR_SUCCESS;

cleanup:  // only called on failure

    if (connection->ConfigNC != NULL) {
        FREE_TYPE(connection->ConfigNC);
    }

    if (connection != NULL) {
        FREE_TYPE( connection );
    }

    if (ldapConnection != NULL) {
        ldap_unbind( ldapConnection );
    }

    return status;

} /* DirOpenConnection */


DWORD
DirCloseConnection(
    PVOID ConnectionHandle
    )

/*++

Routine Description:

Close a connection handle.

Arguments:

    ConnectionHandle -

Return Value:

    DWORD -

--*/

{
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldap_unbind( connection->LdapConnection );

    FREE_TYPE( connection->ConfigNC );

    FREE_TYPE( connection );

    return ERROR_SUCCESS;
} /* DirCloseConnection */


DWORD
cacheOperationalAtts(
    IN OUT  CONNECTION_INSTANCE *   pConnection
    )

/*++

Routine Description:

    Helper routine to cache important operational atts from the DS
    into the connection handle.

Arguments:

    pConnection (IN/OUT) - Connection to poulate with cached info.

Return Value:

    Win32 error code

--*/

{
#define ATT1 L"configurationNamingContext"
#define ATT2 L"serverName"
#define ATT3 L"objectGuid"
    DWORD status, ldapStatus, length;
    PWCHAR rootAttributeList[] = { ATT1, ATT2, NULL };
    PWCHAR serverAttributeList[] = {ATT3, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *serverResults = NULL;
    LDAPMessage *rootMessage;
    LDAPMessage *serverMessage;
    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;
    WCHAR *pch;
    DWORD ib;

    // Get the config NC attribute
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"Root DN" ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    length = wcslen( *valueList ) + 1; // length in wchars inc term
    pConnection->ConfigNC = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pConnection->ConfigNC) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy(pConnection->ConfigNC, *valueList);

    // Get the DN of the server object.
    ldap_value_free(valueList);
    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage,
                                ATT2 );
    if (NULL == valueList) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // TODO: Search for this attribute with the others in the previous search

    // Read the server object.
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               *valueList,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               &serverAttributeList[0],
                               FALSE,
                               &serverResults);
    if (LDAP_SUCCESS != ldapStatus) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2(0, "Ldap_search_s failed, server object, ldap error = %d, win32 error = %d\n",
                ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( *valueList ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (NULL == serverResults) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }
    serverMessage = ldap_first_entry(pConnection->LdapConnection, serverResults);
    if (NULL == serverMessage) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Extract the object GUID and cache the GUID form of the DN.
    // Referencing the server object via the GUID DN later makes us immune from
    // renames of our site and renames/moves of our server object.
    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT3 );
    if (NULL == ppbv) {
        // error, inconsistent results found
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }
    Assert(1 == ldap_count_values_len(ppbv));
    Assert(sizeof(GUID) == (*ppbv)->bv_len);

    wcscpy(pConnection->szServerGuidDN, L"<GUID=");
    pch = pConnection->szServerGuidDN + sizeof(L"<GUID=")/sizeof(WCHAR) - 1;
    for (ib = 0; ib < sizeof(GUID); ib++) {
        swprintf(pch, L"%02x", (UCHAR) (*ppbv)->bv_val[ib]);
        pch += 2;
    }
    *(pch++) = L'>';
    *(pch++) = L'\0';
    Assert(pch - &pConnection->szServerGuidDN[0]
           == sizeof(pConnection->szServerGuidDN)/sizeof(WCHAR));

    status = ERROR_SUCCESS;

cleanup:  // called in all cases

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree( rootResults );
    }

    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }

    return status;
#undef ATT1
#undef ATT2
#undef ATT3
} /* cacheOperationalAtts */


DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

This routine rereads the transport object from the directory service.

Object must exist.

Arguments:

    ConnectionHandle - directory handle
    pTransport - dn of transport object

Return Value:

    DWORD -

--*/

{
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
    PWCHAR attributeList[] = { ATT_RI, ATT_OP, NULL };
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PCHAR *numberList;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 pTransport->Name, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // We only update the value if the attribute is present.  By presetting a
    // value in field to be updated, the caller may determine whether the
    // attribute was actually present or not.

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        pTransport->ReplInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport default replication interval = %d\n", pTransport->ReplInterval );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        pTransport->Options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
        DPRINT1( 2, "Transport options = 0x%x\n", pTransport->Options );
    }

    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadTransport */


DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )

/*++

Routine Description:

This routine returns the bridgehead servers for a given site

Arguments:

    SiteDN - string name of site. It is supposed to be the full DN of the site.
    It must exist.
    pNumberServers - pointer to dword to receive number of servers
    ppServerList - pointer to a pointer, that will receive a pointer to a block of
           strings (which are pointers to char)
           Server list must be freed by the caller.

Return Value:

    DWORD -

--*/

{
#define ATT1 L"bridgeheadServerListBL"
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    DWORD status, ldapStatus, index, length;
    DWORD number = 0;
    LPWSTR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LPWSTR *pServerList = NULL;
    LPWSTR *valueList = NULL, *pString;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Construct the element path
    // CODE.IMP - default to current stie
    if ( (SiteDN == NULL) || (*SiteDN == L'\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Bug 151694. Verify that the site dn is valid
    status = verifyExistence( ConnectionHandle, SiteDN );
    if (status != ERROR_SUCCESS) {
        if (status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_NO_SUCH_SITE;
        }
        return status;
    }

    // Get the bridgehead servers for this transport.
    // Note, these are the servers for all sites
    ldapStatus = ldap_search_s( connection->LdapConnection,
                               pTransport->Name,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results

    // Attribute not found, a success case
    if (ldapStatus == LDAP_NO_SUCH_ATTRIBUTE)
    {
       *pNumberServers = 0;
       *ppServerList = NULL;
       status = ERROR_SUCCESS;
       goto cleanup;
    }

    if (ldapStatus != LDAP_SUCCESS) {
        // better error, no such transport
        // error LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, base object, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pTransport->Name ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // better error, no such transport
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList == NULL) {
        // Attribute is optional
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Count the number of servers in this site
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            number++;
        }
        pString++;
    }

    // If no matching sites, exit now
    if (number == 0) {
        *pNumberServers = 0;
        *ppServerList = NULL;
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Allocate the block of pointers
    // Zero'd for ease of cleanup
    pServerList = NEW_TYPE_ARRAY_ZERO( number, LPWSTR );
    if (pServerList == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;

    }

    // Populate the return block
    index = 0;
    pString = valueList;
    while (*pString != NULL) {
        if (wcsstr( *pString, SiteDN ) != NULL) {
            length = wcslen( *pString ) + 1; // len in wchars plus term
            pServerList[index] = NEW_TYPE_ARRAY( length, WCHAR );
            if (pServerList[index] == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            wcscpy( pServerList[index], *pString );
            index++;
        }
        pString++;
    }

    // Return out parameters

    *pNumberServers = number;
    *ppServerList = pServerList;

    pServerList = NULL; // given away, don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if (pServerList != NULL) {
        for( index = 0; index < number; index++ ) {
            if (pServerList[index] != NULL) {
                FREE_TYPE( pServerList[index] );
            }
        }
        FREE_TYPE( pServerList );
    }

    if (valueList != NULL) {
        ldap_value_free( valueList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
#undef ATT1
} /* IpGetSiteBridgeheadList */


DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Return the list of all sites.
    Some of these sites may be inaccessible for our purposes if they are not mentioned in the
    site link structures.

    This site list is a counted array of pointers to strings, NOT a multi-sz format as is
    used in other places.

    The preferred method to interate a container is to do a search with only
    invalid arguments, and then get the dn out of each entry

Arguments:

    ConnectionHandle - Current open directory
    pNumberSites - pointer to dword to receive the number of sites
    ppSiteList - pointer which receives pointer to array of strings.
                 Storage must be freed by caller.

Return Value:

    DWORD -

--*/

{
#define ATT1        L"invalid"
    DWORD status, ldapStatus, length, number, i, total;
    DWORD index = 0;
    LPWSTR *pSiteList = NULL;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    WCHAR path[MAX_REG_PATH];
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    LDAPSearch *pSearch = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    wcscpy( path, L"CN=Sites," );
    wcscat( path, connection->ConfigNC );

    //
    // Initialize paged search
    //
    pSearch = ldap_search_init_page(
        connection->LdapConnection,
        path,                   // base dn
        LDAP_SCOPE_ONELEVEL,    // immediate children
        L"(objectClass=site)",  // filter is all objects
        &attributeList[0],      // list of attributes
        FALSE,                  // attrs only
        NULL,                   // ServerControls
        NULL,                   // ClientControls
        0,                      // PageTimeLimit
        0,                      // TotalSizeLimit
        NULL                   // SortKeys
        );
    if (pSearch == NULL) {
        ldapStatus = LdapGetLastError();
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 path, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
            szInsertWC( path ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        goto cleanup;
    }

    // Search for all site objects below the Sites container
    // In order to free loop resources, all exits from loop must be through
    // loop cleanup at bottom

    status = ERROR_SUCCESS;
    do {
        //
        // Get the next page of results
        //
        ldapStatus = ldap_get_next_page_s(
            connection->LdapConnection,
            pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &results );
        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         path, ldapStatus, status );
                LogEvent8WithData(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( path ),
                    szInsertWin32Msg( status ),
                    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(status),
		    &status
                    );
                logExtendedServerError( connection->LdapConnection );
            }
            goto loop_cleanup;
        }
        if (results == NULL) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Count number of entries found
        number = ldap_count_entries( connection->LdapConnection, results );
        // There should always be atleast one site
        if (number == 0) {
            // 0 entry pages permissable
            goto loop_cleanup;
        }

        // Allocate return array
        if (pSiteList) {
            // Expand existing array to encompass new entries
            LPWSTR *pTempSiteList =
                REALLOC_TYPE_ARRAY( pSiteList, (index + number), PWSTR );
            if (pTempSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
            pSiteList = pTempSiteList;
        } else {
            // New array
            pSiteList = NEW_TYPE_ARRAY( number, PWSTR );
            if (pSiteList == NULL) {
                DPRINT( 1, "failed to allocate site array\n" );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }
        }

        // Load the array with the sites
        message = ldap_first_entry( connection->LdapConnection, results );
        while (message != NULL ) {
            PWCHAR dn;
            dn = ldap_get_dn( connection->LdapConnection, message );
            if (dn == NULL) {
                // error, inconsistent results found
                DPRINT( 0, "missing dn in ldap message\n" );
                status = ERROR_DS_MISSING_EXPECTED_ATT;
                goto loop_cleanup;
            }

            length = wcslen( dn ) + 1;    // length in wchars inc term

            pSiteList[index] = (PWSTR) NEW_TYPE_ARRAY( length, WCHAR );   // in wchars
            if (pSiteList[index] == NULL) {
                ldap_memfree( dn );
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto loop_cleanup;
            }

            wcscpy(pSiteList[index], dn);
            ldap_memfree( dn );


            index++;
            message = ldap_next_entry( connection->LdapConnection, message );
        }

    loop_cleanup:
        if (results != NULL) {
            ldap_msgfree( results );
            results = NULL;
        }

    } while (status == ERROR_SUCCESS);
    // Make sure loop exited for right reason
    // This is the goofy ldap translation of NO_RESULTS_RETURNED
    if (status != ERROR_MORE_DATA) {
        goto cleanup;
    }
    // There should always be atleast one site
    if (index == 0) {
        // error, inconsistent results found
        // missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto loop_cleanup;
    }

    // Return the OUT parameters

    *pNumberSites = index;
    *ppSiteList = pSiteList;

    // Don't clean up the list now that we've given it away
    pSiteList = NULL;

    status = ERROR_SUCCESS;

cleanup:
    if (pSiteList != NULL) {
        for( i = 0; i < index; i++ ) {
            if (pSiteList[i] != NULL) {
                FREE_TYPE( pSiteList[i] );
            }
        }
        FREE_TYPE( pSiteList );
    }

   // Clean up paged search
   if (pSearch) {
       ldapStatus = ldap_search_abandon_page(
           connection->LdapConnection,
           pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT3( 0, "Ldap_search_abandon_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                    path, ldapStatus, status1 );
       }
   }

   return status;
#undef ATT1
} /* DirGetSiteList */


void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LPWSTR *pNewSiteList = NULL;
    LPWSTR pszNewSite;
    DWORD i, length;

    Assert( ppSiteList );

    *ppSiteList = NULL;

    pNewSiteList = NEW_TYPE_ARRAY_ZERO( NumberSites, LPWSTR );
    if (pNewSiteList == NULL) {
        return;
    }

    for( i = 0; i < NumberSites; i++ ) {
        length = wcslen( pSiteList[i] ) + 1;
        pszNewSite = NEW_TYPE_ARRAY( length, WCHAR );
        if (pszNewSite == NULL) {
            goto cleanup;
        }
        wcscpy( pszNewSite, pSiteList[i] );
        pNewSiteList[i] = pszNewSite;
    }

    *ppSiteList = pNewSiteList;

    pNewSiteList = NULL;  // don't clean up

cleanup:
    if (pNewSiteList) {
        DirFreeSiteList( i, pNewSiteList );
    }
}


void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    )

/*++

Routine Description:

Free the site list returned from the DirGetSiteList function.

Arguments:

    NumberSites -
    pSiteList -

Return Value:

    None

--*/

{
    DWORD i;

    // Get rid of site list
    for( i = 0; i < NumberSites; i++ ) {
        FREE_TYPE( pSiteList[i] );
    }
    FREE_TYPE( pSiteList );
} /* DirFreeSiteList */


DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle - pointer to a PVOID
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLink)",
                          pIterateContextHandle,
                          SiteLinkName );

} /* DirIterateSiteLinks */


DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    )

/*++

Routine Description:

This function is called multiple times to return the name of each site link bridge object.

The context handle is always a pointer to a PVOID.  The PVOID should have null in it the first
time in order to start the iteration.  The iteration should be called repeatedly until this
function returns error or ERROR_NO_MORE_ITEMS.

The iteration can also be terminated prematurely by calling DirTerminateIteration.

Arguments:

    pTransport -
    ConnectionHandle -
    pIterateContextHandle -
    SiteLinkName - user allocated; assumed to be MAX_REG_COMPONENT size

Return Value:

    DWORD - ERROR_NO_MORE_ITEMS indicates end of iteration, no data returned

--*/

{
    return
        iterateContainer( ConnectionHandle,
                          pTransport->Name,
                          L"(objectClass=siteLinkBridge)",
                          pIterateContextHandle,
                          SiteLinkBridgeName );

} /* DirIterateSiteLinkBridges */


static DWORD
iterateContainer(
    PVOID ConnectionHandle,
    LPWSTR BaseDN,
    LPWSTR LdapFilter,
    PVOID *pIterateContextHandle,
    LPWSTR Name
    )

/*++

Routine Description:

Helper routine to iterate through the names of a set of child objects given a dn of
the parent.

The preferred LDAP mechanism to get the dn's of child objects is to do a
search with only invalid arguments, and retrieve the dn's of the returned
entries.  LDP also does this.  This should get around problems were we don't
have permission to read the child object's attributes, but still want to
enumerate the directory.

Arguments:

    ConnectionHandle - Handle to the directory service
    BaseDN - Parent of children to be returned
    LdapFilter - select class of objects to be returned, can use
    L"(objectClass = *)" for all.
    pIterateContextHandle - Context for the iteration. Pointer to DWORD.  DWORD is null
       to start
    Name - Storage for returned name.  Must be REG_MAX_COMPONENT

Return Value:

    DWORD -

--*/

{
#define ATT1 L"invalid"
    PWCHAR attributeList[] = { ATT1, NULL };
    DWORD status, ldapStatus, total;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PITERATION_CONTEXT context;
    PWCHAR dn;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }
    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (*pIterateContextHandle == NULL) {

        // *****************************
        // Set up for first time through
        // *****************************

        // Allocate a new context
        context = NEW_TYPE_ZERO( ITERATION_CONTEXT );
        if (context == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        context->hLdap = connection->LdapConnection;

        //
        // Initialize paged search
        //

        context->pSearch = ldap_search_init_page(
            connection->LdapConnection,
            BaseDN,                 // base dn
            LDAP_SCOPE_ONELEVEL,    // immediate children
            LdapFilter,             // filter is all objects
            &attributeList[0],      // list of attributes
            FALSE,                  // attrs only
            NULL,                   // ServerControls
            NULL,                   // ClientControls
            0,                      // PageTimeLimit
            0,                      // TotalSizeLimit
            NULL                   // SortKeys
            );
        if (context->pSearch == NULL) {
            ldapStatus = LdapGetLastError();
            status = LdapMapErrorToWin32( ldapStatus );
            DPRINT3( 0, "Ldap_search_init_page failed, dn %ws, ldap error = %d, win32 error = %d\n",
                     BaseDN, ldapStatus, status );
            LogEvent8WithData(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                szInsertWC( BaseDN ),
                szInsertWin32Msg( status ),
                NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		sizeof(status),
		&status
                );
            logExtendedServerError( connection->LdapConnection );
            goto cleanup;
        }
        *pIterateContextHandle = (PVOID) context;
    } else {

        // On second and later iterations, ConnectionHandle, BaseDN, and
        // LdapFilter not guaranteed to be present.

        context = (PITERATION_CONTEXT) *pIterateContextHandle;
    }

    while (context->Message == NULL) {

        // *****************************
        // Set up for first entry on a new page
        // *****************************

        // Release any previous results
        if (context->Results) {
            ldap_msgfree( context->Results );
        }
        context->Results = NULL;

        // Read the next page
        ldapStatus = ldap_get_next_page_s(
            context->hLdap,
            context->pSearch,
            NULL,
            ISM_LDAP_PAGE_SIZE,
            &total,
            &(context->Results) );

        if (ldapStatus != LDAP_SUCCESS) {
            status = LdapMapErrorToWin32( ldapStatus );
            if ( (ldapStatus != LDAP_SERVER_DOWN) &&
                 (ldapStatus != LDAP_NO_RESULTS_RETURNED) ) {
                DPRINT3( 0, "Ldap_get_next_page_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                         BaseDN, ldapStatus, status );
                LogEvent8WithData(
                    DS_EVENT_CAT_ISM,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_ISM_LDAP_ONELEVEL_SEARCH_FAILED,
                    szInsertWC( BaseDN ? BaseDN : L"(iteration)" ),
                    szInsertWin32Msg( status ),
                    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    sizeof(status),
		    &status
                    );
                logExtendedServerError( context->hLdap );
            }
            if (ldapStatus == LDAP_NO_RESULTS_RETURNED) {
                // Return a better translation than ldap does
                status = ERROR_NO_MORE_ITEMS;
            }
            goto cleanup;
        }
        if (context->Results == NULL) {
            continue;  // 0 entry pages are permissable
        }

        context->Message = ldap_first_entry( context->hLdap, context->Results );
        if (context->Message == NULL) {
            continue;  // 0 entry pages are permissable
        }
    }

    // *****************************
    // Return the next dn
    // *****************************

    Assert( context->Results );
    Assert( context->Message );

    dn = ldap_get_dn( context->hLdap, context->Message );
    if (dn == NULL) {
        // error, inconsistent results found
        DPRINT( 0, "missing dn in ldap message\n" );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // Name must be allocated by the caller to be MAX_REG_COMPONENT length
    wcsncpy( Name, dn, MAX_REG_COMPONENT );
    Name[MAX_REG_COMPONENT - 1] = L'\0';

    ldap_memfree( dn );

    // Advance context to next message
    context->Message = ldap_next_entry( context->hLdap, context->Message );

    return ERROR_SUCCESS;

cleanup:

    DirTerminateIteration( pIterateContextHandle );

    return status;
#undef ATT1
} /* iterateContainer */


void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    )

/*++

Routine Description:

Clean up the context of an DirIterate* call.

Arguments:

    pIterateContextHandle -

Return Value:

    None

--*/

{
    PITERATION_CONTEXT context =
        (PITERATION_CONTEXT) *pIterateContextHandle;

    Assert( context ); // don't call us twice
    if (context == NULL) {
        return;
    }

    // Release the search
    if (context->pSearch) {
        DWORD ldapStatus = ldap_search_abandon_page(
            context->hLdap,
            context->pSearch );
       if (ldapStatus != LDAP_SUCCESS) {
           DWORD status1 = LdapMapErrorToWin32( ldapStatus );
           DPRINT2( 0, "Ldap_search_abandon_page failed, ldap error = %d, win32 error = %d\n",
                    ldapStatus, status1 );
       }
    }

    // Release the results
    if (context->Results) {
        ldap_msgfree( context->Results );
    }
    context->Results = NULL;
    context->Message = NULL;
    context->hLdap = NULL;

    // Destory context
    FREE_TYPE( context );
    *pIterateContextHandle = NULL;
} /* DirTerminateIteration */


DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    )

/*++

Routine Description:

   Given the name of a site link, return its fields.

   The site list and the schedule are allocated by this routine.  The user must deallocate.

   The expectation that the site link object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkName -
    pSiteList - pointer to pointer to string. Receives multisz string.  Caller must free.  May be NULL
    pCost - pointer to DWORD. Filled with cost.
    pSchedule - pointer to schedule. Filled with schedule.  Caler must free.

Return Value:

    DWORD -

--*/

{
#define ATT_SL L"siteList"
#define ATT_COST L"cost"
#define ATT_COST_A "cost"
#define ATT_RI L"replInterval"
#define ATT_RI_A "replInterval"
#define ATT_OP L"options"
#define ATT_OP_A "options"
#define ATT_SCHED L"schedule"

// Note, schedule must be last in the list
#define ATT_SCHED_POS 4  // index from 0 of sched attribute
    PWCHAR attributeList[] =
    { ATT_SL, ATT_COST, ATT_RI, ATT_OP, ATT_SCHED, NULL };

    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    PCHAR *numberList;
    struct berval **ppThing;
    LPWSTR siteList = NULL;
    PBYTE pSchedule = NULL;
    DWORD cost = 0, replInterval = 0, options = 0;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Don't read schedule attribute if it wasn't requested.

    Assert(0 == _wcsicmp(ATT_SCHED, attributeList[ATT_SCHED_POS]));
    Assert(NULL == attributeList[ATT_SCHED_POS+1]);
    if (NULL == ppSchedule) {
        attributeList[ATT_SCHED_POS] = NULL;
    }

    // Get the attributes for this one site link object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        // error LDAP_NO_SUCH_OBJECT
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkName, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkName ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteList attribute
    // CODE.IMPROVEMENT: It would be nice to return this native form, array of ptrs,
    // instead of converting to multisz.

    // Attribute may be empty if all references deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT_SL );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Read optional cost attribute
    // Integers are represented as an array of ascii digits, not unicode

    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_COST_A);
    if (numberList != NULL) {
        cost = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional replInterval attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_RI_A);
    if (numberList != NULL) {
        replInterval = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read optional options attribute
    numberList = ldap_get_valuesA( connection->LdapConnection, message,
                                   ATT_OP_A);
    if (numberList != NULL) {
        options = strtoul( *numberList, NULL, 10 );
        ldap_value_freeA( numberList );
    }

    // Read schedule attribute
    ppThing = ldap_get_values_len( connection->LdapConnection, message,
                                   ATT_SCHED );
    if ( (ppThing != NULL) && ( (*ppThing)->bv_len != 0 ) ) {
        // Validate schedule attribute.
        SCHEDULE *psched = (SCHEDULE *) (*ppThing)->bv_val;

        if (((*ppThing)->bv_len < offsetof(SCHEDULE, Size) + sizeof(psched->Size))
            || (psched->Size != sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES)
            || (psched->NumberOfSchedules != 1)
            || (psched->Schedules[0].Type != SCHEDULE_INTERVAL)
            || (psched->Schedules[0].Offset != sizeof(SCHEDULE))) {
            // The schedule blob is not a correctly formed SCHEDULE structure.
            DPRINT1(0, "The schedule attribute of siteLink object %ls is invalid.\n",
                    SiteLinkName);
            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_ISM_SITELINK_INVALID_SCHEDULE_FORMAT,
                     szInsertWC(SiteLinkName),
                     NULL, NULL);

            // Pretend as if we didn't find a schedule attribute....
        }
        else {
            // Is the schedule set to "never"?
            BYTE *  pEntries = (BYTE *) psched + psched->Schedules[0].Offset;
            DWORD   iEntry;
            BOOL    fIsNever = TRUE;

            for (iEntry = 0; iEntry < SCHEDULE_DATA_ENTRIES; iEntry++) {
                if (pEntries[iEntry] & 0xf) {
                    fIsNever = FALSE;
                    break;
                }
            }

            if (fIsNever) {
                // The schedule is "never".
                DPRINT1(0, "The schedule attribute of siteLink object %ls is \"never\".\n",
                        SiteLinkName);
                LogEvent(DS_EVENT_CAT_ISM,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_ISM_SITELINK_SCHEDULE_NEVER,
                         szInsertWC(SiteLinkName),
                         NULL, NULL);
                // Pretend as if we didn't find a schedule attribute....
            }
            else {
                // Schedule is acceptable -- use it.
                pSchedule = NEW_TYPE_ARRAY( (*ppThing)->bv_len, CHAR );
                if (pSchedule == NULL) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    ldap_value_free_len( ppThing );
                    goto cleanup;
                }
                CopyMemory( pSchedule, (*ppThing)->bv_val, (*ppThing)->bv_len );
            }
        }

        ldap_value_free_len( ppThing );
    }

    // Return data to user
    if (pSiteList != NULL) {
        *pSiteList = siteList;
        siteList = NULL;  // given to user
    }

    if (pLinkValue != NULL) {
        pLinkValue->ulCost = cost;
        pLinkValue->ulReplicationInterval = replInterval;
        pLinkValue->ulOptions = options;
    }

    if (ppSchedule) {
        *ppSchedule = pSchedule;
        pSchedule = NULL; // don't clean up
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteList) {
        FREE_TYPE( siteList );
    }

    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT_SL
#undef ATT_COST
#undef ATT_COST_A
#undef ATT_RI
#undef ATT_RI_A
#undef ATT_OP
#undef ATT_OP_A
#undef ATT_SCHED
} /* DirReadSiteLink */


DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    )

/*++

Routine Description:

   Return the fields of a site link bridge object

   The expectation that the bridge object has already been found via
   enumeration of transport container.

Arguments:

    pTransport -
    ConnectionHandle -
    SiteLinkBridgeName -
    pSiteLinkList - pointer to pointer to multisz string allocated by this routine,
        user must free

Return Value:

    DWORD -

--*/

{
#define ATT1 L"siteLinkList"
    DWORD status, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    PWCHAR attributeList[] = { ATT1, NULL };
    LDAPMessage *results = NULL;
    LDAPMessage *message;
    PWCHAR *valueList;
    LPWSTR siteLinkList = NULL;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    // Return the attributes for this one site link bridge object

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               SiteLinkBridgeName,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // error LDAP_NO_SUCH_OBJECT
        // error LDAP_NO_SUCH_ATTRIBUTE
        status = LdapMapErrorToWin32( ldapStatus );
        // TODO:LOG AN EVENT HERE. OBJECT WAS FOUND VIA ENUM BUT CAN'T BE READ!
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 SiteLinkBridgeName, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( SiteLinkBridgeName ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (results == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    message = ldap_first_entry( connection->LdapConnection, results );
    if (message == NULL) {
        // error, inconsistent results found
        // missing object
        // error, no such site link bridge
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // Read siteLinkList attribute

    // Attribute may not exist if all referents have been deleted
    valueList = ldap_get_values( connection->LdapConnection, message, ATT1 );
    if (valueList != NULL) {
        status = stringArrayToMultiSz( valueList, &siteLinkList );
        if (status != ERROR_SUCCESS) {
            ldap_value_free( valueList );
            goto cleanup;
        }
        ldap_value_free( valueList );
    }

    // Return data to user
    if (pSiteLinkList != NULL) {
        *pSiteLinkList = siteLinkList;
        siteLinkList = NULL;  // given to user
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteLinkList) {
        FREE_TYPE( siteLinkList );
    }

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;

#undef ATT1
} /* DirReadSiteLinkBridge */


void
DirFreeMultiszString(
    LPWSTR MultiszString
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (MultiszString) {
        FREE_TYPE( MultiszString );
    }
}


void
DirFreeSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    if (pSchedule) {
        FREE_TYPE( pSchedule );
    }
}

DWORD
cacheServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )
{
    DWORD   winError = ERROR_SUCCESS;
    DWORD   cch;

    Assert(NULL == pTransport->Smtp.pszSmtpAddress);

    // Cache SMTP address (e.g., mailbox@server-4.ntdev.microsoft.com).
    cch = 1 + wcslen(pszMailAddress);
    pTransport->Smtp.pszSmtpAddress = NEW_TYPE_ARRAY(cch, WCHAR);
    if (NULL == pTransport->Smtp.pszSmtpAddress) {
        winError = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        wcscpy(pTransport->Smtp.pszSmtpAddress, pszMailAddress);
    }

    if (ERROR_SUCCESS != winError) {
        // Failed; free any memory we allocated.
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return winError;
}


DWORD
DirReadServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport
    )
{
#define ATT1 L"mailAddress"
    CONNECTION_INSTANCE * pConn
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD           winError;
    int             ldStatus;
    LPWSTR          rgpszServerAttrsToRead[] = {ATT1, NULL};
    LDAPMessage *   pResults = NULL;
    LDAPMessage *   pEntry;
    LPWSTR *        ppszMailAddress;

    ldStatus = ldap_search_s(pConn->LdapConnection,
                             pConn->szServerGuidDN,
                             LDAP_SCOPE_BASE,
                             L"(objectClass=*)",
                             rgpszServerAttrsToRead,
                             0,
                             &pResults);
    switch (ldStatus) {
      case LDAP_NO_SUCH_ATTRIBUTE:
        // Our server object has no mailAddress.
        DPRINT(0, "Our server object has no mailAddress attribute.\n");
        // This is not an error; detect by examining SmtpAddress field
        winError = ERROR_SUCCESS;
        break;

      case LDAP_SUCCESS:
        // Successfully read our server object's mailAddress; cache it.
        pEntry = ldap_first_entry(pConn->LdapConnection, pResults);
        Assert(NULL != pEntry);

        ppszMailAddress = ldap_get_values(pConn->LdapConnection, pEntry,
                                          ATT1);
        if (NULL == ppszMailAddress) {
            DPRINT(0, "Our server object has empty mailAddress attribute.\n");
            // This is not an error; detect by examining SmtpAddress field
            winError = ERROR_SUCCESS;
        }
        else {
            Assert(1 == ldap_count_values(ppszMailAddress));

            winError = cacheServerSmtpAttributes(pTransport, *ppszMailAddress);

            ldap_value_free(ppszMailAddress);
            DPRINT1(0, "Our SMTP address is \"%ls\".\n",
                    pTransport->Smtp.pszSmtpAddress);
        }
        break;

      default:
        // Some other error...
        DPRINT1(0, "Failed to ldap_search_s(), error %d.\n", ldStatus);
        winError = LdapMapErrorToWin32(ldStatus);
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pConn->szServerGuidDN ),
            szInsertWin32Msg( winError ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof( winError ),
	    &winError
            );
        logExtendedServerError( pConn->LdapConnection );
        break;
    }

    // bug 327001, ldap_search* functions can return failure and still allocate
    // the result buffer.
    if (pResults) {
        ldap_msgfree(pResults);
    }

    return winError;
#undef ATT1
}


DWORD
DirGetServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    OUT LPWSTR *ppszMailAddress
    )

/*++

Routine Description:

Construct the mail address of the server

This routine constructs an address suitable for the SMTP service.
We should only call this when we know that SMTP service is running.
TODO: If Exchange is running, we should do something different.

The name looks like:

_IsmService@guid-based-dns-name

Arguments:

    pTransport -
    ppszMailAddress -

Return Value:

    DWORD -

--*/

{
#define NTDS_SETTINGS L"CN=NTDS Settings,"
#define ENTERPRISE_CONFIGURATION L"CN=Enterprise Configuration,CN=Partitions,"
#define ISM_SMTP_RECIPIENT L"_IsmService"
#define ATT1 L"serverName"
#define ATT2 L"objectGuid"
#define ATT3 L"dnsRoot"
#define ATT4 L"mailAddress"
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus, length;

    PWCHAR rootAttributeList[] = {ATT1, NULL};
    LDAPMessage *rootResults = NULL;
    LDAPMessage *rootMessage;

    PWCHAR serverAttributeList[] = {ATT2, NULL};
    LDAPMessage *serverResults = NULL;
    LDAPMessage *serverMessage;

    PWCHAR computerAttributeList[] = {ATT3, NULL};
    LDAPMessage *computerResults = NULL;
    LDAPMessage *computerMessage;

    PWCHAR *valueList = NULL;
    struct berval **ppbv = NULL;

    PWCHAR pszNTDSA = NULL;
    PWCHAR pszMailAddress = NULL;
    PWCHAR pszEnterprise = NULL;
    PWCHAR pszGUID = NULL;

    // Read the server name on the base dn
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               NULL,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &rootAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &rootResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( L"root dn" ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (rootResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    rootMessage = ldap_first_entry( pConnection->LdapConnection, rootResults );
    if (rootMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    valueList = ldap_get_values(pConnection->LdapConnection, rootMessage, ATT1);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT1 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dn of the server oobject

    length = wcslen( NTDS_SETTINGS) + wcslen( *valueList ) + 1;
    pszNTDSA = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszNTDSA) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszNTDSA, NTDS_SETTINGS );
    wcscat( pszNTDSA, *valueList );

    // *********************************************************************

    // Read the object guid on the NTDS settings object
    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszNTDSA,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &serverAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &serverResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszNTDSA ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }

    if (serverResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    serverMessage = ldap_first_entry( pConnection->LdapConnection, serverResults );
    if (serverMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ppbv = ldap_get_values_len(pConnection->LdapConnection, serverMessage,
                               ATT2 );
    if ( (ppbv == NULL) ||
         ( 1 != ldap_count_values_len(ppbv)) ||
         ( sizeof(GUID) != (*ppbv)->bv_len ) ) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT2 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *********************************************************************

    // Read the dnsRoot for the enterprise

    length = wcslen( ENTERPRISE_CONFIGURATION ) +
        wcslen( pConnection->ConfigNC ) + 1;
    pszEnterprise = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszEnterprise) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszEnterprise, ENTERPRISE_CONFIGURATION );
    wcscat( pszEnterprise, pConnection->ConfigNC );

    ldapStatus = ldap_search_s(pConnection->LdapConnection,
                               pszEnterprise,                   // base dn
                               LDAP_SCOPE_BASE,     // just this object
                               L"(objectClass=*)",      // filter is all objects
                               &computerAttributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &computerResults );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_search_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( pszEnterprise ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (computerResults == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    computerMessage = ldap_first_entry( pConnection->LdapConnection, computerResults );
    if (computerMessage == NULL) {
        // error, inconsistent results found, missing object
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    ldap_value_free(valueList);  // get rid of last value
    valueList = ldap_get_values(pConnection->LdapConnection, computerMessage, ATT3);
    if (valueList == NULL) {
        // error, inconsistent results found,
        DPRINT1( 0, "missing attribute %ws\n", ATT3 );
        status = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    // *valueList is the dns root of the enterprise

    // *********************************************************************

    status = UuidToStringW( (PVOID) (*ppbv)->bv_val, &pszGUID );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "UuidToString failed, error %d\n", status );
        goto cleanup;
    }

    //
    // Form new mail address
    //
    length = wcslen( ISM_SMTP_RECIPIENT ) + 1 +
        wcslen( pszGUID ) + 8 +
        wcslen( *valueList ) + 1; // length in wchars inc term
    pszMailAddress = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == pszMailAddress) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pszMailAddress, ISM_SMTP_RECIPIENT );
    wcscat( pszMailAddress, L"@" );
    wcscat( pszMailAddress, pszGUID );
    wcscat( pszMailAddress, L"._msdcs." );
    wcscat( pszMailAddress, *valueList);

    // *********************************************************************

    // Return mail address

    *ppszMailAddress = pszMailAddress;

    pszMailAddress = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    if (pszGUID) {
        RpcStringFreeW( &pszGUID );
    }
    if (pszEnterprise) {
        FREE_TYPE( pszEnterprise );
    }
    if (pszNTDSA) {
        FREE_TYPE( pszNTDSA );
    }
    if (pszMailAddress) {
        FREE_TYPE( pszMailAddress );
    }

    if (valueList != NULL) {
        ldap_value_free(valueList);
    }
    if (NULL != ppbv) {
        ldap_value_free_len(ppbv);
    }

    if (NULL != rootResults) {
        ldap_msgfree(rootResults);
    }
    if (NULL != serverResults) {
        ldap_msgfree(serverResults);
    }
    if (NULL != computerResults) {
        ldap_msgfree(computerResults);
    }

    return status;

} /* DirGetServerSmtpAttributes */


DWORD
DirWriteServerSmtpAttributes(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPWSTR                pszMailAddress
    )

/*++

Routine Description:

This routine auto configures the mail address attribute.

It is assumed the mail address is empty at this point.

Note, we should only put a mail address on a server object if we are sure
that the server can receive mail.  The KCC uses the presense of the mailAddress
of an indicator of which system it should choose as form a connection to.

Arguments:

    pTransport - Transport object
    pszMailAddress - Mail address to be written. A null means to remove it.

Return Value:

    DWORD -

--*/

{
    CONNECTION_INSTANCE * pConnection
        = (CONNECTION_INSTANCE *) pTransport->DirectoryConnection;
    DWORD status, ldapStatus;
    LDAPModW *ppModifyList[2];
    LDAPModW modMailAddress;
    PWCHAR ppszValueList[2];

    // Get rid of any old cached address
    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE(pTransport->Smtp.pszSmtpAddress);
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    //
    // Write it to server object
    //

    ppszValueList[0] = pszMailAddress;
    ppszValueList[1] = NULL;
    modMailAddress.mod_op = LDAP_MOD_REPLACE;
    modMailAddress.mod_type = ATT4;
    modMailAddress.mod_vals.modv_strvals = ppszValueList;
    ppModifyList[0] = &modMailAddress;
    ppModifyList[1] = NULL;

    ldapStatus = ldap_modify_s( pConnection->LdapConnection,
                                pConnection->szServerGuidDN,  // base dn
                                ppModifyList );
    if (ldapStatus != LDAP_SUCCESS) {
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "Ldap_modify_s failed, ldap error = %d, win32 error = %d\n",
                 ldapStatus, status );
        LogEvent(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_MODIFY_FAILED,
            szInsertWC( pConnection->szServerGuidDN ),
            szInsertWin32Msg( status ),
            NULL
            );
        logExtendedServerError( pConnection->LdapConnection );
        goto cleanup;
    }

    if (pszMailAddress) {
        DPRINT1(0, "Wrote new SMTP address \"%ls\".\n", pszMailAddress );

        // Cache the new server mail address
        cacheServerSmtpAttributes( pTransport, pszMailAddress );
    }

    status = ERROR_SUCCESS;

cleanup:  // executed in all cases

    return status;
} /* DirWriteServerSmtpAttributes */


static DWORD
stringArrayToMultiSz(
    PWSTR *pString,
    PWSTR *pFlat
    )

/*++

Routine Description:

Given a null-terminated array of string pointers, convert that into a multisz array.

Arguments:

    pString - pointer to null-terminated array of pointers
    pFlat - pointer to receive allocated buffer.  Buffer contains the multisz rep of the
            input string array, for example member1\0member2\0\member3\0\0

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    PWSTR flat = NULL, *pItem, element;

    // Count number of characters and terminators
    length = 0;
    pItem = pString;

    if (pItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    while (*pItem != NULL) {
        length += wcslen( *pItem ) + 1;
        pItem++;
    }
    length++; // length in whars plus all terminators

    // Allocate the multisz array
    flat = NEW_TYPE_ARRAY( length, WCHAR );
    if (flat == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        return status;
    }

    // Populate it
    pItem = pString;
    element = flat;
    while (*pItem != NULL) {
        length = wcslen( *pItem ) + 1;
        wcscpy( element, *pItem );
        element += length;
        pItem++;
    }
    *element = L'\0';

    *pFlat = flat;
    return ERROR_SUCCESS;
} /* stringArrayToMultiSz */


DWORD
static verifyExistence(
    PVOID ConnectionHandle,
    LPCWSTR ObjectDN
    )

/*++

Routine Description:

Verify that an object exists.
This routine does not try to read any attributes.
If the object does not exist, an error is displayed

This code uses the ldap enumeration technique where we search for invalid
arguments and see how many entries are returned.

Arguments:

    ConnectionHandle -
    ObjectDN -

Return Value:

    DWORD -

--*/

{
    PWCHAR attributeList[] = { L"invalid", NULL };
    DWORD status, length, ldapStatus;
    PCONNECTION_INSTANCE connection = (PCONNECTION_INSTANCE) ConnectionHandle;
    LDAPMessage *results = NULL;
    LDAPMessage *message;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    ldapStatus = ldap_search_s( connection->LdapConnection,
                               (LPWSTR) ObjectDN,     // base dn
                               LDAP_SCOPE_BASE,     // just this one
                               L"(objectClass=*)",      // filter is all objects
                               &attributeList[0],      // list of attributes
                               FALSE,                 // attrs only
                               &results );                // gets results
    if (ldapStatus != LDAP_SUCCESS) {
        // If the object is not present, this is the path that will be taken
        // LDAP_NO_SUCH_OBJECT
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT3( 0, "Ldap_search_s failed, dn %ws, ldap error = %d, win32 error = %d\n",
                 ObjectDN, ldapStatus, status );
        LogEvent8WithData(
            DS_EVENT_CAT_ISM,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_ISM_LDAP_BASE_SEARCH_FAILED,
            szInsertWC( ((LPWSTR) ObjectDN) ),
            szInsertWin32Msg( status ),
            NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    NULL,
	    sizeof(status),
	    &status
            );
        logExtendedServerError( connection->LdapConnection );
        // bug 327001, ldap_search* functions can return failure and still allocate
        // the result buffer.
        goto cleanup;
    }
    if (results == NULL) {
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    // There should be an entry for the base object, but no attributes
    message = ldap_first_entry( connection->LdapConnection, results);
    if (message  == NULL) {
        DPRINT1( 0, "expected object %ws is missing.\n", ObjectDN );
        // error, inconsistent results found
        // error, ds object missing
        status = ERROR_DS_OBJ_NOT_FOUND;
        goto cleanup;
    }

    //
    // Bug 26647 comment:
    // For some names such as CNF names, the ldap returned dn string
    // format isn't necessarily identical to the core generated dn string.
    // That is:
    //  wcsicmp(ObjectDN, dn) != 0
    // Example (note the "" and \):
    // CN="ExampleSite<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d",CN=Sites,
    // CN=Configuration,...DC=com !=
    // CN=ExampleSite\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites,
    // CN=Configuration,...DC=com
    // Do represent the same object yet the strings are different.
    //
    status = ERROR_SUCCESS;

cleanup:

    if (results != NULL) {
        ldap_msgfree( results );
    }

    return status;
} /* static verifyExistence */


DWORD
DirStartNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Start a notification thread if one is not already running
    This routine is thread-safe. Multiple callers can try to create the
    thread and only one will succeed.
    Assumes pTransport->NotifyThreadHandle is initialized to zero at first.

Arguments:

    pTransport - transport instance

Return Value:

    DWORD - error if thread could not be started

--*/

{
    DWORD status;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LONG threadId;

    if (connection->Size != sizeof( CONNECTION_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // Under protection of the lock, atomically test and set the thread
    // handle to determine if a thread should be started or not.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if (pTransport->NotifyThreadHandle) {
            // Thread already running
            status = ERROR_SUCCESS;
            __leave;
        }

        // Note, _beginthreadex returns 0 on error
        pTransport->NotifyThreadHandle = (HANDLE)
            _beginthreadex(
                NULL,
                0,
                notifyThread,
                pTransport, // argument
                0,
                &threadId
                );
        if (0 == pTransport->NotifyThreadHandle) {
            status = _doserrno;
            Assert(status);
            DPRINT1(0, "Failed to create listener thread, error %d.\n", status);
            __leave;
        }

        DPRINT2( 2, "Started notification thread 0x%x on %ws\n",
                 pTransport->NotifyThreadHandle,
                 pTransport->Name );

        status = ERROR_SUCCESS;
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    return status;
} /* DirStartNotifyThread */


BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Test whether notification thread is still alive.

We have having problems with the thread exiting prematurely.  This check is down
periodically by the ISM apis.  If the thread has disappeared, this call will
log the fact.

Arguments:

    pTransport -

Return Value:

    BOOL - True, active or False, exited

--*/

{
    DWORD exitCode = 0;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;
    }

    if (pTransport->NotifyThreadHandle) {

        // Is the thread still alive?
        if ( (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) &&
             (exitCode == STILL_ACTIVE) ) {
            return TRUE;
        }

        // Thread is dead - reap it

        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );

        pTransport->NotifyThreadHandle = 0;
    }

    // Start another thread
    DirStartNotifyThread( pTransport );

    // Indicate thread was not active at time of check
    return FALSE;
} /* DirIsNotifyThreadActive */


BOOL
DirEndNotifyThread(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

Cause the notification thread to exit.

Ideally, the execution of this routine would be the only legitimate way
that the thread should exit.  The problem is that because we are in a dll
of a server, we sometimes don't get notificated of shutdown in a timely
manner.  In fact, LDAP may have shutdown its searches before we are called.
In that case, the thread may have exitted on its own legitimately before
we get a chance to do so.

Arguments:

    pTransport - transport state object

Return Value:

    BOOL - whether the thread exited, or not

--*/

{
    DWORD status, ldapStatus, waitStatus, exitCode;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    BOOL fExit = FALSE;

    if ( (connection->Size != sizeof( CONNECTION_INSTANCE )) ||
         (connection->LdapConnection == 0) ) {
        return FALSE;  // don't know
    }
    // Make sure not already called
    if (pTransport->NotifyThreadHandle == 0) {
        DPRINT(1, "DirEndNotifyThread already called!\n" );
        return TRUE;  // has exitted
    }

    // We don't enforce that the thread is still alive at this point. It may
    // have terminated on its own due to LDAP shutting down

    // Stop asynchronous search
    ldapStatus = ldap_abandon(
        connection->LdapConnection,
        pTransport->NotifyMessageNumber
        );
    if (ldapStatus != LDAP_SUCCESS) {
        // May occur if LDAP is shutting down
        status = LdapMapErrorToWin32( ldapStatus );
        DPRINT2( 0, "ldap_abandon failed, ldap error = %d, status = %d\n",
                 ldapStatus, status );
        // Keep going to see if the thread exited or not
    }

    waitStatus = WaitForSingleObject(pTransport->NotifyThreadHandle,5*1000);
    if (waitStatus == WAIT_TIMEOUT) {
        DPRINT1( 0, "Notify thread 0x%x did not exit promptly, timeout.\n",
                 pTransport->NotifyThreadHandle );
        goto cleanup;
    } else if (waitStatus != WAIT_OBJECT_0 ) {
        status = GetLastError();
        DPRINT2(0, "Failure waiting for notify thread to exit, wait status=%d, error=%d\n",
                waitStatus, status);
        goto cleanup;
    }

    exitCode = 0;
    if (GetExitCodeThread( pTransport->NotifyThreadHandle, &exitCode )) {
        if (exitCode != ERROR_SUCCESS) {
            DPRINT1( 1, "Notify thread exited with non success code %d\n",
                     exitCode );
        }
    }

    fExit = (exitCode != STILL_ACTIVE);
    // pass status through
cleanup:
    if (!fExit) {
        DPRINT( 0, "Notify thread did not exit\n" );
    }
    if (pTransport->NotifyThreadHandle) {
        // Note, beginthreadex requires us to close the thread handle
        CloseHandle( pTransport->NotifyThreadHandle );
    }

    pTransport->NotifyThreadHandle = 0;

    return fExit;
} /* DirEndNotifyThread */


unsigned __stdcall
notifyThread(
    PVOID Argument
    )

/*++

Routine Description:

    Notification thread routine

Arguments:

    Argument - Transport object
    Note that the controller of this thread guarantees not to destroy the
    transport object until this thread has exitted cleanly

Return Value:

    unsigned __stdcall -

--*/

{
    DWORD status, ldapResultType, ldapStatus;
    PTRANSPORT_INSTANCE pTransport = (PTRANSPORT_INSTANCE) Argument;
    PCONNECTION_INSTANCE connection =
        (PCONNECTION_INSTANCE) pTransport->DirectoryConnection;
    LDAPMessage *results = NULL;
    BOOL fDone;
    LPWSTR attributeList[] = {
        L"objectGuid", L"objectClass", L"isDeleted",
        NULL};
    LDAPControl ctrlNotify = {LDAP_SERVER_NOTIFICATION_OID_W, {0, NULL}, TRUE};
    LDAPControl *serverControls[] = {&ctrlNotify, NULL};
    DWORD i;

    DPRINT1( 1, "Started monitoring %ws\n", pTransport->Name );

    InterlockedIncrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        while (1) {
            // Check for official shutdown first
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break; // exit shutdown loop
            }

            // Start a new search
            ldapStatus = ldap_search_ext(
                connection->LdapConnection,     // ldap connection
                pTransport->Name,               // base dn
                LDAP_SCOPE_ONELEVEL,            // scope
                L"(objectClass=*)",             // filter
                attributeList,                  // attrs[]
                0,                              // attrsonly
                serverControls,                 // server controls
                NULL,                           // client controls
                0,                              // time limit
                0,                              // size limit
                &(pTransport->NotifyMessageNumber) // message number
                );

#ifdef FAULT_INSERTION
            if (rand() % 2 == 0) {
                DPRINT( 0, "Inserting ldap_search_ext error\n" );
                ldapStatus = LDAP_PROTOCOL_ERROR;
            }
#endif

            if (ldapStatus != LDAP_SUCCESS) {
                status = LdapMapErrorToWin32( ldapStatus );
                DPRINT2( 0, "ldap_search_ext failed, ldap error = %d, status = %d\n",
                         ldapStatus, status );
                logExtendedServerError( connection->LdapConnection );
                // This is a hard error with no recovery - exit shutdown loop
                break;
            }

            DPRINT2( 1, "Starting new notify search %d on %ws\n",
                     pTransport->NotifyMessageNumber,  pTransport->Name );

            // Loop reading results until error
            fDone = FALSE;
            while (!fDone) {
                ldapResultType = ldap_result(
                    connection->LdapConnection,      // ldap connection
                    pTransport->NotifyMessageNumber, // message id
                    LDAP_MSG_ONE,                    // all
                    NULL,                            // timeout
                    &results                         // results
                    );

                // Check for official shutdown first
                if (pTransport->fShutdownInProgress) {
                    status = ERROR_SUCCESS;
                    fDone = TRUE;
                    goto loop_cleanup;
                }

#ifdef FAULT_INSERTION
                if (rand() % 5 == 0) {
                    DPRINT( 0, "Inserting ldap_result error\n" );
                    ldapResultType = 0xffffffff;
                    connection->LdapConnection->ld_errno = LDAP_PROTOCOL_ERROR;
                }
#endif

                if (ldapResultType == 0xffffffff) {
                    ldapStatus = connection->LdapConnection->ld_errno;
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT2( 0, "ldap_result failed, ldap error = %d, status = %d\n",
                             ldapStatus, status );
                    fDone = TRUE;
                } else if (ldapResultType == LDAP_RES_SEARCH_ENTRY) {

                    // This is the normal, successful result
                    RouteInvalidateConnectivity( pTransport );

                } else if (ldapResultType == LDAP_RES_SEARCH_RESULT) {

                    // This means the server terminated the search

                    ldapStatus = ldap_result2error(
                        connection->LdapConnection,      // ldap connection
                        results,
                        FALSE );
                    status = LdapMapErrorToWin32( ldapStatus );
                    DPRINT1( 0, "IsmNotifyThread:Ldap result error is 0x%x\n",ldapStatus );
                    fDone = TRUE;
                } else {
                    // Something unexpected
                    DPRINT2( 0, "IsmNotifyThread: Unexpected ldap result type 0x%x for %ws\n",
                             ldapResultType, pTransport->Name );
                    LogUnhandledError( ldapResultType );
                    status = ERROR_INVALID_FUNCTION;
                    fDone = TRUE;
                }

            loop_cleanup:

                if (results) {
                    ldap_msgfree( results );
                    results = NULL;
                }

            } // while (!fDone) result loop

            // Its ambiguous whether this is a real error or a shutdown induced error.
            // See if we were asked to shutdown

            if (!pTransport->fShutdownInProgress) {
                // Give us some time to see if we're shutting down
                DWORD waitStatus;
                waitStatus = WaitForSingleObject( pTransport->hShutdownEvent,
                                                  60 * 1000 );
                if ( (waitStatus != WAIT_OBJECT_0) &&
                     (waitStatus != WAIT_TIMEOUT) ) {
                    DPRINT2( 0, "WaitForSingleObject failed with return %d, win32 = %d\n",
                             waitStatus, GetLastError() );
                }
            }

            // If shutting down, we're done
            if (pTransport->fShutdownInProgress) {
                status = ERROR_SUCCESS;
                break;
            }

            // LDAP terminated our search prematurely, do error recovery
            // This can occur under some legitimate circumstances, such as when
            // Kerberos tickets expire.
            DPRINT2( 0, "ldap_result failed!, ldapStatus = 0x%x, win32 = %d\n",
                     ldapStatus, status );
            DPRINT2( 0, "h_ldap = 0x%p, message number = %d\n",
                     connection->LdapConnection,
                     pTransport->NotifyMessageNumber );
            // Assert( !"LDAP terminated search prematurely" );

        // Record that there was a problem with the last search
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_BASIC,
                              DIRLOG_ISM_LDAP_EXT_SEARCH_RESULT,
                              szInsertWC(pTransport->Name),
                              szInsertWin32Msg(status),
                              NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(status),
                              &status);
            // Do this before we alter the connection state
            logExtendedServerError( connection->LdapConnection );

            // Stop asynchronous search - make sure we're cleaned up
            (void) ldap_abandon(
                connection->LdapConnection,
                pTransport->NotifyMessageNumber
                );
            // ignore error - keep going
            pTransport->NotifyMessageNumber = 0;

            // Invalidate the cache on error to force re-read of data
            // in case we miss any notifications
            RouteInvalidateConnectivity( pTransport );

        } // while (1) search loop

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        DPRINT1(0, "Caught exception 0x%x in notifyThread!\n", status );
    }

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "Notify thread terminating due to error %d\n", status );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_LINK_MONITOR_FAILURE_RESTART,
                          szInsertWC(pTransport->Name),
                          szInsertWin32Msg(status),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(status),
                          &status);
    } else {
        DPRINT1( 3, "monitor thread %ws exit\n", pTransport->Name );
    }

    InterlockedDecrement( &(pTransport->ReferenceCount) );  // 1 for this thread

    // Note that if this thread exists prematurely, we don't touch the
    // ThreadHandle. It is still open.  When we reap the thread later we will
    // close the handle at that time.

    // _endthreadex() is called automatically

    return status;
} /* notifyThread */
/* end ldapobj.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\memory.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Debug memory allocator.
    Checks for heap corruption.
    Reports memory not deallocated

    User interface:
    ptr = NEW_TYPE( type )
    ptr = NEW_TYPE_ARRAY( count, type )
    ptr = NEW_TYPE_ZERO( type )
    ptr = NEW_TYPE_ARRAY_ZERO( count, type )
    TYPE_FREE( ptr )

Author:

    Will Lees (wlees) 22-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include "common.h"

#define DEBSUB "IPMEM:"

#define HEADER_SIGNATURE  0x01234567
#define TRAILER_SIGNATURE 0xabcdef01
#define DEAD_SIGNATURE    0xdeadbeef

// Force quadword alignment

#define ALIGNMENT 8
#define ALIGN( x ) (((x) + (ALIGNMENT-1)) & ~(ALIGNMENT-1))

typedef struct _HEADER {
    LIST_ENTRY Link;
    PCHAR File;
    DWORD Line;
    DWORD Signature;
    DWORD UserSize;
    DWORD TrailerOffset;
    LARGE_INTEGER UserData[1];
    // CODE.IMP: in use linkage
} HEADER, *PHEADER;

typedef struct _TRAILER {
    DWORD Signature;
} TRAILER, *PTRAILER;

/* External */

/* Static */

CRITICAL_SECTION gcsIsmMemoryLock;
LIST_ENTRY gleIsmMemoryListHead;

// Last entry we saw before we crashed
PLIST_ENTRY gpleIsmLastGoodEntry = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Jul 20 17:08:24 1998 */

void
DebugMemoryInitialize(
    void
    );

void
DebugMemoryTerminate(
    void
    );

PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryRellocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    );

BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    );

void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    );

/* End Forward */


void
DebugMemoryInitialize(
    void
    )

/*++

Routine Description:

Initialize the package.  Call once at startup.

Arguments:

    void - 

Return Value:

    None

--*/

{
    InitializeCriticalSection( &gcsIsmMemoryLock );
    InitializeListHead( &gleIsmMemoryListHead );
} /* DebugMemoryInitialize */


void
DebugMemoryTerminate(
    void
    )

/*++

Routine Description:

Rundown the package.  Call once at shutdown.  Reports memory not deallocated.

Arguments:

    void - 

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

    while (!IsListEmpty(&gleIsmMemoryListHead)) {
        entry = RemoveHeadList( &gleIsmMemoryListHead );
        pHeader = CONTAINING_RECORD( entry, HEADER, Link );
        DPRINT2( 0, "Unfreed memory: %s:%d\n", pHeader->File, pHeader->Line );
    }
    DeleteCriticalSection( &gcsIsmMemoryLock );
} /* DebugMemoryTerminate */


PVOID
DebugMemoryAllocate(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to allocate a block of memory.

Arguments:

    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader;
    PTRAILER pTrailer;

//    DPRINT3( 1, "DebugMemoryAllocate, Size=%d,File=%s,Line=%d\n", Size, File, Line );

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pHeader = (PHEADER) malloc( amount );
    if (pHeader == NULL) {
        DPRINT3( 0, "Memory allocation of %d failed at %s:%d\n", amount, File, Line );
        // CODE.IMP: Additional logging?
        return NULL;
    }
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryAllocate */


PVOID
DebugMemoryReallocate(
    PVOID MemoryBlock,
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Internal routine to reallocate a block of memory.

Arguments:

    MemoryBlock - pointer to old block
    Size - amount in bytes
    File - file where allocation occurred, expected not to be deleted
    Line - line where allocation occurred

Return Value:

    PVOID - pointer to user portion

--*/

{
    DWORD userOffset, trailerOffset, amount;
    PHEADER pHeader, pNewHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    // Treat like a new allocation

    userOffset = FIELD_OFFSET( HEADER, UserData );
    trailerOffset = ALIGN( userOffset + Size );
    amount = trailerOffset + sizeof( TRAILER );
    pNewHeader = (PHEADER) realloc( pHeader, amount );
    if (pNewHeader == NULL) {
        DPRINT4( 0, "Memory reallocation of %p,%d failed at %s:%d\n",
                 MemoryBlock, amount, File, Line );
        // CODE.IMP: Additional logging?

        // Need to reinsert block back on the list
        EnterCriticalSection( &gcsIsmMemoryLock );
        __try {
            // Most recent to the front
            InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
        } __finally {
            LeaveCriticalSection( &gcsIsmMemoryLock );
        }

        return NULL;
    }
    pHeader = pNewHeader;

    // Reinitialize header and trailer
    pHeader->File = File;
    pHeader->Line = Line;
    pHeader->UserSize = Size;
    pHeader->TrailerOffset = trailerOffset;
    pHeader->Signature = HEADER_SIGNATURE;

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + trailerOffset);
    pTrailer->Signature = TRAILER_SIGNATURE;

    // Don't put on the list until fully formed
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        // Most recent to the front
        InsertHeadList( &gleIsmMemoryListHead, &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    return (PVOID) pHeader->UserData;
} /* DebugMemoryReallocate */


PVOID
DebugMemoryAllocateZero(
    DWORD Size,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Allocate a block of memory, zero user portion

Arguments:

    Size - 
    File - 
    Line - 

Return Value:

    PVOID - 

--*/

{
    PVOID memory;
    memory = DebugMemoryAllocate( Size, File, Line );
    if (memory) {
        ZeroMemory( memory, Size );
    }
    return memory;
} /* DebugMemoryAllocateZero */


BOOL
DebugMemoryCheck(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Check if block of memory is ok

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    True if block is ok, else false

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );
    if (pHeader->Signature != HEADER_SIGNATURE) {
        if (pHeader->Signature == DEAD_SIGNATURE) {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p header is already deleted, from %s:%d\n",
                     File, Line,
                     MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT3( 0, "Check on %s:%d\nMemory block %p header has invalid signature\n",
                     File, Line, MemoryBlock );
        }
        Assert( FALSE );
        return FALSE;
    }

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    if (pTrailer->Signature != TRAILER_SIGNATURE) {
        if (pTrailer->Signature == DEAD_SIGNATURE) {
           DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer is already deleted, from %s:%d\n",
                    File, Line,
                    MemoryBlock, pHeader->File, pHeader->Line );
        } else {
            DPRINT5( 0, "Check on %s:%d\nMemory block %p trailer has invalid signature, from %s:%d\n",
                     File, Line, MemoryBlock, pHeader->File, pHeader->Line );
        }
        Assert( FALSE );
        return FALSE;
    }
    return TRUE;
} /* DebugMemoryCheck */


void
DebugMemoryFree(
    PVOID MemoryBlock,
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

Free a block of memory

Arguments:

    MemoryBlock - pointer to user portion

Return Value:

    None

--*/

{
    PHEADER pHeader;
    PTRAILER pTrailer;

    DebugMemoryCheck( MemoryBlock, File, Line );

    pHeader = CONTAINING_RECORD( MemoryBlock, HEADER, UserData );

    // Remove from list before modification
    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {
        RemoveEntryList( &(pHeader->Link) );
    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

    pHeader->Signature = DEAD_SIGNATURE;
    ZeroMemory( &(pHeader->Link), sizeof( LIST_ENTRY ) );

    pTrailer = (PTRAILER) (((PBYTE) pHeader) + pHeader->TrailerOffset);
    pTrailer->Signature = DEAD_SIGNATURE;

    // Note that we preserve the remaining header contents so that if this
    // block turns up again, we may know where it came from

    memset( MemoryBlock, 'w', pHeader->UserSize );

    free( (PVOID) pHeader );
} /* DebugMemoryFree */


void
DebugMemoryCheckAll(
    PCHAR File,
    DWORD Line
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PHEADER pHeader;

/*
  Do the whole list traversal and analysis under the lock. Yuck. This guarantees a
  coherent view. If contention gets to be a problem, we need to do two things:
1. Protect access to the Flink using the critical section to prevent linked
   list simultaneous access.
2. Guarantee the lifetime of the block while we are using it.  A ref count or an
   in use flag will be needed for that.
*/

    gpleIsmLastGoodEntry = &gleIsmMemoryListHead;

    EnterCriticalSection( &gcsIsmMemoryLock );
    __try {

        entry = gleIsmMemoryListHead.Flink;
        while ( entry != &gleIsmMemoryListHead ) {
            Assert( entry && "linked list entry should have been non-zero but was not\ndd gpleIsmLastEntry l1 for pointer to last good list entry" );

            pHeader = CONTAINING_RECORD( entry, HEADER, Link );
            DebugMemoryCheck( pHeader->UserData, File, Line );

            gpleIsmLastGoodEntry = entry;
            entry = entry->Flink;
        }

    } __finally {
        LeaveCriticalSection( &gcsIsmMemoryLock );
    }

}
/* end memory.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\list.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    list.c

Abstract:

    Generic linked list package    

    Current functions include: create element or lookup element, and delete whole
    list.

    Callers define their list element.  They embed in the structure an element of
    type LIST_ENTRY. It is the address of this field that is used to identify an
    element in the list.  The caller can convert from a pointer to a LIST_ENTRY in
    their structure, to the base of their structure, by using CONTAINING_RECORD.

    Because the caller's structure may have other dynamically allocated storage, the
    caller must pass in callback routines to create and destroy their element as
    needed.

    In the future it would be reasonable to add a sorted version of the list.
    Also, single element removal/deletion function.
    Note there is no provision for protecting the lifetime of single elements,
    especially when a pointer has been handed out to another caller. In order
    to do that, a reference counting mechanism would need to be added.

Author:

    Will Lees (wlees) 19-Oct-1998

Environment:

Notes:

Revision History:

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include <winsock.h>

#include "common.h"

#define DEBSUB "ISMLIST:"

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 20 15:27:32 1998 */

DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    );

DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    );

/* End Forward */


DWORD
ListFindCreateEntry(
    LIST_CREATE_CALLBACK_FN *pfnCreate,
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    DWORD cbEntry,
    DWORD MaximumNumberEntries,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount,
    LPCWSTR EntryName,
    BOOL Create,
    PLIST_ENTRY_INSTANCE *ppListEntry
    )

/*++

Routine Description:

Generic list lookup and element creation routine.

Look up an element with the given name. If not found and Create is true, create
a new one.  If there are too many elements, release the oldest one.

List lock should be held by caller, if necessary.

Caller should have initialized listhead

Arguments:

    pfnCreate - Routine to initialize the callers element, but not allocate
    pfnDestroy - Routine to clear the caller's element, but not deallocate
    cbEntry - Size of callers element, including LIST_ENTRY_INSTANCE
    MaximumNumberEntries - List limit, or 0 for none
    pListHead - List head, must already be initialized
        NOTE, this is a LIST_ENTRY not a LIST_ENTRY_INSTANCE
    pdwEntryCount - Updated count of entries in list, caller must initialize
    EntryName - Name of new entry. Matching is on the basis of this name
    Create - Set true if we should create a new element if this name not found
    ppListEntry - Returned entry, either existing or newly created

Return Value:

    DWORD - 

--*/

{
    DWORD status, length;
    PLIST_ENTRY curr;
    PLIST_ENTRY_INSTANCE pNewEntry = NULL;

    // Be defensive
    if ( !( ppListEntry ) ||
         !( pdwEntryCount ) ||
         ( cbEntry < sizeof( LIST_ENTRY_INSTANCE ) ) ||
         !( pListHead ) ||
         !( pListHead->Flink ) ||
         !( pListHead->Blink ) ) {
        Assert( FALSE );
        return E_INVALIDARG;
    }

    // See if the entry is already present

    curr = pListHead->Flink;
    while (curr != pListHead) {
        PLIST_ENTRY_INSTANCE pListEntry;

        pListEntry = CONTAINING_RECORD( curr, LIST_ENTRY_INSTANCE, ListEntry );

        if (_wcsicmp( EntryName, pListEntry->Name ) == 0) {
            *ppListEntry = pListEntry;
            return ERROR_SUCCESS;
        }
        curr = curr->Flink;
    }

    // If we are not allowed to create it, exit at this point

    if (!Create) {
        *ppListEntry = NULL;
        return ERROR_FILE_NOT_FOUND;
    }

    // Create new record of user-specified size

    pNewEntry = (PLIST_ENTRY_INSTANCE) NEW_TYPE_ARRAY_ZERO( cbEntry, BYTE );
    if (pNewEntry == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize our part
    // Do this first so callback can use this info

    length = wcslen( EntryName );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    pNewEntry->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (pNewEntry->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pNewEntry->Name, EntryName );

    // Initialize caller's part

    status = (*pfnCreate)( pNewEntry );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // If too many instances, get rid of one
    if ( (MaximumNumberEntries) &&
         (*pdwEntryCount == MaximumNumberEntries) ) {
        PLIST_ENTRY entry;
        PLIST_ENTRY_INSTANCE pListEntry;

        // Select least recent
        entry = pListHead->Flink;
        Assert( !IsListEmpty( pListHead ) );

        RemoveEntryList( entry );
        pListEntry = CONTAINING_RECORD( entry, LIST_ENTRY_INSTANCE,
                                        ListEntry);

        // Deallocate caller's part
        (VOID) (*pfnDestroy)( pListEntry );

        // Deallocate our part
        if (pListEntry->Name) {
            FREE_TYPE( pListEntry->Name );
        }
        FREE_TYPE( pListEntry );

    } else {
        (*pdwEntryCount)++;
    }

    // Link the new instance onto the list at the end

    InsertTailList( pListHead, &(pNewEntry->ListEntry) );

    // Success!

    *ppListEntry = pNewEntry;

    return ERROR_SUCCESS;

cleanup:
    if (pNewEntry) {
        if (pNewEntry->Name != NULL) {
            FREE_TYPE( pNewEntry->Name );
        }
        FREE_TYPE( pNewEntry );
    }

    return status;

} /* ListFindCreateEntry */


DWORD
ListDestroyList(
    LIST_DESTROY_CALLBACK_FN *pfnDestroy,
    PLIST_ENTRY pListHead,
    LPDWORD pdwEntryCount
    )

/*++

Routine Description:

Destroy a generic list.

Caller should hold list lock if necessary

Arguments:

    pfnDestroy - Caller's element release function
    pListHead - List head of list
    pdwEntryCount - Updated count of elements in list, set to zero
        Note, we check this for accuracy

Return Value:

    DWORD - Always success

--*/

{
    PLIST_ENTRY entry;
    PLIST_ENTRY_INSTANCE pListEntry;

    Assert( pdwEntryCount );

    while (!IsListEmpty( pListHead )) {
        Assert( *pdwEntryCount );
        (*pdwEntryCount)--;

        entry = RemoveHeadList( pListHead );

        pListEntry = CONTAINING_RECORD( entry, LIST_ENTRY_INSTANCE,
                                        ListEntry );

        // Release caller's part
        (VOID) (*pfnDestroy)( pListEntry );

        // Release our part
        FREE_TYPE( pListEntry->Name );

        FREE_TYPE( pListEntry );
    }

    Assert( *pdwEntryCount == 0 );
    *pdwEntryCount = 0;

    return ERROR_SUCCESS;
} /* ListDestroyList */

/* end list.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\route.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    route.c

Abstract:

This module contains the routines to implement the "routing api", namely
    GetTransportServers
    GetSiteConnectivity
    GetSchedule

These routines are independent from the data transfer functions.

These routines are based on configuration data of servers, sites and links.  This may come
from the local system registry (testing) or from ldap.

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // INTERSITETRANS_OPT_* flags

#include <dsconfig.h>  // GetConfigParam()
#include <ismapi.h>
#include <debug.h>

#include <winsock.h>

#include <common.h>

#include <dsutil.h> // TickTime routines

#define DEBSUB "ROUTE:"

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ROUTE

// Use the generate table template to create a type specific table!
// Site Hash Table

#define SITE_HASH_TABLE_SIZE 107  // should be prime

typedef struct _SITE_INSTANCE {
    TABLE_ENTRY TableEntry;  // must be first
    DWORD Size;
    DWORD Index;
} SITE_INSTANCE, *PSITE_INSTANCE;

typedef PTABLE_INSTANCE PSITE_TABLE;

#define SiteTableCreate() TableCreate( SITE_HASH_TABLE_SIZE, sizeof( SITE_INSTANCE ) )
#define SiteTableFree( table ) TableFree( (PTABLE_INSTANCE) table )
#define SiteTableFindCreate( table, name, create ) \
(PSITE_INSTANCE) TableFindCreateEntry( (PTABLE_INSTANCE) table, name, create )

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Oct 27 11:07:11 1998 */

VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
RouteGetConnInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    );

DWORD
RouteGetPathSchedInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    );

void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    );

static DWORD
processSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PSITE_TABLE SiteTable,
    DWORD NumberSites,
    PGRAPH CostArray
    );

static DWORD
readSimpleBridge(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PWSTR BridgeName,
    PSITE_TABLE SiteTable,
    PGRAPH TempArray,
    PGRAPH CostArray
    );

static DWORD
walkSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

static DWORD
addSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    LPWSTR SiteLinkName,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    );

static DWORD
addLinkToCostArray(
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    PWSTR FromSite,
    PWSTR ToSite,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    );

/* End Forward */


VOID
RouteInvalidateConnectivity(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        // Invalidate the cache, recalculate later
        DPRINT1( 1, "Invalidating routing cache for %ws\n",
                 pTransport->Name );
        pTransport->RoutingState.fCacheIsValid = FALSE;
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
}


DWORD
RouteGetConnInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

Return the list of sites, a site name array, and a connectivity matrix.

A hash table is used to store the site names found, for ease of lookup.

Once all the site names are found, they are assigned an order (index).  This is the order
used to generate the site name list at the end.

The simple link structures are read to determine which sites are connected.

Once the number of sites is known, the cost array is allocated.  The initial single hop costs
are then placed in the array.  Then the ALL COSTS algorithm is run on the array to produce the
shorted paths for all pairs.

Each time this routine is called, it regenerates three pieces of information:
- the list of sites
- the matrix of costs
- the matrix of schedules
The first two are returned and freed.

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

Arguments:

    pTransport - 
    pNumberSites - 
    ppSiteList - 
    ppLinkArray - 

    dwRouteFlags - Zero or more of the following bits:
        ROUTE_IGNORE_SCHEDULES - Schedules on siteLink objects will be ignored.
            (And the "ever-present" schedule is assumed.)
        ROUTE_BRIDGES_REQUIRED - siteLinks must be explicitly bridged with
            siteLinkBridge objects to indicate transitive connections.
            Otherwise, siteLink transitivity is assumed.

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status, i;
    PGRAPH CostGraph = NULL;
    PSITE_TABLE SiteTable = NULL;
    PSITE_INSTANCE site;
    DWORD NumberSites;
    LPWSTR *pSiteList = NULL, *pSiteListCopy = NULL;
    PISM_LINK pLinkArray = NULL;
    int nPriority = THREAD_PRIORITY_NORMAL;
    DWORD dwBiasedPriority;

    if ( (!pNumberSites) ||
         (!ppSiteList) ||
         (!ppLinkArray) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Step 0: Check if cached data still valid
    // Use tick counts in case time gets changed or set backwards
    // Tick counts are in 1ms intervals, wrap every 47 days of uptime
    // Note the degraded performance guarantee. If the notify thead dies for some
    // reason, we will not consider the cache valid and will recalculate.

    if ( (DirIsNotifyThreadActive( pTransport ) ) &&
         (pTransport->RoutingState.CostGraph) &&
         (pTransport->RoutingState.fCacheIsValid) ) {

        NumberSites = pTransport->RoutingState.NumberSites;
        CostGraph = pTransport->RoutingState.CostGraph;
        pSiteList = pTransport->RoutingState.pSiteList;

        goto copy_out;
    }

    // Step 1: Initialize

    // Free previous graph state 
    RouteFreeState( pTransport );

    // initialize site list
    NumberSites = 0;
    status = DirGetSiteList( pTransport->DirectoryConnection,
                             &NumberSites,
                             &pSiteList );
    if (status != ERROR_SUCCESS) {
        // nothing to clean up yet
        return status;
    }

    // There should always be atleast one site
    if (NumberSites == 0) {
        // nothing to clean up yet
        return ERROR_DS_OBJ_NOT_FOUND;
    }

    // Initialize symbol table
    SiteTable = SiteTableCreate();
    if (NULL == SiteTable) {
        // nothing to clean up yet
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Change priority if necessary
    if (!GetConfigParam( ISM_THREAD_PRIORITY, &dwBiasedPriority, sizeof( DWORD ) )) {
        if (dwBiasedPriority > ISM_MAX_THREAD_PRIORITY) {
            dwBiasedPriority = ISM_MAX_THREAD_PRIORITY;
        }
        nPriority = dwBiasedPriority - ISM_THREAD_PRIORITY_BIAS;
        if( ! SetThreadPriority(GetCurrentThread(),nPriority) ) {
            status = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", status);
            LogEvent(
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_KCC_SET_PRIORITY_ERROR,
                szInsertWin32Msg(status),
                NULL,
                NULL
                );
        } else {
            DPRINT1(1, "ISM thread priority is now %d\n", nPriority );
        }
    }

    // Step 2: Insert each site into the hash table for ease of lookup
    for( i = 0; i < NumberSites; i++ ) {
        site = SiteTableFindCreate( SiteTable, pSiteList[i], TRUE /* create */ );
        if (site == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        // Assign index to site according to site list order
        site->Index = i;
    }

    // Step 3: allocate cost matrix
    // SCALING BUG 87827:
    // 1000 SITES = 1000 * 1000 * 12 BYTES = approx 12 MB
    CostGraph = GraphCreate( NumberSites, TRUE /* initialize */ );
    if (CostGraph == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;  // bug fix 151725
        goto cleanup;
    }

    // Step 4: add pure links without bridging

    status = walkSiteLinks( pTransport,
                            SiteTable,
                            CostGraph,
                            dwRouteFlags,
                            dwReplInterval );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (dwRouteFlags & ROUTE_BRIDGES_REQUIRED) {
        // Step 5: walk site link bridges for explicit transitivity

        status = processSiteLinkBridges( pTransport,
                                         dwRouteFlags,
                                         dwReplInterval,
                                         SiteTable,
                                         NumberSites,
                                         CostGraph );
        if (status != ERROR_SUCCESS) {
            goto cleanup;
        }
    }
    else {
        // Step 5: Transitivity is assumed, so compute the full transitive
        // closure.
        GraphAllCosts( CostGraph, (dwRouteFlags & ROUTE_IGNORE_SCHEDULES) );
    }

    // Cache data: SiteList, CostGraph and SiteTable remain allocated
    pTransport->RoutingState.fCacheIsValid = TRUE;
    pTransport->RoutingState.NumberSites = NumberSites;
    pTransport->RoutingState.pSiteList = pSiteList;
    pTransport->RoutingState.CostGraph = CostGraph;
    pTransport->RoutingState.SiteSymbolTable = SiteTable;

copy_out:
    // Step 6: Copy out user arguments

    DirCopySiteList( NumberSites, pSiteList, &pSiteListCopy );
    if (pSiteListCopy == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // This call copies the array portion out of the graph.
    GraphReferenceMatrix( CostGraph, &pLinkArray );
    if (pLinkArray == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    *pNumberSites = NumberSites;
    *ppSiteList = pSiteListCopy;
    *ppLinkArray = pLinkArray;

    pSiteList = NULL; // don't clean this up
    pSiteListCopy = NULL;
    CostGraph = NULL; // don't clean this up
    SiteTable = NULL; // don't clean this up
    pLinkArray = NULL;

    status = ERROR_SUCCESS;

cleanup:               

    if (nPriority != THREAD_PRIORITY_NORMAL) {
        if( ! SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL) ) {
            status = GetLastError();
            DPRINT1(0, "Failed to set the thread priority. Err=%d\n", status);
        }
    }

    // Clean up site list
    if (pSiteList) {
        DirFreeSiteList( NumberSites, pSiteList );
    }
    if (pSiteListCopy) {
        DirFreeSiteList( NumberSites, pSiteListCopy );
    }

    // free site table
    if (SiteTable != NULL) {
        SiteTableFree( SiteTable );
    }

    // free matrix
    if (pLinkArray != NULL) {
        GraphDereferenceMatrix( CostGraph, pLinkArray );
    }

    // free cost array
    if (CostGraph != NULL) {
        GraphFree( CostGraph );
    }

    return status;
} /* RouteGetConnectivity */


DWORD
RouteGetConnectivity(
    PTRANSPORT_INSTANCE pTransport,
    LPDWORD pNumberSites,
    PWSTR **ppSiteList,
    PISM_LINK *ppLinkArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

Wrapper for RouteGetConnInternal.
Take a lock around the connectivity function so that no other routine may
be reading or writing the routing state variables.

Arguments:

    pTransport - 
    pNumberSites - 
    ppSiteList - 
    ppLinkArray - 
    dwRouteFlags - 
    dwReplInterval - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    EnterCriticalSection( &(pTransport->Lock) );
    __try {

        status = RouteGetConnInternal(
            pTransport,
            pNumberSites,
            ppSiteList,
            ppLinkArray,
            dwRouteFlags,
            dwReplInterval
            );
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    return status;
} /* RouteGetConnectivity */


VOID
RouteFreeLinkArray(
    PTRANSPORT_INSTANCE pTransport,
    PISM_LINK pLinkArray
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    pLinkArray - 

Return Value:

    None

--*/

{
    GraphDereferenceMatrix( pTransport->RoutingState.CostGraph,
                            pLinkArray );
} /* RouteFreeLinkArray */


DWORD
RouteGetPathSchedInternal(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    PSITE_INSTANCE toSite, fromSite;

    // Note that there are no cache lifetime requirements on the schedule
    // data.
    // TODO: investigate returning schedules with connectivity data

    // Must have called GetConnectivity first
    if (pTransport->RoutingState.CostGraph == NULL) {
        DPRINT( 0, "Must call GetConnectivity first on this transport\n" );
        return ERROR_NOT_READY;
    }

    fromSite = SiteTableFindCreate( pTransport->RoutingState.SiteSymbolTable,
                                    FromSiteName,
                                    FALSE /* don't create */ );
    if (fromSite == NULL) {
        DPRINT1( 0, "GetPathSched: %ws, (from) site not found\n", FromSiteName );
        return ERROR_NO_SUCH_SITE;
    }

    toSite = SiteTableFindCreate( pTransport->RoutingState.SiteSymbolTable,
                                  ToSiteName,
                                  FALSE /* don't create */ );
    if (toSite == NULL) {
        DPRINT1( 0, "GetPathSched: %ws, (to) site not found\n", ToSiteName );
        return ERROR_NO_SUCH_SITE;
    }

    return
        GraphGetPathSchedule( pTransport->RoutingState.CostGraph,
                              fromSite->Index,
                              toSite->Index,
                              pSchedule,
                              pLength );
}


DWORD
RouteGetPathSchedule(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR FromSiteName,
    LPCWSTR ToSiteName,
    PBYTE *pSchedule,
    DWORD *pLength
    )

/*++

Routine Description:

Wrapper for RouteGetPathSchedInternal.
Take the transport lock so only one thread may be accessing the routing
state at a given time.

Arguments:

    pTransport - 
    FromSiteName - 
    ToSiteName - 
    pSchedule - 
    pLength - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        status = RouteGetPathSchedInternal(
            pTransport,
            FromSiteName,
            ToSiteName,
            pSchedule,
            pLength
            );
    } finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    return status;
} /* RouteGetPathSchedule */


void
RouteFreeState(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 

Return Value:

    None

--*/

{
    PROUTING_STATE prs = &(pTransport->RoutingState);
    
    // This routine assumes that the caller will hold the transport
    // lock, expect during rundown

    if (prs->pSiteList) {
        DirFreeSiteList( prs->NumberSites, prs->pSiteList );
    }
    if (prs->CostGraph) {
        GraphFree( prs->CostGraph );
    }
    if (prs->SiteSymbolTable) {
        SiteTableFree( prs->SiteSymbolTable );
    }

    ZeroMemory( prs, sizeof( ROUTING_STATE ) );
} /* RouteFreeState */


static DWORD
processSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PSITE_TABLE SiteTable,
    DWORD NumberSites,
    PGRAPH CostArray
    )

/*++

Routine Description:

This routine enumerates the simple link structures in the registry.  It calls an action
routine for each.

The temp array is used to calculate an intermediate matrix for each bridged network
They are merged into the final cost array

Arguments:

    pTransport - 
    dwRouteFlags - route behavior options
    dwReplInterval - default replication interval
    NumberSites - 
    SiteTable - 
    CostArray - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, index, length;
    WCHAR bridgeName[MAX_REG_COMPONENT];
    PGRAPH TempArray = NULL;
    PVOID context = NULL;

    Assert( dwRouteFlags & ROUTE_BRIDGES_REQUIRED );

    // Allocate a temp array now for intermediate results.  It is init'd later
    TempArray = GraphCreate( NumberSites, FALSE /* initialize */ );
    if (TempArray == NULL) {
        DPRINT1( 0, "failed to allocate temp matrix for %d sites\n", NumberSites );
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    while (1) {
        status = DirIterateSiteLinkBridges( pTransport,
                                            pTransport->DirectoryConnection,
                                            &context,
                                            bridgeName );
        if (status == ERROR_NO_MORE_ITEMS) {
            // context is already cleaned up
            status = ERROR_SUCCESS;
            break;
        } else if (status != ERROR_SUCCESS) {
            break;
        }

        status = readSimpleBridge( pTransport,
                                   dwRouteFlags,
                                   dwReplInterval,
                                   bridgeName,
                                   SiteTable,
                                   TempArray,
                                   CostArray
                                   );
        if (status != ERROR_SUCCESS) {
            DPRINT2( 0, "read of bridge key %ws, error = %d\n", bridgeName, status );
            LogEvent8WithData( 
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_OBJECT_FAILURE,
                szInsertWC( bridgeName ),
                szInsertWin32Msg( status ),
                NULL, NULL, NULL, NULL, NULL, NULL,
                sizeof( status ), &status
                );
            // keep going
        }
    }

    // status is set according to success or failure of iteration

cleanup:

    if (context != NULL) {
        DirTerminateIteration( &context );
    }

    if (TempArray != NULL) {
        GraphFree( TempArray );
    }

    return status;
} /* processSiteLinkBridges */


static DWORD
readSimpleBridge(
    PTRANSPORT_INSTANCE pTransport,
    DWORD dwRouteFlags,
    DWORD dwReplInterval,
    PWSTR BridgeName,
    PSITE_TABLE SiteTable,
    PGRAPH TempArray,
    PGRAPH CostArray
    )

/*++

Routine Description:

This routine is called by processSiteLinkBridges.  It handles the work on a single bridge entry.

Arguments:

    pTransport - 
    dwRouteFlags - route behavior options
    dwReplInterval - default replication interval
    BridgeName - 
    NumberSites - 
    SiteTable - 
    TempArray - 
    CostArray - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, type, length, i;
    PWSTR siteLinkList = NULL, linkName;

    DPRINT1( 3, "readSimpleBridge, bridge = %ws\n", BridgeName );

    GraphInit( TempArray );

    status = DirReadSiteLinkBridge( pTransport,
                                    pTransport->DirectoryConnection,
                                    BridgeName,
                                    &siteLinkList );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    // No siteLinks listed, all done
    if (siteLinkList == NULL) {
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Walk SiteLink list, populating array

    for( linkName = siteLinkList; *linkName != L'\0'; linkName += wcslen( linkName ) + 1 ) {

        status = addSiteLink( pTransport,
                              SiteTable,
                              TempArray,
                              linkName,
                              dwRouteFlags,
                              dwReplInterval );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "Action routine failed, error %d\n", status );
            goto cleanup;
        }

    }

    // All sites in a site link that is in a bridge are transitive
    // Perform all pairs, shortest path

    GraphAllCosts( TempArray, (dwRouteFlags & ROUTE_IGNORE_SCHEDULES) );

    // Merge results into master matrix
    GraphMerge( CostArray, TempArray );

    status = ERROR_SUCCESS;

cleanup:

    if (siteLinkList != NULL) {
        DirFreeMultiszString( siteLinkList );
    }

    return status;
} /* readSimpleBridge */


static DWORD
walkSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

This routine enumerates the simple link structures in the registry.  It calls an action
routine for each.

Arguments:

    pTransport - 
    SiteTable - 
    CostArray - 

    dwRouteFlags - If the ROUTE_IGNORE_SCHEDULES bit is set, schedules on
        siteLink objects will be ignored.  (And the "ever-present" schedule
        is assumed.)

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    PVOID context = NULL;
    WCHAR siteLinkName[MAX_REG_COMPONENT];

    while (1) {
        status = DirIterateSiteLinks( pTransport,
                                      pTransport->DirectoryConnection,
                                      &context,
                                      siteLinkName );
        if (status == ERROR_NO_MORE_ITEMS) {
            // context is already cleaned up
            status = ERROR_SUCCESS;
            break;
        } else if (status != ERROR_SUCCESS) {
            goto cleanup;
        }

        status = addSiteLink( pTransport,
                              SiteTable,
                              CostArray,
                              siteLinkName,
                              dwRouteFlags,
                              dwReplInterval );
        if (status != ERROR_SUCCESS) {
            LogEvent8WithData( 
                DS_EVENT_CAT_ISM,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_ISM_OBJECT_FAILURE,
                szInsertWC( siteLinkName ),
                szInsertWin32Msg( status ),
                NULL, NULL, NULL, NULL, NULL, NULL,
                sizeof( status ), &status
                );
            // keep going
        }
    }

    // status is set at this point according to success or failure

cleanup:

    if (context != NULL) {
        DirTerminateIteration( &context );
    }

    return status;

} /* walkSiteLinks */


static DWORD
addSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    LPWSTR SiteLinkName,
    DWORD dwRouteFlags,
    DWORD dwReplInterval
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    SiteTable - 
    CostArray - 
    SiteLinkName - 

    dwRouteFlags - If the ROUTE_IGNORE_SCHEDULES bit is set, schedules on
        siteLink objects will be ignored.  (And the "ever-present" schedule
        is assumed.)

    dwReplInterval - default replication interval

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    LPWSTR siteList = NULL, inner, outer;
    PBYTE pSchedule = NULL;
    PBYTE *ppSchedule;
    ISM_LINK link;

    //DPRINT1( 3, "addSiteLink, link name = %ws\n", SiteLinkName );

    ppSchedule = (dwRouteFlags & ROUTE_IGNORE_SCHEDULES)
                    ? NULL
                    : &pSchedule;

    status = DirReadSiteLink( pTransport,
                              pTransport->DirectoryConnection,
                              SiteLinkName,
                              &siteList,
                              &link,
                              ppSchedule );
    if (status != ERROR_SUCCESS) {
        // nothing to clean up
        return status;
    }

    // No sites listed
    if (siteList == NULL) {
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // If interval not specified, use the transport default

    if (link.ulReplicationInterval == 0) {
        link.ulReplicationInterval = dwReplInterval;
    }

    // process site link

    // SiteList can be 2 or more sites
    // Generate pairs, eliminate duplicates (order is not significant):
    // (a,b,c) => (a,b), (a,c), (b,c)

    outer = siteList;
    while (*outer != L'\0') {
        DWORD outerLength = wcslen( outer) + 1;

        for( inner = outer + outerLength; *inner != L'\0'; inner += wcslen( inner ) + 1 ) {

            // Filter out cyles to self, just in case
            if (_wcsicmp( outer, inner ) == 0) {
                continue;
            }

            // The action routine handles unidirectional (directed) links.  We convert here from
            // the bidirectional (undirected) notation by calling the action routine twice, once
            // for each direction.
            
            // Add the link in the forward direction

            status = addLinkToCostArray( SiteTable, CostArray, 
                                         outer, inner, &link, pSchedule );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "addLinkToCostArray1 failed, error %d\n", status );
                goto cleanup;
            }

            // Add the link in the backward direction
            status = addLinkToCostArray( SiteTable, CostArray,
                                         inner, outer, &link, pSchedule );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "addLinkToCostArray2 failed, error %d\n", status );
                goto cleanup;
            }
        }

        outer += outerLength;
    }

    status = ERROR_SUCCESS;

cleanup:

    if (siteList) {
        DirFreeMultiszString( siteList );
    }

    if (pSchedule) {
        DirFreeSchedule( pSchedule );
    }

    return status;
} /* addSiteLink */


static DWORD
addLinkToCostArray(
    PSITE_TABLE SiteTable,
    PGRAPH CostArray,
    PWSTR FromSite,
    PWSTR ToSite,
    PISM_LINK pLinkValue,
    PBYTE pSchedule
    )

/*++

Routine Description:

This is an action routine for the WalkSiteLinks function.

This routine stores the hop costs in the cost array.

Arguments:

    SiteTable - 
    CostArray - 
    FromSite - 
    ToSite - 
    Cost - 
    pSchedule - 

Return Value:

    DWORD - 

--*/

{
    PSITE_INSTANCE site1, site2;
    LPDWORD element;

    DPRINT5( 3, "Adding simple link %ws --(%d,%d,%p)--> %ws\n",
             FromSite,
             pLinkValue->ulCost, pLinkValue->ulReplicationInterval,
             pSchedule, ToSite );

    site1 = SiteTableFindCreate( SiteTable,
                                 FromSite,
                                 FALSE /* don't create */ );
    if (site1 == NULL) {
        // Must exist
        DPRINT1( 0, "Site %ws is not valid\n", FromSite );
        return ERROR_NO_SUCH_SITE;
    }
    site2 = SiteTableFindCreate( SiteTable,
                                 ToSite,
                                 FALSE /* don't create */ );
    if (site2 == NULL) {
        // Must exist
        DPRINT1( 0, "Site %ws is not valid\n", ToSite );
        return ERROR_NO_SUCH_SITE;
    }

    // Put cost in table ONLY if it is better than previous cost
    GraphAddEdgeIfBetter( CostArray,
                          site1->Index, site2->Index,
                          pLinkValue, pSchedule );

    return ERROR_SUCCESS;
} /* addLinkToCostArray */

/* end route.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\simlib\simism.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    simism.c

Abstract:

    Simulate the ISM connectivity APIs    

    This module is a wrapper around the ISM plug in common library.  It exposes
    the ISM APIs in a callable library.  Normally, you have to go through the
    ISM SERVICE to access this code.

Author:

    Will Lees (wlees) 22-Jul-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#define UNICODE 1

#include <ntdspch.h>
#include <ntdsa.h>
#include <ismapi.h>

#include "common.h"         // common transport library
#include <debug.h>
#define DEBSUB "SIMISM:"
#define  FILENO FILENO_ISMSERV_ROUTE

// Memory block tags
// We have a problem with the memory allocation/deallocation model.
// Becuase this interface is normally remoted via RPCs, the expectation
// of the free routine is that all the memory returned is contigious.
// Use a Tag to determine what kind of block is being freed.

#define SIMISM_CONNECTIVITY 1
#define SIMISM_SERVER_LIST 2
#define SIMISM_SCHEDULE 3

typedef struct _TAGGED_BLOCK {
    DWORD BlockType;
    union {
        ISM_CONNECTIVITY Connectivity;
        ISM_SERVER_LIST ServerList;
        ISM_SCHEDULE Schedule;
    };
} TAGGED_BLOCK, *PTAGGED_BLOCK;

/* External */

/* Static */

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Fri Jul 23 10:13:39 1999 */

void
I_ISMInitialize(
    void
    );

void
I_ISMTerminate(
    void
    );

PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    );

PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    );

void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    );

void
deleteTransportList(
    void
    );

void
I_ISMFree(
    IN  VOID *  pv
    );

DWORD
I_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

DWORD
I_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   );

DWORD
I_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    );

/* End Forward */


void
SimI_ISMInitialize(
    void
    )

/*++

Routine Description:

This function is to be called before the other functions.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
#if DBG
    DebugMemoryInitialize();
#endif
    InitializeListHead( &TransportListHead );
}


void
SimI_ISMTerminate(
    void
    )

/*++

Routine Description:

This function is to be called at the end.

This function is not part of the actual ISM API.

Arguments:

    None

Return Value:

    None

--*/

{
    deleteTransportList();
#if DBG
    DebugMemoryTerminate();
#endif
    if (!IsListEmpty( &TransportListHead )) {
        DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
    }

}


PTRANSPORT_INSTANCE
createTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length, status;
    PTRANSPORT_INSTANCE instance = NULL;

    length = wcslen( pszTransportDN );
    if (length == 0) {
        return NULL;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        return NULL;
    }
    instance->Size = sizeof( TRANSPORT_INSTANCE );

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        return NULL;
    }
    wcscpy( instance->Name, pszTransportDN );

    InitializeCriticalSection( &(instance->Lock) );

    // ReplInterval is 0, meaning the application should take default
    instance->ReplInterval = 0;

    if (wcsstr( pszTransportDN, L"CN=SMTP" ) == pszTransportDN) {
        // SMTP transport
        // Default is schedules not significant, bridges not required (transitive)
        instance->Options = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;
    } else {
        // non-SMTP transport
        // Default is schedules significant, bridges not required (transitive)
        instance->Options = 0;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Add to transport list
    InsertTailList( &TransportListHead, &(instance->ListEntry) );

    return instance;
cleanup:
    if (instance) {
        deleteTransport( instance );
    }
    return NULL;
}


PTRANSPORT_INSTANCE
lookupTransport(
    IN  LPCWSTR                 pszTransportDN
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PLIST_ENTRY entry;
    PTRANSPORT_INSTANCE pTransport, pFound = NULL;

    for( entry = TransportListHead.Flink;
         entry != &(TransportListHead);
         entry = entry->Flink ) {
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );
        if (_wcsicmp( pszTransportDN, pTransport->Name ) == 0) {
            pFound = pTransport;
            break;
        }
    }

    return pFound;
}


void
deleteTransport(
    PTRANSPORT_INSTANCE instance
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    Assert( instance );

    // Release any routing state
    RouteFreeState( instance );

    DeleteCriticalSection( &(instance->Lock) );

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }
    instance->Size = 0; // clear signature to prevent reuse

    FREE_TYPE( instance );
}


void
deleteTransportList(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LIST_ENTRY *entry;
    PTRANSPORT_INSTANCE pTransport;

    while (!IsListEmpty(&TransportListHead)) {

        entry = RemoveHeadList( &TransportListHead );
        pTransport = CONTAINING_RECORD( entry, TRANSPORT_INSTANCE, ListEntry );

        deleteTransport( pTransport );

    }
}

void
SimI_ISMFree(
    IN  VOID *  pv
    )
/*++

Routine Description:

    Frees memory allocated on the behalf of the client by I_ISM* APIs.

Arguments:

    pv (IN) - Memory to free.

Return Values:

    None.

--*/
{
    PTAGGED_BLOCK pBlock;
    if (pv == NULL) {
        return;
    }

    pBlock = CONTAINING_RECORD( pv, TAGGED_BLOCK, Connectivity );
    switch (pBlock->BlockType) {
    case SIMISM_CONNECTIVITY:
    {
        TRANSPORT_INSTANCE dummyInstance;

        ISM_CONNECTIVITY *pConnectivity = &(pBlock->Connectivity);

        if (pConnectivity->cNumSites > 0) {
            DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

            RouteFreeLinkArray( &dummyInstance, pConnectivity->pLinkValues );
        }
        break;
    }
    case SIMISM_SERVER_LIST:
    {
        ISM_SERVER_LIST *pServerList = &(pBlock->ServerList);
        DWORD i;

        DirFreeSiteList( pServerList->cNumServers, pServerList->ppServerDNs );

        break;
    }
    case SIMISM_SCHEDULE:
    {
        ISM_SCHEDULE *pSchedule = &(pBlock->Schedule);
        Assert( pSchedule->cbSchedule != 0 );
        Assert( pSchedule->pbSchedule );

        FREE_TYPE( pSchedule->pbSchedule );

        pSchedule->pbSchedule = NULL;
        pSchedule->cbSchedule = 0;

        break;
    }
    default:
        Assert( FALSE );
    }

    FREE_TYPE( pBlock );
}


DWORD
SimI_ISMGetConnectivity(
    IN  LPCWSTR                 pszTransportDN,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites via a
    specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppConnectivity);

Arguments:

    pszTransportDN (IN) - The transport for which to query costs.

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along the given transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    DWORD status;
    DWORD numberSites, i;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppConnectivity) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppConnectivity = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Simulate the call

    // Get the site list and connectivity matrix

    status = RouteGetConnectivity( instance, &numberSites, &pSiteList,
                                   &pLinkArray, instance->Options,
                                   instance->ReplInterval );

    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to get connectivity, error %d\n", status );
        goto cleanup;
    }

    // Return null structure to indicate no sites
    if (numberSites == 0) {
        ppConnectivity = NULL; // No connectivity
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( pLinkArray );
    Assert( pSiteList );

    // Build a connectivity structure to return

//    pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );

        // Cleanup the pieces
        DirFreeSiteList( numberSites, pSiteList );
        RouteFreeLinkArray( instance, pLinkArray );

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pBlock->BlockType = SIMISM_CONNECTIVITY;
    pConnectivity = &(pBlock->Connectivity);

    pConnectivity->cNumSites = numberSites;
    pConnectivity->ppSiteDNs = pSiteList;
    pConnectivity->pLinkValues = pLinkArray;
    *ppConnectivity = pConnectivity;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}

DWORD
SimI_ISMGetTransportServers(
   IN  LPCWSTR              pszTransportDN,
   IN  LPCWSTR              pszSiteDN,
   OUT ISM_SERVER_LIST **   ppServerList
   )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via a specific transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppServerList);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE instance = NULL;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppServerList) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppServerList = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    // Get the server list

    status = DirGetSiteBridgeheadList( instance, instance->DirectoryConnection,
                                       pszSiteDN, &numberServers, &serverList );
    if (status != ERROR_SUCCESS) {

        if (status == ERROR_FILE_NOT_FOUND) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            goto cleanup;
        }

        DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
        return status;
    }

    // Return null structure to indicate no servers
    if (numberServers == 0) {
        *ppServerList = NULL; // All servers
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    // Construct the server structure

    // pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
    pBlock = NEW_TYPE( TAGGED_BLOCK );
    if (pBlock == NULL) {
        DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

        // Clean up the pieces
        for( i = 0; i < numberServers; i++ ) {
            FREE_TYPE( serverList[i] );
        }
        FREE_TYPE( serverList );

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    pBlock->BlockType = SIMISM_SERVER_LIST;
    pIsmServerList = &(pBlock->ServerList);

    pIsmServerList->cNumServers = numberServers;
    pIsmServerList->ppServerDNs = serverList;

    *ppServerList = pIsmServerList;

// ************************************************************

    status = ERROR_SUCCESS;
cleanup:

    return status;
}


DWORD
SimI_ISMGetConnectionSchedule(
    LPCWSTR             pszTransportDN,
    LPCWSTR             pszSiteDN1,
    LPCWSTR             pszSiteDN2,
    ISM_SCHEDULE **     ppSchedule
    )
/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via a specific
    transport.

    On successful return, it is the client's responsibility to eventually call
    I_ISMFree(*ppSchedule);

Arguments:

    pszTransportDN (IN) - Transport to query.

    pszSiteDN1, pszSiteDN2 (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE instance = NULL;
    PBYTE pSchedule;
    PTAGGED_BLOCK pBlock;

    if (NULL == ppSchedule) {
        return ERROR_INVALID_PARAMETER;
    }

    *ppSchedule = NULL;

    // Find or create the transport instance

    instance = lookupTransport( pszTransportDN );
    if (!instance) {
        instance = createTransport( pszTransportDN );
        if (!instance) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

// ************************************************************

    status = RouteGetPathSchedule( instance,
                                   pszSiteDN1,
                                   pszSiteDN2,
                                   &pSchedule,
                                   &length );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
//        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        pBlock = NEW_TYPE( TAGGED_BLOCK );
        if (pBlock == NULL) {
            FREE_TYPE( pSchedule );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        pBlock->BlockType = SIMISM_SCHEDULE;
        *ppSchedule = &(pBlock->Schedule);
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

// ************************************************************

    status = ERROR_SUCCESS;

cleanup:

    return status;
}

BOOL
DirIsNotifyThreadActive(
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    // Caching is always supported in the simulator
    return TRUE;
}

/* end simism.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\simlib\simismt.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    simismt.c

ABSTRACT:

    Test utility for the Simulated Intersite Messaging service.

DETAILS:

CREATED:

    22 Jul 99   Will Lees

REVISION HISTORY:

--*/

#include <ntdspch.h>
#if SIMISM
#define I_ISMGetConnectivity SimI_ISMGetConnectivity
#define I_ISMGetConnectionSchedule SimI_ISMGetConnectionSchedule
#define I_ISMFree SimI_ISMFree
#endif
#include <ismapi.h>

#include <schedule.h>
#include <debug.h>
#include "common.h"

// Extern
// Need to find a header file for these
void
SimI_ISMInitialize(
    void
    );
void
SimI_ISMTerminate(
    void
    );

int
__cdecl
wmain(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i, j;
    ISM_CONNECTIVITY *pConnectivity = NULL;
    LPSTR rgpszDebugParams[] = {"simism.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
    ISM_SCHEDULE *pSchedule = NULL;

    DEBUGINIT(cNumDebugParams, rgpszDebugParams, "simismt");

    printf( "hello world\n" );

#if DBG
// This stuff forces the debugging spew in the simism library to come out on
// your kernel debugger. You probably won't need this...
//        DebugInfo.severity = 1;
//        strcpy( DebugInfo.DebSubSystems, "ISMIP:IPDGRPC:" ); 
        DebugInfo.severity = 3;
        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif

    printf( "I_ISMInitialize\n" );
    SimI_ISMInitialize();

// *************************************

    printf( "I_ISMGetConnectivity\n" );
    status = I_ISMGetConnectivity( L"CN=IP", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    status = I_ISMGetConnectionSchedule( L"CN=IP",
                                         pConnectivity->ppSiteDNs[0],
                                         pConnectivity->ppSiteDNs[1],
                                         &pSchedule );
    if (pSchedule) {
        printf( "Returned non-null schedule = 0x%p\n", pSchedule );
        I_ISMFree( pSchedule );
    } else {
        printf( "Returned schedule = NULL\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

    pConnectivity = NULL;

// *************************************

    printf( "I_ISMGetConnectivity, second time, cached results\n" );
    status = I_ISMGetConnectivity( L"CN=IP", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

// *************************************

    printf( "I_ISMGetConnectivity(SMTP)\n" );
    status = I_ISMGetConnectivity( L"CN=SMTP,blah", &pConnectivity );
    printf( "status = %d; pConnectivity = 0x%p\n", status, pConnectivity );

    // Dump the matrix
    printf( "Number sites = %d\n", pConnectivity->cNumSites );
    for( i = 0; i < pConnectivity->cNumSites; i++ ) {
        printf( "Sitedn[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            ISM_LINK *pLink =
                pConnectivity->pLinkValues + (i * pConnectivity->cNumSites + j);
            printf( " %d:%d:%d", pLink->ulCost,
                    pLink->ulReplicationInterval, pLink->ulOptions );
        }
        printf("\n" );
    }

    status = I_ISMGetConnectionSchedule( L"CN=SMTP,blah",
                                         pConnectivity->ppSiteDNs[0],
                                         pConnectivity->ppSiteDNs[1],
                                         &pSchedule );
    if (pSchedule) {
        printf( "Returned non-null schedule = 0x%p\n", pSchedule );
        I_ISMFree( pSchedule );
    } else {
        printf( "Returned schedule = NULL\n" );
    }

    printf( "I_ISMFree\n" );
    I_ISMFree( pConnectivity );

    pConnectivity = NULL;

// *************************************

    printf( "I_ISMTerminate\n" );
    SimI_ISMTerminate();

    DEBUGTERM();

    return 0;
}

//**************************************************************************************
// Aaron - these are the routines that you need to simulate
//**************************************************************************************


DWORD
DirReadTransport(
    PVOID ConnectionHandle,
    PTRANSPORT_INSTANCE pTransport
    )

/*++

Routine Description:

This routine allows the directory provider to fill in the instance with
transport object specific information.  The name transport object should
be looked up to make sure it exists.  If it does, the "replInterval" and
"options" attributes should be read and populated into the fields
in the transport instance.

Note that the transport instance is already initialized. Only update it
if you have something to override.

Arguments:

    ConnectionHandle - Ignored
    pTransport - Contains useful information in and out
       in: Name - name of transport
       out: ReplInterval - transport specific replInterval to apply
            Options - transport specific options to apply

Return Value:

    DWORD - 

--*/

{
    printf( "DirReadTransport, name = %ws\n", pTransport->Name );

    // Look up name of transport and make sure it exists
    // Look up "replInterval" on transport object and return if non-zero
    // Loop up options on transport object and return if non-zero

    return ERROR_SUCCESS;
} /* DirReadTransport */

//**************************************************************************************
// These routines deal with an array of pointers to strings for the sites
//**************************************************************************************

void
DirFreeSiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList
    )

/*++

Routine Description:

Free the site list returned by DirGetSiteList.
Also frees the server list returned by DirGetSiteBridgeheadList
Use the matching deallocator that you use for the allocator.

Note that this routine should be defensive and free partially constructed
structures.

Arguments:

    NumberSites - 
    pSiteList - 

Return Value:

    None

--*/

{
    DWORD i;
    printf( "DirFreeSiteList\n" );

    if ( (NumberSites == 0) || (pSiteList == NULL) ) {
        return;
    }
    for( i = 0; i < NumberSites; i++ ) {
        if (pSiteList[i] != NULL) {
            free( pSiteList[i] );
            pSiteList[i] = NULL;
        }
    }
    free( pSiteList );
} /* DirFreeSiteList */

void
DirCopySiteList(
    DWORD NumberSites,
    LPWSTR *pSiteList,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

Make a copy of a site list.  A site list is a array of pointers to strings.

Use the same allocator as DirGetSiteList.

Arguments:

    NumberSites - 
    pSiteList - 
    ppSiteList - 

Return Value:

    None

--*/

{
    DWORD i;
    LPWSTR *pStringList = NULL;

    printf( "DirCopySiteList\n" );

    if ( (NumberSites == 0) || (pSiteList == NULL) ) {
        *ppSiteList = NULL;
        return;
    }

    pStringList = (LPWSTR *) malloc( NumberSites * sizeof( LPWSTR ) );
    if (pStringList == NULL) {
        *ppSiteList = NULL;
        return;
    }
    ZeroMemory( pStringList, NumberSites * sizeof( LPWSTR ) );

    for( i = 0; i < NumberSites; i++ ) {
        pStringList[i] = malloc( (wcslen( pSiteList[i] ) + 1) * sizeof( WCHAR ) );
        if (pStringList[i] == NULL) {
            goto cleanup;
        }
        wcscpy( pStringList[i], pSiteList[i] );
    }

    *ppSiteList = pStringList;

    return;
cleanup:
    if (pStringList) {
        DirFreeSiteList( NumberSites, pStringList );
    }
    // Must null out parameters on error because no error code returned
    *ppSiteList = NULL;

} /* DirCopySiteList */

DWORD
DirGetSiteList(
    PVOID ConnectionHandle,
    LPDWORD pNumberSites,
    LPWSTR **ppSiteList
    )

/*++

Routine Description:

Return the list of sites as an array of pointers to wide strings.

To get the list of sites, do a one-level search of the sites container,
looking for objects of type site.

If any of the allocations should fail, any internal allocations should
be cleaned up, and NULL should be returned.

Arguments:

    ConnectionHandle - 
    pNumberSites - 
    ppSiteList - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, numberSites;
    LPWSTR pszSite1 = L"CN=Site One";
    LPWSTR pszSite2 = L"CN=Site Two";
    LPWSTR pszSite3 = L"CN=Site Three";
    LPWSTR *pStringList = NULL;

    printf( "DirGetSiteList\n" );

    numberSites = 3;
    pStringList = (LPWSTR *) malloc( 3 * sizeof( LPWSTR ) );
    if (pStringList == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pStringList, 3 * sizeof( LPWSTR ) );

    pStringList[0] = malloc( (wcslen( pszSite1 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[0] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[0], pszSite1 );

    pStringList[1] = malloc( (wcslen( pszSite2 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[1] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[1], pszSite2 );

    pStringList[2] = malloc( (wcslen( pszSite3 ) + 1) * sizeof( WCHAR ) );
    if (pStringList[2] == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    wcscpy( pStringList[2], pszSite3 );

    // Return out parameters

    *ppSiteList = pStringList;
    *pNumberSites = numberSites;
    pStringList = NULL; // don't clean up

    status = ERROR_SUCCESS;
cleanup:
    if (pStringList) {
        DirFreeSiteList( numberSites, pStringList );
    }

    // No need to null out parameters on error, because error code is returned

    return status;
} /* DirGetSiteList */

//**************************************************************************************
// These routines return the site links and bridges
//**************************************************************************************


void
DirTerminateIteration(
    PVOID *pIterateContextHandle
    )

/*++

Routine Description:

This routine cleans up an iteration context allocated by the following routines.

Arguments:

    pIterationContextHandle - pointer to a PVOID. The PVOID contains a pointer to
         whatever context you need to implement the iteration functions

Return Value:

    None

--*/

{
    LPDWORD pContext;

    printf( "DirTerminateIteration\n" );

    if (pIterateContextHandle == NULL) {
        return;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    if (pContext != NULL) {
        // Context is present, deallocate
        *pContext = 0;
        free( pContext );
        *pIterateContextHandle = NULL;
    }
}

DWORD
DirIterateSiteLinks(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkName
    )

/*++

Routine Description:

This routine returns name name of each site link, one at a time.

This routine is structured as an "iterator", where the caller calls us
successively until no more items are returned.  The caller provides us
with a pointer to a PVOID in which we can keep whatever we need
to keep track of where we are.  The caller agrees to call us with NULL
in the PVOID at the start of the iteration.

The site links are stored below the transport object.  Do a one-level search
below the transport object for objects of type "siteLink".

SiteLinkName must be allocated by the caller to be MAX_REG_COMPONENT length

Arguments:

    pTransport - Context for the transport. Various transport-wide defaults are
        here. You can get the name.
    ConnectionHandle - Ignored.
    pIterateContextHandle - A pointer to a pointer, which this routine uses to store
        a pointer to a block of storage we use to keep track of where we are.
        In this sample, we use only a DWORD for a count, but you can keep whatever
        you want.
    SiteLinkName - Pointer to a fixed string allocated by the caller.

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    LPDWORD pContext;
    LPWSTR dn;

    printf( "DirIterateSiteLinks, transport = %ws\n", pTransport->Name );

    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    // Allocate the context if this is the first time
    if (pContext == NULL) {
        // First time, new context required
        pContext = (LPDWORD) malloc( sizeof( DWORD ) );
        if (pContext == NULL) {
            *pIterateContextHandle = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIterateContextHandle = pContext;
        if (wcsstr( pTransport->Name, L"CN=SMTP") != NULL) {
            *pContext = 4;
        } else {
            *pContext = 0;
        }
    }

    switch (*pContext) {
    case 0:
        dn = L"CN=Site Link One";
        break;
    case 1:
        dn = L"CN=Site Link Two";
        break;
    case 2:
        dn = L"CN=Site Link Three";
        break;
    case 3:
        return ERROR_NO_MORE_ITEMS;
    case 4:
        dn = L"CN=Site Link Four";
        break;
    default:
        return ERROR_NO_MORE_ITEMS;
    }

    // Call allocates the storage, we copy into it
    wcsncpy( SiteLinkName, dn, MAX_REG_COMPONENT );
    SiteLinkName[MAX_REG_COMPONENT - 1] = L'\0';

    // Advance context for next iteration
    (*pContext)++;

    return ERROR_SUCCESS;;

} /* DirIterateSiteLinks */


void
DirFreeMultiszString(
    LPWSTR MultiszString
    )

/*++

Routine Description:

Free the storage for the multisz out parameters return from 
DirReadSiteLink and DirReadSiteLinkBridge

This deallocator must match the allocator used by DirRead functions.

Arguments:

    MultiszString - String to be freed.

Return Value:

    None

--*/

{
    free( MultiszString );
} /* DirFreeMultiszString */


void
DirFreeSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

Free the storage for the schedule returned from the
DirReadSiteLink routine

This deallocator must match the allocator used by DirRead functions.

Arguments:

    pSchedule - 

Return Value:

    None

--*/

{
    free( pSchedule );
} /* DirFreeSchedule */

DWORD
DirReadSiteLink(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkName,
    LPWSTR *pSiteList,
    PISM_LINK pLinkValue,
    PBYTE *ppSchedule
    )

/*++

Routine Description:

Return the attributes of the named site link.  The attributes are stored
on the object and returned in the directory.

The attributes are:
#define ATT_SL L"siteList"
#define ATT_COST L"cost"
#define ATT_RI L"replInterval"
#define ATT_OP L"options"
#define ATT_SCHED L"schedule"

Arguments:

    pTransport - 
    ConnectionHandle - 
    SiteLinkName - 
    pSiteList - pointer to a multisz string, we allocate
        Note that allocator must match deallocator in DirFreeMultiszString
    pLinkValue - pointer to an ISM_LINK, caller allocates
    ppSchedule - pointer to a blob, we allocate
        Note that allocator must match deallocator in DirFreeSchedule

Return Value:

    DWORD - 

--*/

{
    DWORD length;
// Calculating the size of these is a little tricky since the string
// has embedded NULL's
#define MULTISZ1 L"CN=Site One\0"
#define MULTISZ3 L"CN=Site Two\0CN=Site Three\0"
#define MULTISZ4 L"CN=Site One\0CN=Site Three\0"
    LPWSTR pszSiteList1 = MULTISZ1;
    LPWSTR pszSiteList3 = MULTISZ3;
    LPWSTR pszSiteList4 = MULTISZ4;

    printf( "DirReadSiteLink, transport = %ws, SiteLinkName = %ws\n",
            pTransport->Name, SiteLinkName );

    if (_wcsicmp( SiteLinkName, L"CN=Site Link One") == 0) {
        length = (sizeof MULTISZ1) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList1, length );

        pLinkValue->ulCost = 100;
        pLinkValue->ulReplicationInterval = 15;
        pLinkValue->ulOptions = 0;

        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Two") == 0) {
        *pSiteList = NULL;
        pLinkValue->ulCost = 200;
        pLinkValue->ulReplicationInterval = 30;
        pLinkValue->ulOptions = 0;

        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Three") == 0) {
        length = (sizeof MULTISZ3) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList3, length );

        pLinkValue->ulCost = 300;
        pLinkValue->ulReplicationInterval = 45;
        pLinkValue->ulOptions = 0;
        ppSchedule = NULL;
    } else if (_wcsicmp( SiteLinkName, L"CN=Site Link Four") == 0) {
        length = (sizeof MULTISZ4) * sizeof( WCHAR );
        *pSiteList = (LPWSTR) malloc( length );
        if (*pSiteList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy( *pSiteList, pszSiteList4, length );

        pLinkValue->ulCost = 400;
        pLinkValue->ulReplicationInterval = 60;
        pLinkValue->ulOptions = 0;
        ppSchedule = NULL;
    } else {
        Assert( FALSE );
    }

    return ERROR_SUCCESS;
} /* DirReadSiteLink */

//**************************************************************************************
// The remaining routines must be stubbed out, but are not called by default
//**************************************************************************************

DWORD
DirIterateSiteLinkBridges(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    PVOID *pIterateContextHandle,
    LPWSTR SiteLinkBridgeName
    )

/*++

Routine Description:

Return each site link bridge one at a time.

NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! 

Not used by default. Only when "bridges required option" turned on.
Aaron, implement this last.

Arguments:

    pTransport - 
    ConnectionHandle - 
    pIterateContextHandle - 
    SiteLinkBridgeName - 

Return Value:

    DWORD - 

--*/

{
#if 0
    DWORD status;
    LPDWORD pContext;
    LPWSTR dn;

    printf( "DirIterateSiteLinkBridges, transport = %ws\n", pTransport->Name );

    if (pIterateContextHandle == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    pContext = *((LPDWORD *) pIterateContextHandle);

    if (pContext == NULL) {
        // First time, new context required
        pContext = (LPDWORD) malloc( sizeof( DWORD ) );
        if (pContext == NULL) {
            *pIterateContextHandle = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIterateContextHandle = pContext;
        *pContext = 0;
    }

    status = ERROR_SUCCESS;

    switch (*pContext) {
    case 0:
        dn = L"Site Bridge One";
        break;
    case 1:
        dn = L"Site Bridge Two";
        break;
    case 2:
        dn = L"Site Bridge Three";
        break;
    default:
        status = ERROR_NO_MORE_ITEMS;
        break;
    }

    // Call allocates the storage, we copy into it
    wcsncpy( SiteLinkBridgeName, dn, MAX_REG_COMPONENT );
    SiteLinkBridgeName[MAX_REG_COMPONENT - 1] = L'\0';

    // Advance context for next iteration
    (*pContext)++;

    return status;
#endif
    return ERROR_INVALID_PARAMETER;
} /* DirIterateSiteLinkBridges */


DWORD
DirReadSiteLinkBridge(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPWSTR SiteLinkBridgeName,
    LPWSTR *pSiteLinkList
    )

/*++

Routine Description:

NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! NOT USED! 

Return information on the named site link bridge

Site link bridges are only when read the transport option is set such that
bridges are required. This is not the default. Thus this routine is never
called unless specifically requested by the user.  

Arguments:

    pTransport - 
    ConnectionHandle - 
    SiteLinkBridgeName - 
    pSiteLinkList - 

Return Value:

    DWORD - 

--*/

{
    printf( "DirReadSiteLinkBridge, transport = %ws, SiteLinkBridgeName = %ws\n",
            pTransport->Name, SiteLinkBridgeName );

    // Aaron, you can fill this in at the end if you have time

    return ERROR_INVALID_PARAMETER;

} /* DirReadSiteLinkBridge */

DWORD
DirGetSiteBridgeheadList(
    PTRANSPORT_INSTANCE pTransport,
    PVOID ConnectionHandle,
    LPCWSTR SiteDN,
    LPDWORD pNumberServers,
    LPWSTR **ppServerList
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    printf( "DirGetSiteBridgeheadList\n" );

    if ( (SiteDN == NULL) || (*SiteDN == L'\0') ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Should validate that the site is valid

    // This is the result if there are no explicit bridgeheads in the site

    *pNumberServers = 0;
    *ppServerList = NULL;
    status = ERROR_SUCCESS;

    // If there were explicit bridgheads, the would be returend as a
    // array of pointers to strings.

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\common\table.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    table.c

Abstract:

    This is a generic table module.

    It is customized by macro's by the caller to return entries of whatever size and type
    the user requires.  For example, in route.c we have:

// Use the generate table template to create a type specific table!
// Site Hash Table

#define SITE_HASH_TABLE_SIZE 107  // should be prime

typedef struct _SITE_INSTANCE {
    TABLE_ENTRY TableEntry;  // must be first
    DWORD Size;
    DWORD Index;
} SITE_INSTANCE, *PSITE_INSTANCE;

typedef PTABLE_INSTANCE PSITE_TABLE;

#define SiteTableCreate() TableCreate( SITE_HASH_TABLE_SIZE, sizeof( SITE_INSTANCE ) )
#define SiteTableFree( table ) TableFree( (PTABLE_INSTANCE) table )
#define SiteTableFindCreate( table, name, create ) \
(PSITE_INSTANCE) TableFindCreateEntry( (PTABLE_INSTANCE) table, name, create )

The core structure must be embedded in the user's datatype at the start.

TODO: Deletion of entries, locking, and reference counting
For deletion, switch to using doubly linked list macros

Author:

    Will Lees (wlees) 08-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

#include <winsock.h>
#include <ntdsapi.h>

#include "common.h"

#define DEBSUB "TABLE:"

// This represents a generic table.  It is self describing.
typedef struct _TABLE_INSTANCE {
    DWORD Size;
    DWORD TableSize;
    DWORD EntrySize;
    struct _TABLE_ENTRY **Table;
} TABLE_INSTANCE, *PTABLE_INSTANCE;

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 08 16:25:46 1998 */

PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    );

VOID
TableFree(
    PTABLE_INSTANCE Table
    );

PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    );

LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    );

/* End Forward */


PTABLE_INSTANCE
TableCreate(
    DWORD TableSize,
    DWORD EntrySize
    )

/*++

Routine Description:

Create a generic table.

Arguments:

    TableSize - Number of hash buckets.  Should be prime.
    EntrySize - Size of user entries.  Must embed a TABLE_ENTRY structure

Return Value:

    PTABLE_INSTANCE -

--*/

{
    DWORD i;
    PTABLE_INSTANCE table;

    if (EntrySize < sizeof( TABLE_ENTRY ) ) {
        DPRINT( 1, "table entry size is invalid\n" );
        return NULL;
    }

    table = NEW_TYPE( TABLE_INSTANCE );
    if (table == NULL) {
        // ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    table->Size = sizeof( TABLE_INSTANCE );
    table->TableSize = TableSize;
    table->EntrySize = EntrySize;

    table->Table = NEW_TYPE_ARRAY( TableSize, PTABLE_ENTRY );
    if (table->Table == NULL) {
        FREE_TYPE( table );
        return NULL;
    }

    // INITIALIZE TABLE INSTANCE HERE

    for( i = 0; i < TableSize; i++ ) {
        table->Table[i] = NULL;
    }

    return table;
} /* TableCreate */


VOID
TableFree(
    PTABLE_INSTANCE Table
    )

/*++

Routine Description:

Free a generic table

CODE.IMPROVEMENT: provide a means to deallocate dynamic data in user section of the entry

Arguments:

    Table -

Return Value:

    None

--*/

{
    DWORD i;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return;
    }

    // Cleanup hash table
    for( i = 0; i < Table->TableSize; i++ ) {
        PTABLE_ENTRY current, next;

        current = Table->Table[i];
        while (current != NULL) {
            next = current->Next;

            FREE_TYPE( current->Name );
            current->Name = NULL;
            FREE_TYPE( current ); // destroys the users entry, EntrySize bytes worth

            current = next;
        }
    }
    FREE_TYPE( Table->Table );
    Table->Table = NULL;

    FREE_TYPE( Table );
} /* TableFree */


PTABLE_ENTRY
TableFindCreateEntry(
    PTABLE_INSTANCE Table,
    LPCWSTR EntryName,
    BOOLEAN Create
    )

/*++

Routine Description:

This routine stores an in the hash table.

Data structure is a hash table to a sorted single linked list by name

Arguments:

    Table - Hash table to work on
    EntryName - Name in DN form
    Create - flag to indicate wether to create if not found

Return Value:

    Success: created or found PTABLE_ENTRY
    Error: NULL.

Remarks:
    - Assumes EntryName is in DN form.
--*/

{
    DWORD hash, length;
    PWCHAR p;
    LPWSTR pCanonicalName = NULL;
    PTABLE_ENTRY current, new, previous;
    int result;
    DWORD err;

    if (Table->Size != sizeof( TABLE_INSTANCE ) ) {
        DPRINT( 1, "table is invalid\n" );
        return NULL;
    }

    pCanonicalName = GetCanonicalDN( EntryName );

    if ( !pCanonicalName ) {
        DPRINT(1, "Error: Failed to generate canonical name\n");
        return NULL;
    }

    hash = 0;
    for( p = (LPWSTR) pCanonicalName; *p != L'\0'; p++ ) {
        hash += *p;
    }
    hash %= Table->TableSize;

    previous = NULL;
    current = Table->Table[hash];
    while (current != NULL) {
        result = _wcsicmp( pCanonicalName, current->Name );
        if (result == 0) {
            goto cleanup;
        } else if (result == 1) {
            break;
        }
        previous = current;
        current = current->Next;
    }

    // If we are not allowed to create it, exit at this point

    if (!Create) {
        current = NULL;
        goto cleanup;
    }

    // Create new entry

    new = (PTABLE_ENTRY) NEW_TYPE_ARRAY_ZERO( Table->EntrySize, CHAR );
    if (new == NULL) {
        current = NULL;
        goto cleanup;
    }

    // INITIALIZE TABLE ENTRY HERE

    length = wcslen( pCanonicalName ) + 1;  // in wchars inc terminator
    new->Name = NEW_TYPE_ARRAY( length, WCHAR );
    if (NULL == new->Name) {
        FREE_TYPE(new);
        current = NULL;
        goto cleanup;
    }

    wcscpy( new->Name, pCanonicalName );

    // INITIALIZE TABLE ENTRY HERE

    new->Next = current;

    if (previous == NULL) {
        Table->Table[hash] = new;
    } else {
        previous->Next = new;
    }

    current = new;

cleanup:
    if (pCanonicalName) {
        FREE_TYPE(pCanonicalName);
    }
    return current;
} /* TableFindCreateEntry */


LPWSTR
GetCanonicalDN(
    IN      LPCWCH      pDN
    )
/*++

Routine Description:

    Convert a DN into canonical form (see DsUnquoteRdnValueW for details).


    Various clients use different name forms resulting w/ misses when searched
    for in the hash table. For example, two name forms of interest are as follows:

    A) Backslash form (typically an ldap client will get this form)
        CN=site3\<0xA>CNF:d565bc93-293c-46d8-8831-69c345b30f7d,CN=Sites...

    B) Quoted form (typically core generated dsname format)
        CN="site3<0xA>CNF:d565bc93-293c-46d88831-69c345b30f7d",CN=Sites...

    To overcome this problem, all names are converted to the unquoted/unescaped
    form (we'll call it canonical) in this function.


Arguments:

    pDN - name to compute value for.

Return Value:

    success: name in canonical form.
    error: NULL.

Remarks:
    On success, returned name is allocated. Caller is responsible to
    free using FREE_TYPE().

--*/
{

    DWORD cDN, cKey, cVal, cRdn;
    LPCWCH pVal, pKey, pTmpDN = pDN;
    LPWCH pRdn = NULL;
    LPWCH pName = NULL, pCurName=NULL;
    DWORD err = ERROR_SUCCESS;
    DWORD len = 0, curlen = 0;


    // param sanity
    if (!pDN){
        // when would we ever try to hash an empty name?
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    //
    // Convert to canonical form:
    // a) calc required mem & alloc
    // b) cycle, apply DsUnquoteRdnValueW & copy
    //

    //
    // calc required memory
    //

    // first string length
    curlen = cDN = wcslen(pDN);
    if (!cDN) {
        DPRINT(1, "Error: invalid DN\n");
        return NULL;
    }

    // now cycle rdns.
    while (cDN) {
        err = DsGetRdnW( &pTmpDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        len += cKey + cVal + 2;         // 2 addt'l for '=' & ','
    }

    // allocate memory (+ term char)
    pCurName = pName = NEW_TYPE_ARRAY_ZERO( len + 1, WCHAR );
    if (!pName) {
        DPRINT(1, "Error: not enough memory\n");
        return NULL;
    }

    // restore cDN (note that pDN wasn't touched, only pTmpDN)
    cDN = curlen;
    curlen = 0;


    while (cDN) {
        //
        // Cycle & re-create DN in unquoted form
        //

        err = DsGetRdnW( &pDN, &cDN, &pKey, &cKey, &pVal, &cVal);
        if (err != ERROR_SUCCESS) {
            goto cleanup;
        }
        //
        // create formatted rdn
        //
        if (cKey) {
            // copy key (ie "CN" etc)
            wcsncpy(pCurName, pKey, cKey);
            curlen += cKey;
            // add '='
            pName[curlen++] = '=';
            pCurName = &pName[curlen];
        }
        if (cVal) {
            // copy value
            cRdn = len - curlen;
            err = DsUnquoteRdnValueW(cVal, pVal, &cRdn, pCurName);
            if (err) {
                goto cleanup;
            }
            Assert(cRdn);

            curlen += cRdn;
            pName[curlen++] = ',';
            pCurName = &pName[curlen];
        }
    }

    // terminate name excluding (overwriting) last ','
    Assert(curlen > 1 && pName[curlen-1] == ',');
    pName[curlen-1] = '\0';

    Assert(err == ERROR_SUCCESS);

cleanup:

    if (err) {
        if (pName) {
            FREE_TYPE(pName);
            pName = NULL;
        }
    }

    return pName;
}


/* end table.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\ip\private.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    private.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 15-Dec-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _PRIVATE_
#define _PRIVATE_

#include "common.h"         // common transport library

// This is a server-side structure describing a message recipient.  There is
// one of these instances for each unique service which as received a message.

typedef struct _SERVICE_INSTANCE {
    DWORD Size;
    LPWSTR Name;
    DWORD ByteCount;
    DWORD MessageCount;
    CRITICAL_SECTION Lock;
    LIST_ENTRY MessageListHead;
    LIST_ENTRY ServiceListEntry;
} SERVICE_INSTANCE, *PSERVICE_INSTANCE;

// This is a message descriptor.  It is to allow us to keep track of the
// queue of messages.  It points to the actual message which is allocated
// by rpc.

typedef struct _MESSAGE_INSTANCE {
    DWORD Size;
    LIST_ENTRY ListEntry;
    PISM_MSG pIsmMsg;
} MESSAGE_INSTANCE, *PMESSAGE_INSTANCE;

// Limit on number of queued messages per service

#define MESSAGES_QUEUED_PER_SERVICE 16

// Limit on total number of bytes queued

#define BYTES_QUEUED_PER_SERVICE (1024 * 1024)

// Registry parameter to overide to default endpoint
#define IP_SERVER_ENDPOINT "ISM IP Transport Endpoint"
#define HTTP_SERVER_ENDPOINT "ISM HTTP Transport Endpoint"

// RPC protocol sequences

#define HTTP_PROTOCOL_SEQUENCE L"ncacn_http"
#define UDP_PROTOCOL_SEQUENCE L"ncadg_ip_udp"
#define TCP_PROTOCOL_SEQUENCE L"ncacn_ip_tcp"

// Register parameter for options
#define HTTP_OPTIONS L"ISM HTTP Transport Options"

// Size cutoff of when to switch from udp to tcp

#define TCP_PROTOCOL_SWITCH_OVER (16 * 1024)

// External (see data.c)

// Lock on services list
extern CRITICAL_SECTION ServiceListLock;

// ismip.c

DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    );

PTRANSPORT_INSTANCE
IpLookupTransport(
    LPCWSTR TransportName
    );

// dgrpc.c

DWORD
IpRegisterRpc(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
IpUnregisterRpc(
    PTRANSPORT_INSTANCE pTransport
    );

DWORD
IpSend(
    PTRANSPORT_INSTANCE pTransport,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IpFindCreateService(
    PTRANSPORT_INSTANCE pTransport,
    LPCWSTR ServiceName,
    BOOLEAN Create,
    PSERVICE_INSTANCE *pService
    );

PISM_MSG
IpDequeueMessage(
    PSERVICE_INSTANCE Service
    );

VOID
IpRundownServiceList(
    HANDLE hIsm
    );

#endif /* _PRIVATE_ */

/* end private.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\ip\ismip.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ismip.c

Abstract:

   This module is a plug-in DLL for the Inter-Site Messaging service, which is part of
   the mail-based replication subsystem in the Directory Service.

   This DLL, as is any instance of the ISM plug-in DLL class, provides a set of abstract
   transport functions, such as send, receive, and so on.  See plugin.h for details.

   This implementation is based on sockets, using the TCP protocol.  This is used for testing.
   A true implementation would not require the server to be up at the time of send.

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    User-mode, win32 dll
    To be loaded by another image

Notes:

    optional-notes

Revision History:


--*/

#define UNICODE 1

#include <ntdspch.h>

#include <rpc.h>
#include <rpcndr.h>   // midl_user_free
#include <ismapi.h>
#include <debug.h>
#include <fileno.h>
#include <drs.h>     // DSTIME
#include <ntdsa.h>   // Option flags

// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include <dsevent.h>

#include "private.h"

// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

#define DEBSUB "ISMIP:"
#define FILENO FILENO_ISMSERV_ISMIP

// Set this non-zero to display debug messages
#define UNIT_TEST_DEBUG 0

/* External */

// Event logging config (as exported from ismserv.exe).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

/* Static */

// Lock on instances list
CRITICAL_SECTION TransportListLock;

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Nov 04 09:54:07 1998 */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     );

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    );

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    );

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    );

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    );

void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    );

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    );

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    );

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    );

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    );

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    );

/* End Forward */


DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    )

/*++

Routine Description:

Wrapper function to handle exception handling in the
InitializeCriticalSection() function.

Arguments:

    pcsCriticalSection - pointer to critical section

Return Value:

    DWORD - status code

--*/

{
    DWORD status;

    __try {
        InitializeCriticalSection( pcsCriticalSection );
        status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    return status;
} /* initializeCriticalSectionHelper */

WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.
--*/
{
    DWORD status;
    BOOL  fReturn = TRUE;
    LPSTR rgpszDebugParams[] = {"lsass.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {
        // DO QUICK STUFF HERE - DO THE REST IN STARTUP/FIRSTTIME
        // Initialize debug library.
        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ismip");

        // Get event logging config (as exported from ismserv.exe).
        gpDsEventConfig = DsGetEventConfig();

#if DBG
#if UNIT_TEST_DEBUG
        DebugInfo.severity = 1;
        strcpy( DebugInfo.DebSubSystems, "ISMIP:IPDGRPC:" ); 
//        DebugInfo.severity = 3;
//        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif
        DebugMemoryInitialize();
#endif
        
        if (ERROR_SUCCESS != InitializeCriticalSectionHelper( &TransportListLock )) {
            fReturn = FALSE;
            goto exit;
        }
        InitializeListHead( &TransportListHead );
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // Make sure all threads stopped
        // Empty address list
        DeleteCriticalSection( &TransportListLock );
        if (!IsListEmpty( &TransportListHead )) {
            DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
        }
#if DBG
        DebugMemoryTerminate();
#endif
        DEBUGTERM();
        break;
    }
    default:
        break;
    }   /* switch */

exit:
    return ( fReturn);
}  /* DllLibMain() */

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    )
/*++

Routine Description:

    Initialize the plug-in.

Arguments:

    pszTransportDN (IN) - The DN of the Inter-Site-Transport that named this
        DLL as its plug-in.  The DS object may contain additional configuration
        information for the transport (e.g., the name of an SMTP server for
        an SMTP transport).

    pNotifyFunction (IN) - Function to call to notify the ISM service of pending
        messages.

    hNotify (IN) - Parameter to supply to the notify function.

    phIsm (OUT) - On successful return, holds a handle to be used in
        future calls to the plug-in for the named Inter-Site-Transport.  Note
        that it is possible for more than one Inter-Site-Transport object to
        name a given DLL as its plug-in, in which case IsmStartup() will be
        called for each such object.

Return Values:

    NO_ERROR - Successfully initialized.

    other - Failure.
        
--*/
{
    DWORD length;
    PTRANSPORT_INSTANCE instance;
    DWORD status;
    BOOLEAN firsttime;
    BOOLEAN fNotifyInit = FALSE;

    DPRINT1( 1, "IsmStartup, transport='%ws'\n", pszTransportDN );

    // Check validity of arguments

    if (phIsm == NULL) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    length = wcslen( pszTransportDN );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Restrict to only one transport instance.
    EnterCriticalSection(&TransportListLock);
    __try {
        firsttime = IsListEmpty( &(TransportListHead) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }
    if (!firsttime) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        return status;
    }

    // INITIALIZE TRANSPORT INSTANCE HERE
    // All values initially zero

    instance->Size = sizeof( TRANSPORT_INSTANCE );
    Assert( instance->ReferenceCount == 0 );
    instance->pNotifyFunction = pNotifyFunction;
    instance->hNotify = hNotify;
    InitializeListHead( &(instance->ServiceListHead) );
    status = InitializeCriticalSectionHelper( &(instance->Lock) );
    if (ERROR_SUCCESS != status) {
        goto cleanup;
    }
    // ReplInterval is 0, meaning the application should take default
    // Default is schedules significant, bridges not required (transitive)
    instance->Options = 0;

    // INITIALIZE TRANSPORT INSTANCE HERE

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }
    wcscpy( instance->Name, pszTransportDN );

    // ***********************************************************************

    // Create event to signal shutdown.
    instance->hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == instance->hShutdownEvent) {
        status = GetLastError();
        DPRINT1(0, "Failed to create shutdown event, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    // Open connection to directory service
    status = DirOpenConnection( &instance->DirectoryConnection );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Start monitoring for routing changes
    status = DirStartNotifyThread( instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }
    fNotifyInit = TRUE;

    // Insert this instance into the list.
    
    // Note that, assuming the ISM service is functioning correctly, this list
    // cannot contain duplicates (where "duplicate" is defined as an entry with
    // the same DN).
    
    EnterCriticalSection(&TransportListLock);
    __try {
        InsertTailList( &TransportListHead, &(instance->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    InterlockedIncrement( &(instance->ReferenceCount) );  // 1 for the lifetime of this transport

    *phIsm = instance;

    return ERROR_SUCCESS;

cleanup:
    instance->fShutdownInProgress = TRUE;

    if (fNotifyInit) {
        (void) DirEndNotifyThread( instance );
    }

    if (instance->DirectoryConnection) {
        (void) DirCloseConnection( instance->DirectoryConnection );
    }

    if (instance->hShutdownEvent != NULL) {
        CloseHandle( instance->hShutdownEvent );
    }

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }

    Assert( instance->ReferenceCount == 0 );
    FREE_TYPE(instance);

    return status;
}

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    )
/*++

Routine Description:

    Called whenever changes occur to the Inter-Site-Transport object specified
    in the IsmStartup() call.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    eReason (IN) - Reason code for refresh

    pszObjectDN (IN) - DN of the Inter-Site-Transport object.  This is
        guaranteed to be the same as the DN passed in IsmStartup, as inter-site
        transport objects cannot be renamed.

Return Values:

    0 or Win32 error code.
    
--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status, oldOptions, oldReplInterval;

    DPRINT2( 1, "IsmRefresh, reason = %d, new name = %ws\n",
             eReason,
             pszObjectDN ? pszObjectDN : L"not supplied" );

    if (instance->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( (eReason == ISM_REFRESH_REASON_RESERVED) ||
         (eReason >= ISM_REFRESH_REASON_MAX) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // If a site changed in any way, just invalidate the cache

    if (eReason == ISM_REFRESH_REASON_SITE) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( eReason == ISM_REFRESH_REASON_TRANSPORT );

    // Inter-site transport objects cannot be renamed.
    Assert((pszObjectDN == NULL)
           || (0 == _wcsicmp(pszObjectDN, instance->Name)));

    oldOptions = instance->Options;
    oldReplInterval = instance->ReplInterval;

    // Reread parameters from the registry 
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( ( oldOptions != instance->Options) ||
         ( oldReplInterval != instance->ReplInterval ) ) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
    }

cleanup:

    return status;
}

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    )
/*++

Routine Description:

    Uninitialize transport plug-in.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().
    eReason (IN) - Reason for shutdown

Return Values:

    None.

--*/
{
    DWORD status;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    BOOL fFailed;
    LONG count;

    DPRINT2( 1, "IsmShutdown %ws, Reason %d\n", transport->Name, eReason );

    // Validate
    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        return;
    }
    transport->fShutdownInProgress = TRUE;

    SetEvent(transport->hShutdownEvent);

    // Remove this instance from the list.
    EnterCriticalSection(&TransportListLock);
    __try {
        RemoveEntryList( &(transport->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    DeleteCriticalSection( &(transport->Lock) );

    DirEndNotifyThread( transport );

    count = InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for the lifetime of this transport
    if (count == 0) {
        // Clean up only if thread is finished

        // Release any routing state
        RouteFreeState( transport );

        // Close connection to directory
        status = DirCloseConnection( transport->DirectoryConnection );
        // ignore error

        CloseHandle( transport->hShutdownEvent );
        transport->hShutdownEvent = NULL;

        // RUNDOWN TRANSPORT INSTANCE HERE

        transport->Size = 0; // clear signature to prevent reuse
        FREE_TYPE( transport->Name );
        FREE_TYPE( transport );

        // RUNDOWN TRANSPORT INSTANCE HERE
    } else {
        DPRINT2( 0, "Transport %ws not completely shutdown, %d references still exist.\n",
                 transport->Name, count );
    }
}

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Send a message over this transport.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszRemoteTransportAddress (IN) - Transport address of the destination
        server.

    pszServiceName (IN) - Name of the service on the remote machine that is the
        intended receiver of the message.

Return Values:

    0 or Win32 error.

--*/
{
    // The IP transport does not support send/receive.
    return ERROR_NOT_SUPPORTED;
}

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Return the next waiting message (if any).  If no message is waiting, a NULL
    message is returned.  If a non-NULL message is returned, the ISM service
    is responsible for calling IsmFreeMsg(*ppMsg) when the message is no longer
    needed.

    If a non-NULL message is returned, it is immediately dequeued.  (I.e., once
    a message is returned through IsmReceive(), the transport is free to destroy
    it.)

This routine is pretty simple.  It finds the service, and dequeues a message if there is any.
Queue the message is done by the listener thread behind the scenes.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    0 or Win32 error.

--*/
{
    // The IP transport does not support send/receive.
    // Return "no message waiting."
    *ppMsg = NULL;
    return 0;
}


void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Frees a message returned by IsmReceive().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pMsg (IN) - Message to free.

Return Values:

    None.

--*/
{
    // The IP transport does not support send/receive.
    ;
}

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites.

    On successful return, the ISM service will eventually call
    IsmFreeConnectivity(hIsm, *ppConnectivity);

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

There is no time-based caching of this information.  Each time this routine is called, the
information is regnerated.  GetConnectionSchedule api uses the matrix of schedules from the
last time this call was made, regardless of time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along this transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, numberSites, i;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;

    DPRINT( 2, "IsmGetConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }


    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {

        // Get the site list and connectivity matrix

        status = RouteGetConnectivity( transport, &numberSites, &pSiteList,
                                       &pLinkArray, transport->Options,
                                       transport->ReplInterval );

        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "failed to get connectivity, error %d\n", status );
            __leave;
        }

        // Return null structure to indicate no sites
        if (numberSites == 0) {
            ppConnectivity = NULL; // No connectivity
            status = ERROR_SUCCESS;
            __leave;
        }

        Assert( pLinkArray );
        Assert( pSiteList );

        // Build a connectivity structure to return

        pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
        if (pConnectivity == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );

            // Cleanup the pieces
            DirFreeSiteList( numberSites, pSiteList );
            RouteFreeLinkArray( transport, pLinkArray );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pConnectivity->cNumSites = numberSites;
        pConnectivity->ppSiteDNs = pSiteList;
        pConnectivity->pLinkValues = pLinkArray;
        *ppConnectivity = pConnectivity;

        status = ERROR_SUCCESS;
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    return status;
}

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    )
/*++

Routine Description:

    Frees the structure returned by IsmGetConnectivity().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSiteConnectivity (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    DPRINT( 2, "IsmFreeConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pConnectivity == NULL) {
        return;
    }

    // Free individual components

    if (pConnectivity->cNumSites > 0) {
        DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

        RouteFreeLinkArray( transport, pConnectivity->pLinkValues );
    }

    FREE_TYPE( pConnectivity );
}

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via this transport.

    On successful return of a non-NULL list, the ISM service will eventually call
    IsmFreeTransportServers(hIsm, *ppServerList);

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;

    DPRINT1( 2, "IsmGetTransportServers, site = %ws\n", pszSiteDN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Get the server list

        status = DirGetSiteBridgeheadList( transport, transport->DirectoryConnection,
                                           pszSiteDN, &numberServers, &serverList );
        if (status != ERROR_SUCCESS) {

            if (status == ERROR_FILE_NOT_FOUND) {
                *ppServerList = NULL; // All servers
                status = ERROR_SUCCESS;
                __leave;
            }

            DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
            __leave;
        }

        // Return null structure to indicate no servers
        if (numberServers == 0) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            __leave;
        }

        // Construct the server structure

        pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
        if (pIsmServerList == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

            // Clean up the pieces
            for( i = 0; i < numberServers; i++ ) {
                FREE_TYPE( serverList[i] );
            }
            FREE_TYPE( serverList );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pIsmServerList->cNumServers = numberServers;
        pIsmServerList->ppServerDNs = serverList;

        *ppServerList = pIsmServerList;

        status = ERROR_SUCCESS;
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    return status;
}

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pServerList (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    DPRINT( 2, "IsmFreeTransportServers\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pServerList == NULL) {
        return;
    }

    // Free individual components

    if ( (pServerList->cNumServers != 0) && (pServerList->ppServerDNs != NULL) ) {
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            FREE_TYPE( pServerList->ppServerDNs[i] );
        }
        FREE_TYPE( pServerList->ppServerDNs );
    }

    FREE_TYPE( pServerList );
}

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    )

/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via this
    transport.

    On successful return, it is the ISM service's responsibility to eventually
    call IsmFreeSchedule(*ppSchedule);

The transport has associated with it some lingering state.  The matrix of schedules is not
freed at the end of this routine.  It remains, tied to the transport handle, for the benefit
of the GetConnectionSchedule api.

There is no time-based caching of this information.  Each time the get conn routine is called, the
information is regnerated.  GetConnectionSchedule api uses the matrix of schedules from the
last time this call was made, regardless of time.

The actual semantics of this routine are that it returns a non-default schedule
if there is one.  Otherwise, it returns the default, all available schedule.
If you desire to know if there is a path between the two sites, consult the
cost matrix first. It is a feature of this routine that inquiring a schedule
for a non-connected pair of sites will return NULL for all available.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PBYTE pSchedule;

    DPRINT2( 2, "IsmGetConnectionSchedule, site1 = %ws, site2 = %ws\n",
            pszSite1DN, pszSite2DN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return ERROR_INVALID_PARAMETER;
    }

    status = RouteGetPathSchedule( transport,
                                   pszSite1DN,
                                   pszSite2DN,
                                   &pSchedule,
                                   &length );
    if (status != ERROR_SUCCESS) {
        return status;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        if (*ppSchedule == NULL) {
            FREE_TYPE( pSchedule );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

    return ERROR_SUCCESS;
}

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSchedule (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    DPRINT( 2, "IsmFreeConnectionSchedule\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        return; // error: invalid parameter
    }

    if (pSchedule == NULL) {
        return;
    }

    Assert( pSchedule->cbSchedule != 0 );
    Assert( pSchedule->pbSchedule );

    FREE_TYPE( pSchedule->pbSchedule );

    pSchedule->pbSchedule = NULL;
    pSchedule->cbSchedule = 0;

    FREE_TYPE( pSchedule );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\adsisupp.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    adsisupp.cxx

Abstract:

    ADSI support routines

    This package contains general ADSI helper routines, as well as routines to
    query and manipulate data in the metabase for particular services.

    ADSI is a general COM interface to any kind of hierarchical data store.
    Many components in the system register themselves as providers to the asdi
    namespace, and thus become managable through it.  We are managing the
    Smtpservice in the way.

    You can view the structure of the namespace using adsvw.

    The structure of the smtp service is:

    IIS:/LocalHost/SMTPSVC/
        1/ (class IIsSmtpServer)
            .
            .
            Domain (class Container)
                <your domain here> (Class IIsSmtpDomain)

        Info/ (class IIsSmtpInfo)

    There are many interesting properties on the server and domain objects that
    may prove useful in the future.

    The routines here include:
        Determine if a given Smtp mail routing domain is present
        Create a smtp mail routing domain

Author:

    Will Lees (wlees) 07-Oct-1998

Environment:

Notes:

Revision History:

--*/

#define INC_OLE2

#include <ntdspchx.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ADSISUPP

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

#define DEBSUB "ADSISUPP:"

#include <activeds.h>

/* External */

/* Static */
static LPWSTR EmptyClassList[] = { NULL };

#define ADS_DOMAIN_PATH L"IIS://LocalHost/SMTPSVC/1/Domain"
#define ADS_DOMAIN_PATH_LENGTH (ARRAY_SIZE(DROP_DIRECTORY))

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Apr 26 09:46:36 1999 */

HRESULT
AddSmtpDomainIfNeeded(
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT __cdecl
domainCallback(
    PVOID pObjectOpaque,
    PVOID Context1,
    PVOID Context2
    );

HRESULT
addSmtpDomain(
    LPWSTR AdsPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT
ModifySmtpDomainIfNeeded(
    LPWSTR AdsContainerPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    );

HRESULT
EnumObject(
    LPWSTR pszADsPath,
    LPWSTR * lppClassNames,
    DWORD dwClassNames,
    ENUM_CALLBACK_FN *pCallback,
    PVOID Context1,
    PVOID Context2
    );

HRESULT
getSmtpServerProperties(
    LPWSTR AdsPath,
    BSTR *pbstrDropDirectory
    );

HRESULT
getPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR *pbstrValue
    );

HRESULT
putPropInteger(
    IADs *pObject,
    LPWSTR PropertyName,
    DWORD Value
    );

HRESULT
putPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR bstrValue
    );

/* End Forward */


HRESULT
CheckSmtpDomainContainerPresent(
    void
    )

/*++

Routine Description:

Check whether the Smtp Domain Container can be opened

Arguments:

    void - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL;
    IADsContainer * pADsContainer =  NULL;

    // Get the domain container
    hr = ADsGetObject(
        ADS_DOMAIN_PATH,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        goto cleanup;
    }

    // Just checking

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }

    return hr;
} /* CheckSmtpDomainContainerPresent */


HRESULT
removeSmtpDomainHelper(
    LPWSTR AdsPath,
    LPWSTR DomainName
    )

/*++

Routine Description:

    Remove the given smtp domain

Arguments:

    AdsPath - 
    DomainName - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    IADs * pADsObject =  NULL;

    // Get the domain container
    hr = ADsGetObject(
        AdsPath,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                          szInsertWC(AdsPath),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

    hr = pADsContainer->Delete( L"IIsSmtpDomain", DomainName );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsContainer->Delete(%ws) failed with error 0x%x\n",
                DomainName, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_DELETE_OBJECT_FAILURE,
                          szInsertWC(DomainName),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

    hr = pADsContainer->QueryInterface(IID_IADs, (VOID **) &pADsObject) ;
    if (FAILED(hr)) {
        DPRINT1( 0, "QueryInterface failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Commit the deletion to the store
    hr = pADsObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT2(0,"ADsObject->SetInfo(%ws) failed with error 0x%x\n",
                DomainName, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_SET_INFO_FAILURE,
                          szInsertWC(DomainName),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }
    if (pADsObject) {
        pADsObject->Release();
    }

    return hr;

} /* removeSmtpDomainHelp */


HRESULT
RemoveSmtpDomain(
    LPWSTR DomainName
    )

/*++

Routine Description:

    Remove the given smtp domain

Arguments:

    DomainName - 

Return Value:

    HRESULT - 

--*/

{
    return removeSmtpDomainHelper( ADS_DOMAIN_PATH, DomainName );
}


HRESULT
AddSmtpDomainIfNeeded(
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Check for the given Smtp Domain in the Smtp Service metabase, and create one
if not present.

Note, this routine uses the first virtual Smtp Server.  In the future we may
need a way to specify the preferred virtual server

Arguments:

    DomainName - usually a dns name of this computer, the RHS of a mail addr

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    LPWSTR classList[] = { L"IIsSmtpDomain" };
    BOOL fDomainFound = FALSE;

    // Note: we search only the first Virtual Smtp Server

    // Enumerate the domain container, looking for IIsSmtpDomain objects

    hr = EnumObject( ADS_DOMAIN_PATH,
                     classList,
                     1,
                     domainCallback,
                     DomainName,
                     &fDomainFound
                     );
    if (FAILED(hr)) {
        DPRINT2( 0, "EnumObject(%ws) failed, error 0x%x\n",
                 ADS_DOMAIN_PATH, hr );
        // Error already logged
        goto cleanup;
    }

    // If it was found, we need to check that it is correct
    if (fDomainFound) {
        DPRINT1( 1, "SMTP Domain %ws is already present.\n", DomainName );
        hr = ModifySmtpDomainIfNeeded( ADS_DOMAIN_PATH, DomainName, bstrDropDirectory );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to modify Smtp Domain, error 0x%x\n", hr );
            // Error already logged
        }
        goto cleanup;
    }

    // Add the new domain
    hr = addSmtpDomain( ADS_DOMAIN_PATH, DomainName, bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to add Smtp Domain, error 0x%x\n", hr );
        // Error already logged
        goto cleanup;
    }

    hr = S_OK;
cleanup:
   return hr;
} /* AddSmtpDomainIfNeeded */


HRESULT __cdecl
domainCallback(
    PVOID pObjectOpaque,
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

This is a call back routine for the EnumObject function.
This routine is expected to be called back for SmtpDomain objects.  It
compares the passed in objects with the given domain name, and sets the
out parameter boolean true when they match

Arguments:

    pObjectOpaque - a pointer to a IADS * object for a smtp domain
    Context1 - lpwstr domain name
    Context2 - lpbool found, set true if a match occurs

Return Value:

    HRESULT __cdecl - 

--*/

{
    HRESULT hr;
    BSTR bstrName = NULL;
    IADs *pObject = (IADs *) pObjectOpaque;
    LPWSTR DomainName = (LPWSTR) Context1;
    LPBOOL pfDomainFound = (LPBOOL) Context2;

    // Get the object name
    hr = pObject->get_Name(&bstrName) ;
    if (FAILED(hr)) {
        DPRINT1(0,"get_Name failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Does it match?
    if (_wcsicmp(DomainName,bstrName) == 0) {
        *pfDomainFound = TRUE;
        hr = S_FALSE; // terminate enumeration with success
    }

cleanup:

    if (bstrName) {
        SysFreeString(bstrName);
    }

    return hr;
} /* domainCallback */


HRESULT
addSmtpDomain(
    LPWSTR AdsPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Add a Smtp Domain to the given domain container.
The domain is added as type "1".
We default everything else for now.

Arguments:

    AdsPath - 
    DomainName - 
    bstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    BSTR bstrClass = NULL, bstrName = NULL;
    IDispatch *pDispatch = NULL;
    IADs *pObject = NULL;

    // Get the domain container
    hr = ADsGetObject(
        AdsPath,
        IID_IADsContainer,
        (void **)&pADsContainer
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                          szInsertWC(AdsPath),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

    // build a class string
    bstrClass = SysAllocString( L"IIsSmtpDomain" );
    if (bstrClass == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // build a new object name string
    bstrName = SysAllocString( DomainName );
    if (bstrName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Invoke the create method on the container object to create the new
    // object of default class, in this case, IIsSmtpDomain.

    hr = pADsContainer->Create(
        bstrClass,
        bstrName,
        &pDispatch
        );
    if (FAILED(hr)) {
        DPRINT1(0,"ADsContainer::Crate failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }
    
    // Get the newly created object
    hr = pDispatch->QueryInterface(
        IID_IADs,
        (VOID **) &pObject
        );
    if (FAILED(hr)) {
        DPRINT1(0,"QueryInterface failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write properties here if needed
    // 0x1 is the value Mike Swafford (mikeswa) said to put here.
    hr = putPropInteger( pObject, L"RouteAction", 1 );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropInteger failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = putPropBstr( pObject, L"RouteActionString", bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write the object to persistent store
    hr = pObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT1(0,"SetInfo failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT3( 1, "Added SMTP Domain %ws (drop dir %ws) to %ws\n",
             DomainName, bstrDropDirectory, AdsPath );
    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_DOMAIN_ADD,
              szInsertWC(AdsPath),
              szInsertWC(DomainName),
              szInsertWC(bstrDropDirectory),
              NULL, NULL, NULL, NULL, NULL);

cleanup:
    if (pADsContainer) {
        pADsContainer->Release();
    }
    if (pDispatch) {
        pDispatch->Release();
    }
    if (pObject) {
        pObject->Release();
    }

    if (bstrClass) {
        SysFreeString( bstrClass );
    }
    if (bstrName) {
        SysFreeString( bstrName );
    }

    return hr;
} /* addSmtpDomain */


HRESULT
ModifySmtpDomainIfNeeded(
    LPWSTR AdsContainerPath,
    LPWSTR DomainName,
    BSTR bstrDropDirectory
    )

/*++

Routine Description:

Make sure the drop directory is correct on the existing smtp domain

Arguments:

    AdsPath - 
    DomainName - 
    bstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL;
    LPWSTR pwzDomainObjectPath = NULL;
    BSTR bstrOldDropDirectory = NULL;

    pwzDomainObjectPath = NEW_TYPE_ARRAY(
        (wcslen( AdsContainerPath ) + 1 + wcslen( DomainName ) + 1), WCHAR );
    if (pwzDomainObjectPath == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"Can't allocate domain path, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }
    wcscpy( pwzDomainObjectPath, AdsContainerPath );
    wcscat( pwzDomainObjectPath, L"/" );
    wcscat( pwzDomainObjectPath, DomainName );

    // Get the domain container
    hr = ADsGetObject(
        pwzDomainObjectPath,
        IID_IADs,
        (void **)&pObject
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                pwzDomainObjectPath, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                          szInsertWC(pwzDomainObjectPath),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

    hr = getPropBstr( pObject, L"RouteActionString", &bstrOldDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"getPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // See if the value needs to be changed
    if (_wcsicmp( bstrOldDropDirectory, bstrDropDirectory ) == 0) {
        hr = S_OK;
        goto cleanup;
    }

    // Write properties here if needed
    // 0x1 is the value Mike Swafford (mikeswa) said to put here.
    hr = putPropInteger( pObject, L"RouteAction", 1 );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropInteger failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = putPropBstr( pObject, L"RouteActionString", bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"putPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Write the object to persistent store
    hr = pObject->SetInfo();
    if (FAILED(hr)) {
        DPRINT1(0,"SetInfo failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT2( 1, "Modified object %ws with drop dir %ws\n",
             pwzDomainObjectPath, bstrDropDirectory );
    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_DOMAIN_ADD,
              szInsertWC(AdsContainerPath),
              szInsertWC(DomainName),
              szInsertWC(bstrDropDirectory),
              NULL, NULL, NULL, NULL, NULL);

cleanup:
    if (pwzDomainObjectPath != NULL) {
        FREE_TYPE( pwzDomainObjectPath );
    }
    if (pObject) {
        pObject->Release();
    }
    if (bstrOldDropDirectory) {
        SysFreeString( bstrOldDropDirectory );
    }


    return hr;
} /* addSmtpDomain */


HRESULT
EnumObject(
    LPWSTR pszADsPath,
    LPWSTR * lppClassNames,
    DWORD dwClassNames,
    ENUM_CALLBACK_FN *pCallback,
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

Enumerates the contents of a container object.
Calls a callback on each object found.
Filters objects returned if requested.

This routine is taken from
mssdk\samples\netds\adsi\cpp\adscmd\enum.cxx
Enhanced for error handling, manual filtering and a callback routine.

Arguments:

    pszADsPath - string path of container in ads namespace
    lppClassNames - array of strings of classes to request
    dwClassNames - number of strings in array
    pCallback - callback function to call on each object found
    Context1 - callback argument 1
    Context2 - callback argument 2

Return Value:

    HRESULT - 

--*/

{
#define MAX_ADS_ENUM      16     // number of entries to read each time
    ULONG cElementFetched = 0L;
    IEnumVARIANT * pEnumVariant = NULL;
    VARIANT VarFilter, VariantArray[MAX_ADS_ENUM];

    HRESULT hr;
    IADsContainer * pADsContainer =  NULL;
    DWORD i = 0;
    BOOL  fContinue = TRUE, fLoopContinue;
    BOOL fFilterPutSuccessful = FALSE;
    BOOL fManualFilterNeeded = FALSE;

   VariantInit(&VarFilter);

   // Get the container object
   hr = ADsGetObject(
       pszADsPath,
       IID_IADsContainer,
       (void **)&pADsContainer
       );
    if (FAILED(hr)) {
        DPRINT2( 0, "AdsGetObject(%ws) failed, error 0x%x\n",
                 pszADsPath, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                          szInsertWC(pszADsPath),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup ;
    }

    // Build and supply the filter array
    // Not all classes support this, apparently
    if (dwClassNames) {
        hr = ADsBuildVarArrayStr(
            lppClassNames,
            dwClassNames,
            &VarFilter
            );
        if (FAILED(hr)) {
            DPRINT1( 0, "ADsBuildVarArrayStr failed, error 0x%x\n", hr );
            LogUnhandledError( hr );
            goto cleanup ;
        }

        hr = pADsContainer->put_Filter(VarFilter);
        if (hr != E_NOTIMPL) {
            if (FAILED(hr)) {
                DPRINT1( 0, "put_Filter failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                goto cleanup ;
            }
            fFilterPutSuccessful = TRUE;
        } else {
            fManualFilterNeeded = TRUE;
        }
    }

    // Build an enumerator for the container
    hr = ADsBuildEnumerator(
            pADsContainer,
            &pEnumVariant
            );
    if (FAILED(hr)) {
        DPRINT1( 0, "ADsBuildEnumerator failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup ;
    }

    // Loop while more to do
    // Note the structure of the loop: we always exit through the top.
    // The loop_cleanup section must be executed to free resources.

    while (fContinue) {

        // Zero the array of variants
        memset(VariantArray, 0, sizeof(VARIANT)*MAX_ADS_ENUM);

        // Get the next batch. Note that cElemFetched may be >0 even though
        // the routine returns S_FALSE.

        hr = ADsEnumerateNext(
                    pEnumVariant,
                    MAX_ADS_ENUM,
                    VariantArray,
                    &cElementFetched
                    );

        if (hr == S_FALSE) {
            fContinue = FALSE;
            // keep going, but this is the last time
        } else if (FAILED(hr)) {
            DPRINT1( 0, "ADsEnumerateNext failed, error 0x%x\n", hr );
            LogUnhandledError( hr );
            goto cleanup ;
        }

        // Loop through the elements found
        fLoopContinue = TRUE;
        for (i = 0; ((i < cElementFetched) && (fLoopContinue)); i++ ) {

            IDispatch *pDispatch = NULL;
            IADs *pObject = NULL ;
            BSTR bstrClass = NULL;

            // Get the pointer to the object returned

            pDispatch = VariantArray[i].pdispVal;

            hr = pDispatch->QueryInterface(IID_IADs,
                                           (VOID **) &pObject) ;
            if (FAILED(hr)) {
                DPRINT1( 0, "QueryInterface failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                fLoopContinue = FALSE;
                goto loop_cleanup ;
            }

            // Get its class name

            hr = pObject->get_Class(&bstrClass);
            if (FAILED(hr)) {
                DPRINT1( 0, "get_Class failed, error 0x%x\n", hr );
                LogUnhandledError( hr );
                fLoopContinue = FALSE;
                goto loop_cleanup ;
            }

            // If manual filtering, check class against list
            if (fManualFilterNeeded) {
                DWORD j;
                BOOL found;
                for( j = 0, found=FALSE; (j < dwClassNames) && (!found); j++ ) {
                    found = (wcscmp( bstrClass, lppClassNames[j] ) == 0);
                }
                if (!found) {
                    goto loop_cleanup;
                }
            }

            // Call the callback on this object
            hr = (*pCallback)( pObject, Context1, Context2 );
            if (FAILED(hr)) {
                DPRINT1( 0, "enumObject callback failed, error 0x%x\n", hr );
                fLoopContinue = FALSE;
            } else if (hr == S_FALSE) {
                fLoopContinue = FALSE;
                // Enumeration terminated prematurely with success
            }

        loop_cleanup:
            if (bstrClass) {
                SysFreeString(bstrClass);
            }

            if (pObject) {
                pObject->Release();
            }
            pDispatch->Release();

        } // For loop through elements found

        // Cleanup up premature loop termination
        if (!fLoopContinue) {
            for (; (i < cElementFetched); i++ ) {
                IDispatch *pDispatch = NULL;

                pDispatch = VariantArray[i].pdispVal;
                pDispatch->Release();
            }
            // Abort containing loop
            fContinue = FALSE;
        }

    } // while (fContinue)

    // hr set above and passed through

cleanup:

    if (pEnumVariant) {
        pEnumVariant->Release();
    }

    if (!fFilterPutSuccessful) {
        VariantClear(&VarFilter);
    }
    // else will be cleared as part of container release

    if (pADsContainer) {
        pADsContainer->Release();
    }

    return(hr);
} /* EnumObject */


HRESULT
getSmtpServerProperties(
    LPWSTR AdsPath,
    BSTR *pbstrDropDirectory
    )

/*++

Routine Description:

Get properties from the given smtp server

Arguments:

    AdsPath - 
    pbstrDropDirectory - pointer to bstr to get drop directory, caller frees

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    IADs *pObject = NULL ;

    // Get smtp server object
    hr = ADsGetObject(
        AdsPath,
        IID_IADs,
        (void **)&pObject
        );
    if (FAILED(hr)) {
        DPRINT2(0,"ADsGetObject(%ws) failed with error 0x%x\n",
                AdsPath, hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_ADS_GET_OBJECT_FAILURE,
                          szInsertWC(AdsPath),
                          szInsertWin32Msg( hr ),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof( hr ), &hr );
        goto cleanup;
    }

    hr = getPropBstr( pObject, L"DropDirectory", pbstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1(0,"getPropBstr failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Retrieve other properties here as needed

    hr = S_OK;

cleanup:

    if (pObject) {
        pObject->Release();
    }

    return hr;
} /* getSmtpServerProperties */


HRESULT
getPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR *pbstrValue
    )

/*++

Routine Description:

Get a bstr-valued property from an object. Caller must free.

Arguments:

    pObject - 
    PropertyName - 
    pbstrValue - pointer to allocated bstr; caller must sysfree()

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    // Allocate the property
    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property
    hr = pObject->Get( bstrProp, &varValue );
    if (FAILED(hr)) {
        DPRINT1(0,"Get failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // We are expecting a bstr

    if (varValue.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1( 0, "Variant has unexpected type %d\n", varValue.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

// Steal the bstr out of the variant, and don't free the variant
    *pbstrValue = varValue.bstrVal;

    hr = S_OK;

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    return hr;
} /* getPropBstr */


HRESULT
putPropInteger(
    IADs *pObject,
    LPWSTR PropertyName,
    DWORD Value
    )

/*++

Routine Description:

This is a helper routine to create an integer attribute on an object.
The attribute to be set is specified at run-time.

Note, it is assumed caller will call pObject->SetInfo to flush the changes

Arguments:

    pObject - iads object pointer
    PropertyName - string name of property to be written
    Value - integer

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    VariantInit( &varValue );

    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    varValue.vt = VT_I4;
    varValue.lVal = Value;

    hr = pObject->Put( bstrProp, varValue );
    if (FAILED(hr)) {
        DPRINT1(0, "Put failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    // No need to free variant

    return hr;

} /* putPropInteger */


HRESULT
putPropBstr(
    IADs *pObject,
    LPWSTR PropertyName,
    BSTR bstrValue
    )

/*++

Routine Description:

This is a helper routine to create an bstr attribute on an object.
The attribute to be set is specified at run-time.

Note, it is assumed caller will call pObject->SetInfo to flush the changes

Arguments:

    pObject - iads object pointer
    PropertyName - string name of property to be written
    Value - bstr

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrProp = NULL;
    VARIANT varValue;

    VariantInit( &varValue );

    bstrProp = SysAllocString( PropertyName );
    if (bstrProp == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT1(0,"SysAllocString failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    varValue.vt = VT_BSTR;
    varValue.bstrVal = bstrValue;

    hr = pObject->Put( bstrProp, varValue );
    if (FAILED(hr)) {
        DPRINT1(0, "Put failed with error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

cleanup:
    if (bstrProp) {
        SysFreeString(bstrProp);
    }

    // Caller will free bstr
    // No need to free variant

    return hr;

} /* putPropBstr */

/* end adsisupp.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\cdosupp.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cdosupp.cxx

Abstract:

    CDO support routines

Author:

    Will Lees (wlees) 20-Oct-1998

Environment:

Notes:

Revision History:

--*/

#include <ntdspchx.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_CDOSUPP

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

#include <atlbase.h>          // cccomptr
#include "cdosys.h"

#define DEBSUB "CDOSUPP:"

#include <smtpsink.h>
#include <initguid.h>
#include <seo.h>
#include <seoexports.h> // IEventUtil   

// This code fragment defines the CLSIDs and IIDs for the event sink
#include "smtpsink_i.c"

// This code fragment defines the CLSIDs and IIDs for the event package
#include "seo_i.c"

// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
DEFINE_GUID(GUID_PLAT_SMTPSVC, 
0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
DEFINE_GUID(SMTP_PLAT_SOURCE_TYPE_GUID,
0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);

// {4f803d90-fd85-11d0-869a-00c04fd65616}
DEFINE_GUID(SMTP_SOURCE_TYPE_GUID,
0x4f803d90, 0xfd85, 0x11d0, 0x86, 0x9a, 0x0, 0xc0, 0x4f, 0xd6, 0x56, 0x16);

// OnArrival category guid
//"{ff3caa23-00b9-11d2-9dfb-00C04FA322BA}"
DEFINE_GUID( CATID_SMTP_ON_ARRIVAL,
0xff3caa23, 0xb9, 0x11d2, 0x9d, 0xfb, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);

#define STR_DISPLAY_NAME                 "ISM SMTP Transport"
#define STR_SINKCLASS                    "CDO2EventSink.IsmSink1"
#define LONG_PRIORITY                    8192

typedef HRESULT STDAPICALLTYPE REGISTER_SERVER_FN( VOID );

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon Apr 26 10:02:58 1999 */

VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    );

BOOL
classPresent(
    IN const GUID *puuidClass
    );

BOOL
servicePresent(
    LPSTR ServiceName
    );

BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    );

HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    );

HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    );

HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    );

LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    );

HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    );

HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    );

HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    );

/* End Forward */


VOID
LogCdoErrorInternal(
    HRESULT hrError,
    ULONG ulInternalId
    )

/*++

Routine Description:

    Log a CDO error event

Arguments:

    hrError - Error status to be logged
    ulInternalId - Call site

Return Value:

    None

--*/

{
    LogEvent8WithData(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_CDO_ERROR,
                      szInsertWin32Msg(hrError),
                      szInsertUL(ulInternalId),
                      NULL, NULL, NULL, NULL, NULL, NULL,
                      sizeof(hrError),
                      &hrError );
} /* LogCdoErrorInternal */


BOOL
classPresent(
    IN const GUID *puuidClass
    )

/*++

Routine Description:

Determine if a given COM class is registered

Arguments:

    puuidClass - pointer to uuid of class, the CLSID or class-id

Return Value:

    BOOL - is it registered

--*/

{
#define CLASS_REG_PATH "SOFTWARE\\Classes\\CLSID\\{%s}"
    BOOL found = FALSE;
    CHAR keyPath[80];
    unsigned char *pszUuidString = NULL;
    DWORD status;
    HKEY hkKey = NULL;

    status = UuidToString( (GUID *) puuidClass, &pszUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        goto cleanup;
    }

    sprintf( keyPath, CLASS_REG_PATH, pszUuidString );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (pszUuidString) {
        RpcStringFree( &pszUuidString );
    }

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* classPresent */


BOOL
servicePresent(
    LPSTR ServiceName
    )

/*++

Routine Description:

Determine if a given service is installed.  We do this by checking the registry.

Arguments:

    ServiceName - Name of service to check

Return Value:

    BOOL - 

--*/

{
#define SERVICE_REG_PATH "SYSTEM\\CurrentControlSet\\Services\\%s"
    BOOL found = FALSE;
    CHAR keyPath[80];
    DWORD status;
    HKEY hkKey = NULL;

    sprintf( keyPath, SERVICE_REG_PATH, ServiceName );

    status = RegOpenKey( HKEY_LOCAL_MACHINE, keyPath, &hkKey );
    if ( (status != ERROR_SUCCESS) &&
         (status != ERROR_FILE_NOT_FOUND) ) {
        DPRINT2( 0, "RegOpenKey %s failed, error %d\n", keyPath, status );
        LogUnhandledError( status );
        goto cleanup;
    }

    found = (status == ERROR_SUCCESS);

cleanup:

    if (hkKey) {
        RegCloseKey( hkKey );
    }

    return found;
} /* servicePresent */


BOOL
mailAddressMatch(
    BSTR bstrAddress,
    LPWSTR Name
    )

/*++

Routine Description:

    See if the given name matches the mail address
    This handle the mail address syntax "person" <user@domain>
    A prefix match is done on the name, so that we may match on user only

Arguments:

    bstrAddress - 
    Name - 

Return Value:

    BOOL - 

--*/

{
    LPWSTR start;

    start = wcschr( bstrAddress, L'<' );
    if (start == NULL) {
        return FALSE;
    }
    start++;
    return (_wcsnicmp( start, Name, wcslen( Name ) ) == 0 );

} /* mailAddressMatch */


HRESULT
getFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Get the value of the named field out of a Field object
Returned as a variant, caller must free contents

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    VariantInit( pvarValue );

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->get_Value( pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* getFieldVariant */


HRESULT
putFieldVariant(
    Fields *pFields,
    LPWSTR FieldName,
    VARIANT *pvarValue
    )

/*++

Routine Description:

Helper routine
Put the value of the named field in a Field object

Arguments:

    pFields - 
    FieldName - 
    pvarValue - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItemName = NULL;
    VARIANT vItemName;

    // Turn the field name in to a bstr
    bstrItemName = SysAllocString( FieldName );
    if (bstrItemName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Load the field name into a variant
    VariantInit( &vItemName );
    vItemName.vt = VT_BSTR;
    vItemName.bstrVal = bstrItemName;

    // Get a field object for the item
    hr = pFields->get_Item(vItemName, &pField);
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to get_Item(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Get the property out of the field object
    hr = pField->put_Value( *pvarValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "failed to put_Value(%ws), error 0x%x\n",
                 FieldName, hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:

    if (pField) {
        pField = NULL;
    }
    if (bstrItemName) {
        SysFreeString( bstrItemName );
    }
    // No need to free vItemName

    return hr;
} /* putFieldVariant */


HRESULT
getMessageId(
    IMessage *pIMsg,
    BSTR *pbstrId
    )

/*++

Routine Description:

Return the message id of the message

Arguments:

    pIMsg - 
    pbstrFilename - pointer to receive bstr, caller must free

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vMessageId;

    *pbstrId = NULL;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        // This code is on the error handling path
        // Don't log
        // The system may be too hosed at this point to retrieve the message id
        goto cleanup;
    }

    hr = getFieldVariant( pFields, cdoMessageId, &vMessageId );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vMessageId.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Message id type %d was not expected!\n",
                vMessageId.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Steal the bstr out of the variant; don't clean up the variant

    *pbstrId = vMessageId.bstrVal;

    hr = S_OK;

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* getMessageId */


HRESULT
putFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pwzUuidString = NULL;
    BSTR bstrGuid = NULL;
    VARIANT vGuid;

    VariantInit( &vGuid );

    status = UuidToStringW( (GUID *) pGuid, &pwzUuidString );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    bstrGuid = SysAllocString( pwzUuidString );
    if (bstrGuid == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    vGuid.vt = VT_BSTR;
    vGuid.bstrVal = bstrGuid;

    hr = putFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "putFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    hr = S_OK;

cleanup:
    if (pwzUuidString) {
        RpcStringFreeW( &pwzUuidString );
    }
    if (bstrGuid) {
        SysFreeString( bstrGuid );
    }

    return hr;
}


HRESULT
getFieldGuid(
    Fields *pFields,
    LPWSTR FieldName,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    DWORD status;
    VARIANT vGuid;

    hr = getFieldVariant( pFields, FieldName, &vGuid );
    if (FAILED(hr)) {
        DPRINT1( 0, "getFieldVariant failed, error 0x%x\n", hr );
        LogUnhandledError( hr );
        goto cleanup;
    }

    if (vGuid.vt == VT_EMPTY) {
        ZeroMemory( pGuid, sizeof( GUID ) );
        goto cleanup;
    } else if (vGuid.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Guid type %d was not expected!\n", vGuid.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    status = UuidFromStringW( vGuid.bstrVal, pGuid );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "RpcUuidToString failed, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    // Release resources in the variant
    if (vGuid.vt != VT_EMPTY) {
        VariantClear( &vGuid );
    }

    return hr;
}


LPWSTR
parseStatus(
    BSTR bstrDeliveryStatus,
    LPDWORD pdwWin32Status
    )

/*++

Routine Description:

Parse a delivery status message for the status: field.
Field is of the form class.subject.detail
Return a descriptive error string for each message

Arguments:

    bstrDeliveryStatus - String describing delivery status message to be
parsed.
    pdwStatus - Pointer to dword to receive closest win32 status

Return Value:

    LPWSTR - Error string returned

--*/

{
#define STATUS_KEYWORD L"Status: "
    LPWSTR pszStatus;
    LONG classCode = 0, subjectCode = 0, detailCode = 0;

    Assert( pdwWin32Status );

    pszStatus = wcsstr( bstrDeliveryStatus, STATUS_KEYWORD );
    if (pszStatus == NULL) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse delivery status message";
    }

    pszStatus += wcslen( STATUS_KEYWORD );

    if (swscanf( pszStatus, L"%d.%d.%d", &classCode, &subjectCode, &detailCode )
        != 3) {
        *pdwWin32Status = ERROR_INVALID_PARAMETER;
        return L"Cannot parse status field";
    }

    // Any success
    if (classCode == 2) {
        *pdwWin32Status = ERROR_SUCCESS;
        return L"Success";
    }

    switch (subjectCode) {
    case 0:
        switch (classCode) {
        // Case 2 handled above
        case 4:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Transient failure, no other information";
        case 5:
            *pdwWin32Status = ERROR_CAN_NOT_COMPLETE;
            return L"Permanent failure, no other information";
        }
    case 1:
        *pdwWin32Status = ERROR_INCORRECT_ADDRESS;
        switch (detailCode) {
        case 1:
            return L"Bad destination mailbox address";
        case 2:
            return L"Bad destination system address";
        case 3:
            return L"Bad destination mailbox address syntax";
        case 4:
            return L"Destination mailbox address ambiguous";
        case 5:
            return L"Destination address valid";
        case 6:
            return L"Destination mailbox has moved, No forwarding address";
        case 7:
            return L"Bad sender's mailbox address syntax";
        case 8:
            return L"Bad sender's system address";
        }
        break;
    case 2:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"Mailbox disabled, not accepting messages";
        case 2:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mailbox full";
        case 3:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message length exceeds administrative limit";
        case 4:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Mailing list expansion problem";
        }
        break;
    case 3:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HANDLE_DISK_FULL;
            return L"Mail system full";
        case 2:
            *pdwWin32Status = ERROR_SERVICE_DISABLED;
            return L"System not accepting network messages";
        case 3:
            *pdwWin32Status = ERROR_CALL_NOT_IMPLEMENTED;
            return L"System not capable of selected features";
        case 4:
            *pdwWin32Status = ERROR_DS_OBJ_TOO_LARGE;
            return L"Message too big for system";
        case 5:
            *pdwWin32Status = ERROR_BAD_CONFIGURATION;
            return L"System incorrectly configured";
        }
        break;
    case 4:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_HOST_UNREACHABLE;
            return L"No answer from host";
        case 2:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Bad connection";
        case 3:
            *pdwWin32Status = ERROR_FILE_NOT_FOUND;
            return L"Directory server failure";
        case 4:
            *pdwWin32Status = ERROR_NETWORK_UNREACHABLE;
            return L"Unable to route";
        case 5:
            *pdwWin32Status = ERROR_NETWORK_BUSY;
            return L"Mail system congestion";
        case 6:
            *pdwWin32Status = ERROR_DS_LOOP_DETECT;
            return L"Routing loop detected";
        case 7:
            *pdwWin32Status = ERROR_SEM_TIMEOUT;
            return L"Delivery time expired";
        }
        break;
    case 5:
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command";
        case 2:
            *pdwWin32Status = ERROR_INVALID_DATA;
            return L"Syntax error";
        case 3:
            *pdwWin32Status = ERROR_TOO_MANY_OPEN_FILES;
            return L"Too many recipients";
        case 4:
            *pdwWin32Status = ERROR_INVALID_FUNCTION;
            return L"Invalid command arguments";
        case 5:
            *pdwWin32Status = ERROR_UNKNOWN_REVISION;
            return L"Wrong protocol version";
        }
        break;
    case 6:
        *pdwWin32Status = ERROR_BAD_FORMAT;
        switch (detailCode) {
        case 1:
            return L"Media not supported";
        case 2:
            return L"Conversion required and prohibited";
        case 3:
            return L"Conversion required but not supported";
        case 4:
            return L"Conversion with loss performed";
        case 5:
            return L"Conversion failed";
        }
        break;
    case 7:
        *pdwWin32Status = ERROR_ACCESS_DENIED;
        switch (detailCode) {
        case 1:
            *pdwWin32Status = ERROR_CONNECTION_REFUSED;
            return L"Delivery not authorized, message refused";
        case 2:
            return L"Mailing list expansion prohibited";
        case 3:
            return L"Security conversion required but not possible";
        case 4:
            return L"Security features not supported";
        case 5:
            return L"Cryptographic failure";
        case 6:
            return L"Cryptographic algorithm not supported";
        case 7:
            return L"Message integrity failure";
        }
        break;
    }

    *pdwWin32Status = ERROR_DS_UNKNOWN_ERROR;
    return L"Unknown status code";

} /* parseStatus */


HRESULT
registerInterfaceDll(
    LPSTR DllFilename,
    BOOL Register
    )

/*++

Routine Description:

Invoke a COM dll's registration or deregistration entry point

Arguments:

    DllFilename - 
    Register - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    HINSTANCE hDll = NULL;
    REGISTER_SERVER_FN *pfnRegisterServer, *pfnUnregisterServer;

    hDll = LoadLibrary( DllFilename );
    if (hDll == NULL) {
        status = GetLastError();
        DPRINT2( 0, "LoadLibrary(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    pfnRegisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllRegisterServer" );
    pfnUnregisterServer = (REGISTER_SERVER_FN *) GetProcAddress( hDll, "DllUnregisterServer" );
    if ( (pfnRegisterServer == NULL) ||
         (pfnUnregisterServer == NULL) ) {
        status = GetLastError();
        DPRINT2( 0, "GetProcAddress(%s) failed with %d\n", DllFilename, status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    hr = S_OK;
    __try {
        if (Register) {
            hr = (*pfnRegisterServer)();
        } else {
            hr = (*pfnUnregisterServer)();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = GetExceptionCode();
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Registration function failed with %d\n", hr );
    }

cleanup:
    if (NULL != hDll) {
        FreeLibrary(hDll);
    }

    return hr;
} /* registerInterfaceDll */


HRESULT
modifyExistingBinding(
    IEventBinding *pBinding,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Update the existing binding with new properties if necessary

Arguments:

    pBinding - 
    bstrRule - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;
    VARIANT vOldRule;

    VariantInit( &vOldRule );

    hr = pBinding->get_SourceProperties(&pSourceProps);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
        goto cleanup;
    }

    // Get the old value of the rule
    hr = pSourceProps->Item( &CComVariant(CComBSTR(_T("Rule"))), &vOldRule );
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "SourceProps->Item(Rule) failed with error 0x%x\n", hr );
        goto cleanup;
    }

    if (vOldRule.vt != VT_BSTR) {
        hr = E_INVALIDARG;
        DPRINT1(0, "Rule type %d was not expected!\n", vOldRule.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // If changed, modify the rule
    if (_wcsicmp( vOldRule.bstrVal, bstrRule ) != 0 ) {
        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto cleanup;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto cleanup;
        }

        DPRINT2( 1, "Event sink binding '%ws' Rule=%ws was modified.\n",
                 bstrDisplayName, bstrRule );
    }

cleanup:
    pSourceProps = NULL;

    if (vOldRule.vt != VT_EMPTY) {
        VariantClear( &vOldRule );
    }

    return hr;
} /* modifyBinding */


HRESULT
eventBindingPresent(
    IEventBindings *pBindings,
    BSTR bstrDisplayName,
    BSTR bstrRule
    )

/*++

Routine Description:

Check if the desired binding is present in the binding list.
If so, verify the fields are up to date

Arguments:

    pBindings - 
    bstrDisplayName - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IUnknown> pIUnknown;
    CComPtr<IEnumVARIANT> pIEnumVariant;
    CComPtr<IEventBinding> pBinding	= NULL;
    LONG count = 0;
    DWORD fetched;
    VARIANT varRet;
    BSTR bstrBindingDisplayName = NULL;
    BOOLEAN found;

    VariantInit( &varRet );

    // Get a new enumeration
    hr = pBindings->get__NewEnum( &pIUnknown );
    if (FAILED(hr))
        goto error_exit;

    // How many?
    hr = pBindings->get_Count(&count);
    if (FAILED(hr))
        goto error_exit;
    if (count == 0) {
        hr = S_FALSE;  // not found
        goto error_exit;
    }

    // Enumerate a series of variants
    hr = pIUnknown->QueryInterface(IID_IEnumVARIANT, (void**)&pIEnumVariant);
    if (FAILED(hr))
        goto error_exit;

    // Here is the search loop. We exit at the top. Resources released at loop end

    found = FALSE;
    hr = S_OK;
    while ( (hr == S_OK) && (!found) ) {

        // Get next item
        fetched = 0;
        hr = pIEnumVariant->Next(1UL,&varRet,&fetched);
        if ( FAILED(hr) || (!fetched) ) {
            hr = S_FALSE;
            goto loop_cleanup;
        }

        // Retrieve the binding
        hr = varRet.punkVal->QueryInterface(IID_IEventBinding,(void**)&pBinding);
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Get the display name
        hr = pBinding->get_DisplayName( &bstrBindingDisplayName );
        if (FAILED(hr)) {
            goto loop_cleanup;
        }

        // Does it match?
        if (_wcsicmp( bstrDisplayName, bstrBindingDisplayName ) == 0) {
            found = TRUE;

            hr = modifyExistingBinding( pBinding, bstrDisplayName, bstrRule );
            if (FAILED(hr)) {
                LogUnhandledError( hr );
                DPRINT1( 0, "modifyExistingBinding failed with error 0x%x\n", hr );
                goto loop_cleanup;
            }
        }

    loop_cleanup:
        // Loop resource release
        VariantClear(&varRet);
        pBinding = NULL;
        if (bstrBindingDisplayName) {
            SysFreeString( bstrBindingDisplayName );
            bstrBindingDisplayName = NULL;
        }
    }

    // hr == S_OK, found
    // hr == S_FALSE, not found
    // hr other, error

error_exit:

    return hr;
} /* eventBindingPresent */



HRESULT
HrIsmSinkBinding(
    BOOL fBindSink,
    BSTR bstrRule
    )

/* HrIsmSinkBinding()
 *
 * Credits: This code was obtained from Jeff Stammerjohn (jstammerj) of the
 * Exchange group.  It was modified to work as a CDO sink.

 * Purpose:
 *     Binds or unbinds the Ism sink
 *
 * Parameters:
 *     BOOL    fBindSink
 *                 TRUE  - bind the sink
 *                 FALSE - unbind the sink
 *     BSTR    bstrRule - rule to use when creating the binding
 *
 * Returns:
 *     HResult
 */

{
    HRESULT	hr = NULL;
    CComPtr<IEventUtil> pEventUtil = NULL;
    TCHAR szDisplayName[32]	= { NULL };
    CComPtr<IEventBindingManager> pBindingManager	= NULL;
    CComPtr<IEventBindings>	pBindings= NULL;
    CComPtr<IEventBinding> pBinding	= NULL;
    CComPtr<IEventPropertyBag> pSourceProps = NULL;

    // SEO.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_CEventUtil )) ) {
        DPRINT(0,"One or more SEO classes not found - SEO not registered\n" );
        hr = REGDB_E_CLASSNOTREG;
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_CLASS_MISSING,
                          szInsertWC( L"SEO.DLL" ),
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto error_exit;
    }

    // Set up the default site (instance)
    lstrcpy(szDisplayName,_T("smtpsvc 1"));

    hr = CoCreateInstance(CLSID_CEventUtil,NULL,CLSCTX_ALL,IID_IEventUtil,(LPVOID *) &pEventUtil);
    if (FAILED(hr))
    {
        LogUnhandledError( hr );
        DPRINT1( 0, "CoCreateInstance CEventUtil failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pEventUtil->RegisterSource(CComBSTR((LPCWSTR) CStringGUID(SMTP_PLAT_SOURCE_TYPE_GUID)),
                                    CComBSTR((LPCWSTR) CStringGUID(GUID_PLAT_SMTPSVC)),
                                    1,
                                    CComBSTR(_T("smtpsvc")),
                                    CComBSTR(_T("")),
                                    CComBSTR(_T("event.metabasedatabasemanager")),
                                    CComBSTR(szDisplayName),
                                    &pBindingManager);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "RegisterSource smtpsvc failed with error 0x%x\n", hr );
        goto error_exit;
    }

    hr = pBindingManager->get_Bindings(CComBSTR((LPCWSTR) CStringGUID(CATID_SMTP_ON_ARRIVAL)),
									   &pBindings);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "get_Bindings failed with error 0x%x\n", hr );
        goto error_exit;
    }

    // Check if binding already registered

    hr = eventBindingPresent( pBindings, CComBSTR(STR_DISPLAY_NAME), bstrRule);
    if (FAILED(hr)) {
        LogUnhandledError( hr );
        DPRINT1( 0, "eventBindingPresent failed with error 0x%x\n", hr );
        goto error_exit;
    }

    if (fBindSink)
    {
        if (hr == S_OK) {
            // Binding already present
            DPRINT2( 1, "Event sink binding '%s' %s already present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Create binding
        hr = pBindings->Add(CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)),&pBinding);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Add failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_DisplayName(CComBSTR(STR_DISPLAY_NAME));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_DisplayName failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->put_SinkClass(CComBSTR(STR_SINKCLASS));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SinkClass failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->get_SourceProperties(&pSourceProps);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.put_SourceProperties failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("priority")),&CComVariant(LONG_PRIORITY));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop priority failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pSourceProps->Add(CComBSTR(_T("Rule")),&CComVariant(bstrRule));
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "add prop rule failed with error 0x%x\n", hr );
            goto error_exit;
        }

        hr = pBinding->Save();
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Save failed with error 0x%x\n", hr );
            goto error_exit;
        }

        DPRINT3( 1, "Event sink binding '%s' Class=%s Rule=%ws was added.\n",
                 STR_DISPLAY_NAME, STR_SINKCLASS, bstrRule );
    }
    else
    {
        if (hr == S_FALSE) {
            // Binding not present
            DPRINT2( 1, "Event sink binding '%s' %s is not present.\n",
                     STR_DISPLAY_NAME, STR_SINKCLASS );
            goto error_exit;
        }
        // Delete binding
        CComVariant vID (CComBSTR((LPCWSTR) CStringGUID(CLSID_IsmSink1)));
        
        hr = pBindings->Remove(&vID);
        if (FAILED(hr)) {
            LogUnhandledError( hr );
            DPRINT1( 0, "Bindings.Remove failed with error 0x%x\n", hr );
            goto error_exit;
        }
    }
error_exit:

    return hr;
}

/* end cdosupp.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\ip\dlltest.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    transporttest.c

Abstract:

Test for a transport dll.    

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name

        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

#include <schedule.h>

#include "ismapi.h"

/* External */

/* Static */

static ISM_NOTIFY NotifyFunction;

static HANDLE ghNotify = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 15 17:05:00 1998 */

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    );

static void
Usage(
    WCHAR *ProgramName
    );

static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    );

static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    );

static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    );

static void
printSchedule(
    PBYTE pSchedule
    );

static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    );

/* End Forward */


int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *option, *address, *service, *message, *transport, *site;
    if (argc < 2) {
        Usage( argv[0] );
        return -1;
    }
    option = argv[1];
    if (_wcsicmp( option, L"-c" ) == 0) {
        if (argc < 6) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        address = argv[3];
        service = argv[4];
        message = argv[5];
        if (!clientTest( transport, address, service, message )) {
            printf( "client test failed\n" );
        }
    } else if (_wcsicmp( option, L"-s" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        service = argv[3];

        if (!serverTest( transport, service )) {
            printf( "server test failed\n" );
        }
    } else if (_wcsicmp( option, L"-r" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        site = argv[3];

        if (!directoryTest( transport, site )) {
            printf( "directory test failed\n" );
        }
    } else {
        Usage( argv[0] );
        return -1;
    }
    return 0;
}


static void
Usage(
    WCHAR *ProgramName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "Usage:\n" );
    printf( "\t%ws -c transport address service \"string\"\tclient test\n", ProgramName );
    printf( "\t%ws -s transport service\tserver test\n", ProgramName );
    printf( "\t%ws -r transport site \trouting function test\n", ProgramName );
}


static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    ISM_MSG message;
    DWORD status, bytes, i;
    PBYTE pBlock;

    printf( "client test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    bytes = 0;
    bytes = _wtoi( Message );
    if (bytes == 0) {
        message.pszSubject = L"This is the subject";
        message.cbData = (wcslen( Message ) + 1) * sizeof( WCHAR );
        message.pbData = (PBYTE) Message;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
    } else {
        pBlock = LocalAlloc( LMEM_FIXED, bytes );
        if (pBlock == NULL) {
            printf( "LocalAlloc failed to alloc %d bytes\n", bytes );
            return FALSE;
        }
        for( i = 0; i < bytes; i++ ) {
            pBlock[i] = (BYTE) ((i % 26) + 'a');
        }
        message.cbData = bytes;
        message.pbData = pBlock;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
        LocalFree( pBlock );
    }

    IsmShutdown( handle );

    return TRUE;
}


static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status;
    PISM_MSG pMessage;
    BOOLEAN done = FALSE;

    printf( "server  test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = RpcServerListen(
        1, // minimum
        RPC_C_LISTEN_MAX_CALLS_DEFAULT, // maximum,
        1   // don't wait
        ); 
    if (status != ERROR_SUCCESS) {
        printf( "RpcServerListen failed with status %d\n", status );
        return FALSE;
    }

    while (!done) {
        status = IsmReceive( handle, Service, &pMessage );
        if (status) {
            printf( "IsmReceived failed with error %d\n", status );
            break;
        }
        if (pMessage == NULL) {
            Sleep( 30 * 1000 );
        } else {
            if (pMessage->cbData < 100) {
                printf( "Received subj: '%ws', message: \"%ws\"\n",
                        pMessage->pszSubject ? pMessage->pszSubject : L"no subject",
                        pMessage->pbData );
                if (_wcsicmp( (WCHAR *) pMessage->pbData, L"exit" ) == 0) {
                    done = TRUE;
                }
            } else {
                printf( "Received message: %d bytes\n", pMessage->cbData );
            }
            IsmFreeMsg( handle, pMessage );
        }
    }

    status = RpcMgmtStopServerListening( NULL );
    if (status != ERROR_SUCCESS) {
        printf( "RpcMgmtStopServerListen failed with status %d\n", status );
    }

    status = RpcMgmtWaitServerListen( );
    if (status != ERROR_SUCCESS) {
        printf( "RpcMgmtWaitServerListen failed with status %d\n", status );
    }

    IsmShutdown( handle );
    return TRUE;
}


static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status, i, j;
    BOOLEAN result = FALSE;
    PISM_CONNECTIVITY pConnectivity = NULL;
    PISM_SERVER_LIST pServerList = NULL;
    PISM_SCHEDULE pSchedule = NULL;

    printf( "directory test\n" );
    if (IsmStartup( TransportName, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = IsmGetTransportServers( handle, SiteName, &pServerList );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get transport servers, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nTransport Servers:\n" );
    if (pServerList != NULL) {
        printf( "Number of Servers = %d\n", pServerList->cNumServers );
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            printf( "\tServer[%d] = %ws\n", i, pServerList->ppServerDNs[i] );
        }
    } else {
        printf( "\tNone\n" );
    }

    status = IsmGetConnectionSchedule( handle, L"FOO", L"BAR", &pSchedule );
    if (status != ERROR_NOT_READY) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectivity( handle, &pConnectivity );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get connectivity, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nSite Connectivity::\n" );

    if (pConnectivity != NULL) {
        printf( "Number of sites = %d\n", pConnectivity->cNumSites );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "\tSite[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        }
        printf( "All pairs shortest path matrix:\n" );
        printf( "     |" );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            printf( "%5.5d|", j );
        }
        printf( "\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "%5.5d|", i );
            for( j = 0; j < pConnectivity->cNumSites; j++ ) {
                PISM_LINK pLink = &( pConnectivity->pLinkValues[ i * pConnectivity->cNumSites + j ] );
                if (pLink->ulCost != 0xffffffff) {
                    printf( "%5.5u:", pLink->ulCost );
                } else {
                    printf( "  *  :" );
                }
                printf( "%5.5u:", pLink->ulReplicationInterval );
                printf( "%5.5x|", pLink->ulOptions );
            }
            printf( "\n" );
        }
    } else {
        printf( "\tNo site connectivity\n" );
    }

    status = IsmGetConnectionSchedule( handle,
                                       pConnectivity->ppSiteDNs[0],
                                       L"BAR",
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectionSchedule( handle,
                                       L"FOO",
                                       pConnectivity->ppSiteDNs[0],
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    // Generate all pairs of sites

    if (pConnectivity != NULL) {
        printf( "\nSite to Site Scheduling:\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            for( j = i + 1; j < pConnectivity->cNumSites; j++ ) {
                if (pConnectivity->pLinkValues[ i + pConnectivity->cNumSites * j ].ulCost == 0xffffffff) {
                    continue;
                }
                status = IsmGetConnectionSchedule( handle,
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j],
                               &pSchedule );
                if (status != ERROR_SUCCESS) {
                    printf( "failed to get common site schedule, or not connected\n" );
                    goto cleanup;
                }

                printf( "\t%ws to %ws: ",
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j] );
                if (pSchedule != NULL) {
                    printf( "Connected via schedule, addr: %p, len: %d\n",
                            pSchedule->pbSchedule, pSchedule->cbSchedule );
                    printSchedule( pSchedule->pbSchedule );
                    IsmFreeConnectionSchedule( handle, pSchedule );
                } else {
                    printf( "Connected all the time\n" );
                }

            }
        }
    }


    result = TRUE;

cleanup:
    if (pConnectivity != NULL) {
        IsmFreeConnectivity( handle, pConnectivity );
    }

    if (pServerList != NULL) {
        IsmFreeTransportServers( handle, pServerList );
    }

    IsmShutdown( handle );

    return result;
}


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tues","Wed","Thurs","Fri","Sat"};

    printf( "\t\t" );
    for( day = 0; day < 7; day++ ) {
        for( hour = 0; hour < 24; hour++ ) {
            if (*data & 0x1) printf( "%s%d:00;", dow[day], hour );
            if (*data & 0x2) printf( "%s%d:15;", dow[day], hour );
            if (*data & 0x4) printf( "%s%d:30;", dow[day], hour );
            if (*data & 0x8) printf( "%s%d:45;", dow[day], hour );
            data++;
        }
    }
    printf( "\n" );
}


static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    )
/*++

Routine Description:

    Called by the plug-in to notify the ISM service that a message has been
    received for the given service.

Arguments:

    hNotify (IN) - Notification handle, as passed to the plug-in in the
        IsmStartup() call.

    pszServiceName (IN) - Service for which a message was received.

Return Values:

    None.

--*/
{
    printf( "Notified of pending message for service %ws.\n", pszServiceName );
}

/* end plugtest.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\ismsmtp.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ismsmtp.h

ABSTRACT:

DETAILS:

CREATED:

    3/20/98     Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <ntrtl.h>            // Generic table

#ifdef __cplusplus
extern "C" {
#endif

extern CRITICAL_SECTION DropDirectoryLock;
extern CRITICAL_SECTION QueueDirectoryLock;

// Don't support messages bigger than a megabyte.
#define MAX_DATA_SIZE (1024 * 1024)

// xmitrecv.cxx

HRESULT
SmtpInitialize(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

HRESULT
SmtpTerminate(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fRemoval
    );

unsigned __stdcall
SmtpRegistryNotifyThread(
    IN  HANDLE        hIsm
    );

DWORD
SmtpSend(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
SmtpReceive(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    );

VOID
SmtpFreeMessage(
    IN ISM_MSG *              pMsg
    );










// table.c

DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

// Service descriptor

typedef struct _SERVICE_INSTANCE {
    LIST_ENTRY_INSTANCE ListEntryInstance;
    RTL_GENERIC_TABLE TargetTable;
} SERVICE_INSTANCE, *PSERVICE_INSTANCE;

// Target descriptor

typedef struct _TARGET_INSTANCE {
    DWORD NameLength;
    RTL_GENERIC_TABLE SendSubjectTable;
    DWORD MaximumSendSubjectEntries;
    DWORD NumberSendSubjectEntries;
    LIST_ENTRY SendSubjectListHead;
    WCHAR Name[1]; // variable length structure
} TARGET_INSTANCE, *PTARGET_INSTANCE;

// Subject descriptor

typedef struct _SUBJECT_INSTANCE {
    DWORD NameLength;
    GUID Guid;
    LIST_ENTRY ListEntry;
    WCHAR Name[1]; // variable length structure
} SUBJECT_INSTANCE, *PSUBJECT_INSTANCE;

DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE   * ppSubjectInstance
    );

// Guid table

typedef struct _GUID_TABLE {
    RTL_GENERIC_TABLE GuidTable;
} GUID_TABLE, *PGUID_TABLE;

typedef struct _GUID_ENTRY {
    GUID Guid;
} GUID_ENTRY, *PGUID_ENTRY;

PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    );

VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    );

BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\ismsmtp.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    imssmtp.c

ABSTRACT:

    This module is a plug-in DLL for the Inter-Site Messaging service, which is
    part of the mail-based replication subsystem in the Directory Service.

    This DLL, as is any instance of the ISM plug-in DLL class, provides a set
    of abstract transport functions, such as send, receive, and so on.  See
    ismapi.h for details.

    This implementation is based on e-mail, using the SMTP protocol.

DETAILS:

CREATED:

    1/28/98     Jeff Parham (jeffparh)
                (Largely copied from WLees's ismip.c.)

REVISION HISTORY:

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>
#include <ntdsa.h>   // Option flags

// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include <dsevent.h>

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_ISMSMTP

#include "common.h"
#include "ismsmtp.h"

// Needed by dscommon.lib.
DWORD ImpersonateAnyClient(   void ) { return ERROR_CANNOT_IMPERSONATE; }
VOID  UnImpersonateAnyClient( void ) { ; }

#define DEBSUB "ISMSMTP:"

// Here is a way to enable debugging dynamically
// Run ismserv.exe under ntsd
// break in to the ismserv process
// !dsexts.dprint /m:ismsmtp level 4
// !dsexts.dprint /m:ismsmtp add *

// Set this to 1 for unit test debug
#define UNIT_TEST_DEBUG 0


/* External */

// Event logging config (as exported from ismserv.exe).
DS_EVENT_CONFIG * gpDsEventConfig = NULL;

/* Static */

// Lock on instances list
CRITICAL_SECTION TransportListLock;
// Lock on drop directory
CRITICAL_SECTION DropDirectoryLock;
// Lock on queue directory
CRITICAL_SECTION QueueDirectoryLock;

// Note that aligned 32 bit access is naturally atomic. However, if you ever
// require any atomic test-and-set functionality, you must use Interlocked
// instructions.
volatile DWORD gcRefCount = 0;
#define ENTER_CALL() (gcRefCount++)
#define EXIT_CALL() (--gcRefCount)
#define CALLS_IN_PROGRESS() (gcRefCount)
#define NO_CALLS_IN_PROGRESS() (gcRefCount == 0)

// List head of transport instances
LIST_ENTRY TransportListHead;

/* Forward */ /* Generated by Emacs 19.34.1 on Wed Nov 04 10:12:42 1998 */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     );

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    );

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    );

DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    );

DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    );

void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    );

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    );

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    );

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    );

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    );

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    );

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    );

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    );

/* End Forward */


DWORD
InitializeCriticalSectionHelper(
    CRITICAL_SECTION *pcsCriticalSection
    )

/*++

Routine Description:

Wrapper function to handle exception handling in the
InitializeCriticalSection() function.

Arguments:

    pcsCriticalSection - pointer to critical section

Return Value:

    DWORD - status code

--*/

{
    DWORD status;

    __try {
        InitializeCriticalSection( pcsCriticalSection );
        status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    return status;
} /* initializeCriticalSectionHelper */

BOOL
WINAPI
DllMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL
     )
/*++

 Routine Description:

    This function DllLibMain() is the main initialization function for
    this DLL. It initializes local variables and prepares it to be invoked
    subsequently.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    DWORD status;
    BOOL  fReturn = TRUE;
    LPSTR rgpszDebugParams[] = {"lsass.exe", "-noconsole"};
    DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
    HANDLE hevLogging;

    switch (fdwReason )
    {
    case DLL_PROCESS_ATTACH:
    {
        // Initialize debug library.
        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ismsmtp");

        // Get event logging config (as exported from ismserv.exe).
        gpDsEventConfig = DsGetEventConfig();

#if DBG
#if UNIT_TEST_DEBUG
        DebugInfo.severity = 1;
        strcpy( DebugInfo.DebSubSystems, "ISMSMTP:XMITRECV:CDOSUPP:" ); 
//        DebugInfo.severity = 3;
//        strcpy( DebugInfo.DebSubSystems, "*" ); 
#endif
        DebugMemoryInitialize();
#endif
        
        if ( (ERROR_SUCCESS != InitializeCriticalSectionHelper( &TransportListLock ) ) ||
             (ERROR_SUCCESS != InitializeCriticalSectionHelper( &DropDirectoryLock ) ) ||
             (ERROR_SUCCESS != InitializeCriticalSectionHelper( &QueueDirectoryLock ) ) ) {
            fReturn = FALSE;
            goto exit;
        }
        InitializeListHead( &TransportListHead );
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        // Make sure all threads stopped
        // Empty address list
        DeleteCriticalSection( &TransportListLock );
        DeleteCriticalSection( &DropDirectoryLock );
        DeleteCriticalSection( &QueueDirectoryLock );
        if (!IsListEmpty( &TransportListHead )) {
            DPRINT( 0, "Warning: Not all transport instances were shutdown\n" );
        }
#if DBG
        DebugMemoryTerminate();
#endif
        DEBUGTERM();
        break;
    }
    default:
        break;
    }   /* switch */

exit:
    return ( fReturn);
}  /* DllLibMain() */

DWORD
IsmStartup(
    IN  LPCWSTR         pszTransportDN,
    IN  ISM_NOTIFY *    pNotifyFunction,
    IN  HANDLE          hNotify,
    OUT HANDLE          *phIsm
    )
/*++

Routine Description:

    Initialize the plug-in.

Arguments:

    pszTransportDN (IN) - The DN of the Inter-Site-Transport that named this
        DLL as its plug-in.  The DS object may contain additional configuration
        information for the transport (e.g., the name of an SMTP server for
        an SMTP transport).

    pNotifyFunction (IN) - Function to call to notify the ISM service of pending
        messages.

    hNotify (IN) - Parameter to supply to the notify function.

    phIsm (OUT) - On successful return, holds a handle to be used in
        future calls to the plug-in for the named Inter-Site-Transport.  Note
        that it is possible for more than one Inter-Site-Transport object to
        name a given DLL as its plug-in, in which case IsmStartup() will be
        called for each such object.

Return Values:

    NO_ERROR - Successfully initialized.

    other - Failure.
        
--*/
{
    DWORD length;
    PTRANSPORT_INSTANCE instance;
    DWORD status, hr;
    BOOLEAN firsttime;
    BOOLEAN fSmtpInit = FALSE;
    BOOLEAN fNotifyInit = FALSE;

    DPRINT1( 1, "IsmStartup, transport='%ws'\n", pszTransportDN );

    MEMORY_CHECK_ALL();
    // Check validity of arguments

    if (phIsm == NULL) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    length = wcslen( pszTransportDN );
    if (length == 0) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Restrict to only one transport instance.
    EnterCriticalSection(&TransportListLock);
    __try {
        firsttime = IsListEmpty( &(TransportListHead) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }
    if (!firsttime) {
        status = ERROR_INVALID_PARAMETER;
        LogUnhandledError( status );
        return status;
    }

    // Allocate a new transport instance
    // Zero memory to simply cleanup
    instance = NEW_TYPE_ZERO( TRANSPORT_INSTANCE );
    if (instance == NULL) {
        // error: insufficient resources
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        return status;
    }

    // INITIALIZE TRANSPORT INSTANCE HERE
    // All values initially zero

    instance->Size = sizeof( TRANSPORT_INSTANCE );
    Assert( instance->ReferenceCount == 0 );
    instance->pNotifyFunction = pNotifyFunction;
    instance->hNotify = hNotify;
    InitializeListHead( &(instance->ServiceListHead) );
    InitializeCriticalSection( &(instance->Lock) );
    // ReplInterval is 0, meaning the application should take default

    // Default is schedules not significant, bridges not required (transitive)
    instance->Options = NTDSTRANSPORT_OPT_IGNORE_SCHEDULES;

    // INITIALIZE TRANSPORT INSTANCE HERE

    instance->Name = NEW_TYPE_ARRAY( (length + 1), WCHAR );
    if (instance->Name == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }
    wcscpy( instance->Name, pszTransportDN );

    MEMORY_CHECK_ALL();

    // ************************************************************************

    // Create event to signal shutdown.
    instance->hShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == instance->hShutdownEvent) {
        status = GetLastError();
        DPRINT1(0, "Failed to create shutdown event, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    // Open connection to directory service
    status = DirOpenConnection( &instance->DirectoryConnection );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Make sure key exists
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }

    // Start monitoring for routing changes
    status = DirStartNotifyThread( instance );
    if (status != ERROR_SUCCESS) {
        LogUnhandledError( status );
        goto cleanup;
    }
    fNotifyInit = TRUE;

    hr = SmtpInitialize( instance );
    if (FAILED(hr)) {
        status = hr;
        // Event already logged
        goto cleanup;
    }
    fSmtpInit = TRUE;

    MEMORY_CHECK_ALL();

    // Insert this instance into the list.

    // Note that, assuming the ISM service is functioning correctly, this list
    // cannot contain duplicates (where "duplicate" is defined as an entry with
    // the same DN).
    
    EnterCriticalSection(&TransportListLock);
    __try {
        InsertTailList( &TransportListHead, &(instance->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    // Start a listener thread for this instance
    // Note, make sure instance fully initialized before starting this thread
    // Note, instance cannot be destroyed until thread is stopped
    instance->ListenerThreadHandle = (HANDLE)
        _beginthreadex(NULL, 0, SmtpRegistryNotifyThread, instance, 0,
                       &instance->ListenerThreadID);
    if (NULL == instance->ListenerThreadHandle) {
        status = _doserrno;
        Assert(status);
        DPRINT1(0, "Failed to create listener thread, error %d.\n", status);
        LogUnhandledError( status );
        goto cleanup;
    }

    InterlockedIncrement( &(instance->ReferenceCount) );  // 1 for the lifetime of this transport

    *phIsm = instance;

    MEMORY_CHECK_ALL();

    return ERROR_SUCCESS;

cleanup:

    instance->fShutdownInProgress = TRUE;

    if (fNotifyInit) {
        (void) DirEndNotifyThread( instance );
    }

    if (fSmtpInit) {
        (void) SmtpTerminate( instance, FALSE /* not removal */ );
    }

    if (instance->DirectoryConnection) {
        (void) DirCloseConnection( instance->DirectoryConnection );
    }

    if (instance->hShutdownEvent != NULL) {
        CloseHandle( instance->hShutdownEvent );
    }

    if (instance->Name != NULL) {
        FREE_TYPE( instance->Name );
    }
    Assert( instance->ReferenceCount == 0 );
    FREE_TYPE(instance);

    MEMORY_CHECK_ALL();

    return status;
}

DWORD
IsmRefresh(
    IN  HANDLE          hIsm,
    IN  ISM_REFRESH_REASON_CODE eReason,
    IN  LPCWSTR         pszObjectDN              OPTIONAL
    )
/*++

Routine Description:

    Called whenever changes occur to the Inter-Site-Transport object specified
    in the IsmStartup() call.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    eReason (in) - Reason for refresh

    pszObjectDN (IN) - DN of the Inter-Site-Transport object.  This is
        guaranteed to be the same as the DN passed in IsmStartup, as inter-site
        transport objects cannot be renamed.

Return Values:

    0 or Win32 error code.

--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status, oldReplInterval, oldOptions;

    ENTER_CALL();

    DPRINT2( 1, "IsmRefresh, reason = %d, new name = %ws\n",
             eReason,
             pszObjectDN ? pszObjectDN : L"not supplied" );

    if (instance->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if ( (eReason == ISM_REFRESH_REASON_RESERVED) ||
         (eReason >= ISM_REFRESH_REASON_MAX) ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // If a site changed in any way, just invalidate the cache

    if (eReason == ISM_REFRESH_REASON_SITE) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
        status = ERROR_SUCCESS;
        goto cleanup;
    }

    Assert( eReason == ISM_REFRESH_REASON_TRANSPORT );

    // Inter-site transport objects cannot be renamed.
    Assert((pszObjectDN == NULL)
           || (0 == _wcsicmp(pszObjectDN, instance->Name)));

    oldOptions = instance->Options;
    oldReplInterval = instance->ReplInterval;

    // Reread parameters from the registry 
    status = DirReadTransport( instance->DirectoryConnection, instance );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if ( ( oldOptions != instance->Options) ||
         ( oldReplInterval != instance->ReplInterval ) ) {
        // Invalidate connectivity cache
        RouteInvalidateConnectivity( instance );
    }

cleanup:

    EXIT_CALL();

    return status;
}


DWORD
IsmSend(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszRemoteTransportAddress,
    IN  LPCWSTR         pszServiceName,
    IN  const ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Send a message over this transport.

    The local message is implementated as four segments:
    1. Length of service, 4 bytes
    2. Service name itself, terminated, unicode
    3. Length of data, 4 bytes
    4. Data itself

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszRemoteTransportAddress (IN) - Transport address of the destination
        server.

    pszServiceName (IN) - Name of the service on the remote machine that is the
        intended receiver of the message.

Return Values:

    0 or Win32 error code.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD status;

    ENTER_CALL();

    DPRINT2( 1, "IsmSend, address = %ws, service = %ws\n",
            pszRemoteTransportAddress, pszServiceName);

    // Validate arguments

    if ( (transport->Size != sizeof( TRANSPORT_INSTANCE )) ||
         (pszServiceName == NULL) ||
         (*pszServiceName == L'\0') ||
         (pMsg == NULL) ||
         (pMsg->cbData == 0) ||
         (pMsg->pbData == NULL) ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call
    __try {
        status = SmtpSend(transport,
                          pszRemoteTransportAddress,
                          pszServiceName,
                          pMsg);
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

cleanup:

    EXIT_CALL();

    return status;
}


DWORD
IsmReceive(
    IN  HANDLE          hIsm,
    IN  LPCWSTR         pszServiceName,
    OUT ISM_MSG **      ppMsg
    )
/*++

Routine Description:

    Return the next waiting message (if any).  If no message is waiting, a NULL
    message is returned.  If a non-NULL message is returned, the ISM service
    is responsible for calling IsmFreeMsg(*ppMsg) when the message is no longer
    needed.

    If a non-NULL message is returned, it is immediately dequeued.  (I.e., once
    a message is returned through IsmReceive(), the transport is free to destroy
    it.)

    This routine is pretty simple.  It finds the service, and dequeues a message
    if there is any.  Queue the message is done by the listener thread behind
    the scenes.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppMsg (OUT) - On successful return, holds a pointer to the received message
        or NULL.

Return Values:

    0 or Win32 error code.

--*/
{
    DWORD status;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT1( 2, "IsmReceive, service name = %ws\n", pszServiceName );

    // Validate arguments

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (ppMsg == NULL) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call
    __try {
        status = SmtpReceive(transport, pszServiceName, ppMsg);
    } __finally {
        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
    }

    DPRINT1( 2, "IsmReceive, size = %d\n", *ppMsg ? (*ppMsg)->cbData : 0 );

cleanup:

    EXIT_CALL();

    return status;
}


void
IsmFreeMsg(
    IN  HANDLE          hIsm,
    IN  ISM_MSG *       pMsg
    )
/*++

Routine Description:

    Frees a message returned by IsmReceive().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pMsg (IN) - Message to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE instance = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT1( 1, "IsmFreeMsg, size = %d\n", pMsg->cbData );

    // Validate arguments

    if ( (instance != NULL) &&
         (instance->Size != sizeof( TRANSPORT_INSTANCE )) ) {
        // error: invalid parameter
        Assert( FALSE );
        goto cleanup;
    }

    SmtpFreeMessage( pMsg );

cleanup:

    EXIT_CALL();

}

DWORD
IsmGetConnectivity(
    IN  HANDLE                  hIsm,
    OUT ISM_CONNECTIVITY **     ppConnectivity
    )
/*++

Routine Description:

    Compute the costs associated with transferring data amongst sites.

    On successful return, the ISM service will eventually call
    IsmFreeConnectivity(hIsm, *ppConnectivity);

    The transport has associated with it some lingering state.  The matrix of
    schedules is notfreed at the end of this routine.  It remains, tied to
    the transport handle, for the benefit of the GetConnectionSchedule api.

    There is no time-based caching of this information.  Each time this routine
    is called, theinformation is regnerated.  GetConnectionSchedule api uses the
    matrix of schedules from the last time this call was made, regardless of
    time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    ppConnectivity (OUT) - On successful return, holds a pointer to the
        ISM_CONNECTIVITY structure describing the interconnection of sites
        along this transport.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, numberSites, i;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PWSTR *pSiteList;
    PISM_LINK pLinkArray;
    PISM_CONNECTIVITY pConnectivity;

    DPRINT( 1, "IsmGetConnectivity\n" );

    ENTER_CALL();
    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Validate
        if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
            status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (transport->fShutdownInProgress) {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            __leave;
        }

        // Get the site list and connectivity matrix

        status = RouteGetConnectivity( transport,
                                       &numberSites,
                                       &pSiteList,
                                       &pLinkArray,
                                       transport->Options,
                                       transport->ReplInterval );
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "failed to get connectivity, error %d\n", status );
            __leave;
        }

        // Return null structure to indicate no sites
        if (numberSites == 0) {
            ppConnectivity = NULL; // No connectivity
            status = ERROR_SUCCESS;
            __leave;
        }

        Assert( pLinkArray );
        Assert( pSiteList );

        // Build a connectivity structure to return

        pConnectivity = NEW_TYPE( ISM_CONNECTIVITY );
        if (pConnectivity == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM CONNECTIVITY\n" );
            
            DirFreeSiteList( numberSites, pSiteList );
            RouteFreeLinkArray( transport, pLinkArray );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pConnectivity->cNumSites = numberSites;
        pConnectivity->ppSiteDNs = pSiteList;
        pConnectivity->pLinkValues = pLinkArray;
        *ppConnectivity = pConnectivity;

        status = ERROR_SUCCESS;
    } __finally {

        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
        EXIT_CALL();
    }

    return status;
}

void
IsmFreeConnectivity(
    IN  HANDLE              hIsm,
    IN  ISM_CONNECTIVITY *  pConnectivity
    )
/*++

Routine Description:

    Frees the structure returned by IsmGetConnectivity().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSiteConnectivity (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeConnectivity\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        goto cleanup;
    }

    if (pConnectivity == NULL) {
        goto cleanup;
    }

    // Free individual components

    if (pConnectivity->cNumSites > 0) {
        DirFreeSiteList( pConnectivity->cNumSites, pConnectivity->ppSiteDNs );

        RouteFreeLinkArray( transport, pConnectivity->pLinkValues );
    }

    FREE_TYPE( pConnectivity );

cleanup:

    EXIT_CALL();
}

DWORD
IsmGetTransportServers(
    IN  HANDLE               hIsm,
    IN  LPCWSTR              pszSiteDN,
    OUT ISM_SERVER_LIST **   ppServerList
    )
/*++

Routine Description:

    Retrieve the DNs of servers in a given site that are capable of sending and
    receiving data via this transport.

    On successful return of a non-NULL list, the ISM service will eventually
    call IsmFreeTransportServers(hIsm, *ppServerList);

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSiteDN (IN) - Site to query.

    ppServerList - On successful return, holds a pointer to a structure
        containing the DNs of the appropriate servers or NULL.  If NULL, any
        server with a value for the transport address type attribute can be
        used.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PISM_SERVER_LIST pIsmServerList;
    DWORD numberServers, status, i;
    PWSTR *serverList;

    DPRINT1( 1, "IsmGetTransportServers, site = %ws\n", pszSiteDN );

    ENTER_CALL();
    InterlockedIncrement( &(transport->ReferenceCount) );  // 1 for this call

    __try {
        // Validate

        if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
            status = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (transport->fShutdownInProgress) {
            status = ERROR_SHUTDOWN_IN_PROGRESS;
            __leave;
        }

        // Get the server list

        status = DirGetSiteBridgeheadList( transport, transport->DirectoryConnection,
                                           pszSiteDN, &numberServers, &serverList );
        if (status != ERROR_SUCCESS) {

            if (status == ERROR_FILE_NOT_FOUND) {
                *ppServerList = NULL; // All servers
                status = ERROR_SUCCESS;
                __leave;
            }

            DPRINT1( 0, "failed to get registry server list, error = %d\n", status );
            __leave;
        }

        // Return null structure to indicate no servers
        if (numberServers == 0) {
            *ppServerList = NULL; // All servers
            status = ERROR_SUCCESS;
            __leave;
        }

        // Construct the server structure

        pIsmServerList = NEW_TYPE( ISM_SERVER_LIST );
        if (pIsmServerList == NULL) {
            DPRINT( 0, "failed to allocate memory for ISM SERVER LIST\n" );

            // Clean up the pieces
            for( i = 0; i < numberServers; i++ ) {
                FREE_TYPE( serverList[i] );
            }
            FREE_TYPE( serverList );

            status = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        pIsmServerList->cNumServers = numberServers;
        pIsmServerList->ppServerDNs = serverList;

        *ppServerList = pIsmServerList;

        status = ERROR_SUCCESS;

    } __finally {

        InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for this call
        EXIT_CALL();

    }
    return status;
}

void
IsmFreeTransportServers(
    IN  HANDLE              hIsm,
    IN  ISM_SERVER_LIST *   pServerList
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pServerList (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    DWORD i;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeTransportServers\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
// error: invalid parameter
        goto cleanup;
    }

    if (pServerList == NULL) {
        goto cleanup;
    }

    // Free individual components

    if ( (pServerList->cNumServers != 0) && (pServerList->ppServerDNs != NULL) ) {
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            FREE_TYPE( pServerList->ppServerDNs[i] );
        }
        FREE_TYPE( pServerList->ppServerDNs );
    }

    FREE_TYPE( pServerList );

cleanup:

    EXIT_CALL();
}

DWORD
IsmGetConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  LPCWSTR             pszSite1DN,
    IN  LPCWSTR             pszSite2DN,
    OUT ISM_SCHEDULE **     ppSchedule
    )

/*++

Routine Description:

    Retrieve the schedule by which two given sites are connected via this
    transport.

    On successful return, it is the ISM service's responsibility to eventually
    call IsmFreeSchedule(*ppSchedule);

    The transport has associated with it some lingering state.  The matrix of
    schedules is not freed at the end of this routine.  It remains, tied to the
    transport handle, for the benefit of the GetConnectionSchedule api.

    There is no time-based caching of this information.  Each time the get conn
    routine is called, the information is regnerated.  GetConnectionSchedule api
    uses the matrix of schedules from the last time this call was made,
    regardless of time.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pszSite1DN, pszSite2DN (IN) - Sites to query.

    ppSchedule - On successful return, holds a pointer to a structure
        describing the schedule by which the two given sites are connected via
        the transport, or NULL if the sites are always connected.

Return Values:

    NO_ERROR - Success.
    ERROR_* - Failure.

--*/
{
    DWORD status, length;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    PBYTE pSchedule;

    ENTER_CALL();

    DPRINT2( 1, "IsmGetConnectionSchedule, site1 = %ws, site2 = %ws\n",
            pszSite1DN, pszSite2DN );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (transport->fShutdownInProgress) {
        status = ERROR_SHUTDOWN_IN_PROGRESS;
        goto cleanup;
    }

    status = RouteGetPathSchedule( transport,
                                     pszSite1DN,
                                     pszSite2DN,
                                     &pSchedule,
                                     &length );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    if (pSchedule == NULL) {
        *ppSchedule = NULL; // always connected
    } else {
        *ppSchedule = NEW_TYPE( ISM_SCHEDULE );
        if (*ppSchedule == NULL) {
            FREE_TYPE( pSchedule );
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        (*ppSchedule)->cbSchedule = length;
        (*ppSchedule)->pbSchedule = pSchedule;
    }

    status = ERROR_SUCCESS;
cleanup:

    EXIT_CALL();

    return status;
}

void
IsmFreeConnectionSchedule(
    IN  HANDLE              hIsm,
    IN  ISM_SCHEDULE *      pSchedule
    )

/*++

Routine Description:

    Frees the structure returned by IsmGetTransportServers().

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().

    pSchedule (IN) - Structure to free.

Return Values:

    None.

--*/
{
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;

    ENTER_CALL();

    DPRINT( 1, "IsmFreeConnectionSchedule\n" );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
// error: invalid parameter
        goto cleanup;
    }

    if (pSchedule == NULL) {
        goto cleanup;
    }

    Assert( pSchedule->cbSchedule != 0 );
    Assert( pSchedule->pbSchedule );

    FREE_TYPE( pSchedule->pbSchedule );

    pSchedule->pbSchedule = NULL;
    pSchedule->cbSchedule = 0;

    FREE_TYPE( pSchedule );

cleanup:

    EXIT_CALL();
}

void
IsmShutdown(
    IN  HANDLE          hIsm,
    IN  ISM_SHUTDOWN_REASON_CODE eReason
    )
/*++

Routine Description:

    Uninitialize transport plug-in.

Arguments:

    hIsm (IN) - Handle returned by a prior call to IsmStartup().
    eReason (IN) - Reason for shutdown

Return Values:

    None.

--*/
{
    DWORD               status;
    DWORD               waitStatus;
    PTRANSPORT_INSTANCE transport = (PTRANSPORT_INSTANCE) hIsm;
    LONG count;

    DPRINT1( 1, "IsmShutdown, Reason %d\n", eReason );

    // Validate

    if (transport->Size != sizeof( TRANSPORT_INSTANCE )) {
        // error: invalid parameter
        return;
    }

    transport->fShutdownInProgress = TRUE;

    SetEvent(transport->hShutdownEvent);

    // Shutdown the listener thread
    // Note, shut this down before invalidating the instance

    waitStatus = WaitForSingleObject(transport->ListenerThreadHandle, 5*1000);
    if ( (WAIT_OBJECT_0 != waitStatus) &&
         (WAIT_TIMEOUT != waitStatus) ) {
        status = GetLastError();
        DPRINT3(0, "Shutdown failed, wait status=%d, GLE=%d, TID=0x%x.\n",
                waitStatus, status, transport->ListenerThreadID);
    }

    // If calls in progress, give them a chance to finish
    // The service and rpc should guarantee that this entrypoint is
    // not called while calls are in progress. I suspect this is not
    // always true.  Be defensive.

    if (CALLS_IN_PROGRESS()) {
        Sleep( 5 * 1000 );
    }

    // Remove this instance from the list.
    EnterCriticalSection(&TransportListLock);
    __try {
        RemoveEntryList( &(transport->ListEntry) );
    }
    __finally {
        LeaveCriticalSection(&TransportListLock);
    }

    // Release any routing state
    RouteFreeState( transport );

    DeleteCriticalSection( &(transport->Lock) );

    if (NO_CALLS_IN_PROGRESS()) {
        // Clean up only if all calls complete
        (void) SmtpTerminate( transport, (eReason == ISM_SHUTDOWN_REASON_REMOVAL) );
    } else {
        Assert( FALSE && "calls in progress did not exit" );
    }

    DirEndNotifyThread( transport );

    count = InterlockedDecrement( &(transport->ReferenceCount) );  // 1 for the lifetime of this transport

    if (count == 0) {
        // Clean up only if thread is finished

        // Close connection to directory
        status = DirCloseConnection( transport->DirectoryConnection );
        // ignore error

        CloseHandle( transport->hShutdownEvent );
        transport->hShutdownEvent = NULL;

        // RUNDOWN TRANSPORT INSTANCE HERE

        transport->Size = 0; // clear signature to prevent reuse
        
        FREE_TYPE( transport->Name );
        FREE_TYPE( transport );

        // RUNDOWN TRANSPORT INSTANCE HERE
    } else {
        DPRINT2( 0, "Transport %ws not completely shutdown, %d references still exist.\n",
                 transport->Name, count );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\table.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    table.c

Abstract:

    Subject table routines

// The following helper routines are used with the link list package to create
// a hierarchy of lists to keep track of subjects strings

This lookaside list represents our recent history of messages that were sent.  We
want the list large enough to hold all the messages sent during a retry interval.
That way if we come to the next interval and we find that we have already sent
this subject before, we will tag it with the guid of the original message and
the mail system can filter it out.
How many is enough?
(number ncs) x (2 types [req/resp]) x (4 flags variations)
64 x 2 x 4 = 512
The only drawback with making the list very large is that the only way it is cleared
is when new items push older items out the end.  So when things are not backed up
you end up searching this long history each time you send.

Author:

    Will Lees (wlees) 10-May-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <ismapi.h>
#include <debug.h>

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include <ntrtl.h>                      // Generic table package

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_XMITRECV

#include "common.h"
#include "ismsmtp.h"

#define DEBSUB "SMTPTAB:"

#define MAXIMUM_SEND_SUBJECT_ENTRIES 512

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Tue May 11 14:36:11 1999 */

PVOID NTAPI
tableAllocate(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    );

VOID NTAPI
tableFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );

PSUBJECT_INSTANCE
subjectEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    );

VOID
subjectEntryFree(
    PSUBJECT_INSTANCE pSubject
    );

PSUBJECT_INSTANCE
LookupInsertSubjectEntry(
    IN PTARGET_INSTANCE pTarget,
    IN LPCWSTR pszMessageSubject
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
subjectTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

VOID
subjectTableDestroy(
    RTL_GENERIC_TABLE *pSubjectTable
    );

PTARGET_INSTANCE
targetEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    );

VOID
targetEntryFree(
    PTARGET_INSTANCE pTarget
    );

PTARGET_INSTANCE
LookupInsertTargetEntry(
    RTL_GENERIC_TABLE *pTargetTable,
    IN  LPCWSTR pszRemoteTransportAddress
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
targetTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

VOID
targetTableDestroy(
    RTL_GENERIC_TABLE *pTargetTable
    );

DWORD __cdecl
serviceConstruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    );

DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE  *  ppSubject
    );

RTL_GENERIC_COMPARE_RESULTS NTAPI
guidTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    );

VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    );

BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    );

/* End Forward */











PVOID NTAPI
tableAllocate(
    struct _RTL_GENERIC_TABLE *Table,
    CLONG ByteSize
    )

/*++

Routine Description:

Memory allocation helper routine for use by Rtl Generic Table.

I am assuming the Rtl routine does the right think if you return null
out of here.

Arguments:

    Table - 
    ByteSize - 

Return Value:

    PVOID NTAPI - 

--*/

{
    return NEW_TYPE_ARRAY( ByteSize, CHAR );
} /* tableAllocate */


VOID NTAPI
tableFree(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    )

/*++

Routine Description:

Memory free helper routine for use by Rtl Generic Table.

Arguments:

    Table - 
    Buffer - 

Return Value:

    VOID NTAPI - 

--*/

{
    FREE_TYPE( Buffer );
} /* tableFree */
















PSUBJECT_INSTANCE
subjectEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    )

/*++

Routine Description:

Allocate a zero-initialized, correctly formatted subject instance.
The instance is variable sized, depending on the name.

Arguments:

    Name - Name of instance
    pdwInstanceSize - Returned total size of instance allocated

Return Value:

    PSUBJECT_INSTANCE - 

--*/

{
    PSUBJECT_INSTANCE pSubject;
    DWORD length = wcslen( Name ) + 1, size;
    size = sizeof( SUBJECT_INSTANCE ) + (length * sizeof( WCHAR ));

    pSubject = (SUBJECT_INSTANCE *) NEW_TYPE_ARRAY_ZERO( size, CHAR );
    if (pSubject == NULL) {
        DPRINT( 0, "subjectEntryCreate failed to allocate memory\n" );
        return NULL;
    }
    pSubject->NameLength = length;
    wcscpy( pSubject->Name, Name );
    *pdwInstanceSize = size;

    return pSubject;
} /* subjectEntryCreate */


VOID
subjectEntryFree(
    PSUBJECT_INSTANCE pSubject
    )

/*++

Routine Description:

Free a subject entry.

Arguments:

    pSubject - 

Return Value:

    None

--*/

{
    // There are no contained pointers to release

    FREE_TYPE( pSubject );
} /* subjectEntryFree */


PSUBJECT_INSTANCE
LookupInsertSubjectEntry(
    IN PTARGET_INSTANCE pTarget,
    IN LPCWSTR pszMessageSubject
    )

/*++

Routine Description:

Lookup a subject instance by name. The subject table and supporting variables
are the target instance passed in.

Arguments:

    pTarget - 
    pszMessageSubject - 

Return Value:

    PSUBJECT_INSTANCE - 

--*/

{
    PVOID pElement;
    PSUBJECT_INSTANCE pDummySubject = NULL;
    PSUBJECT_INSTANCE pSubject = NULL;
    DWORD subjectSize;
    BOOLEAN fNewElement;

    // Create an empty subject instance for matching purposes
    pDummySubject = subjectEntryCreate( pszMessageSubject, &subjectSize );
    if (pDummySubject == NULL) {
        return NULL;
    }

    // Lookup existing element or insert the new element in the table
    pElement = RtlInsertElementGenericTable(
        &(pTarget->SendSubjectTable),
        pDummySubject,
        subjectSize,
        &fNewElement );
    if (!pElement) {
        // Error, not created for some reason
        // pSubject is already NULL
        goto cleanup;
    }

    // Note, after the insertion, pElement points to the actual table member,
    // while pDummy is only a copy.
    pSubject = (PSUBJECT_INSTANCE) pElement;

    // See if it was in the table
    if (!fNewElement) {
        // pSubject is set to the found element
        goto cleanup;
    }

    // It wasn't in the table
    DPRINT2( 4, "subject entry create, %ws(%d)\n",
             pDummySubject->Name, pDummySubject->NameLength );

    // BEGIN Initialize SUBJECT instance
        
    // Link the element into the list as the newest element
    InsertHeadList( &(pTarget->SendSubjectListHead), &(pSubject->ListEntry) );

    // END Initialize SUBJECT instance



    // See if we need to get rid of oldest entry
    if (pTarget->NumberSendSubjectEntries == pTarget->MaximumSendSubjectEntries) {
        // Older entries at the end of the list
        PSUBJECT_INSTANCE pDeadSubject;
        PLIST_ENTRY pListEntry;
        BOOL found;

        pListEntry = RemoveTailList( &(pTarget->SendSubjectListHead) );
        pDeadSubject = CONTAINING_RECORD( pListEntry, SUBJECT_INSTANCE, ListEntry );

        DPRINT1( 4, "Deleting oldest subject: %ws\n", pDeadSubject->Name );

        found = RtlDeleteElementGenericTable(
            &(pTarget->SendSubjectTable),
            pDeadSubject );
        Assert( found );
        pDeadSubject = NULL;

        // The code giveth and the code taketh away
        // Entry count stays the same
    } else {
        (pTarget->NumberSendSubjectEntries)++;
    }

cleanup:
    if (pDummySubject) {
        subjectEntryFree( pDummySubject );
    }
    return pSubject;
} /* LookupInsertSubjectEntry */


RTL_GENERIC_COMPARE_RESULTS NTAPI
subjectTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table to compare two subject instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PSUBJECT_INSTANCE pFirstSubject = (PSUBJECT_INSTANCE) FirstStruct;
    PSUBJECT_INSTANCE pSecondSubject = (PSUBJECT_INSTANCE) SecondStruct;

    diff = pFirstSubject->NameLength - pSecondSubject->NameLength;
    if (diff == 0) {
        diff = wcscmp( pFirstSubject->Name, pSecondSubject->Name );
    }
    DPRINT5( 5, "Comparing %ws(%d) with %ws(%d) = %d\n",
             pFirstSubject->Name,
             pFirstSubject->NameLength,
             pSecondSubject->Name,
             pSecondSubject->NameLength,
             diff);

    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* subjectTableCompare */


VOID
subjectTableDestroy(
    RTL_GENERIC_TABLE *pSubjectTable
    )

/*++

Routine Description:

Deallocate all the elements of the table.

Arguments:

    pSubjectTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( pSubjectTable, TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( pSubjectTable, TRUE ) ) {
        PSUBJECT_INSTANCE pSubject = (PSUBJECT_INSTANCE) pElement;
        BOOLEAN found;

        DPRINT1( 4, "\t\tCleaning up subject %ws\n", pSubject->Name );
        found = RtlDeleteElementGenericTable( pSubjectTable, pElement );
        Assert( found );
    }
} /* subjectTableDestroy */


















PTARGET_INSTANCE
targetEntryCreate(
    LPCWSTR Name,
    LPDWORD pdwInstanceSize
    )

/*++

Routine Description:

Create a zero-initialized, properly formed target instance.  The target instance
is a variable length structure.

Arguments:

    Name - 
    pdwInstanceSize - Returned total byte count allocated

Return Value:

    PTARGET_INSTANCE - null on error

--*/

{
    PTARGET_INSTANCE pTarget;
    DWORD length = wcslen( Name ) + 1, size;
    size = sizeof( TARGET_INSTANCE ) + (length * sizeof( WCHAR ));

    pTarget = (TARGET_INSTANCE *) NEW_TYPE_ARRAY_ZERO( size, CHAR );
    if (pTarget == NULL) {
        DPRINT( 0, "targetEntryCreate failed to allocate memory\n" );
        return NULL;
    }
    pTarget->NameLength = length;
    wcscpy( pTarget->Name, Name );
    *pdwInstanceSize = size;

    return pTarget;
} /* targetEntryCreate */


VOID
targetEntryFree(
    PTARGET_INSTANCE pTarget
    )

/*++

Routine Description:

Free a target instance.

This routine should not be used to remove elements from the table.

Arguments:

    pTarget - 

Return Value:

    None

--*/

{
    // Secondary pointers not cleaned up here by design

    FREE_TYPE( pTarget );
} /* targetEntryFree */


PTARGET_INSTANCE
LookupInsertTargetEntry(
    RTL_GENERIC_TABLE *pTargetTable,
    IN  LPCWSTR pszRemoteTransportAddress
    )

/*++

Routine Description:

Lookup or instert a new target entry in the target table.

Arguments:

    pTargetTable - 
    pszRemoteTransportAddress - 

Return Value:

    PTARGET_INSTANCE - 

--*/

{
    PVOID pElement;
    PTARGET_INSTANCE pDummyTarget = NULL;
    PTARGET_INSTANCE pTarget = NULL;
    DWORD targetSize;
    BOOLEAN fNewElement;

    // Create a empty target instance for matching against
    pDummyTarget = targetEntryCreate( pszRemoteTransportAddress, &targetSize );
    if (pDummyTarget == NULL) {
        return NULL;
    }

    // Lookup or Insert the new element in the table
    pElement = RtlInsertElementGenericTable(
        pTargetTable,
        pDummyTarget,
        targetSize,
        &fNewElement );
    if (!pElement) {
        // Error, not created for some reason
        // pTarget is set to NULL already
        goto cleanup;
    }

    // Note, after the insertion, pElement points to the actual table member,
    // while pDummy is only a copy.
    pTarget = (PTARGET_INSTANCE) pElement;

    // Element was already in table
    if (!fNewElement) {
        // pTarget points to the found element
        goto cleanup;
    }

    // It wasn't in the table
    DPRINT1( 4, "target entry create, %ws\n", pDummyTarget->Name );

    // BEGIN Initialize empty TARGET instance
    pTarget->MaximumSendSubjectEntries = MAXIMUM_SEND_SUBJECT_ENTRIES;
    RtlInitializeGenericTable( &(pTarget->SendSubjectTable),
                               subjectTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );
    InitializeListHead( &(pTarget->SendSubjectListHead) );
    // END Initialize empty TARGET instance
        

cleanup:
    if (pDummyTarget) {
        targetEntryFree( pDummyTarget );
    }

    return pTarget;
} /* LookupInsertTargetEntry */


RTL_GENERIC_COMPARE_RESULTS NTAPI
targetTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table. Compare two target instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PTARGET_INSTANCE pFirstTarget = (PTARGET_INSTANCE) FirstStruct;
    PTARGET_INSTANCE pSecondTarget = (PTARGET_INSTANCE) SecondStruct;

    diff = pFirstTarget->NameLength - pSecondTarget->NameLength;
    if (diff == 0) {
        diff = wcscmp( pFirstTarget->Name, pSecondTarget->Name );
    }
    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* targetTableCompare */


VOID
targetTableDestroy(
    RTL_GENERIC_TABLE *pTargetTable
    )

/*++

Routine Description:

Destroy all the elements in the target table.

Arguments:

    pTargetTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( pTargetTable, TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( pTargetTable, TRUE ) ) {
        PTARGET_INSTANCE pTarget = (PTARGET_INSTANCE) pElement;
        BOOLEAN found;

        DPRINT1( 4, "\tCleaning up target %ws\n", pTarget->Name );

        subjectTableDestroy( &(pTarget->SendSubjectTable) );
        // number entries and list head now incoherent

        found = RtlDeleteElementGenericTable( pTargetTable, pElement );
        Assert( found );
    }

} /* targetTableDestroy */

















DWORD __cdecl
serviceConstruct(
    PLIST_ENTRY_INSTANCE pListEntry
    )

/*++

Routine Description:

Callback routine for the generic list package
Initializes a structure of type SERVICE_INSTANCE

Arguments:

    pListEntry - 

Return Value:

    DWORD - 

--*/

{
    PSERVICE_INSTANCE pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

    DPRINT1( 4, "serviceCreate %ws\n", pListEntry->Name );

    RtlInitializeGenericTable( &(pService->TargetTable),
                               targetTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );

    return ERROR_SUCCESS;
} /* serviceCreate */


DWORD __cdecl
SmtpServiceDestruct(
    PLIST_ENTRY_INSTANCE pListEntry
    )

/*++

Routine Description:

Callback routine for the generic list package.
Destroys a service instance

Arguments:

    None

Return Value:

    None

--*/

{
    PSERVICE_INSTANCE pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

    DPRINT1( 4, "serviceDestroy %ws\n", pListEntry->Name );

    targetTableDestroy( &(pService->TargetTable) );

    return ERROR_SUCCESS;
}



















DWORD
SmtpTableFindSendSubject(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    OUT PSUBJECT_INSTANCE  *  ppSubject
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pszMessageSubject - 
    ppSubject - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;
    PSERVICE_INSTANCE pService;
    PTARGET_INSTANCE pTarget;
    PLIST_ENTRY_INSTANCE pListEntry;

// First level search, look up service in service list
// This list is a linear linked list unsorted

    status = ListFindCreateEntry(
        serviceConstruct,
        SmtpServiceDestruct,
        sizeof( SERVICE_INSTANCE ),
        ISM_MAX_SERVICE_LIMIT,
        &(pTransport->ServiceListHead),
        &(pTransport->ServiceCount),
        pszServiceName,
        TRUE, // Create
        &(pListEntry) );
    if (status != ERROR_SUCCESS) {
        DPRINT2( 0, "Couldn't find/create service entry %ws, error %d\n",
                 pszServiceName, status );
        LogUnhandledError( status );
        goto cleanup;
    }
    pService = CONTAINING_RECORD( pListEntry, SERVICE_INSTANCE, ListEntryInstance );

// Second level search, look up target in target table

    pTarget = LookupInsertTargetEntry(
        &( pService->TargetTable ),
        pszRemoteTransportAddress
        );
    if (pTarget == NULL) {
        DPRINT1( 0, "Failed to allocate new target table entry for %ws\n",
                 pszRemoteTransportAddress);
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }

// Third level search: look up subject in subject table

    *ppSubject = LookupInsertSubjectEntry(
        pTarget,
        pszMessageSubject
        );
    if (*ppSubject == NULL) {
        DPRINT1( 0, "Failed to allocate new subject table entry for %ws\n",
                pszMessageSubject);
        status = ERROR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( status );
        goto cleanup;
    }

    status = ERROR_SUCCESS;

cleanup:

    return status;
} /* SmtpTableFindSendSubject */


RTL_GENERIC_COMPARE_RESULTS NTAPI
guidTableCompare(
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:

Helper routine for Rtl generic table to compare two guid instances.

Arguments:

    Table - 
    FirstStruct - 
    SecondStruct - 

Return Value:

    RTL_GENERIC_COMPARE_RESULTS NTAPI - 

--*/

{
    int diff;
    PGUID_ENTRY pFirstEntry = (PGUID_ENTRY) FirstStruct;
    PGUID_ENTRY pSecondEntry = (PGUID_ENTRY) SecondStruct;

    diff = memcmp( &(pFirstEntry->Guid), &(pSecondEntry->Guid), sizeof( GUID ) );
    if ( 0 == diff )
        return(GenericEqual);
    else if ( diff > 0 )
        return(GenericGreaterThan);

    return(GenericLessThan);
} /* guidTableCompare */


PGUID_TABLE 
SmtpCreateGuidTable(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    VOID - 

Return Value:

    PGUID_TABLE  - 

--*/

{
    PGUID_TABLE pGuidTable = NULL;

    pGuidTable = NEW_TYPE_ZERO( GUID_TABLE );
    if (pGuidTable == NULL) {
        goto cleanup;
    }

    // BEGIN Initialize guid table here
    RtlInitializeGenericTable( &(pGuidTable->GuidTable),
                               guidTableCompare,
                               tableAllocate,
                               tableFree,
                               NULL );
    // END Initialize guid table here

cleanup:
    return pGuidTable;
} /* SmtpCreateGuidTable */


VOID
SmtpDestroyGuidTable(
    PGUID_TABLE pGuidTable
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 

Return Value:

    None

--*/

{
    PVOID pElement;

    Assert( pGuidTable );

    // Note that we restart the enumeration each time through because the
    // table has changed as a result of the delete.
    for( pElement = RtlEnumerateGenericTable( &(pGuidTable->GuidTable), TRUE );
         pElement != NULL;
         pElement = RtlEnumerateGenericTable( &(pGuidTable->GuidTable), TRUE ) ) {
        BOOLEAN found;
        PGUID_ENTRY pGuidEntry = (PGUID_ENTRY) pElement;
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &(pGuidEntry->Guid), &pszUuid );
        DPRINT1( 4, "cleaning up guid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif

        found = RtlDeleteElementGenericTable( &(pGuidTable->GuidTable), pElement );
        Assert( found );
    }

    FREE_TYPE( pGuidTable );
} /* SmtpDestroyGuidTable */


BOOL
SmtpGuidPresentInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 
    pGuid - 

Return Value:

    BOOL - 

--*/

{
    PVOID pElement;
    GUID_ENTRY dummyEntry;

    ZeroMemory( &dummyEntry, sizeof( GUID_ENTRY ) );
    dummyEntry.Guid = *pGuid;

    pElement = RtlLookupElementGenericTable(
        &(pGuidTable->GuidTable),
        &dummyEntry );

    return (pElement != NULL);
} /* SmtpGuidPresentInTable */


BOOL
SmtpGuidInsertInTable(
    PGUID_TABLE pGuidTable,
    GUID *pGuid
    )

/*++

Routine Description:

    Description

Arguments:

    pGuidTable - 
    pGuid - 

Return Value:

    BOOL - 

--*/

{
    PVOID pElement;
    GUID_ENTRY dummyEntry;
    BOOLEAN fNewElement;

    ZeroMemory( &dummyEntry, sizeof( GUID_ENTRY ) );
    dummyEntry.Guid = *pGuid;

    pElement = RtlInsertElementGenericTable(
        &(pGuidTable->GuidTable),
        &dummyEntry,
        sizeof( GUID_ENTRY ),
        &fNewElement );

    return (pElement != NULL) && fNewElement;

} /* SmtpGuidInsertInTable */

/* end table.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\stdafx.cxx ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

//#include "stdafx.h"
#include "atlbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\xmitrecv.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    xmitrecv.cxx

ABSTRACT:

    Methods to support send and receive via SMTP for the Intersite Messaging
    service.

DETAILS:

CREATED:

    3/20/98     Jeff Parham (jeffparh)

REVISION HISTORY:

    Jul 17, 1998  Will Lees (wlees)
           Restructured and simplified to use CDO V2.
1. Use events as primary means of event notification (polling as backup)
2. Send message data in-line instead of an attachment
3. Combine polling and receiving routines into one

    Sep 3, 1998   wlees
          Added support for detecting and eliminating duplicate messages

    Oct 22, 1998
          Duplicate suppression, guid-based mail names

--*/

#include <ntdspchx.h>

#include <align.h>

#include <ismapi.h>
#include <debug.h>

#include <atlbase.h>          // cccomptr
#include "cdosys.h"
// Jun 8, 1999. #ifdef necessary until new headers checked in
#ifdef __cdo_h__
using namespace CDO;
#endif

// Logging headers.
// TODO: better place to put these?
typedef ULONG MessageId;
typedef ULONG ATTRTYP;
//#include "ntdsa.h"
//#include "taskq.h"                      // GetSecondsSince1601()
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dsconfig.h"                   // Get config param
#include <ntrtl.h>                      // Generic table package

#include <fileno.h>
#define  FILENO FILENO_ISMSERV_XMITRECV

#include "common.h"
#include "ismsmtp.h"
#include "support.hxx"

// This is actually a C fragment generated by the IDL compiler
// It contains some useful constants for calling CDO
#include "cdosys_i.c"

// Include the class id for the smtp sink so we can check for it
#include "smtpsink_i.c"

#define DEBSUB "XMITRECV:"

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define QUEUE_DIRECTORY L"Queue"
#define QUEUE_DIRECTORY_LEN (ARRAY_SIZE(QUEUE_DIRECTORY))

#define DROP_DIRECTORY L"Drop"
#define DROP_DIRECTORY_LEN (ARRAY_SIZE(DROP_DIRECTORY))

#define RCPT_TO_RULE L"RCPT TO="
#define RCPT_TO_RULE_LEN (ARRAY_SIZE(RCPT_TO_RULE))

// Format for the message subject.
#define USER_PREFIX L"_IsmService@"
#define USER_PREFIX_LEN (ARRAY_SIZE(USER_PREFIX) - 1)
#define SUBJECT_PREFIX      L"Intersite message for "
#define SUBJECT_PREFIX_LEN  (ARRAY_SIZE(SUBJECT_PREFIX) - 1)
#define SUBJECT_SEPARATOR L": "
#define SUBJECT_SEPARATOR_LEN  (ARRAY_SIZE(SUBJECT_SEPARATOR) - 1)
const WCHAR gszSubjectFormat[] =
SUBJECT_PREFIX L"%ls" SUBJECT_SEPARATOR L"%ls";
const DWORD gcchSubjectFormat = ARRAY_SIZE(gszSubjectFormat);

#define HR_SHARING_VIOLATION (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
#define HR_FILE_NOT_FOUND (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
#define HR_NOT_ENOUGH_MEMORY (HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))

#define SMTP_MSG_GUID cdoNSMailHeader L"X-MsgGuid"
#define SMTP_SUPERSEDES_MSG_GUID cdoNSMailHeader L"X-SupersedesMsgGuid"

// How frequently do we log an error if SMTP domain not available
#define NO_SMTP_DOMAIN_INTERVAL (24 * 60 * 60)  // Once a day

typedef LONGLONG DSTIME;

extern "C" {
// Return seconds since Jan 1, 1601.
DSTIME
GetSecondsSince1601( void );
}

// Forward

DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    );

// Static

static GUID zeroGuid = {0};


HRESULT
supersedeMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  LPCWSTR               pszMessageSubject,
    IN  IMessage *            pIMsg
    )

/*++

Routine Description:

This routine writes the necessary fields in the message so that it will supercede
a previous message with the same (service,address,subject).  This is done by
keeping keeping a circular list/cache of most recent triples, and associating
with the entry the guid of the last sent message.  On the first send, a new guid
is used.  On a second or later send, the previous guid is set for the
"supersede guid", and then a new guid is set in the cache.

Note that this cache is a performance optimization.  If an entry is bumped out
of the cache, it only means that we won't be able to regenerate the previous
supersede guid to suppress the previous message.  Under certain degenerate
circumstances (more than x services, more than y naming contexts), we will start
to drop entries out.

Note that we depend on the circular nature of the list at the subject level in
order to push out old subject entries.  We don't get feed back whether we were
successful. We depend on the fact that when communication in happening, new
subjects get inserted at the front and the old useless subjects get pushed out
the back. We limit the number of entries so we won't have to search so many each
time.  When communication isn't happening, we expect that the size of the circular
buffer is enough to contain all the unique subjects that are generated by the
application (hopefully small).  These limits can be adjusted.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pszMessageSubject - 
    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr;
    CComPtr<Fields> pFields;
    PSUBJECT_INSTANCE pSubject = NULL;

    // Look up the (Service, Address, Subject) triple
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        status = SmtpTableFindSendSubject(
            pTransport,
            pszRemoteTransportAddress,
            pszServiceName,
            pszMessageSubject,
            &pSubject
            );
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "failed to find subject cache, error 0x%x\n", status );
        hr = HRESULT_FROM_WIN32( status );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Now we have a pointer to a subject record, either new or previous

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // if guid is present, ie this is a retry, load the guid into the
    // supersedes guid filed
    if (memcmp( &(pSubject->Guid), &zeroGuid, sizeof(GUID) ) != 0) {
        DPRINT3( 1, "This message supersedes prior message: (%ws,%ws,%ws)\n",
                 pszServiceName,
                 pszRemoteTransportAddress,
                 pszMessageSubject );
        hr = putFieldGuid( pFields,
                           SMTP_SUPERSEDES_MSG_GUID,
                           &(pSubject->Guid) );
        if (FAILED(hr)) {
            DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Allocate a new guid, store in subject descriptor
    status = UuidCreate( &(pSubject->Guid) );
    if ( (status != RPC_S_OK) &&
         (status != RPC_S_UUID_LOCAL_ONLY) ) {
        DPRINT1( 0, "failed to create guid, error %d\n", status );
        LogUnhandledError( status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Load guid into message
    hr = putFieldGuid( pFields, SMTP_MSG_GUID, &(pSubject->Guid) );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to set field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pFields->Update();
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to update fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* supersedeMessage */


VOID
addRemoveSmtpSvc(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fIsSmtpSvcPresent
    )

/*++

Routine Description:

    Description

Arguments:

    pTransport - 
    fIsSmtpSvcPresent - 

Return Value:

    None

--*/

{
    DWORD status, tries, waitCode;

    if (fIsSmtpSvcPresent) {
        DPRINT( 1, "SMTPSVC is present\n" );

        // Even though SmtpSvc is installed, all the other necessary plumbing
        // to add a new domain (ADSI) support is not fully there.  Give the IIS
        // install a chance to finish
    
        for( tries = 0; tries < 40; tries++ ) {
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
    
            if (pTransport->fShutdownInProgress) {
                return;
            }

            if (SUCCEEDED( CheckSmtpDomainContainerPresent() )) {
                break;
            }
        }
    
        if (pTransport->fShutdownInProgress) {
            return;
        }
    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
                status = configureMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } else {
        // This is where we detect the SmtpSvc being uninstalled.
        
        DPRINT( 1, "SMTPSVC is absent\n" );
                    
        EnterCriticalSection( &(pTransport->Lock) );
        __try {
            if ( NULL != pTransport->Smtp.pszSmtpAddress ) {
                disableMailAddress( pTransport );
            }
        }
        __finally {
            LeaveCriticalSection( &(pTransport->Lock) );
        }

    } // if fIsSmtpSvcPresent

} /* addRemoveSmtpSvc */


unsigned __stdcall
SmtpRegistryNotifyThread(
    void *Argument1
    )

/*++

Routine Description:

Thread to wait for a registry notification that the Smtp Service
has been installed.  When we detect that the Smtp Service is present,
we configure our mail address so that we may receive mail.

This thread exits after the mail address has been set.

This thread uses closure of the registry hkey being monitored as a
single to terminate.  That way we don't need a separate event for
that purpose.

Arguments:

    Argument1 - Transport Instance

Return Value:

    void __cdecl - 

--*/

{
    TRANSPORT_INSTANCE *pTransport = (PTRANSPORT_INSTANCE) Argument1;
    DWORD status, waitCode;
    HKEY hKey = NULL;
    HANDLE hRegChange = NULL;
    HANDLE rghWaitHandles[2];
    BOOL fIsSmtpSvcPresentOldState, fIsSmtpSvcPresentNewState;

    DPRINT( 1, "SmtpRegistryNotifyThread is watching...\n" );

    InterlockedIncrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread

    __try {
        status = RegOpenKey(HKEY_LOCAL_MACHINE, 
                            "SYSTEM\\CurrentControlSet\\Services",
                            &hKey);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0, "failed to open services key, error %d\n",
                    status);
            LogUnhandledError(status);
            __leave;
        }

        hRegChange = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == hRegChange) {
            status = GetLastError();
            DPRINT1(0, "CreateEvent failed with %d\n", status);
            LogUnhandledError(status);
            __leave;
        }

        rghWaitHandles[0] = pTransport->hShutdownEvent;
        rghWaitHandles[1] = hRegChange;
        
        // Remember initial state
        fIsSmtpSvcPresentOldState = servicePresent("SmtpSvc");

        // Verify the proper settings on startup every time
        addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentOldState );


        // Wait in a loop watching for SmtpSvc either coming or going

        while (!pTransport->fShutdownInProgress) {
            // Register request for notification of registry change
            // This call does not wait.
            // Returns success on handle closure
            status = RegNotifyChangeKeyValue(hKey,
                                             TRUE, // bWatchSubkeys
                                             REG_NOTIFY_CHANGE_NAME,
                                             hRegChange,
                                             TRUE // fAsynchronous
                                             );
            if (status != ERROR_SUCCESS) {
                DPRINT1( 0, "RegNotifyChangeValue returned %d\n", status );
                LogUnhandledError( status );
                __leave;
            }

            // Wait for shutdown or a change in the Services portion of the
            // registry.
            waitCode = WaitForMultipleObjects(ARRAY_SIZE(rghWaitHandles),
                                              rghWaitHandles,
                                              FALSE,
                                              INFINITE);
            switch (waitCode) {
            case WAIT_OBJECT_0:
                // Shutdown was signalled; bail.
                __leave;

            case WAIT_OBJECT_0 + 1:
                // Services registry change; loop back to the top.
                break;

            case WAIT_FAILED:
            default:
                // Unexpected error return; log and bail.
                status = GetLastError();
                LogUnhandledError(waitCode);
                LogUnhandledError(status);
                __leave;
            }

            fIsSmtpSvcPresentNewState = servicePresent("SmtpSvc"); 

            if (fIsSmtpSvcPresentOldState != fIsSmtpSvcPresentNewState) {

                addRemoveSmtpSvc( pTransport, fIsSmtpSvcPresentNewState );

                fIsSmtpSvcPresentOldState = fIsSmtpSvcPresentNewState;

            } // If OldState != NewState 

        } // while ! shutdown

    } __finally {
        DPRINT( 1, "SmtpRegistryNotifyThread exit\n" );

        if (NULL != hRegChange) {
            CloseHandle(hRegChange);
        }

        if (NULL != hKey) {
            RegCloseKey(hKey);
        }

        InterlockedDecrement( (PLONG) &(pTransport->ReferenceCount) );  // 1 for this thread
    }

    if (pTransport->fShutdownInProgress) {
        // Normal thread termination.
        status = 0;
    }

    return status;
} /* SmtpRegistryNotifyThread */


DWORD
configureMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

This routine initializes the mail address for this server, and prepares the
SMTP server to receive mail on this system.

This routine does nothing if SMTP is not installed.

This routine performs several functions:
1. Generates a mail address for this server and writes it to the mailAddress
attribute if necessary
2. Initializes the transport mail address
3. Adds the Smtp mail routing domain for the guid-based name on this server
4. Register the event sink dll as a COM dll if necessary
5. Bind the event sink to SMTP/CDO

The administrator is no longer required to manually assign a mail address for
the server.  This is created automatically based on the guid-based name of the
server.

Arguments:

    pTransport - The Smtp.pszSmtpAddress field in the transport is updated

Return Value:

    DWORD - success if smtp not installed, otherwise
       hresult error if anything goes wrong

--*/

{
    HRESULT hr;
    DWORD status;
    LPWSTR pszDomain, pszOfficialMailAddress = NULL;
    BOOL fIsGuidBasedName = FALSE;
    BOOL fMailAddressSyntaxIsBad = FALSE;
    LPWSTR pwzRule = NULL;
    BSTR bstrRule = NULL;

    Assert( NULL == pTransport->Smtp.pszSmtpAddress );
    Assert( OWN_CRIT_SEC(pTransport->Lock) );

    if (pTransport->fShutdownInProgress) {
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }

    // SMTP must be installed (not nec. running) in order to set up
    if ( (!servicePresent("SmtpSvc")) ||
         (!servicePresent("IisAdmin")) ) {
        DPRINT( 1, "Dependent services not present, SMTP not configured.\n" );

        hr = S_OK;
        goto cleanup;
    }

    // SMTP administrative namespace must be available
    // If this fails, either IIS is disabled, or misconfigured
    // Warn the administrator infrequently
    if (FAILED(hr = CheckSmtpDomainContainerPresent())) {
        static DSTIME timeLastFailureLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastFailureLogged)
            || (timeCurrent > (timeLastFailureLogged + NO_SMTP_DOMAIN_INTERVAL))) {
            // Log event to alert admin that we have no domain.
            timeLastFailureLogged = timeCurrent;
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_NO_SMTP_DOMAIN,
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
        }

        DPRINT1( 0, "Smtp Domain configuration not available, error 0x%x, SMTP not configured.\n",
                hr);

        hr = S_OK;
        goto cleanup;
    }

    // This check was needed before CDO was a regular part of the NT build.
    // CDOSYS.DLL sanity check. This dll should always be present
    if ( (!classPresent( &CLSID_Message )) ||
         (!classPresent( &CLSID_Configuration )) ||
         (!classPresent( &CLSID_DropDirectory )) ) {

        DPRINT(0,"One or more CDO classes not found - CDO not registered\n" );

        hr = REGDB_E_CLASSNOTREG;
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_CDO_CLASS_MISSING,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    // Calculate official mail address
    status = DirGetServerSmtpAttributes( pTransport, &pszOfficialMailAddress );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to get server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // See if we have a mail address attribute already set
    status = DirReadServerSmtpAttributes( pTransport );
    if (status != ERROR_SUCCESS) {
        // Error already logged
        DPRINT1( 0, "failed to read server mail address, error %d\n",
                 status );
        hr = HRESULT_FROM_WIN32( status );
        goto cleanup;
    }

    // Check if it is a guid-based name and syntax is correct
    if (pTransport->Smtp.pszSmtpAddress) {
#define UUID_STRING_LENGTH 36
        LPWSTR p1, p2;
        DWORD length;
        WCHAR szServerUuid[UUID_STRING_LENGTH + 1];
        UUID uuidServer;

        p1 = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (p1) {
            p1++;
            p2 = wcschr( p1, L'.' );
            if (p2) {
                length = (DWORD) (p2 - p1);
            } else {
                length = 0;
            }
        } else {
            fMailAddressSyntaxIsBad = TRUE;
            length = 0;
        }
        if (length == UUID_STRING_LENGTH) {
            wcsncpy(szServerUuid, p1, length);
            szServerUuid[length] = L'\0';
            status = UuidFromStringW(szServerUuid, &uuidServer);
            fIsGuidBasedName = (status == ERROR_SUCCESS);
        }
        // Check that addressee is correct
        if (!fMailAddressSyntaxIsBad) {
            fMailAddressSyntaxIsBad =
                (_wcsnicmp( pTransport->Smtp.pszSmtpAddress,
                            USER_PREFIX, USER_PREFIX_LEN ) != 0 );
        }
    }

    // If we don't, set one up
    // If we have an address, if it is guid-based, check that it is correct
    // Otherwise, leave the address alone.  This allows a user-provided
    // mail address to override the official form.
    if ( (!pTransport->Smtp.pszSmtpAddress) ||
         ( (fIsGuidBasedName || fMailAddressSyntaxIsBad) &&
           (_wcsicmp( pTransport->Smtp.pszSmtpAddress,
                      pszOfficialMailAddress ) != 0 ) ) ) {
        // This call writes the new address and makes it the default
        status = DirWriteServerSmtpAttributes( pTransport,
                                               pszOfficialMailAddress);
        if (status != ERROR_SUCCESS) {
            DPRINT1(0,"Failed to auto configure mail address, error %d\n",
                    status );
            // Error already logged
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else if (!pTransport->Smtp.pszSmtpAddress) {
            status = ERROR_INCORRECT_ADDRESS;
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        } else {
            DPRINT1( 1, "This server was assigned mail address %ws\n",
                     pTransport->Smtp.pszSmtpAddress );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_MAIL_ADDRESS,
                      szInsertWC(pTransport->Smtp.pszSmtpAddress ),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
    }

    // Make sure guid-based mail routing domain is known to SMTP

    pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
    if (pszDomain == NULL) {
        DPRINT1( 0, "Smtp address %ws is malformed\n",
                 pTransport->Smtp.pszSmtpAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto cleanup;
    }

    pszDomain++; // skip separator

    hr = AddSmtpDomainIfNeeded( pszDomain, pTransport->Smtp.bstrDropDirectory );
    if (FAILED(hr)) {
        DPRINT1( 0, "AddSmtpDomain failed with error 0x%x\n", hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DOMAIN_ADD_FAILURE,
                          szInsertWC(pszDomain),
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    // See if our event sink is already registered
    // Note that ismsink.dll has a registration dependency on seo.dll
    // This will only work if IIS is installed, which is implied by smtp check
    // TODO: how do we deregister when we demote?
    if (!classPresent( &CLSID_IsmSink1 )) {
        hr = registerInterfaceDll( "ismsink.dll", TRUE /* register */ );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to register ismsink.dll, error 0x%x\n", hr );
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_SMTP_SINK_REG_FAILURE,
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
            goto cleanup;
        } else {
            DPRINT( 1, "Successfully registered COM server ismsink.dll.\n" );
        }
    }

    // Create a filter rule to use with our binding
    // The rule is:
    //     RCPT TO=_IsmService@guid-based-domain
    // This will fire for mail addressed to us, and returned mail from the postmaster.
    // It will not fire for mail being routed through this system destined
    // for other servers

    pwzRule = NEW_TYPE_ARRAY(
        (DWORD)(RCPT_TO_RULE_LEN + wcslen( pTransport->Smtp.pszSmtpAddress ) + 1),
        WCHAR );
    if (pwzRule == NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    wcscpy( pwzRule, RCPT_TO_RULE );
    wcscat( pwzRule, pTransport->Smtp.pszSmtpAddress );
    bstrRule = SysAllocString( pwzRule );
    if (bstrRule == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Bind our event sink to SMTPSVC, if necessary
    // We check this everytime we start in case IIS has been removed and re-added
    // TODO: When do we call unbind?

    hr = HrIsmSinkBinding( TRUE /* register */, bstrRule );
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to bind event sink, error 0x%x\n", hr );
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_SINK_BIND_FAILURE,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr),
                          &hr );
        goto cleanup;
    }

    hr = S_OK;

cleanup:

    if (pwzRule) {
        FREE_TYPE( pwzRule );
    }
    if (bstrRule) {
        SysFreeString( bstrRule );
    }
    if (pszOfficialMailAddress) {
        FREE_TYPE( pszOfficialMailAddress );
    }

    if (FAILED(hr)) {
        if (NULL != pTransport->Smtp.pszSmtpAddress) {
            FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
            pTransport->Smtp.pszSmtpAddress = NULL;
        }
    }

    return hr;
} /* configureMailAddress */


VOID
removeMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Undo the effects of configureMailAddress.
    Cleanup permanent changes to environment prior to service removal

    Environment:

    fShutdownInProgress is TRUE
    CDO Messages have been released
    COM is still running
    pTransport is largely intact

    At the time this is running, LDAP is not available. We do not try to
    remove the transport specific mail address.  It is largely irrelevant
    now since if this server is being demoted, it will not have a NT-DSA
    object and will not be a subject for replication.

Arguments:

    pTransport - Transport state object

Return Value:

    None.

--*/

{
    HRESULT hr;
    LPWSTR pszDomain, pszEnd;
    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    BOOL fMoreFound, fFilesRemaining;
    WCHAR szFileName[MAX_PATH];

    // Remove the smtp domain (if configured)

    if (pTransport->Smtp.pszSmtpAddress) {
        pszDomain = wcschr( pTransport->Smtp.pszSmtpAddress, L'@' );
        if (pszDomain == NULL) {
            DPRINT1( 0, "Smtp address %ws is malformed\n",
                     pTransport->Smtp.pszSmtpAddress);
            hr = E_INVALIDARG;
            LogUnhandledError( hr );
        } else {
            pszDomain++; // Skip @
            hr = RemoveSmtpDomain( pszDomain );
            if (FAILED(hr)) {
                DPRINT1( 0, "RemoveSmtpDomain failed with error 0x%x\n", hr );
                LogEvent8WithData(DS_EVENT_CAT_ISM,
                                  DS_EVENT_SEV_ALWAYS,
                                  DIRLOG_ISM_SMTP_DOMAIN_REMOVE_FAILURE,
                                  szInsertWC(pszDomain),
                                  szInsertWin32Msg(hr),
                                  NULL, NULL, NULL, NULL, NULL, NULL,
                                  sizeof(hr),
                                  &hr );
                // Keep going
            } else {
                DPRINT1(0, "Removed Smtp Domain %ls\n", pszDomain );
            }
        }
    }

    // Remove any files in the Drop directory

    wcscpy( szFileName, pTransport->Smtp.bstrDropDirectory);
    pszEnd = szFileName + wcslen(pTransport->Smtp.bstrDropDirectory);
    *pszEnd++ = L'\\';

    wcscpy( pszEnd, L"*" );

    fFilesRemaining = FALSE;
    hFind = FindFirstFileW( szFileName, &FindFileData );
    if (hFind != INVALID_HANDLE_VALUE) {
        fMoreFound = TRUE;
        while ( fMoreFound ) {
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                wcscpy( pszEnd, FindFileData.cFileName );
                if (!DeleteFileW( szFileName )) {
                    DPRINT1(0, "Failed to delete %ls\n", szFileName );
                    fFilesRemaining = TRUE;
                    // We don't log this error
                } else {
                    DPRINT1(1, "Deleted %ls\n", szFileName );
                }
            }
            fMoreFound = FindNextFileW( hFind, &FindFileData );
        }
        FindClose(hFind);
    }

    // Remove the drop directory itself
    // Don't even try if the directory is not empty
    if ( !fFilesRemaining ) {
        if (!RemoveDirectoryW(pTransport->Smtp.bstrDropDirectory)) {
            DPRINT1(0, "Failed to delete directory %ls\n",
                    pTransport->Smtp.bstrDropDirectory);
        } else {
            DPRINT1(1, "Deleted %ls\n", pTransport->Smtp.bstrDropDirectory);
        }
    }

} /* removeMailAddress */


VOID
disableMailAddress(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

    Reset our configuration when SMTP service has been removed

    We leave the drop directory in place since this is tied to our service,
    not SMTPSVC.

    The SMTP domain registration was lost when SMTPSVC was deinstalled, so
    we don't try to remove it here.

    We need to handle the following removal scenarios
    1. We were configured, had a mail address attribute
    2. We are not configured, no mail address attribute
    3. We are not configured, lingering mail address attribute

    Removing the mail address attribute does not solve the problem. Without
    SMTP, there is no way for knowledge of the removal to replicate off the
    system.

Arguments:

    pTransport - 

Return Value:

    None

--*/

{
    // Mark ourselves as unconfigured so we will try again later

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
        pTransport->Smtp.pszSmtpAddress = NULL;
    }

    // Warn the user once at removal time

    LogEvent8(DS_EVENT_CAT_ISM,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
              NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

} /* disableMailAddress */


HRESULT
getDropDirectoryPath(
    BSTR *pbstrDropDirectory
    )

/*++

Routine Description:

Calculate the drop directory for the system and return it as a BSTR.
The drop directory is recalculated each startup according to the base
NTDS directories in the registry.
Here is the algorithm:
1. If the MAILPATH_KEY is present, it's value is used as an override
2. Otherwise we start with the LOGPATH_KEY.  We want the mail files to
follow the ntds files so they all stay together. The reason the mail files follow
the log and not the main database is that I figure they are both secondary,
supporting files to the main database.  Also, if the main database is
getting full, we want these files to migrate away as well.
2a. Prepend "Drop" as the subdirectory

Note that we expect these registry keys to only change between boots. You can
currently only change these keys during directory safe mode.

Arguments:

    pbstrDropDirectory - 

Return Value:

    HRESULT - 

--*/

{
    DWORD status;
    HRESULT hr, dwFileAttributes;
    WCHAR wzPath[MAX_PATH];

    Assert( pbstrDropDirectory );

    // Construct the drop directory path
    // It comes from the mail path key, or if not defined, from the concatenation
    // of the logging path and the name Drop
    if (GetConfigParamW( MAKE_WIDE(MAILPATH_KEY), wzPath, MAX_PATH)){
        if (status = GetConfigParamW( MAKE_WIDE(LOGPATH_KEY), wzPath, MAX_PATH)){
            DPRINT1( 0, "LOGPATH_KEY not present, error %d\n", status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
        wcscat( wzPath, L"\\" );
        wcscat( wzPath, DROP_DIRECTORY );
    }

    // Make sure it exists
    dwFileAttributes = GetFileAttributesW( wzPath );
    if (dwFileAttributes == 0xffffffff) {
        status = GetLastError();
        if ( (status == ERROR_FILE_NOT_FOUND) ||
             (status == ERROR_PATH_NOT_FOUND) ) {
            if (!CreateDirectoryW( wzPath, NULL )) {
                status = GetLastError();
                DPRINT2( 0, "CreateDirectory(%ws) failed, error %d\n", wzPath, status );
                hr = HRESULT_FROM_WIN32( status );
                goto cleanup;
            }
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_DROP_DIRECTORY,
                      szInsertWC(wzPath),
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        } else {
            status = GetLastError();
            DPRINT2( 0, "GetFileAttributes(%ws) failed, error %d\n", wzPath, status );
            hr = HRESULT_FROM_WIN32( status );
            goto cleanup;
        }
    } else if ( (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
        DPRINT1( 0, "File %ws already exists, but is not a directory!\n", wzPath );
        hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
        goto cleanup;
    }

    // Allocate a return string for it
    *pbstrDropDirectory = SysAllocString( wzPath );
    if (*pbstrDropDirectory == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto cleanup;
    }

    DPRINT1( 1, "This server is using drop directory %ws\n", wzPath );

    hr = S_OK;
cleanup:
    return hr;
} /* getDropDirectoryPath */


HRESULT
SmtpInitialize(
    IN  TRANSPORT_INSTANCE *  pTransport
    )

/*++

Routine Description:

Initialize the Smtp specific aspects of the transport.

In this case, initialize COM so that we can use CDO V2

This is called by the Startup() entry point.  If things are amiss, IsmServ
will unload the dll and log a message.

PERF: Create one long lived drop directory object for the life of the dll?

Arguments:

    pTransport - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BOOLEAN fComInit = FALSE;

// NOTE: This code must return success when SMTP not installed

    // Initialize COM for multi-threaded application
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( (hr != S_OK) && (hr != S_FALSE) ) {
        DPRINT1( 0, "CoInitializeEx failed with error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }
    fComInit = TRUE;

    // We no longer call configureMailAddress at this point because it takes
    // too long. It will be called the first time the Receive or Send entry
    // points are called.

    // Calculate the drop directory
    
    pTransport->Smtp.bstrDropDirectory = NULL;
    hr = getDropDirectoryPath( &(pTransport->Smtp.bstrDropDirectory) );
    if (FAILED(hr)) {
        DPRINT1(0, "Failed to get drop directory, error 0x%x.\n", hr);
        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DROP_DIR_MISSING,
                          szInsertWin32Msg(hr),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hr), &hr);
        goto cleanup;
    }

    hr = S_OK;
    fComInit = FALSE; // Don't clean this up

cleanup:

    if (fComInit) {
        CoUninitialize();
    }

    return hr;
} /* SmtpInitialize */


HRESULT
SmtpTerminate(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  BOOL                  fRemoval
    )

/*++

Routine Description:

    Terminate the smtp transport functions

Arguments:

    pTransport - Transport object
    fRemoval - Whether service is being removed

Return Value:

    HRESULT - 

--*/

{
    DPRINT( 1, "Enter SmtpTerminate\n" );

    if (NULL != pTransport->Smtp.pvCurrentCollection) {
        IMessages *pIMessages = (IMessages *)pTransport->Smtp.pvCurrentCollection;
        pIMessages->Release();
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
    }

    if (fRemoval) {
        DPRINT( 1, "Removal of ISMSERV/ISMSMTP requested.\n" );
        removeMailAddress( pTransport );
    }

    CoUninitialize();

    (VOID) ListDestroyList( SmtpServiceDestruct,
                            &(pTransport->ServiceListHead),
                            &(pTransport->ServiceCount) );

    if (NULL != pTransport->Smtp.pszSmtpAddress) {
        FREE_TYPE( pTransport->Smtp.pszSmtpAddress );
    }

    if (pTransport->Smtp.bstrDropDirectory) {
        SysFreeString( pTransport->Smtp.bstrDropDirectory );
    }

    if (pTransport->Smtp.pvGuidTable) {
        SmtpDestroyGuidTable( (PGUID_TABLE) pTransport->Smtp.pvGuidTable );
    }

    MEMORY_CHECK_ALL();

    DPRINT( 1, "Exit SmtpTerminate\n" );

    return S_OK;
} /* SmtpTerminate */


HRESULT
attachMessageData(
    IN OUT CComPtr<IMessage> pIMsg,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

    Attach the ISM message data.

Arguments:

    pIMsg - 
    pMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<_Stream> pStream;
    CComPtr<IBodyPart> pIBodyPart;
    VARIANT vBuffer;
    SAFEARRAY *psaData = NULL;

    // Allocate an array to describe the binary data
    hr = SafeArrayAllocDescriptor( 1, &psaData );
    if FAILED(hr) {
        DPRINT1(0, "Unable to SafeArrayAllocDescriptor, error 0x%x.\n", hr);
        LogUnhandledError( hr );
        goto exit;
    }

    // Initialize the array.  We construct the array manually so we can use
    // our own data which has been already allocated.
    psaData->cbElements = sizeof( char );
    psaData->pvData = pMsg->pbData;
    psaData->rgsabound[0].lLbound = 0;
    psaData->rgsabound[0].cElements = pMsg->cbData;

    // Set the body part options for binary data

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if FAILED(hr) {
        DPRINT1(0, "Unable to get_BodyPart, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentTransferEncoding(cdoBase64);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentTransferEncoding, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->put_ContentMediaType(cdoGif);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_ContentMediaType, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if FAILED(hr) {
        DPRINT1(0, "Unable to GetDecodedContentStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->put_Type(adTypeBinary);
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Type, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Write the binary data into the body
    VariantInit( &vBuffer );
    vBuffer.vt = VT_ARRAY | VT_UI1;
    vBuffer.parray = psaData;

    hr = pStream->Write(vBuffer);
    if FAILED(hr) {
        DPRINT1(0, "Unable to WriteStream, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    hr = pStream->Flush();
    if FAILED(hr) {
        DPRINT1(0, "Unable to Commit, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

exit:

    if (psaData != NULL) {
        HRESULT hr1;

        psaData->pvData = NULL;
        hr1 = SafeArrayDestroyDescriptor( psaData );
        if (FAILED(hr1)) {
            DPRINT1(0, "Unable to SafeArrayDestroyDescriptor, error 0x%x.\n", hr);
            LogUnhandledError( hr1 );
        }
    }

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* attachMessageData */


HRESULT
getDropMessages(
    BSTR bstrDropDirectory,
    IDropDirectory **ppIDropDir,
    IMessages **ppIMessages,
    LONG *pCount
    )

/*++

Routine Description:

Helper routine to initialize a drop directory object, get the message
collection, and get the count of messages.

Note, drop directory and message collection must be freed by the caller!

Arguments:

    ppIDropDir - Returned pointer to drop directory object
    ppIMessages - Return pointer to message collection
    pCount - Returned count of messgaes

Return Value:

    HRESULT - 

--*/

{
    HRESULT     hr;

    Assert( ppIDropDir );
    Assert( ppIMessages );
    Assert( *ppIDropDir == NULL );
    Assert( *ppIMessages == NULL );

    // Create the drop directory object
    hr = CoCreateInstance(CLSID_DropDirectory, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDropDirectory,
                          (void**) ppIDropDir);
    if (FAILED(hr)) {
        DPRINT1(0, "CoCreateInstance(DropDirectory) failed, error 0x%x\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get the object representing the list of all messages

    hr = (*ppIDropDir)->GetMessages(bstrDropDirectory, ppIMessages);
    if (FAILED(hr)) {
        DPRINT1(0, "getMessages() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    
    // Get count of messages

    *pCount = 0;
    hr = (*ppIMessages)->get_Count( pCount );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Count() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    DPRINT2( 1, "Found %d messages in the drop directory %ws\n",
             *pCount, bstrDropDirectory ? bstrDropDirectory : L"default" );

    return S_OK;

cleanup:

    if (*ppIMessages) {
        (*ppIMessages)->Release();
        *ppIMessages = NULL;
    }
    if (*ppIDropDir) {
        (*ppIDropDir)->Release();
        *ppIDropDir = NULL;
    }

    return hr;
} /* getDropMessages */


DWORD
SmtpSend(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszRemoteTransportAddress,
    IN  LPCWSTR               pszServiceName,
    IN  const ISM_MSG *       pMsg
    )

/*++

Routine Description:

   Send a message using the smtp transport.
   Message is sent as a binary blob.

   Our approach is to keep the dll running even when the smtp service is
   not running.  The dll can operate without the smtp
   service running since the CDO library only uses the file system for
   communication.

   We check for valid conditions when the ism server tries to use the dll
   for sending or receiving.

CDO provides three ways to send a message:
1. Send by pickup directory.  That is the default and what we are doing.  The
mail is actually "relayed", in the sense that it is received by here, queued,
and sent to the destination when possible.  Triggers OnArrival routine as
a mail receiption on localhost as well as ultimate destination host.
Benefit: if the destination is down, it will resend.
2. Send to local host and port.  Same as #1. The mail is received, queued, and
sent on when possible.
3. Send to destination host, using port number. The destination must be up.
OnArrival routine on triggered on destination.  No queuing on localhost.

Arguments:

    pTransport - 
    pszRemoteTransportAddress - 
    pszServiceName - 
    pMsg - 

Return Value:

    DWORD - 

--*/

{
    DWORD       status;
    HRESULT     hr;
    LPWSTR      pszSubject, pszMessageSubject, pszServer;
    DWORD       cchSubject;
    CComPtr<IMessage> pIMsg;
    BSTR bstrFrom = NULL, bstrTo = NULL, bstrSubj = NULL;

    if ( (!pTransport) ||
         (!pszRemoteTransportAddress) ||
         (!pszServiceName) ||
         (!pMsg) ) {
        status = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( status );
        return status;
    }

    DPRINT4( 1, "SmtpSend, addr = %ws, serv = %ws, subj = %ws, size = %d\n",
             pszRemoteTransportAddress,
             pszServiceName,
             pMsg->pszSubject,
             pMsg->cbData );

    MEMORY_CHECK_ALL();

    // If we don't have a mail address, try to auto configure
    // A mailAddress attribute has to have been written in order for the KCC
    // to have created a mail-based replica.
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if ( ( hr == S_OK ) &&
         ( NULL == pTransport->Smtp.pszSmtpAddress ) ) {
        // SMTP not installed
        hr = HRESULT_FROM_WIN32( ERROR_SERVICE_DOES_NOT_EXIST );
    }

    if (FAILED(hr)) {
        static DSTIME timeLastNoSmtpLogged = 0;
        DSTIME timeCurrent = GetSecondsSince1601();

        if ((timeCurrent < timeLastNoSmtpLogged)
            || (timeCurrent > (timeLastNoSmtpLogged + NO_SMTP_DOMAIN_INTERVAL))) {

            // Log event to alert admin we have no SMTP transport
            timeLastNoSmtpLogged = timeCurrent;
            DPRINT( 0, "Cannot send: SMTP transport not installed.\n" );
            LogEvent8(DS_EVENT_CAT_ISM,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        }
        return hr;
    }

    // CDO does not depend on any services to queue the message.
    // Some service needs to be running in order for the messages to get off
    // the machine.
    // That service could be SmtpSvc or Exchange

//***************************************************************************

    // Create an instance of the message object
    hr = CoCreateInstance(CLSID_Message, 
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IMessage,
                          (void**) &pIMsg);
    if FAILED(hr) {
        DPRINT1(0, "Unable to create CLSID_Message object, error 0x%x.\n", hr);
        DPRINT(0, "Check that CDOSYS.DLL is registered via regsvc32\n" );
        LogCdoError( hr );
        goto exit;
    }

    Assert( pTransport->Smtp.pszSmtpAddress );
    // Set the 'From' property.
    bstrFrom = SysAllocString( pTransport->Smtp.pszSmtpAddress );
    if (bstrFrom == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate from bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }

    hr = pIMsg->put_From( bstrFrom );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_From, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Determine the server to send to
    pszServer = wcschr( pszRemoteTransportAddress, L'@' );
    if (pszServer == NULL) {
        DPRINT1( 0, "Remote transport address %ws is malformed\n",
                 pszRemoteTransportAddress);
        hr = E_INVALIDARG;
        LogUnhandledError( hr );
        goto exit;
    }
    pszServer++;  // Skip separator

    // Set the 'To' property.
    bstrTo = SysAllocString( pszRemoteTransportAddress );
    if (bstrTo == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate to bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_To( bstrTo );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_To, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // This field may be null
    pszMessageSubject = pMsg->pszSubject ? pMsg->pszSubject : L"";

    // Set the 'Subject' property.
    cchSubject = gcchSubjectFormat +
        wcslen(pszServiceName) + wcslen( pszMessageSubject );

    __try {
        pszSubject = (LPWSTR) alloca(cchSubject * sizeof(*pszSubject));
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    swprintf(pszSubject, gszSubjectFormat, pszServiceName, pszMessageSubject);

    bstrSubj = SysAllocString( pszSubject );
    if (bstrSubj == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "Failed to allocate subj bstr\n" );
        LogUnhandledError( hr );
        goto exit;
    }
    hr = pIMsg->put_Subject( bstrSubj );
    if FAILED(hr) {
        DPRINT1(0, "Unable to put_Subject, error 0x%x.\n", hr);
        LogCdoError( hr );
        goto exit;
    }

    // Attach the data

    hr = attachMessageData( pIMsg, pMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to attach message data, error 0x%x.\n", hr);
        // Event already logged at lower layer
        goto exit;
    }

    hr = supersedeMessage( pTransport,
                           pszRemoteTransportAddress,
                           pszServiceName,
                           pszMessageSubject,
                           pIMsg );
    if (FAILED(hr)) {
        DPRINT1(0, "Unable to supersede message, error 0x%x.\n", hr);
        // Keep going, not fatal
    }

//***************************************************************************

    // Serialize access to queue directory, by this dll anyway
    EnterCriticalSection(&QueueDirectoryLock);
    __try {

        // queue the message locally
        hr = pIMsg->Send();
    }
    __finally {
        LeaveCriticalSection(&QueueDirectoryLock);
    }

    if (FAILED(hr)) {
        DPRINT1(0, "Unable to Send(), error 0x%x.\n", hr);
        // Error will be logged at a higher level
        goto exit;
    }

exit:

    if (bstrFrom) {
        SysFreeString( bstrFrom );
    }
    if (bstrTo) {
        SysFreeString( bstrTo );
    }
    if (bstrSubj) {
        SysFreeString( bstrSubj );
    }

    MEMORY_CHECK_ALL();

    // IsmServ will log the send failure

    if (pIMsg) {
        pIMsg = NULL;
    }

    return hr;
} /* SmtpSend */



HRESULT
getIsmMsgFromAttachment(
    CComPtr<IMessage> pIMsg,
    OUT ISM_MSG **  ppMsg,
    LPWSTR pszMessageSubject
    )

/*++

Routine Description:

Read the contents of a message.  The message is read into the message
descriptor

Arguments:

    pIMsg - CDO message object
    ppMsg - New message descriptor allocated to repesent the decoded message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IBodyPart> pIBodyPart;
    CComPtr<_Stream> pStream;
    VARIANT vBuffer;
    SAFEARRAY *psaData;
    ULONG cbData, cbDataAligned, len, subjectLength;
    BYTE *ptr;
    int i = 0;
    
    if (!pszMessageSubject) {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        LogUnhandledError( hr );
        return hr;
    }

    DPRINT1( 4, "getIsmMsgFromAttachment, subj=%ws\n", pszMessageSubject );

    VariantInit( &vBuffer );

    hr = pIMsg->get_BodyPart( &pIBodyPart );
    if (FAILED(hr)) {
        DPRINT1(0, "get_BodyPart() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pIBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = pStream->Read(adReadAll, &vBuffer);
    if (FAILED(hr)) {
        DPRINT1(0, "Read() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (vBuffer.vt != (VT_ARRAY | VT_UI1)) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, Body part type %d was not expected!\n",
                vBuffer.vt );
        LogUnhandledError( hr );
        goto cleanup;
    }

    psaData = vBuffer.parray;
    cbData = psaData->rgsabound[0].cElements;
    cbDataAligned = ROUND_UP_COUNT( cbData, ALIGN_WCHAR );

    subjectLength = wcslen( pszMessageSubject );

// wlees Sep 1, 1998. Getting mysterious AVs while freeing messages. Switch
// to simpler buffer management until we can track this down

#ifdef NO_COPY
// Minimize the number of data copies by extracting the binary data right out
// of the returned safe array.  We free the array descriptor manually.  Later,
// when we free the message, we use the right OLE api to free the data

    // Allocate an ISM_MSG to hold the data
    *ppMsg = NEW_TYPE( ISM_MSG );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }

    // Steal the data chuck out of the safe array.

    (*ppMsg)->cbData = cbData;
    (*ppMsg)->pbData = (BYTE *) psaData->pvData;

    // Free the descriptor manually.

    psaData->rgsabound[0].cElements = 0;
    psaData->pvData = NULL;

    hr = SafeArrayDestroyDescriptor( psaData );
    if (FAILED(hr)) {
        DPRINT1(0, "SafeArrayDestroyDescriptor() failed, error 0x%x\n", hr);
        // keep going
    }

    // No need to free this now
    vBuffer.vt = VT_EMPTY;
    vBuffer.parray = NULL;

    // Allocate a subject
    (*ppMsg)->pszSubject = NEW_TYPE_ARRAY( subjectLength + 1, WCHAR );
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );

#else
    // Allocate a buffer for the ISM_MSG, the data, and the subject string
    len = sizeof( ISM_MSG ) + 
        cbDataAligned +
        (subjectLength + 1) * sizeof( WCHAR );
    *ppMsg = (ISM_MSG *) NEW_TYPE_ARRAY( len, CHAR );
    if (NULL == *ppMsg) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        LogUnhandledError( hr );
        goto cleanup;
    }
    (*ppMsg)->cbData = cbData;
    ptr = (BYTE *) &( (*ppMsg)[1] ); // point past struct
    (*ppMsg)->pbData = ptr;
    // PERF: this is a data copy
    memcpy( ptr, psaData->pvData, cbData );
    ptr += cbDataAligned;
    Assert( POINTER_IS_ALIGNED( ptr, ALIGN_WCHAR ) );
    (*ppMsg)->pszSubject = (LPWSTR) ptr;
    wcscpy( (*ppMsg)->pszSubject, pszMessageSubject );
#endif

    hr = NOERROR;

cleanup:

    if (pIBodyPart) {
        pIBodyPart = NULL;
    }
    if (pStream) {
        pStream = NULL;
    }

    if (vBuffer.vt != VT_EMPTY) {
        VariantClear( &vBuffer );
    }

    if FAILED(hr) {
        Assert(NULL == *ppMsg);
    }
    else {
        Assert(NULL != *ppMsg);
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "NTDS ISM SMTP failed to read a message stream, error 0x%x\n", hr );
    }

    return hr;
} /* getIsmMsgFromAttachment */


VOID
SmtpFreeMessage(
    IN ISM_MSG *pMsg
    )

/*++

Routine Description:

Free the message alllocated by SmtpReceive.

This routine has the actual knowledge of how the data should be deallocated.

Arguments:

    pMsg - ism message descriptor

Return Value:

    None

--*/

{
    HRESULT hr;
    SAFEARRAY saData;

    Assert( pMsg );
    Assert( pMsg->pbData );

    DPRINT1( 3, "SmtpFreeMessage, size = %d\n", pMsg->cbData );

#ifdef NO_COPY
    // Whip up a phony safe array descriptor to describe the data
    // Try to use it to deallocate the data
    // Hope that this descriptor is close enough to the one originally
    // allocated.  Note if we have problems, we may need to see what the
    // "features" field had at time of allocation, and set accordingly.

    ZeroMemory( &saData, sizeof( SAFEARRAY ) );
    saData.cDims = 1;
    saData.cbElements = sizeof( char );
    saData.pvData = pMsg->pbData;
    saData.rgsabound[0].lLbound = 0;
    saData.rgsabound[0].cElements = pMsg->cbData;

    hr = SafeArrayDestroyData( &saData );
    if (FAILED(hr)) {
        DPRINT1( 0, "SafeArrayDestroyData failed with error 0x%x\n", hr );
    }

    if (pMsg->pszSubject) {
        FREE_TYPE( pMsg->pszSubject );
    }
#else
    // In this mode, data allocated with the msg descriptor
#endif

    pMsg->cbData = 0;
    pMsg->pbData = NULL;

    FREE_TYPE( pMsg );

} /* SmtpFreeMessage */


BOOL
messageIsDuplicate(
    PGUID_TABLE pGuidTable,
    BSTR bstrFrom,
    BSTR bstrSubject,
    IMessage *pIMsg
    )

/*++

Routine Description:

We can take advantage of the fact that all messages have a message guid, and that
retried messages have a supersedes guid.  As we receive messages, we record the
message guid in a guid table.  The guid table is only for the current drop
directory.  If the message we receive has a supersedes guid, we check to see if
that superseded guid is in the table.  If so, then we have recently seen the
predecessor of the current message, and we do not have to process the current
message.

The reason that we only consider messages in the current drop directory to be
candidates for recently seen messages is that mail delivery is unreliable.  The
fact that we have seen a request mail doesn't mean the reply was delivered.  The
requestor may send us the same request again for legitimate reasons and we
don't want to drop it on the floor.  The current drop directory becomes a kind
of simple grouping mechanism: all messages in the same drop directory instance
we received together in time and can be treated as equivalent.

Arguments:

    pGuidTable - Table of guid's recently seen
    bstrFrom - From field from message
    bstrSubject - Subject field from message
    pIMsg - Current message object

Return Value:

    BOOL - 

--*/

{
    HRESULT hr;
    BOOL fResult = FALSE;   // say no if not sure
    CComPtr<Fields> pFields;
    GUID guidMessage, guidSupersedes;

    hr = pIMsg->get_Fields(&pFields);
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to get_Fields, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Record that we have seen this message
    // Note that we record the message as seen regardless of whether we later
    // decide to discard it as a duplicate.  This is because of the transitive
    // nature of the supersedes guid:
    // message A
    // message B, supersedes A
    // message C, supersedes B
    // A is accepted, B is a duplicate of A, and in order to suppress C,
    // we must note B as seen, which it was transitively.

    hr = getFieldGuid( pFields, SMTP_MSG_GUID, &guidMessage );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // If the message has a guid
    if (memcmp( &guidMessage, &zeroGuid, sizeof(GUID) ) != 0) {
        // Insert in table of guids that have been seen
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidMessage, &pszUuid );
        DPRINT1( 4, "Message contains messageGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (!SmtpGuidInsertInTable( pGuidTable, &guidMessage )) {
            DPRINT( 0, "Failed to insert msg guid into table\n" );
            // Keep going
        }
    } else {
        DPRINT2( 0, "Warning: Message from %ws, subject %ws lacks a message guid.\n",
                 bstrFrom, bstrSubject );
    }

    // See if there is a supersedes guid in the message
    hr = getFieldGuid( pFields, SMTP_SUPERSEDES_MSG_GUID, &guidSupersedes );
    if (FAILED(hr)) {
        DPRINT1( 0, "failed to guid field guid, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (memcmp( &guidSupersedes, &zeroGuid, sizeof(GUID) ) != 0) {
        // See if we've seen the prior message
#if DBG
        LPWSTR pszUuid;
        UuidToStringW( &guidSupersedes, &pszUuid );
        DPRINT1( 4, "Message contains supersedesGuid %ws\n", pszUuid );
        RpcStringFreeW( &pszUuid );
#endif
        if (SmtpGuidPresentInTable( pGuidTable, &guidSupersedes )) {
            // It is a duplicate of a message we have seen recently
            fResult = TRUE;
            goto cleanup;
        }
    }

cleanup:
    if (pFields) {
        pFields = NULL;
    }

    return fResult;
} /* messageIsDuplicate */



HRESULT
parseDeliveryStatus(
    CComPtr<IBodyPart> pBodyPart,
    LPWSTR pszExpectedContentType,
    BSTR *pbstrText
    )

/*++

Routine Description:

This is a helper routine to parse the delivery status section of a
delivery status report.

Arguments:

    pBodyPart - 
    pszExpectedContentType - 
    pbstrText - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    BSTR bstrContentType = NULL;
    CComPtr<_Stream> pStream;
    StreamTypeEnum streamType;
    DWORD length;
    BSTR bstrCharset = NULL;

    hr = pBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    if (_wcsicmp( bstrContentType, pszExpectedContentType ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", pszExpectedContentType, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the content stream
    hr = pBodyPart->GetDecodedContentStream(&pStream);
    if (FAILED(hr)) {
        DPRINT1(0, "get_GetDecodedContentStream() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the stream type
    hr = pStream->get_Type( &streamType );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Type() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    if (streamType != adTypeText) {
        hr = E_INVALIDARG;
        DPRINT1(0, "ismsmtp, ndr, Stream type %d was not expected!\n",
                streamType );
        LogCdoError( hr );
        goto cleanup;
    }

    // Check the character set.  Adjust if not correct.
    // This works around a problem where body parts are incorrectly marked
    // with the wrong character set.
    hr = pStream->get_Charset( &bstrCharset );
    if (FAILED(hr)) {
        DPRINT1(0, "get_Charset() failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }
    if (_wcsicmp( bstrCharset, cdoISO_8859_1 ) != 0) {
        SysFreeString(bstrCharset);
        bstrCharset = SysAllocString( cdoISO_8859_1 );
        if (bstrCharset == NULL) {
            hr = E_OUTOFMEMORY;
            DPRINT( 0, "Failed to allocate from bstr\n" );
            LogUnhandledError( hr );
            goto cleanup;
        }
        hr = pStream->put_Charset( bstrCharset );
        if (FAILED(hr)) {
            DPRINT1(0, "set_Charset() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto cleanup;
        }
    }

    // Read it into a bstr
    hr = pStream->ReadText( adReadAll, pbstrText );
    if (FAILED(hr)) {
        DPRINT1(0, "ReadText(All) failed, error 0x%x\n", hr);
        LogCdoError( hr );
        goto cleanup;
    }

    hr = S_OK;
cleanup:
    if (bstrCharset) {
        SysFreeString(bstrCharset);
    }

    if (bstrContentType) {
        SysFreeString(bstrContentType);
    }
    if (pStream) {
        pStream = NULL;
    }

    return hr;
} /* parseDeliveryStatus */


HRESULT
parseNondeliveryReport(
    BSTR bstrSubject,
    CComPtr<IMessage> pIMsg
    )

/*++

Routine Description:

Decode a Nondelivery report.  It is encoded as a hierarchy of body parts:

root body part
   body part 1 - plain text, the session transcript
   body part 2 - message/delivery-status
         ... n-1
   body part n - message/rfc822, the original message

Warning, this may change in the future.  To accomodate this, we don't log
when we encounter unexpected syntax.  We simply stop parsing.  The caller
won't delete the report and the user can dispose of it himself. Note that we
do log function errors, since they should not happen.

We are only interested in the first and second parts

Arguments:

    pIMsg - 

Return Value:

    HRESULT - 

--*/

{
#define CDO_CONTENT_TYPE_MULTIPART_REPORT L"multipart/report"
#define CDO_CONTENT_TYPE_DELIVERY_STATUS L"message/delivery-status"
    DWORD win32Status;
    HRESULT hr;
    LONG count, i;
    CComPtr<IBodyPart> pRootBodyPart;
    CComPtr<IBodyParts> pBodyParts;
    BSTR bstrContentType = NULL;

    CComPtr<IBodyPart> pBodyPart;
    BSTR bstrText = NULL;
    LPWSTR pwzErrorString;

    // Get the root body part
    hr = pIMsg->get_BodyPart(&pRootBodyPart);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get root body part, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Get content type of whole message
    hr = pRootBodyPart->get_ContentMediaType(&bstrContentType);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_ContentMediaType, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // It better be a multi-part report
    if (_wcsicmp( bstrContentType, CDO_CONTENT_TYPE_MULTIPART_REPORT ) != 0) {
        hr = E_INVALIDARG;
        DPRINT2( 0, "DSN does not have expected content type, expected = %ws, actual = %ws\n", CDO_CONTENT_TYPE_MULTIPART_REPORT, bstrContentType );
        // Do not log
        goto cleanup;
    }

    // Get the collection of 1st level body parts
    hr = pRootBodyPart->get_BodyParts(&pBodyParts);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_BodyParts, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // See how many there are
    hr = pBodyParts->get_Count(&count);
    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to get_Count, error 0x%x\n", hr );
        LogCdoError( hr );
        goto cleanup;
    }

    // Should be atleast one
    if (count < 3) {
        hr = E_INVALIDARG;
        DPRINT( 0, "Malformed DSN doesn't have enough parts!\n" );
        // Do not log
        goto cleanup;
    }

    //DPRINT1( 0, "NDR has %d body parts\n", count );

// ***********************************************************************

    DPRINT1( 1, "ISM SMTP %ws:\n", bstrSubject );

    // Skip the first and the last

    count--;
    for( i = 2; i <= count; i++ ) {
        pBodyPart = NULL;
        bstrText = NULL;

        hr = pBodyParts->get_Item(i,&pBodyPart);
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to get_Item, error 0x%x\n", hr );
            LogCdoError( hr );
            goto loop_cleanup;
        }

        hr = parseDeliveryStatus( pBodyPart,
                                  (i == 1) ?
                                  cdoTextPlain :
                                  CDO_CONTENT_TYPE_DELIVERY_STATUS,
                                  &bstrText );
        if (FAILED(hr)) {
            DPRINT1( 0, "parseDeliveryStatus failed, error 0x%x\n", hr );
            // don't log
            goto loop_cleanup;
        }

        // This string is static and doesn't need to be freed
        pwzErrorString = parseStatus( bstrText, &win32Status );

        DPRINT4( 1, "\t(%d): Status: 0x%x - %ws\nText: %ws\n",
                 i, win32Status, pwzErrorString, bstrText );

        LogEvent8WithData(DS_EVENT_CAT_ISM,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_ISM_SMTP_DSN,
                          szInsertWin32Msg(win32Status),
                          szInsertWC(pwzErrorString),
                          szInsertWC(bstrText),
                          NULL, NULL, NULL, NULL, NULL,
                          sizeof(win32Status),
                          &win32Status
            );


    loop_cleanup:
        pBodyPart = NULL;
        if(bstrText)
        {
            SysFreeString(bstrText);
        }
    }

    hr = S_OK;

cleanup:

    if(bstrContentType)
    {
        SysFreeString(bstrContentType);
    }

    pBodyParts = NULL;
    pRootBodyPart = NULL;

    return hr;
} /* parseNondeliveryReport */


HRESULT
scanMessages(
    IN TRANSPORT_INSTANCE *pTransport,
    IN IMessages *pIMessages,
    IN  LPCWSTR pszServiceName,
    IN OUT LONG *plCount,
    IN OUT PGUID_TABLE pGuidTable,
    OUT ISM_MSG **ppMsg
    )

/*++

Routine Description:

Enumerate the messages in the drop directory.  Return the first one.
Duplicates are eliminated as they are encountered in the drop directory.

If we encounter any nondelivery reports for ISM messages, we log and delete.

We loop through the messages in the drop directory.  We read the first message
each time.  At the end of the loop we delete the first message, making the
next one the first.  If we can dispose of the message in the loop because
it is a notification or a duplicate, we do so.  On the first valid message, we
break out of the loop and return.  If we can't read a message, we log an event
and delete it.

There is no notion of skipped messages. We don't track unreadable messages still
in the collection. Our current reading position is always at the start and we
expect we can delete each message as we go.  There are no errors returned out of this
routine. We always delete the message or return it.  When we exit the routine
there are no messages left, or we are returning a valid message.

The only exception to this is file busy errors.  If we get such
an error, we exit the loop and do not return a message.  This appears that the
drop directory is empty to the caller, and he will rebuild a new drop directory
collection at a later time and try again.

Arguments:

    pTransport - Transport object
    pIMessages - Collection of messages
    pszServiceName - Name of server we are looking for
    plCount - Pointer to count of how many left to read. This is updated
               as we read each so we don't read them again next time
    pGuidTable - pointer to guid table to track duplicates
    ppMsg - Pointer to receive a message

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr, hr1;
    CComPtr<IMessage> pIMsg;
    BSTR bstrSubject, bstrTo, bstrFrom;
    LPWSTR pszMsgForServiceName, pszMessageSubject;
    BOOL done, busy;

    DPRINT1( 2, "scanning message collection entry, %d unread\n", *plCount );

    Assert( pIMessages );
    Assert( plCount );
    Assert( *plCount >= 1 );
    Assert( ppMsg );
    Assert( *ppMsg == NULL );

    // Initial conditions: not done, not busy and atleast one message

    // Note the structure of this loop.  We have to go through the next_
    // message processing at the bottom to free the resources.  The only way
    // out is through the for test at the bottom of the loop.

    done = busy = FALSE;
    do {
        DWORD busyTries = 0, waitCode;
        bstrSubject = bstrTo = bstrFrom = NULL;

        // We always read the first message
        // Each time we delete message 1, moving the rest up

        // If shutdown detected exit immediately
        if (pTransport->fShutdownInProgress) {
            DPRINT(2, "Message was skipped due to shutdown\n");
            hr = S_OK;
            busy = TRUE;
            goto next_message;
        }

        // NOTE: Busy retry loop could be avoided with an improved ismsink.dll
        // paragdigm -- see bug 88430: ISM SMTP sink should pre-process received
        // messages.
        
        // Read a message with retry
        // Deal with contention with writer process. This is a fact of life since
        // we will try to read a new file as soon as it appears in the directory.
        
        while (1) {
            hr = pIMessages->get_Item(1,&pIMsg);
            if (FAILED(hr)) {
                DPRINT1(0, "get_Item(1) failed, error 0x%x\n", hr);
                LogCdoError( hr );
                goto next_message;
            }

            // This is the first field we read from the message. If something is going
            // to fail, this is where it happens
            hr = pIMsg->get_To( &bstrTo );

            // Workaround. It appears that CDO will succeed with an empty value
            // when there is a sharing violation.
            if ( (SUCCEEDED(hr)) && ((bstrTo == NULL) || (wcslen(bstrTo) == 0)) ) {
                DPRINT( 1, "get_To returned empty string, treating as busy.\n" );
                hr = HR_SHARING_VIOLATION;
            }

            if ( (hr != HR_SHARING_VIOLATION) ||
                 (busyTries > 4) ||
                 (pTransport->fShutdownInProgress) ) {
                break;
            }
            busyTries++;
            DPRINT1( 1, "get_To returned busy, try %d\n", busyTries );
            pIMsg = NULL; // Cleanup old instance
            // Sleep while watching for shutdown
            waitCode = WaitForSingleObject( pTransport->hShutdownEvent,
                                            15 * 1000 );
            if (waitCode == WAIT_OBJECT_0) {
                // Shutdown detected.
                // Treat as busy error so message won't be deleted
                break;
            }
        }
        if (FAILED(hr)) {
            if (hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                // We can legitimately get a sharing violation if the dropping process
                // is not done writing the new message file yet
                DPRINT(2, "Message was skipped due to a sharing violation\n");
                hr = S_OK;
                busy = TRUE;
            } else {
                DPRINT1(0, "get_To() failed, error 0x%x\n", hr);
                LogCdoError( hr );
            }
            goto next_message;
        }
        if ( (bstrTo == NULL) || (wcslen( bstrTo ) == 0) ) {
            DPRINT( 0, "To: field in Ism Message is empty\n" );
            goto next_message;
        }

        hr = pIMsg->get_Subject( &bstrSubject );
        if (FAILED(hr)) {
            DPRINT1(0, "get_Subject() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrSubject == NULL) || (wcslen( bstrSubject ) == 0) ) {
            DPRINT( 0, "Subj: field in Ism Message is empty\n" );
            goto next_message;
        }

        hr = pIMsg->get_From( &bstrFrom );
        if (FAILED(hr)) {
            DPRINT1(0, "get_From() failed, error 0x%x\n", hr);
            LogCdoError( hr );
            goto next_message;
        }
        if ( (bstrFrom == NULL) || (wcslen( bstrFrom ) == 0) ) {
            DPRINT( 0, "From: field in Ism Message is empty\n" );
            goto next_message;
        }

        // See if the message is addressed to us
        if (!mailAddressMatch( bstrTo, pTransport->Smtp.pszSmtpAddress )) {
            DPRINT1( 0, "Ism Message not addressed to this DSA: %ws\n", bstrTo );
            // We wouldn't be finding the message unless the @domain portion of
            // the address matches. Mail being sent to the wrong user?
            goto next_message;
        }

        // Sanity check subject for basic syntax
        if (_wcsnicmp(bstrSubject, SUBJECT_PREFIX, SUBJECT_PREFIX_LEN) != 0) {

            // Check for delivery status report
            hr = parseNondeliveryReport( bstrSubject, pIMsg );
            if (SUCCEEDED(hr)) {
                goto next_message;
            }

            // Not an ISM message.
            DPRINT3(0, "IsmSmtp: Ignoring non-ISM message to %ws from %ws with subject \"%ls\".\n",
                    bstrTo, bstrFrom, bstrSubject);
            goto next_message;
        }

        // Check if message is a recently seen duplicate
        if (messageIsDuplicate(
            pGuidTable,
            bstrFrom,
            bstrSubject,
            pIMsg)) {

            DPRINT2( 1, "Duplicate message suppressed: From: \"%ws\", Subject: \"%ws\"\n",
                     bstrFrom, bstrSubject );

            // Note that we can get into a tight loop identifying and
            // deleting duplicates if there are many of them. This will be
            // true if the machine has been down or the ismserv had been
            // stopped. We will detect shutdown above. Do we need to return
            // the thread to the ismserv after every x messages so we don't
            // hog the thread?

            goto next_message;
        }

        // Looks like an ISM message.
        pszMsgForServiceName = bstrSubject + SUBJECT_PREFIX_LEN;
        pszMessageSubject = wcsstr( pszMsgForServiceName, SUBJECT_SEPARATOR );
        if (!pszMessageSubject) {
            // malformed subject line
            DPRINT1( 0, "Ism message subject line is malformed: %ws\n",
                     pszMsgForServiceName );
            goto next_message;
        }
        *pszMessageSubject = L'\0';
        pszMessageSubject += SUBJECT_SEPARATOR_LEN; // Skip over

        DPRINT2(3, "Message appears to be for service \"%ls\", from %ws.\n",
                pszMsgForServiceName, bstrFrom);

        // It is implicit in the design of this message loop that there is only
        // one type of service per drop directory.  This is fine in product 1
        // where the only client of ISM SMTP is NTDS Replication.  In the future we
        // will need to have child drop directories, one per service.  This is not
        // hard: the sink needs to save the incoming message in the right child.
        // That means we don't need a private domain either.
        if (_wcsicmp(pszServiceName, pszMsgForServiceName)) {
            // Not for us
            DPRINT1( 0, "Ism message is in wrong drop directory, claiming to be for service %ws\n", pszMsgForServiceName );
            goto next_message;
        }

        hr = getIsmMsgFromAttachment( pIMsg, ppMsg, pszMessageSubject );
        if (FAILED(hr)) {
            DPRINT1( 0, "Failed to decode message, error 0x%x\n", hr );
            goto next_message;
        }

        Assert( *ppMsg );
        DPRINT3( 1, "SmtpReceive, from %ws, subj %ws, size %d bytes.\n",
                pszServiceName, (*ppMsg)->pszSubject, (*ppMsg)->cbData );

        done = TRUE;

    next_message:

        // If we are not in the busy state, try to remove a message we read.  If we
        // fail, put ourselves in the busy state.
        if (!busy) {
            hr1 = pIMessages->Delete( 1 );
            if (SUCCEEDED(hr1))
            {
                (*plCount)--;
            } else {
                // Note we can be in the strange position of having a valid message
                // but not being able to delete it.  We don't want to return a
                // message we can't delete, since we will read it again, causing
                // duplicates.
                DPRINT1(0, "Delete() failed, error 0x%x\n", hr1);
                if (hr1 != HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION )) {
                    LogCdoError( hr1 );
                    if (SUCCEEDED(hr)) {
                        hr = hr1;
                    }
                }
                done = FALSE;  // don't return message
                busy = TRUE;   // exit message loop
            }
        }

        // Log an event on failure to read a message
        // Note, pIMsg may be NULL at this point
        if (FAILED(hr)) {
            LogEvent8WithData(DS_EVENT_CAT_ISM,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_ISM_SMTP_MSG_UNREADABLE,
                              szInsertUL(1),
                              szInsertWC( pTransport->Smtp.bstrDropDirectory ),
                              szInsertWin32Msg(hr),
                              NULL, NULL, NULL, NULL, NULL,
                              sizeof(hr),
                              &hr );
        }

        // Since this can take a while to work through a large backlog, let
        // the user know the progress we've made
        if ( ( *plCount >= 1 ) && ((*plCount % 50) == 0) ) {
            DPRINT1( 0, "There are %d SMTP messages remaining to be processed.\n",
                     *plCount );

            LogEvent(DS_EVENT_CAT_ISM,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_ISM_SMTP_MESSAGE_COUNT,
                     szInsertUL(*plCount),
                     szInsertWC(pTransport->Smtp.bstrDropDirectory),
                     NULL );
        }

        // Clean up if necessary

        if ( (!done) && (*ppMsg) ) {
            SmtpFreeMessage( *ppMsg );
            *ppMsg = NULL;
        }

        if (pIMsg) {
            pIMsg = NULL;
        }

        if (bstrSubject != NULL) {
            SysFreeString( bstrSubject );
        }
        if (bstrTo != NULL) {
            SysFreeString( bstrTo );
        }
        if (bstrFrom != NULL) {
            SysFreeString( bstrFrom );
        }
    }
    while ((!done) && (!busy) && (*plCount));

    // Termination conditions:
    Assert( (*plCount == 0) ||
            (done) && (*ppMsg) ||
            (busy)
        );

    DPRINT1( 2, "scanning message collection exit, %d remaining\n", *plCount );

    hr = S_OK;

    return hr;

} /* scanMessages */


HRESULT
getMailMessage(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

This is a wrapper around the scanMessages function.  It handles
caching of the current collection.  We only get a collection once from the
drop directory, and eliminate duplicates once.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT hr;
    CComPtr<IDropDirectory> pIDropDir;
    IMessages *pIMessages =
        (IMessages *) pTransport->Smtp.pvCurrentCollection;
    PGUID_TABLE pGuidTable = (PGUID_TABLE) pTransport->Smtp.pvGuidTable;

    Assert( ppMsg );
    Assert( *ppMsg == NULL );   // we don't have a message yet

    // If we already have a collection in progress, use it
    if (pIMessages) {

        hr = scanMessages(
            pTransport,
            pIMessages,
            pszServiceName,
            &(pTransport->Smtp.lCount),
            pGuidTable,
            ppMsg );

        // If we got a message, return it
        if ( (SUCCEEDED(hr)) && (*ppMsg) ) {
            goto cleanup;
        }

        // No message left in current collection, get rid of it
        pIMessages->Release();
        pIMessages = NULL;
        pTransport->Smtp.lCount = 0;
        SmtpDestroyGuidTable( pGuidTable);
        pGuidTable = NULL;
    }

    // We don't have a current collection
    Assert( pTransport->Smtp.lCount == 0);

    // Get the collection of messages
    hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                          &pIDropDir,
                          &pIMessages,
                          &(pTransport->Smtp.lCount) );
    if (FAILED(hr)) {
        DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
        // Status already logged
        goto cleanup;
    }

    Assert( pIDropDir );
    Assert( pIMessages );

    // The way the notification mechanism works, we may receive a notification
    // before the file appears in the drop directory. We delay here in order
    // to give time for the file to arrive.  A better approach would be to have
    // the sink write the file itself before signalling the event.
    //
    // See bug 88430: ISM SMTP sink should pre-process received messages.

    // Only wait when no messages pending, so that under load we pay no penelty
    if (pTransport->Smtp.lCount == 0) {
        DWORD waitCode;

        // Call destructors
        pIMessages->Release();
        pIMessages= NULL;
        pIDropDir = NULL;

        // Sleep( 10 * 1000 ) while waiting for shutdown
        waitCode = WaitForSingleObject( pTransport->hShutdownEvent, 10 * 1000 );
        if (waitCode == WAIT_OBJECT_0) {
            // Shutdown requested
            hr = S_OK;
            goto cleanup;
        }

        hr = getDropMessages( pTransport->Smtp.bstrDropDirectory,
                              &pIDropDir,
                              &pIMessages,
                              &(pTransport->Smtp.lCount) );
        if (FAILED(hr)) {
            DPRINT1(0, "getDropMessages failed, error 0x%x\n", hr);
            // Message already logged
            goto cleanup;
        }

        Assert( pIMessages );

        // Sorry, no mail today
        if (pTransport->Smtp.lCount == 0) {
            hr = S_OK;
            goto cleanup;
        }
    }

    Assert( pTransport->Smtp.lCount >= 1 );

    // Create a new guid table for tracking duplicates
    pGuidTable = SmtpCreateGuidTable();
    if (pGuidTable == NULL) {
        DPRINT( 0, "failed to allocate guid table\n" );
        hr = HR_NOT_ENOUGH_MEMORY;
        LogUnhandledError( hr );
        goto cleanup;
    }

    // Try to get one out
    hr = scanMessages(
        pTransport,
        pIMessages,
        pszServiceName,
        &(pTransport->Smtp.lCount),
        pGuidTable,
        ppMsg );

cleanup:

    // Update context
    if ( (SUCCEEDED(hr)) &&
         (pTransport->Smtp.lCount > 0) ) {
        pTransport->Smtp.pvCurrentCollection = pIMessages;
        pIMessages = NULL;  // don't free
        pTransport->Smtp.pvGuidTable = pGuidTable;
        pGuidTable = NULL; // don't free
    } else {
        pTransport->Smtp.pvCurrentCollection = NULL;
        pTransport->Smtp.lCount = 0;
        pTransport->Smtp.pvGuidTable = NULL;
    }

    // Free resources if necessary
    if (pIMessages) {
        pIMessages->Release();
        pIMessages= NULL;
    }

    if (pIDropDir) {
        pIDropDir = NULL;
    }

    if (pGuidTable) {
        SmtpDestroyGuidTable( pGuidTable );
        pGuidTable = NULL;
    }

    return hr;
} /* getMailMessage */


DWORD
SmtpReceive(
    IN  TRANSPORT_INSTANCE *  pTransport,
    IN  LPCWSTR               pszServiceName,
    OUT ISM_MSG **            ppMsg
    )

/*++

Routine Description:

API called by the server to retrieve a message.

This routine needs to return success if we are not configured yet.

Arguments:

    pTransport - 
    pszServiceName - 
    ppMsg - pointer to receive allocated message structure
    If NULL, notify instead of return a message

Return Value:

    DWORD - 

--*/

{
    HRESULT     hr;
    DWORD       winError;

    DPRINT1( 3, "SmtpReceive, serv = %ws\n", pszServiceName );

    MEMORY_CHECK_ALL();

    if ( (NULL == ppMsg) ||
         (NULL == pszServiceName) ) {
        return E_INVALIDARG;
    }

    // Default to "none waiting."
    *ppMsg = NULL;

    // If not configured, try to do so now
    EnterCriticalSection( &(pTransport->Lock) );
    __try {
        if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
            hr = configureMailAddress( pTransport );
        } else {
            hr = S_OK;
        }
    }
    __finally {
        LeaveCriticalSection( &(pTransport->Lock) );
    }

    if (FAILED(hr)) {
        DPRINT1( 0, "Failed to configure mail address, error 0x%x\n", hr );
        LogEvent8(DS_EVENT_CAT_ISM,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_ISM_SMTP_NO_MAIL_ADDRESS,
                  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        return hr;
    }

    // Smtp not installed, its ok
    if ( NULL == pTransport->Smtp.pszSmtpAddress ) {
        DPRINT( 3, "SMTP not present, returning no messages\n");
        return S_OK;
    }

    // Synchronize access to drop directory

    EnterCriticalSection(&DropDirectoryLock);
    __try {
        hr = getMailMessage( pTransport, pszServiceName, ppMsg );
    }
    __finally {
        LeaveCriticalSection(&DropDirectoryLock);
    }

    MEMORY_CHECK_ALL();

    return hr;
} /* SmtpReceive */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtp\dlltest.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    transporttest.c

Abstract:

Test for a transport dll.    

Author:

    Will Lees (wlees) 25-Nov-1997

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name

        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcndr.h>

#include <schedule.h>

#include "ismapi.h"

/* External */

/* Static */

static ISM_NOTIFY NotifyFunction;

static HANDLE ghNotify = NULL;

/* Forward */ /* Generated by Emacs 19.34.1 on Thu Jan 15 17:05:00 1998 */

int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    );

static void
Usage(
    WCHAR *ProgramName
    );

static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    );

static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    );

static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    );

static void
printSchedule(
    PBYTE pSchedule
    );

static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    );

/* End Forward */


int __cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    WCHAR *option, *address, *service, *message, *transport, *site;
    if (argc < 2) {
        Usage( argv[0] );
        return -1;
    }
    option = argv[1];
    if (_wcsicmp( option, L"-c" ) == 0) {
        if (argc < 6) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        address = argv[3];
        service = argv[4];
        message = argv[5];
        if (!clientTest( transport, address, service, message )) {
            printf( "client test failed\n" );
        }
    } else if (_wcsicmp( option, L"-s" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        service = argv[3];

        if (!serverTest( transport, service )) {
            printf( "server test failed\n" );
        }
    } else if (_wcsicmp( option, L"-r" ) == 0) {
        if (argc < 4) {
            Usage( argv[0] );
            return -1;
        }
        transport = argv[2];
        site = argv[3];

        if (!directoryTest( transport, site )) {
            printf( "directory test failed\n" );
        }
    } else {
        Usage( argv[0] );
        return -1;
    }
    return 0;
}


static void
Usage(
    WCHAR *ProgramName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "Usage:\n" );
    printf( "\t%ws -c transport address service \"string\"\tclient test\n", ProgramName );
    printf( "\t%ws -s transport service\tserver test\n", ProgramName );
    printf( "\t%ws -r transport site \trouting function test\n", ProgramName );
}


static BOOL
clientTest(
    LPWSTR Transport,
    LPWSTR ServerAddress,
    LPWSTR Service,
    LPWSTR Message
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    ISM_MSG message;
    DWORD status, bytes, i;
    PBYTE pBlock;

    printf( "client test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    bytes = 0;
    bytes = _wtoi( Message );
    if (bytes == 0) {
        message.pszSubject = L"This is the mail subject";
        message.cbData = (wcslen( Message ) + 1) * sizeof( WCHAR );
        message.pbData = (PBYTE) Message;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
    } else {
        pBlock = LocalAlloc( LMEM_FIXED, bytes );
        if (pBlock == NULL) {
            printf( "LocalAlloc failed to alloc %d bytes\n", bytes );
            return FALSE;
        }
        for( i = 0; i < bytes; i++ ) {
            pBlock[i] = (BYTE) ((i % 26) + 'a');
        }
        message.cbData = bytes;
        message.pbData = pBlock;
        status = IsmSend( handle, ServerAddress, Service, &message );
        if (status) {
            printf( "IsmSend failed with status %d\n", status );
        }
        LocalFree( pBlock );
    }

    IsmShutdown( handle );

    return TRUE;
}


static BOOL
serverTest(
    LPWSTR Transport,
    LPWSTR Service
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle, event;
    DWORD status, waitStatus;
    PISM_MSG pMessage;
    BOOLEAN done = FALSE;
    WCHAR eventName[255];

    wcscpy( eventName, L"_NT_DS_ISM_SMTP" );
    wcscat( eventName, Service );

    printf( "server  test\n" );
    if (IsmStartup( Transport, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    printf( "startup successful\n" );

    // auto-reset, inital value non-signaled
    event = CreateEventW( NULL, FALSE, FALSE, eventName );
    if (NULL == event) {
        printf( "CreateEvent failed\n" );
        return FALSE;
    }

    while (!done) {
        status = IsmReceive( handle, Service, &pMessage );
        if (status) {
            printf( "IsmReceived failed with error %d\n", status );
            break;
        }
        if (pMessage == NULL) {
            printf( "no more messages, waiting...\n" );
            waitStatus = WaitForSingleObject( event, INFINITE );
            if (waitStatus != WAIT_OBJECT_0) {
                printf( "wait failed with unexpected status %d\n",waitStatus);
                break;
            }
        } else {
            if (pMessage->cbData < 100) {
                printf( "Received subj: '%ws', message: \"%ws\"\n",
                        pMessage->pszSubject, pMessage->pbData );
                if (_wcsicmp( (WCHAR *) pMessage->pbData, L"exit" ) == 0) {
                    done = TRUE;
                }
            } else {
                printf( "Received message: %d bytes\n", pMessage->cbData );
            }
            IsmFreeMsg( handle, pMessage );
        }
    }

    CloseHandle( event );

    IsmShutdown( handle );
    return TRUE;
}


static BOOLEAN
directoryTest(
    PWSTR TransportName,
    PWSTR SiteName
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HANDLE handle;
    DWORD status, i, j;
    BOOLEAN result = FALSE;
    PISM_CONNECTIVITY pConnectivity = NULL;
    PISM_SERVER_LIST pServerList = NULL;
    PISM_SCHEDULE pSchedule = NULL;

    printf( "directory test\n" );
    if (IsmStartup( TransportName, NotifyFunction, ghNotify, &handle )) {
        printf( "IsmStartup failed\n" );
        return FALSE;
    }

    status = IsmGetTransportServers( handle, SiteName, &pServerList );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get transport servers, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nTransport Servers:\n" );
    if (pServerList != NULL) {
        printf( "Number of Servers = %d\n", pServerList->cNumServers );
        for( i = 0; i < pServerList->cNumServers; i++ ) {
            printf( "\tServer[%d] = %ws\n", i, pServerList->ppServerDNs[i] );
        }
    } else {
        printf( "\tNone\n" );
    }

    status = IsmGetConnectionSchedule( handle, L"FOO", L"BAR", &pSchedule );
    if (status != ERROR_NOT_READY) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectivity( handle, &pConnectivity );
    if (status != ERROR_SUCCESS) {
        printf( "failed to get connectivity, status = %d\n", status );
        goto cleanup;
    }

    printf( "\nSite Connectivity::\n" );

    if (pConnectivity != NULL) {
        printf( "Number of sites = %d\n", pConnectivity->cNumSites );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "\tSite[%d] = %ws\n", i, pConnectivity->ppSiteDNs[i] );
        }
        printf( "All pairs shortest path matrix:\n" );
        printf( "     |" );
        for( j = 0; j < pConnectivity->cNumSites; j++ ) {
            printf( "%5.5d|", j );
        }
        printf( "\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            printf( "%5.5d|", i );
            for( j = 0; j < pConnectivity->cNumSites; j++ ) {
                PISM_LINK pLink = &( pConnectivity->pLinkValues[ i * pConnectivity->cNumSites + j ] );
                if (pLink->ulCost != 0xffffffff) {
                    printf( "%5.5u:", pLink->ulCost );
                } else {
                    printf( "  *  :" );
                }
                printf( "%5.5u:", pLink->ulReplicationInterval );
                printf( "%5.5x|", pLink->ulOptions );
            }
            printf( "\n" );
        }
    } else {
        printf( "\tNo site connectivity\n" );
    }

    status = IsmGetConnectionSchedule( handle,
                                       pConnectivity->ppSiteDNs[0],
                                       L"BAR",
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    status = IsmGetConnectionSchedule( handle,
                                       L"FOO",
                                       pConnectivity->ppSiteDNs[0],
                                       &pSchedule );
    if (status != ERROR_NO_SUCH_SITE) {
        printf( "Call to IsmGetConnSched did not return expected error, %d",
                status );
        goto cleanup;
    }

    // Generate all pairs of sites

    if (pConnectivity != NULL) {
        printf( "\nSite to Site Scheduling:\n" );
        for( i = 0; i < pConnectivity->cNumSites; i++ ) {
            for( j = i + 1; j < pConnectivity->cNumSites; j++ ) {
                if (pConnectivity->pLinkValues[ i + pConnectivity->cNumSites * j ].ulCost == 0xffffffff) {
                    continue;
                }
                status = IsmGetConnectionSchedule( handle,
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j],
                               &pSchedule );
                if (status != ERROR_SUCCESS) {
                    printf( "failed to get common site schedule, or not connected\n" );
                    goto cleanup;
                }

                printf( "\t%ws to %ws: ",
                               pConnectivity->ppSiteDNs[i],
                               pConnectivity->ppSiteDNs[j] );
                if (pSchedule != NULL) {
                    printf( "Connected via schedule, addr: %p, len: %d\n",
                            pSchedule->pbSchedule, pSchedule->cbSchedule );
                    printSchedule( pSchedule->pbSchedule );
                    IsmFreeConnectionSchedule( handle, pSchedule );
                } else {
                    printf( "Connected all the time\n" );
                }

            }
        }
    }


    result = TRUE;

cleanup:
    if (pConnectivity != NULL) {
        IsmFreeConnectivity( handle, pConnectivity );
    }

    if (pServerList != NULL) {
        IsmFreeTransportServers( handle, pServerList );
    }

    IsmShutdown( handle );

    return result;
}


static void
printSchedule(
    PBYTE pSchedule
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    char *dow[] = { "Sun","Mon","Tues","Wed","Thurs","Fri","Sat"};

    printf( "\t\t" );
    for( day = 0; day < 7; day++ ) {
        for( hour = 0; hour < 24; hour++ ) {
            if (*data & 0x1) printf( "%s%d:00;", dow[day], hour );
            if (*data & 0x2) printf( "%s%d:15;", dow[day], hour );
            if (*data & 0x4) printf( "%s%d:30;", dow[day], hour );
            if (*data & 0x8) printf( "%s%d:45;", dow[day], hour );
            data++;
        }
    }
    printf( "\n" );
}


static
void
NotifyFunction(
    IN  HANDLE          hNotify,
    IN  LPCWSTR         pszServiceName
    )
/*++

Routine Description:

    Called by the plug-in to notify the ISM service that a message has been
    received for the given service.

Arguments:

    hNotify (IN) - Notification handle, as passed to the plug-in in the
        IsmStartup() call.

    pszServiceName (IN) - Service for which a message was received.

Return Values:

    None.

--*/
{
    printf( "Notified of pending message for service %ws.\n", pszServiceName );
}

/* end plugtest.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\ismsink1.cpp ===
// Modified from SMTP SINK SAMPLE by wlees, Jul 22, 1998

/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ismsink1

Abstract:

    This module contains the implementation of the OnArrival method for the
    ism smtp event sink.

    This method is invoked when a new smtp message arrives

    Since this notification dll runs in a different process from the ism, we
    employ a optimization to notify the ISM.
    1. The event that the ism waits for, for a particular transport and
    service, has a name we can predict.
    2. We signal the ism directly that a message is available.  We don't bother
    signalling the transport dll, which would just have to have a thread
    waiting on the event.  The ism is already waiting on the event anyway.

    ISM notification events look like:
    _NT_DS_ISM_<transport rdn><service name>

Author:

    Will Lees (wlees) 22-Jul-1998

Environment:

Notes:

Revision History:


--*/

// Sink1.cpp : Implementation of CSink1

#include "stdafx.h"
#include "SMTPSink.h"
#include "ismSink1.h"

extern "C" ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

// To temporarily enable debugging
#if 1
#define DPRINT( level, format ) DbgPrint( format )
#define DPRINT1( level, format, arg1 ) DbgPrint( format, arg1 )
#define DPRINT2( level, format, arg1, arg2 ) DbgPrint( format, arg1, arg2 )
#else
#define DPRINT( level, format ) 
#define DPRINT1( level, format, arg1 ) 
#define DPRINT2( level, format, arg1, arg2 ) 
#endif

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))

#define SMTP_EVENT_PREFIX L"_NT_DS_ISM_SMTP"
#define SMTP_EVENT_PREFIX_LEN  (ARRAY_SIZE(SMTP_EVENT_PREFIX) - 1)

// TODO: put this in a common header?

// The service name used to send and receive messages between DSAs via ISM.
#define DRA_ISM_SERVICE_NAME L"NTDS Replication"
#define SUBJECT_PREFIX      L"Intersite message for "
#define SUBJECT_PREFIX_LEN  (ARRAY_SIZE(SUBJECT_PREFIX) - 1)
#define SUBJECT_SEPARATOR L": "
#define SUBJECT_SEPARATOR_LEN  (ARRAY_SIZE(SUBJECT_SEPARATOR) - 1)

// This code fragment defines the CLSIDs and IIDs for the event package
#include "seo_i.c"

/////////////////////////////////////////////////////////////////////////////
// CSink1


HRESULT
getItemValue(
    LPWSTR ItemName,
    CComPtr<Fields> pFields,
    VARIANT *pvValue
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItem = NULL;
    VARIANT vItem;

    VariantInit( &vItem );

    bstrItem = SysAllocString( ItemName );
    if (bstrItem == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: Failed to allocate from bstr\n" );
        goto exit;
    }
    vItem.vt = VT_BSTR;
    vItem.bstrVal = bstrItem;

    hr = pFields->get_Item( vItem, &pField );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Item(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = pField->get_Value( pvValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Value(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = S_OK;

exit:
    if (vItem.vt != VT_EMPTY) {
        VariantClear( &vItem );
    }
    if (pField) {
        pField = NULL;
    }

    return hr;
}


HRESULT
putItemValue(
    LPWSTR ItemName,
    CComPtr<Fields> pFields,
    VARIANT *pvValue
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Field> pField;
    BSTR bstrItem = NULL;
    VARIANT vItem;

    VariantInit( &vItem );

    bstrItem = SysAllocString( ItemName );
    if (bstrItem == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: Failed to allocate from bstr\n" );
        goto exit;
    }
    vItem.vt = VT_BSTR;
    vItem.bstrVal = bstrItem;

    hr = pFields->get_Item( vItem, &pField );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: get_Item(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = pField->put_Value( *pvValue );
    if (FAILED(hr)) {
        DPRINT2( 0, "IsmSink: put_Value(%ws) failed, error 0x%x\n", ItemName, hr );
        goto exit;
    }

    hr = S_OK;

exit:
    if (vItem.vt != VT_EMPTY) {
        VariantClear( &vItem );
    }
    if (pField) {
        pField = NULL;
    }

    return hr;
}


HRESULT
abortDelivery(
    IN IMessage *pIMsg
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vMessageStatus;

    VariantInit( &vMessageStatus );

    // Get the envelope fields
    hr = pIMsg->get_EnvelopeFields( &pFields );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_EnvelopeFields failed, error 0x%x\n", hr );
        goto exit;
    }

    vMessageStatus.vt = VT_I4;
    vMessageStatus.lVal = cdoStatAbortDelivery;

    // Set Message Status
    hr = putItemValue( cdoMessageStatus, pFields, &vMessageStatus );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = S_OK;
exit:
    if (vMessageStatus.vt != VT_EMPTY) {
        VariantClear( &vMessageStatus );
    }
    if (pFields) {
        pFields = NULL;
    }

    return hr;
}


HRESULT
filterOnEnvelope(
    IN CComPtr<IMessage> pIMsg,
    OUT BOOL *pfSkip
    )

/*++

Routine Description:

Determine if we should skip this message based on the contents of the envelope

Arguments:

    pIMsg - 
    pfSkip - 

Return Value:

    HRESULT - 

--*/

{
#define IP_LOCALHOST L"127.0.0.1"
    HRESULT hr;
    CComPtr<Fields> pFields;
    VARIANT vClientIp;

    VariantInit( &vClientIp );

    // Get the envelope fields
    hr = pIMsg->get_EnvelopeFields( &pFields );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_EnvelopeFields failed, error 0x%x\n", hr );
        goto exit;
    }

    // Submitters IP address
    hr = getItemValue( cdoClientIPAddress, pFields, &vClientIp );
    if (FAILED(hr)) {
        goto exit;
    }

    // If value not present, finish now
    if (vClientIp.vt == VT_EMPTY) {
        hr = S_OK;
        goto exit;
    }

    if (vClientIp.vt != VT_BSTR) {
        DPRINT1( 0, "IsmSink: Client IP address has wrong variant type %d\n", vClientIp.vt );
        hr = E_INVALIDARG;
        goto exit;
    }

    //DPRINT1( 0, "client ip vt = %d\n", vClientIp.vt );
    //DPRINT1( 0, "client ip = %ws\n", vClientIp.bstrVal );

    // We want to ignore arrivals from the pickup directory
    // Ignore if client or server ip is "local host"
    // NOTE. See my comments in xmitrecv.c::SmtpSend about the three ways to
    // send a message.  If we switch from using the pickup directory, we may
    // need to be more clever about how we detect "relay arrival" notifies.
    if (0 == _wcsicmp( vClientIp.bstrVal, IP_LOCALHOST )) {
        *pfSkip = TRUE;
    }

    hr = S_OK;
exit:
    if (vClientIp.vt != VT_EMPTY) {
        VariantClear( &vClientIp );
    }
    if (pFields) {
        pFields = NULL;
    }

    return hr;
} /* filterOnEnvelope */

STDMETHODIMP
CIsmSink1::OnArrival(
    IMessage *pISinkMsg,
    CdoEventStatus *pEventStatus
    )

/*++

Routine Description:

   Event handling routine for a new message

   The messages we receive are governed by our filter rule.
   Currently the rule is RCPT TO=_IsmService@guid-based-dns-name
   Thus we receive any mail addressed directly to us, including ism messages,
   status notifications, and potentially anything else.

   There are three possible outcomes from this sink:
1. The message is recognized. We signal the event and skip remaining sinks.
2. We get an error and can't determine what kind of message it is.  In this
case we don't signal, but we don't skip either.
3. We message is definitely not for us.  In this case we don't signal the
event, we abort delivery of the message, and we skip remaining sinks.

Arguments:

    pISinkMsg - 
    pEventStatus - 

Return Value:

    STDMETHODIMP - 

--*/

{
    HRESULT hr;
    HANDLE handle = NULL;
    BSTR bstrSubject = NULL;
    LPWSTR pszEventName = NULL;
    LPWSTR pszMsgForServiceName, pszMessageSubject;
    CdoEventStatus disposition = cdoRunNextSink; // assume not for us
    DWORD length;
    BOOL fSkip, fAbortDelivery = FALSE;

//    DPRINT( 0, "Smtp event sink, message OnArrival routine\n" );

    fSkip = FALSE;
    hr = filterOnEnvelope( pISinkMsg, &fSkip );
    // If we fail to determine, don't skip
    if  (fSkip) {
        goto exit;
    }

    // Get the subject of the message
    hr = pISinkMsg->get_Subject( &bstrSubject );
    if (FAILED(hr)) {
        DPRINT1( 0, "IsmSink: get_To failed with error 0x%x\n", hr );
        goto exit;
    } else if (NULL == bstrSubject) {
        // Can't be for us
        DPRINT( 0, "IsmSink: subject field is missing\n" );
        fAbortDelivery = TRUE;
        hr = S_OK;
        goto exit;
    }

    // Determine which ISM service to notify.  Note that we notify on any reasonable
    // message we receive. We leave complex message validation for the ISM service.

    if (_wcsnicmp(bstrSubject, SUBJECT_PREFIX, SUBJECT_PREFIX_LEN) == 0) {
        pszMsgForServiceName = bstrSubject + SUBJECT_PREFIX_LEN;
        pszMessageSubject = wcsstr( pszMsgForServiceName, SUBJECT_SEPARATOR );
        if (!pszMessageSubject) {
            // malformed subject line
            DPRINT1( 0, "IsmSink: subject field not recognized: '%ws'\n", bstrSubject );
            fAbortDelivery = TRUE;
            hr = S_OK;
            goto exit;
        }

        *pszMessageSubject = L'\0';
        pszMessageSubject += SUBJECT_SEPARATOR_LEN; // Skip over
    } else {
        // We have received a status notification about some returned mail or problem
        // delivering the mail.  We need to wake up the ismserv.  Normally we signal
        // the ism in the context of a particular ism service according to the message.
        // In the case of returned mail, the name of the original service is not easy to
        // find in the returned mail. So use a well known ISM service.
        // If this mail is not a valid mail delivery problem report, it will be screened
        // out when the message is read by the ISM service.
        pszMsgForServiceName = DRA_ISM_SERVICE_NAME;
        pszMessageSubject = bstrSubject;
    }

#ifdef UNIT_TEST_DEBUG
    DPRINT2( 0, "NTDS ISM SMTP message arrived for service '%ws' subject '%ws'\n",
             pszMsgForServiceName, pszMessageSubject );
#endif

    length = (DWORD)(SMTP_EVENT_PREFIX_LEN + wcslen( pszMsgForServiceName ) + 1);

    pszEventName = new WCHAR [length];
    if (pszEventName == NULL) {
        hr = E_OUTOFMEMORY;
        DPRINT( 0, "IsmSink: failed to allocate memory\n" );
        goto exit;
    }

    // Build the predicted global name of the ism+smtp+service event
    wcscpy( pszEventName, SMTP_EVENT_PREFIX );
    wcscat( pszEventName, pszMsgForServiceName );

    // Open the event.  If the ism smtp dll isn't running, we will get
    // error 2 here.  Just ignore it.
    handle = OpenEventW( EVENT_MODIFY_STATE,  // Access flag
                        FALSE,               // Inherit flag
                        pszEventName
                        );
    if (handle == NULL) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if (hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND )) {
            DPRINT2( 0, "IsmSink: OpenEvent(%ws) failed with 0x%x\n", pszEventName, hr);
        }
        goto exit;
    }

    // Signal the event.
    if (!SetEvent( handle )) {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DPRINT1( 0, "IsmSink: SetEvent failed with 0x%x\n", hr );
        goto exit;
    }

    hr = S_OK;
    disposition = cdoSkipRemainingSinks;  // its for us

exit:
    if (handle != NULL) {
        CloseHandle( handle );
    }
        
    if (pszEventName) {
        delete pszEventName;
    }

    if (bstrSubject != NULL) {
        SysFreeString( bstrSubject );
    }

    if (fAbortDelivery) {
        HRESULT hr1;
        hr1 = abortDelivery( pISinkMsg );
        if (FAILED(hr1)) {
            DPRINT1( 0, "IsmSink: abortDelivery failed with error 0x%x\n", hr );
            // ignore error
        }
    }

    *pEventStatus = disposition;

    return hr;
} /* CIsmSink1::OnArrival */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\ismsink1.h ===
// Modified from SMTP SINK SAMPLE by wlees, Jul 22, 1998

// Sink1.h : Declaration of the CSink1

#ifndef __ISMSINK1_H_
#define __ISMSINK1_H_

#include "resource.h"       // main symbols
#include "cdosys.h"  // ISMTPOnArrival
// Jun 8, 1999. #ifdef necessary until new headers checked in
#ifdef __cdo_h__
using namespace CDO;
#endif
#include "cdosysstr.h" // string constants (field names)
#include "cdosyserr.h" // error codes for CDO
#include "seo.h" // IEventIsCacheable

HRESULT HrIsmSinkBinding(BOOL fBindSink);

/////////////////////////////////////////////////////////////////////////////
// CIsmSink1
class ATL_NO_VTABLE CIsmSink1 : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CIsmSink1, &CLSID_IsmSink1>,
	public IDispatchImpl<ISMTPOnArrival, &IID_ISMTPOnArrival, &LIBID_ISMSMTPSINKLib>,
        public IEventIsCacheable
{
public:
	CIsmSink1()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SINK1)

BEGIN_COM_MAP(CIsmSink1)
	COM_INTERFACE_ENTRY(ISMTPOnArrival)
	COM_INTERFACE_ENTRY(IEventIsCacheable)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISink1
public:
    STDMETHOD(OnArrival)(IMessage *pISinkMsg, CdoEventStatus *pEventStatus);
    STDMETHOD(IsCacheable)() { return S_OK; };
};

#endif //__ISMSINK1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SMTPSink.rc
//
#define IDS_PROJNAME                    100
#define IDR_SINK1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED_)
#define AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D5F35B67_BDF8_11D1_914E_00805FD41EF5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ism\trnsprts\smtpsink\smtpsink.cpp ===
// Modified from CDO V2 SMTP SINK sample, by wlees Jul 22, 1998
// SMTPSink.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SMTPSinkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "SMTPSink.h"
#include "SMTPSink_i.c"
#include "ismSink1.h"
#include "cdosys_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IsmSink1, CIsmSink1)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
    HRESULT hr;

    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbak_server.c ===
#include <jetbak_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbak_client.c ===
#include <jetbak_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetbp.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetbp.h

Abstract:

    This module contains the private definitions for the JET backup APIs


Author:

    Larry Osterman (larryo) 21-Aug-1994


Revision History:


--*/

#ifndef	_JETBP_
#define	_JETBP_

#include <dsjet.h>
#ifndef	MIDL_PASS
#include <jetbak.h>
#endif
#include <nspapi.h>

// MIDL 2.0 switched the names of the generated server interface globals (why!?).
// This hack so that we only have to change one place.
// Parameters are interface name, major and minor version numbers.
#if   (_MSC_VER > 800)
#define ServerInterface(s,vMaj,vMin)	s##_v##vMaj##_##vMin##_s_ifspec
#define ClientInterface(s,vMaj,vMin)	s##_v##vMaj##_##vMin##_c_ifspec
#else
#define ServerInterface(s,vMaj,vMin)	s##_ServerIfHandle
#define ClientInterface(s,vMaj,vMin)	s##_ClientIfHandle
#endif

#include "options.h"

#define	MAX_SOCKETS	10

#define	RESTORE_IN_PROGRESS		L"\\Restore in Progress"
#define	RESTORE_STATUS			L"RestoreStatus"
#define	BACKUP_LOG_PATH			L"BackupLogPath"
#define	CHECKPOINT_FILE_PATH	L"CheckpointFilePath"
#define	LOG_PATH				L"LogPath"
#define	HIGH_LOG_NUMBER			L"HighLog Number"
#define	LOW_LOG_NUMBER			L"LowLog Number"
#define	JET_RSTMAP_NAME			L"NTDS_RstMap"
#define	JET_RSTMAP_SIZE			L"NTDS_RstMap Size"
#define	JET_DATABASE_RECOVERED	L"NTDS Database recovered"
#define	BACKUP_INFO				L"SYSTEM\\CurrentControlSet\\Services\\NTDS\\BackupInformation\\"
#define	LAST_BACKUP_LOG			L"Last Backup Log"
#define	DISABLE_LOOPBACK		L"DisableLoopback"
#define	ENABLE_TRACE			L"Enable Trace"
#define RESTORE_NEW_DB_GUID     L"New Database GUID"

//
//	Sockets protocol value.
//
typedef INT PROTVAL;

#define	LOOPBACKED_READ_EVENT_NAME      L"Global\\NTDS Backup Loopbacked Read Event - %d"
#define	LOOPBACKED_WRITE_EVENT_NAME     L"Global\\NTDS Backup Loopbacked Write Event - %d"
#define	LOOPBACKED_CRITSEC_MUTEX_NAME   L"Global\\NTDS Backup Loopbacked Critical Section - %d"
#define	LOOPBACKED_SHARED_REGION        L"Global\\NTDS Backup Shared Memory Region - %d"

#define	READAHEAD_MULTIPLIER	5
#ifdef	DEBUG
#define	BACKUP_WAIT_TIMEOUT		10*60*1000
#else
#define	BACKUP_WAIT_TIMEOUT		2*60*1000
#endif

typedef volatile struct {
	DWORD	cbSharedBuffer;
	DWORD	cbPage;				// 	Convenient place to store the size of a page.
	DWORD	dwReadPointer;		//	Read offset within shared buffer.
	DWORD	dwWritePointer;		//	Write offset within buffer.
	LONG	cbReadDataAvailable;//	Number of bytes of data available.
	HRESULT	hrApi;				//	Status of API - used to communicate to server if client fails.
	BOOLEAN	fReadBlocked;		//	Read operation is blocked
	BOOLEAN	fWriteBlocked;		//	Write operation is blocked
} JETBACK_SHARED_HEADER, *PJETBACK_SHARED_HEADER;


typedef struct {
	HANDLE		hSharedMemoryMapping;
	HANDLE		heventRead;
	HANDLE		heventWrite;
	HANDLE		hmutexSection;
	PJETBACK_SHARED_HEADER pjshSection;
} JETBACK_SHARED_CONTROL, *PJETBACK_SHARED_CONTROL;


//
//	Client side context.
//

typedef struct _BackupContext {
	handle_t	hBinding;
	CXH			cxh;
	BOOLEAN		fLoopbacked;
	BOOLEAN		fUseSockets;
	BOOLEAN		fUseSharedMemory;

	//
	//	Socket support.
	//

	SOCKET		rgsockSocketHandles[MAX_SOCKETS];
	PROTVAL		rgprotvalProtocolsUsed[MAX_SOCKETS];
	C			cSockets;
	SOCKET		sock;
	HANDLE		hReadThread;
	DWORD		tidThreadId;
	HANDLE		hPingThread;		// Keep alive thread for loopbacked backups.
	DWORD		tidThreadIdPing;	// And thread ID for that thread.
	HRESULT		hrApiStatus;

	//
	//	Shared memory support.
	//

	JETBACK_SHARED_CONTROL jsc;

        // Whether a token was supplied at checked when the context was created
        BOOL fExpiryTokenChecked;
} BackupContext, *pBackupContext;

typedef
DWORD
(*PRESTORE_DATABASE_LOCATIONS)(
	OUT CHAR rgLocationBuffer[],
	OUT PULONG pulLocationSize,
	OUT char rgRegistryBase[],
	OUT ULONG cbRegistryBase,
	OUT BOOL *pfCircularLogging
	);

typedef
DWORD
(*PRESTORE_PERFORM_RESTORE)(
	SZ szLogPath,
	SZ szBackupLogPath,
	C crstmap,
	JET_RSTMAP rgrstmap[]
	);

//
//	Server side context binding - the server context handle points to a
//	structure containing this information.
//
typedef struct _JETBACK_SERVER_CONTEXT {
	BOOL	fRestoreOperation;
	union {
		struct {
			JET_HANDLE		hFile;
			BOOL			fHandleIsValid;
			CB				cbReadHint;
			SOCKET			sockClient;
			LARGE_INTEGER 	liFileSize;
			DWORD			dwHighestLogNumber;
			WSZ				wszBackupAnnotation;
			DWORD			dwFileSystemGranularity;
			BOOLEAN			fUseSockets;
			BOOLEAN			fUseSharedMemory;
			BOOLEAN			fBackupIsRegistered;

			//
			//	Client identifer used to identify the client to the server - we use this
			//	when opening the shared memory segment on local backup.
			//

			DWORD			dwClientIdentifier;
			JETBACK_SHARED_CONTROL jsc;
		} Backup;
		struct {
			BOOL						fJetCompleted;
			C							cUnitDone;
			C							cUnitTotal;
		} Restore;
	} u;
} JETBACK_SERVER_CONTEXT, *PJETBACK_SERVER_CONTEXT;

//
// Structure representing ExpiryToken
//
typedef struct
{
    DWORD       dwVersion;      // token version (only one version is supported now)
    LONGLONG    dsBackupTime;   // time stamp on backup copy (number of seconds since 1601)
    DWORD       dwTombstoneLifeTimeInDays; // tombstone life time as per the DS
} EXPIRY_TOKEN;

//
//	Server side private routines.
//

typedef ULONG MessageId;

VOID
GetCurrentSid(
	PSID *ppsid
	);
BOOL
FBackupServerAccessCheck(
	BOOL fRestoreOperation
	);

DWORD
AdjustBackupRestorePrivilege(
	BOOL fEnable,
	BOOL fRestoreOperation,
	PTOKEN_PRIVILEGES ptpPrevious,
	DWORD *pcbptpPrevious
	);

LONGLONG
GetSecsSince1601();

HRESULT
HrFromJetErr(
	JET_ERR jetError
	);

HRESULT
HrDestroyCxh(
	CXH cxh
	);

BOOL
FIsAbsoluteFileName(SZ szFileName);

HRESULT
HrAnnotateMungedFileList(
	PJETBACK_SERVER_CONTEXT pjsc,
	WSZ wszFileList,
	CB cbFileList,
	WSZ *pwszAnnotatedList,
	CB *pcbAnnotatedList
	);

HRESULT
HrMungedFileNamesFromJetFileNames(
	WSZ *pszMungedList,
	C *pcbSize,
	SZ szJetAttachmentList,
	C cbJetSize,
	BOOL fAnnotated
	);

HRESULT
HrMungedFileNameFromJetFileName(
	SZ szJetFileName,
	WSZ *pszMungedFileName
	);

HRESULT
HrJetFileNameFromMungedFileName(
	WSZ szMungedList,
	SZ *pszJetFileName
	);

VOID
RestoreRundown(
	PJETBACK_SERVER_CONTEXT pjsc
	);

EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    );

BOOL
FInitializeRestore();

BOOL
FUninitializeRestore();

DWORD
getTombstoneLifetimeInDays(
    VOID
    );

//
//	Client side private routines.
//

HRESULT
HrCreateRpcBinding( I iszProtoseq, WSZ szServer, handle_t * phBinding );

void
UnbindRpc( handle_t *phBinding );

HRESULT
HrJetbpConnectToBackupServer(
	WSZ szBackupServer,
	WSZ szBackupAnnotation,
	RPC_IF_HANDLE rifHandle,
	RPC_BINDING_HANDLE *prbhBinding
	);

BOOL
FBackupClientAccessCheck(
	BOOL fRestoreOperation
	);

BOOL
FIsInBackupGroup(
	BOOL fRestoreOperation
	);


WSZ
WszFromSz(LPCSTR Sz);


HRESULT
HrGetTombstoneLifeTime(
    LPCWSTR wszBackupServer,
    LPDWORD pdwTombstoneLifeTimeDays
    );

extern
WSZ
rgszProtSeq[];

extern
long
cszProtSeq;


//
//	Sockets related APIs and prototypes.
//

HRESULT
HrCreateBackupSockets(
	SOCKET rgsockSocketHandles[],
	PROTVAL rgprotvalProtocolsUsed[],
	C *pcSocketHandles
	);

SOCKET
SockWaitForConnections(
	SOCKET rgsockSocketHandles[],
	C cSocketMax
	);

SOCKET
SockConnectToRemote(
	SOCKADDR rgsockaddrClient[],
	C cSocketMax
	);

HRESULT
HrSockAddrsFromSocket(
	OUT SOCKADDR sockaddr[],
	OUT C *pcSockets,
	IN SOCKET sock,
	IN PROTVAL protval
	);


BOOL
FInitializeSocketClient(
	);

BOOL
FInitializeSocketServer(
	);

BOOL
FUninitializeSocketClient(
	);

BOOL
FUninitializeSocketServer(
	);

HRESULT
I_DsRestoreW(
	HBC hbc,
	WSZ szCheckpointFilePath,
	WSZ szLogPath,
	EDB_RSTMAPW __RPC_FAR rgrstmap[  ],
	C crstmap,
	WSZ szBackupLogPath,
	unsigned long genLow,
	unsigned long genHigh,
	BOOLEAN *pfRecoverJetDatabase);

HRESULT
I_DsCheckBackupLogs(
	WSZ wszBackupAnnotation
	);


BOOLEAN
FIsLoopbackedBinding(
    WSZ wszServerName
	);

BOOLEAN
FCreateSharedMemorySection(
	PJETBACK_SHARED_CONTROL pjsc,
	DWORD dwClientIdentifier,
	BOOLEAN	fClientOperation,
	CB	cbSharedMemory
	);

VOID
CloseSharedControl(
	PJETBACK_SHARED_CONTROL pjsc
	);

VOID
LogNtdsErrorEvent(
    IN DWORD EventMid,
    IN DWORD ErrorCode
    );

DWORD
CreateNewInvocationId(
    IN BOOL     fSaveGuid,
    OUT GUID    *NewId
    );

DWORD
RegisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf,
    IN  LPWSTR          pszAnnotation
    );

DWORD
UnregisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf
    );

#ifdef	DEBUG
VOID
DebugPrint(char *format,...);

BOOL GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD dwBufferLen // required/provided TextualSid buffersize
    );

VOID
OpenTraceLogFile(
    VOID
    );

BOOL
FInitializeTraceLog(
    VOID
    );

VOID
UninitializeTraceLog(
    VOID
    );

NET_API_STATUS
TruncateLog(
    VOID
    );

		   
#define	DebugTrace(x)	DebugPrint x
#undef KdPrint
#define KdPrint(x)	DebugPrint x
#else
#define	DebugTrace(x)
#endif

#endif	// _JETBP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetbsock.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetbsock.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetbsock.c

Abstract:

    This module provides socket support for the exchange MDB/DS backup APIs.


Author:

    Larry Osterman (larryo) 1-Sep-1994


Revision History:

--*/
#define UNICODE

#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <rpcdce.h>
#include <svcguid.h>

#ifdef  SOCKETS

WSADATA
wsaDataClient;

WSADATA
wsaDataServer;

HRESULT
HrCreateBackupSockets(
    SOCKET rgsockSocketHandles[],
    PROTVAL rgprotvalProtocolsUsed[],
    C *pcSocket
    )
/*++

Routine Description:

    This will create a socket for each of the socket protocols registered
    for backup processing.

Arguments:

    rgsockSocketHandles - Filled in with the sockets that have been allocated.
    rgprotvalProtocolsUsed - Protocol value for each of the socket handles.
    pcSocket - IN: the maximum number of entries available in the rgsockSocketHandles array.
                OUT: the number of actual sockets read.

Return Value:

    HRESULT - hrNone if no error, otherwise a reasonable value.

--*/
{
    SOCKET sock;

    //
    //  Start at the beginning.
    //
    *pcSocket = 0;

    sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if ( sock != INVALID_SOCKET ) {
        HRESULT hrErr;
        struct sockaddr_in sockaddr = {0};

        sockaddr.sin_family = AF_INET;

        //
        // Bind the socket to the local address specified.
        //

        hrErr = bind( sock, (PSOCKADDR)&sockaddr, sizeof(sockaddr) );
        if ( hrErr != NO_ERROR ) {
            closesocket( sock );
            return hrErr;
        }

        //
        // Start listening for incoming sockets on the socket if this is
        // not a datagram socket.  If this is a datagram socket, then
        // the listen() API doesn't make sense; doing a bind() is
        // sufficient to listen for incoming datagrams on a
        // connectionless protocol.
        //
    
        hrErr = listen( sock, 5 );
        if ( hrErr != NO_ERROR ) {
            closesocket( sock );
            return hrErr;
        }

        //
        //  Ok, we're ready to rock&roll now.
        //

        rgsockSocketHandles[*pcSocket] = sock;
        rgprotvalProtocolsUsed[*pcSocket] = IPPROTO_TCP;
        *pcSocket += 1;

    }
    //
    //  The client socket has been created, and it is now listening, we
    //  can finish now.
    //

    return(hrNone);
}


SOCKET
SockWaitForConnections(
    SOCKET rgsockSocketHandles[],
    C cSocketMax
    )
/*++

Routine Description:

    Waits for a connection to be established on any of the specified sockets.

Arguments:

    rgsockSocketHandles - An array of socket handles to accept connections on.
    C cSocketMax - The number of sockets to wait on.

Return Value:

    A connected socket handle, or INVALID_SOCKET if the connection
    could not be established.

--*/
{
    I iT;
    C cSocketsConnected;
    fd_set fdset;
    struct timeval timeval = {5, 0};

    fdset.fd_count = 0;

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        FD_SET(rgsockSocketHandles[iT], &fdset);
    }


    cSocketsConnected = select(FD_SETSIZE, &fdset, NULL, NULL, &timeval);

    if (cSocketsConnected == 0)
    {
        SetLastError(WAIT_TIMEOUT);
        return(INVALID_SOCKET);
    }
    else if (cSocketsConnected == SOCKET_ERROR)
    {
        return(INVALID_SOCKET);
    }

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        if (FD_ISSET(rgsockSocketHandles[iT], &fdset)) {
            return(accept(rgsockSocketHandles[iT], NULL, 0));
        }
    }

    return INVALID_SOCKET;
}

HRESULT
HrSockAddrsFromSocket(
    OUT SOCKADDR sockaddr[],
    OUT C *pcSocket,
    IN SOCKET sock,
    IN PROTVAL protval
    )
/*++

Routine Description:

    Converts a socket handle into a sockaddr suitable for connecting to the specified socket.

Arguments:

    sockaddr - the socket to connect to.
    sock - the socket to convert.
    protval - the protocol used for the socket.

Return Value:

    ecNone if the operation as successful, a reasonable value otherwise.

--*/
{

    switch (protval)
    {
    case IPPROTO_TCP:
        {
            CB cbAddrSize = sizeof(SOCKADDR);
            SOCKADDR sockaddrT;
            char    rgchComputerName[MAX_COMPUTERNAME_LENGTH + 1];
            CB cbComputerName = sizeof(rgchComputerName);
            struct hostent *hostentT;
            struct sockaddr_in *sockaddrinT = (struct sockaddr_in *)sockaddr;

            if (getsockname(sock, &sockaddrT, &cbAddrSize) == INVALID_SOCKET) {
                return(GetLastError());
            }
        
            if (cbAddrSize > sizeof(SOCKADDR))
            {
                return(hrInvalidParam);
            }
        
            if (gethostname(rgchComputerName, cbComputerName) == SOCKET_ERROR)
            {
                return(GetLastError());
            }

            hostentT = gethostbyname(rgchComputerName);

            //
            //  If there are multiple entries to return, return them.
            //

            *pcSocket = 0;
            while (hostentT->h_addr_list[*pcSocket])
            {
                //
                //  Copy in the fixed portion of the socket address.
                //

                memcpy(sockaddrinT, &sockaddrT, cbAddrSize);
                sockaddrinT->sin_addr = *((struct in_addr *)hostentT->h_addr_list[*pcSocket]);
                *pcSocket += 1;
                sockaddrinT = (struct sockaddr_in *)(++sockaddr);
            }

            break;
        }
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return(hrNone);
}

SOCKET
SockConnectToRemote(
    SOCKADDR rgsockaddrClient[],
    C cSocketMax
    )
/*++

Routine Description:

    Converts a socket handle into a sockaddr suitable for connecting to the specified socket.

Arguments:

    rgsockaddrClient - The address of the client.
    rgprotvalClient - the protocol used by the client.
    cSocketMax - the number of sockets that can be used to connect to the client.

Return Value:

    scNone if the operation as successful, a reasonable value otherwise.

--*/
{
    I iT;
    SOCKET sock;

    for (iT = 0 ; iT < cSocketMax ; iT += 1)
    {
        if (rgsockaddrClient[iT].sa_family == AF_INET)
        {
            struct sockaddr_in sockaddrLocal;

            memset(&sockaddrLocal, 0, sizeof(struct sockaddr_in));

            sock = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP);

            //
            //  If we can't open a socket with this address, keep on trying.
            //
            if (sock == INVALID_SOCKET)
            {
                continue;
            }

            //
            //  Bind this socket to the first available port on the server.
            //

            sockaddrLocal.sin_family = AF_INET;
            sockaddrLocal.sin_port = 0;
            sockaddrLocal.sin_addr.s_addr = 0;

            if (bind(sock, (struct sockaddr *)&sockaddrLocal, sizeof(struct sockaddr_in)) == SOCKET_ERROR)
            {
                closesocket(sock);
                sock = INVALID_SOCKET;
                continue;
            }

            //
            //  Now connect back to the client.
            //
            if (connect(sock, &rgsockaddrClient[iT], sizeof(struct sockaddr_in)) == SOCKET_ERROR)
            {
                closesocket(sock);
                sock = INVALID_SOCKET;
                continue;
            }

            //
            //  It succeeded, we're done.
            //

            return(sock);
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(INVALID_SOCKET);
        }
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return INVALID_SOCKET;
}


BOOL
FInitializeSocketClient(
    )
{
    WORD wVersionRequested;
    int iError;
    wVersionRequested = MAKEWORD(1,1);

    //
    //  Register ourselves with winsock.
    //

    iError = WSAStartup(wVersionRequested, &wsaDataClient);

    //
    //  The winsock implementation is not version 1.1, so
    //  punt.
    //

    if (iError != 0)
    {
        return(FALSE);
    }


    return(fTrue);
}

BOOL
FUninitializeSocketClient(
    )
{
    return(fTrue);
}
BOOL
FInitializeSocketServer(
    )
{
    WORD wVersionRequested;
    int iError;
    wVersionRequested = MAKEWORD(1,1);

    //
    //  Register ourselves with winsock.
    //

    iError = WSAStartup(wVersionRequested, &wsaDataServer);

    //
    //  The winsock implementation is not version 1.1, so
    //  punt.
    //

    if (iError != 0)
    {
        return(FALSE);
    }

    return(fTrue);

}

BOOL
FUninitializeSocketServer(
    )
{
    return(fTrue);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\common.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       common.c
//
//--------------------------------------------------------------------------

/*
 *	COMMON.C
 *	
 *	Code common between restore client and server.
 *	
 *	
 */
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>
#include <windows.h>
#include <stdlib.h> // wsplitpath
#include <mxsutil.h>
#include <rpc.h>
#include <ntdsbcli.h>
#include <dsconfig.h>
#include <jetbp.h>
#include <mdcodes.h>
#include <ntdsa.h>
#include <dsevent.h>    // pszNtdsSourceGeneral


WSZ
WszFromSz(
	IN	LPCSTR Sz
	)
{
	WSZ Wsz;
	CCH cchWstr;

	cchWstr = MultiByteToWideChar(CP_ACP, 0, Sz, -1, NULL, 0);

	if (cchWstr == 0)
	{
		return(NULL);
	}

	Wsz = MIDL_user_allocate(cchWstr*sizeof(WCHAR));

	if (Wsz == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return(NULL);
	}

	if (MultiByteToWideChar(CP_ACP, 0, Sz, -1, Wsz, cchWstr) == 0) {
		MIDL_user_free(Wsz);
		return(NULL);
	}

	return(Wsz);
}

/*
 -	FGetCurrentSid
 -
 *	Purpose:
 *		Retrieves the current SID of the logged on user.
 *
 *	Parameters:
 *		psidCurrentUser - Filled in with the SID of the current user.
 *
 *	Returns:
 *		fTrue if we retrieved the SID.
 *
 */

VOID
GetCurrentSid(
	PSID *ppsid
	)
{
	HANDLE hToken;
	CB cbUserLength = 200;
	PTOKEN_USER ptuUserInfo = (PTOKEN_USER)LocalAlloc(0, cbUserLength);

	*ppsid = NULL;

	if (ptuUserInfo == NULL) {
		DebugTrace(("GetCurrentSid: Unable to allocate token_user structure: %d\n", GetLastError()));
		return;
	}

	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, fTrue, &hToken))
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
			DebugTrace(("GetCurrentSid: OpenProcess and ThreadToken fails: %d\n", GetLastError()));
            LocalFree(ptuUserInfo);
			return;
		}
	}
	
	if (!GetTokenInformation(hToken, TokenUser, ptuUserInfo, cbUserLength, &cbUserLength)) {
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
			DebugTrace(("GetCurrentSid: GetTokenInformation failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			LocalFree(ptuUserInfo);
			return;
		}

		LocalFree(ptuUserInfo);

		ptuUserInfo = (PTOKEN_USER)LocalAlloc(0, cbUserLength);

		if (ptuUserInfo == NULL) {
			DebugTrace(("GetCurrentSid: Allocate of buffer failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			return;
		}

		if (!GetTokenInformation(hToken, TokenUser, ptuUserInfo, cbUserLength, &cbUserLength)) {
			DebugTrace(("GetCurrentSid: GetTokenInformation failed: %d\n", GetLastError()));
			CloseHandle(hToken);
			LocalFree(ptuUserInfo);
			return;
		}
	}

	
	Assert(IsValidSid(ptuUserInfo->User.Sid));

	*ppsid = LocalAlloc(0, GetLengthSid(ptuUserInfo->User.Sid));

	if (*ppsid == NULL)
	{
		DebugTrace(("GetCurrentSid: Allocation of new SID failed: %d\n", GetLastError()));
        CloseHandle(hToken);
        LocalFree(ptuUserInfo);
		return;
	}

	//
	//	We know know the SID (and attributes) of the current user.  Return the SID.
	//

	CopySid(GetLengthSid(ptuUserInfo->User.Sid), *ppsid, ptuUserInfo->User.Sid);

	Assert(IsValidSid(*ppsid));

	LocalFree(ptuUserInfo);

	CloseHandle(hToken);
}


BOOL
InitializeSectionEventDacl(
    PACL *ppDacl
    )

/*++

Routine Description:

This routine constructs a Dacl which allows ourself and local system
access.  We grant all access for both section and event objects, which is
what this dacl is currently used for.

Arguments:

    ppDacl - pointer to pointer to receive allocated pDacl. Caller must
    deallocate using HeapFree

Return Value:

    BOOL - success/failure

--*/

{
    DWORD status;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PACL pDacl = NULL;
    PSID pAdministratorsSid = NULL;
    PSID pSelfSid = NULL;
    DWORD dwAclSize;

    //
    // preprate a Sid representing the well-known admin group
    // Are both the local admin and the domain admin members of this group?
    //

    if (!AllocateAndInitializeSid(
        &sia,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &pAdministratorsSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to allocate and init sid, error %d\n", status));
        goto cleanup;
    }

    // Here is a sid for ourself
    GetCurrentSid( &pSelfSid );
    if (pSelfSid == NULL) {
        status = GetLastError();
        DebugTrace(("Unable to allocate and init sid, error %d\n", status));
        goto cleanup;
    }

    //
    // compute size of new acl
    //
    dwAclSize = sizeof(ACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pAdministratorsSid) +
        GetLengthSid(pSelfSid);

    //
    // allocate storage for Acl
    //
    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
    if(pDacl == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace(("Unable to allocate acl, error %d\n", status));
        goto cleanup;
    }

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        status = GetLastError();
        DebugTrace(("Unable to initialize acl, error %d\n", status));
        goto cleanup;
    }

    //
    // grant the Administrators Sid access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        (SECTION_ALL_ACCESS|EVENT_ALL_ACCESS),
        pAdministratorsSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to add access allowed ace, error %d\n", status));
        goto cleanup;
    }

    //
    // grant the Self Sid access
    //
    if (!AddAccessAllowedAce(
        pDacl,
        ACL_REVISION,
        (SECTION_ALL_ACCESS|EVENT_ALL_ACCESS),
        pSelfSid
        )) {
        status = GetLastError();
        DebugTrace(("Unable to add access allowed ace, error %d\n", status));
        goto cleanup;
    }

    *ppDacl = pDacl;
    pDacl = NULL; // don't clean up

    status = ERROR_SUCCESS;

cleanup:

    if(pAdministratorsSid != NULL)
    {
        FreeSid(pAdministratorsSid);
    }

    if(pSelfSid != NULL)
    {
        FreeSid(pSelfSid);
    }

    if (pDacl) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    return (status == ERROR_SUCCESS) ? TRUE : FALSE;
} /* InitializeSectionDacl */

BOOLEAN
FCreateSharedMemorySection(
	PJETBACK_SHARED_CONTROL pjsc,
	DWORD dwClientIdentifier,
	BOOLEAN	fClientOperation,
	CB	cbSharedMemory
	)
{
	WCHAR rgwcMutexName[ MAX_PATH ];
	WCHAR rgwcClientEventName[ MAX_PATH ];
	WCHAR rgwcServerEventName[ MAX_PATH ];
	WCHAR rgwcSharedName[ MAX_PATH ];

	SECURITY_ATTRIBUTES	*	psa = NULL;

	SECURITY_ATTRIBUTES		sa;
	char		rgbForSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
	SECURITY_DESCRIPTOR *  	psd;
        PACL pDacl = NULL;
	BOOLEAN fResult = fFalse;  // assume failure

// Both client and server ends map the section.  Although the bulk of the data
// passes from server to client (server:write,client:read), the client writes
// some initial configuation data in the section for the server initially.
// Both need write. Thus access is ourself:write,admin:write.  The first is for
// ourself, the second is for the ds running as LocalSystem.

	psa = &sa;
	psd = (SECURITY_DESCRIPTOR *)rgbForSecurityDescriptor;

	if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
		return fFalse;

        if (!InitializeSectionEventDacl( &pDacl ))
            return fFalse;

	// Add DACL to the security descriptor..
	if (!SetSecurityDescriptorDacl(psd, TRUE, pDacl, FALSE)) {
            fResult = fFalse;
            goto cleanup;
        }

	psa->nLength = sizeof(*psa);
	psa->lpSecurityDescriptor = psd;
	psa->bInheritHandle = FALSE;

	wsprintfW(rgwcMutexName, LOOPBACKED_CRITSEC_MUTEX_NAME, dwClientIdentifier);
	wsprintfW(rgwcClientEventName, LOOPBACKED_READ_EVENT_NAME, dwClientIdentifier);
	wsprintfW(rgwcServerEventName, LOOPBACKED_WRITE_EVENT_NAME, dwClientIdentifier);
	wsprintfW(rgwcSharedName, LOOPBACKED_SHARED_REGION, dwClientIdentifier);

	//
	//	Allocate the shared memory section.  The size of the section is the size requested, plus enough
	//	memory for the header (which means 1 more page).
	//

	pjsc->hSharedMemoryMapping = CreateFileMappingW(
            (HANDLE) (-1),
            psa,
            PAGE_READWRITE,
            0,
            cbSharedMemory + sizeof(JETBACK_SHARED_HEADER),
            rgwcSharedName
            );

	//
	//	Ok, we've created our shared memory region, we now want to open up the
	//	read, write, and critical section events (and mutex).
	//
        // Jan 25, 1999 wlees. Events made auto-reset with SetEvent being used
        // instead of PulseEvent.
        // heventRead is used to synchronize when the writing-side has more
        // data available.  See jetback\jetback.c
        // heventWrite is used to synchonize when the read-side has consumed
        // the data. See jetbcli\jetbcli.c
	if (pjsc->hSharedMemoryMapping != NULL)
	{
		if (pjsc->heventRead = CreateEventW(psa, fFalse /* ManualReset is false ==> AutoReset */, fFalse, rgwcClientEventName))
		{
			if (pjsc->heventWrite = CreateEventW(psa, fFalse /* ManulReset is False means AutoReset*/, fFalse, rgwcServerEventName))
			{
				if (pjsc->hmutexSection = CreateMutexW(psa, FALSE, rgwcMutexName))
				{
					if ((pjsc->pjshSection = MapViewOfFile(pjsc->hSharedMemoryMapping, FILE_MAP_WRITE,0,0,0)) != NULL)
					{
						//
						//	Initialize the shared memory section.
						//

						if (fClientOperation)
						{
							SYSTEM_INFO si;

							//
							//	Take cbReadHintSize, and round it up to the nearest page size (on the client).
							//

							GetSystemInfo(&si);

							//
							//	Guarantee that dwPageSize is a power of 2
							//

							Assert ((si.dwPageSize & ~si.dwPageSize) == 0);

							pjsc->pjshSection->cbPage = si.dwPageSize;
							pjsc->pjshSection->cbSharedBuffer = cbSharedMemory;
							pjsc->pjshSection->dwReadPointer = 0;
							pjsc->pjshSection->dwWritePointer = 0;
							pjsc->pjshSection->cbReadDataAvailable = 0;
							pjsc->pjshSection->fReadBlocked = fFalse;	//	Read operation is blocked
							pjsc->pjshSection->fWriteBlocked = fFalse;	//	Write operation is blocked
						} else
						{
							Assert(pjsc->pjshSection->cbSharedBuffer == (DWORD) cbSharedMemory);
						}

						//
						//	Ok, we're ready to use the shared memory section!!!!
						//

						fResult = fTrue;
					}
				}
			}
		}
	}

cleanup:
#if DEBUG
        if (!fResult) {
            DebugTrace(("fCreateSharedMemoryFailed, client=%d, error %d\n", fClientOperation, GetLastError()));
        }
#endif
        // Free the ACL now that we are finished with it
        if (pDacl) {
            HeapFree(GetProcessHeap(), 0, pDacl);
        }

	return fResult;
}

VOID
CloseSharedControl(
	PJETBACK_SHARED_CONTROL pjsc
	)
{
	if (pjsc->pjshSection)
	{
		UnmapViewOfFile((HANDLE )pjsc->pjshSection);
		pjsc->pjshSection = NULL;
	}

	if (pjsc->hSharedMemoryMapping)
	{
		CloseHandle(pjsc->hSharedMemoryMapping);
		pjsc->hSharedMemoryMapping = NULL;
	}

	if (pjsc->heventRead)
	{
		CloseHandle(pjsc->heventRead);
		pjsc->heventRead = NULL;
	}

	if (pjsc->heventWrite)
	{
		CloseHandle(pjsc->heventWrite);
		pjsc->heventWrite = NULL;
	}

	if (pjsc->hmutexSection)
	{
		CloseHandle(pjsc->hmutexSection);
		pjsc->hmutexSection = NULL;
	}
}


VOID
LogNtdsErrorEvent(
    IN DWORD EventMid,
    IN DWORD ErrorCode
    )
/*++

Routine Description:

    This function writes an error event with the given description into the
    directory service error log.

Arguments:

    Description - Supplies the text for the error description.
    ErrorCode - Supplies the error code to be displayed.

Return Value:

    None

--*/
{

    HANDLE hEventSource = NULL;
    DWORD err;
    BOOL succeeded;
    WCHAR errorCodeText[16];
    WCHAR *inserts[1];

    hEventSource = RegisterEventSourceA(NULL, pszNtdsSourceGeneral);

    if (hEventSource == NULL)
        goto CleanUp;

    if (!_itow(ErrorCode, errorCodeText, 10))
        goto CleanUp;

    inserts[0] = errorCodeText;

    succeeded = ReportEvent(hEventSource,
                            EVENTLOG_ERROR_TYPE,
                            BACKUP_CATEGORY,
                            EventMid,
                            NULL,
                            1,
                            0,
                            inserts,
                            NULL);

    if (!succeeded)
        goto CleanUp;

CleanUp:

    if (hEventSource != NULL)
    {
        DeregisterEventSource(hEventSource);
    }

} // LogNtdsErrorEvent


DWORD
CreateNewInvocationId(
    IN BOOL     fSaveGuid,
    OUT GUID    *NewId
    )
{
    RPC_STATUS rpcStatus;
    DWORD dwErr;
    HKEY hKey;
    PWCHAR pszUuid = NULL;

    //
    // Try to create one
    //

    rpcStatus = UuidCreate(NewId);

    if ( (rpcStatus != RPC_S_OK)
#if 0
         // 2000-02-23 JeffParh
         // Local UUIDs are bad, particularly for invocation IDs.
         && (rpcStatus != RPC_S_UUID_LOCAL_ONLY)
#endif
         ) {
        
        return rpcStatus;
    }

    if ( !fSaveGuid ) {
        return ERROR_SUCCESS;
    }

    //
    // Store this new uuid in a registry key so it can be reused by a second
    // Auth restore and by the restore from backup code in the bootup code
    //

    // Open the DS parameters key.

    dwErr = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
                        DSA_CONFIG_SECTION,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey);

    if ( ERROR_SUCCESS != dwErr ) {
        return dwErr;
    } 

    rpcStatus = UuidToString(NewId, &pszUuid);

    if ( rpcStatus != RPC_S_OK ) {
        RegCloseKey(hKey);
        return rpcStatus;
    }

    dwErr = RegSetValueEx(  hKey, 
                            RESTORE_NEW_DB_GUID,
                            0, 
                            REG_SZ, 
                            (BYTE *) pszUuid,
                            (wcslen(pszUuid) + 1)*sizeof(WCHAR));

    RpcStringFree(&pszUuid);
    RegCloseKey(hKey);

    if ( ERROR_SUCCESS != dwErr ) {
        return dwErr;
    } 

    return ERROR_SUCCESS;

} // CreateNewInvocationId


DWORD
RegisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf,
    IN  LPWSTR          pszAnnotation
    )
/*++

Routine Description:

    Registers the given (backup or restore) RPC interface.

Arguments:

    hRpcIf (IN) - Interface to register.
    
    pszAnnotation (IN) - Interface description.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err;
    RPC_BINDING_VECTOR *rgrbvVector = NULL;
    BOOL fEpsRegistered = FALSE;
    BOOL fIfRegistered = FALSE;

    __try {
        DebugTrace(("RegisterRpcInterface: Register %S\n", pszAnnotation));
    
        err = RpcServerInqBindings(&rgrbvVector);
    
        if (err == RPC_S_NO_BINDINGS) {
            //
            //  If there are no existing bindings, then we need to register all
            //  our protocol sequences.
            //
    
            err = RpcServerUseAllProtseqs(RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL);
            if (err) {
                __leave;
            }
        }
    
        err = RpcEpRegisterW(hRpcIf, rgrbvVector, NULL, pszAnnotation);
        if (err) {
            __leave;
        }

        fEpsRegistered = TRUE;
    
        //
        //  Now register the interface with RPC.
        //
    
        err = RpcServerRegisterIf(hRpcIf, NULL, NULL);
        if (err) {
            __leave;
        }

        fIfRegistered = TRUE;
    
        //
        //  Now make this endpoint secure using WinNt security.
        //
    
        err = RpcServerRegisterAuthInfoA(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);
        if (err) {
            __leave;
        }
    
        err = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, fTrue);
    
        //
        //  We want to ignore the "already listening" error.
        //
    
        if (RPC_S_ALREADY_LISTENING == err) {
            err = 0;
        }
    
    } __finally {
        if (err) {
            if (fEpsRegistered) {
                RpcEpUnregister(hRpcIf, rgrbvVector, NULL);
            }
            
            if (fIfRegistered) {
                RpcServerUnregisterIf(hRpcIf, NULL, TRUE);
            }
        }

        if (NULL != rgrbvVector) {
            RpcBindingVectorFree(&rgrbvVector);
        }
    }

    return err;
}

DWORD
UnregisterRpcInterface(
    IN  RPC_IF_HANDLE   hRpcIf
    )
/*++

Routine Description:

    Unregisters the given (backup or restore) RPC interface, which presumably
    was previously registered successfully via RegisterRpcInterface().

Arguments:

    hRpcIf (IN) - Interface to unregister.

Return Values:

    0 or Win32 error.

--*/
{
    DWORD err;
    RPC_BINDING_VECTOR *rgrbvVector;

    err = RpcServerInqBindings(&rgrbvVector);
    
    if (!err) {
        RpcEpUnregister(hRpcIf, rgrbvVector, NULL);
        
        RpcBindingVectorFree(&rgrbvVector);
        
        err = RpcServerUnregisterIf(hRpcIf, NULL, TRUE);
    }

    return err;
}

#ifdef	DEBUG

#define TRACE_FILE_SIZE 256

VOID
ResetTraceLogFile(
    VOID
    );

CRITICAL_SECTION
critsTraceLock = {0};

DWORD
dwDebugFileLimit = 10000000;

TER
terTraceEnabled = terUnknown;


HANDLE
hfileTraceLog = NULL;
UCHAR chLast = '\n';

DWORD
dwTraceLogFileSize = 0;

BOOLEAN fTraceInitialized = {0};

#include <lmshare.h>
#include <lmapibuf.h>
#include <lmerr.h>

/*++

A standardized shorthand notation for SIDs makes it simpler to
visualize their components:

S-R-I-S-S...

In the notation shown above,

S identifies the series of digits as an SID,
R is the revision level,
I is the identifier-authority value,
S is subauthority value(s).

An SID could be written in this notation as follows:
S-1-5-32-544

In this example,
the SID has a revision level of 1,
an identifier-authority value of 5,
first subauthority value of 32,
second subauthority value of 544.
(Note that the above Sid represents the local Administrators group)

The GetTextualSid function will convert a binary Sid to a textual
string.

The resulting string will take one of two forms.  If the
IdentifierAuthority value is not greater than 2^32, then the SID
will be in the form:

S-1-5-21-2127521184-1604012920-1887927527-19009
  ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
  | | |		 |			|		   |		|
  +-+-+------+----------+----------+--------+--- Decimal

Otherwise it will take the form:

S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
  ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
  |		  |		   |	  |			 |			|		 |
  |	  Hexidecimal  |	  |			 |			|		 |
  +----------------+------+----------+----------+--------+--- Decimal

If the function succeeds, the return value is TRUE.
If the function fails, the return value is FALSE.  To get extended
	error information, call the Win32 API GetLastError().

Scott Field (sfield)	11-Jul-95
Unicode enabled

Scott Field (sfield)	15-May-95
--*/

BOOL GetTextualSid(
	PSID pSid,			// binary Sid
	LPWSTR szTextualSid,  // buffer for Textual representaion of Sid
	LPDWORD dwBufferLen // required/provided TextualSid buffersize
	)
{
	PSID_IDENTIFIER_AUTHORITY psia;
	DWORD dwSubAuthorities;
	DWORD dwSidRev=SID_REVISION;
	DWORD dwCounter;
	DWORD dwSidSize;

	//
	// test if Sid passed in is valid
	//
	if(!IsValidSid(pSid)) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	// obtain SidIdentifierAuthority
	psia=GetSidIdentifierAuthority(pSid);

	// obtain sidsubauthority count
	dwSubAuthorities=*GetSidSubAuthorityCount(pSid);

	//
	// compute buffer length
	// S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
	//
	dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(WCHAR);

	//
	// check provided buffer length.
	// If not large enough, indicate proper size and setlasterror
	//
	if (*dwBufferLen < dwSidSize)
	{
		DebugTrace(("Buffer too small.  Requested %d bytes, %d needed\n", *dwBufferLen, dwSidSize));
		*dwBufferLen = dwSidSize;
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	//
	// prepare S-SID_REVISION-
	//
	wsprintfW(szTextualSid, L"S-%lu-", dwSidRev );

	//
	// prepare SidIdentifierAuthority
	//
	if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid),
					L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
					(USHORT)psia->Value[0],
					(USHORT)psia->Value[1],
					(USHORT)psia->Value[2],
					(USHORT)psia->Value[3],
					(USHORT)psia->Value[4],
					(USHORT)psia->Value[5]);
	}
	else
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid), L"%lu",
					(ULONG)(psia->Value[5]		)	+
					(ULONG)(psia->Value[4] <<  8)	+
					(ULONG)(psia->Value[3] << 16)	+
					(ULONG)(psia->Value[2] << 24)	);
	}

	//
	// loop through SidSubAuthorities
	//
	for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
	{
		wsprintfW(szTextualSid + wcslen(szTextualSid), L"-%lu",
					*GetSidSubAuthority(pSid, dwCounter) );
	}

	SetLastError(NO_ERROR);
	return TRUE;
}
VOID
DebugPrint(char *szFormat,...)
#define LAST_NAMED_ARGUMENT szFormat

{
	CHAR rgchOutputString[4096];
	ULONG ulBytesWritten;

	va_list ParmPtr;					// Pointer to stack parms.

	if (terTraceEnabled == terUnknown)
	{
		HRESULT hr;
		HKEY hkey;
		DWORD dwType;
		DWORD fTraceEnabled;
		DWORD cbTraceEnabled;

		if (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, BACKUP_INFO, 0, KEY_READ, &hkey))
		{
			terTraceEnabled = terFalse;
		}
		dwType = REG_DWORD;
		cbTraceEnabled = sizeof(fTraceEnabled);
		hr = RegQueryValueEx(hkey, ENABLE_TRACE, 0, &dwType, (LPBYTE)&fTraceEnabled, &cbTraceEnabled);
	
		RegCloseKey(hkey);
		if (hr != hrNone)
		{
			terTraceEnabled = terFalse;
		}
		if (fTraceEnabled)
		{
			terTraceEnabled = terTrue;
		}
		
	}

	if (terTraceEnabled == terFalse)
	{
		return;
	}


	if (!fTraceInitialized) {
		if (!FInitializeTraceLog())
            return;
	}

	EnterCriticalSection(&critsTraceLock);

	try {

		if (hfileTraceLog == NULL) {
			//
			//	We've not opened the trace log file yet, so open it.
			//

			OpenTraceLogFile();
		}

		if (hfileTraceLog == INVALID_HANDLE_VALUE) {
			LeaveCriticalSection(&critsTraceLock);
			return;
		}

		//
		//	Attempt to catch bad trace.
		//

		for (ulBytesWritten = 0; ulBytesWritten < strlen(szFormat) ; ulBytesWritten += 1) {
			if (szFormat[ulBytesWritten] > 0x7f) {
				DebugBreak();
			}
		}

		if (chLast == '\n') {
			SYSTEMTIME SystemTime;

			GetLocalTime(&SystemTime);

			//
			//	The last character written was a newline character.	 We should
			//	timestamp this record in the file.
			//

			sprintf(rgchOutputString, "%2.2d/%2.2d/%4.4d %2.2d:%2.2d:%2.2d.%3.3d: ", SystemTime.wMonth,
															SystemTime.wDay,
															SystemTime.wYear,
															SystemTime.wHour,
															SystemTime.wMinute,
															SystemTime.wSecond,
															SystemTime.wMilliseconds);

			if (!WriteFile(hfileTraceLog, rgchOutputString, strlen(rgchOutputString), &ulBytesWritten, NULL)) {
//				  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
				return;
			}

			if (ulBytesWritten != strlen(rgchOutputString)) {
//				  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
				return;
			}

			dwTraceLogFileSize += ulBytesWritten;

		}

		va_start(ParmPtr, LAST_NAMED_ARGUMENT);

		//
		//	Format the parameters to the string.
		//

		vsprintf(rgchOutputString, szFormat, ParmPtr);

		if (!WriteFile(hfileTraceLog, rgchOutputString, strlen(rgchOutputString), &ulBytesWritten, NULL)) {
//			  KdPrint(("Error writing to Browser log file: %ld\n", GetLastError()));
//			  KdPrint(("%s", rgchOutputString));
			return;
		}

		if (ulBytesWritten != strlen(rgchOutputString)) {
//			  KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
//			  KdPrint(("%s", rgchOutputString));
			return;
		}

		dwTraceLogFileSize += ulBytesWritten;

		//
		//	Remember the last character output to the log.
		//

		chLast = rgchOutputString[strlen(rgchOutputString)-1];

		if (dwTraceLogFileSize > dwDebugFileLimit) {
			ResetTraceLogFile();
		}

	} finally {
		LeaveCriticalSection(&critsTraceLock);
	}
}


BOOL
FInitializeTraceLog()
{

    __try
    {
	    InitializeCriticalSection(&critsTraceLock);
	    fTraceInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);
    }

    return TRUE;
}

VOID
GetTraceLogRoot(
	IN PWCHAR szTraceFileName
	)
{
	PSHARE_INFO_502 ShareInfo;
	WCHAR rgwcModuleName[ MAX_PATH ];
	WCHAR rgwcFileName[ MAX_PATH ];

	//
	//	If the DEBUG share exists, put the log file in that directory,
	//	otherwise, use the system root.
	//
	//	This way, if the browser is running on an NTAS server, we can always
	//	get access to the log file.
	//

	if (NetShareGetInfo(NULL, L"DEBUG", 502, (PCHAR *)&ShareInfo) != NERR_Success) {

		if (GetSystemDirectory(szTraceFileName, TRACE_FILE_SIZE*sizeof(WCHAR)) == 0)  {
//			  KdPrint(("Unable to get system directory: %ld\n", GetLastError()));
		}

		if (szTraceFileName[wcslen(szTraceFileName)] != L'\\') {
			szTraceFileName[wcslen(szTraceFileName)+1] = L'\0';
			szTraceFileName[wcslen(szTraceFileName)] = L'\\';
		}

	} else {
		//
		//	Seed the trace file buffer with the local path of the netlogon
		//	share if it exists.
		//

		wcscpy(szTraceFileName, ShareInfo->shi502_path);

		szTraceFileName[wcslen(ShareInfo->shi502_path)] = L'\\';
		szTraceFileName[wcslen(ShareInfo->shi502_path)+1] = L'\0';

		NetApiBufferFree(ShareInfo);
	}

	//
	//	Figure out our process name.
	//
	GetModuleFileName(NULL, rgwcModuleName, sizeof(rgwcModuleName));

	_wsplitpath(rgwcModuleName, NULL, NULL, rgwcFileName, NULL);

	wcscat(szTraceFileName, rgwcFileName);

}

VOID
ResetTraceLogFile(
	VOID
	)
{
	WCHAR rgwcOldTraceFile[TRACE_FILE_SIZE];
	WCHAR rgwcNewTraceFile[TRACE_FILE_SIZE];

	if (hfileTraceLog != NULL) {
		CloseHandle(hfileTraceLog);
	}

	hfileTraceLog = NULL;

	GetTraceLogRoot(rgwcOldTraceFile);

	wcscpy(rgwcNewTraceFile, rgwcOldTraceFile);

	wcscat(rgwcOldTraceFile, L".Backup.Log");

	wcscat(rgwcNewTraceFile, L".Backup.Bak");

	//
	//	Delete the old log
	//

	DeleteFile(rgwcNewTraceFile);

	//
	//	Rename the current log to the new log.
	//

	MoveFile(rgwcOldTraceFile, rgwcNewTraceFile);

	OpenTraceLogFile();

}

VOID
OpenTraceLogFile(
	VOID
	)
{
	WCHAR rgwcTraceFile[TRACE_FILE_SIZE];

	GetTraceLogRoot(rgwcTraceFile);

	wcscat(rgwcTraceFile, L".Backup.Log");

	hfileTraceLog = CreateFile(rgwcTraceFile,
										GENERIC_WRITE,
										FILE_SHARE_READ,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL);


	if (hfileTraceLog == INVALID_HANDLE_VALUE) {
//		  KdPrint(("Error creating trace file %ws: %ld\n", rgwcTraceFile, GetLastError()));

		return;
	}

	dwTraceLogFileSize = SetFilePointer(hfileTraceLog, 0, NULL, FILE_END);

	if (dwTraceLogFileSize == 0xffffffff) {
//		  KdPrint(("Error setting trace file pointer: %ld\n", GetLastError()));

		return;
	}
}

VOID
UninitializeTraceLog()
{
	if (fTraceInitialized)
	{
		DeleteCriticalSection(&critsTraceLock);

		if (hfileTraceLog != NULL) {
			CloseHandle(hfileTraceLog);
		}

		hfileTraceLog = NULL;

		fTraceInitialized = FALSE;
	}
}

NET_API_STATUS
TruncateLog()
{
	if (hfileTraceLog == NULL) {
		OpenTraceLogFile();
	}

	if (hfileTraceLog == INVALID_HANDLE_VALUE) {
		return ERROR_GEN_FAILURE;
	}

	if (SetFilePointer(hfileTraceLog, 0, NULL, FILE_BEGIN) == 0xffffffff) {
		return GetLastError();
	}

	if (!SetEndOfFile(hfileTraceLog)) {
		return GetLastError();
	}

	return NO_ERROR;
}

		


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\options.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       options.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1996

Module Name:

    options.h

Abstract:

    This module contains compile time options for the jet backup APIs.


Author:

    Larry Osterman (larryo) 2-Sep-1994


Revision History:


--*/

#ifndef	_OPTIONS_
#define	_OPTIONS_
#define	SOCKETS	1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\local.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       local.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    local.h

Abstract:

    Header file for common routines shared by both client and server

Author:

    Will Lees (wlees) 11-Sep-1998

Environment:

Notes:

Revision History:

--*/

#ifndef _LOCAL_
#define _LOCAL_

// Common routines

EC HrLocalQueryDatabaseLocations(
	SZ szDatabaseLocation,
	CB *pcbDatabaseLocationSize,
	SZ szRegistryBase,
	CB cbRegistryBase,
	BOOL *pfCircularLogging
    );

HRESULT
HrLocalGetRegistryBase(
	OUT WSZ wszRegistryPath,
	OUT WSZ wszKeyName
	);

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore );


HRESULT
HrLocalRestoreRegister(WSZ wszCheckpointFilePath,
                WSZ wszLogPath,
                EDB_RSTMAPW rgrstmap[],
                C crstmap,
                WSZ wszBackupLogPath,
                ULONG genLow,
                ULONG genHigh);

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore );

#endif /* _LOCAL_ */

/* end local.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\local.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       local.c
//
//--------------------------------------------------------------------------

/*
 *  LOCAL.C
 *  
 *  Code common between restore client and server.
 *  
 * wlees Aug 28, 1998
 *    Code to update the registry moved into the common section so the client
 *    library to utilize these functions too.
 *  
 */
#define UNICODE
#include <windows.h>
#include <mxsutil.h>
#include <rpc.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <mdcodes.h>
#include <dsconfig.h>
#include <stdlib.h>

/*
 -  EcDsarQueryStatus
 -
 *  Purpose:
 *
 *      This routine will return progress information about the restore process
 *
 *  Parameters:
 *      pcUnitDone - The number of "units" completed.
 *      pcUnitTotal - The total # of "units" completed.
 *
 *  Returns:
 *      ec
 *
 */
EC HrLocalQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    )
{
    EC ec = hrNone;
    char rgchPathBuf[ MAX_PATH ];
    SZ szDatabase = NULL;
    HKEY hkeyDs;
    DWORD dwType;
    DWORD cbBuffer;

    if (pcbDatabaseLocationSize)
    {
        *pcbDatabaseLocationSize = 0;
    }

    if (szRegistryBase != NULL && sizeof(DSA_CONFIG_ROOT) <= cbRegistryBase)
    {
        strcpy(szRegistryBase, DSA_CONFIG_ROOT);
    }

    ec = RegCreateKeyA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hkeyDs); 

    if (ec != hrNone)
    {
        return(ec);
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);

    ec = RegQueryValueExA(hkeyDs, JETSYSTEMPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            szDatabase = szDatabaseLocation;

            *szDatabaseLocation++ = BFT_CHECKPOINT_DIR;
            strcpy(szDatabaseLocation, rgchPathBuf);
            szDatabaseLocation += strlen(rgchPathBuf)+1;
        }
        
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);
    ec = RegQueryValueExA(hkeyDs, LOGPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            szDatabase = szDatabaseLocation+1;

            *szDatabaseLocation++ = BFT_LOG_DIR;
            strcpy(szDatabaseLocation, rgchPathBuf);
            szDatabaseLocation += strlen(szDatabaseLocation)+1;
        }
    }

    dwType = REG_SZ;
    cbBuffer = sizeof(rgchPathBuf);
    ec = RegQueryValueExA(hkeyDs, FILEPATH_KEY, 0, &dwType, (LPBYTE)rgchPathBuf, &cbBuffer);

    if (ec == hrNone)
    {
        if (pcbDatabaseLocationSize)
        {
            *pcbDatabaseLocationSize += strlen(rgchPathBuf)+2;
        }

        if (szDatabaseLocation)
        {
            if (szDatabaseLocation)
            {
                *szDatabaseLocation++ = BFT_NTDS_DATABASE;
                strcpy(szDatabaseLocation, rgchPathBuf);
                szDatabaseLocation += strlen(szDatabaseLocation)+1;
            }
        }
    }

    if (szDatabaseLocation)
    {
        *szDatabaseLocation = '\0';
    }

    if (pcbDatabaseLocationSize)
    {
        *pcbDatabaseLocationSize += 1;
    }

    // Circular logging is all we do nowadays.
    if (pfCircularLogging) {
        *pfCircularLogging = fTrue;
    }

    RegCloseKey(hkeyDs);
    
    return(hrNone);
}

HRESULT
HrLocalGetRegistryBase(
    OUT WSZ wszRegistryPath,
    OUT WSZ wszKeyName
    )
{
    CHAR rgbRegistryPath[ MAX_PATH ];
    HRESULT hr;

    hr = HrLocalQueryDatabaseLocations(NULL, NULL, rgbRegistryPath, sizeof(rgbRegistryPath), NULL);

    if (hr != hrNone)
    {
        return hr;
    }

    if (MultiByteToWideChar(CP_ACP, 0, rgbRegistryPath, -1, wszRegistryPath, MAX_PATH) == 0) {
        return(GetLastError());
    }
    
    if (wszKeyName)
    {
        wcscat(wszRegistryPath, wszKeyName);
    }

    return hrNone;
}

/*
 -  HrJetFileNameFromMungedFileName
 -
 *  Purpose:
 *
 *  This routine will convert the database names returned from JET into a form
 *  that the client can use.  This is primarily there for restore - the client
 *  will get the names in UNC format relative to the root of the server, so they
 *  can restore the files to that location.
 *  
 *  Please note that a munged file name might not be from the local machine.
 *
 *  Parameters:
 *
 *      cxh - the server side context handle for this operation.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  hrNone if successful, reasonable value if not.
 *
 */

HRESULT
HrJetFileNameFromMungedFileName(
    WSZ wszMungedName,
    SZ *pszJetFileName
    )
{
    CB cbJetName;
    SZ szJetFileName;
    WSZ wszJetNameStart;
    BOOL fUsedDefault;

    //
    //  Make sure this is a munged file name.
    //
    //  A munged file has the following format:
    //
    //  \\server\<drive>$\<path>
    //

    if (wszMungedName[0] != '\\' ||
        wszMungedName[1] != '\\' ||
        (wszJetNameStart = wcschr(&wszMungedName[2], '\\')) == 0 ||
        !iswalpha(*(wszJetNameStart+1)) ||
        *(wszJetNameStart+2) != L'$' ||
        *(wszJetNameStart+3) != L'\\')
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    //  Ok, we know the name is of the form:
    //
    //  \\server\<drive>$\<file>
    //
    //  And wszJetNameStart is:
    //
    //  \<drive>$\<file>
    //

    cbJetName = wcslen(wszJetNameStart);    // No need for +1 because of first "\"

    szJetFileName = MIDL_user_allocate(cbJetName);

    if (szJetFileName == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    szJetFileName[0] = (CHAR)*(wszJetNameStart+1);  // Drive letter.
    szJetFileName[1] = ':'; //  form <drive>:

    if (!WideCharToMultiByte(CP_ACP, 0, wszJetNameStart+3, -1,
                                          &szJetFileName[2],
                                          cbJetName-2,
                                          "?", &fUsedDefault))
    {
        MIDL_user_free(szJetFileName);
        return(GetLastError());
    }

    *pszJetFileName = szJetFileName;

    return(hrNone);
}

HRESULT
HrLocalCleanupOldLogs(
    WSZ wszCheckpointFilePath,
    WSZ wszLogPath, 
    ULONG genLow, 
    ULONG genHigh
    )
{
    HRESULT hr = hrNone;
    SZ szUnmungedLogPath = NULL;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA findData;
    // We use MAX_PATH+10 so we can have MAX_PATH of directory, plus 10 of filespec
    char szLogFileWildCard[MAX_PATH + 10];
    char szLogFileName[MAX_PATH + 10]; // logfile name with full path (e-x c:\winnt\ntds\edb0006A.log)
    char *pszFileName = NULL;         // final component of the logfilename (e-x:  edb0006A.log)   
    char szCheckpointFileName[MAX_PATH + 10]; // Checkpoint file name with full path
    DWORD dwErr, dwCheckpointFileLength;

    if ( (NULL == wszCheckpointFilePath) ||
         (NULL == wszLogPath) ||
         (genHigh < genLow) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    __try 
    {
        //
        // Delete old checkpoint files (edb.chk)
        //

        // Convert the UNC logpath to the regular drive based logpath 
        hr = HrJetFileNameFromMungedFileName(wszCheckpointFilePath, &szUnmungedLogPath);
        if (hrNone != hr)
        {
            __leave;
        }
        lstrcpynA(szCheckpointFileName, szUnmungedLogPath, MAX_PATH);
        MIDL_user_free(szUnmungedLogPath);
        szUnmungedLogPath = NULL;
        dwCheckpointFileLength = strlen( szCheckpointFileName );
        // Append a \ if not there already
        if ('\\' != szCheckpointFileName[dwCheckpointFileLength - 1]) {
            strcat(szCheckpointFileName, "\\");
            dwCheckpointFileLength++;
        }

        // Delete unneeded checkpoint files
        strcpy( szCheckpointFileName + dwCheckpointFileLength, "edb.chk" );
        // If the file is there...
        if (0xffffffff != GetFileAttributesA( szCheckpointFileName ) ) {
            if (!DeleteFileA(szCheckpointFileName))
            {
                // Unable to delete the old logfile; not cleaning up will cause problems later
                // return failure code
                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32( dwErr );
                __leave;
            }
        }

        //
        // Set up log paths
        //

        // Convert the UNC logpath to the regular drive based logpath 
        hr = HrJetFileNameFromMungedFileName(wszLogPath, &szUnmungedLogPath);
        if (hrNone != hr)
        {
            __leave;
        }

        // copy the the unmunged LogPath (it's of the form c:\winnt\ntlog or c:\winnt\ntlog\ )
        // make two copies of the logpath - one to pass a wildcard string for searching and
        // other to create filenames with full path for the logfiles found
        lstrcpynA(szLogFileWildCard, szUnmungedLogPath, MAX_PATH);
        lstrcpynA(szLogFileName, szUnmungedLogPath, MAX_PATH);

        // append the wildcard string to search for all *.log files from the logpath
        if ('\\' == szLogFileWildCard[strlen(szLogFileWildCard) - 1])
        {
            // given logpath has a backslash at the end
            strcat(szLogFileWildCard, "*.log");
        }
        else
        {
            // given logpath does not have a backslash at the end
            strcat(szLogFileWildCard, "\\*.log");
            strcat(szLogFileName, "\\");
        }

        //
        // Delete old log files (edbxxx.log, *.log)
        //

        // make pszFileName poing to the terminating null in szLogFileName
        pszFileName = &szLogFileName[strlen(szLogFileName)];

        hFind = FindFirstFileA(szLogFileWildCard, &findData);
        if (INVALID_HANDLE_VALUE == hFind)
        {
            // Nothing to cleanup - return success
            hr = hrNone;
            __leave;
        }

        do
        {
            BOOL fDelete = TRUE;
            // We are only in this loop if file is a log file

            // Save edbxxx.log where sequence is in range
            if (_strnicmp( findData.cFileName, "edb", 3 ) == 0) {
                // findData.cFileName points to the name of edb*.log file found
                ULONG ulLogNo = strtoul(findData.cFileName + 3, NULL, 16);

                fDelete = (ulLogNo < genLow) || (ulLogNo > genHigh);
            }
            if (fDelete) {
                // This is an old logfile which was not copied down by ntbackup - clean it up

                // first append the filename to the logpath (note:- pszFileName already pointing
                // to the byte at the end of the final backslash in logpath) and then delete the
                // file by passing in the filename with full path
                strcpy(pszFileName, findData.cFileName); 
                if (!DeleteFileA(szLogFileName))
                {
                    // Unable to delete the old logfile; not cleaning up will cause problems later
                    // return failure code
                    dwErr = GetLastError();
                    hr = HRESULT_FROM_WIN32( dwErr );
                    __leave;
                }
            }
        } while (FindNextFileA(hFind, &findData));
        
        if (ERROR_NO_MORE_FILES != (dwErr = GetLastError()))
        {
            // we came out of the loop for some unexpected error - return the error code
            hr = HRESULT_FROM_WIN32( dwErr );
            __leave;
        }

        // We are done cleaningup
        hr = hrNone;
        // fall out the end
    }
    __finally
    {
        if (szUnmungedLogPath)
        {
            MIDL_user_free(szUnmungedLogPath);
        }

        if (INVALID_HANDLE_VALUE != hFind)
        {
            FindClose(hFind);
        }
    }

    return hr;
}

HRESULT
HrLocalRestoreRegister(
    WSZ wszCheckpointFilePath,
    WSZ wszLogPath,
    EDB_RSTMAPW rgrstmap[],
    C crstmap,
    WSZ wszBackupLogPath,
    ULONG genLow,
    ULONG genHigh
    )
{
    WCHAR rgwcRegistryPath[ MAX_PATH ];
    HRESULT hr = hrNone;
    HKEY hkey = NULL;
    CB cbRstMap = 0;
    WSZ wszRstMap = NULL;
    WSZ wszRstEntry;
    I irgrstmap;

    __try
    {
        DWORD dwDisposition;
        DWORD dwType;
        DWORD cbGen;
        ULONG genCurrent;
        BOOLEAN fDatabaseRecovered = fFalse;
        BYTE rgbSD[200];
        BYTE rgbACL[200];
        PACL pACL = (PACL)rgbACL;
        PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) rgbSD;
        PSID psidUser;
        SECURITY_ATTRIBUTES sa;
        SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
        PSID psidAdmin;
        PSID psidEveryone;

        hr = HrLocalGetRegistryBase(rgwcRegistryPath, RESTORE_IN_PROGRESS);

        if (hr != hrNone)
        {
            __leave;
        }

        //
        //  Construct the default security descriptor allowing access to all
        //  this is used to allow authenticated connections over LPC.
        //  By default LPC allows access only to the same account
        //

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            DebugTrace(("Error %d constructing a security descriptor\n", GetLastError()));
            pSD = NULL;
        }

        if (pSD && !InitializeAcl(pACL, sizeof(rgbACL), ACL_REVISION))
        {
            DebugTrace(("Error %d constructing an ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        GetCurrentSid(&psidUser);

        if (pSD && pACL && psidUser && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_ALL_ACCESS, psidUser))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidUser != NULL)
        {
            MIDL_user_free(psidUser);
        }

        if (!AllocateAndInitializeSid(&siaNt, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdmin)) {
            DebugTrace(("Error %d Allocating SID for admin.\n", GetLastError()));
        }

        if (pSD && pACL && psidAdmin && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidAdmin)
        {
            FreeSid(psidAdmin);
            psidAdmin = NULL;
        }

        if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID,0, 0, 0, 0, 0, 0, 0, &psidEveryone)) {
            DebugTrace(("Error %d Allocating SID for world.\n", GetLastError()));
        }

        if (pSD && pACL && psidEveryone && !AddAccessAllowedAce(pACL, ACL_REVISION, KEY_READ, psidEveryone))
        {
            DebugTrace(("Error %d adding an ACE to the ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (psidEveryone)
        {
            FreeSid(psidEveryone);
            psidEveryone = NULL;
        }
        if (pSD && pACL && !SetSecurityDescriptorDacl(pSD,  TRUE, pACL, FALSE))
        {
            DebugTrace(("Error %d setting a security descriptor ACL\n", GetLastError()));
            pSD = NULL;
            pACL = NULL;
        }

        if (pSD && pACL)
        {
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = fFalse;
            sa.nLength = sizeof(sa);
        }

        if (hr = RegCreateKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryPath, 0, 0, 0, KEY_WRITE | KEY_READ, &sa, &hkey, &dwDisposition))
        {
            __leave;
        }

        
        //
        //  Seed the restore-in-progress in the registry.
        //

        hr = hrRestoreInProgress;

        if (hr = RegSetValueExW(hkey, RESTORE_STATUS, 0, REG_DWORD, (LPBYTE)&hr, sizeof(DWORD)))
        {
            __leave;
        }


        //
        //  We've now interlocked other restore operations from coming in from other machines.
        //

        if (wszBackupLogPath)
        {
            hr = RegSetValueExW(hkey, BACKUP_LOG_PATH, 0, REG_SZ, (LPBYTE)wszBackupLogPath, (wcslen(wszBackupLogPath)+1)*sizeof(WCHAR));
    
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (wszCheckpointFilePath)
        {
            hr = RegSetValueExW(hkey, CHECKPOINT_FILE_PATH, 0, REG_SZ, (LPBYTE)wszCheckpointFilePath, (wcslen(wszCheckpointFilePath)+1)*sizeof(WCHAR));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (wszLogPath)
        {
            hr = RegSetValueExW(hkey, LOG_PATH, 0, REG_SZ, (LPBYTE)wszLogPath, (wcslen(wszLogPath)+1)*sizeof(WCHAR));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        //
        //  Reset the "database recovered" bit.
        //
        hr = RegSetValueExW(hkey, JET_DATABASE_RECOVERED, 0, REG_BINARY, (LPBYTE)&fDatabaseRecovered, sizeof(BOOLEAN));
        if (hr != hrNone)
        {
            __leave;
        }


        dwType = REG_DWORD;
        cbGen = sizeof(DWORD);

        hr = RegQueryValueExW(hkey, LOW_LOG_NUMBER, 0, &dwType, (LPBYTE)&genCurrent, &cbGen);

        if (crstmap != 0 || hr != hrNone || genLow < genCurrent)
        {
            hr = RegSetValueExW(hkey, LOW_LOG_NUMBER, 0, REG_DWORD, (LPBYTE)&genLow, sizeof(DWORD));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        hr = RegQueryValueExW(hkey, HIGH_LOG_NUMBER, 0, &dwType, (LPBYTE)&genCurrent, &cbGen);

        if (crstmap != 0 || hr != hrNone || genHigh > genCurrent)
        {
            hr = RegSetValueExW(hkey, HIGH_LOG_NUMBER, 0, REG_DWORD, (LPBYTE)&genHigh, sizeof(DWORD));
        }

        if (hr != hrNone)
        {
            __leave;
        }

        if (crstmap)
        {

//
//          //
//          //  If there's already a restore map size (or restore map), then you can't set
//          //  another restore map.  The restore map should only be set on a full backup.
//          //
//
//          if ((hr = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&genCurrent, &cbGen)) != ERROR_FILE_NOT_FOUND)
//          {
//              return hrRestoreMapExists;
//          }
//

            //
            //  Save away the size of the restore map.
            //

            hr = RegSetValueExW(hkey, JET_RSTMAP_SIZE, 0, REG_DWORD, (LPBYTE)&crstmap, sizeof(DWORD));
    
            //
            //  We now need to convert the restore map into one that we can put into the
            //  registry.
            //
    
            //
            //  First figure out how big this thing is going to be.
            //
            for (irgrstmap = 0 ; irgrstmap < crstmap ; irgrstmap += 1)
            {
                cbRstMap += wcslen(rgrstmap[irgrstmap].wszDatabaseName)+wcslen(rgrstmap[irgrstmap].wszNewDatabaseName)+2;
            }
    
            cbRstMap *= sizeof(WCHAR);
    
            wszRstMap = MIDL_user_allocate(cbRstMap+sizeof(WCHAR));
    
            if (wszRstMap == NULL)
            {
                hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_SERVER_MEMORY );
                __leave;
            }
    
            wszRstEntry = wszRstMap;
    
            for (irgrstmap = 0 ; irgrstmap < crstmap ; irgrstmap += 1)
            {
                wcscpy(wszRstEntry, rgrstmap[irgrstmap].wszDatabaseName);
                wszRstEntry += wcslen(wszRstEntry)+1;
    
                wcscpy(wszRstEntry, rgrstmap[irgrstmap].wszNewDatabaseName);;
                wszRstEntry += wcslen(wszRstEntry)+1;
            }
    
            *wszRstEntry++ = L'\0';
    
            hr = RegSetValueExW(hkey, JET_RSTMAP_NAME, 0, REG_MULTI_SZ, (LPBYTE)wszRstMap, (DWORD)(wszRstEntry-wszRstMap)*sizeof(WCHAR));
        }
        else
        {
            if ((hr = RegQueryValueExW(hkey, JET_RSTMAP_SIZE, 0, &dwType, (LPBYTE)&genCurrent, &cbGen)) != NO_ERROR)
            {
                hr = hrNoFullRestore;
            }
        }

        //
        // Create the new Database Invocation ID.This will be used by both
        // authoritative restore and boot recovery. This would cause AR to
        // fail.
        //

        {
            GUID tmpGuid;

            hr = CreateNewInvocationId(TRUE,        // save GUID in Database
                                       &tmpGuid);

            //
            // Log and fail if we can't create. 
            //

            if ( hr != S_OK ) {

                LogNtdsErrorEvent(DIRLOG_FAILED_TO_CREATE_INVOCATION_ID,
                                  hr);
            }
        }

        if (hrNone == hr)
        {
            // We have successfully registered the restore, now cleanup the any pre-existing logfiles
            // in the logdir to avoid JetExternalRestore() from using logfiles that are not specified
            // by the lowlog and highlog numbers.

            hr = HrLocalCleanupOldLogs(
                wszCheckpointFilePath,
                wszLogPath,
                genLow, genHigh);
        }

    }
    __finally
    {
        if (wszRstMap != NULL)
        {
            MIDL_user_free(wszRstMap);
        }

        if (hkey != NULL)
        {
            RegCloseKey(hkey);
        }
    }


    return hr;
}

HRESULT
HrLocalRestoreRegisterComplete(
    HRESULT hrRestore )
{
    WCHAR rgwcRegistryPath[ MAX_PATH ];
    HRESULT hr = hrNone;
    HKEY hkey;
    
        hr = HrLocalGetRegistryBase(rgwcRegistryPath, RESTORE_IN_PROGRESS);
    
        if (hr != hrNone)
        {
            return hr;
        }

        if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryPath, 0, KEY_WRITE | DELETE, &hkey))
        {
            //
            //  We want to ignore file_not_found - it is ok.
            //
            if (hr == ERROR_FILE_NOT_FOUND)
            {
                return(ERROR_SUCCESS);
            }
    
            return(hr);
        }
    
        //
        //  If the restore status is not success, then set the status to the error.
        //  If the restore status is success, then clear the "restore-in-progress"
        //  indicator.
        //
        if (hrRestore != hrNone)
        {
            hr = RegSetValueExW(hkey, RESTORE_STATUS, 0, REG_DWORD, (BYTE *)&hrRestore, sizeof(HRESULT));
        }
        else
        {
            hr = RegDeleteValueW(hkey, RESTORE_STATUS);
        }
    
        RegCloseKey(hkey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\mxsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mxsutil.h
//
//--------------------------------------------------------------------------

/*
 *      General include file
 */

#ifndef MXSUTIL_INCLUDED
#define	MXSUTIL_INCLUDED	1

#include "util.h"

#ifdef DOS16
#define __export
#define _export
#define export
#endif

//#ifndef NONMAPI
//#include "mapiwin.h"
//#endif
#endif // MXSUTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\idl\imports.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       imports.h
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <winbase.h>
#include <lmcons.h>
#define	_INC_WINDOWS
#include <winsock.h>
#include <ntdsbcli.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif

#include <options.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       util.h
//
//--------------------------------------------------------------------------

/*
 *	Declarations for utilities common to store and msp.
 */

#ifndef UTIL_INCLUDED
#define UTIL_INCLUDED

#include "assert.h"
#include "malloc.h"
#include "memory.h"
#include "string.h"
#include "stdio.h"

//#define	FARSTRUCT

#ifdef __cplusplus
extern "C"
{
#endif

#include "windows.h"

#ifdef __cplusplus
}
#endif

#include "debug.h"

/* Count, index types */
#define	UINT_MAX	(UINT)0x7FFFFFFF
typedef LONG	C;
typedef LONG	I;

/* Other Hungarian */
typedef char *	SZ;
typedef WCHAR *	WSZ;
typedef long	EC;
typedef void *	PV;
typedef C		CB;
typedef I		IB;
typedef BYTE *	PB;
typedef C		CCH;
typedef	char *	PCH;

/* Standard Boolean values */
#define	fFalse	((BOOL)0)
#define fTrue	((BOOL)1)

#endif // UTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\idl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

#
# This is the MIDL compile phase of the build process.
#

!INCLUDE $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

UNICODE=1

SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)

INCS  = -I$(SDKINC) -I$(SDKCRTINC) -I..\..\inc -I..\..\xinc -I..

EXTRN_DEPENDS = $(SDKINC)\winbase.h \
                $(SDKINC)\windef.h

NET_C_DEFINES= -DINCL_32= -DNT -DRPC_NO_WINDOWS_H
CPP = -cpp_cmd "$(MIDL_CPP)" -cpp_opt "-nologo -E $(MIDL_FLAGS) $(INCS) $(C_DEFINES) $(NET_C_DEFINES)"


$(O)\jetbak.h : jetbak.idl jetbak.acf imports.h imports.idl ..\options.h $(EXTRN_DEPENDS)
    midl -Oicf -robust -oldnames -error ref -ms_ext -c_ext $(CPP) -out .\$(O) $(INCS) .\jetbak.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetback\snapshot.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    snapshot.cxx

Abstract:

    Support for Jet Snapshot Backup

    The code instantiates a COM object which performs snapshot writer functions.
    We override some of the methods of the interface in order to receive notification
    when important events occur.  The events are:

    o PrepareBackupBegin
    o PrepareBackupEnd
    o BackupCompleteEnd
    o RestoreBegin
    o RestoreEnd

    It is not necessary to call any Jet functions after the restore.

    The snapshot writer operates under the same model as the file-based backup facility.
    The backup occurs online with the NTDS, and the restore occurs when the NTDS is
    offline.  We enforce this and will reject the snapshot operation if the NTDS is not
    in the proper mode. The snapshot facility supports online restore, but we continue
    to require an offline restore, because currently we have no mechanism to synchronize
    the directory with an instantaneous change in the database.

    We continue to enforce the concept of backup expiration. If a backup is older than a
    tombstone lifetime, we refuse to restore it.

    The way we communicate information about the backup to the restoration is through the
    use of "backup metadata". This is a string that we provide at backup-time that is
    given back to us at restore time. We impose a simple keyword=value structure on this
    string. This is how we communicate the backup expiration.  This mechanism can be
    extended in the future to pass whatever we want.

    After the restore is done, we update the registry to inform the directory that a
    restore has taken place. Two actions are done (see OnRestoreEnd):

    1. We create a new invocation id to represent the new database identity
    2. We set the key in the registry to indicate we are restored.

    Note that we do not set the "restore in progress" key that is used by the
    RecoverAfterRestore facility, because that is only required for a file-based
    restore.

Author:

    Will Lees (wlees) 22-Dec-2000

Environment:

Notes:

Revision History:

--*/

#include <NTDSpchx.h>
#pragma  hdrstop

#include "snapshot.hxx"

extern "C" {

// Core DSA headers.
#include <ntdsa.h>
#include "dsexcept.h"

#include <windows.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <ntdsbsrv.h>
#include <ntdsbmsg.h>
#include <dsconfig.h>
#include <taskq.h>
#include <dsutil.h> // SZDSTIME_LEN
#include "local.h"

#define DEBSUB "SNAPSHOT:"       // define the subsystem for debugging
#include "debug.h"              // standard debugging header
#include <fileno.h>
#define  FILENO FILENO_SNAPSHOT
#include "dsevent.h"
#include "mdcodes.h"            // header for error codes

BOOLEAN
DsaWaitUntilServiceIsRunning(
    CHAR *ServiceName
    );

} // extern "C"

#include <vss.h>
#include <vswriter.h>
#include <jetwriter.h>
#include <esent.h>

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#define EXPIRATION_TIME_KEYWORD L"ExpirationTime"
#define EXPIRATION_TIME_LENGTH (ARRAY_SIZE(EXPIRATION_TIME_KEYWORD) - 1)

#define LOG_UNHANDLED_BACKUP_ERROR( error ) logUnhandledBackupError( error, DSID( FILENO, __LINE__ ))

#define EVENT_SERVICE "EventSystem"

/* External */

extern "C" {
    extern BOOL g_fBootedOffNTDS;
} // extern "C"

/* Static */

HANDLE  hSnapshotJetWriterThread = NULL;
HANDLE hServDoneEvent = NULL;
unsigned int tidSnapshotJetWriterThread = 0;

static UUID guuidWriter = { /* b2014c9e-8711-4c5c-a5a9-3cf384484757 */
    0xb2014c9e,
    0x8711,
    0x4c5c,
    {0xa5, 0xa9, 0x3c, 0xf3, 0x84, 0x48, 0x47, 0x57}
  };

/* Forward */

DWORD
DsSnapshotJetWriter(
    VOID
    );

/* End Forward */




// Override writer class with custom restore function

class CVssJetWriterLocal : public CVssJetWriter
    {
public:

	virtual bool STDMETHODCALLTYPE OnPrepareBackupBegin(IN IVssWriterComponents *pWriterComponents);
	virtual bool STDMETHODCALLTYPE OnPrepareBackupEnd(IN IVssWriterComponents *pWriterComponents,
							  IN bool fJetPrepareSucceeded);

	virtual bool STDMETHODCALLTYPE OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							   IN bool fJetBackupCompleteSucceeded);
	virtual bool STDMETHODCALLTYPE OnPreRestoreBegin(IVssWriterComponents *pComponents);
	virtual bool STDMETHODCALLTYPE OnPreRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
};


VOID
logUnhandledBackupError(
    DWORD dwError,
    DWORD dsid
    )

/*++

Routine Description:

    Log an error for an unexpected condition.

Arguments:

    dwError - Error code
    dsid - position of caller

Return Value:

    None

--*/

{
    DPRINT3(0,"Unhandled BACKUP error %d (0x%X) with DSID %X\n",
            dwError, dwError, dsid);

    LogEvent8WithData(DS_EVENT_CAT_BACKUP,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_BACKUP_UNEXPECTED_WIN32_ERROR,
                      szInsertWin32Msg(dwError),
                      szInsertHex(dsid),
                      NULL, NULL, NULL, NULL, NULL, NULL,
                      sizeof(dwError),
                      &dwError);
} /* logUnhandledBackupError */


unsigned int
__stdcall
writerThread(
    PVOID StartupParam
    )

/*++

Routine Description:

    The dedicated thread in which the snapshot writer runs

Arguments:

    StartupParam - UNUSED

Return Value:

    unsigned int - thread exit status

--*/

{
    DWORD dwError = 0;

    __try
    {
        if (!DsaWaitUntilServiceIsRunning(EVENT_SERVICE))
        {
            dwError = GetLastError();
            DPRINT1( 0, "Failed to wait for event service, error %d\n", dwError );
            LOG_UNHANDLED_BACKUP_ERROR( dwError );
            __leave;
        }

        // This call will not return until shutdown
        dwError = DsSnapshotJetWriter();
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwError = GetExceptionCode();
        DPRINT1( 0, "Caught exception in writerThread 0x%x\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
    }

    return dwError;
} /* writerThread */


DWORD
DsSnapshotRegister(
    VOID
    )

/*++

Routine Description:

    Call to initialize the DS Jet Snapshot Writer.

    Called when the backup server dll is initialized.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError;

    DPRINT(1, "DsSnapshotRegister()\n" );

    // Create the server done event
    hServDoneEvent = CreateEvent( NULL, // default sd
                                  FALSE, // auto reset
                                  FALSE, // initial state, not set
                                  NULL // name, none
                                  );
    if (hServDoneEvent == NULL) {
        dwError = GetLastError();
        DPRINT1( 0, "CreateEvent failed with error %d\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        goto cleanup;
    }

    // Start snapshot thread
    hSnapshotJetWriterThread = (HANDLE)
        _beginthreadex(NULL,
                       0,
                       writerThread,
                       NULL,
                       0,
                       &tidSnapshotJetWriterThread);
    if (0 == hSnapshotJetWriterThread) {
        DPRINT1( 0, "Failed to create Snapshot Jet Writer thread, errno = %d\n", errno );
        LOG_UNHANDLED_BACKUP_ERROR( errno );
        goto cleanup;
    }

    dwError = ERROR_SUCCESS;

 cleanup:

    // Cleanup on error
    if (dwError) {
        if (hServDoneEvent != NULL) {
            CloseHandle( hServDoneEvent );
            hServDoneEvent = NULL;
        }
        if (hSnapshotJetWriterThread != NULL) {
            CloseHandle( hSnapshotJetWriterThread );
            hSnapshotJetWriterThread = NULL;
        }
    }

    return dwError;
} /* DsSnapshotRegister */


DWORD
DsSnapshotShutdownTrigger(
    VOID
    )

/*++

Routine Description:

    Initiate the termination of the DS Jet Snapshot Writer

    Called when the backup server dll is terminated.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError;

    DPRINT(1, "DsSnapshotShutdownTrigger()\n" );

    // Check parameters
    if ( (hServDoneEvent == NULL) ||
         (hSnapshotJetWriterThread == NULL) ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Set server done event
    if (!SetEvent( hServDoneEvent )) {
        dwError = GetLastError();
        DPRINT1( 0, "SetEvent failed with error %d\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        return dwError;
    }

    return ERROR_SUCCESS;
}


DWORD
DsSnapshotShutdownWait(
    VOID
    )

/*++

Routine Description:

    Wait for the DS Jet Snapshot Writer to exit

    Called when the backup server dll is terminated.

Arguments:

    VOID - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwError, waitStatus;

    DPRINT(1, "DsSnapshotShutdownWait()\n" );

    // Check parameters
    if ( (hServDoneEvent == NULL) ||
         (hSnapshotJetWriterThread == NULL) ) {
        dwError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // Server done event should have already been set
    // If not, no big deal, we will timeout after a small delay

    // Wait a fixed length of time for thread to exit
    waitStatus = WaitForSingleObject(hSnapshotJetWriterThread,5*1000);
    if (waitStatus == WAIT_TIMEOUT) {
        DPRINT1( 0, "Snapshot Jet writer thread 0x%x did not exit promptly, timeout.\n",
                 hSnapshotJetWriterThread );
        dwError = ERROR_TIMEOUT;
        goto cleanup;
    } else if (waitStatus != WAIT_OBJECT_0 ) {
        dwError = GetLastError();
        DPRINT2(0, "Failure waiting for writer thread to exit, wait status=%d, error=%d\n",
                waitStatus, dwError);
        goto cleanup;
    }

    dwError = ERROR_BAD_THREADID_ADDR;
    GetExitCodeThread( hSnapshotJetWriterThread, &dwError );

    if (dwError == STILL_ACTIVE) {
        DPRINT( 0, "Snapshot Jet Writer thread did not exit\n" );
    } else if (dwError != ERROR_SUCCESS) {
        DPRINT1( 0, "Snapshot Jet Writer thread exited with non success code %d\n",
                 dwError );
    }

 cleanup:
    if (hServDoneEvent != NULL) {
        CloseHandle( hServDoneEvent );
        hServDoneEvent = NULL;
    }
    if (hSnapshotJetWriterThread != NULL) {
        CloseHandle( hSnapshotJetWriterThread );
        hSnapshotJetWriterThread = NULL;
    }
    return dwError;
} /* DsSnapshotShutdownWait */


DWORD
DsSnapshotJetWriter(
    VOID
    )

/*++

Routine Description:

    This function embodies the C++ environment of the DS JET WRITER thread.
    It constructs a writer instance, initializes COM, initializes the writer,
    hangs around until shutdown, then cleans up.
    This call does not return until the DSA is shutdown.

    Even though control returns from the writer->Initialize call, the thread
    must be kept available for the life of the writer. This is because the thread
    that called CoInitialize must be available in order for the writer to function.

Arguments:

    None.

Return Value:

    DWORD - Win32 error status

--*/

{
    DWORD dwRet = ERROR_SUCCESS;
    HRESULT hrStatus;
    BOOL fComInit = FALSE, fWriterInit = FALSE;
    CVssJetWriterLocal writer;

    DPRINT( 1, "DsSnapshotJetWriter enter\n" );

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);
    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CoInitializeEx failed with HRESULT 0x%x\n", hrStatus );
        LOG_UNHANDLED_BACKUP_ERROR( hrStatus );
        dwRet = ERROR_DLL_INIT_FAILED;
        goto cleanup;
    }
    fComInit = TRUE;

    hrStatus = CoInitializeSecurity (
        NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
        -1,                                  //  IN LONG                         cAuthSvc,
        NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
        NULL,                                //  IN void                        *pReserved1,
        RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
        RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
        NULL,                                //  IN void                        *pAuthList,
        EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
        NULL                                 //  IN void                        *pReserved3
        );
    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CoInitializeEx failed with HRESULT 0x%x\n", hrStatus );
        LOG_UNHANDLED_BACKUP_ERROR( hrStatus );
        dwRet = ERROR_NO_SECURITY_ON_OBJECT;
        goto cleanup;
    }

    hrStatus = writer.Initialize(guuidWriter,		// id of writer
                                 L"NTDS",	// name of writer
                                 TRUE,		// system service
                                 TRUE,		// bootable state
                                 NULL,	// files to include
                                 NULL);	// files to exclude
    if (FAILED (hrStatus)) {
        DPRINT1( 0, "CVssJetWriter Initialize failed with HRESULT 0x%x\n", hrStatus );
        LogEvent8WithData(DS_EVENT_CAT_BACKUP,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_BACKUP_JET_WRITER_INIT_FAILURE,
                          szInsertWin32Msg(hrStatus),
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                          sizeof(hrStatus),
                          &hrStatus);
        dwRet = ERROR_FULL_BACKUP;
        goto cleanup;
    }
    fWriterInit = TRUE;

    DPRINT( 1, "cVssJetWriter successfully initialized.\n" );

    // Wait for shutdown
    WaitForSingleObject(hServDoneEvent, INFINITE);

 cleanup:
    
    if (fWriterInit) {
        writer.Uninitialize();
    }

    if (fComInit) {
        CoUninitialize();
    }

    DPRINT1( 1, "DsSnapshotJetWriter exit, dwRet = 0x%x\n", dwRet );

    return dwRet;
} /* DsSnapshotJetWriter */


bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareBackupBegin(
    IN IVssWriterComponents *pWriterComponents
    )

/*++

Routine Description:

    Method called at the start of the backup preparation phase

Arguments:

    pWriterComponents - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    DPRINT1( 1, "OnPrepareBackupBegin(%p)\n", pWriterComponents );

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        return true;
    }

    // If not running as NTDS, do not allow backup
    if (!g_fBootedOffNTDS){
        // Not online, no backup
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_NO_NTDS_NO_BACKUP,
                 NULL, NULL, NULL );
        return false;
    }

    return true;
} /* CVssJetWriterLocal::OnPrepareBackupBegin */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPrepareBackupEnd(
    IN IVssWriterComponents *pWriterComponents,
    IN bool fJetPrepareSucceeded
    )

/*++

Routine Description:

    Method called at the end of the backup preparation phase
    We use this opportunity to calculate the backup metadata, which is any
    string data we want to associate with the backup. We store the backup
    expiration time presently.

    The backup metadata takes this form:

    keyword=value[;keyword=value]...

    Note that the parser is simple and does not tolerate whitespace before or after
    the equal or semicolon.

Arguments:

    pWriterComponents - Component being backed up

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    HRESULT hr;
    UINT cComponents;
    IVssComponent *pComponent = NULL;
    bool fSuccess;
    WCHAR wszBuffer[128];
    DSTIME dstime;
    DWORD days;

    // If the prepare phase did not succeed, don't do anything
    if (!fJetPrepareSucceeded) {
        DPRINT(0,"DS Snapshot backup prepare failed.");
        return true;
    } 

    DPRINT2(1, "OnPrepareBackupEnd(%p,%d)\n",
            pWriterComponents,fJetPrepareSucceeded);

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        return false;
    }

    // Calculate expiration time of backup
    dstime = GetSecondsSince1601();

    days = getTombstoneLifetimeInDays();

    dstime += (days * 24 * 60 * 60);

    swprintf( wszBuffer, L"%ws=%I64d", EXPIRATION_TIME_KEYWORD, dstime );

    // Get the 1 database component

    __try {
        hr = pWriterComponents->GetComponentCount( &cComponents );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        if (cComponents == 0) {
            // WORKAROUND - TOLERATE BACKUP WITHOUT A COMPONENT
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
            DPRINT( 0, "Warning: AD snapshot backup expiration not recorded.\n" );
            // KEEP GOING
            fSuccess = true;
            __leave;
        }

        hr = pWriterComponents->GetComponent( 0, &pComponent );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        // Set the backup metadata for the component

        hr = pComponent->SetBackupMetadata( wszBuffer );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        DPRINT1( 1, "Wrote backup metadata: %ws\n", wszBuffer );

        fSuccess = true;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        DWORD dwError = GetExceptionCode();
        DPRINT1( 0, "Caught exception in OnPrepareBackupEnd 0x%x\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        fSuccess = false;
    }

    if (pComponent) {
        pComponent->Release();
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPrepareBackupEnd */


bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnBackupCompleteEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Method called when the backup completes, successfully or not

Arguments:

    pWriter - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    DWORD dwEvent;

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        // keep going
    }

    if (!bRestoreSucceeded) {
        DPRINT(0,"DS Snapshot Backup failed.\n");
        dwEvent = DIRLOG_BACKUP_SNAPSHOT_FAILURE;
    } else {
        DPRINT(0,"DS Snapshot Backup succeeded.\n");
        dwEvent = DIRLOG_BACKUP_SNAPSHOT_SUCCESS;
    }
    LogEvent(DS_EVENT_CAT_BACKUP,
             DS_EVENT_SEV_ALWAYS,
             dwEvent,
             NULL, NULL, NULL );

    return true;
} /* CVssJetWriterLocal::OnBackupCompleteEnd */


BOOL
processBackupMetadata(
    BSTR bstrBackupMetadata
    )

/*++

Routine Description:

    Apply the backup metadata, if any

Arguments:

    bstrBackupMetadata - 

Return Value:

    BOOL - Whether we should allow the restore to continue

--*/

{
    LONGLONG dstimeCurrent, dstimeExpiration;
    LPWSTR pszOptions, pszEqual;

    if (bstrBackupMetadata == NULL) {
        DPRINT( 0, "No backup metadata found.\n" );
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_FILE_NOT_FOUND );
        // TEMPORARY WORKAROUND
        // Tolerate lack of metadata
        return true;
    }

    DPRINT1( 0, "Read backup metadata: %ws\n", bstrBackupMetadata );

    // Parse the metadata
    // Note that for backward compatibility with older backups, we must continue to support
    // keywords from older versions, or atleast ignore them. Similarly, to provide some
    // tolerance for future versions, we ignore keywords we do not recognize without
    // generating an error.

    dstimeCurrent = GetSecondsSince1601();

    pszOptions = bstrBackupMetadata;
    dstimeExpiration = 0;
    while (1) {
        pszEqual = wcschr( pszOptions, L'=' );
        if (!pszEqual) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
            break;
        }
        if ( (((DWORD) (pszEqual - pszOptions)) == EXPIRATION_TIME_LENGTH) &&
             (wcsncmp( pszOptions, EXPIRATION_TIME_KEYWORD, EXPIRATION_TIME_LENGTH ) == 0) ) {
            if (swscanf( pszEqual + 1, L"%I64d", &dstimeExpiration ) == 1) {

                // Validate expiration here
                if (dstimeExpiration < dstimeCurrent) {
                    CHAR buf1[SZDSTIME_LEN + 1];
                    DPRINT( 0, "Can't restore AD snapshot because it is expired\n" );
                    LogEvent(DS_EVENT_CAT_BACKUP,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_BACKUP_SNAPSHOT_TOO_OLD,
                             szInsertDSTIME( dstimeExpiration, buf1 ),
                             NULL, NULL );
                    return false;
                }
            }
        }
        pszOptions = wcschr( pszOptions, L';' );
        if (!pszOptions) {
            break;
        }
        pszOptions++;
    }

    return true;
} /* processBackupMetadata */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPreRestoreBegin(
    IVssWriterComponents *pWriterComponents
    )

/*++

Routine Description:

    Method called before the restore begins, at the start of the "pre-restore" phase.
    We take this opportunity to read the backup metadata.
    We validate that the backup is still good.

Arguments:

    pComponents - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    HRESULT hr;
    UINT cComponents;
    IVssComponent *pComponent = NULL;
    bool fSuccess;
    BSTR bstrBackupMetadata = NULL;

    DPRINT1(0, "OnPreRestoreBegin(%p)\n", pWriterComponents );

    __try {
        // Check for invalid arguments
        if (!pWriterComponents) {
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
            fSuccess = false;
            __leave;
        }

        // If running as NTDS, do not allow restore
        if (g_fBootedOffNTDS){
            // Not offline, no restore
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                     NULL, NULL, NULL );
            fSuccess = false;
            __leave;
        }

        // Get the 1 database component

        hr = pWriterComponents->GetComponentCount( &cComponents );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        if (cComponents == 0) {
            // WORKAROUND - TOLERATE BACKUP WITHOUT A COMPONENT
            LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
            DPRINT( 0, "Warning: AD snapshot backup expiration not checked.\n" );
            // KEEP GOING
            fSuccess = true;
            __leave;
        }

        hr = pWriterComponents->GetComponent( 0, &pComponent );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        // Read the metadata

        hr = pComponent->GetBackupMetadata( &bstrBackupMetadata );
        if (!SUCCEEDED(hr)) {
            LOG_UNHANDLED_BACKUP_ERROR( hr );
            fSuccess = false;
            __leave;
        }

        if (!processBackupMetadata( bstrBackupMetadata )) {
            // Error already logged
            fSuccess = false;
            __leave;
        }

        fSuccess = true;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        DWORD dwError = GetExceptionCode();
        DPRINT1( 0, "Caught exception in OnRestoreBegin 0x%x\n", dwError );
        LOG_UNHANDLED_BACKUP_ERROR( dwError );
        fSuccess = false;
    }

    // Cleanup processing for function
    // Control should always exit through this path

    if (bstrBackupMetadata) {
        SysFreeString( bstrBackupMetadata );
    }

    if (pComponent) {
        pComponent->Release();
    }

    return fSuccess;
} /* CVssJetWriterLocal::OnPreRestoreBegin */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPreRestoreEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Called at the end of pre-restore phase. The data on disk has not been changed yet.

    We set the following registry key to indicate a restore is in progress.

    DSA_CONFIG_SECTION \ RESTORE_STATUS - Restore is in progress key

    We rely on the fact that RecoverAfterRestore will check for this key and abort if it
    is present. Note that although snapshot restore does not require RecoverAfterRestore
    functionality for restore reasons, we do depend on it being called in order to
    check the restore status key.

Arguments:

    pWriterComponents - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    bool fSuccess = true;
    HRESULT hr;
    DWORD dwWin32Status;
    HKEY hkeyDs;

    DPRINT2(0, "OnPreRestoreEnd(%p,%d)\n", pWriterComponents, bRestoreSucceeded);

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        // keep going
    }

    // Pre-restore failed, we are done
    if (!bRestoreSucceeded) {
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_SNAPSHOT_PRERESTORE_FAILURE,
                 NULL, NULL, NULL );
        return true;
    }

    // If running as NTDS, do not allow restore
    if (g_fBootedOffNTDS){
        // Not offline, no restore
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                 NULL, NULL, NULL );
        return false;
    }

    // Indicate a restore is in progress
    // See similar logic in HrLocalRestoreRegister

    dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
    if (dwWin32Status != ERROR_SUCCESS) {
        LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
    } else {
        hr = hrRestoreInProgress;

        dwWin32Status = RegSetValueExW(hkeyDs, RESTORE_STATUS, 0, REG_DWORD, (LPBYTE)&hr, sizeof(HRESULT));
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        }

        RegCloseKey(hkeyDs);
    }

    return (dwWin32Status == ERROR_SUCCESS) ? true : false;
} /* CVssJetWriterLocal::OnPreRestoreEnd */

bool
STDMETHODCALLTYPE
CVssJetWriterLocal::OnPostRestoreEnd(
    IVssWriterComponents *pWriterComponents,
    bool bRestoreSucceeded
)

/*++

Routine Description:

    Called at the end of post-restore phase. The data on disk has been changed.
    This routine may not be called on some error scenarios.

    On success, set up the registry keys that let the DS know that we have been
    restored.

    They are:

    DSA_CONFIG_SECTION \ DSA_RESTORED_DB_KEY - if present, we were restored
    DSA_CONFIG_SECTION \ RESTORE_NEW_DB_GUID - new invocation id to use

Arguments:

    pWriterComponents - 
    bRestoreSucceeded - 

Return Value:

    STDMETHODCALLTYPE - 

--*/

{
    bool fSuccess = true;
    DWORD dwWin32Status;
    HRESULT hr;
    GUID tmpGuid;
    HKEY hkeyDs;

    DPRINT2(0, "OnPostRestoreEnd(%p,%d)\n", pWriterComponents,bRestoreSucceeded);

    // Check for invalid arguments
    if (!pWriterComponents) {
        LOG_UNHANDLED_BACKUP_ERROR( ERROR_INVALID_PARAMETER );
        // keep going
    }

    // If running as NTDS, do not allow restore
    if (g_fBootedOffNTDS){
        // Not offline, no restore
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_YES_NTDS_NO_RESTORE,
                 NULL, NULL, NULL );
        return false;
    }

    //
    // Handle restore failure
    //

    if (!bRestoreSucceeded) {
        DPRINT(0,"DS Snapshot Restore failed.\n");

        dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        } else {

            // Make sure restored key is not present
            dwWin32Status = RegDeleteValue(hkeyDs, DSA_RESTORED_DB_KEY);
            // May fail if key not present

            // Update restore status with error indication
            hr = hrError;
            dwWin32Status = RegSetValueExW(hkeyDs, RESTORE_STATUS, 0, REG_DWORD, (BYTE *)&hr, sizeof(HRESULT));

            RegCloseKey(hkeyDs);
        }

        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_SNAPSHOT_RESTORE_FAILURE,
                 NULL, NULL, NULL );

        return true;
    }

    //
    // Handle restore success
    //

    dwWin32Status = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, 0, KEY_SET_VALUE, &hkeyDs);
    if (dwWin32Status != ERROR_SUCCESS) {
        LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
    } else {
        // Make sure restored key is not present
        dwWin32Status = RegDeleteValueW(hkeyDs, RESTORE_STATUS);
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        }

        RegCloseKey(hkeyDs);
    }

    // Create new invocation id

    dwWin32Status = CreateNewInvocationId(TRUE,        // save GUID in Database
                               &tmpGuid);
    if (dwWin32Status == ERROR_SUCCESS) {

        // Set restored key in registry

        dwWin32Status = EcDsarPerformRestore( NULL, NULL, 0, NULL );
        if (dwWin32Status != ERROR_SUCCESS) {
            LOG_UNHANDLED_BACKUP_ERROR( dwWin32Status );
        }
    } else {
        LogEvent( DS_EVENT_CAT_BACKUP,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_FAILED_TO_CREATE_INVOCATION_ID,
                  szInsertWin32Msg(dwWin32Status),
                  NULL, NULL );
    }

    if (dwWin32Status == ERROR_SUCCESS) {
        DPRINT(0,"DS Snapshot Restore was successful.\n");
        LogEvent(DS_EVENT_CAT_BACKUP,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_BACKUP_SNAPSHOT_RESTORE_SUCCESS,
                 szInsertUUID(&tmpGuid),
                 NULL, NULL );
    }
    return (dwWin32Status == ERROR_SUCCESS) ? true : false;
} /* CVssJetWriterLocal::OnPreRestoreEnd */

/* end snapshot.cxx */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetback\dirapi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dirapi.c

Abstract:

    Routines to obtain data from the ds using the DirXXX api
    Used for in-process, non-ntdsa callers.
    This code is intended to be used by the backup server dll, which is
    dynamically loaded into lsass.  The DirApi will only work when NTDSA
    is active (that is, not during DS Restore Mode).

Author:

    Will Lees (wlees) 06-Apr-2001

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <nt.h>
#include <winbase.h>
#include <tchar.h>
#include <string.h>
#include <dsconfig.h>
#include <ntdsa.h>
#include <attids.h>
#include <direrr.h>

#define DEBSUB "DIRAPI:"       // define the subsystem for debugging
#include "debug.h"              // standard debugging header
#include <fileno.h>
#define  FILENO FILENO_DIRAPI
#include "dsevent.h"
#include "mdcodes.h"            // header for error codes

/* External */

/* Static */

/* Forward */
/* End Forward */


DWORD
getTombstoneLifetimeInDays(
    VOID
    )

/*++

Routine Description:

    Get the forest tombstone lifetime, in days. If none is set or an error occurs,
    we return the default.

Arguments:

    VOID - 

Return Value:

    DWORD - lifetime, in days

--*/

{
    NTSTATUS NtStatus;

    ULONG        Size;
    DSNAME       *DsServiceConfigName = 0;
    ULONG        dirError;

    ATTR      rgAttrs[] =
    {
        { ATT_TOMBSTONE_LIFETIME, { 0, NULL } }
    };

    ENTINFSEL Sel =
    {
        EN_ATTSET_LIST,
        { sizeof( rgAttrs )/sizeof( rgAttrs[ 0 ] ), rgAttrs },
        EN_INFOTYPES_TYPES_VALS
    };

    READARG   ReadArg;
    READRES   *pReadRes = 0;

    DWORD iAttr;
    DWORD dwTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;

    try {

        //
        // Create a thread state
        //
        if (THCreate( CALLERTYPE_INTERNAL )) {

            leave;

        }

        // Find DN of Ds Service Config Object
        Size = 0;
        NtStatus = GetConfigurationName( DSCONFIGNAME_DS_SVC_CONFIG,
                                         &Size,
                                         DsServiceConfigName );
        if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
            __leave;
        }
        DsServiceConfigName = (DSNAME*) alloca( Size );
        NtStatus = GetConfigurationName( DSCONFIGNAME_DS_SVC_CONFIG,
                                         &Size,
                                         DsServiceConfigName );
        if (NtStatus) {
            __leave;
        }

        // Set up read args
        RtlZeroMemory(&ReadArg, sizeof(ReadArg));

        ReadArg.pObject = DsServiceConfigName;

        ReadArg.pSel    = &Sel;

        //
        // Setup the common arguments
        //
        InitCommarg(&ReadArg.CommArg);

        // Trusted caller
        SampSetDsa( TRUE );

        // Clear errors
        THClearErrors();

        //
        // We are now ready to read!
        //
        dirError = DirRead(&ReadArg, &pReadRes);

        if ( 0 != dirError )
        {
            if ( attributeError == dirError )
            {
                INTFORMPROB * pprob = &pReadRes->CommRes.pErrInfo->AtrErr.FirstProblem.intprob;

                if (    ( PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == pprob->problem )
                        && ( DIRERR_NO_REQUESTED_ATTS_FOUND == pprob->extendedErr )
                    )
                {
                    // No value; use default (as set above).
                    dirError = 0;
                }
            }

            if ( 0 != dirError )
            {
                LogEvent8(
                    DS_EVENT_CAT_BACKUP,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_BACKUP_DIR_READ_FAILURE,
                    szInsertDN(DsServiceConfigName),
                    szInsertInt(dirError),
                    szInsertSz(THGetErrorString()),
                    szInsertHex(DSID(FILENO,__LINE__)),
                    NULL, NULL, NULL, NULL
                    ); 
                __leave;
            }
        }
        else
        {
            // Read succeeded; parse returned attributes.
            for ( iAttr = 0; iAttr < pReadRes->entry.AttrBlock.attrCount; iAttr++ )
            {
                ATTR *  pattr = &pReadRes->entry.AttrBlock.pAttr[ iAttr ];

                switch ( pattr->attrTyp )
                {
                case ATT_TOMBSTONE_LIFETIME:
                    Assert( 1 == pattr->AttrVal.valCount );
                    Assert( sizeof( ULONG ) == pattr->AttrVal.pAVal->valLen );
                    dwTombstoneLifetimeDays = *( (ULONG *) pattr->AttrVal.pAVal->pVal );
                    break;
            
                default:
                    DPRINT1( 0, "Received unrequested attribute 0x%X.\n", pattr->attrTyp );
                    break;
                }
            }

            if ( dwTombstoneLifetimeDays < DRA_TOMBSTONE_LIFE_MIN )
            {
                // Invalid value; use default.
                dwTombstoneLifetimeDays = DEFAULT_TOMBSTONE_LIFETIME;
            }
        }
    }
    finally
    {
        THDestroy();
    }

    DPRINT1( 1, "Tombstone Lifetime is %d days.\n", dwTombstoneLifetimeDays );

    return dwTombstoneLifetimeDays;
} /* getTombstoneLifetimeInDays */

/* end dirapi.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetback\jetback.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       jetback.c
//
//--------------------------------------------------------------------------

/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    jetback.c

Abstract:

    This module is the server side header file for the NTDS backup APIs.


Author:

    Larry Osterman (larryo) 19-Aug-1994
    R.S. Raghavan  (rsraghav) 03/24/97 Modified to use with backing up NTDS.


Revision History:

Note:
    Exchange backup is performed via 3 mechanisms:
        The first is a straightforward extension of the JET backup APIs.
        The second uses a private socket based mechanism for performance.
        The third is used when loopbacked - we read and write to a shared memory section.


--*/

#define UNICODE

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <jetbak.h>
#include <rpc.h>
#include <stdlib.h>
#include <debug.h>

#define DEBSUB "JETBACK:"       // define the subsystem for debugging
#include "debug.h"              // standard debugging header
#include <ntdsa.h>
#include <dsevent.h>

BOOL
fBackupRegistered = fFalse;

WCHAR
rgchComputerName[MAX_COMPUTERNAME_LENGTH+1];

// 
// Global flag that tells if the System is booted off the DS
//
BOOL g_fBootedOffNTDS = FALSE;

// proto-types
EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    );


HRESULT
HrFromJetErr(
    JET_ERR jetError
    )
{
    HRESULT hr = 0;

    if (jetError == JET_errSuccess)
    {
        return(hrNone);
    }

    //
    //  Set the error code.
    //

    if (jetError < 0)
    {
        hr = (STATUS_SEVERITY_ERROR << 30) | (FACILITY_NTDSB << 16) | -jetError;
    }
    else
    {
        hr = (STATUS_SEVERITY_WARNING << 30) | (FACILITY_NTDSB << 16) | jetError;
    }

    DebugTrace(("HrFromJetErr: %d maps to 0x%x\n", jetError, hr));

    return(hr);
}


//
//  JET backup server side interface.
//

void SetNTDSOnlineStatus(BOOL fBootedOffNTDS)
{
    g_fBootedOffNTDS = fBootedOffNTDS;
}

/*
 -  HrBackupRegister
 -
 *  Purpose:
 *      This routine to register a process for backup.  It is called by either the store or DS.
 *
 *  Parameters:
 *
 *      puuidService - an Object UUID for the service.
 *
 *  Returns:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
HrBackupRegister()
{
    HRESULT hr;

    Assert(!fBackupRegistered);

    hr = RegisterRpcInterface(JetBack_ServerIfHandle, g_wszBackupAnnotation);
    if (hrNone == hr) {
        fBackupRegistered = fTrue;
    }

    return(hr);
}

/*
 -  HrBackupUnregister
 -
 *  Purpose:
 *
 *      This routine will unregister a process for backup.  It is called by either the store or DS.
 *
 *  Parameters:
 *      None.
 *
 *  Return Value:
 *
 *      HRESULT - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT
HrBackupUnregister()
{
    HRESULT hr = hrNone;

    hr = UnregisterRpcInterface(JetBack_ServerIfHandle);
    if (hrNone == hr) {
        fBackupRegistered = FALSE;
    }

    return(hr);
}


/*
 -  MIDL_user_allocate
 -
 *  Purpose:
 *      Allocates memory for RPC operations.
 *
 *  Parameters:
 *      cbBytes - # of bytes to allocate
 *
 *  Returns:
 *      Memory allocated, or NULL if not enough memory.
 */

void *
MIDL_user_allocate(
    size_t cbBytes
    )
{
    return(LocalAlloc(LMEM_ZEROINIT, cbBytes));
}


/*
 -  MIDL_user_free
 -
 *  Purpose:
 *      Frees memory allocated via MIDL_user_allocate.
 *
 *  Parameters:
 *      pvBuffer - The buffer to free.
 *
 *  Returns:
 *      None.
 */
void
MIDL_user_free(
    void *pvBuffer
    )
{
    LocalFree(pvBuffer);
}




//
//
//  The actual JET backup APIs.
//



HRESULT
HrRBackupPrepare(
    handle_t hBinding,
    unsigned long grbit,
    unsigned long btBackupType,
    WSZ wszBackupAnnotation,
    DWORD dwClientIdentifier,
    CXH *pcxh
    )
/*++

Routine Description:

    This routine is called to notify JET that a backup is in progress.  It will also allocate
    and initialize the server side RPC binding context

Arguments:
    hBinding - the initial binding handle.  Ignored by this routine, and not needed from now on.
    pcxh - Pointer to a context handle for this client.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrNone;
    PJETBACK_SERVER_CONTEXT pjsc;
    
#ifdef  DEBUG
    if (!FInitializeTraceLog())
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
#endif

    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    DebugTrace(("HrrBackupPrepare.\n", hr));
    //
    //  Check to make sure that the client can perform the backup.
    //

    if (!FBackupServerAccessCheck(fFalse))
    {
        DebugTrace(("HrrBackupPrepare: Returns ACCESS_DENIED"));
        return(ERROR_ACCESS_DENIED);
    }

    switch (btBackupType)
    {
    case BACKUP_TYPE_FULL:

        //
        //  When we come in for a full backup, we want to reset our current max
        //  log number.
        //

        hr = DsSetCurrentBackupLog(rgchComputerName, 0);
        DebugTrace(("HrSetCurrentBackupLog (%S, 0) returns %d", rgchComputerName, hr));
        break;
    case BACKUP_TYPE_LOGS_ONLY:
        //
        //  When we come in for an incremental or differential backup, we want
        //  to check to make sure that the right logs are there.
        //

        hr = I_DsCheckBackupLogs(g_wszBackupAnnotation);
        DebugTrace(("I_DsCheckBackupLogs (%S) returns %d", g_wszBackupAnnotation, hr));
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (hr != hrNone)
    {
        DebugTrace(("Failing HrBackupPrepare with %d", hr));
        return hr;
    }
    pjsc = MIDL_user_allocate(sizeof(JETBACK_SERVER_CONTEXT));

    if (pjsc == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    pjsc->u.Backup.wszBackupAnnotation = MIDL_user_allocate((wcslen(wszBackupAnnotation)+1)*sizeof(WCHAR));

    if (pjsc->u.Backup.wszBackupAnnotation == NULL)
    {
        MIDL_user_free(pjsc);
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    wcscpy(pjsc->u.Backup.wszBackupAnnotation, wszBackupAnnotation);

    //
    //  Remember the PID of the client.  We'll use this later to set up our shared memory
    //  segment.
    //

    pjsc->u.Backup.dwClientIdentifier = dwClientIdentifier;

    pjsc->fRestoreOperation = fFalse;

    pjsc->u.Backup.fHandleIsValid = fFalse;

    pjsc->u.Backup.sockClient = INVALID_SOCKET;

    *pcxh = (CXH)pjsc;

    //
    //  Now tell Jet that this guy is starting a backup process.
    //

    pjsc->u.Backup.fBackupIsRegistered = fFalse;

    hr = HrFromJetErr(JetBeginExternalBackup(grbit));

    if (hr == hrNone)
    {
        pjsc->u.Backup.fBackupIsRegistered = fTrue;
    }
    else
    {
        DebugTrace(("JetBeginExternalBackup failed with 0x%x", hr));
        MIDL_user_free(pjsc->u.Backup.wszBackupAnnotation);
        pjsc->u.Backup.wszBackupAnnotation = NULL;
        MIDL_user_free(pjsc);
        *pcxh = NULL;
    }

    DebugTrace(("HrrBackupPrepare returns 0x%x", hr));
    return(hr);
}


HRESULT
HrRBackupTruncateLogs(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called to notify JET that the backup is complete.
    It should only be called when the backup has successfully completed.

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr;

    hr = HrFromJetErr(JetTruncateLog());

    return(hr);
}

HRESULT
HrRBackupGetBackupLogs(
    CXH cxh,
    char **pszBackupLogs,
    CB *pcbSize
    )
/*++

Routine Description:

    This routine is called to return the list of log files for the current database.

Arguments:
    cxh - the server side context handle for this operation.
    pszBackupLogs - the name of the file to open.
    pcbSize - The size of the attachment, in bytes.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr;
    SZ szJetBackupLogs;
    unsigned long cbJetSize;
    unsigned long cbOldJetSize;
    WSZ wszBackupLogs;
    CB cbBackupLogs;

    //
    //  Figure out how much storage is needed to hold the logs.
    //

    hr = HrFromJetErr(JetGetLogInfo(NULL, 0, &cbJetSize));

    if (hr != hrNone)
    {
        return(hr);
    }
    do
    {
        szJetBackupLogs = MIDL_user_allocate(cbJetSize);

        if (szJetBackupLogs == NULL)
        {
            return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        }

        //
        //  Now actually retrieve the logs.
        //
    
        cbOldJetSize = cbJetSize;

        hr = HrFromJetErr(JetGetLogInfo(szJetBackupLogs, cbJetSize, &cbJetSize));
    
        if (hr != hrNone)
        {
            MIDL_user_free(szJetBackupLogs);
            return(hr);
        }
    
        if (cbJetSize != cbOldJetSize)
        {
            MIDL_user_free(szJetBackupLogs);
        }

    } while ( cbOldJetSize != cbJetSize  );

    //
    //  Now convert the log name from JET to a uniform name that
    //  can be accessed from the client.
    //

    hr = HrMungedFileNamesFromJetFileNames(&wszBackupLogs, &cbBackupLogs, szJetBackupLogs, cbJetSize, fFalse);

    //
    //  Ok, we're not quite done yet.
    //
    //  Now we need to annotate the list of files being returned.
    //
    //  This means that we need to re-allocate the buffer being returned (again).
    //

    if (hr == hrNone)
    {
        hr = HrAnnotateMungedFileList(cxh, wszBackupLogs, cbBackupLogs, (WSZ *)pszBackupLogs, pcbSize);

        MIDL_user_free(wszBackupLogs);
    }

    
    MIDL_user_free(szJetBackupLogs);
    return(hr);
}

HRESULT
HrRBackupGetAttachmentInformation(
    CXH cxh,
    SZ *pszAttachmentInformation,
    CB *pcbSize
    )
/*++

Routine Description:

    This routine is called to return the list of attachments to the current database.

Arguments:
    cxh - the server side context handle for this operation.
    szAttachmentInformation - the name of the file to open.
    pcbSize - The size of the attachment, in bytes.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr;
    SZ szJetAttachmentList;
    CB cbJetSize;
    WSZ wszAttachmentInformation;
    CB cbAttachmentInformation;
    //
    //  Figure out how much storage is needed to hold the logs.
    //

    hr = HrFromJetErr(JetGetAttachInfo(NULL, 0, &cbJetSize));

    if (hr != hrNone)
    {
        return(hr);
    }

    szJetAttachmentList = MIDL_user_allocate(cbJetSize);

    if (szJetAttachmentList == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    hr = HrFromJetErr(JetGetAttachInfo(szJetAttachmentList, cbJetSize, &cbJetSize));

    if (hr != hrNone)
    {
        MIDL_user_free(szJetAttachmentList);
        return(hr);
    }

    //
    //  Now convert the log name from JET to a uniform name that
    //  can be accessed from the client.
    //

    hr = HrMungedFileNamesFromJetFileNames(&wszAttachmentInformation, &cbAttachmentInformation, szJetAttachmentList, cbJetSize, fFalse);

    //
    //  Ok, we're not quite done yet.
    //
    //  Now we need to annotate the list of files being returned.
    //
    //  This means that we need to re-allocate the buffer being returned (again).
    //

    if (hr == hrNone)
    {
        hr = HrAnnotateMungedFileList(cxh, wszAttachmentInformation, cbAttachmentInformation, (WSZ *)pszAttachmentInformation, pcbSize);

        MIDL_user_free(wszAttachmentInformation);
    }

    MIDL_user_free(szJetAttachmentList);

    return(hr);
}

BOOL
FIsLogFile(
    SZ szName,
    LPDWORD dwGeneration
    )
{
    char rgchDrive[_MAX_DRIVE];
    char rgchDir[_MAX_DIR];
    char rgchFileName[_MAX_FNAME];
    char rgchExtension[_MAX_EXT];

    _splitpath(szName, rgchDrive, rgchDir, rgchFileName, rgchExtension);
    
    if (_stricmp(rgchExtension, ".log"))
    {
        return fFalse;
    }

    if (_strnicmp(rgchFileName, "edb", 3))
    {
        return fFalse;
    }

    //
    //  It's a log file.
    //

    if (dwGeneration != NULL)
    {
        SZ szT = rgchFileName;

        *dwGeneration = 0;
        //
        //  We want to find out the generation of this file if it's a log file.
        //
        while (*szT)
        {
            if (isdigit(*szT))
            {
                int iResult = sscanf(szT, "%x", dwGeneration);
                if ( (iResult == 0) || (iResult == EOF) ) {
                    return fFalse;
                }
                break;
            }
            szT += 1;
        }
    }

    return fTrue;
}

HRESULT
HrRBackupOpenFile(
    CXH cxh,
    WSZ szAttachment,
    CB cbReadHintSize,
    BOOLEAN *pfUseSockets,
    C cProtocols,
    struct sockaddr rgsockaddrSockets[],
    BOOLEAN *pfUseSharedMemory,
    unsigned hyper *plicbFile
    )
/*++

Routine Description:

    This routine is called to open a file for Jet backup.

Arguments:
    cxh - the server side context handle for this operation.
    szAttachment - the name of the file to open.
    cbReadHintSize - A hint of the size of the reads that are to be done on the file.
    pulLengthLow - Low 32 bit of the file size.
    pulLengthHigh - High 32 bits of the file size.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrError;
    LARGE_INTEGER liFileSize;

    if (cxh != NULL)
    {
        PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;
        SZ szJetName;
        DWORD dwFileGeneration;
        WCHAR rgwcDrive[4];
        DWORD dwDummy;

        if (pjsc->u.Backup.fHandleIsValid)
        {
            return(hrAlreadyOpen);
        }

        hr = HrJetFileNameFromMungedFileName(szAttachment, &szJetName);

        if (hr != hrNone)
        {
            return(hr);
        }

        Assert(isascii(*szJetName));
        Assert(szJetName[1] == ':');
        Assert(szJetName[2] == '\\');
        rgwcDrive[0] = szJetName[0];
        rgwcDrive[1] = ':';
        rgwcDrive[2] = '\\';
        rgwcDrive[3] = '\0';

        //
        //  Figure out the granularity of the drive.
        //

        if (!GetDiskFreeSpaceW(rgwcDrive, &dwDummy, &pjsc->u.Backup.dwFileSystemGranularity, &dwDummy, &dwDummy))
        {
            MIDL_user_free(szJetName);
            return GetLastError();
        }

        //
        //  Open the file.
        //

        hr = HrFromJetErr(JetOpenFile(szJetName, &pjsc->u.Backup.hFile, &liFileSize.LowPart, &liFileSize.HighPart));

        if (hr != hrNone)
        {

            MIDL_user_free(szJetName);
            return(hr);
        }

        pjsc->u.Backup.fHandleIsValid = fTrue;

        //
        //  Now save away state information about the read.
        //

        *plicbFile = liFileSize.QuadPart;
        pjsc->u.Backup.liFileSize = liFileSize;
        pjsc->u.Backup.cbReadHint = cbReadHintSize;

        if (FIsLogFile(szJetName, &dwFileGeneration))
        {
            if (dwFileGeneration != -1)
            {
                HKEY hkey;
                DWORD dwDisposition;
                DWORD   dwCurrentLogNumber = 0;
                DWORD   dwType;
                DWORD   cbLogNumber;
                WCHAR   rgwcRegistryBuffer[ MAX_PATH ];

                _snwprintf(rgwcRegistryBuffer,
                           sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
                           L"%ls%ls",
                           BACKUP_INFO,
                           pjsc->u.Backup.wszBackupAnnotation);

                if (hr = RegCreateKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, NULL, 0, KEY_WRITE | KEY_READ, NULL, &hkey, &dwDisposition))
                {
                    MIDL_user_free(szJetName);
                    return(hr);
                }

                dwType = REG_DWORD;
                cbLogNumber = sizeof(DWORD);
                hr = RegQueryValueExW(hkey, LAST_BACKUP_LOG, 0, &dwType, (LPBYTE)&dwCurrentLogNumber, &cbLogNumber);

                if (hr && hr != ERROR_FILE_NOT_FOUND)
                {
                    MIDL_user_free(szJetName);
                    RegCloseKey(hkey);
                    return(hr);
                }


                if (dwFileGeneration >= dwCurrentLogNumber)
                {

                    hr = RegSetValueExW(hkey, LAST_BACKUP_LOG, 0, REG_DWORD, (LPBYTE)&dwFileGeneration, sizeof(DWORD));
    
                    if (hr)
                    {
                        MIDL_user_free(szJetName);
                        RegCloseKey(hkey);
                        return(hr);
                    }

                }
                RegCloseKey(hkey);
            }
        }

        MIDL_user_free(szJetName);

        if (*pfUseSharedMemory)
        {
            pjsc->u.Backup.fUseSharedMemory =
                *pfUseSharedMemory =
                    FCreateSharedMemorySection(&pjsc->u.Backup.jsc,
                                                pjsc->u.Backup.dwClientIdentifier,
                                                fFalse,
                                                cbReadHintSize*READAHEAD_MULTIPLIER);
        }

        //
        //  If the client can use sockets, and isn't using shared memory, connect back to the client.
        //

        if (!*pfUseSharedMemory && *pfUseSockets)
        {
            //
            //  Connect back to the client.
            //
    
            pjsc->u.Backup.sockClient = SockConnectToRemote(rgsockaddrSockets, cProtocols);
    
            if (pjsc->u.Backup.sockClient != INVALID_SOCKET)
            {

                //
                //  We connected back to the client, we're in luck.
                //

                //
                //  Now tell winsock the buffer size of the transfer.
                //

                setsockopt(pjsc->u.Backup.sockClient, SOL_SOCKET, SO_SNDBUF, (char *)&cbReadHintSize, sizeof(DWORD));               

                //
                //  And tell it to turn on keepalives.
                //

                //
                //  Boolean socket operations just need a pointer to a non-
                //  zero buffer.
                //
                Assert(cbReadHintSize != 0);

                setsockopt(pjsc->u.Backup.sockClient, SOL_SOCKET, SO_KEEPALIVE, (char *)&cbReadHintSize, sizeof(DWORD));

                //
                //  Indicate that we're using sockets.
                //

                pjsc->u.Backup.fUseSockets = fTrue;

                //
                //  And make sure that nobody else can close this socket.
                //

                SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);

            }
            else
            {
                //
                //  We couldn't connect - continue, but we can't use sockets.
                //

                *pfUseSockets = fFalse;

                pjsc->u.Backup.fUseSockets = fFalse;

            }

        }

    }

    return(hr);
}

DWORD
dwPingCounter = 0;

HRESULT
HrRBackupPing(
    handle_t hBinding
    )
{
    //
    //  Monotonically increase the ping counter.
    //

    InterlockedIncrement(&dwPingCounter);

    return hrNone;
}

HRESULT
HrSharedWrite(
    PJETBACK_SERVER_CONTEXT pjsc,
    char *pvBuffer,
    CB cbBuffer,
    CB *pcbRead
    )
/*++

Routine Description:

Write data to the shared memory segment, synchronizing with the reader.

HrSharedWrite synchronizes with HrBackupRead using two events:
heventRead and heventWrite.
heventRead is the data available event from writer to reader
heventWrite is the data consumed event from reader to writer
This side is the writing side.
Reading side is at jetbcli\jetbcli.c:HrBackupRead()

Here is the algorithm:
while()
    write blocked = false
    Make data available
    if (read blocked) set data available
    write blocked = true
    wait for data consumed

One purpose of the read block flag is to determine whether the reader is
waiting or not.  The reader may or may not block depending on whether he
finds data in buffer.

I've come to the conclusion that the if (reader blocked) set event constructs
to serve a purpose.  The reader may or may not wait, depending on whether he
finds data in the buffer.  The producer avoids setting the event if the
consumer isn't waiting.  

I've toned down my complaining in common.c since the code really is pretty
reasonble using the mutex to keep things orderly.  The only problem was the
use of pulse event.  I can sort of see the reasoning now: if you use
synchronized flags to tell that your partner is waiting, pulse event does the
job since it only wakes a waiting waiter.  The problem no one saw is that
reader blocked = true
release mutex
wait for event
is not atomic.  If the producer runs between steps two and three, the pulse
is lost.  This is why the SetEvent is now used.

Arguments:

    pjsc - 
    pvBuffer - 
    cbBuffer - 
    pcbRead - 

Return Value:

    HRESULT - 

--*/
{
    HRESULT hr = hrNone;
    PJETBACK_SHARED_HEADER pjsh = pjsc->u.Backup.jsc.pjshSection;
    LARGE_INTEGER liBytesRead;
    liBytesRead.QuadPart = 0;

    //
    //  We're writing the file using shared memory.
    //

    WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);

    //
    //  We've now got the shared memory region locked.  See if there's enough room in the shared
    //  memory region available to read the data from the file, and if so, read it and update our pointers.
    //

    while (liBytesRead.QuadPart < pjsc->u.Backup.liFileSize.QuadPart)
    {
        DWORD dwWriteEnd;
        BOOLEAN fWriteOk;
        pjsc->u.Backup.jsc.pjshSection->fWriteBlocked = fFalse;

        //
        //  If the read side of the API returned while we were blocked, we want to return
        //  right away.
        //

                
        if ((hr = pjsh->hrApi) != hrNone)
        {
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);
            return hr;
        }
        
        //
        //  If the write is ahead of the read pointer, we want to read one buffers worth of data.
        //
        
        if (pjsh->dwWritePointer > pjsh->dwReadPointer || pjsh->cbReadDataAvailable == 0)
        {
            //
            //  The end of this write is either the end of the buffer, or 1 read-hint length into
            //  the buffer.
            //

            dwWriteEnd = min(pjsh->dwWritePointer + pjsc->u.Backup.cbReadHint,
                             pjsh->cbSharedBuffer);
            
            fWriteOk = fTrue;
        }
        else
        {
            //
            //  In this case, the start of the write is before the start of the read pointer,
            //  so the end of the write is 1 read-hint length ahead of the write pointer.
            //
            //  There are basically 3 cases:
            //      1)  Read pointer is > 1 read-hint length ahead of the write pointer -
            //              In this case we can read data into the buffer.
            //      2)  Read pointer is < 1 read-hint length ahead of the write pointer -
            //              In this case, we need to block until read data is taken
            //      3)  Read pointer is == write pointer.
            //              In this case, we need to follow the comment below.
            //

            dwWriteEnd = pjsh->dwWritePointer + pjsc->u.Backup.cbReadHint;
            
            //
            //  We can write iff the end of the write is before the read offset.
            //
            
            if (dwWriteEnd < pjsh->dwReadPointer)
            {
                fWriteOk = fTrue;
            }
            else if (dwWriteEnd == pjsh->dwReadPointer)
            {
                //
                //  if dwWriteEnd == dwReadPointer, it means that there is either no data
                //  available in the buffer, or all the data is available in the buffer.
                //
                //  If there's no data available in the buffer, we can write more, if the buffer
                //  is full, we can't.
                //
                
                fWriteOk = ((DWORD)pjsh->cbReadDataAvailable !=
                            pjsh->cbSharedBuffer);
            }   
            else
            {
                //
                //  The write extends into the read data.  We can't do the write.
                //
                
                fWriteOk = fFalse;
            }
        }
        
        if (fWriteOk)
        {
            DWORD cbBackupRead;
            LARGE_INTEGER cbBytesRemaining;
            
            //
            //  We want to read either the full amount of data for the read or to the end of the file.
            //

            cbBackupRead = dwWriteEnd - pjsh->dwWritePointer;
            
            cbBytesRemaining.QuadPart = pjsc->u.Backup.liFileSize.QuadPart - liBytesRead.QuadPart;

            if (cbBytesRemaining.HighPart == 0)
            {
                cbBackupRead = min(cbBackupRead, cbBytesRemaining.LowPart);
            }

            Assert (pjsh->cbReadDataAvailable   <
                    (LONG)pjsh->cbSharedBuffer);

            Assert (pjsh->cbReadDataAvailable   <=
                    (LONG)pjsh->cbSharedBuffer-(LONG)cbBackupRead);
            //
            //  We want to release the mutex, read the data, and re-acquire after writing the data.
            //
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);

            //
            //  Now read the data from JET into the shared memory region.
            //

            //
            //  Read either the read hint or the amount remaining in the
            //  file.  If the read hint size is > the size of the file, JetReadFile
            //  will simply return ecDiskIO.
            //
        
            Assert (cbBackupRead);
            hr = HrFromJetErr(JetReadFile(pjsc->u.Backup.hFile,
                                                    (void *)((CHAR *)pjsh+
                                                        pjsh->cbPage+
                                                        pjsh->dwWritePointer),
                                                    cbBackupRead,
                                                    pcbRead));
        
            //
            //  If the read failed, bail out now.  We don't own any resources, so we can just return.
            //

            if (hr != hrNone)
            {
                pjsh->hrApi = hr;
                return hr;
            }

            liBytesRead.QuadPart += *pcbRead;

            //
            //  We were woken up.  Reacquire the shared mutex and wait again.
            //

            WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);

            Assert (pjsh->cbReadDataAvailable < (LONG)pjsh->cbSharedBuffer);

            //
            //  Bump the number of available data bytes.
            //

            pjsh->cbReadDataAvailable   += *pcbRead;

            //
            //  There is always less data than the size of the buffer available.
            //

            Assert (pjsh->cbReadDataAvailable <= pjsh->cbReadDataAvailable);

            //
            //  Advance the write end pointer.
            //

            pjsh->dwWritePointer += *pcbRead;

            if (pjsh->dwWritePointer >= pjsh->cbSharedBuffer)
            {
                pjsh->dwWritePointer -= pjsh->cbSharedBuffer;
            }

            if (pjsh->fReadBlocked)
            {
                //
                //  Kick the reader - there's data for him.
                //
                
                SetEvent(pjsc->u.Backup.jsc.heventRead);
            }

#ifdef DEBUG
            //
            //  The number of bytes available is always the same as the
            //  the number of bytes in the buffer - the # of bytes read, unless
            //  the read and write pointers are the same, in which case, it is either
            //  0 or the total # of bytes available.
            //
            //  If the read is blocked, then there must be 0 bytes available, otherwise there
            //  must be the entire buffer available.
            //
                
            if (pjsh->dwWritePointer == pjsh->dwReadPointer)
            {
                Assert (pjsh->cbReadDataAvailable == 0 ||
                        pjsh->cbReadDataAvailable == (LONG)pjsh->cbSharedBuffer);
            }
            else
            {
                CB cbAvailable;
                if (pjsh->dwWritePointer > pjsh->dwReadPointer)
                {
                    cbAvailable = pjsh->dwWritePointer - pjsh->dwReadPointer;
                }
                else
                {
                    cbAvailable = pjsh->cbSharedBuffer - pjsh->dwReadPointer;
                    cbAvailable += pjsh->dwWritePointer;
                }
                
                Assert (cbAvailable >= 0);
                Assert (pjsh->cbReadDataAvailable == cbAvailable);
                    
            }
#endif
        }
        else
        {
            DWORD dwOldPingCounter;
            pjsh->fWriteBlocked = fTrue;

            //
            //  Ok, we think we've got to block.  Make sure that the write event
            //  is really going to block.
            //

            
            ReleaseMutex(pjsc->u.Backup.jsc.hmutexSection);

            //
            //  Wait for the client to read the data.  If the wait times out and
            //  the client hasn't pinged the server since we started the wait,
            //  then we need to punt - the client is probably long gone.
            //
            //  Please note that the client pings the server 4 times in a wait timeout,
            //  so we should never incorrectly detect the client going away - even if the client
            //  was CPU bound for some period of time, at least one of the pings should have
            //  made it in.
            //


            do
            {
                DWORD dwWin32Error;

                dwOldPingCounter = dwPingCounter;
                dwWin32Error = WaitForSingleObject(pjsc->u.Backup.jsc.heventWrite, BACKUP_WAIT_TIMEOUT);
                hr = HRESULT_FROM_WIN32( dwWin32Error );
            } while (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT) && dwPingCounter != dwOldPingCounter );
            
            if (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT))
            {
                return hrCommunicationError;
            }
            //
            //  We were woken up.  Reacquire the shared mutex and wait again.
            //

            WaitForSingleObject(pjsc->u.Backup.jsc.hmutexSection, INFINITE);
            
        }
    }

    return hr;
}


HRESULT
HrSocketWrite(
    PJETBACK_SERVER_CONTEXT pjsc,
    char *pvBuffer,
    CB cbBuffer,
    CB *pcbRead
    )
{
    HRESULT hr;
    HANDLE hWriteCompleteEvent;
    DWORD cbWritten;
    OVERLAPPED overlapped;
    CHAR *pbBufferRead;
    CHAR *pbBufferSend;
    LARGE_INTEGER liBytesRead;

    liBytesRead.QuadPart = 0;

    DebugTrace(("HrSocketWrite\n"));


    //
    //  We're reading the file using sockets.
    //

    //
    //  Create an event in the signalled state.
    //
    
    hWriteCompleteEvent = CreateEvent(NULL, fFalse, fTrue, NULL);
    
    if (hWriteCompleteEvent == NULL)
    {
        DebugTrace(("HrSocketWrite: Could not create completion event\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    //
    //  Zero the contents of the overlapped structure.  This is actually important, because
    //  it allows us to call GetOverlappedResult() on a handle that doesn't have I/O
    //  outstanding on it yet.
    //
    
    memset(&overlapped, 0, sizeof(overlapped));
    
    overlapped.hEvent = hWriteCompleteEvent;
    
    //
    //  Ok, we're using sockets for this API, we want to read the data from the file and
    //  return it to the client.
    //
            
    pbBufferSend = VirtualAlloc(NULL, pjsc->u.Backup.cbReadHint, MEM_COMMIT, PAGE_READWRITE);
    
    if (pbBufferSend == NULL)
    {
        CloseHandle(hWriteCompleteEvent);
        DebugTrace(("HrSocketWrite: Could not allocate send buffer\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    pbBufferRead = VirtualAlloc(NULL, pjsc->u.Backup.cbReadHint, MEM_COMMIT, PAGE_READWRITE);
    
    if (pbBufferRead == NULL)
    {
        CloseHandle(hWriteCompleteEvent);
        VirtualFree(pbBufferSend, 0, MEM_RELEASE);
        DebugTrace(("HrSocketWrite: Could not allocate read buffer\n"));
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }
    
    //
    //  Now loop reading data from the file and sending it to the
    //  client.
    //
    //  Please note that there is a fundimental assumption here that it takes longer
    //  to transmit the data to the client than it does to read the data from the file,
    //  if this is incorrect, then we probably want to queue up multiple writes to the
    //  client.  We also attempt to improve performance by overlapping the read with the network write.
    //
    
    while (liBytesRead.QuadPart < pjsc->u.Backup.liFileSize.QuadPart)
    {
        DWORD cbBytesToRead = pjsc->u.Backup.cbReadHint;
        LARGE_INTEGER cbBytesRemaining;
        CHAR *pbTemp;
        cbBytesRemaining.QuadPart = pjsc->u.Backup.liFileSize.QuadPart - liBytesRead.QuadPart;
    
        if (cbBytesRemaining.HighPart == 0)
        {
            cbBytesToRead = min(cbBytesToRead, cbBytesRemaining.LowPart);
        }
        
        //
        //  Read either the read hint or the amount remaining in the
        //  file.  If the read hint size is > the size of the file, JetReadFile
        //  will simply return ecDiskIO.
        //
    
        hr = HrFromJetErr(JetReadFile(pjsc->u.Backup.hFile,
                                      pbBufferRead,
                                      cbBytesToRead,
                                      pcbRead));
        
        if (hr != hrNone)
        {
            DebugTrace(("HrSocketWrite: JetReadFile failed with %x\n", hr));
            //
            //  Wait for any previous writes to complete before returning the JET error.
            //
            WaitForSingleObject(hWriteCompleteEvent, INFINITE);
    
            GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue);
            CloseHandle(hWriteCompleteEvent);
            
            //
            //  We're going to close the socket - make sure we can get away with it.
            //
            
            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
            
            closesocket(pjsc->u.Backup.sockClient);
            pjsc->u.Backup.sockClient = INVALID_SOCKET;
            VirtualFree(pbBufferSend, 0, MEM_RELEASE);
            VirtualFree(pbBufferRead, 0, MEM_RELEASE);
            return(hr);
        }
    
        //
        //  Wait for the previous write to complete.
        //
        
        WaitForSingleObject(hWriteCompleteEvent, INFINITE);
        
        if (!GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue)) {

            DebugTrace(("HrSocketWrite: Previous write failed with %d\n", GetLastError()));
            //
            //  The previous I/O failed.  Return the error to the client
            //
            hr = GetLastError();
            CloseHandle(hWriteCompleteEvent);
            //
            //  We're going to close the socket - make sure we can get away with it.
            //

            SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);

            closesocket(pjsc->u.Backup.sockClient);
            pjsc->u.Backup.sockClient = INVALID_SOCKET;
            VirtualFree(pbBufferSend, 0, MEM_RELEASE);
            VirtualFree(pbBufferRead, 0, MEM_RELEASE);
            return(hr);
        }
    
        //
        //  Now swap the send and read buffers - Thus the buffer we just read will be
        //  in pbBufferSend, and pbBufferRead will point to the buffer we just completed
        //  sending.
        //
        pbTemp = pbBufferSend;
        pbBufferSend = pbBufferRead;
        pbBufferRead = pbTemp;
        
        //
        //  Now transmit the next portion of the file to the client.
        //
        
        if (!WriteFile((HANDLE)pjsc->u.Backup.sockClient, pbBufferSend, *pcbRead, &cbWritten, &overlapped))
        {
            //
            //  The write failed with something other than I/O pending,
            //  we need to return that error to the client.
            //
            if (GetLastError() != ERROR_IO_PENDING)
            {
                hr = GetLastError();
                DebugTrace(("HrSocketWrite: Immediate write failed with %d\n", hr));
                CloseHandle(hWriteCompleteEvent);
                //
                //  We're going to close the socket - make sure we can get away with it.
                //
                
                SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);
                
                closesocket(pjsc->u.Backup.sockClient);
                pjsc->u.Backup.sockClient = INVALID_SOCKET;
                VirtualFree(pbBufferSend, 0, MEM_RELEASE);
                VirtualFree(pbBufferRead, 0, MEM_RELEASE);
                return(hr);
            }
        }
        
        //
        //  The write is on its way - mark that we've read and transmitted the
        //  data and continue sending.
        //
        
        liBytesRead.QuadPart += *pcbRead;
    }
    
    //
    //  We've transmitted the entire file to the client,
    //  we want to wait for the last outstanding I/O on the file to
    //  complete and then return to the client.
    //
    
    WaitForSingleObject(hWriteCompleteEvent, INFINITE);
    
    if (!GetOverlappedResult((HANDLE)pjsc->u.Backup.sockClient, &overlapped, &cbWritten, fTrue)) {
        //
        //  The previous I/O failed.  Return the error to the client
        //
        hr = GetLastError();
        DebugTrace(("HrSocketWrite: Final write failed with %d\n", hr));
    }
    else
    {
        hr = hrNone;
    }
    
    //
    //  Indicate that 0 bytes were read to the read API - if we don't
    //  do this, then RPC will attempt to transfer bogus data
    //  to the client.
    //
    
    *pcbRead = 0;
    
    CloseHandle(hWriteCompleteEvent);
    
    VirtualFree(pbBufferSend, 0, MEM_RELEASE);
    VirtualFree(pbBufferRead, 0, MEM_RELEASE);
    
    return hr;
}

HRESULT
HrRBackupRead(
    CXH cxh,
    char *pvBuffer,
    CB cbBuffer,
    CB *pcbRead
    )
{
    HRESULT hr = hrNone;

    if (cxh != NULL)
    {
        PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;
        LARGE_INTEGER liBytesRead;

        if (!pjsc->u.Backup.fHandleIsValid)
        {
            return(hrInvalidHandle);
        }

        liBytesRead.QuadPart = 0;

        //
        //  If we're not using sockets, just perform the read using JET, and
        //  return it to the caller.
        //

        if (pjsc->u.Backup.fUseSharedMemory)
        {
            hr = HrSharedWrite(pjsc, pvBuffer, cbBuffer, pcbRead);
        } else if (pjsc->u.Backup.fUseSockets)
        {
            hr = HrSocketWrite(pjsc, pvBuffer, cbBuffer, pcbRead);
        } else {
            char *pvReadBuffer;

            pvReadBuffer = VirtualAlloc(NULL, cbBuffer, MEM_COMMIT, PAGE_READWRITE);

            if (pvReadBuffer == NULL)
            {
                return ERROR_NOT_ENOUGH_SERVER_MEMORY;
            }

            hr = HrFromJetErr(JetReadFile(pjsc->u.Backup.hFile, pvReadBuffer, cbBuffer, pcbRead));
            
            if (hr != hrNone)
            {
                VirtualFree(pvReadBuffer, 0, MEM_RELEASE);
                return hr;
            }

            //
            //  Now copy the data from our buffer to the RPC buffer and free our buffer.
            //

            memcpy(pvBuffer, pvReadBuffer, cbBuffer);

            VirtualFree(pvReadBuffer, 0, MEM_RELEASE);

            return(hr);
        }
    
    }
    else
    {
        hr = hrError;
    }
    return(hr);
}


HRESULT
HrRBackupClose(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called to close a handle that was opened via a cal to HrRBackupOpenFile.

Arguments:
    cxh - The context handle for the client for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrInvalidHandle;
    if (cxh != NULL)
    {
        PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

        if (!pjsc->u.Backup.fHandleIsValid)
        {
            return(hrInvalidHandle);
        }

        //
        //  Tell Jet to close the backup file.
        //

        hr = HrFromJetErr(JetCloseFile(pjsc->u.Backup.hFile));

        pjsc->u.Backup.fHandleIsValid = fFalse;

        if (pjsc->u.Backup.fUseSharedMemory)
        {
            CloseSharedControl(&pjsc->u.Backup.jsc);
        }


        if (pjsc->u.Backup.fUseSockets)
        {
            if (pjsc->u.Backup.sockClient != INVALID_SOCKET)
            {
                //
                //  We're going to close the socket - make sure we can get away with it.
                //

                SetHandleInformation((HANDLE)pjsc->u.Backup.sockClient, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0);

                closesocket(pjsc->u.Backup.sockClient);
            }
        }

    }
    return(hr);
}

/*++

Routine Description:

    This routine retrieves the database locations for the specified component.

Arguments:
    wszBackupAnnotation - the annoation for the component to query.
    pwszDatabases - a pointer that will hold the locations of the databases
    pcbDatabases - the size of the buffer.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
HRESULT
HrGetDatabaseLocations(
    WSZ *pwszDatabases,
    CB *pcbDatabases
    )
{
    HRESULT hr = hrNone;
    char *szDatabases = NULL;
    CB cbSize;

    *pwszDatabases = NULL;
    __try 
    {
        // First find out how big the database locations are.
        hr = EcDsaQueryDatabaseLocations(NULL, &cbSize, NULL, 0, NULL);
        if (hr != hrNone)
        {
            return hr;
        }

        // Allocate memory to receive database locations
        szDatabases = MIDL_user_allocate(cbSize);
        if (!szDatabases)
        {
            return ERROR_NOT_ENOUGH_SERVER_MEMORY;
        }

        // Now actually get the database locations
        hr = EcDsaQueryDatabaseLocations(szDatabases, &cbSize, NULL, 0, NULL);
        if (hr != hrNone)
        {
            return hr;
        }

        // Now create munged file name from Jet file names
        hr = HrMungedFileNamesFromJetFileNames((WSZ *)pwszDatabases, pcbDatabases, 
                szDatabases, cbSize, fTrue);

        return hr;
    }
    __finally
    {
        if (szDatabases)
        {
            MIDL_user_free(szDatabases);
        }

        if (hr != hrNone)
        {
            if (*pwszDatabases)
            {
                MIDL_user_free(*pwszDatabases);
            }

            *pwszDatabases = NULL;
            *pcbDatabases = 0;
        }
    }

    return hr;
}


HRESULT
HrRBackupEnd(
    CXH *pcxh
    )
/*++

Routine Description:

    This routine is called when a backup is complete.  It terminates the server side
    operation.

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    HRESULT hr = hrNone;

#if 0
    CB cbDatabases;
    WSZ wszDatabases = NULL;
    WSZ wszDatabasesOrg = NULL;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) *pcxh;

    hr = HrGetDatabaseLocations(&wszDatabases, &cbDatabases);

    if (hr == hrNone)
    {
        WCHAR rgwcLogFiles[ MAX_PATH ];
        WSZ wszLogBaseEnd;
        BFT bftLocation;
        BOOLEAN fLogFound = fFalse;

        wszDatabasesOrg = wszDatabases;

        //
        //  Remember the log directory.
        //
        while (*wszDatabases)
        {
            bftLocation = *wszDatabases++;
    
            if (bftLocation == BFT_LOG_DIR)
            {
                wcscpy(rgwcLogFiles, wszDatabases);
                fLogFound = fTrue;
                break;
            }

            wszDatabases += wcslen(wszDatabases)+1;
        }

        if (fLogFound)
        {
            //
            //  Remember the start of the patch file name location.
            //
    
            wszLogBaseEnd = rgwcLogFiles+wcslen(rgwcLogFiles);
    
            //
            //  Start back at the beginning.
            //
            wszDatabases = wszDatabasesOrg;
    
            while (*wszDatabases)
            {
                bftLocation = *wszDatabases++;

                //
                //  If this thing is a database, then it had a patch file.
                //

                if (bftLocation & BFT_DATABASE_DIRECTORY)
                {
                    WSZ wszDatabaseName;
                    //
                    //  Skip to the start of the database names.
                    //
            
                    wszDatabaseName = wcsrchr(wszDatabases, L'\\');
        
                    if (wszDatabaseName)
                    {
                        wcscpy(wszLogBaseEnd, wszDatabaseName);

                        //
                        //  Change the extension of the name from EDB to PAT
                        //
        
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-4]== L'.');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-3]== L'E' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-3]== L'e');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-2]== L'D' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-2]== L'd');
                        Assert(wszLogBaseEnd[wcslen(wszDatabaseName)-1]== L'B' ||
                               wszLogBaseEnd[wcslen(wszDatabaseName)-1]== L'b');

                        wcscpy(&wszLogBaseEnd[wcslen(wszDatabaseName)-3], L"PAT");
        
                        //
                        //  Now delete the patch file.
                        //
        
                        DeleteFileW(rgwcLogFiles);
        
                    }
        
                }

                wszDatabases += wcslen(wszDatabases)+1;
            }
        }
    }

    if (wszDatabasesOrg != NULL)
    {
        BackupFree(wszDatabasesOrg);
    }

#endif //#if 0
    HrDestroyCxh(*pcxh);

    MIDL_user_free(*pcxh);

    *pcxh = NULL;

    return hr;
}


HRESULT
HrDestroyCxh(
    CXH cxh
    )
/*++

Routine Description:

    This routine is called when a client has disconnected from the server.  It will do whatever actions are necessary
    to clean up any client state that is remaining.
    

Arguments:
    cxh - the server side context handle for this operation.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{

    if (cxh != NULL)
    {
        PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT) cxh;

        if (pjsc->fRestoreOperation)
        {
            RestoreRundown(pjsc);
        }
        else
        {
            //
            //  Close the backup if appropriate.
            //
    
            if (pjsc->u.Backup.fHandleIsValid)
            {
                HrRBackupClose(cxh);
            }
    
            //
            //  Tell JET we're done doing the backup.
            //
    
            if (pjsc->u.Backup.fBackupIsRegistered)
            {
                JetEndExternalBackup();
            }

            if (pjsc->u.Backup.wszBackupAnnotation)
            {
                MIDL_user_free(pjsc->u.Backup.wszBackupAnnotation);
                pjsc->u.Backup.wszBackupAnnotation = NULL;
            }

            if (pjsc->u.Backup.fUseSharedMemory)
            {
                CloseSharedControl(&pjsc->u.Backup.jsc);
            }

#ifdef  DEBUG
            UninitializeTraceLog();
#endif
        }

    }

    return(hrNone);
}

BFT
BftClassify(
    WSZ wszFileName,
    WSZ wszDatabaseLocations,
    CB cbLocations
    )
{
    BFT bft = BFT_UNKNOWN;
    WCHAR rgwcPath[ _MAX_PATH ];
    WCHAR rgwcExt[ _MAX_EXT ];
    WSZ wszT;

    _wsplitpath(wszFileName, NULL, rgwcPath, NULL, rgwcExt);

    //
    //  Do the easy cases first.
    //

    if (_wcsicmp(rgwcExt, L".PAT") == 0)
    {
        return BFT_PATCH_FILE;
    }
    else if (_wcsicmp(rgwcExt, L".LOG") == 0)
    {
        return BFT_LOG;
    }
    else if (_wcsicmp(rgwcExt, L".DIT") == 0)
    {
        //
        //  This guy's a database.  We need to look and find out which database
        //  it is.
        //

        wszT = wszDatabaseLocations;
        bft = *wszT++;
        while (*wszT)
        {
            if ((bft & BFT_DATABASE_DIRECTORY) &&
                _wcsicmp(wszT, wszFileName)==0)
            {
                
                return bft;
            }
            wszT += wcslen(wszT)+1;
            bft = *wszT++;
        }
    }

    //
    //  Ok, I give up.  I don't know anything about this guy at all, so I need to
    //  try to figure out what I can tell the user about him.
    //

    wszT = wszDatabaseLocations;
    bft = *wszT++;

    rgwcPath[wcslen(rgwcPath)-1] = L'\0';

    while (*wszT)
    {
        if (bft & BFT_DIRECTORY)
        {
            //
            //  If the directory this file is in matches the directory I'm looking at,
            //  I know where it needs to go on the restore.
            //

            if (_wcsicmp(wszT, rgwcPath) == 0)
            {
                return bft;
            }
        }

        wszT += wcslen(wszT)+1;
        bft = *wszT++;
    }

    return BFT_UNKNOWN;
}

HRESULT
HrAnnotateMungedFileList(
    PJETBACK_SERVER_CONTEXT pjsc,
    WSZ wszFileList,
    CB cbFileList,
    WSZ *pwszAnnotatedList,
    CB *pcbAnnotatedList
    )
{
    HRESULT hr;
    WSZ wszDatabaseLocations = NULL;
    WSZ wszAnnotatedList = NULL;
    CB cbLocations;
    WSZ wszT;
    C cFileList = 0;

    hr = HrGetDatabaseLocations(&wszDatabaseLocations, &cbLocations);

    if (hr != hrNone)
    {
        return hr;
    }

    //
    //  First figure out how long the file list is.  This indicates how many items we've got to add to the list.
    //

    wszT = wszFileList;
    while (*wszT)
    {
        cFileList += 1;
        wszT += wcslen(wszT)+1;
    }

    *pcbAnnotatedList = cbFileList+cFileList*sizeof(WCHAR);

    *pwszAnnotatedList = wszAnnotatedList = MIDL_user_allocate( *pcbAnnotatedList );

    if (*pwszAnnotatedList == NULL)
    {
        MIDL_user_free(wszDatabaseLocations);
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
    }

    wszT = wszFileList;
    while (*wszT)
    {
        *wszAnnotatedList++ = BftClassify(wszT, wszDatabaseLocations, cbLocations);
        wcscpy(wszAnnotatedList, wszT);

        wszT += wcslen(wszT)+1;
        wszAnnotatedList += wcslen(wszAnnotatedList)+1;
    }

    MIDL_user_free(wszDatabaseLocations);

    return hrNone;
}

HRESULT
HrMungedFileNamesFromJetFileNames(
    WSZ *pszMungedList,
    CB *pcbSize,
    SZ szJetFileNameList,
    CB cbJetSize,
    BOOL fAnnotated
    )
/*++

Routine Description:

    This routine will convert the database names returned from JET into a form
    that the client can use.  This is primarily there for restore - the client
    will get the names in UNC format relative to the root of the server, so they
    can restore the files to that location.
    
Arguments:
    pszMungedList - The resulting munged list.
    pcbSize - the length of the list.
    szJetFileNameList - the list of files returned from JET.
    cbJetSize - the length of the JET list.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

--*/
{
    SZ szJetString;
    WSZ wszMungedList;
    CCH cchMungeString = 0;
    HRESULT hr = hrNone;

    szJetString = szJetFileNameList;

    //
    //  First go through and figure out how large the converted strings will be.
    //

    while (*szJetString != '\0')
    {
        WSZ wszMungedName;

        if (fAnnotated)
        {
            szJetString++;
        }

        hr = HrMungedFileNameFromJetFileName(szJetString, &wszMungedName);

        if (hr != hrNone)
        {
            return(hr);
        }

        cchMungeString += wcslen(wszMungedName)+1+(fAnnotated != 0);

        MIDL_user_free(wszMungedName);

        szJetString += strlen(szJetString)+1;
    }

    //
    //  Account for the final null at the end of the string.
    //

    cchMungeString += 1;

    *pcbSize = cchMungeString*sizeof(WCHAR);

    wszMungedList = MIDL_user_allocate(cchMungeString*sizeof(WCHAR));

    *pszMungedList = wszMungedList;

    if (wszMungedList == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    szJetString = szJetFileNameList;

    //
    //  Now actually go through and convert the names.
    //

    while (*szJetString != '\0')
    {
        WSZ wszMungedName;

        //
        //  Copy over the annotation.
        //

        if (fAnnotated)
        {
            *wszMungedList++ = (*szJetString++ & 0xFF);
        }
    
        hr = HrMungedFileNameFromJetFileName(szJetString, &wszMungedName);

        if (hr != hrNone)
        {
            MIDL_user_free(wszMungedList);

            *pszMungedList = NULL;
            return(hr);
        }

        wcscpy(wszMungedList, wszMungedName);

        MIDL_user_free(wszMungedName);

        szJetString += strlen(szJetString)+1;

        wszMungedList += wcslen(wszMungedList)+1;

    }
    
    return(hrNone);
}

HRESULT
HrMungedFileNameFromJetFileName(
    SZ szJetFileName,
    WSZ *pszMungedFileName
    )
/*++

Routine Description:

    This routine will convert the database names returned from JET into a form
    that the client can use.  This is primarily there for restore - the client
    will get the names in UNC format relative to the root of the server, so they
    can restore the files to that location.
    

Arguments:
    pszMungedFileName - the list of files returned from JET.
    szJetFileName - The resulting munged list.

Return Value:

    HRESULT - Status of operation.  hrNone if successful, reasonable value if not.

Note:
    This routine will allocate memory for the returned munged file name.

--*/
{
    //
    //  First check to see if this is a JET absolute file name or a JET relative file name.
    //
    if (FIsAbsoluteFileName(szJetFileName))
    {
        C cbConvertedName;
        WSZ wszMungedFileName;
        WSZ szT;
        //
        //  Convert this name to an absolute name.
        //
        cbConvertedName = strlen(szJetFileName) + wcslen(rgchComputerName) + 3/* for \\ */ + 1;

        wszMungedFileName = MIDL_user_allocate(cbConvertedName*sizeof(WCHAR));

        if (wszMungedFileName == NULL)
        {
            return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        }

        wszMungedFileName[0] = TEXT('\\');
        wszMungedFileName[1] = TEXT('\\');  //  form \\.
        wcscat(wszMungedFileName, rgchComputerName);        // form \\server

        szT = wszMungedFileName + wcslen(wszMungedFileName);
        *szT++ = TEXT('\\');                //  form \\server\.
        *szT++ = *szJetFileName;    //  form \\server\<drive>
        *szT++ = '$';               //  Form \\server\<drive>$

        if (MultiByteToWideChar(CP_ACP, 0, &szJetFileName[2], -1, szT, cbConvertedName-wcslen(rgchComputerName) - 3) == 0) {
            MIDL_user_free(wszMungedFileName);
            return(GetLastError());
        }
        
        *pszMungedFileName = wszMungedFileName;

        return(hrNone);
    }
    else
    {
        //
        //  We don't handle relative file names.
        //
        return(ERROR_INVALID_PARAMETER);
    }
}

BOOL
FIsAbsoluteFileName(
    SZ szFileName
    )
/*++

Routine Description:

        

Arguments:
    szFileName - the file name to check.

Return Value:

    BOOL - fTrue if the file is an absolute filename, fFalse if not.

--*/
{
    return(isalpha(*szFileName) && szFileName[1] == ':' && szFileName[2] == '\\');
}


//
//  RPC related management routines.
//

void
CXH_rundown(
    CXH cxh
    )
/*++

Routine Description:

    This routine is invoked when the connection to the remote client is abortively
    disconnected.

Arguments:

    cxh - The context handle for the client.

Return Value:

    None.

--*/
{
    HrDestroyCxh(cxh);

    //
    //  Free up the context handle
    //

    MIDL_user_free(cxh);
}

BOOL
DllEntryPoint(
    HINSTANCE hinstDll,
    DWORD dwReason,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.

Arguments:

    hinstDll - an instance handle for the DLL.
    dwReason - The reason the routine was called.
    pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

    BOOL - fTrue if the DLL initialization was successful, fFalse if not.

--*/
{
    BOOL fReturn;
    HANDLE hevLogging;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    {
        LPSTR rgpszDebugParams[] = {"ntdsbsrv.dll", "-noconsole"};
        DWORD cNumDebugParams = sizeof(rgpszDebugParams)/sizeof(rgpszDebugParams[0]);
        CB cbComputerName = sizeof(rgchComputerName)/sizeof(rgchComputerName[0]);

        DEBUGINIT(cNumDebugParams, rgpszDebugParams, "ntdsbsrv");

        if (!FInitializeRestore())
        {
            return(fFalse);
        }

        if (!GetComputerNameW(rgchComputerName, &cbComputerName))
        {
            FUninitializeRestore();
            return(fFalse);
        }

        // Note that the reason we don't use the shared event initialization mechanism
        // (DS_EVENT_CONFIG, see dsevent.h) is that ntdsa.dll is not always initialized
        // when we are.
        hevLogging = LoadEventTable();
        if (hevLogging == NULL) {
            DPRINT( 0, "Failed to load event table.\n" );
        }

        //
        //  We don't do anything on thread attach/detach, so we don't
        //  need to be called.
        //
        DisableThreadLibraryCalls(hinstDll);

        return(FInitializeSocketServer());

    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        Assert(fFalse);
        break;
    case DLL_PROCESS_DETACH:
        if (pvReserved == NULL)
        {
            //
            //  We were called because of an FreeLibrary call.  Clean up what ever is
            //  appropriate.
            //
            FUninitializeSocketServer();
        } else
        {
            //
            //  The system will free up resources we have loaded.
            //
        }

        fReturn = FUninitializeRestore();
        if (!fReturn)
        {
            return(fFalse);
        }

        //
        //  We want to unregister ourselves if we haven't already.
        //

        if (fBackupRegistered)
        {
            HrBackupUnregister();
        }

        UnloadEventTable();

        DEBUGTERM();
        
        break;
    default:
        break;
    }
    return(fTrue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\jetback\jetback\jetrest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       jetrest.c
//
//--------------------------------------------------------------------------

/*
 *  JETREST.C
 *  
 *  JET restore API support.
 *  
 *  
 */
#define UNICODE

#include <windows.h>
#include <mxsutil.h>
#include <ntdsbcli.h>
#include <jetbp.h>
#include <ntdsbsrv.h>
#include <rpc.h>
#include <dsconfig.h>
#include <safeboot.h>
#include <mdcodes.h>
#include <usn.h>

#include <stdlib.h>
#include <stdio.h>

#include "local.h"  // common functions shared by client and server
#include "snapshot.hxx"

#define RESTORE_MARKER_FILE_NAME L"restore.mrk"

BOOL
fRestoreRegistered = fFalse;

BOOL
fSnapshotRegistered = fFalse;

BOOL
fRestoreInProgress = fFalse;

extern BOOL g_fBootedOffNTDS;

// proto-types
EC EcDsarPerformRestore(
    SZ szLogPath,
    SZ szBackupLogPath,
    C crstmap,
    JET_RSTMAP rgrstmap[]
    );

EC EcDsaQueryDatabaseLocations(
    SZ szDatabaseLocation,
    CB *pcbDatabaseLocationSize,
    SZ szRegistryBase,
    CB cbRegistryBase,
    BOOL *pfCircularLogging
    );

HRESULT
HrGetDatabaseLocations(
    WSZ *pwszDatabases,
    CB *pcbDatabases
    );


/*
 -  HrRIsNTDSOnline
 *
 *  Purpose:
 *  
 *      This routine tells if the NT Directory Service is Online or not.
 *
 *  Parameters:
 *      hBinding - An RPC binding handle for the operation - ignored.
 *      pfDSOnline - Boolean that receives TRUE if the DS is online; FALSE
 *                   otherwise.store target to restore.
 *  Returns:
 *      HRESULT - status of operation. hrNone if successful; error code if not.
 *
 */
HRESULT HrRIsNTDSOnline(handle_t hBinding, BOOLEAN *pfDSOnline)
{
    HRESULT hr = hrNone;

    *pfDSOnline = (BOOLEAN) g_fBootedOffNTDS;

    return hr;
}

/*
 -  HrRRestorePrepare
 *
 *  Purpose:
 *  
 *      This routine will prepare the server and client for a restore operation.
 *      It will allocate the server side context block and will locate an appropriate
 *      restore target for this restore operation.
 *
 *  Parameters:
 *      hBinding - An RPC binding handle for the operation - ignored.
 *      szEndpointAnnotation - An annotation for the endpoint.  A client can use this
 *          annotation to determine which restore target to restore.
 *      pcxh - The RPC context handle for the operation.
 *
 *  Returns:
 *      EC - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */
HRESULT HrRRestorePrepare(
    handle_t hBinding,
    WSZ wszDatabaseName,
    CXH *pcxh)
{
    PJETBACK_SERVER_CONTEXT pjsc = NULL;
    HRESULT hr;

    if (!FBackupServerAccessCheck(fTrue))
    {
        DebugTrace(("HrrRestorePrepare: Returns ACCESS_DENIED\n"));
        return(ERROR_ACCESS_DENIED);
    }


    if (fRestoreInProgress)
    {
        return(hrRestoreInProgress);
    }

    pjsc = MIDL_user_allocate(sizeof(JETBACK_SERVER_CONTEXT));

    if (pjsc == NULL)
    {
        return(ERROR_NOT_ENOUGH_SERVER_MEMORY);
    }

    pjsc->fRestoreOperation = fTrue;

    fRestoreInProgress = fTrue;

    *pcxh = (CXH)pjsc;

    return(hrNone);
}


/*
 -  HrRRestore
 *
 *  Purpose:
 *  
 *      This routine actually processes the restore operation.
 *
 *  Parameters:
 *
 *      cxh                     - The RPC context handle for this operation
 *      szCheckpointFilePath    - Checkpoint directory location.
 *      szLogPath               - New log path
 *      rgrstmap                - Mapping from old DB locations to new DB locations
 *      crstmap                 - Number of entries in rgrstmap
 *      szBackupLogPath         - Log path at the time of backup.
 *      genLow                  - Low log #
 *      genHigh                 - High log # (logs between genLow and genHigh must exist)
 *      pfRecoverJetDatabase    - IN/OUT - on IN, indicates if we are supposed to use JET to recover
 *                                  the DB.  on OUT, indicates if we successfully recovered the JET database.
 *
 *  Returns:
 *
 *      EC - Status of operation.  ecNone if successful, reasonable value if not.
 *
 */

HRESULT HrRRestore(
    CXH cxh,
    WSZ szCheckpointFilePath,
    WSZ szLogPath,
    EDB_RSTMAPW __RPC_FAR rgrstmap[  ],
    C crstmap,
    WSZ szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh,
    BOOLEAN *pfRecoverJetDatabase
    )
{
    return hrNone;
}

HRESULT HrRestoreLocal(
    WSZ szCheckpointFilePath,
    WSZ szLogPath,
    EDB_RSTMAPW __RPC_FAR rgrstmap[  ],
    C crstmap,
    WSZ szBackupLogPath,
    unsigned long genLow,
    unsigned long genHigh,
    BOOLEAN *pfRecoverJetDatabase
    )
{
    HRESULT hr = hrNone;
    SZ szUnmungedCheckpointFilePath = NULL;
    SZ szUnmungedLogPath = NULL;
    SZ szUnmungedBackupLogPath = NULL;
    JET_RSTMAP *rgunmungedrstmap = NULL;
    DWORD err; //delete me

    __try {
        if (szCheckpointFilePath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szCheckpointFilePath, &szUnmungedCheckpointFilePath);
        }

        if (hr != hrNone) {
            __leave;
        }

        if (szLogPath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szLogPath, &szUnmungedLogPath);
        }

        if (hr != hrNone) {
            __leave;
        }

        if (szBackupLogPath != NULL)
        {
            hr = HrJetFileNameFromMungedFileName(szBackupLogPath, &szUnmungedBackupLogPath);
        }

        if (hr != hrNone) {
            __leave;
        }

        //
        //  Now unmunge the restoremap....
        //

        if (crstmap)
        {
            I irgunmungedrstmap;
            rgunmungedrstmap = MIDL_user_allocate(sizeof(JET_RSTMAP)*crstmap);
            if (rgunmungedrstmap == NULL)
            {
                hr = ERROR_NOT_ENOUGH_SERVER_MEMORY;
                __leave;
            }

            for (irgunmungedrstmap = 0; irgunmungedrstmap < crstmap ; irgunmungedrstmap += 1)
            {
                hr = HrJetFileNameFromMungedFileName(rgrstmap[irgunmungedrstmap].wszDatabaseName,
                                                    &rgunmungedrstmap[irgunmungedrstmap].szDatabaseName);

                if (hr != hrNone) {
                    __leave;
                }

                hr = HrJetFileNameFromMungedFileName(rgrstmap[irgunmungedrstmap].wszNewDatabaseName,
                                                    &rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName);

                if (hr != hrNone) {
                    __leave;
                }
            }
        }

        //
        //  We've now munged our incoming parameters into a form that JET can deal with.
        //
        //  Now call into JET to let it munge the databases.
        //
        //  Note that the JET interpretation of LogPath and BackupLogPath is totally
        //  wierd, and we want to pass in LogPath to both parameters.
        //

        if (!*pfRecoverJetDatabase)
        {
            err = JetExternalRestore(szUnmungedCheckpointFilePath,
                                    szUnmungedLogPath,  
                                    rgunmungedrstmap,
                                    crstmap,
                                    szUnmungedLogPath,
                                    genLow,
                                    genHigh,
                                    NULL);

            hr = HrFromJetErr(err);
            if (hr != hrNone) {
                __leave;
            }
        }

        //
        //  Ok, we were able to recover the database.  Let the other side of the API know about it
        //  so it can do something "reasonable".
        //

        *pfRecoverJetDatabase = fTrue;


        //
        //  Mark the DS as a restored version
        //  [Add any external notification here.]
        //

        hr = EcDsarPerformRestore(szUnmungedLogPath,
                                                szUnmungedBackupLogPath,
                                                crstmap,
                                                rgunmungedrstmap
                                                );

    }
    __finally
    {
        if (szUnmungedCheckpointFilePath)
        {
            MIDL_user_free(szUnmungedCheckpointFilePath);
        }
        if (szUnmungedLogPath)
        {
            MIDL_user_free(szUnmungedLogPath);
        }
        if (szUnmungedBackupLogPath)
        {
            MIDL_user_free(szUnmungedBackupLogPath);
        }
        if (rgunmungedrstmap != NULL)
        {
            I irgunmungedrstmap;
            for (irgunmungedrstmap = 0; irgunmungedrstmap < crstmap ; irgunmungedrstmap += 1)
            {
                if (rgunmungedrstmap[irgunmungedrstmap].szDatabaseName)
                {
                    MIDL_user_free(rgunmungedrstmap[irgunmungedrstmap].szDatabaseName);
                }

                if (rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName)
                {
                    MIDL_user_free(rgunmungedrstmap[irgunmungedrstmap].szNewDatabaseName);
                }
            }

            MIDL_user_free(rgunmungedrstmap);
        }
    }

    return(hr);

}

HRESULT
HrGetRegistryBase(
    IN PJETBACK_SERVER_CONTEXT pjsc,
    OUT WSZ wszRegistryPath,
    OUT WSZ wszKeyName
    )
{
    return HrLocalGetRegistryBase( wszRegistryPath, wszKeyName );
}

HRESULT
HrRRestoreRegister(CXH cxh,
                    WSZ wszCheckpointFilePath,
                    WSZ wszLogPath,
                    EDB_RSTMAPW rgrstmap[],
                    C crstmap,
                    WSZ wszBackupLogPath,
                    ULONG genLow,
                    ULONG genHigh)
{
    HRESULT hr = hrNone;

    hr = HrLocalRestoreRegister(
            wszCheckpointFilePath,
            wszLogPath,
            rgrstmap,
            crstmap,
            wszBackupLogPath,
            genLow,
            genHigh
            );

    return hr;
}

HRESULT
HrRRestoreRegisterComplete(CXH cxh,
                    HRESULT hrRestore )
{
    HRESULT hr = hrNone;
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT )cxh;
    
    if (pjsc != NULL)
    {
        hr = HrLocalRestoreRegisterComplete( hrRestore );
    }

    return hr;
}

HRESULT
HrRRestoreGetDatabaseLocations(
    CXH cxh,
    char **pszDatabaseLocations,
    C *pcbSize
    )
{
    *pszDatabaseLocations = NULL;
    *pcbSize = 0;

    if (!cxh)
    {
        return hrNone;
    }

    return HrGetDatabaseLocations((WSZ *)pszDatabaseLocations, pcbSize);
}



HRESULT
HrRRestoreEnd(
    CXH *pcxh)
{
    PJETBACK_SERVER_CONTEXT pjsc = (PJETBACK_SERVER_CONTEXT)*pcxh;
    fRestoreInProgress = fFalse;

    RestoreRundown(pjsc);

    MIDL_user_free(*pcxh);

    *pcxh = NULL;

    return(hrNone);
}

/*
 -  HrRRestoreCheckLogsForBackup
 -
 *
 *  Purpose:
 *      This routine checks to verify
 *
 *  Parameters:
 *      hBinding - binding handle (ignored)
 *      wszAnnotation - Annotation for service to check.
 *
 *  Returns:
 *      hrNone if it's ok to start the backup, an error otherwise.
 *
 */
HRESULT
HrRRestoreCheckLogsForBackup(
    handle_t hBinding,
    WSZ wszBackupAnnotation
    )
{
    HRESULT hr;
    PRESTORE_DATABASE_LOCATIONS prqdl;
    HINSTANCE hinstDll;
    WCHAR   rgwcRegistryBuffer[ MAX_PATH ];
    CHAR    rgchInterestingComponentBuffer[ MAX_PATH * 4];
    CHAR    rgchMaxLogFilename[ MAX_PATH ];
    SZ      szLogDirectory = NULL;
    HKEY    hkey;
    DWORD   dwCurrentLogNumber;
    DWORD   dwType;
    DWORD   cbLogNumber;
    DWORD   cbInterestingBuffer;
    BOOL    fCircularLogging;

    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    //  First check to see if we know what the last log was.
    //

    _snwprintf(rgwcRegistryBuffer,
               sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
               L"%ls%ls",
               BACKUP_INFO,
               wszBackupAnnotation);

    if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, KEY_READ, &hkey))
    {
        //
        //  If we can't find the registry key, this means that we've never done a full backup.
        //
        if (hr == ERROR_FILE_NOT_FOUND)
        {
            return(hrFullBackupNotTaken);
        }

        return(hr);
    }

    dwType = REG_DWORD;
    cbLogNumber = sizeof(DWORD);
    hr = RegQueryValueExW(hkey, LAST_BACKUP_LOG, 0, &dwType, (LPBYTE)&dwCurrentLogNumber, &cbLogNumber);

    if (hr != hrNone)
    {
        RegCloseKey(hkey);
        return hrNone;
    }

    if (dwCurrentLogNumber == BACKUP_DISABLE_INCREMENTAL)
    {
        RegCloseKey(hkey);
        return hrIncrementalBackupDisabled;
    }

    //
    //  We now know the last log number, we backed up, check to see if the next
    //  log is there.
    //

    hr = EcDsaQueryDatabaseLocations(rgchInterestingComponentBuffer, &cbInterestingBuffer, NULL, 0, &fCircularLogging);

    if (hr != hrNone)
    {
        RegCloseKey(hkey);
        return hr;
    }

    //
    //  This is a bit late to figure this out, but it's the first time we
    //  have an opportunity to look for circular logging.
    //
    if (fCircularLogging)
    {
        RegCloseKey(hkey);
        return hrCircularLogging;
    }

    //
    //  The log path is the 2nd path in the buffer returned (the 1st is the system database directory).
    //

    // Temp:
    // #22467:  Restore.cxx was changed in #20416, and some special characters are put in the path.
    //          So here I am advancing by one more byte to accomodate the change in restore.cxx.
    //          The change is only temporary.
    
    szLogDirectory = &rgchInterestingComponentBuffer[strlen(rgchInterestingComponentBuffer)+2];

    Assert(szLogDirectory+MAX_PATH < rgchInterestingComponentBuffer+sizeof(rgchInterestingComponentBuffer));

    sprintf(rgchMaxLogFilename, "%s\\EDB%-5.5x.LOG", szLogDirectory, dwCurrentLogNumber);

    if (GetFileAttributesA(rgchMaxLogFilename) == -1)
    {
        hr = hrLogFileNotFound;
    }

    RegCloseKey(hkey);
    return hr;
}

/*
 -  HrRRestoreSetCurrentLogNumber
 -
 *
 *  Purpose:
 *      This routine checks to verify
 *
 *  Parameters:
 *      hBinding - binding handle (ignored)
 *      wszAnnotation - Annotation for service to check.
 *      dwNewCurrentLog - New current log number
 *
 *  Returns:
 *      hrNone if it's ok to start the backup, an error otherwise.
 *
 */
HRESULT
HrRRestoreSetCurrentLogNumber(
    handle_t hBinding,
    WSZ wszBackupAnnotation,
    DWORD dwNewCurrentLog
    )
{
    HRESULT hr;
    WCHAR   rgwcRegistryBuffer[ MAX_PATH ];
    HKEY hkey;

    if (NULL == wszBackupAnnotation) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    //
    //  First check to see if we know what the last log was.
    //

    _snwprintf(rgwcRegistryBuffer,
               sizeof(rgwcRegistryBuffer)/sizeof(rgwcRegistryBuffer[0]),
               L"%ls%ls",
               BACKUP_INFO,
               wszBackupAnnotation);

    if (hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, rgwcRegistryBuffer, 0, KEY_WRITE, &hkey))
    {
        //
        //  We want to ignore file_not_found - it is ok.
        //
        if (hr == ERROR_FILE_NOT_FOUND)
        {
            return(hrNone);
        }

        return(hr);
    }

    hr = RegSetValueExW(hkey, LAST_BACKUP_LOG, 0, REG_DWORD, (LPBYTE)&dwNewCurrentLog, sizeof(DWORD));

    RegCloseKey(hkey);

    return hr;
}


/*
 -  ErrRestoreRegister
 *
 *  Purpose:
 *  
 *      This routine to register a process for restore.  It is called by either the store or DS.
 *
 *  Parameters:
 *
 *
 *  Returns:
 *
 *      EC - Status of operation.  hrNone if successful, reasonable value if not.
 *
 */

DWORD
ErrRestoreRegister()
{
    DWORD err = 0;

    if (!fRestoreRegistered) {
        err = RegisterRpcInterface(JetRest_ServerIfHandle, g_wszRestoreAnnotation);
        if (!err) {
            fRestoreRegistered = fTrue;
        }
    }

    if (!fSnapshotRegistered) {
        err = DsSnapshotRegister();
        if (!err) {
            fSnapshotRegistered = fTrue;
        }
    }
    return(err);
}

/*
 -  ErrRestoreUnregister
 -  
 *  Purpose:
 *
 *  This routine will unregister a process for restore.  It is called by either the store or DS.
 *
 *  Parameters:
 *      szEndpointAnnotation - the endpoint we are going to unregister.
 *
 *  Returns:
 *
 *      ERR - Status of operation.  ERROR_SUCCESS if successful, reasonable value if not.
 *
 */


DWORD
ErrRestoreUnregister()
{
    return(ERROR_SUCCESS);
}

BOOL
FInitializeRestore(
    VOID
    )
/*
 -  FInitializeRestore
 -  
 *
 *  Purpose:
 *      This routine initializes the global variables used for the JET restore DLL.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      BOOL - false if uninitialize fails
 */

{
    return(fTrue);
}

BOOL
FUninitializeRestore(
    VOID
    )
/*
 -  FUninitializeRestore
 -  
 *
 *  Purpose:
 *      This routine cleans up all the global variables used for the JET restore DLL.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      BOOL - false if uninitialize fails
 */

{
    BOOL ok1 = TRUE, ok2 = TRUE;

    // Initiate shutdown proceedings in parallel
    if (fSnapshotRegistered) {
        (void) DsSnapshotShutdownTrigger();
    }

    if (fRestoreRegistered) {
        ok1 = (ERROR_SUCCESS == UnregisterRpcInterface(JetRest_ServerIfHandle));

        if (ok1) {
            fRestoreRegistered = FALSE;
        }
    }

    if (fSnapshotRegistered) {
        ok2 = (ERROR_SUCCESS == DsSnapshotShutdownWait());

        if (ok2) {
            fSnapshotRegistered = FALSE;
        }
    }

    return ok1 && ok2;
}

/*
 -  RestoreRundown
 -  
 *
 *  Purpose:
 *      This routine will perform any and all rundown operations needed for the restore.
 *
 *  Parameters:
 *      pjsc - Jet backup/restore server context
 *
 *  Returns:
 *      None.
 */
VOID
RestoreRundown(
    PJETBACK_SERVER_CONTEXT pjsc
    )
{
    Assert(pjsc->fRestoreOperation);

    fRestoreInProgress = fFalse;

    return;
}

DWORD
AdjustBackupRestorePrivilege(
    BOOL fEnable,
    BOOL fRestoreOperation,
    PTOKEN_PRIVILEGES ptpPrevious,
    DWORD *pcbptpPrevious
    )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tpNew;
    DWORD err;
    //
    //  Open either the thread or process token for this process.
    //

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, fTrue, &hToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
            return(GetLastError());
        }
    }

    if (fEnable)
    {
        LUID luid;
        tpNew.PrivilegeCount = 1;
    
        if (!LookupPrivilegeValue(NULL, fRestoreOperation ? SE_RESTORE_NAME : SE_BACKUP_NAME, &luid)) {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    
        tpNew.Privileges[0].Luid = luid;
        tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    
        if (!AdjustTokenPrivileges(hToken, fFalse, &tpNew, sizeof(tpNew), ptpPrevious, pcbptpPrevious))
        {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    }
    else
    {
        if (!AdjustTokenPrivileges(hToken, fFalse, ptpPrevious, *pcbptpPrevious, NULL, NULL))
        {
            err = GetLastError();
            CloseHandle(hToken);
            return(err);
        }
    }

    CloseHandle(hToken);

    return(ERROR_SUCCESS);
}


/*
 -	FIsBackupPrivilegeEnabled
 -
 *	Purpose:
 *		Determines if the client process is in the backup operators group.
 *
 *              Note: we should be impersonating the client at this point
 *
 *	Parameters:
 *		None.
 *
 *	Returns:
 *		fTrue if client can legally back up the machine.
 *
 */
BOOL
FIsBackupPrivilegeEnabled(
    BOOL fRestoreOperation)
{
    HANDLE hToken;
    PRIVILEGE_SET psPrivileges;
    BOOL fGranted, fHeld = FALSE;
    LUID luid;
    CHAR buffer[1024];
    PTOKEN_PRIVILEGES ptpTokenPrivileges = (PTOKEN_PRIVILEGES) buffer;
    DWORD returnLength, i, oldAttributes = 0;

    //
    //	Open either the thread or process token for this process.
    //

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, fTrue, &hToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            return(fFalse);
        }
    }

    Assert(ANYSIZE_ARRAY >= 1);

    // Look up privilege value

    psPrivileges.PrivilegeCount = 1;	//	We only have 1 privilege to check.
    psPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;	// And it must be set.

    if (!LookupPrivilegeValue(NULL, (fRestoreOperation ? SE_RESTORE_NAME : SE_BACKUP_NAME),&luid)) {
        fGranted = fFalse;
        goto cleanup;
    }

    // Get current privileges

    if (!GetTokenInformation( hToken,
                              TokenPrivileges,
                              ptpTokenPrivileges,
                              sizeof( buffer ),
                              &returnLength )) {
        DebugTrace(("GetTokenInfo failed with error %d\n", GetLastError()));
        fGranted = fFalse;
        goto cleanup;
    }

    // See if held

    for( i = 0; i < ptpTokenPrivileges->PrivilegeCount; i++ ) {
        LUID_AND_ATTRIBUTES *laaPrivilege =
            &(ptpTokenPrivileges->Privileges[i]);
        if (memcmp( &luid, &(laaPrivilege->Luid), sizeof(LUID) ) == 0 ) {
            oldAttributes = laaPrivilege->Attributes;
            fHeld = TRUE;
            break;
        }
    }
    if (!fHeld) {
        DebugTrace(("Token does not hold privilege, fRest=%d\n",
                    fRestoreOperation ));
        fGranted = fFalse;
        goto cleanup;
    }

    DebugTrace(("FIsBackupPrivilegeEnabled, fRest=%d, attrib